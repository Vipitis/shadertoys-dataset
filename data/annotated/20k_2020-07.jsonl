{"id": "3l2cD3", "name": "correct perlin noise in 3d", "author": "CoolerZ", "description": "Correct implementation of perlin noise in 3d.", "tags": ["noise", "perlin"], "likes": 5, "viewed": 81, "published": "Public", "date": "1595553375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nBased on http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\nThe pdf gives details and code for both perlin and simplex noise in Java.\n*/\n#define A .5\n#define F 1.\n\nconst vec3[] grad = vec3[](\n    vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n\tvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n\tvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1)\n);\n\nconst int perm[] = int[](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\nvec3 fade(vec3 x)\n{\n    return x*x*x*(x*(x*6.-15.)+10.);\n}\n\nint hash(ivec3 XYZ)\n{\n    return perm[XYZ.x+perm[XYZ.y+perm[XYZ.z]]]%12;\n}\n\nfloat perlin3d(vec3 xyz)\n{\n    ivec3 XYZ = ivec3(floor(xyz)) & 0xFF;\n    xyz = fract(xyz);\n\n    int gi000 = hash(XYZ);\n    int gi001 = hash(XYZ + ivec3(0,0,1));\n    int gi010 = hash(XYZ + ivec3(0,1,0));\n    int gi011 = hash(XYZ + ivec3(0,1,1));\n    int gi100 = hash(XYZ + ivec3(1,0,0));\n    int gi101 = hash(XYZ + ivec3(1,0,1));\n    int gi110 = hash(XYZ + ivec3(1,1,0));\n    int gi111 = hash(XYZ + ivec3(1,1,1));\n\n    float n000 = dot(grad[gi000],xyz);\n    float n001 = dot(grad[gi001],xyz+vec3( 0., 0.,-1.));\n    float n010 = dot(grad[gi010],xyz+vec3( 0.,-1., 0.));\n    float n011 = dot(grad[gi011],xyz+vec3( 0.,-1.,-1.));\n    float n100 = dot(grad[gi100],xyz+vec3(-1., 0., 0.));\n    float n101 = dot(grad[gi101],xyz+vec3(-1., 0.,-1.));\n    float n110 = dot(grad[gi110],xyz+vec3(-1.,-1., 0.));\n    float n111 = dot(grad[gi111],xyz+vec3(-1.,-1.,-1.));\n\n    vec3 uvw = fade(xyz);\n\n    float nx00 = mix(n000, n100, uvw.x);\n    float nx01 = mix(n001, n101, uvw.x);\n    float nx10 = mix(n010, n110, uvw.x);\n    float nx11 = mix(n011, n111, uvw.x);\n\n    float nxy0 = mix(nx00, nx10, uvw.y);\n    float nxy1 = mix(nx01, nx11, uvw.y);\n\n    return mix(nxy0, nxy1, uvw.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 pos = vec3(uv*8., iTime);\n    // vec3 col = vec3(perlin3d(pos));\n\n    float x0 = A*perlin3d(pos*F);\n    float x1 = A*A*perlin3d(pos*F*2.);\n    float x2 = A*A*A*perlin3d(pos*F*4.);\n    float x3 = A*A*A*A*perlin3d(pos*F*8.);\n    float x4 = A*A*A*A*A*perlin3d(pos*F*16.);\n\n    vec3 col = vec3(4.*(x0 + x1 + x2 + x3 + x4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2232, 2232, 2251, 2251, 2290], [2292, 2292, 2313, 2313, 2366], [2368, 2368, 2394, 2394, 3532], [3534, 3534, 3591, 3591, 4064]], "test": "error"}
{"id": "3l2cDd", "name": "Jungle2", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 94, "published": "Public", "date": "1595744907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat hash(float x){\n    return fract(sin(x*234.123+156.2));\n}\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nfloat map(vec3 p){\n    vec2 id=floor(p.xz);\n    p.xz=mod(p.xz,1.)-.5;\n    p.y=abs(p.y)-.5;\n    p.y=abs(p.y)-.5;\n   \tp.xy*=rot(hash(dot(id,vec2(12.3,46.7))));\n    p.yz*=rot(hash(dot(id,vec2(32.9,76.2))));\n   \tfloat s = 1.;\n\tfor(int i = 0; i < 6; i++) {\n\t\tfloat r2=1.2/pow(lpNorm(p.xyz, 5.0),1.5);\n\t\tp-=.1;\n    \tp*=r2;\n    \ts*=r2;\n\t\tp=p-2.*round(p/2.);\n\t}\n\treturn .6*dot(abs(p),normalize(vec3(1,2,3)))/s-.002;\n}\n\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<200;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 p,\n  \t\tro=vec3(2.-iTime*.2,1.8,-iTime*.3),\n  \t\tw=normalize(vec3(.0,-1.2,-1)),\n  \t\tu=normalize(cross(w,vec3(0,1,0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,1));\n    vec3 col;\n    vec3 bg=mix(vec3(.15,.05,.05),vec3(.1,.1,.4),uv.y*.5+.5);\n\tfloat maxd=20.0, t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(0.2,0.9,0.2)+cos(p*0.5)*0.5+0.5;\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(3);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.7,0.4,0.5)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n    }\n    col=mix(bg,col,exp(-t*.2));\n    fragColor.xyz = mix(bg,col,exp(-t*.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 71, 71, 113], [115, 115, 146, 146, 208], [210, 210, 228, 228, 619], [622, 622, 648, 648, 800], [802, 802, 856, 856, 1023], [1025, 1025, 1077, 1077, 1160], [1163, 1163, 1220, 1220, 2351]], "test": "valid"}
{"id": "3l2cDw", "name": "漫天星", "author": "gggab", "description": "满天都是小星星", "tags": ["2d"], "likes": 1, "viewed": 100, "published": "Public", "date": "1594547598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYER 10.\nmat2 Rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);\n    float m =.005/d;\n    \n    float rays =max(0., 1.-abs(uv.x*uv.y*300.));\n    m+=rays*flare;\n    \n    uv*=Rot(3.1415/4.);\n    rays =max(0., 1.-abs(uv.x*uv.y*300.));\n    m+=rays*.3*flare;\n    m*=smoothstep(.9,.2,d);\n    return m;\n}\nfloat Hash21(vec2 p){\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x + p.y);\n}\nvec3 StarLayer(vec2 uv, float t){\n    vec3 col=vec3(0);\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv)+.5;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 offs = vec2(x,y);        \n\n            float n = Hash21(id+offs);\n            float size = fract(n*345.2)*5.*(t*2.-n);\n            float star = Star(gv-offs+(vec2(n,fract(n*10.))-.5),.6);\n            vec3 color = vec3(.2,.9,1.);\n            color*=vec3(.0,1.,1.);\n            col+=star*size*color;\n        }\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime*.5;\n    uv*=2.;\n    \n    vec3 col = vec3(0);\n    \n    for(float i=0.;i<1.;i+=1./NUM_LAYER){\n        float depth = fract(i);\n        //float fade = depth*smoothstep(1.,.9,depth);\n        float scale = mix(20.,.5,depth);\n        \n    \tcol+=StarLayer(uv*scale+i*64.,sin(t)*.5+.5);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 106], [107, 107, 140, 140, 398], [399, 399, 420, 420, 518], [519, 519, 552, 552, 1039], [1040, 1040, 1097, 1097, 1491]], "test": "valid"}
{"id": "3l2cDz", "name": "strash. first shader", "author": "strash", "description": "ok", "tags": ["noise", "wave"], "likes": 1, "viewed": 43, "published": "Public", "date": "1594150107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = vec3(1.0);\n    col += sin(uv.x * 3.0 + cos(iTime / 100.0) * 300.0) + cos(uv.y * 12.0 + sin(iTime / 40.0) * 10.0);\n    col += sin(uv.x * 7.0 + sin(iTime / 100.0) * 20.0) + cos(uv.y * 20.0 + cos(iTime / 50.0) * 40.0);\n    col.x += sin(uv.y * 3.0 + sin(iTime / 40.0) * 16.0);\n    col.y += cos(uv.y * 23.0 + sin(iTime / 40.0) * 15.0);\n    col.z += sin(uv.y * 18.0 + sin(iTime / 40.0) * 14.0);\n    col = sin(col * 0.9) * 0.1 + sin(iTime * col) * 0.9;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 603]], "test": "valid"}
{"id": "3l2cRV", "name": "chrysalis 2", "author": "haptix", "description": "chrysalis 2", "tags": ["kif", "chrysalis"], "likes": 4, "viewed": 227, "published": "Public API", "date": "1594845854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 box(vec3 p, vec3 b, float matId)\n{\n    vec3 q = abs(p) - b;\n    return vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.), matId);\n}\n\nvec2 rBox(vec3 p, vec3 b, float r, float matId)\n{\n\tvec3 q = abs(p) - b;\n\treturn vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r, matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime + iDate.y;\n    \n    for(float i = 0.; i < 9.; i++)\n    {   \n        p.xy *= rot(.067*t);\n        \n        p = abs(p) - vec3(((sin(.02*t) + .5) * .011*cos(t*.07)) + ((cos(.013*t) + .5) * .011*sin(t*.07)) + .09,\n                          ((cos(.03*t) + .5) * .011*sin(t*.17)) + ((sin(.015*t) + .5) * .011*cos(t*.17)) + .05,\n                          ((cos(.05*t) + .5) * .011*sin(t*.27)) + ((sin(.017*t) + .5) * .011*cos(t*.27)) + .07);\n\n        p.zx *= rot(-.043*t);\n        \n        p = abs(p) - vec3(((cos(.03*t) + .5) * .011*sin(t*.19)) + ((sin(.015*t) + .5) * .011*cos(t*.19)) + .05,\n                          ((sin(.05*t) + .5) * .011*cos(t*.29)) + ((cos(.017*t) + .5) * .011*sin(t*.29)) + .09,\n                          ((sin(.02*t) + .5) * .011*cos(t*.09)) + ((cos(.013*t) + .5) * .011*sin(t*.09)) + .07);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    float rCorner = .002;\n    p = kif(p);\n    \n    vec2 m1 = rBox(p, vec3(.65, .06, .65), .015, 1.);\n    vec2 m2 = rBox(p, vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m3 = rBox(vec3(p.x - .05, p.yz), vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m4 = rBox(vec3(p.x + .05, p.yz), vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m5 = rBox(p, vec3(.08, .8, 1.), rCorner, 2.);\n    vec2 m6 = rBox(vec3(p.x - .25, p.yz), vec3(.06, .55, .45), .015, 1.);\n    vec2 m7 = rBox(vec3(p.x + .25, p.yz), vec3(.06, .55, .45), .015, 1.);\n    vec2 m = add(m1, m2);\n    m = add(add(add(add(add(add(m1, m2), m3), m4), m5), m6), m7);\n    glo += .1 / (.1 + m1.x*m1.x*m1.x);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 22.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .9;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.6*cos(-.1*iTime),\n                   .91*sin(-.1*iTime),\n                   -4.);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(2.5, 2.5, -20.);\n    vec3 lightPos2 = vec3(-2.5, -2.5, -20.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime)),\n                       cos(.151*(iTime)),\n                       cos(.227*(iTime))) + 1.2;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        vec3 lightDir2 = normalize(lightPos2 - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float spec2 = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n        \n        vec3 col = vec3(.1);\n        col *= .1 * ao;\n        \n        if(t.y == 1.)\n            colRot = vec3(.18);\n        else if (t.y == 3.)\n        {\n            col += glo*.02*colRot;\n        }    \n        else\n        {\n            colRot = colRot.yzx;\n            col += glo*.02*colRot;\n        }\n        \n        col += .3 * diff * colRot;\n        col += 1. * spec * vec3(0., .7, 1.);\n        col += 1. * spec2 * vec3(0., .7, 1.);\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*colRot.zxy*.02, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 61, 61, 121], [123, 123, 162, 162, 268], [270, 270, 319, 319, 423], [425, 425, 443, 443, 1306], [1308, 1308, 1336, 1336, 1372], [1374, 1374, 1392, 1392, 2063], [2065, 2065, 2092, 2092, 2324], [2326, 2326, 2383, 2383, 4318]], "test": "valid"}
{"id": "3l2cWd", "name": "Distance Practice", "author": "reatured", "description": "Learning Practice, shape, angle, and color and rotate.", "tags": ["learning"], "likes": 1, "viewed": 114, "published": "Public", "date": "1595725209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //float resize = 80./45.; //multiply to square\n    vec2 uv = fragCoord/iResolution.xy;\n    float screenRatio = iResolution.x/iResolution.y;\n    uv.x *= screenRatio;\n    //vec2 canvas =iResolution.xy;\n    //uv = vec2((uv.x * resize)-45./120., uv.y); //rescale canvas;\n       \n    //tile\n\t\n   \tvec2 center = vec2(0.5 * screenRatio, 0.5);\n    //uv *= tile( uv, 2.);\n    //rotate\n    \n    uv -= center;\n    uv = rotate2d( sin(iTime)*PI ) * uv;\n    uv += center;  \n    \n\tvec2 toCenter = uv - center;  \n    \n    float r = length(toCenter);\n    \n    \n    // Color update 1\n    vec3 col = vec3(smoothstep(0.40,0.52, r));//draw circle\n    \n    \n    float angle = atan(toCenter.y,toCenter.x);\n    r *=2.;\n    \n    //Color update 2\n\tcol += hsb2rgb(vec3((angle /TWO_PI)+0.5,r,2. * cos(iTime))); //draw color\n    \n\n    \n    //vec3 col = vec3(uv.y); \n    // Output to screen\n    fragColor = vec4(col,1.0) ;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 80, 80, 313], [315, 315, 343, 343, 429], [431, 431, 466, 466, 509], [510, 510, 567, 668, 1516]], "test": "valid"}
{"id": "3l2czV", "name": "digitalflow", "author": "vdmo", "description": "experiments of course darling ;) ", "tags": ["cineshader"], "likes": 3, "viewed": 5262, "published": "Public API", "date": "1594853252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 20. * iTime),\n      r = (x)^(y);\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 10970 < 1000 );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"vdmo.tv\",\n\t\"description\": \"live visuals\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2czV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 90, 90, 224]], "test": "error"}
{"id": "3l2yDd", "name": "fractal cage", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 5, "viewed": 96, "published": "Public", "date": "1595736648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nfloat map(vec3 p){\n\tfloat s = 1.;\n\tfor(int i = 0; i < 9; i++) {\n\t\tp=p-2.*round(p/2.);\n\t\tfloat r2=1.1/max(pow(lpNorm(p.xyz, 4.5),1.6),.15);\n    \tp*=r2;\n    \ts*=r2;\n\t}\n\treturn length(p)/s-.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(1,1.5,-iTime*.3),\n  \t\tw=normalize(vec3(.2,sin(iTime*.05),-1)),\n  \t\tu=normalize(cross(w,vec3(0,1,0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n  \tfloat h=0.,d,i,zoom = 3.;\n \tro*=zoom;\n\tfor(i=1.;i<100.;i++){\n    \tp=ro+rd*h;\n    \tp/=zoom;\n\t  \td=map(p);\n    \tif(d<0.001||h>25.)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=25.*vec3(cos(p*.4)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 93], [95, 95, 113, 113, 288], [290, 290, 347, 347, 773]], "test": "valid"}
{"id": "3l2yDG", "name": "Bees (жъжъь)", "author": "CyanMARgh", "description": "Russian postironic meme called \"жъжъь\".", "tags": ["raymarching", "meme", "bees"], "likes": 7, "viewed": 82, "published": "Public", "date": "1595264904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPos = vec3(0., 2., -6.5);\nfloat softShadow = 10.;\nfloat depthmax = 50.; \nconst float eps = 1e-3;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n//additioanal operations\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n//SDF operations\n//colored\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix(vec4 d1, vec4 d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//uncolored\nfloat un(float d1, float d2){\n    return d1<d2?d1:d2;\n}\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//SDF\nfloat sphere(vec3 pos){\n    return length(pos);\n}\nfloat capsule(vec3 a, vec3 b, float r1, float r2, vec3 p){\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\t\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                           return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat disk(vec3 p0, vec3 n, float r,vec3 p){\n    p-=p0;\n    float d = length(p);\n    float h = abs(dot(p,n));    \n    float R = sqrt(d*d-h*h)-r;\n    return (R>0.)?sqrt(h*h+R*R):h;\n}\n\n//texturing functions\nbool cb3(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return (d.x+d.y+d.z)%2==0;\n}\nbool cb1(float p, int i){\n    int d = int(floor(p));\n    return d%i==0;\n}\n\n//bee SDF with color\nvec4 bee(vec3 p0, float a, float b, float c, float s, vec3 p){    \n    p-=p0;s/=2.;\n    p/=s;\n    p.xz*=ro(a);\n    p.xy*=ro(b);\n    p.yz*=ro(c);\n\tvec4 body = vec4(cb1(p.z * 5. + .8 ,3)?vec3(.3,.3,.2):vec3(.7,.7,.3), sphere(p-vec3(.0,.0,0.))-1.3);        \n\n    //sting    \n    vec4 sting = vec4(.15,.15,.15,capsule(vec3(0.,0.,0.),vec3(0.,0.,-2.2),.3,.01,p));\n    body = cun(body,sting);\n    \n    //legs\n    p.x=abs(p.x);    \n    vec3 p_=p;  \n\tfloat leg=1e20;\n\tfor(int i=0;i<3;i++){\n\t\tleg = un(leg,capsule(vec3(.5,-1.5,.5),vec3(.4,-.9,.5),.15,.2,p_));\n\t\tp_.z+=.5;\n    }\n    p_=p;        \n    body = cun(body,vec4(.1,.1,.1,leg));\n        \n    //eyes    \n    vec4 eye = vec4(1.,1.,1.,sphere(p_-vec3(.6,0.8,1.))-.7);\n    eye = cun(eye,vec4(.1,.1,.1,sphere(p_-vec3(.6,0.8,1.2))-.55));\n    p_-=vec3(.7,1.5,1.);\n    p_.xy*=ro(-.25);\n    eye = cun(eye,vec4(.2,.2,.2,box(vec3(.6,.1,.2),p_)));        \n\tbody = cun(body,eye);\n    p_=p;\n    \n    //wings    \n    p_.xy *= ro(.1*sin(iTime*30.));\n\tvec4 wing = vec4(.9,.9,1.,disk(vec3(.9,1.,-0.8),normalize(vec3(-1.,1.,0.3)),.8,p_)-.07);        \n\tbody = cun(body,wing);\n    \n    return body*s;\n\n}\n\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(.9,.9,1.,-box(vec3(20.,20.,20.),p-vec3(0.,18.,0.)));\n    d0.xyz *= vec3(cb3(p)?.6:.8);\n    //d0.xyz *= vec3(0.,0.,inf);\n    //greenscreen\n    \n    float t1 = .1*sin(iTime*.3);\n    float t2 = .1*sin(iTime*.26);\n    float t3 = .1*sin(iTime*.22);\n    \n    d0 = cun(d0, bee(vec3(-0.3,0.8+t1,-1.8),2.3,0.0+t2,-.3,1.5,p));\n\td0 = cun(d0, bee(vec3(-1.3,4.0-t2,0.5),1.2,0.0-t3,-0.4,1.5,p));\n\td0 = cun(d0, bee(vec3(0.9,3.9+t3,3.2),3.3,0.0-t1,-0.4,1.5,p));\n    \n    return d0;\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n//light from all sources + occlusion by point\nvec3 getFullLight(vec3 pos, vec3 n){   \n    pos+=eps*n;\n    vec3 col;\n    //vec3 col = map(pos).xyz;\n    vec3 lighting = vec3(.25);\n\n    if (length(pos) < depthmax){\n        // adding 3 point lights and one directional light\n\t\tlighting += getLight(pos, vec3(6., 6., 6.), n, vec3(1.,.9,.9), 50.,false);\n        lighting += getLight(pos, vec3(6., 10., -6.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(-6., 6., 6.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(3., 3., -6.), n, vec3(1.,.9,.9), 50.,false);\n        \n\t\tcol = lighting;\n    }else{\n        col = backcol;\n    }\n    return col;\n}\n//direction of ray by pixel coord\nvec3 getDir(vec2 fragCoord, float angle){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n    return dir;\n}\n//raymarching\nvec3 rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n\n        depth += dist;\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    vec3 n = norm(pos);\n    pos+=eps*n;\n    col+=map(pos).xyz*k*getFullLight(pos,n);\n    return col * exp(-0.003*sdepth);\n}\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //direction calculation\n    float angle = 1.32;    \n    vec3 eye = cameraPos;\n    eye.xz*=ro(angle); // rotating camera\n    vec3 dir = getDir(fragCoord,angle);\n    //raymarching\n    vec3 col = rayCast(eye, dir);    \n    fragColor = vec4(1.5*log(1.+ col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 204, 223, 223, 283], [284, 311, 338, 338, 368], [369, 369, 397, 397, 442], [443, 443, 481, 481, 584], [585, 597, 626, 626, 652], [653, 653, 696, 696, 795], [796, 802, 825, 825, 851], [852, 852, 910, 910, 1440], [1441, 1441, 1467, 1467, 1554], [1555, 1555, 1599, 1599, 1736], [1738, 1760, 1777, 1777, 1841], [1842, 1842, 1867, 1867, 1915], [1917, 1938, 2000, 2000, 3067], [3069, 3081, 3098, 3098, 3585], [3586, 3596, 3614, 3614, 3791], [3792, 3823, 3892, 3892, 4299], [4300, 4330, 4361, 4361, 4758], [4759, 4805, 4841, 4841, 5444], [5445, 5479, 5520, 5520, 5751], [5752, 5766, 5799, 5799, 6397], [6398, 6412, 6466, 6494, 6733]], "test": "valid"}
{"id": "3l2yRh", "name": "Better Multicolor Metaballs", "author": "Mischawake", "description": "Trying to improve look, moved metaballs to an array, added better-looking shading and interactions between bordering colors. Building off https://www.shadertoy.com/view/3llyDB", "tags": ["metaballs"], "likes": 3, "viewed": 75, "published": "Public", "date": "1593718827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nfloat calcShading( vec4 ball, vec2 uv )\n{\n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/(d+ball.b), 3.0 );\n    return  inf;   \n}\n\nvec3[] colors = vec3[]\n(   \n\n    vec3(255./255., 77./255., 0./255.),\n    vec3(255./255., 246./255., 0./255.),\n    vec3(0./255., 192./255., 199./255.),\n    vec3(10./255., 84./255., 255./255.)\n);\n\n//for gradient\nvec3[] colors2 = vec3[]\n(   \n\n    vec3(230./255., 25./255., 56./255.),\n    vec3(230./255., 144./255., 25./255.),\n    vec3(0./255., 199./255., 152./255.),\n    vec3(10./255., 165./255., 255./255.)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    \n   \tfloat threshold = 1.0;\n   \n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n    float rad = 0.1;\n    float jiggle = sin(iTime*(2.0)) * 0.0125;\n    \n    vec4[] balls = vec4[]\n    (\n        vec4(0.2 + jiggle,0.2 + jiggle, rad, 0.),\n        vec4(0.2 - jiggle,0.4,rad, 3.),\n        vec4(0.2,0.6 + jiggle,rad, 3.),\n        vec4(0.2 + jiggle,0.8 + jiggle,rad, 0.),\n\n        vec4(0.4 + jiggle,0.2 - jiggle,rad, 0.),\n        vec4(0.4 + jiggle,0.4,rad, 2.),\n        vec4(0.4,0.6 + jiggle,rad, 0.),\n        vec4(0.4 - jiggle * 3.,0.8+jiggle,rad, 0.),\n\n        vec4(0.6,0.2 - jiggle,rad, 1.),\n        vec4(0.6,0.4 - jiggle,rad, 2.),\n        vec4(0.6 - jiggle,0.6 - jiggle,rad, 2.),\n        vec4(0.6,0.8 - jiggle,rad, 1.),\n\n        vec4(0.8 + jiggle,0.2 + jiggle,rad, 0.),\n        vec4(0.8 + jiggle,0.4 - jiggle,rad, 2.),\n        vec4(0.8,0.6 + jiggle,rad, 1.),    \n        vec4(0.8,0.8 - jiggle,rad, 1.),\n\n        vec4( mouse.xy,rad, 2.),\n        vec4( abs(vec2(sin(iTime*0.25), cos(iTime*0.15))),rad, 1.)\n        \n     );\n    \n   \n   \n    int ballCount = 18;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    float[] shaders = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    int i;\n    //first pass determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n\n        int idx = int( balls[i].a );\n        accumulators[idx] += calcInfluence( balls[i], uv);   \n        shaders[idx] += calcShading( balls[i], uv);\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 totalColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        totalColor += accumulators[i] * colors[i];\n    }\n    \n    totalColor /= totalInf;\n    \n    float ps = (maxInf/totalInf);\n    ps = smoothstep( 0.15, 0.55, ps);\n    \n    vec3 baseColor = mix(colors[maxIdx],colors2[maxIdx],uv.y);\n    vec3 color = mix(vec3(0),baseColor,ps);\n   \n    float influence = accumulators[maxIdx];\n    \n    float totalShade = clamp(0.,1., shaders[maxIdx] );\n    totalShade = pow( 1.0 - pow( 1.0 - totalShade, 2.0), 1.0 );\n    \n    color *= smoothstep(0.0,1.0,totalShade) + 0.25;\n    \n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n   \n    color = mix( totalColor * 0.15, color, smo);\n\n    fragColor = vec4( color, 1.0 );\n    //fragColor = vec4( vec3(1.0)* totalShade, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 117, 117, 214], [216, 216, 257, 257, 363]], "test": "error"}
{"id": "3l2yW1", "name": "Newton's attractor", "author": "lekkel124", "description": "Convergence for Newton's Method of the equation z^alpha - 1 = 0, where alpha changes over time.\nThe screen is the complex plane. The colour indicates to which root the method converges starting from that point. The darker, the more steps needed.", "tags": ["fractal", "attractor", "newton", "method"], "likes": 1, "viewed": 74, "published": "Public", "date": "1595855981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITER 100\n#define EPS 0.001\n#define PI 3.14159265359\n#define HORIZONTALUNITAMOUNT 6.0\n#define SPREADFACTOR 2.0\n\n//polar/cartesian conversions\n//see atan2 on wikipedia https://en.wikipedia.org/wiki/Atan2\nvec2 cart2polar(vec2 a)\n{\n    float theta = 0.0;\n    if(a.x > 0.0) {theta = atan(a.y/a.x);}\n    if(a.x <= 0.0 && a.y >= 0.0) {theta = atan(a.y/a.x) + PI;}\n    if(a.x <= 0.0 && a.y < 0.0) {theta = atan(a.y/a.x) - PI;}\n    return vec2(length(a), mod(theta, 2.0*PI));\n}\n\nvec2 polar2cart(vec2 a)\n{\n    return vec2(a.x*cos(a.y), a.x*sin(a.y));\n}\n\n//Complex division (polar form)\nvec2 cDiv(vec2 a, vec2 b)\n{\n    return vec2(a.x/b.x, a.y-b.y);\n}\n\n//Functions (taking and outputing complex numbers in polar form)\nvec2 foo(vec2 a, float exponent)\n{\n    vec2 b = vec2(pow(a.x, exponent), exponent*a.y);\n    vec2 c = polar2cart(b)-vec2(1.0, 0.0);\n    vec2 d = cart2polar(c);\n    return vec2(d.x, mod(d.y, 2.0*PI));\n}\n\nvec2 dfoo(vec2 a, float exponent)\n{\n    return vec2(exponent*pow(a.x, exponent-1.0), mod((exponent-1.0)*a.y, 2.0*PI));\n}\n\n\n//Messing up with other functions. Please ignore.\n\nvec2 cPower(vec2 a, float e)\n{\n    return vec2(pow(a.x, e), mod(e*a.y, 2.0*PI));\n}\n\nvec2 dcPower(vec2 a, float e)\n{\n    return vec2(e*pow(a.x, e-1.0), mod((e-1.0)*a.y, 2.0*PI));\n}\n\nvec2 r2cPower(float e, vec2 a)\n{\n    return vec2(pow(e, a.x*cos(a.y)), mod(log(e)*sin(a.y), 2.0*PI));\n}\n\nvec2 dr2cPower(float e, vec2 a)\n{\n    vec2 b = r2cPower(e, a);\n    return vec2(log(e)*b.x, b.y);\n}\n\nvec2 foo2(vec2 a, float exponent)\n{\n    vec2 part1 = cPower(a, exponent);\n    vec2 part2 = r2cPower(exponent, a);\n    return cart2polar(polar2cart(part1) - polar2cart(part2));\n}\n\nvec2 dfoo2(vec2 a, float exponent)\n{\n    vec2 part1 = dcPower(a, exponent);\n    vec2 part2 = dr2cPower(exponent, a);\n    return cart2polar(polar2cart(part1) - polar2cart(part2));\n}\n\nvec2 foo3(vec2 a, float e)\n{\n    return cart2polar(polar2cart(cPower(a, 3.0*e)) + polar2cart(cPower(a, 2.0*e)) - vec2(1.0, 0.0));\n}\n\nvec2 dfoo3(vec2 a, float e)\n{\n    return cart2polar(polar2cart(dcPower(a, 3.0*e)) + polar2cart(dcPower(a, 2.0*e)));\n}\n\n//http://www.milefoot.com/math/complex/functionsofi.htm\n//Be careful must not be polar. Better naming convention ?\nvec2 csin(vec2 a) { return vec2(sin(a.x)*cosh(a.y), cos(a.x)*sinh(a.y)); }\n\nvec2 ccos(vec2 a) { return vec2(cos(a.x)*cosh(a.y), -sin(a.x)*sinh(a.y)); }\n\nvec2 csinh(vec2 a) { return vec2(sinh(a.x)*cos(a.y), cosh(a.x)*sin(a.y)); }\n\nvec2 ccosh(vec2 a) { return vec2(cosh(a.x)*cos(a.y), sinh(a.x)*sin(a.y)); }\n\n\nvec2 foo4(vec2 a, float e)\n{\n    return cart2polar(csin(polar2cart(a)));\n}\n\nvec2 dfoo4(vec2 a, float e)\n{\n    return cart2polar(ccos(polar2cart(a)));\n}\n\n//Newton's Algorithm\n//Return vec3 where the two first components are the point the method converges towards\n//And the last one is the number of iterations it took.\nvec3 newton(vec2 a0, float exponent)\n{\n  vec2 ai = a0;\n  for (int i = 0; i < MAXITER; i++)\n  {  \n    vec2 zp = cart2polar(ai);\n    ai -= polar2cart(cDiv(foo(zp, exponent), dfoo(zp, exponent)));\n    if(foo(zp, exponent).x <= EPS) {\n    \treturn vec3(zp, float(i));\n    }\n  }\n  return vec3(0.0);\n}\n\n//Colours ------------------------------------------\n\n//See https://www.shadertoy.com/view/3ljyW1 for the colorwheel.\nfloat colorSpike(float theta, float spike)\n{\n    return max(0.0, smoothstep(0.0, 1.0, 1.0 - abs(SPREADFACTOR*(theta - spike))));\n}\n\n\nvec4 colorWheel(float theta)\n{\n    float thetamod = mod(theta, 2.0*PI)/(2.0*PI);\n    return vec4(colorSpike(thetamod, 0.0) + colorSpike(thetamod, 1.0),\n                colorSpike(thetamod, 1.0/3.0) + colorSpike(thetamod, 4.0/3.0),\n                colorSpike(thetamod, 2.0/3.0) + colorSpike(thetamod, -1.0/3.0),\n                1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, 0.5*iResolution.y/iResolution.x);\n    uv *= HORIZONTALUNITAMOUNT;\n    float exponent = 2.0 + 0.1*iTime;\n    vec2 polaruv = cart2polar(uv);\n    vec3 tmp = newton(uv, exponent);\n    vec2 root = tmp.xy;\n    float alpha = sqrt(tmp.z*2.0/(float(MAXITER)));\n    vec4 color = vec4(0.0);\n    if(root != vec2(0,0))\n    {\n        //color = colorWheel(root.y);\n        color = colorWheel(root.y)*(1.0-alpha);\n        //color = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    /*/if(abs(1.0 - polaruv.x) <= 0.05)\n    {\n        color = colorWheel(polaruv.y);\n    }/*/\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 213, 238, 238, 479], [481, 481, 506, 506, 553], [555, 587, 614, 614, 651], [653, 718, 752, 752, 918], [920, 920, 955, 955, 1040], [1094, 1094, 1124, 1124, 1176], [1178, 1178, 1209, 1209, 1273], [1275, 1275, 1307, 1307, 1378], [1380, 1380, 1413, 1413, 1478], [1480, 1480, 1515, 1515, 1657], [1659, 1659, 1695, 1695, 1839], [1841, 1841, 1869, 1869, 1972], [1974, 1974, 2003, 2003, 2091], [2093, 2208, 2227, 2227, 2282], [2284, 2284, 2303, 2303, 2359], [2361, 2361, 2381, 2381, 2436], [2438, 2438, 2458, 2458, 2513], [2516, 2516, 2544, 2544, 2590], [2592, 2592, 2621, 2621, 2667], [2669, 2834, 2872, 2872, 3128], [3184, 3248, 3292, 3292, 3378], [3381, 3381, 3411, 3411, 3715]], "test": "valid"}
{"id": "3l2yWK", "name": "00-a: Lambertian Sphere", "author": "yarn", "description": "learn", "tags": ["learn"], "likes": 2, "viewed": 44, "published": "Public", "date": "1595379909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// todo moon orbiting and casting a shadow + stars/nebulae\n\n\nvec3 normal_at(vec3 s_c, vec3 point) {\n\treturn normalize(point - s_c);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio; // unstretch\n    uv.x += (1.0 - aspect_ratio) / 2.0; // centre\n    \n    //vec2  mouse_loc = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n\t//vec2 mouse_loc = vec2(0.5) + 0.2*vec2(sin(0.05 * iTime), cos(0.05 * iTime));\n    vec2 mouse_loc = vec2(0.5);\n \n    //vec3 sphere_centre = vec3(0.2);\n    vec3 sphere_centre = vec3(mouse_loc.x, 0.3, mouse_loc.y);\n    float sphere_radius = 0.2;\n    \n    vec3 ray_origin = vec3(uv.x, -1.0, uv.y); // view plane at z = -1.0\n    \n    vec3 ray_dir = vec3(0.0, 1.0, 0.0); // straight from view plane\n    \n    float t = iTime * 5.0;\n    \n    vec3 light_pos = vec3(0.5 + 0.3 * sin(0.3 * t), 0.3 + 0.2*sin(0.5 * t), 0.5 + 0.3 * cos(0.3 * t));\n    \n    vec3 col;\n    \n    float root = pow(dot(ray_dir, ray_origin - sphere_centre) , 2.0) - pow(length(ray_origin - sphere_centre), 2.0) + pow(sphere_radius, 2.0);\n    \n    if (root < 0.0) {\n    \tcol = vec3(0.0);   \n    } else {\n        float t = -(dot(ray_dir, ray_origin - sphere_centre)) - sqrt(root);\n        //col = vec3(1.0 - 0.7*t);\n\n        vec3 light_dir = -normalize(sphere_centre - light_pos);\n        vec3 norm = (normal_at(sphere_centre, ray_origin +  t * ray_dir)); // norman!\n        \n        \n        col = vec3(dot(light_dir, norm));\n    }\n    \n    float light_point = step(distance(uv, vec2(light_pos.x, light_pos.z)), (0.3 - 0.2*sin(0.5 * t)) * 0.03);\n    \n    if (light_point > 0.95) {\n     \tcol = vec3(0.0, 0.3 - 0.2*sin(0.5 * t), 0.0);   \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 99, 99, 136], [138, 138, 195, 195, 1818]], "test": "valid"}
{"id": "3l2yzD", "name": "ParabolaCapped", "author": "jj99", "description": "Modded version of IQ's parabola segment (Capped) - not sure if this is 100% correct!\n( original here: https://www.shadertoy.com/view/3lSczz )", "tags": ["cappedparabolasegment"], "likes": 2, "viewed": 189, "published": "Public API", "date": "1593869190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modded version of IQ's parabola segment (Capped) - not sure if this is 100% correct!\n// Use at your own risk!! :)\n\nfloat sdParabolaCapped( in vec2 pos, in float wi, in float he, float thickness )\n{\n    pos.x = abs(pos.x);\n\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        // 3 roots\n        2.0*cos(atan(r/q)/3.0)*sqrt(p);\n    \n    x = min(x,wi);\n    \n    float d =  length(pos-vec2(x,he-x*x/ik))-thickness;\t// * sign(ik*(pos.y-he)+pos.x*pos.x);\n    \n    // cap test...\n    vec2 ep = pos-vec2(wi,0.0);\n    vec2 mp = pos-vec2(0.0,he);\n    return max(d, dot(ep,normalize(mp-ep)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n    \n\tfloat w = 0.7+0.69*sin(iTime*1.1+0.0);\n    float h = 0.3+0.55*sin(iTime*1.3+2.0);\n    \n    // sdf\n    float d = sdParabolaCapped( p, w, h, 0.05 );\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yzD.jpg", "access": "shaders20k", "license": "warranty-disclaimer", "functions": [[118, 118, 200, 200, 804], [806, 806, 861, 861, 1363]], "test": "valid"}
{"id": "3lBcWt", "name": "Funky sines", "author": "wetmore", "description": "use mouse.", "tags": ["moire", "monochrome"], "likes": 1, "viewed": 62, "published": "Public", "date": "1595621778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(float i, float s, float t, float x, float y) {\n\treturn i * (y - s) / (t - s) + x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iMouse.xy/iResolution.xy;\n    if (uv == vec2(0.,0.)) {\n    \tuv = vec2(0.6,0.5);\n    }\n\n    float i = fragCoord.x * uv.x ;\n    float j = fragCoord.y * uv.y + iTime/100.;\n    float t = iTime / 1000.;\n    \n    float a = 100.;\n    float m = 10.*sin(t*i*j);\n    float f = 1.;\n    \n    float l = abs(200.*j*cos(i*10.));\n    float u=map(m,0.,f,0.,128.)+map(l,0.,300.,0.,127.);\n    float col = u / 255.;\n    \n    // Output to screen\n    fragColor = vec4(col,col, col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 93], [95, 95, 152, 202, 683]], "test": "valid"}
{"id": "3lBcWy", "name": " Solskogen 2020 Semifinal", "author": "Alkama", "description": "My semifinal Shader Showdown result @ Solskogen 2020 demoparty.\n25 minutes round.\n(I ultimately got defeated by the great evvvvil)", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 10, "viewed": 335, "published": "Public API", "date": "1595195826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi=acos(-1.),t,d;\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat cube(vec3 p, vec3 s) { vec3 b=abs(p)-s; return max(max(b.x,b.y),b.z); }\nfloat scene(vec3 p) {\n  vec3 pp=p;\n  float s=1.;\n  float a=1.5;\n  for(int i=0; i<5; i++) {\n    p = 2.*clamp(p,-a,a)-p;\n    float r=max(1., .4/dot(p,p));\n    p*=r;\n    s*=r;\n  }\n  p.xz*=rot(t*10.);\n  return cube(p, vec3(.2, 2., .2))/s;\n}\nvec3 norm(vec3 p) { vec2 e=vec2(.0001,0); return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx))); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-.5)*vec2(iResolution.x / iResolution.y, 1);\n    t=mod(.1*iTime,10.*pi);\n    vec2 uv2=uv;\n    uv/=1.5-length(uv);\n    vec3 o,tg,f,s,u,dir,col;\n    o.y+=.02+.02*sin(t);\n    o+=.04*vec3(sin(t),sin(t),cos(t));\n    tg.y=-.02*sin(t);\n    f=normalize(tg-o);\n    s=normalize(cross(vec3(.5*sin(t*5.),1,0),f));\n    u=normalize(cross(f,s));\n    dir=normalize(f*.8+uv.x*s+uv.y*u);\n    vec3 lp=vec3(.1);\n    lp.xz+=vec2(sin(t*10.),cos(t*10.));\n    vec3 p=o;\n    float side=sign(scene(p));\n    for(int i=0;i<200;i++) {\n        float h=scene(p)*side*.5;\n        if(h<.0001*d) {\n            vec3 n=norm(p)*side;\n            vec3 ld=normalize(lp-p);\n            float df=max(0.,dot(n,ld));\n            float sp=pow(max(0.,dot(dir,reflect(ld,n))), 5.);\n            float fr=pow(abs(1.-dot(n,-dir)), .5);\n            vec3 fromage=acos(normalize(dir-p));\n            col+=.5*vec3(.1*df+fromage*sp*fr);\n            p-=n*.005;\n            side*=-1.;\n        }\n        if(d>.2) break;\n        d+=h;\n        p+=dir*h;\n    }\n    col= mix(col,.09*vec3(.9,.9,1.),5.-exp(-d));\n    col*=pow(1.5-length(uv2),3.);\n    fragColor = vec4(pow(col,vec3(1./1.7)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 93], [94, 94, 122, 122, 171], [172, 172, 193, 193, 408], [409, 409, 428, 428, 531], [532, 532, 589, 589, 1762]], "test": "valid"}
{"id": "3lByDh", "name": "Borromean World Beta", "author": "sl2c", "description": "If you put the Borromean rings in the 3-sphere and double-cover the sphere branched around the rings, you get a manifold with Euclidean geometry.  This is effectively that manifold.  However, I don't know how to do shading yet.", "tags": ["raymarching", "sdf", "euclidean", "wraparound"], "likes": 3, "viewed": 68, "published": "Public", "date": "1594223751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nfloat dist(vec2 z) {\n    vec2 r = vec2(z.x-0.5, min(z.y,1.0-z.y));\n    return sqrt(dot(r,r));\n}\n\nfloat scene(vec3 p) {\n    return min(min(dist(p.xy),dist(p.yz)),dist(p.zx)) - 0.05;\n}\n\nvoid borro(inout vec2 z, inout vec2 v) {\n    if (z.y < 0.0) {\n        z = vec2(1.0, 0.0) - z;\n        v = -v;\n    }\n    if (z.y > 1.0) {\n        z = vec2(1.0, 2.0) - z;\n        v = -v;\n    }\n}\n\nvoid rotate(inout vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    z = vec2(z.x * c - z.y * s,\n             z.y * c + z.x * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float w = mod(iTime * 0.1 + 0.5, 1.0);\n    \n    vec3 loc = vec3(w);\n    vec3 dir = vec3(uv,0.5);\n    dir = normalize(dir);\n    \n    if (iMouse.x > 0.0) {\n        vec2 m = (tau / 2.5) * (iMouse.xy - iResolution.xy * 0.5)/iResolution.y;        \n        rotate(dir.yz, m.y);\n        rotate(dir.xz, m.x);\n    }\n    \n    float fog = 0.0; int i;\n    for(i=0; i<100; i++) {\n        float d = scene(loc);\n        if (d < 0.01) {\n            break;\n        }\n        loc += d * dir;\n        fog += d;\n        \n\t    borro(loc.xy, dir.xy); borro(loc.yz, dir.yz); borro(loc.zx, dir.zx);\n    }\n    \n    if (dist(loc.xy)<0.11) {\n        col = vec3(1.0,0.0,0.0);\n    } else if (dist(loc.yz)<0.11) {\n        col = vec3(0.0,1.0,0.0);\n    } else if (dist(loc.zx)<0.11) {\n        col = vec3(0.0,0.0,1.0);\n    } else {\n        col = vec3(0.5);\n    }\n\n    // Output to screen\n    fragColor = vec4(col * exp(-fog * 0.12) * 0.98,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByDh.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[247, 247, 267, 267, 342], [344, 344, 365, 365, 429], [431, 431, 471, 471, 623], [625, 625, 665, 665, 784], [786, 786, 843, 843, 1919]], "test": "valid"}
{"id": "3lByDy", "name": "Mug Torus Homeomorphism", "author": "Roninkoi", "description": "I couldn't find this classic bit of topology on here, so I decided to make it! [url]https://en.wikipedia.org/wiki/File:Mug_and_Torus_morph.gif[/url]", "tags": ["torus", "morph", "topology", "mug", "homeomorphism"], "likes": 5, "viewed": 227, "published": "Public API", "date": "1595201996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 200\n#define EPSILON 0.001\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat mug(vec3 r, float m)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - vec2(2.);\n    float cyl = (min(max(p.x, p.y), 0.0) + length(max(p, 0.)));\n    \n\tp = abs(vec2(length(r.xz), r.y - 1. - 4. * (1. - m)*4.)) - vec2(1.5 - (1.-m)*3., 3.);\n    float icyl = (min(max(p.x, p.y), 0.0) + length(max(p, 0.)));\n    \n    vec3 rr = r;\n    rr.x += 1.5;\n    p = vec2(length(rr.xy) - 1.5, rr.z);\n    float tor = (length(p) - 0.25);\n\t\n\treturn min(max(-icyl, cyl), max(-icyl, tor)) * m;\n}\n\nfloat torusm(vec3 r, float m)\n{\n    vec3 rr = r;\n    rr.x += 1.5;\n    vec2 p = vec2(length(rr.xy) - 1.5, rr.z);\n    float tor = (length(p) - 0.25);\n\t\n    return tor * m;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n)\n{\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r)\n{\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a)\n{\t\n    vec3 p = (abs(r) - a);\n    \n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n    obj = rotY(t) * rotX(sin(t*0.33) * 0.1 - 0.1);\n    \n    r = obj * r;\n    \n    float m = (sin(t * 0.5) + 1.) * 0.5;\n        \n    r.x -= (1.-m) * 1.5;\n    \n    float d = torusm(r, 1. - m);\n    d += mug(r, m);\n    \n    return vec2(d, 1.);\n}\n\nvec3 matCol(vec2 o)\n{\n    return vec3(1.0, 0.5, 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.5);\n       \n    vec3 ro = vec3(0., 3.0, -5.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.0, (1.+uv.y)*0.5, (1.+uv.y*0.5)*0.5)*2. + vec3(0.5);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.05, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.6 - 0.1 * hash(uv);\n\t\tr += rd * d.x;\n        \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    \n\tcol.rgb *= exp(-sh * 1.0);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 181, 181, 283], [286, 286, 306, 306, 410], [413, 413, 433, 433, 535], [549, 549, 580, 580, 608], [611, 611, 640, 640, 714], [716, 716, 744, 744, 1187], [1189, 1189, 1220, 1220, 1360], [1363, 1363, 1400, 1400, 1428], [1430, 1430, 1462, 1462, 1564], [1566, 1566, 1586, 1586, 1658], [1660, 1660, 1687, 1687, 1753], [1755, 1755, 1785, 1785, 1840], [1843, 1843, 1885, 1885, 1925], [1938, 1938, 1956, 1956, 2202], [2204, 2204, 2225, 2225, 2258]], "test": "valid"}
{"id": "3lByRd", "name": "Final Storm", "author": "Xor", "description": "Noise experiments", "tags": ["clouds", "fire"], "likes": 21, "viewed": 328, "published": "Public", "date": "1595044651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float value(vec2 p)\n{\n \tvec2 f = floor(p);\n    vec2 s = (p-f);\n    s *= s*(3.-2.*s);\n    \n    return texture(iChannel0,(f+s-.5)/256.).r;\n}\nvoid mainImage(out vec4 Color, in vec2 Coord)\n{\n    vec2 u = Coord/iResolution.xy;\n    vec2 c = u*3.;\n    vec2 h = vec2(0);\n    float a = 1.;\n    float s = 1.;\n    for(float i = 0.;i<10.;i++)\n    {\n        a*=2.2;\n        s*=2.;\n        h += vec2(value(c*s+iTime*vec2(.2,-.1*a)+h.x*a/s*vec2(4,6)),1)/a;\n    }\n   \tfloat g = smoothstep(-.8,.8,h.x/h.y-u.y);\n\tvec3 v = 1.+smoothstep(.2,1.,length(u-.5))*vec3(4,6,8)*value(vec2(iTime));\n    float n = 1.+.05*g*g*cos(value(Coord*.2+vec2(g,0)*10.)/.1+iTime/.1);\n    Color = vec4(exp(-vec3(2,6,11)*g*v)*n,1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 138], [139, 139, 186, 186, 690]], "test": "error"}
{"id": "3lByRK", "name": "Analytic Line Integral Fog", "author": "blackle", "description": "analytic integral for fog with the density `pow(dot(sin(origin + x*dir), vec3(1), 2.);` currently have problems with divisions by zero\n\non the left is one component, on the right are 50 summed up", "tags": ["fog", "analytic", "integral", "lineintegral"], "likes": 7, "viewed": 317, "published": "Public API", "date": "1594758165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec3 b) {\n    b += vec3(equal(b,vec3(0)))*.01;\n    return a/b;\n}\n\nfloat antiderivative(float x, vec3 origin, vec3 dir) {\n    //antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3(1,1,0,-1,0,1,0,-1,-1);\n    mat3 B = mat3(1,1,0,1,0,1,0,1,1);\n    vec3 Q = origin + dir*x;\n    vec3 integral = div(sin(A*Q),(A*dir)) - div(sin(B*Q),(B*dir)) + div((2.*Q-sin(2.*Q)),(4.*dir));\n    return dot(integral, vec3(1));\n}\n\nfloat lineintegral(vec3 a, vec3 b) {\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    return antiderivative(len,a,dir) - antiderivative(0.,a,dir);\n}\n\nfloat scene(vec3 p) {\n    p = asin(sin(p+1.));\n    return length(p)-1.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) {\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n\tvec3 init = vec3(-4,0,0);\n    cam = erot(cam, vec3(0,1,0), .2);\n    init = erot(init, vec3(0,1,0), .2);\n    cam = erot(cam, vec3(0,0,1), iTime/5.);\n    init = erot(init, vec3(0,0,1), iTime/5.);\n    init.x += iTime;\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist * cam;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 a = p; vec3 b = init; float scale = 1.;\n    float fog = lineintegral(a,b)/20.;\n    \n    if (uv.x > 0.) {\n    \t//sum up multiple different versions of the fog\n    \tfor (int i = 0; i < 50; i++) {\n            //random rotation\n        \tvec3 ax = normalize(tan(hash3(float(i),14353.)));\n        \tfloat ro = hash(float(i),66123.)*10.;\n        \ta = erot(a,ax,ro);\n        \tb = erot(b,ax,ro);\n        \tfog += lineintegral(a*scale,b*scale)/sqrt(scale);\n       \t\tscale *= 1.06;\n    \t}\n\t\tfog /= 2500.;\n\t}\n\n    fragColor = sqrt(vec4(fog));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByRK.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 274, 300, 300, 355], [357, 357, 411, 479, 724], [726, 726, 762, 762, 887], [889, 889, 910, 910, 962], [964, 964, 1002, 1002, 1064], [1121, 1121, 1151, 1151, 1227], [1229, 1229, 1259, 1259, 1371], [1373, 1373, 1430, 1430, 2504]], "test": "valid"}
{"id": "3lByRw", "name": "Even Better Multicolor Metaballs", "author": "Mischawake", "description": "Building off of https://www.shadertoy.com/view/3l2yRh -- added normals and lighting", "tags": ["metaballs"], "likes": 10, "viewed": 247, "published": "Public", "date": "1593914818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nfloat calcHeight( vec4 ball, vec2 uv )\n{\n \n   float d = distance(ball.rg, uv)/ball.b;\n   float h = pow( 1. - pow( d, 2.), 1./3. );\n   return h;\n    \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n   \n    float eps = 0.00001;\n    \n    vec3 xp = vec3( uv.x + eps, uv.y, calcHeight( ball, vec2(uv.x + eps, uv.y) ) \n                   - vec3( uv.x - eps, uv.y, calcHeight( ball, vec2(uv.x - eps, uv.y) )  ) );\n    vec3 yp = vec3( uv.x, uv.y + eps, calcHeight( ball, vec2( uv.x, uv.y + eps) ) \n                   - vec3( uv.x, uv.y - eps, calcHeight( ball, vec2(uv.x, uv.y - eps) ) ) );\n    \n    return cross( xp, yp );\n}\n\n\nvec3 calcOldNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.1);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    vec3(255./255., 77./255., 0./255.),\n    vec3(255./255., 246./255., 0./255.),\n    vec3(0./255., 192./255., 199./255.),\n    vec3(10./255., 84./255., 255./255.)\n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n    vec3(230./255., 25./255., 56./255.),\n    vec3(230./255., 144./255., 25./255.),\n    vec3(0./255., 199./255., 152./255.),\n    vec3(10./255., 165./255., 255./255.)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n    \n    //settings to play with!\n    float threshold = 1.0;\n    float shadowIntensity = 0.7;\n    float specularIntensity = 0.1;\n    float specularPower = 20.0;\n    float rimIntensity = 2.0; //2\n    float aoIntensity = 0.9;\n    float ambientBrightness =  0.05;\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.1;\n    float rf = 0.;//0.005;\n    float jiggle = 0.;//sin(iTime*(2.0)) * 0.0125;\n    \n    vec4[] balls = vec4[]\n    (\n        \n        vec4(0.0 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 3.),\n        vec4(0.0 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.0,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 2.),\n        vec4(0.0 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 2.),\n        \n        vec4(0.2 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 0.),\n        vec4(0.2 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.2,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 3.),\n        vec4(0.2 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 0.),\n\n        vec4(0.4 + jiggle,0.2 - jiggle,rad + sin(iTime * 4. + 3.) * rf, 0.),\n        vec4(0.4 + jiggle,0.4,rad + sin(iTime * 4. + 4.) * rf, 2.),\n        vec4(0.4,0.6 + jiggle,rad + sin(iTime * 4. + 5.) * rf, 0.),\n        vec4(0.4 - jiggle * 3.,0.8+jiggle,rad + sin(iTime * 4. + 6.) * rf, 0.),\n\n        vec4(0.6,0.2 - jiggle,rad + sin(iTime * 4. + 7.) * rf, 1.),\n        vec4(0.6,0.4 - jiggle,rad + sin(iTime * 4. + 8.) * rf, 2.),\n        vec4(0.6 - jiggle,0.6 - jiggle,rad + sin(iTime * 4. + 9.) * rf, 2.),\n        vec4(0.6,0.8 - jiggle,rad + sin(iTime * 4. + 10.) * rf, 1.),\n\n        vec4(0.8 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(0.8 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(0.8,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(0.8,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 1.),\n        \n        vec4(1.0 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(1.0 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(1.0,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(1.0,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 0.),\n\n        vec4( mouse.xy,rad, 2.),\n        vec4( 0.95 * abs(vec2(sin(iTime*0.2345), cos(iTime*0.1234))), rad, 1.)\n        \n     );\n    \n    int ballCount = 26;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] normals = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    vec2[] pos = vec2[]\n    (\n    \tvec2(0),\n        vec2(0),\n        vec2(0),\n        vec2(0)\n    );\n    \n    \n    int i;\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv );\n        accumulators[idx] += inf;\n        normals[idx] += calcOldNormal( balls[i], uv) * min(10.0, inf );\n        pos[idx] += (balls[i].rg - uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    \n  \n    \n    vec3 normal = normalize( normals[maxIdx] );\n   \n    \n \t\n    //influence = mix( influence, 1.0, 1.0 - off/0.1 );\n    \n      \n    //point light\n    vec3 light = vec3( 0.5 + sin(iTime/2.0) * 0.65, 0.5 + cos(iTime/2.0) * 0.45, -0.25);\n    float lightRadius = 0.01;\n    float lightIntensity = calcInfluence( vec4(light.x, light.y, lightRadius, 0.), uv );\n\tvec3 lightDir = normalize( light - vec3( uv, 0.0 ) );            \t\n    \n    //basecolor\n    vec3 color = baseColor;\n    vec3 ambientColor = vec3(ambientBrightness);\n    if( rainbowMode )\n        ambientColor = avgColor * ambientBrightness;\n   \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    color += vec3(1.0) * rimIntensity * pow (rim, 2.0);\n    \n    //diffuse\n    float lighting = max(0.,dot( -normal, lightDir) );\n    color = mix( color, color * lighting, (1.0 - ambientBrightness) * shadowIntensity );\n    \n    // specular blinn phong\n    vec3 dir = normalize(lightDir + vec3(0,0,-1.0) );\n    float specAngle = max(dot(dir, -normal), 0.0);\n    float specular = pow(specAngle, specularPower);\n    color += vec3(1.0) * specular * specularIntensity;\n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor, color, smo);\n    \n    color += pow(lightIntensity,0.5) * 2.0 * vec3(1.);                    \n    \n    \n    \n   \n    \n    \n    fragColor = vec4( color, 1.0 );\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 117, 117, 214], [216, 216, 256, 256, 366], [368, 368, 407, 407, 828], [831, 831, 873, 873, 918]], "test": "error"}
{"id": "3lByzh", "name": "Jagarikin illusion 2", "author": "ciphered", "description": "Highly inspired by the work of Jagarikin\nhttps://twitter.com/jagarikin", "tags": ["illusion", "opart", "jagarikin"], "likes": 1, "viewed": 219, "published": "Public API", "date": "1593654074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Highly inspired by the work of Jagarikin\n// https://twitter.com/jagarikin\n//\n// \n//\n\n#define DELAY .1\n#define PI 3.1415927\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n\n// @author Fabrice Neyret \n// https://www.shadertoy.com/view/MtG3Wh\n// His color interpolation just works so well with this illusion !\nvec3 rainbow (float h) {\n\tvec4 O = mod(vec4(1,2,3,0)-3.*h, 3.); O = min(O,2.-O);     // linear rainbow\n  \tO = .5+.5*cos(6.283185*(h +vec4(0,1,-1,0)/3.));       // 1/j/j² rainbow \n    //O = pow(max(O,0.),vec4(1./2.2));\t\t// gamma correction\n    return O.rgb;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime * .1;\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    uv*= 3.;\n    \n    \n    float L = length(uv);\n    float An = atan(uv.y, uv.x)*10. + sin(L*(clamp(cos(T*2.), -.2, .2)-.2)*10.)*5.;\n    float B = mod(An, 2.*PI) / (2.*PI) - .5;\n    vec2 id = vec2(floor(abs(An)/(PI*2.) - .5), floor((L-.5)*3.));\n    float S = cos(An) * .5 + .5;\n    \n    float C = smoothstep(.7, .8, S);\n    float Lt = smoothstep(.6, .62, S) - C;\n    \n    float A = step(abs(cos(L*10.)), .5);\n    C*= A;\n    Lt*= A;\n    \n    T*=  10.;\n    T+= (-id.y * .08 + id.x * (.08 + cos(iTime*.1)*.05)) * min(iTime/60., 1.);\n    vec3 cC = rainbow(T);\n    vec3 cLt = rainbow(T + DELAY*sign(B));\n\n\n    vec3 col = vec3(.5);\n    \n    col = mix(col, cC, C);\n    col = mix(col, cLt, Lt);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 320, 344, 344, 579], [583, 583, 640, 640, 1456]], "test": "valid"}
{"id": "3lcSz7", "name": "Quantum Blorble", "author": "trevorleake", "description": "Pretty. But also hairy.", "tags": ["raymarching", "messy"], "likes": 8, "viewed": 136, "published": "Public", "date": "1594079925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAGIC_BOX_ITERS = 9;\nconst float MAGIC_BOX_MAGIC = 1.;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise(vec3 p){\n    \n    float t = iTime/3.;\n    vec3 np = normalize(p);\n    \n    // kind of bi-planar mapping\n    float a = texture(iChannel0,t/20.+np.xy).x;      \n    float b = texture(iChannel0,t/20.+.77+np.yz).x;\n    \n    a = mix(a,.5,abs(np.x));\n    b = mix(b,.5,abs(np.z));\n    \n    float noise = a+b-.4;    \n    noise = mix(noise,.9,abs(np.y)/2.);\n        \n    return noise;\n}\n\nfloat map(vec3 p){\n    \n    // spheres\n    float d = (-1.*length(p)+3.)+1.5*noise(p) + magicBox(p/2.1)/8. * 2.;    \n    d = min(d, (length(p)-2.1) + noise(p) + magicBox(p)/9.)*.3;\n    \n    // links\n    float m = 1.; float s = .0;    \n//    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          \n//    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    \n//    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    \n//    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    \n//    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );\n    \n    return d;\n}\n\nfloat color( vec3 p){\n   return 0.; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(1.*uv.x,1.*uv.y,1.));\n    \n    // Color    \n    vec3 color = vec3(0);    \n    const int rayCount = 1024;\n    \n    // Raymarching\n    float t = 0.;\n    for (int r = 1; r <= rayCount; r++)\n    {\n        // Ray Position\n        vec3 p = vec3(0,0,-3.) + ray * t;        \n        \n        // Rotation \n       \tp = rotateY(p, iMouse.x/iResolution.x * 2.* 3.14);  \n        p = rotateY(p,iTime/15.);\n        \n        // Deformation \n    \tfloat mask = max(0.,(1.-length(p/3.)));\n    \tp = rotateY(p, mask*sin(iTime/10.)*.2);        \n        p.y += sin(iTime+p.z*3.)*mask*.2;\n        p *= 1.+(sin(iTime/2.)*mask*.1);\n\n        // distance\n        float d =  map(p);   \n        \n        //color\n        if(d<0.01 || r == rayCount )\n        {                 \n            \n            float iter = float(r) / float(rayCount);\n            float ao = (1.-iter);\n            ao*=ao;\n            ao = 1.-ao;\n                        \n            float mask = max(0.,(1.-length(p/2.)));            \n            mask *= abs(sin(iTime*-1.5+length(p)+p.x)-.2);            \n            color += 2.*vec3(.1,1.,.8) * max(0.,(noise(p)*4.-2.6)) * mask;            \n            color += vec3(.1,.5,.6) * ao * 6.;            \n            color += vec3(.5,.1,.4)*(t/8.);\n                       \n            color *= 2.2 + (sin(iTime/3.)*.3 + .55);\n            color -= 1.;\n                        \n            break;          \n        }\n        \n        // march along ray\n        t +=  d *.5;        \n    }\n    \n    // vignetting effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx; \n    float vig = uv.x*uv.y * 20.0;    \n    vig = pow(vig, 0.25);        \n    color *= vig;\n    \n    //color adjustement\n    color.y *= 1.1;\n    color.x *= 2.4;\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 90, 265, 847], [1233, 1233, 1263, 1263, 1384], [1386, 1386, 1427, 1427, 1520], [1522, 1522, 1542, 1542, 1910], [1912, 1912, 1930, 1950, 2520], [2522, 2522, 2543, 2543, 2560], [2562, 2562, 2619, 2642, 4595]], "test": "error"}
{"id": "3lfBz8", "name": "Interlocked Tetrahedra", "author": "dr2", "description": "Interlocked hollow tetrahedra with a little light and shadow (see Escher's Double Planetoid where things get more complicated)", "tags": ["tetrahedron", "shape"], "likes": 10, "viewed": 249, "published": "Public API", "date": "1595923196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Interlocked Tetrahedra\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrTetDf (vec3 p, float d);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (float k = -1.; k <= 1.; k += 2.) {\n    q = p;\n    q.y *= k;\n    q.y -= -0.2;\n    q.xz = Rot2D (q.xz, - k * pi / 6.);\n    q.xy = Rot2D (q.xy, pi / 2. -0.5 * acos (1./3.));\n    q.xz = Rot2D (q.xz, pi / 4.);\n    d = abs (PrTetDf (q, 1.)) - 0.02;\n    d = max (d, - PrSphDf (q, 0.85));\n    DMIN (1);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[4], ltDir, col, vn, c, dfTot, spTot;\n  float dstObj, at, nDotL, sh;\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 1., 3.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. - 0.2 * pi * tCur);\n  }\n  ltPos[3] = vec3 (0., 5., 0.);\n  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.22 * pi * tCur)));\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (64. * ro, vn, 0.2);\n    dfTot = vec3 (0.);\n    spTot = vec3 (0.);\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.6, 0.95, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro + 0.05 * vn, ltDir);\n      c = HsvToRgb (vec3 (0.9 - 0.25 * float (k), 0.9, 1.));\n      nDotL = max (dot (vn, ltDir), 0.);\n      dfTot += c * (0.05 + 0.95 * at * sh * nDotL * nDotL);\n      spTot += 0.2 * c * at * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n    col = dfTot + spTot;\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  zmFac = 5.5;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrTetDf (vec3 p, float d)\n{\n  vec2 e = vec2 (1., -1.);\n  return (max (max (dot (p, e.yxx), dot (p, e.xyx)), max (dot (p, e.xxy), dot (p, e.yyy))) - d) / sqrt (3.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBz8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[445, 445, 467, 467, 834], [836, 836, 869, 869, 1046], [1048, 1048, 1069, 1069, 1317], [1319, 1319, 1356, 1356, 1578], [1580, 1580, 1615, 1615, 2756], [2773, 2773, 2829, 2829, 3828], [3830, 3830, 3863, 3863, 3890], [3892, 3892, 3925, 3925, 4063], [4065, 4065, 4089, 4089, 4206], [4208, 4208, 4244, 4244, 4450], [4452, 4452, 4482, 4482, 4595], [4629, 4629, 4653, 4653, 4765], [4767, 4767, 4792, 4792, 4978], [4980, 4980, 5009, 5009, 5221], [5223, 5223, 5262, 5262, 5442]], "test": "error"}
{"id": "3lfBzN", "name": "polygons in 3d", "author": "CoolerZ", "description": "Trying to construct a dodecahedron in 3d using 2d pentagons in 3d.", "tags": ["3d", "raymarching", "polygon", "dodecahedron"], "likes": 2, "viewed": 72, "published": "Public", "date": "1596156823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON .01\n#define MAX_ITERS 100\n\nconst float PI = radians(180.);\nconst float PI2 = 2.*PI;\n\nvec2 rot2d(vec2 p, float angle)\n{\n    mat2 r = mat2(\n        cos(angle), sin(angle), // first column\n        -sin(angle), cos(angle) // second column\n    );\n    return r*p;\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    vec3 o = dot(p, axis)*axis;\n    vec3 x = normalize(p-o);\n    vec3 y = normalize(cross(-axis, x));\n    float r = length(p-o);\n    return o + r*cos(angle)*x + r*sin(angle)*y;\n}\n\nfloat line_d(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba);\n}\n\nfloat line_d(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba);\n}\n\nfloat thick_line_d(vec2 p, vec2 a, vec2 b, float r)\n{\n    vec2 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba)-r;\n}\n\nfloat point_d(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat ngon_d(vec2 p, int n, float r)\n{\n    float delta = PI2/float(n);\n    float d = 10000.0;\n    float sig = -1.;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec2 v1 = vec2(r*cos(a1), r*sin(a1));\n        vec2 v2 = vec2(r*cos(a2), r*sin(a2));\n        d = min(d, line_d(p, v1, v2));\n\n        if(cross(vec3(v1-p,0.),vec3(v2-v1,0.)).z < 0.)sig = 1.;\n    }\n    return sig*d;\n}\n\nfloat ngon_d(vec3 pos, int n, float r)\n{\n    vec2 p = pos.xy;\n    float delta = PI2/float(n);\n    float sig = -1.;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec2 v1 = vec2(r*cos(a1), r*sin(a1));\n        vec2 v2 = vec2(r*cos(a2), r*sin(a2));\n        if(cross(vec3(v1-p,0.),vec3(v2-v1,0.)).z < 0.)\n        {\n            sig = 1.;\n            break;\n        }\n    }\n    if(sig<0.)return abs(pos.z);\n    float d = 10000.0;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec3 v1 = vec3(r*cos(a1), r*sin(a1), 0.);\n        vec3 v2 = vec3(r*cos(a2), r*sin(a2), 0.);\n        d = min(d, line_d(pos, v1, v2));\n    }\n    return d;\n}\n\n\n\nfloat vertex_d(vec3 p, vec3 pos)\n{\n    const float vertex_size = .1;\n    return length(p-pos)-vertex_size;\n}\n\nfloat dodeca(vec3 p, float radius)\n{\n    // https://en.wikipedia.org/wiki/Pentagon\n    // https://en.wikipedia.org/wiki/Regular_dodecahedron\n    const float C1 = 4./(sqrt(3.)*(1.+sqrt(5.)));\n    const float C2 = .5*sqrt(2.5+1.1*sqrt(5.));\n    const float C3 = sqrt(2./(5.-sqrt(5.)));\n    const float C4 = .5*sqrt(5.+2.*sqrt(5.));\n    const float dihedral_angle = radians(116.57);\n    float edge_len = radius*C1;\n    float ri = edge_len*C2; // radius of the inscribed sphere.\n    float d = 10000.0;\n    vec3 bot_center = ri*vec3(0,-1,0);\n    float pent_rad = edge_len*C3;\n    float delta_angle = PI2/5.;\n    const float line_thickness = .05;\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        float a2 = float(i+1)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    float pent_height = edge_len*C4;\n    float small_height = pent_height*sin(dihedral_angle);\n    float dodeca_height = 2.*ri;\n    float smaller_height = dodeca_height - small_height;\n    float low_height = (ri-smaller_height);\n    vec3 low_center = low_height*vec3(0,-1,0);\n    float low_rad = radius*cos(asin(low_height/radius));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n\n    // top half\n    //const float offset_angle = 0.;\n    const float offset_angle = PI2/10.;\n    //float offset_angle = mix(0., PI2/10.,.5+.5*sin(iTime));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        float a2 = offset_angle+float(i+1)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n\n        // join both halves with edges\n        float a3 = float(i)*delta_angle;\n        vec3 v3 = low_center + low_rad*cos(a3)*vec3(1,0,0) + low_rad*sin(a3)*vec3(0,0,1);\n        d = min(d, line_d(p, v2, v3)-line_thickness);\n        float a4 = offset_angle+float(i-1)*delta_angle;\n        vec3 v4 = -low_center + low_rad*cos(a4)*vec3(1,0,0) + low_rad*sin(a4)*vec3(0,0,1);\n        d = min(d, line_d(p, v3, v4)-line_thickness);\n    }\n\n\n    return d;\n}\n\n\n\nfloat scene_d(vec3 p)\n{\n    //float d = length(p)-1.;\n    //float d = ngon_d(rot2d(p.xy-vec2(0,-1), radians(90.+10.*iTime)), 5, .5);\n    //vec3 axis = vec3(0,0,1);\n    //float d = ngon_d(rot3d(p, axis, radians(90.+10.*iTime)), 5, .5);\n    //float d = ngon_d(rot3d(p-vec3(1,-1,1), axis, radians(90.+10.*iTime)), 5, .5);\n    vec3 pp = rot3d(p,vec3(0,1,0), iTime);\n    float d = dodeca(pp, 1.);\n    d = min(d, p.y+4.); // ground plane\n    d = min(d, length(p.yz)-0.1); // x axis\n    d = min(d, length(p.xz)-0.1); // y axis\n    d = min(d, length(p.xy)-0.1); // z axis\n    return d;\n}\n\nvec3 get_normals(vec3 p)\n{\n    float x1 = scene_d(p-vec3(EPSILON,0,0));\n    float x2 = scene_d(p+vec3(EPSILON,0,0));\n    float y1 = scene_d(p-vec3(0,EPSILON,0));\n    float y2 = scene_d(p+vec3(0,EPSILON,0));\n    float z1 = scene_d(p-vec3(0,0,EPSILON));\n    float z2 = scene_d(p+vec3(0,0,EPSILON));\n\n    return normalize(vec3(x2-x1,y2-y1,z2-z1)/(2.*EPSILON));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam_pos = vec3(1,2,4);\n    vec3 lookat = vec3(0.);\n    vec3 cam_dir = normalize(lookat-cam_pos);\n    vec3 world_up = vec3(0,1,0);\n    vec3 cam_right = normalize(cross(cam_dir, world_up));\n    vec3 cam_up = normalize(cross(cam_right, cam_dir));\n    float focal_dist = 2.;\n    vec3 ro = cam_pos + cam_dir*focal_dist + cam_right*uv.x + cam_up*uv.y;\n    vec3 rd = normalize(ro - cam_pos);\n    float ray_dist = 0.;\n    vec3 col = vec3(0.);\n    bool hit = false;\n    for(int i = 0; i < MAX_ITERS; i++)\n    {\n        float d = scene_d(ro+rd*ray_dist);\n        if(d<EPSILON)\n        {\n            hit = true;\n            break;\n        }\n        ray_dist += d;\n    }\n    if(hit)\n    {\n        vec3 hit_pos = ro+rd*ray_dist;\n\t\tcol = get_normals(hit_pos);\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 134, 134, 275], [277, 277, 321, 321, 500], [502, 502, 540, 540, 659], [661, 661, 699, 699, 818], [820, 820, 873, 873, 994], [996, 996, 1028, 1028, 1054], [1056, 1056, 1094, 1094, 1487], [1489, 1489, 1529, 1529, 2226], [2230, 2230, 2264, 2264, 2338], [2340, 2340, 2376, 2480, 6266], [6270, 6270, 6293, 6588, 6849], [6851, 6851, 6877, 6877, 7210], [7212, 7212, 7267, 7267, 8170]], "test": "error"}
{"id": "3ljcDc", "name": "Waves v.2", "author": "pli", "description": "Still 2d, some textures and a boat.", "tags": ["learning"], "likes": 2, "viewed": 108, "published": "Public API", "date": "1595599866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADOW 0.03\n#define MULTIPLIER 0.6\n#define BASE_COLOR vec4(0.0, 0.18, 0.2 ,1.0)\n#define SHOW_TEXTURES true\n\n#define BOAT_COLOR vec4(1., 0.57, 0.0 ,1.0)\n#define HEAD_COLOR vec4(.7, .6, .4 ,1.0)\n#define EYE_COLOR vec4(0., 0.0, 0.0 ,1.0)\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    // from https://www.shadertoy.com/view/lsf3WH\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat heightAt(vec2 uv, float speed, float height, float vOffset) {\n    return height * cos(speed * iTime + uv.y * 2.0 + uv.x * 300.0 * height)\n        \t+ 0.3 * height * cos(speed * iTime + uv.x * 100.0 * height)\n        \t+ vOffset;\n}\n\nfloat covered(vec2 uv, float speed, float height, float vOffset) {\n    float distance = heightAt(uv, speed, height, vOffset) - uv.y;\n    \n    float covered;\n    if (distance > SHADOW) {\n        covered = 1.0;\n    } else if (distance > 0.) {\n        covered = distance / SHADOW;\n    } else {\n        covered = 0.0;\n    }\n    return covered;\n}\n\nfloat dist(vec2 p1, vec2 p2) {\n\treturn sqrt( (p1.x-p2.x) * (p1.x-p2.x) + (p1.y-p2.y) * (p1.y-p2.y));   \n}\n\nvec4 drawCircle(vec4 pixel, vec2 uv, vec2 position, float size, vec4 color) {\n    if (dist(uv, position) < size) {\n    \tpixel = color;   \n    }\n    return pixel;    \n}\n\nvec4 drawBoat(vec4 pixel, vec2 uv, vec2 position, float size) {\n\n\n    pixel = drawCircle(pixel, uv, vec2(position.x, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)) + 0.03, .015, HEAD_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x + 0.007, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)) + 0.03, .002, EYE_COLOR);\n\n    pixel = drawCircle(pixel, uv, vec2(position.x, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x+0.02, heightAt(vec2(position.x+0.02, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x+0.04, heightAt(vec2(position.x+0.04, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x+0.06, heightAt(vec2(position.x+0.06, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n\n    return pixel;\n}\n\nvec4 drawWave(vec4 pixel, vec2 uv, float speed, float height, float vOffset) {\n    float c = covered(uv, speed, height, vOffset);\n    if (c == 1.) {\n\t\tpixel += BASE_COLOR * MULTIPLIER;\n        \n        if (SHOW_TEXTURES) {\n            vec2 nUv = uv;\n            nUv.x += iTime * sqrt(speed) * 0.1;\n            nUv.y -= heightAt(uv, speed, height, vOffset);\n            pixel += .015 * noise(nUv * 20.);\n    \t}\n    } else if (c > 0.) {\n\t\tpixel *= vec4(vec3(sqrt(1.-c)) ,1.0);\n    }\n    \n\treturn pixel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 result;\n\tresult = vec4(0.0, 0.18, 0.2 ,1.0);\n\n    \n    result = drawWave(result, uv, 1.5, 0.02, 0.2);\n    vec2 boatPosition = vec2(.2 + 0.2 * cos(0.5*iTime) + 0.1 * cos(0.95*iTime), 0.);\n    result = drawBoat(result, uv, boatPosition, .025);\n\n//    vec2 boatPosition2 = vec2(.1 + 0.2 * cos(1.5*iTime) + 0.2 * cos(0.35*iTime), 0.);\n//    result = drawBoat(result, uv, boatPosition2, .025);\n\n    result = drawWave(result, uv, 2.5, 0.04, 0.0);\n    result = drawWave(result, uv, 5.0, 0.05, -0.25);\n\n    \n    // Output to screen\n    //result = vec4(vec3(noise(uv * 100.)), 1.);\n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 301, 301, 405], [407, 407, 433, 483, 777], [779, 779, 846, 846, 1013], [1015, 1015, 1081, 1081, 1356], [1358, 1358, 1388, 1388, 1463], [1465, 1465, 1542, 1542, 1632], [1634, 1634, 1697, 1697, 2480], [2482, 2482, 2560, 2560, 2984], [2986, 2986, 3043, 3093, 3791]], "test": "valid"}
{"id": "3ljcDK", "name": "Texting dots", "author": "acarolli", "description": "Texting, typing, writing animation ", "tags": ["text", "mobile"], "likes": 0, "viewed": 38, "published": "Public", "date": "1595389498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n    \n\tfloat c = smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*3.0);\n    return c;\n}\n\nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n\nfloat easeInOutBack(float x) {\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nvec2 anime(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 3.0;\n    \n    //  Give each cell an index number\n    //  according to its position\n    float indexX = 0.0;\n    // indexX += step(1., mod(_st.x,3.0));\n    indexX += step(1., mod(_st.x,2.0));\n    indexX += step(1., mod(_st.x,3.0));\n    \n    // Rotate each cell according to the index\n    if(indexX == 0.0){\n        _st.y += easeOutBounce(cos(iTime));\n    } else if(indexX == 1.0) {\n        _st.y += easeOutBounce(cos(iTime));\n    } else if(indexX == 2.0){\n        _st.y += easeInOutBack(sin(iTime));\n    }\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    if (ceil(_st.y) == 2.) index = 1.;\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index != 1.0){\n        _st = vec2(1.);\n    }\n\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    // Animate\n    st = anime(st);\n    // Output to screen\n    fragColor = vec4(vec3(circle(st, 0.4)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 91, 91, 284], [286, 286, 316, 316, 646], [648, 648, 678, 678, 887], [889, 889, 910, 954, 1787], [1789, 1789, 1846, 1896, 2046]], "test": "valid"}
{"id": "3ljcRt", "name": "Berx_Circle_02", "author": "berzerkey", "description": "More Practice with circles,  this time with cleaner edges.", "tags": ["practice"], "likes": 0, "viewed": 31, "published": "Public", "date": "1595097814", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution.xy\n#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Remaps coordinates to center.\n    uv -=.5;\n    \n    // Aspect Ratio fix along x.\n    uv.x *= res.x/res.y;\n    \n    // Driving Functions\n    float d = length(uv);\n    float rr = 0.3;\n    float rg = .2;\n    float rb = .05;\n    float red = smoothstep(rr, rr-.01, sin(d*t));\n    float green = smoothstep(rg, rg-.01, cos(d*t));\n    float blue = smoothstep(rb, rb-.01, d*sin(t));\n    \n    //if (d < .3) c = 1.; else c = 0.;\n\n    // Output to screen\n    fragColor = vec4(vec3(red,green,blue),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 151, 696]], "test": "valid"}
{"id": "3ljcRw", "name": "Strange trigonometric surface", "author": "jarble", "description": "This bizarre surface is defined using sine and cosine functions.", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 181, "published": "Public API", "date": "1593984946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat surface1(vec3 p){\n    //p.z += .0;\n    p += sin(p.zxy/2000.0)*(3000.0);\n    vec3 p1 = p/size/3.0;\n    p = p1*(cos(p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    p = sin(p/40000.0)*40000.0;\n    p /= 20.0;\n    float i = 27.0;\n    result = surface1(p*i)/(i);\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*1.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(.5+sin(p/3.0)/4.0)/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,70.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 517, 540, 557, 678], [682, 682, 706, 706, 940], [942, 942, 970, 970, 1031], [1034, 1455, 1546, 1546, 1852], [1867, 2121, 2186, 2186, 2318], [2320, 2409, 2438, 2438, 2748], [2750, 3242, 3382, 3382, 3992], [3994, 4364, 4449, 4449, 4864], [4866, 5193, 5242, 5277, 5408], [5410, 5410, 5467, 5467, 6374]], "test": "valid"}
{"id": "3ljcWt", "name": "Multicolor Spinner", "author": "ChocolatePinecone", "description": "A OSX-like multicolor spinner", "tags": ["spinner"], "likes": 2, "viewed": 63, "published": "Public", "date": "1595708436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n\n//  Function from Iigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x) + iTime * TWO_PI;\n    float radius = length(toCenter)*2.5;\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n\n    float dis = length(fragCoord.xy - 0.5 * iResolution.xy);\n    float shortestRes = min(iResolution.x, iResolution.y);\n    float ring = step(0.15 * shortestRes, dis) - step(0.45 * shortestRes, dis);\n    color = mix(vec3(0.0), color, ring);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 148, 174, 174, 407], [409, 409, 463, 463, 1159]], "test": "valid"}
{"id": "3ljcWw", "name": "NoiseShadow", "author": "solacefy", "description": "Soft Shadow With Noise", "tags": ["3d"], "likes": 0, "viewed": 126, "published": "Public API", "date": "1594534389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// IQ's SDF\n//https://iquilezles.org/\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nmat2 Rot(float a)\n{\n\tfloat s =sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat N21(vec2 p)\n{\n\tp = fract(p*vec2(233.34,851.73));\n    p+= dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n\tfloat n = N21(p);\n    return vec2(n,N21(p+n));\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdMagicCubesRows(vec3 p, vec3 b, float r)\n{\n\tvec3 h = p;\n    float offset = 0.49;\n    vec3 q1 = abs(p + vec3(0.,0., 0.)) - b;\n    vec3 q2 = abs(p + vec3(0.,-offset, 0.)) - b;\n    vec3 q3 = abs(p + vec3(0.,-2.*offset, 0.)) - b;\n    return min(min(length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0) - r\n        ,length(max(q2,0.0)) + min(max(q2.x,max(q2.y,q2.z)),0.0) - r), length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0) - r);\n\n}\n\nfloat sdMagicCubes3Rows(vec3 p, vec3 b, float r)\n{\n\tvec3 h = p;\n    float offset = 0.49;\n    float c1 = sdMagicCubesRows(p + vec3(-offset,0.,0.), b, r);\n    float c2 = sdMagicCubesRows(p + vec3(-0.,0.,0.),b,r);\n    float c3 = sdMagicCubesRows(p + vec3(-offset *2.,0.,0.),b,r);\n    return min(c1,min(c2,c3));\n}\n\nfloat sdMagicCubes(vec3 p, vec3 b, float r)\n{\n    vec3 h = p;\n    float offset = .49;\n    float c1 = sdMagicCubes3Rows(p + vec3(0.,0.,-offset), b,r);\n    float c2 = sdMagicCubes3Rows(p + vec3(0.,0.,-offset*2.), b,r);\n    float c3 = sdMagicCubes3Rows(p + vec3(0.,0.,-0.), b,r);\n    return min(c1,min(c2,c3));\n    \n}\n\nfloat sdCubes(vec3 p, vec3 b, float r, vec3 offset, vec3 rowoff)\n{\n\tvec3 q1 = (abs(p + rowoff) - b) ;\n    vec3 q2 = abs(p - offset + rowoff) - b;\n    vec3 q3 = abs(p - offset*2. + rowoff) - b;\n    \n    //vec3 q = q1+q2+q3;\n    //q1.xz *= Rot(iTime);\n    return min(min(length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0) - r,\n               length(max(q2,0.0)) + min(max(q2.x,max(q2.y,q2.z)),0.0) - r),\n             length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0) - r);\n    //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 posr = pos;\n    posr.xz *= Rot(iTime);\n    vec3 posrX = pos;\n    posrX.yx *= Rot(iTime);\n    \n    float rt = 0.;\n    float t = clamp(fract(iTime),0.5,1.);\n\tfloat d1 = length(pos) - 0.25;\n    \n    float d2= pos.y - (-0.25);\n    \n    vec3 h = pos;\n    \n    h.xz = (mat2(3,4,-4,3)/5.0)*h.xz;\n    h.yz = (mat2(3,4,-4,3)/5.0)*h.yz;\n    \n    posrX.xz = (mat2(3,4,-4,3)/5.0)*posrX.xz;\n    posrX.yz = (mat2(3,4,-4,3)/5.0)*posrX.yz;\n    \n    \n    float d3 = sdTorus((posrX - vec3(-0,.5,0.6)).xzy * vec3(1.,1.,1.) + vec3(0.,0.,rt), vec2(.99, .082));\n    \n    float d4 = sdBoundingBox((pos - vec3(0.,0.8,0.)).xzy, vec3(1) ,.045);\n    \n    float d5 = sdRoundBox(pos, vec3(.2,.2,.2), .05);\n    \n    //float posr = pos;\n \n    float d6 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,0.5));\n    float d7 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,-0.5));\n\tfloat d8 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,0.));\n    \n    float dm = sdMagicCubes(posr, vec3(.2,.2,.2), .05);\n    \n    \n    float dc = min(min(d6,d7),d8);\n    \n  \n    \n   \n    \n    //return smin(min(d2,dc),d3, .03);\n  \t//return smin(dc,d3, .03);\n\treturn smin( smin(dm, d3,.03),d2, .03);\n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, float time)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i<5; i++)\n    {\n    \tfloat h = 0.01 + 0.11 * float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.);\n\treturn normalize(vec3(map(pos+e.xyy) - map(pos-e.xyy),\n                         map(pos+e.yxy) - map(pos-e.yxy),\n                         map(pos+e.yyx) - map(pos-e.yyx)));\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    \n    float k = 10.0;\n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + t*rd;\n\n        float h = map(pos);\n        if(h<0.001)\n        {\n        \tbreak;\n        }\n        t+= h;\n        if(t>20.0) break;       \t         \n    }\n    if(t>20.0) t = -1.0;\n    return t;\n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    vec3 col = vec3(0.46,0.4,0.42);\n    for(int m=0; m<AA;m++)\n    for(int n=0; n<AA; n++)\n    {\n    \tvec2 off = -.5 + vec2(float(m),float(n))/ float(AA);\n        \n        vec2 p = (2.0*(fragCoord+off) - iResolution.xy)/iResolution.y;\n\n        //float an = 0.1 * iTime;\n        float an = 10.0 * iMouse.x/iResolution.x;\n        //oat anz = 10.0 * iMouse.y/iResolution.y;\n        vec3 ro =  2.5 * vec3(1.0*sin(an),.2, 1.0*cos(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n\n        vec3 ww = normalize(ta-ro);\n        vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize(cross(uu,ww));\n\n\n        vec3 rd = normalize(p.x*uu + p.y*vv + 1.1*ww);\n\n        //vec3 col = vec3(0.18,0.1,0.2) - .5 * rd.y;\n        \n        float noise = smoothstep(-0.05 , .99 , N21(p));\n        col *= max(vec3(noise), col*1.85);\n\n        float t = castRay(ro,rd);\n\n\n        if(t>0.0)\n        {\n            float time= iTime;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 mate = vec3(0.18);\n            vec3 sun_lig = normalize(vec3(0.6,0.35,0.5));\n            float occ = calcOcclusion( pos, nor, time )* .8;\n            vec3 sun_dir = normalize(vec3(0.8,0.4,0.8));\n            float sun_dif = clamp(dot(nor,sun_dir), 0.0,1.0);\n            //float sun_sha = step(castRay(pos+nor*0.001, sun_dir), 0.0);\n            //soft one\n\n\n            float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\n            float sky_dif = clamp(.5 + .5 * dot(nor, vec3(0.,1.,0.)), 0.0,1.0);\n            float bou_dif = clamp(.5 + .5 * dot(nor, vec3(0.,-1.,0.)), 0.0,1.0);\n            //col = mate*vec3(7.0,4.5,3.0) * sun_dif*sun_sha;\n\n            //Use black and white\n            col = vec3(1.5,1.5,1.5) * vec3(0.5,.5,.5) * sun_dif*sun_sha*occ;\n            //col += vec3(1.0,1.0,1.0)*vec3(0.1,0.0,0.0) * sky_dif;        \n            //col += vec3(1.0,1.0,1.0)*vec3(0.,0.0,0.0) * bou_dif;\n            col += mate*vec3(0.5,0.8,0.9) * sky_dif;        \n            col += mate*vec3(0.7,0.3,0.2) * bou_dif;\n\n            float noise = smoothstep(-0.05 , .99 , N21(pos.xy));\n\n\n            col *= max(vec3(noise), col*1.85);\n            //col = vec3(1.);\n            \n           \n        }\n        \n        \n        col = pow(col, vec3(0.4545));\n        tot += col;\n    }\n    \n    tot /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 79, 79, 151], [153, 153, 172, 172, 241], [243, 243, 262, 262, 350], [352, 352, 370, 370, 420], [424, 424, 457, 457, 522], [524, 524, 572, 572, 859], [861, 861, 906, 906, 997], [999, 999, 1048, 1048, 1446], [1448, 1448, 1498, 1498, 1757], [1759, 1759, 1804, 1804, 2073], [2075, 2075, 2141, 2141, 2628], [2630, 2630, 2654, 2654, 3857], [3859, 3859, 3918, 3918, 4198], [4200, 4200, 4230, 4230, 4437], [4439, 4439, 4499, 4499, 4814], [4816, 4816, 4852, 4852, 5126], [5143, 5143, 5200, 5200, 7597]], "test": "valid"}
{"id": "3ljcWy", "name": "Rope", "author": "fizzgig", "description": "ropes are made of sierpinski gaskets right", "tags": ["rope"], "likes": 19, "viewed": 357, "published": "Public API", "date": "1595274659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    float strongth;\n    vec3 color;\n};\n\n#define PI 3.1415926\n    \nmat4 euler(float x, float y, float z) {\n    mat4 xmat = mat4(vec4(1.0,  0.0,    0.0,    0.0),\n                     vec4(0.0,  cos(x), sin(x), 0.0),\n                     vec4(0.0, -sin(x), cos(x), 0.0),\n                     vec4(0.0,  0.0,    0.0,    1.0));\n    mat4 ymat = mat4(vec4( cos(y), 0.0, sin(y), 0.0),\n                     vec4( 0.0,    1.0, 0.0,    0.0),\n                     vec4(-sin(y), 0.0, cos(y), 0.0),\n                     vec4( 0.0,    0.0, 0.0,    1.0));\n    mat4 zmat = mat4(vec4( cos(z),  sin(z), 0.0, 0.0),\n                     vec4(-sin(z),  cos(z), 0.0, 0.0),\n                     vec4( 0.0,     0.0,    1.0, 0.0),\n                     vec4( 0.0,     0.0,    0.0, 1.0));\n    \n    return xmat*ymat*zmat;\n}\n\nmat4 transform(float x, float y, float z) {\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(x,   y,   z,   1.0));\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(point - center) - radius;\n}\n\nfloat planeSDF(vec3 origin, vec3 normal, vec3 point) {\n    return dot(point - origin, normal);\n}\n\nfloat ropeSDF(float coiledness, uint n, vec3 point) {\n    for (uint i = 0u; i < n; ++i) {\n        float r = length(point.xz);\n    \tfloat t = atan(-point.x, -point.z) + PI;\n        \n        t -= 2.0*PI*coiledness;\n        t = mod(t, 2.0*PI/3.0) + 2.0*PI/3.0;\n        \n        point.x = r*sin(t);\n        point.z = r*cos(t);\n        \n        point.z += 1.0;\n        point.xz *= 1.0 + 1.0/sin(PI/3.0);\n        //point.z *= -1.0;\n    }\n    \n    point.xz /= 1.0 + sin(PI/3.0);\n    \n    float lpxz = length(point.xz);\n    \n    vec2 d = vec2(lpxz, abs(point.y + 0.5)) - vec2(1.0,0.5);\n    \n    for (uint i = 0u; i < n; ++i) d.x /= 1.0 + 1.0/sin(PI/3.0);\n    \n    d.x *= 1.0 + sin(PI/3.0);\n    \n    return min(max(d.x,d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sceneSDF(vec3 point) {\n    point.y /= 20.0;\n    return ropeSDF(1.0-(0.5*sin(iTime*0.2)+0.5)*(point.y+1.0), 6u, point);\n   /*return min(\n       min(\n           min(\n               sphereSDF(vec3(-0.7, 0.7, 0.0), 0.5, point),\n               sphereSDF(vec3(0.7, 0.7, 0.0), 0.5, point)\n           ),\n           sphereSDF(vec3(0.0), 1.0, point)\n       ),\n       planeSDF(vec3(0.0), vec3(0.0, 1.0, 0.0), point)\n     );\n   */\n}\n\nvec3 sceneSDFGradient(vec3 point, float epsilon) {\n    vec3 xe = vec3(epsilon, 0.0, 0.0)/2.0;\n    vec3 ye = vec3(0.0, epsilon, 0.0)/2.0;\n    vec3 ze = vec3(0.0, 0.0, epsilon)/2.0;\n    \n    return vec3(\n        (sceneSDF(point + xe) - sceneSDF(point - xe)) / epsilon,\n        (sceneSDF(point + ye) - sceneSDF(point - ye)) / epsilon,\n        (sceneSDF(point + ze) - sceneSDF(point - ze)) / epsilon\n      );\n}\n\nvec3 sceneSDFNormal(vec3 point) {\n    return normalize(sceneSDFGradient(point, 0.01));\n}\n\nvec3 rayPoint(Ray ray, float dist) {\n    return ray.origin + dist * ray.direction;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return vec3(1.0) - (vec3(1.0) - a)*(vec3(1.0) - b);\n}\n\nvec3 lightPoint(Light light, vec3 point, vec3 normal, vec3 camera, vec3 diffuse, vec3 bounce, vec3 current) {\n    vec3 lightchord = light.position - point;\n    \n    vec3 lightcolor = light.color * 1.0 / pow(length(lightchord/3.0)/light.strongth+1.0, 2.0);\n    \n    vec3 colour = diffuse * lightcolor * max(dot(normal, normalize(lightchord)), 0.0);\n    colour = screen(colour, bounce * lightcolor * max(vec3(1.0) - 5.0*(vec3(1.0) - dot(normalize(lightchord), reflect(normalize(point - camera), normal))), 0.0));\n    \n    return screen(current, colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lightangle = iTime;\n    \n    Light light1 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(1.0, 0.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light2 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(0.0, 1.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light3 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(0.0, 0.0, 1.0));\n    \n    float disttoscreen = 1.0;\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 camorigin = vec3(-6.0, 6.0, 0.0);\n    \n    mat4 camtoscene = transform(camorigin.x, camorigin.y, camorigin.z)*euler(PI*0.5, -PI*0.18, 0.0);\n    \n    Ray ray = Ray((camtoscene*vec4(vec3(0.0),1.0)).xyz,\n                  normalize(camtoscene*vec4(uv.x, uv.y, disttoscreen, 0.0)).xyz);\n    \n    vec3 point = camorigin;\n    \n    float scenedist = sceneSDF(point);\n    float raydist = 0.0;\n    \n    float epsilon = 0.001;\n    float end = 100.0;\n    \n    while (scenedist > epsilon) {\n        if (raydist > end) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        \n        point = rayPoint(ray, raydist);\n        \n        scenedist = sceneSDF(point);\n        \n        raydist += scenedist;\n    }\n    \n    vec3 normal = sceneSDFNormal(point);\n    vec3 diffuse = vec3(1.0);\n    vec3 bounce = vec3(1.0);\n        \n    vec3 colour = lightPoint(light1, point, normal, camorigin, diffuse, bounce, vec3(0.0));\n    colour = lightPoint(light2, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light3, point, normal, camorigin, diffuse, bounce, colour);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 193, 193, 882], [884, 884, 927, 927, 1098], [1100, 1100, 1156, 1156, 1202], [1204, 1204, 1258, 1258, 1300], [1302, 1302, 1355, 1355, 2047], [2049, 2049, 2077, 2077, 2475], [2477, 2477, 2527, 2527, 2883], [2885, 2885, 2918, 2918, 2973], [2975, 2975, 3011, 3011, 3059], [3061, 3061, 3090, 3090, 3148], [3150, 3150, 3259, 3259, 3703], [3705, 3705, 3762, 3762, 5501]], "test": "valid"}
{"id": "3ljyDW", "name": "Wavy Weave", "author": "Oggbog", "description": "Wobbly repeating weave pattern", "tags": ["pattern", "repeating"], "likes": 6, "viewed": 257, "published": "Public API", "date": "1594382392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 uv, float r, float t){\n    float m = (step(r,abs(uv.x)))*.5-step(abs(uv.y),.5-r-t);\n    m = max(m,(step(r,abs(uv.y)))*.5);\n    m += (step(r+t,abs(uv.x)))-step(abs(uv.y),.5-r-t/4.);\n    m = max(m,(step(r+t,abs(uv.y))));\n    float p = (step(r,abs(uv.x))-step(r+t,abs(uv.x))-step(abs(uv.y),r+t))/2.;\n    if (p>0.) m -= .5;\n    return m;\n}\nfloat cros(vec2 uv, float r, float t){\n    float m = step(abs(uv.x),r+t)*0.5;\n    m = max(m,step(abs(uv.y),r+t)*0.5);\n    m += step(abs(uv.x),r);\n    m = max(m,step(abs(uv.y),r)-step(abs(uv.x),r+t));\n    \n    \n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y += cos(uv.y*3.+uv.x*4.+iTime*2.)*.05;\n    float a = 3.142/4.;  \n    uv = uv*mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    uv = fract(uv * 5.)-.5;\n    vec3 col = vec3(0.);\n\t\n    float m = cros(uv,.15,.04);\n    col += m;\n    m = box(uv,.3,.04);\n    \n    if (m>0.) col = vec3(m);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 350], [351, 351, 389, 389, 581], [583, 583, 640, 640, 1051]], "test": "valid"}
{"id": "3ljyRy", "name": "PerlinNoise Sample", "author": "Johnblu", "description": "perlin噪音的几种表现形式", "tags": ["noise"], "likes": 3, "viewed": 86, "published": "Public", "date": "1594702716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(612.1,946.7)),\n              dot(p,vec2(735.5,354.3)));\n    \n    float time = iTime * 1.0;\n    vec2 rotVec0 = vec2(cos(time), -sin(time));\n    vec2 rotVec1 = vec2(sin(time), cos(time));\n    mat2 rot = mat2(rotVec0,rotVec1);\n\n    vec2 vertexDir = -1.0 + 2.0 * fract(sin(p)*(43758.5453));\n    //以下是以旋转梯度向量的方式让纹理动起来，但是会出现周期性\n    //还有种让纹理动起来的方式是用更高维度的噪音图，其中一个维度是时间维度\n    vertexDir = normalize(rot * vertexDir);\n    return vertexDir;\n}\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\t\n    //以下两个是前人提出的缓和曲线\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\t//一阶导数连续\n    vec2 w = pf * pf * pf * (pf * pf * 6.0 - pf * 15.0 + 10.0);\t//二阶导数连续\n\n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (vec2(fragCoord.x, fragCoord.y) / min(iResolution.x, iResolution.y));\n\tvec2 mouseUv = (vec2(iMouse.x, iMouse.y) / min(iResolution.x, iResolution.y));\n    \n    if(mouseUv.x < 1e-4 && mouseUv.y < 1e-4)\n    {\n        mouseUv = vec2(iResolution.x / iResolution.y * 0.5,0.5);\n    }\n    \n    vec2 divisionUv = uv;\n    uv = uv * (6.0);\n    float result = 0.0;\n    if(divisionUv.x < mouseUv.x && divisionUv.y > mouseUv.y)\n    {\n        result = perlin_noise(uv);\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x < mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * perlin_noise(uv);\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * perlin_noise(uv);\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * perlin_noise(uv);\t\tuv *= 2.0;\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x > mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    }\n\telse\n    {\n        result += 4.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(perlin_noise(uv));\t\tuv *= 2.0;\n        \n        result = cos(result + uv.x * 0.1);\n    }\n    \n    fragColor = vec4(result,result,result,1);\n    float divisionLine = (1.0 - abs(mouseUv.x - divisionUv.x) * 400.0)\n        * (1.0 - abs(mouseUv.y - divisionUv.y) * 400.0);\n    divisionLine = clamp(divisionLine,0.0,1.0);\n    fragColor = mix(vec4(1,1,1,1),fragColor,divisionLine);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 601], [602, 602, 630, 630, 1211], [1213, 1213, 1270, 1270, 2903]], "test": "valid"}
{"id": "3ljyWt", "name": "star field 4 regolfed (311 ch)", "author": "FabriceNeyret2", "description": "regolfing \"star field 4 (433 chars)\" [url]https://shadertoy.com/view/ltBXDd[/url]\n\n", "tags": ["texture", "advection", "starfield", "short", "golf", "3tweets"], "likes": 5, "viewed": 354, "published": "Public API", "date": "1595706652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// regolfing \"star field 4 (433 chars)\" by FabriceNeyret2. https://shadertoy.com/view/ltBXDd\n// ( more readable below )\n\n\n#define R  fract( 1e4* sin(  mat2(1234,-53,457,-17) * I//\n#define M(U,i)  (                                                 \\\n     I = ceil( V = U * (t.i+.75) / exp2(t.i*8.-5.) ),             \\\n     r = .13 + 6.* R +1.)),                                       \\\n\t r.x > .79 ? 1. : dot( V = ( .6*R))-.8 - V+I ) / r.x , V ) ) //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = u / iResolution.y - .5, I,V,r;\n    vec3 t = fract( iTime/8. + vec3(-1,0,1)/3.  ) -.5;\n    O += dot( 1.+cos(6.28*t) , .015/vec3( M(U,x), M(-U,y), M(U.yx,z) ) );} /*\n\n\n\n\n\n// --- 313 chars\n\n#define R  fract( 1e4* sin(  mat2(1234,-53,457,-17) * I//\n#define M(U,i)  (                                                 \\\n     I = ceil( V = U * (t.i+.75) / exp2(t.i*8.-5.) ),             \\\n     r = R +1.)),                                                 \\\n\t r.x > .11 ? 1. : dot( V = ( .6*R))-.8 - V+I ) / (.13+6.*r.x) , V ) ) //\n#define mainImage(O,u)                                            \\\n    vec2 U = u / iResolution.y - .5, I,V,r;                       \\\n    vec3 t = fract( iTime/8. + vec3(-1,0,1)/3.  ) -.5;            \\\n    O += dot( 1.+cos(6.28*t) , .015/vec3( M(U,x), M(-U,y), M(U.yx,z) ) ) /*\n\n\n\n\n\n// --- 327 chars\n\n#define R(U) fract( 1e4* sin(  U * mat2(1234,-53,457,-17) ) )    //\n#define M(U,i)  (                                                 \\\n     I = ceil( V = U * ( (t+6./D) /exp2(t*D-5.) ).i ),            \\\n     r = R(1.+I).x,                                               \\\n\t r > .11 ? 1. : dot( V = ( .6*R(I)-.8 - V+I ) / (.13+6.*r) , V ) ) //\n#define mainImage(O,u)                                            \\\n    float D=8.,r;                                                 \\\n    vec2 U = u / iResolution.y - .5, I,V;                         \\\n    vec3 t = fract( iTime/D + vec3(-1,0,1)/3.  ) -.5;             \\\n    O += dot( 1.+cos(6.28*t) , .015/vec3( M(U,x), M(-U,y), M(U.yx,z) ) ) /*\n\n\n\n\n\n// --- 345 chars\n\n#define R(U) fract( 1e4* sin(  U*mat2(1234,-53,457,-17) ) )      //\n#define M(U,t)  (                                                 \\\n     I = ceil( V = U/exp2(t-8.) / D*(3.+t) ),                     \\\n     r = 9.* R(1.+I).x,                                           \\\n\t r > 1. ? 1. : length( .6*R(I)-.8 - V+I ) * 8./(1.+5.*r) )   //\n#define mainImage(O,u)                                            \\\n    float D=8.,r;                                                 \\\n    vec2 U = u / iResolution.y - .5, I,V;                         \\\n    vec3 t = fract( iTime/D + vec3(-1,0,1)/3.  ) -.5,             \\\n         T = t*D+3.;                                              \\\n    T = vec3( M(U,T.x), M(-U,T.y), M(U.yx,T.z) );                 \\\n    O += dot( .5+.5*cos(6.28*t) , .03/T/T )                                          /*\n\n\n\n\n\n// --- 368 chars\n\n#define R(U,d) fract( 1e4* sin( d + U*mat2(1234,-53,457,-17) ) ) //\n#define M(U,t)  (                                                 \\\n     I = ceil( V = U/exp2(t-8.) / D*(3.+t)),                      \\\n     r = 9.* R(I,1.).x,                                           \\\n\t r > 1. ? 1. : length( .2+.6*R(I,) - fract(V) ) * 8./(1.+5.*r) ) //\n#define mainImage(o,u)                                            \\\n    float D=8.,r;                                                 \\\n    vec2 U = u / iResolution.y - .5, I,V;                         \\\n         t = fract( iTime/D + vec3(-1,0,1)/3. +.5 ) -.5,  T,      \\\n         w = .5+.5*cos(6.28*t);                                   \\\n    t = t*D+3.;                                                   \\\n    T.x = M(U,t.x),  T.y = M(-U,t.y),  T.z = M(U.yx,t.z);         \\\n    o += dot(w,.03/T/T)                                          /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 485, 485, 659]], "test": "valid"}
{"id": "3ljyWV", "name": "Study about procedural warping 2", "author": "D4v1D", "description": "Freely inspired by https://www.shadertoy.com/view/MdSXzz\nWill be a work in progress for long time, as a study about procedural shaders\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonComm", "tags": ["procedural", "warping"], "likes": 2, "viewed": 62, "published": "Public", "date": "1595857797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat2 m=mat2(dot(sin(0.03),cos(0.1))*length(sin(0.2)*sinh(1.9)),tan(.02),   //column1\n                  cos(0.01),fract(.01)); //column2\n\nfloat hash(vec2 p)\n\t{float h=cos(0.01)+dot(p,vec2(1.,1.)); return -1.01+2.0-fract(sin(h)*9.1);}\n\nfloat noise( in vec2 p) \n{   vec2 i = floor(p); vec2 f = (fract(p*0.9)); vec2 u = asin(f)*sin(f-0.01)*(3.-2.0*+f);\n    return mix(mix( hash(i + vec2(0.0,0.0)), hash( i + vec2(3.0,.0)), u.x),\n               mix( hash( i + vec2(.0,1.0)), hash( i + vec2(1.0,1.0)), u.x), u.y); }\n\nfloat fbm(vec2 p) \n{   float f = 0.03;\n          f -= 0.33-noise(p);\n          p += m*p*0.09; return f*1.4;}\n\nvec2 fbm2( in vec2 p) \n\t{return vec2( fbm(p.xy), fbm(p.xy) );}\n\nvec3 map( vec2 p )\n{   p *= 1.0; \n    float f = dot(fbm2(log2(.6)*(iTime*0.11 - sin(noise(sin(p)))*fbm2(0.9-(sign(p) - fbm2(3.0*p)))) ), vec2(0.5,0.8));\n    float bl = smoothstep(0.0,-1.0,f);\n    float ti = asinh(bl)-smoothstep(.0,1.0, fbm((p*f+bl)) ); // highlight color amount;\n    return mix(mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),bl/f), vec3(1.0,0.0,0.0),ti);}     \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 p = (-iResolution.xy+12.0*fragCoord.xy)/iResolution.y;\n    float e = 2.0;\n    vec3 colc = map(e+p);\n    float gc = dot(colc,vec3(30.));\n    vec3 cola = map(sin(p)*sin(e)*.9 + dot(colc,vec3(.0)) - vec2(e,3.0));\n    float ga = dot(cola,vec3(6.1));\n    vec3 colb = map(p - vec2(4.0,e));\n \t \n    float gb = dot(colb,vec3(0.333));\n    //vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n    vec3 col = colc; // colc becomes col\n    col += vec3(.1,0.0,.741)*.1*abs(.20*gc*ga-gb); // defines color for highlight in outlines/borders\n    vec2 q = -fragCoord.xy/iResolution.xy; // this traces screen coordinates;\n    col *= pow(1.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);  // canva vignette   \n   \n    fragColor = vec4(col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 164, 164, 238], [240, 240, 266, 266, 515], [517, 517, 537, 537, 625], [627, 627, 652, 652, 689], [691, 691, 711, 711, 1056], [1063, 1063, 1120, 1120, 1842]], "test": "error"}
{"id": "3ljyWz", "name": "Fractal city", "author": "gaz", "description": "inspired https://www.shadertoy.com/view/MtdBD8", "tags": ["fractal"], "likes": 32, "viewed": 470, "published": "Public", "date": "1594133743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @FabriceNeyret2 thanks. \n\n// I rewrote it without a weight constant that I didn't understand.\n// Instead, a zoom constant is used to reduce color rippling\n\nstruct Data {\n    float interval;\n    vec3 pos0, pos1, dir0, dir1;\n    float up;\n};\n\nData data[] = Data[]( \n\tData(8., vec3(.9,1.2,.4), vec3(.6,1,.8),  vec3(1,0,1), vec3(1,1,0),  0.),\n    Data(9., vec3(0,.3,.6),   vec3(0,0,.6),   vec3(0,1,1), vec3(1,1,1),  2.),\n    Data(8., vec3(0,0,.4),    vec3(0,0,1.2),  vec3(1,0,1), vec3(1,1,1), -3.),\n    Data(8., vec3(0,.4,.7),   vec3(.4,0,.7),  vec3(1,1,0), vec3(0,1,1),  0.),\n    Data(7., vec3(.6,.6,.3),  vec3(.6,.8,0),  vec3(1,0,1), vec3(1,1,0),  3.),\n    Data(9., vec3(-.8,.4,.6), vec3(-.8,.6,0), vec3(0,0,1), vec3(1,0,1),  1.)\n);\n\n\n#define fold45(p)(p.y>p.x)?p.yx:p\nfloat map(vec3 p)\n{\n    float scale = 2.1,\n           off0 = .8,\n           off1 = .3,\n           off2 = .83;\n    vec3 off =vec3(2.,.2,.1);\n\tfloat s=1.0;\n\tfor(int i = 0;++i<20;)\n\t{\n\t\tp.xy = abs(p.xy);\n\t\tp.xy = fold45(p.xy);\n\t\tp.y -= off0;\n\t\tp.y = -abs(p.y);\n\t\tp.y += off0;\n\t\tp.x += off1;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x -= off2;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x += off1;\n\t\tp -= off;\n\t\tp *= scale;\n\t\tp += off;\n\t\ts *= scale;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx, size = data.length();\n\tfloat sam = 0.;\n    for(int i=0;i<size;i++) sam += data[i].interval;\n    float time = mod(iTime,sam);\n    sam = 0.;\n    for(idx=0; idx<size && time>sam; idx++)\n        sam += data[idx].interval;\n    Data P = data[idx-1];\n    // ++++++++++\n    // float t = (time-sam+P.interval)/P.interval;\n    // This is correct.\n    // However, I decided the camera control without noticing it, so changing it will break the picture.\n    // So this time, I'm using it while making a mistake.\n    float t = (time-sam)/P.interval;\n    const float zoom = 2.5;\n\tvec2  R = iResolution.xy,\n         uv = (2.*fragCoord-R)/R.y;\n    vec3 ro = mix(P.pos0, P.pos1, t) * zoom,\n          w = normalize(mix(P.dir0, P.dir1, t)),\n          u = normalize(cross(w,vec3(sin(P.up),cos(P.up),0))),\n         rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\n    float h = 0.0,d,i;\n    vec3 p;\n    for(i=1.;i<100.;i++)\n    {\n        p = ro+rd*h;\n        p /= zoom;\n\t    d = map(p);\n        if(d<0.001 || h>8.) break;\n        h += d;\n    }\n\tfragColor.xyz = 30.*vec3(cos(p*1.2)*.5+.5)/i;\n}\n\n\n/*\nstruct Data {\n    float interval;\n    vec3 pos0, pos1, dir0, dir1;\n    float grad, weight;\n};\n    \n//const Data Z = Data(0.,vec3(0),vec3(0),vec3(0),vec3(0),0.,0.);\nData data[] = Data[]( \n\tData(8., vec3(2.3,3,1), vec3(1.5,2.5,2),vec3(1,0,1), vec3(1,1,0),  .2, .4),\n    Data(9., vec3(0,1,2),   vec3(0,0,2),    vec3(0,1,1), vec3(1,1,1),  2., .3),\n    Data(8., vec3(0,0,1),   vec3(0,0,3),    vec3(1,0,1), vec3(1,1,1), -3., .4),\n    Data(8., vec3(0,1,1.7), vec3(1,0,1.7),  vec3(1,1,0), vec3(0,1,1),  0., .4),\n    Data(7., vec3(2,2,1),   vec3(2,2.5,0),  vec3(1,0,1), vec3(1,1,0),  3., .3),\n    Data(9., vec3(-2,1,1.5),vec3(-2,1.5,0), vec3(0,0,1), vec3(1,0,1),  1., .4)\n);\n\n#define fold45(p)(p.y>p.x)?p.yx:p\nfloat map(vec3 p)\n{\n    float scale = 2.1,\n           off0 = 0.8,\n           off1 = 0.3,\n           off2 = 0.83;\n    vec3 off = vec3(2.,.2,.1);\n\tfloat s = 1.0;\n\tfor(int i = 0;++i<20;)\n\t{\n\t\tp.xy = abs(p.xy);\n\t\tp.xy = fold45(p.xy);\n\t\tp.y -= off0;\n\t\tp.y =- abs(p.y);\n\t\tp.y += off0;\n\t\tp.x += off1;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x -= off2;\n\t\tp.xz = fold45(p.xz);\n\t\tp.x += off1;\n\t\tp -= off;\n\t\tp *= scale;\n\t\tp += off;\n\t\ts *= scale;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx, size = data.length();\n\tfloat sam = 0.;\n    for(int i=0; i<size; i++) sam += data[i].interval;\n    float time = mod(iTime,sam);\n    sam = 0.;\n    for(idx=0; idx<size && time>sam; idx++)\n        sam += data[idx].interval;\n    Data P = data[idx-1];\n    float t = (time-sam)/P.interval;\n\tvec2  R = iResolution.xy,\n         uv = (2.*fragCoord-R)/R.y;\n    vec3 ro = mix(P.pos0, P.pos1, t),\n         up = vec3(sin(P.grad),cos(P.grad),0),\n          w = normalize(mix(P.dir0, P.dir1, t)),\n          u = normalize(cross(w,up)),\n         rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\n    float h = 0.0, d, i;\n    vec3 p;\n    for(i=0.; i<160.; i++)\n    {\n        p = ro+rd*h;\n        p *= P.weight;\n\t    d = map(p);\n        if(d < 0.001 || t > 20.) break;\n        h += d;\n    }\n\tfragColor.xyz = 20.*vec3(cos(p*1.2)*.5+.5)/i;\n}\n*/\n\n\n/*\n#define SIZE 10\nfloat interval[SIZE];\nvec3 pos0[SIZE];\nvec3 pos1[SIZE];\nvec3 dir0[SIZE];\nvec3 dir1[SIZE];\nfloat grad[SIZE];\nfloat weight[SIZE];\nint idx;\n\nvoid registPhase(float i,vec3 p0, vec3 p1, vec3 d0, vec3 d1, float g, float w)\n{\n interval[idx] = i;\n pos0[idx] = p0;\n pos1[idx] = p1;\n dir0[idx] = d0;\n dir1[idx] = d1;\n grad[idx] = g;\n weight[idx] = w;\n idx++;\n}\n\n#define fold45(p)(p.y>p.x)?p.yx:p\nfloat map(vec3 p)\n{\n    float scale=2.1;\n    float off0=0.8;\n    float off1=0.3;\n    float off2=0.83;\n    vec3 off =vec3(2.,.2,.1);\n\tfloat s=1.0;\n\tfor(int i = 0;++i<20;)\n\t{\n\t\tp.xy=abs(p.xy);\n\t\tp.xy=fold45(p.xy);\n\t\tp.y-=off0;\n\t\tp.y=-abs(p.y);\n\t\tp.y+=off0;\n\t\tp.x+=off1;\n\t\tp.xz=fold45(p.xz);\n\t\tp.x-=off2;\n\t\tp.xz=fold45(p.xz);\n\t\tp.x+=off1;\n\t\tp-=off;\n\t\tp*=scale;\n\t\tp+=off;\n\t\ts*=scale;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfor(int i=0; i<SIZE; i++)interval[i] = 0.0;\n\tidx=0;\n\tregistPhase(8.0, vec3(1.8,1.5,1.8), vec3(1.5,1.8,1.6), vec3(1,0,1), vec3(1,1,0),  0.2, 0.4);\n\tregistPhase(9.0, vec3(0,1,2), vec3(0,0,2), vec3(0,1,1), vec3(1,1,1),  2.0, 0.3);\n\tregistPhase(8.0, vec3(0,0.5,1), vec3(0,0.3,3), vec3(1,0,1), vec3(1,1,1),  -3.0, 0.4);\n    registPhase(8.0, vec3(0,1,1.7), vec3(1,0,1.7), vec3(1,1,0), vec3(0,1,1),  0.0, 0.4);\n    registPhase(7.0, vec3(2.1,-1.7,1), vec3(2,-1.4,1.8), vec3(-1,0,1), vec3(-1,.2,0.8),  3.0, 0.3);\n    registPhase(9.0, vec3(-2,1,1.2), vec3(-2,1.2,1.0), vec3(0,0,1), vec3(1,0,1),  1.0, 0.5);\n\tfloat sam = 0.0;\n\tfor(int i=0; i<SIZE; i++)sam += interval[i];\n\tfloat time=mod(iTime,sam);\n\tsam = 0.0;\n\tfor(idx=0; idx<SIZE; idx++)\n    {\n\t    if(time<=sam)break;\n\t    sam+=interval[idx];\n\t}\n    sam-=interval[idx];\n\tidx--;\n\tfloat t=(time-sam)/interval[idx];\n\t\n\t//idx=4;\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = mix(pos0[idx], pos1[idx], t);\n    vec3 up = vec3(sin(grad[idx]),cos(grad[idx]),0);\n    vec3 w = normalize(mix(dir0[idx], dir1[idx], t));\n    vec3 u = normalize(cross(w,up));\n    vec3 rd = mat3(u,cross(u, w),w)*normalize(vec3(uv,2));\n    float h = 0.0,d;\n    float i;\n    vec3 p;\n    for(i=0.;i<160.;i++)\n    {\n        p=ro+rd*h;\n        p*=weight[idx];\n\t    d = map(p);\n        if(d < 0.001 || t > 20.) break;\n        h += d;\n    }\n\tfragColor.xyz= 20.*vec3(cos(p*1.2)*.5+.5)/i;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[770, 770, 789, 789, 1211], [1213, 1213, 1270, 1270, 2356]], "test": "error"}
{"id": "3ljyzc", "name": "Textured Tunnel (N-Sided)", "author": "voax", "description": "reusable 3D Tunnel with specifiable number of sides\nmouse controls curvature/roundness", "tags": ["tunnel", "square", "triangular"], "likes": 5, "viewed": 92, "published": "Public", "date": "1594973586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int sides = 3; // [3, ...)\n\nfloat speed \t = 6.0;\nfloat roundness  = 0.0;\nfloat swirl\t\t = 0.01;\nfloat fadeout\t = 1.0;\nvec2 curvature \t = vec2(2.0, 2.0);\nfloat curviness  = 0.5;\nvec3 bg \t\t = vec3(1,1,1);\n\n#define EPS 0.005\n#define FAR 40.0 \n#define PI 3.14159265359\n#define T iTime\n#define NTILES 1.0\n\nstruct Scene {\n    float t;\n    vec2 walluv;\n    vec2 uvr;\n};\n    \nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nvec3 path(float t) {\n    vec2 ab = vec2(sin(t * PI / 16.0 + 1.5707963 * 1.0),\n        \t\t   cos(t * PI / 16.0));\n    return vec3(ab * curvature, t);    \n}\n\nScene map(vec3 rp) {\n    rp.xy -= path(rp.z).xy;\n    rp.xy = rot(rp.z * swirl) * rp.xy;\n    \n    float a = atan(rp.y,rp.x);\n    \n    float fsides = float(sides);\n    \n    float ax = fsides * a / (2.0*PI); \t// [0,3) e.g. sides = 3\n    float nax = floor(ax);\t\t\t\t// (0,1,2)\n    ax = 0.5 - (ax - nax);\t\t\t\t// [-0.5,0.5) x 3\n    float sax = sign(ax);\n    ax = 2.0/fsides *PI * abs(ax);\t\t// [1/3 PI, 0),[0,1/3 PI) x3 (60 degrees)\n    \n    float r1 = length(rp.xy);\n    float r2 = length(rp.xy) * cos(ax);\t\t\n    float r = mix(r2,r1, roundness);\n    \n    float uvx1 = (nax - sax * ax / (2.0 * PI/fsides) + 0.5) / fsides;\n    float uvx2 = (nax - sax * tan(ax) / (2.0 * tan(PI/fsides)) + 0.5) / fsides;\n    float uvx = mix(uvx2,uvx1, roundness);\n    \n    vec2 uv = vec2(uvx, rp.z);\n    vec2 uvr = vec2(0.0, rp.z);\n\n    float tun = 1.7 - r;\n\n    return Scene(tun, uv, uvr);\n}\n\nScene march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    vec2 walluv = vec2(0.0);\n    vec2 walluvr = vec2(0.0);\n    vec2 cellid = vec2(0.0);\n    float edge1 = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        Scene scene = map(rp);\n        if (scene.t < EPS || scene.t > FAR) {\n            walluv = scene.walluv;\n            walluvr = scene.uvr;\n            break;\n        }\n        t += scene.t;\n    }\n    \n    return Scene(t, walluv, walluvr);\n}\n\nvec3 colour(Scene scene) {\n    return textureGrad(iChannel0, scene.walluv, dFdx(scene.uvr), dFdy(scene.uvr)).xyz; // uvr: https://www.iquilezles.org/www/articles/tunnel/tunnel.htm\n}\n\nvoid setupCamera(vec2 fragCoord, out vec3 ro, out vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float ct = T * speed;\n\n    vec3 lookAt = vec3(0.0, 0.0, ct);\n    ro = lookAt + vec3(0.0, 0.0, -5.0);\n\n    lookAt.xy += path(lookAt.z).xy;\n    ro.xy += path(ro.z).xy;\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iMouse.z > 0.5) {\n     \tcurviness = iMouse.x/iResolution.x;\n        roundness = clamp(2.0 * iMouse.y/iResolution.y - 0.5, 0.0,1.0);\n    }\n    else\n        sides = 3 + int(5.0 * fract(iTime * 0.3));\n    \n    curvature *= curviness;\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n\n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        pc = colour(scene) / (scene.t * 0.5);\n        mint = scene.t;\n        // pc = vec3(scene.walluv, 0);\n    }\n    else\n        pc = bg;\n    \n    pc = mix(pc, bg, fadeout * pow(scene.t/FAR, 2.0));\n        \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n    // fragColor = vec4(pc, 1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 386, 386, 432], [433, 433, 453, 453, 515], [517, 517, 537, 537, 670], [672, 672, 692, 692, 1535], [1537, 1537, 1568, 1568, 2017], [2019, 2019, 2045, 2045, 2200], [2202, 2202, 2262, 2262, 2744], [2746, 2746, 2801, 2801, 3522]], "test": "error"}
{"id": "3lKGRm", "name": "That's Six-Dimensional Gravy", "author": "blackle", "description": "3d slices of a 6d object. rotation done with a random 6x6 orthogonal matrix. uncomment the defines at the top to see what the 6d object looks like without the rotation", "tags": ["slices", "6d", "gravy", "highdimensional"], "likes": 11, "viewed": 362, "published": "Public API", "date": "1596171237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define ROTATE\n#define SLICE\n\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(k-abs(a-b),0.)/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat obj(vec3 p) {\n    vec3 p1 = p;\n#ifdef SLICE\n    vec3 p2 = vec3(asin(sin(iTime)),0,0);\n#else\n    vec3 p2 = vec3(1,0,0);\n#endif\n\n#ifdef ROTATE\n\tmat3 r11 = mat3(-0.33,-0.55,0.29,0.18,-0.055,0.24,-0.11,-0.42,-0.83);\n\tmat3 r12 = mat3(-0.42,0.13,0.26,0.8,-0.13,0.06,-0.088,0.68,-0.29);\n\tmat3 r22 = mat3(-0.67,-0.47,0.23,-0.07,-0.54,0.17,0.4,-0.24,0.46);\n\tmat3 r21 = mat3(0.54,-0.29,0.31,-0.17,0.57,0.73,-0.22,-0.047,0.25);\n#else    \n    mat3 r11 = mat3(1);\n    mat3 r12 = mat3(0);\n    mat3 r21 = mat3(0);\n    mat3 r22 = mat3(1);\n#endif\n\n    vec3 l1s = r11*p1 + r12*p2;\n    vec3 l2s = r21*p1 + r22*p2;\n\n    vec3 l1 = smin(1.-sqrt(l1s*l1s+.1),vec3(.5),.2);\n    vec3 l2 = smin(1.-sqrt(l2s*l2s+.1),vec3(.5),.2);\n\n    \n    float cage = sqrt(dot(l1,l1)+dot(l2,l2))-.9;\n    return cage;\n}\n\nfloat scene(vec3 p) {\n    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture\n    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\tvec2 mouse = (iMouse.xy/iResolution.xy*2.0-1.0)*2.;\n    mouse.x += iTime/2.;\n\n    mat3 rot_x = mat3( cos(-mouse.x), sin(-mouse.x), 0.0,\n                      -sin(-mouse.x), cos(-mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(-mouse.y), 0.0, sin(-mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(-mouse.y), 0.0, cos(-mouse.y));\n    \n    vec3 cam = normalize(vec3(1.7,uv));\n    vec3 init = vec3(-10,0,0);\n\n\tinit*=rot_y*rot_x;\n    cam*=rot_y*rot_x;\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 300; i++) {\n        float dist = scene(p);\n        if (dist*dist < 0.00001) { hit = true; break; }\n        if (distance(p,init)>200.) break;\n        p+=dist*cam;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    vec3 lightdir = normalize(vec3(1));\n    float ao = smoothstep(-.5,2.,scene(p+n*2.))*.9+.1;\n    float ro = smoothstep(-.5,2.,scene(p+r*2.));\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n    vec3 col = ao*mix(ss,diff,.5)*vec3(.3,.1,.07)+pow(spec,30.)*fres*3.*ro;\n    \n    float bg = length(sin(cam*2.5)*0.4+0.6)/sqrt(3.);\n  \tfragColor.xyz = hit ? sqrt(col) : vec3(pow(bg,3.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGRm.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[224, 224, 260, 260, 325], [327, 327, 346, 346, 1108], [1110, 1110, 1131, 1237, 1294], [1296, 1296, 1315, 1315, 1430], [1432, 1432, 1489, 1489, 2912]], "test": "valid"}
{"id": "3llBR8", "name": "DNA Palace", "author": "scry", "description": "raymarching! texturing! voxel-ish stuff! woohoo!\noriginally made in KodeLife\n\nnext thing to figure out...anti-aliasing... haha", "tags": ["3d", "raymarch", "trippy"], "likes": 14, "viewed": 337, "published": "Public API", "date": "1595976881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime*0.5\n// All components are in the range [0…1], including hue.\n//rgb2hsv & hsv2rgb from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nmat2 r2d(float a) {\n    return mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\nfloat cr(vec2 uv) {\n    float col = 0.;\n    col = (sin(uv.y+time*1.));\n    col += (sin(uv.x*10.));\n    return col;\n}\n\n//from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 getDist(vec3 p) {\n    //d = min(d,sdBox(vec3(p.x+5.,p.y+bd+2.,p.z),vec3(bd3,bd2,bd2)));\n    //return d;\n    float rd = 0.02;\n    \n    float id = 0.+p.y*0.02;\n    //p = floor(p*2)/10.;\n    //p.zy *= r2d(mouse.x*2.);\n    //p.xz = (fract(p.xz*rd)-0.5)/rd;\n    p.xz = (fract((abs(p.xz)+5.)*rd)-0.5)/rd;\n    //p.xy *= r2d(mouse.y*2.);\n    //float ps = floor(p.y*0.15-2.5)*0.3;\n    float ps = 0.9;\n    vec3 p1 = p;\n    float t = time;\n    float sc = 3.;\n    float wl = 0.3;\n    p1.zx *= r2d(t+t);\n    p1 = floor(p1*ps)/ps;\n    //p1.z -= 2.;\n    p1.zx *= r2d(p1.y*wl-t);\n    p1.xy += sc;\n    //p1 = floor(p1*ps)/ps;\n    vec3 p2 = p;\n    p2.zx *= r2d(t+t);\n    p2 = floor(p2*ps)/ps;\n    //p2.z -= 0.9;\n    p2.zx *= r2d(p2.y*wl-t+3.);\n    p2.xy += sc;\n    //p1.yx *= r2d(time*0.01);\n    float s = 0.1294+(p.y*p.y*p.y+500.)*0.001;\n    //float s = 0.1294;\n    //p1 = floor(p1*0.5)*0.09;\n    //p1.xz = fract(p1.xz);\n    float d = length(p1.xz)-s;\n    float d2 = length(p2.xz)-s;\n    d = min(d,d2);\n    if (d2 > d) {\n        id += 0.3;\n        //d *= 02.9;\n    }\n    d = min(d,p.y+8.);\n    if (p.y+7.99 < d) {\n        float cs = 2.;\n        vec2 fp = p.xz*0.02;\n        fp.xy *= r2d(p1.y*1.-time+3.);\n        fp = floor(fp.xy*cs)/cs;\n        //fp.xy *= r2d(p1.y*1.+time*0.1);\n        id = (mod(fp.x + mod(fp.y, 2.0), 2.0));\n        //if (id < 0.) {\n        //    id = 0.;\n        //}\n        //id = floor(id);\n        //id = 0.3;\n        if (d < 0.) {\n            d = 40.0;\n        }\n        //d = abs(d);\n    }\n    //if (d < 0.) {\n    //        d = -20.;\n    //    }\n    return vec2(d,id);\n}\n\nvec2 RM (vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<200;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = getDist(p).x;\n        dO += dS*0.3;\n        ii += 0.01;\n        if (dS < 0.01 || dO > 1000.) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\n\n\nvec3 mainKL(vec2 uv)\n{\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    //vec2 tv = inData.v_texcoord;\n    vec2 tv = uv;\n    vec3 col = vec3(0.);\n    uv.x *= iResolution.x/iResolution.y;\n    float c = length(uv);\n    //uv *= 0.5;\n    float t = time*0.1;\n    vec3 ro = vec3(0,-2,-0.);\n    ro.z += time*30.;\n    ro.z += iMouse.x*0.5;\n    //ro += mouse.y*20.;\n    vec3 rd = normalize(vec3(uv,0.8));\n    //rd.zx *= r2d(-mouse.x*20.);\n    rd.zy *= r2d(1.9);\n    rd.zx *= r2d(tv.x+t*5.);\n    //rd.zy *= r2d(2.5);\n    vec2 d = RM(ro,rd);\n    vec3 p2 = rd*d.x;\n    vec3 p = ro+rd*d.x;\n    col = vec3(d.x/100.);\n    float ci = getDist(p).y;\n    //col = hsv2rgb(vec3(ci,1.,(d.y)+(d.x*0.001)));\n    col = hsv2rgb(vec3(ci,1.,1.));\n    if (d.x > 999.) {\n        col *= 0.8;\n    }\n    //d.y += -ci*2.;\n    col += ((d.y*0.9)/(d.x*0.01)-1.)*0.2+d.y*0.2;\n    vec3 cf = fwidth(col);\n    col -= cf;\n    //col = (1.-col)+cf;\n    //col = 1.-cf;\n    //cf = fwidth(col);\n    //col = cf-col;\n    col -= vec3(d.x*0.05)*cf;\n    col = mix(col,vec3(0.),clamp(d.x*0.003,0.,1.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = mainKL(uv-0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 163, 185, 185, 516], [521, 580, 602, 602, 771], [772, 772, 791, 791, 840], [842, 842, 861, 861, 958], [960, 1039, 1070, 1070, 1157], [1159, 1159, 1181, 1267, 2743], [2745, 2745, 2773, 2773, 3043], [3047, 3047, 3069, 3150, 4115], [4117, 4117, 4174, 4224, 4361]], "test": "valid"}
{"id": "3lScDR", "name": "Mountainscape", "author": "mccannjp", "description": "Layers of colored mountain ranges with parallax effect. ", "tags": ["parallax", "mountains", "scenery"], "likes": 7, "viewed": 89, "published": "Public", "date": "1594087594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define S smoothstep\n#define COUNT 45\n\nfloat RAND_01(float co) \n{\n    return fract(sin(co*(98.3458)) * 47453.5453);\n}\n\nfloat RAND_Range(float id, float minimum, float maximum) \n{\n    return (RAND_01(id) * (maximum - minimum)) + minimum;\n}\n\nvec3 mountain(float id, vec2 uv, float blur, float offsetY) \n{\n    float height = RAND_Range(id, 0.2, 0.45);\n    float offsetX = RAND_Range(id + 333., -1., 1.);\n    float width = RAND_Range(id + 100., 0.65, 2.);\n    \n    float r1 = floor(RAND_Range(id, 6., 10.));\n    float r2 = floor(RAND_Range(id, 10., 18.));\n    float r3 = floor(RAND_Range(id, 17., 39.));\n    float r4 = floor(RAND_Range(id, 39., 59.));\n    \n    uv.x = uv.x + (0.5 * width) - offsetX;\n    uv.x += (iTime * (float(COUNT) - id)) / 800.;\n    \n    float y = sin(uv.x * PI / width) * height;\n    y += sin(uv.x * r1 * PI / width) * height / r2;\n    y += sin(uv.x * r3 * PI / width) * height / r4;\n    y += + offsetY;\n    \n    uv.y += 0.03;\n    \n    float res = S(y+blur, y, uv.y);\n    \n    // gradient \n    float ay = S(-0.5, y, uv.y) + 0.6;\n    \n    return vec3(res * ay);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    float ct = float(COUNT);\n\n    for (int i = 0; i < COUNT; i++) {\n        float id = float(i);\n\t\tvec3 m = mountain(id, uv, 0.03, float(i)/ct - 1.0);\n        \n        float idx = RAND_Range(id, 0., 3.);\n        vec3 c = vec3(1.);\n        if(idx > 2.5) c = vec3(0.408, 0.291, 0.817);     // magenta\n        else if(idx > 1.5) c = vec3(0.607, 0.542, 0.80); // light purple\n        else if(idx > 0.5) c = vec3(0.64, 0.682, 0.566); // gray\n        else c = vec3(0.486, 0.234, 0.725);              // purple\n        \n        if(col.r < 0.1)\n        \tcol += c * m;\n    }\n    \n    if(col.r < 0.1)\n        col += vec3(0.7, 0.8, 0.99); // sky\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lScDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 84, 84, 136], [138, 138, 197, 197, 257], [1101, 1101, 1158, 1158, 1919]], "test": "valid"}
{"id": "3lsfR4", "name": "Strange xor", "author": "NLIBS", "description": "trippy eh?", "tags": ["trippy", "xor", "pattern", "short"], "likes": 2, "viewed": 213, "published": "Public API", "date": "1596171936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\t\n    vec2 R = iResolution.xy, p = (2.*U-R)/R.x;\n\tfloat r = (p.x+p.y)*1e3;\n    O-=O-fract(float(int(atan(p.y,iTime*.01)*r+iTime*10.)^int(r))/256.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 190]], "test": "valid"}
{"id": "3lsfRn", "name": "pattern4", "author": "Ausfragezeichen", "description": "what", "tags": ["what"], "likes": 2, "viewed": 191, "published": "Public API", "date": "1595853761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //constants\n    float pi     = 3.14159265359;\n    //float piHalf = 1.57079632679;\n    \n    //variables\n    float zoom = 4.;\n    float speed = 0.125; //rotation speed\n    float space =3.;\n    float radius = 1.;\n    \n    \n    vec2 uv = (fragCoord *2. - iResolution.xy)/iResolution.y;\n    \n    uv *= zoom;\n    \n    vec2 gv = fract(uv);\n    \n    gv *= space;\n    gv -= space/2.;\n    \n    vec3 col = vec3(0.);\n       \n    float cycle = fract(iTime * speed); // from 0. to 1.\n    float alpha = cycle * 2. * pi; // alpha in rad from 0 to 2*pi\n    \n    vec3 coord3D = vec3(gv.x, gv.y, gv.x*gv.y); //start with slice at z=0.\n    //coord3D = vec3();\n    \n    float dist = coord3D.x * coord3D.x + coord3D.y * coord3D.y + coord3D.z * coord3D.z; //!? sqrt missing?\n    \n    float c1 = fract(iTime * speed);\n    float a1 = c1 * 2. * pi; \n    float f1 = sin(a1+gv.x)-cos(a1+gv.y);\n    coord3D.x += uv.x*f1;\n    coord3D.y += uv.y*f1;\n    coord3D.z *= coord3D.z+f1;\n    \n    float c2 = fract(iTime * speed * 0.5);\n    float a2 = c2 * 2. * pi; \n    float f2 = cos(a2+gv.x)+sin(a2+gv.y);\n    coord3D.x += uv.x*f2;\n    coord3D.y += uv.y*f2;\n    coord3D.z += coord3D.z*f2;\n    \n    float lenght3D = length(coord3D);\n    \n    if(lenght3D < radius){\n        col = vec3(coord3D.x, coord3D.y, coord3D.z);\n    }\n\n    //col += vec3(gv, 0.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 1432]], "test": "valid"}
{"id": "3lSSDd", "name": "Archimedes Spiral", "author": "timeisbeautifulhere", "description": "The spiraling shape will make you go insane\nBut everyone wants to see that groovy thing", "tags": ["spiral", "archimedes", "hypno", "hypnotize"], "likes": 3, "viewed": 448, "published": "Public API", "date": "1595894176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\n#define SPIRAL_A 0.0\n#define SPIRAL_B 0.05\n\n#define SPIRAL_WIDTH 0.1\n#define MAX_RADIUS 2.0\n\n//Enable or disable color\n#define COLOR_ENABLED true\n\n#define SPIN_RATE 4.0\n#define COLOR_RATE 0.1\n#define COLOR_RATE2 0.001\n#define COLOR_CONST 0.1\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//If on spiral, return number of degrees (theta).\n//If not on spiral, return -1.0\nfloat checkOnSpiral(vec2 pc, float a, float b){\n    \n    //Solve for spiral theta, given the distance of the\n    //polar coordinate (r = a+b*theta)\n    float theta = (pc[1]-a)/b;\n    \n    //If polar coordinate angle is aligned with theta,\n    //it is on the spiral\n   \tif(abs(pc[0]-mod(theta,2.0*PI)) < SPIRAL_WIDTH)\n        return theta;\n   \telse\n        return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(-1,1)\n    vec2 uv=(2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    //polar coordinates\n    vec2 pc=vec2(\n        atan(uv.y, uv.x),\n        length(uv)\n    );\n    \n    //Time to hypnotize the viewer B)\n    pc[0]+=SPIN_RATE*iTime;\n    pc[0]=mod(pc[0], 2.0*PI);\n\n    vec3 col = vec3(0,0,0);\n    float spiral_degrees = checkOnSpiral(pc, SPIRAL_A, SPIRAL_B);\n    if(spiral_degrees>=0.0){\n        if(COLOR_ENABLED){\n            \n            //Don't ask me to explain what I just did here\n        \tfloat rate = mod(COLOR_RATE+(iTime*COLOR_RATE2), 2.0*PI);\n        \tfloat r = fract(spiral_degrees*rate);\n        \tfloat g = fract(spiral_degrees*(rate+COLOR_CONST));\n        \tfloat b = fract(spiral_degrees*(rate+COLOR_CONST+COLOR_CONST));\n        \tcol = vec3(r,g, b);\n        }else{\n            col = vec3(1.0,1.0,1.0);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 395, 442, 542, 765], [767, 767, 824, 837, 1725]], "test": "valid"}
{"id": "3lSyDG", "name": "Sine SDF (No Root-Finding)", "author": "blackle", "description": "finally, maybe, cracked the sine SDF problem, in the most ad-hoc way possible", "tags": ["2d", "sdf", "sine", "distance", "curve", "cosine"], "likes": 24, "viewed": 637, "published": "Public API", "date": "1595219145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is a method of computing the distance to a sine function\n//it works by creating a rough estimate for the closest point,\n//then checking if there's a closer point by creating a line\n//segment that is tangent to the curve, and finding the closest\n//point on that segment, becoming the new closest point\n//\n//because this works on the idea of finding the closest point,\n//we can also return that point from the function alongside\n//the distance. unfortunately, the point is a little jittery\n//especially when far from the curve. oh well...\n//\n//other solutions:\n//  iq:      https://www.shadertoy.com/view/3t23WG\n//  fabrice: https://www.shadertoy.com/view/tsXXRM\n\n#define PI 3.141592653\n\nvec2 closest_on_line(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n    float wavelen = PI/freq;\n\n    //map p to be within the principal half cycle\n    float cell = round(p.x/wavelen)*wavelen;\n    float sgn = sign(cos(p.x*freq));\n    p.x = (p.x-cell)*sgn;\n\n\t//sloppy initial estimate to the closest point using a line\n    //inexplicably, setting the height of the line to be proportional\n    //to the point's y position gives a *really* good estimate when \n    //far away from the curve.\n    float correction = max(1.,abs(p.y));\n    vec2 estimateline = vec2(wavelen/2.,correction);\n    vec2 cp = closest_on_line(p, -estimateline, estimateline);\n\n    //any less than 2 iterations looks bad, any more does not improve it\n    for(int i = 0; i < 2; i++) {\n        //refine the closest point by checking if there's a closer point on the tangent line\n    \tcp.y = sin(cp.x*freq);\n        float derivative = freq*cos(cp.x*freq);\n        vec2 localline = vec2(1,derivative)/freq/correction*.25;\n    \tcp = closest_on_line(p, cp-localline, cp+localline);\n        cp.x = clamp(cp.x, -wavelen/2., wavelen/2.);\n    }\n\n    cp.y = sin(cp.x*freq);\n    float dist = length(p-cp)*sign(p.y-sin(p.x*freq));\n\n    //map the closest point back to global coordinates\n    cp.x *= sgn; cp.x += cell;\n    return vec3(dist, cp);\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tfloat scale = 5.;\n    uv*=scale; mouse*=scale;\n    float pixel_size = scale/iResolution.y;\n    \n    float t = sin(iTime)*.5+.5;\n    float freq = mix(20.,.5,sqrt(t));\n\n    vec3 mousedist = sine_SDF(mouse, freq);\n    vec3 col = shadeDistance(sine_SDF(uv, freq).x);\n    if (iMouse.z > 0.) {\n        col *= smoothstep(-pixel_size,pixel_size, distance(mouse, uv) - abs(mousedist.x)) *.5 +.5;\n        col = mix(vec3(.8,.9,.4), col, smoothstep(-pixel_size,pixel_size, distance(mousedist.yz, uv) - .05));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyDG.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[887, 887, 933, 933, 1012], [1014, 1014, 1049, 1049, 2283], [2285, 2285, 2314, 2314, 2639], [2641, 2641, 2698, 2698, 3359]], "test": "valid"}
{"id": "3lSyRc", "name": "flow leaf", "author": "inbisibler", "description": "make leaf shape function", "tags": ["leaf"], "likes": 1, "viewed": 49, "published": "Public", "date": "1594913333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 circle(vec2 pos,float r,float time,vec3 col)\n{\n    vec2 center = vec2 (mod(time*0.1,3.)-1.5,sin(time)*0.1);\n    vec2 p = pos - center;\n    float th = atan(p.x,p.y)+0.1*sin(time);\n    float n1 = 7.,n2 = 3.;\n    float grade = 0.5;\n    float shape = r*abs(sin(n1/2.*th+3.14/2.))*(1.+1.*abs(cos(n1/2.*n2*th)))+r/3.;\n    shape = shape * (abs(cos(0.5*th))*grade+1.-grade);\n    return max(col,(1.+sign(length(p)-shape))/2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec2 pos = vec2 (mod(iTime*0.1,3.)-1.5,sin(iTime)*0.1);\n    \n    vec3 c1 = circle(uv,0.15,iTime,vec3(1.,0.,0.));\n    vec3 c2 = circle(uv,0.05,iTime+7.,vec3(1.,1.,0.));\n    vec3 c3 = circle(uv,0.1,iTime+14.,vec3(0.,1.,0.));\n    vec3 c4 = circle(uv,0.08,iTime+21.,vec3(1.,0.,1.));\n\n    // Output to screen\n    vec3 col = min(c4,min(c3,min(c2,c1)));\n    if (col == vec3(1.))\n    {\n    \tcol = vec3(0.8,1.,1.);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 424], [426, 426, 483, 533, 1041]], "test": "valid"}
{"id": "3lSyRd", "name": "Test Circle 1", "author": "UrbanFlame", "description": "Simple circle with random colors\nTrying to understand how shader works", "tags": ["test"], "likes": 2, "viewed": 166, "published": "Public API", "date": "1595022328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RandomF(x) 0.5+0.5*cos(x)\n\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax)\n{\n \treturn outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin) ;  \n}\n\nfloat remap(float value, float inMin, float inMax)\n{\n    return (value - inMin) * 1.0 / (inMax - inMin) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Created total color vec and setting to white for background\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    float circleRadius = 1.0;\n \n    float xCircle = remap(uv.x, 0.0, 1.0, -1.0, 1.0) * iResolution.x / iResolution.y;    \n    float yCircle = remap(uv.y, 0.0, 1.0, -1.0, 1.0) ;\n    float sumCirclePoints = pow(xCircle, 2.0) + pow(yCircle, 2.0);\n    float powCircleRadius = pow(circleRadius, 2.0);\n    \n    if (sumCirclePoints <= powCircleRadius)\n    {\n        float linesFrequency = 3.0;\n        float colorValue = RandomF(uv.x * iTime * linesFrequency);\n     \tcol = vec3(uv.xyx * colorValue);\n        \n        //Adding alpha near to circle borders\n        //float distanceToCenter = distance(vec2(uv.x * iResolution.x / iResolution.y, uv.y)\n        //                                  , vec2(0.5 * iResolution.x / iResolution.y, 0.5));\n       \t\n        float distanceToCenter = sumCirclePoints / powCircleRadius;\n        col = mix(col, vec3(1.0, 1.0, 1.0), distanceToCenter);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 115, 115, 193], [195, 195, 247, 247, 302], [305, 305, 362, 412, 1496]], "test": "valid"}
{"id": "3lSyRh", "name": "Socolar-C5-var tiling [Day 194]", "author": "jeyko", "description": "Derp", "tags": ["tiling", "aperiodic", "mdtmjvm", "socolar"], "likes": 21, "viewed": 346, "published": "Public API", "date": "1593638332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is Socolar-C5 but with mirror simmetry added in the first rule\n\n// Mostly mathematically correct with some number crunching (about 20%) \n// https://tilings.math.uni-bielefeld.de/substitution/socolar-c5/\n\n// Substitution tilings are super fun stuff\n// Although they may seem a bit intimidating, because they,\n// I think starting one from scratch is a good way to get started,\n// because code can get... uh... convoluted, like here.\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\nfloat sdEquilateralTriangle(  vec2 p, float r ){   \n    r = r*1./3.;\n\tp.y -= r;\n    p.y += r*1.5;\n    float d = dot(vec2(abs(p.x),p.y) - -normalize(vec2(0.,1)*rot(tau/3.))*(r), -normalize(vec2(0.,1)*rot(tau/3.)));\n    d = max(d,p.y - r*2.);\n    d = max(d,-p.y - r);\n    return d;\n}\n\nfloat sdRhombus( vec2 p, float height, float angleHoriz, float angleVert ){\n\n    float hypothenuse = sin(pi/2.)*height*0.5/sin(angleHoriz/2.);\n    float base = sin( angleVert/2.)*hypothenuse/sin(pi/2.);\n\t\n    float triarea = height*0.5*base*0.5;\n    float triheight = triarea*2./hypothenuse;\n    \n    float triAngle = asin(triheight*sin(pi/2.)/base);\n    vec2 hdir = vec2(0.,1.)*rot(-triAngle);\n    p = abs(p);    \n    p -= normalize(hdir)*triheight/1.;\n    \n\treturn dot(p,vec2(0.,1.)*rot( -triAngle));\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    \n    float id = 0.;\n    float iters = 5.;\n    \n    float d = 10e5;\n    \n    float s = 1.;\n\n    uv += vec2(sin(iTime/2.6  + cos(iTime/4.)),cos(iTime/2. + sin(iTime/4.)))*0.2;    \n    uv *= 0.7;\n    \n    \n    vec2 p = uv;\n    float sc = 1.;\n    \n    float palvar = 1.;\n    \n    float lside = 2.;\n    float lsplithoriz = 2.35 ; // 2.35 is totally crunched\n    \n    \n    float avert = 2.*( asin( lsplithoriz*0.5*sin(pi/2.)/lside) );\n    float ahoriz = (tau - 2.*avert)/2.;\n    \n    float ahorizb = avert/2.;\n    float avertb = (tau - ahorizb*2.)/2.;\n    \n    float lsplitvert = 2.*sin(ahoriz/2.)*lside/sin(pi/2.);\n    \n    float ratiosidevert = lside/(lside + lsplitvert);\n    \n    float ratiohorizvert = lsplithoriz/(lsplithoriz + lsplitvert);\n    \n    float lsidesmall = lside * ratiosidevert;\n    \n    float lsplitvertsmall = lside - lsidesmall;\n    \n    float lsplithorizsmall = lsplitvertsmall*ratiohorizvert;\n    float lsplitvertb = lsplitvertsmall*1./2.62; // last minute crunch from 2.6 to 2.62?\n    \n    \n    for(float i = 0.; i < iters; i++){\n    \tfloat Llside = lside * sc;\n    \t\n        float Llsplithoriz = lsplithoriz * sc;\n    \n        float Llsplitvert = lsplitvert * sc;\n    \n    \tfloat Lratiosidevert = ratiosidevert * sc;\n    \n    \tfloat Lratiohorizvert = ratiohorizvert * sc;\n    \n    \tfloat Llsidesmall = lsidesmall * sc;\n    \n    \tfloat Llsplitvertsmall = lsplitvertsmall * sc;\n    \n    \tfloat Llsplithorizsmall = lsplithorizsmall * sc;\n    \n    \tfloat Llsplitvertb = lsplitvertb * sc;\n        \n        if(id == 0.){\n        \tfloat drh = sdRhombus(p, Llsplitvert, ahoriz, avert );\n        \n            vec2 pb = p + vec2(0,Llsplitvert*0.5 - Llsplitvertsmall/2.);\n\n            float drhb = sdRhombus(pb, Llsplitvertsmall, ahoriz, avert );\n\n            p.x = abs(p.x);\n            vec2 pc = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pc.y += Llsplitvertsmall*0.495; // some crunch here\n            mat2 pcr = rot(avert*0.5*6.); \n            pc *= pcr;\n            pc.y -= Llsplitvertsmall*0.503;\n            float drhc = sdRhombus( pc, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pd = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pd.y += Llsplitvertsmall*0.5;\n            mat2 pdr = rot(-avert/1.);\n            pd *= pdr;\n            pd.y -= Llsplitvertsmall*0.5;\n\n            float drhd = sdRhombus( pd, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pe = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pe.y += Llsplitvertsmall*0.5;\n            mat2 per = rot(-avert/1.);\n            pe *= per;\n            pe.y -= Llsplitvertsmall*1.;\n\n            pe.x -= Llsplithorizsmall*0.862;\n\n            float drhe = sdRhombus( pe, Llsplitvertsmall, ahoriz, avert );\n\n            \n            vec2 pba = p;\n            pba.x -= Llsplitvertb/2.125;\n            pba.y += Llsplitvertb/1.55;\n\n            pba *= rot(ahoriz/1.5);\n                        \n            float drhba = sdRhombus( pba, Llsplitvertb, ahorizb, avertb );\n\n\n\n\n            d = min(d, abs(drh));\n            d = min(d, abs(drhb));\n            d = min(d, abs(drhc));\n            d = min(d, abs(drhd));\n            d = min(d, abs(drhe));\n            d = min(d, abs(drhba));\n            \n\n            if (drhb < 0.) {\n                p = pb;\n            } else if (drhc < 0.) {\n                p = pc;\n            } else if (drhd < 0.) {\n                p = pd;\n            } else if (drhe < 0.) {\n                p = pe;\n            } else if (drhba < 0.) {\n                p = pba;\n            } else {\n                break;\n            }\n\n            if ( drhb < 0. || drhc < 0. || drhd < 0. || drhe < 0. ){\n\t\t\t\tid = 0.;\n                palvar += 0.4;\n            } else {\n                palvar += 2.1;\n\t\t\t\tid = 1.;\n\t\t\t}\n            sc *= lsplitvertsmall/lsplitvert;\t\n        } else if (id == 1.) {\n            \n            p *= rot(1.*pi);\n            \n            p.y = abs(p.y);\n            //p*=0.5;\n            vec2 pa = p*1.;\n            float dra = sdRhombus( pa, Llsplitvertb, ahorizb, avertb );\n\t\t\t\n            vec2 pb = p;\n            float drb = sdRhombus( pb, Llsplitvertsmall, ahoriz, avert );\n            \n            \n            vec2 pc = p;\n            pc.y += 0.5*Llsplitvertsmall;\n            pc *= rot(avert);\n            pc.y -= 0.5*Llsplitvertsmall;\n            float drc = sdRhombus( pc, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pd = pc;\n            pd.y -= 0.62*Llsplitvertsmall;\n            \n            pd.y -= 0.5*Llsplitvertsmall;\n            pd *= rot(avert/2.);\n            \n            pd.y += 0.5*Llsplitvertsmall;\n            \n            float drd = sdRhombus( pd, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pe = pc;\n            \n            pe.y -= 0.5*Llsplitvertsmall;\n            \n            pe *= rot(-ahorizb);\n            //pe.x += Llsplithorizb*lsplithorizsmall/lsplithoriz/0.75;\n            pe.x += 0.58*Llsplitvertsmall;\n            \n            float dre = sdRhombus( pe, Llsplitvertb, ahorizb, avertb );\n\n            vec2 pf = p;\n            \n            pf.y -= 0.505*Llsplitvertsmall;\n            pf *= rot(-ahorizb);\n            \n            pf.x += 0.58*Llsplitvertsmall;\n            \n            //pe.x += Llsplithorizb*lsplithorizsmall/lsplithoriz/0.75;\n            //pe.x += 0.58*Llsplitvertsmall*lsplitvertsmall/lsplitvert;\n            \n            float drf = sdRhombus( pf, Llsplitvertb, ahorizb, avertb );\n\n            \n\t\t\t\n            //d = min(d, abs(dra));\n            \n            d = min(d, abs(drb));\n            d = min(d, abs(drc));\n            d = min(d, abs(drd));\n            d = min(d, abs(dre));\n            d = min(d, abs(drf));\n            \n            \n\t\t\tif (drb < 0.) {\n                p = pb;\n            } else if (drc < 0.) {\n                p = pc;\n            } else if (drd < 0.) {\n                p = pd;\n            } else if (dre < 0.) {\n                p = pe;\n            } else if (drf < 0.) {\n                p = pf;\n            } else  {\n                break;\n            }\n\n            if ( drb < 0. || drc < 0. || drd < 0.){\n\t\t\t\tid = 0.;\n                palvar += 1.1;\n            } else if ( dre < 0. || drf < 0.) {\n\t\t\t\tid = 1.;\n                palvar += 2.1;\n            } else {\n            \tbreak;\n            }\n            sc *= lsplitvertsmall/lsplitvert;\n            \n            \n        }\n            \n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.56,vec3(3.,0.7,0.2),3.4, palvar + iTime + uv.x/2. + uv.y/2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    //col = mix(col,pal(0.5,0.56,vec3(2.,0.7,0.2),1., palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    \n    d = abs(d);\n    \n    float w = 0.0002;\n    col = mix(col,vec3(0.04),smoothstep(dFdx(uv.x) + w, w,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 581, 581, 814], [816, 816, 891, 891, 1320], [1331, 1331, 1388, 1388, 8395]], "test": "valid"}
{"id": "3lSyz1", "name": "utils: golfed transforms", "author": "FabriceNeyret2", "description": "Rotation , angle vector , hue , iso-triangle tilings (coords, id)...", "tags": ["glsl", "rotation", "hls", "golfing", "shortest", "hexatiling"], "likes": 14, "viewed": 294, "published": "Public API", "date": "1593670360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)   mat2( cos( a + vec4(0,33,11,0)) )      // https://www.shadertoy.com/view/XlsyWX \n#define CS(a)    cos( a + vec2(0,11) )                  // https://www.shadertoy.com/view/XlsyWX \n#define hue(h)   .6 + .6 * cos( h + vec4(0,23,21,0)  )  // h = [0,2Pi]  https://www.shadertoy.com/view/ll2cDc\n#define hGrid(U) vec4( U *= mat2(6, 0, 3, 5) , U-U.y )  // https://www.shadertoy.com/view/Wl2yRz\n                        // normalized: mat()/6.\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.*u/R.y, I = floor(U); U -= I+.5;              // subwindow coords\n    int  i = int(I+3.*I.y);                                  // subwindow Id\n    float t = iTime;\n   \n    O =  i < 2 ? U-=.2*t, O = fract( hGrid(U) ),             // isoTriangle grid\n          i==0 ? O                                           // local coords\n               :( O.xxxx - O.y ) / .1                        // tiling\n        : i==2 ? vec4( length(  U*rot(t) - .2* U/U ) / .1 )  // point rotation\n        : i==3 ? vec4( dot( U, CS(t) ) / .1 )                // direction rotation\n        : i==4 ? hue( 6.3*length(U) - t )                    // concentric hue\n        : i==5 ? hue( atan(U.y,U.x) - t )                    // radial hue\n        :        hue( dot( ceil(hGrid(U)), vec4(1,7,9,0) ) -t ); // isoTriangle Ids\n}                                // 'uniq' id:  1,10,100 or dot(xy,(1,10)) *2 + z%2", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 451, 489, 489, 1332]], "test": "error"}
{"id": "3lXBz8", "name": "glow and gear", "author": "zhengxiangkui", "description": "glow and gear", "tags": ["tutorial", "glow", "gear"], "likes": 4, "viewed": 205, "published": "Public", "date": "1595930806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592657\n#define NUM 15.\nfloat rect(vec2 p, vec2 size) {\n    return max(smoothstep(size.x, size.x+0.01, abs(p.x)),\n        smoothstep(size.y, size.y+0.01, abs(p.y)));\n\n}\n\nmat2 rotate2D(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n\treturn mat2(s, -c,\n               \tc, s\n               );\n\n}\n\nfloat gear(vec2 p, float r, float angle) {\n    float res = 1.;\n    for(float i = 1.; i <= NUM; i++) {\n    \tfloat currAngle = i/NUM * 2. * PI;\n        vec2 rp = rotate2D(currAngle+angle) * p;\n        rp.y -= r;\n        res *= rect(rp, vec2(0.05, 0.06));\n    }\n    res *= smoothstep(r, r+0.01, length(p)) + smoothstep(0.11,0.1, length(p));\n    return res;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = 3.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec2 glowUv = uv - vec2(2.*sin(iTime),1.);\n    vec3 col = vec3(1.,0.5,0.25);\n\tfloat over = 1./length(glowUv);\n    float dist = pow(over, 0.8);\n    col *= dist;\n    \n    col = 1. - exp(-col);\n    \n    float v1 = gear(uv, 0.5, iTime * 0.5);\n    float v2 = gear(uv - vec2(0.72,0.8), 0.5, -iTime * 0.5);\n    float v = min(v1 , v2);\n    // Output to screen\n    fragColor = vec4(col*v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 70, 70, 183], [185, 185, 213, 213, 327], [329, 329, 371, 371, 689], [691, 691, 748, 784, 1235]], "test": "valid"}
{"id": "3sXyzX", "name": "Masking with fract", "author": "nicolaecodreanu", "description": "Maskin line with fract", "tags": ["2d", "mask", "fract"], "likes": 4, "viewed": 59, "published": "Public", "date": "1594910079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANIMATION_TIMESCALE 0.5\n\n//https://www.shadertoy.com/view/4dc3zr\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    float t = iTime * ANIMATION_TIMESCALE;    \n    float udCurve = uv.y - clamp(uv.x, -0.1, 0.1);\n    float aaf = fwidth(udCurve);\n    float PXSIZE = 1./iResolution.x;\n    aaf = 5.0 * PXSIZE;\n    udCurve = abs(udCurve);\n    float mask = fract(uv.x / 4.0 - t);  \n    col += mix(vec3(1.0) * mask, col, smoothstep(0., aaf, udCurve));\t\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 131, 131, 625]], "test": "valid"}
{"id": "3t2cDd", "name": "Noise Practive", "author": "reatured", "description": "Practice noise.", "tags": ["learning"], "likes": 1, "viewed": 115, "published": "Public", "date": "1595738125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n\n    \n    uv *= 10.;\n    vec2 i = floor(uv);\n    //uv = fract(uv);\n    vec2 f = uv;\n    float randomN = random(i);\n    \n    float noise = noise(uv);\n    // Time varying pixel color\n    vec3 col = vec3( noise, random(fract(uv) +sin(iTime)) ,0.7);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 159, 159, 676], [679, 679, 736, 786, 1171]], "test": "valid"}
{"id": "3t2cDh", "name": "Ketchup & Mustard ", "author": "Mischawake", "description": "\"Random\" metaballs up of to 4 colors...", "tags": ["metaballs"], "likes": 13, "viewed": 206, "published": "Public", "date": "1594243064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nconst int nBalls = 40;\nconst int numColors = 2; //max 4\n\nfloat random (float i){\n \treturn fract(sin(float(i)*43.0)*4790.234);   \n}\n\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.1);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    vec3(255./255., 77./255., 0./255.),\n    vec3(255./255., 246./255., 0./255.),\n    vec3(0./255., 192./255., 199./255.),\n    vec3(10./255., 84./255., 255./255.)\n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n    vec3(230./255., 25./255., 56./255.),\n    vec3(230./255., 144./255., 25./255.),\n    vec3(0./255., 199./255., 152./255.),\n    vec3(10./255., 165./255., 255./255.)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n   \tint i;\n    \n    //settings to play with!\n    float threshold = 1.0;\n    float shadowIntensity = 0.5;\n    float specularIntensity = 0.3;\n    float specularPower = 50.0;\n    float rimIntensity = 2.; //2\n    float aoIntensity = 0.5;\n    float ambientBrightness =  0.05;\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.09;\n    float rf = 0.005;\n    float jiggle = sin(iTime*(2.0)) * 0.0125;\n    \n    float speed = 0.25;\n    \n    vec4[nBalls] balls;\n    \n    for( i = 0; i < nBalls; i++ ){\n    \n        float per = float(i)/float(nBalls);\n        float r = random( per * 7.0 );\n        float r2 = random( per * 11.0 );\n        float r3 = random( per * 19.0 );\n        \n        float x = 0.5 + sin(iTime*speed + r*30.0)*r;\n        float y = 0.5 + cos(iTime*speed + r*40.0)*r2*0.5;\n \n        int color = i % numColors;\n        float rd = rad + 0.5 * rad * sin(iTime*speed + r*13.0)*r;\n        \n        balls[i] = vec4( x, y, rd, color );\n        \n    }\n    \n    \n    int ballCount = nBalls;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] shaders = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    \n\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv);  \n        accumulators[idx] += inf;\n        shaders[idx] += calcNormal( balls[i], uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    vec3 normal = normalize(shaders[maxIdx]);\n \n      \n    //point light\n    vec3 light = vec3( mouse.x, mouse.y, -0.25);\n    float lightRadius = 0.01;\n    float lightIntensity = calcInfluence( vec4(light.x, light.y, lightRadius, 0.), uv );\n\tvec3 lightDir = normalize( light - vec3( uv, 0.0 ) );            \t\n    \n    //basecolor\n    vec3 color = baseColor;\n    vec3 ambientColor = vec3(ambientBrightness);\n    if( rainbowMode )\n        ambientColor = avgColor * ambientBrightness;\n   \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    color += vec3(1.0) * rimIntensity * pow (rim, 2.0);\n    \n    //diffuse\n    float lighting = max(0.,dot( -normal, lightDir) );\n    color = mix( color, color * lighting, (1.0 - ambientBrightness) * shadowIntensity );\n    \n    // specular blinn phong\n    vec3 dir = normalize(lightDir + vec3(0,0,-1.0) );\n    float specAngle = max(dot(dir, -normal), 0.0);\n    float specular = pow(specAngle, specularPower);\n    color += vec3(1.0) * specular * specularIntensity;\n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor, color, smo);\n    \n    color += pow(lightIntensity,0.5) * 2.0 * vec3(1.);                    \n    \n    fragColor = vec4( color, 1.0 );\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 155, 155, 205], [208, 208, 250, 250, 347], [349, 349, 388, 388, 433]], "test": "error"}
{"id": "3t2cR1", "name": "attempted vegetation", "author": "yonatan", "description": "a messier version of https://www.shadertoy.com/view/wtfyzf", "tags": ["terrain", "fbm"], "likes": 10, "viewed": 350, "published": "Public API", "date": "1593723953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// feel free to reuse\n\nmat2 rot2d(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));} // Angle => 2D rotation matrix\n\nfloat terrain_height(vec2 position) { // https://www.iquilezles.org/www/articles/fbm/fbm.htm\n  float height=0., amplitude, n, am;\n  vec2 pp = position*.1;\n  float z = length(sin(pp)*cos(pp));\n  am = z*z*z*z*z*.6+.6;\n  amplitude=1.4*z*z;\n  for(int i = 0; i < 20; i++) { // Sum up 20 layers\n    n = sin(position.x) * cos(position.y); n = n * n * n; // Simple base pattern, no noise\n    if(i>9) n*=clamp(1., 1./(height*height*9.), 4.0); // This does the \"trees\"\n    height += n * amplitude; // Accumulate value at current amplitude\n    position *= rot2d(float(i*i)); // Rotate (phase-shift?) by a hash of the current iteration\n    position *= 1.41;\n    amplitude = am * amplitude;\n  }\n  return abs(height) - .02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime * .2 + iMouse.x / iResolution.x * 28.;\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x,iResolution.y);\n  vec3 p, water_tint = vec3(1), ray_origin = vec3(-cos(time*.5)*7.,1.,time+4.), // Camera position\n    ray_direction = normalize(vec3(uv.x, uv.y - .7 + cos(time) * .5, 1.9));\n  ray_direction.xy *= rot2d(sin(time*.5)*.5); // Camera orientation and field of view\n  float distance = 0., ray_length = 0.;\n  for(int i = 0; i < 75; i++) { // Raymarching loop\n    p = ray_origin + ray_direction * ray_length; // Get current ray position\n    if(distance<.1 && p.y<0.) { // If we're close to the surface check p.y for a water hit\n      ray_origin.y = -ray_origin.y; ray_direction.y = -ray_direction.y; // Reflect ray\n      water_tint = vec3(.7,.8,.9)/(ray_direction.y);\n    } else { // Not underwater - march\n      distance = p.y-terrain_height(p.xz); // Real distance is hard to calculate so use p's\n      // height above the terrain, and since that's obviously\n      ray_length += distance * .6; // wrong - only march .6 of the way and hope for the best.\n    }\n    if(ray_length > 20.) break; // We are far away (in the sky)\n  }\n  vec2 h = vec2(.0001, 0); // From https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n  vec3 surface_normal = normalize(vec3(terrain_height(p.xz-h.xy) - terrain_height(p.xz+h.xy),\n                                       2.*h.x, terrain_height(p.xz-h.yx) - terrain_height(p.xz+h.yx)));\n  vec3 terrain_color = mix(vec3(.4,.6,.1),vec3(.7,.65,.15),abs(p.y)*8.)*.5\n    * (surface_normal.z * .5 + .5); // Terrain, backlit\n  vec3 sky_color = mix(vec3(1.1,1.,.8),vec3(.6,.7,.8),abs(ray_direction.y)); // Sunny horizon\n  vec3 color = mix(terrain_color, sky_color, min(1.,ray_length/20.)); // Mountains-sky fade\n  color *= water_tint; // Water color\n  fragColor = vec4(pow(color, vec3(.4545)), 1); // Gamma correction\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 87], [120, 120, 157, 212, 831], [833, 833, 890, 890, 2777]], "test": "valid"}
{"id": "3t2cRc", "name": "Fire Boze", "author": "kaiware007", "description": "Raycast & Raymarch combine test", "tags": ["raymarch", "raycast"], "likes": 9, "viewed": 120, "published": "Public", "date": "1594977206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 20\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 20.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define AA 1\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(-0.6, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89);\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.2 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(MAX_DIST);\n    \n\tvec3 index = floor(p * 1. + 0.5);\n    \n    float at = iTime * 2.5 * M_PI2;\n    \n    vec3 q = opRep(p, vec3(1., 1000., 1.));\n    \n    if(floor(abs(index.x) + abs(index.y) + abs(index.z)) > 0.)\n    {\n        vec2 indexdiff = vec2(0) - index.xz;\n        float angle = atan(indexdiff.y, indexdiff.x);\n        \n        q = rotate(q, angle + RAD90+M_PI, vec3(0,1,0));\n    \n        //result = sdBoze(p + vec3(0, 0, 0), vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n    \tresult = sdBoze(q + vec3(0, 0, 0), vec3(1), 1.);\n    \tresult.metalness = 0.9;\n    \n    }else{\n        q = rotate(q, M_PI, vec3(0,1,0));\n    \t//result = sdBoze(p + vec3(0, 0, 0), vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n    \tresult = sdBoze(q + vec3(0, 0, 0), vec3(1), 1.);\n    \t//result.metalness = 0.9;\n    \n    }\n    \n    // background\n    surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.15, 0.), vec4(0,1,0,0)), p);\n    result = opU(result, bg1);\n\n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0,0,0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n#define fog_density(x) (1.0 - saturate(exp2(5.0 - (x) * 1.5)))\n\n\nfloat densitycalc(vec3 p){\n    //p = rotate(p, 0.45, vec3(0,0,1));\n    p = rotate(p, M_PI, vec3(0,1,0));\n\t//surface r = sdBoze(p, vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n    surface r = sdBoze(p, vec3(1.2), 1.);\n\t//return fbm(p * 25. + iTime * 0.2) - min(r.dist, 1.) * 25.;\n    return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(r.dist, 1.) * (20. - p.y * 20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    //vec3 spherePos = vec3(0,sin(iTime * 0.5) * 0.5,0);\n    const vec3 spherePos = vec3(0);\n    const float radius = 0.5;\n    vec2 sd = GetIntersectSphere(pos, dir, spherePos, radius);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x)) \n    {\n        const float step = 1.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 1.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            //vec3 q = pp - spherePos + vec3(0.,0.1 ,0.);\n            vec3 q = pp - spherePos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 100. * dd * transmittance;\n\t\t\t\t/*\n                float transmittanceLight = 1.0;\n                //vec3 lightPos = q;\n\t\t\t\tvec3 lightDir = normalize(lightPos);\n                for(int j = 0; j < MAX_RAYCAST_L; j++){\n                    float densityLight = densitycalc(q + lightDir * float(j) * lightStep);\n                    if(densityLight > 0.0){\n                        float dl = densityLight * lightStep;\n                        transmittanceLight *= 1.0 - dl * absorption * 0.25;\n                        if(transmittanceLight < 0.01){\n                            transmittanceLight = 0.;\n                            break;\n                        }\n                    }\n                }\n\t\t\t\t*/\n                //albedo += vec3(1.,.7,.5) * (150. * dd * transmittance * transmittanceLight);\n            \t//albedo.rgb += lightColor * (100. * dd * transmittance * transmittanceLight);\n                //result.emission.rgb += vec3(1,0.2,0.05) * (200. * dd * transmittance * transmittanceLight);\n                result.emission.rgb += vec3(1,0.2,0.05) * (150. * dd * transmittance);\n                //result.emission.rgb += vec3(0.05,0.2,1.) * (500. * dd * transmittance * transmittanceLight);\n                //result.emission.rgb += vec3(0.05,0.2,1.) * (200. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        //result.emission.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    //result.albedo = albedo;\n    //result.emission = emission;\n    return result;\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    \n    vec3 sky = SkyColor(direction);\n    vec3 nor = norm(pos);\n\n    // Calc Ambient\n    hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n    // Exponential distance fog\n    hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n\t\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n    //hit.emission += volume.emission;\n    //t = min(t, volume.dist);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n\t\thit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n    }\n\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        \n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //float t = iTime * 1.0 + M_PI * 1.5;\n    //float r = 2.0;\n    //vec3 lightPos = vec3(-0.6, 0.8, -1.5);\n    //vec3 lightColor = vec3(0.98, 0.92, 0.89) * 1.0;\n\n    //if (mat.dist >= MAX_DIST) {\n    //    col = sky;\n    //} else \n    {\n        //vec3 result = vec3(0.);\n        //vec3 nor = norm(pos);\n\t\t//vec3 sky = SkyColor(ray);\n        \n        col = mat.albedo.rgb;\n        //col = vec3(1); // test\n        //col = mat.albedo.rgb; // test\n        //col = calcAmb(pos, ray, nor, lightPos, lightColor, mat);\n        // Exponential distance fog\n        //col = mix(col, sky, fog_density(mat.dist));\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n#ifdef ENABLE_REFLECTION\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 3; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                //pos = pos + mat.dist * ray;\n                //float reflength = length(indirectPosition - p);\n                //p = indirectPosition;\n                //mat = indirectHit;\n\n                \n                \n                //result = calcAmb(pos, ray, nor, lightPos, lightColor, mat);\n\t\t\t\t//result = mat.albedo.rgb;\n                \n                //vec3 sky = SkyColor(ray);\n                dist += mat.dist;\n                \n                // Exponential distance fog\n                //result = mix(result, sky, fog_density(dist));\n\n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    \n        float t = iTime * M_PI2 * -0.1;\n        //float t = iTime * -1.0;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        float y = sin(t * 2.) * 0.25 + 0.5;\n        //float y = 0.25;\n        //float r = 2.0 + sin(t * 0.5);\n        float r = 2.;\n        float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90 + RAD90*0.25;\n        //float theta = t + RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.0, 0);\n        //vec3 ta = vec3(0. + t, -0.5, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1535, 1535, 1572, 1637, 1855], [2331, 2331, 2354, 2354, 2427], [2429, 2429, 2450, 2450, 2520], [2522, 2522, 2545, 2545, 2624], [2627, 2627, 2649, 2649, 3066], [3177, 3177, 3198, 3198, 3339], [3341, 3341, 3371, 3371, 3501], [3503, 3503, 3564, 3564, 3702], [3705, 3765, 3791, 3791, 4657], [4659, 4847, 4870, 4870, 4973], [4975, 4995, 5016, 5016, 5150], [5152, 5171, 5193, 5193, 5326], [5328, 5348, 5370, 5370, 5495], [5596, 5596, 5632, 5632, 5660], [5662, 5662, 5708, 5708, 5764], [5766, 5766, 5797, 5797, 5888], [5890, 5890, 5940, 5940, 6058], [6060, 6060, 6121, 6121, 6252], [6254, 6254, 6291, 6291, 6380], [6382, 6382, 6452, 6452, 6586], [6588, 6588, 6652, 6652, 6769], [6771, 6771, 6804, 6830, 6861], [6863, 6863, 6888, 6888, 6907], [6908, 6908, 6933, 6933, 6952], [6953, 6953, 6989, 6989, 7017], [7019, 7019, 7078, 7078, 7391], [7393, 7393, 7426, 7426, 7491], [7493, 7517, 7569, 7569, 7688], [7690, 7747, 7784, 7825, 7908], [7910, 7910, 7949, 8121, 8230], [8232, 8232, 8281, 8281, 8840], [8842, 8842, 8881, 8927, 9012], [9014, 9014, 9055, 9165, 9279], [9294, 9345, 9382, 9382, 9404], [9406, 9406, 9449, 9449, 9471], [9473, 9473, 9517, 9517, 9538], [9540, 9540, 9592, 9592, 9691], [9694, 9694, 9739, 9739, 10168], [10170, 10170, 10191, 10191, 10259], [10261, 10261, 10301, 10301, 10426], [10429, 10429, 10464, 10464, 10612], [10614, 10614, 10648, 10648, 10824], [10826, 10826, 10861, 10861, 10896], [10898, 10898, 10935, 10935, 10970], [10972, 11143, 11228, 11228, 11305], [11307, 11350, 11425, 11425, 11817], [11819, 12397, 12481, 12481, 12824], [12826, 12832, 12884, 12884, 13040], [13042, 13042, 13102, 13102, 13143], [13145, 13360, 13391, 13391, 13440], [13442, 13442, 13469, 13469, 13507], [13509, 13509, 13538, 13538, 13576], [13578, 13578, 13605, 13605, 13654], [13913, 13913, 13934, 13934, 14073], [14099, 14099, 14131, 14131, 14244], [14246, 14246, 14278, 14278, 14418], [14420, 14420, 14453, 14453, 14684], [14686, 14686, 14709, 14709, 15288], [15290, 15290, 15315, 15315, 15476], [15478, 15478, 15521, 15521, 16543], [16545, 16545, 16611, 16611, 16733], [16735, 16735, 16780, 16780, 16951], [16953, 16953, 17021, 17021, 17239], [17459, 17459, 17480, 17480, 18464], [18984, 18984, 19033, 19033, 19331], [19598, 19666, 19694, 19694, 19821], [19823, 19913, 19976, 19976, 20182], [20184, 20250, 20314, 20484, 21115], [21117, 21117, 21154, 21154, 21244], [21246, 21246, 21272, 21272, 22795], [22971, 22971, 22992, 22992, 23040], [23042, 23042, 23103, 23188, 23387], [23389, 23389, 23462, 23554, 23754], [23756, 23756, 23798, 23878, 23932], [23934, 23934, 23983, 23983, 24031], [24033, 24033, 24106, 24163, 24378], [24380, 24380, 24400, 24400, 24425], [24612, 24612, 24662, 24746, 25104], [25106, 25106, 25161, 25218, 25478], [25480, 25480, 25576, 25576, 26971], [27175, 27175, 27208, 27264, 27450], [27452, 27452, 27491, 27491, 27534], [27536, 27552, 27625, 27625, 27709], [27711, 27837, 27907, 27907, 28190], [28192, 28192, 28292, 28292, 29085], [29152, 29152, 29178, 29218, 29551], [29553, 29553, 29602, 29659, 32392], [32394, 32394, 32473, 32473, 34444], [34446, 34446, 34486, 34486, 37604], [37606, 37606, 37648, 37648, 37826]], "test": "valid"}
{"id": "3t2cRh", "name": "Alternating waves", "author": "Oggbog", "description": "Another happy accident", "tags": ["sinewave"], "likes": 1, "viewed": 175, "published": "Public API", "date": "1593715890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv = uv*cos(iTime)*4.;\n    \n    float a = uv.y + sin(sin(uv.x*cos(iTime)));\n    \n    uv.y = atan(a)*16.+10.;\n\t\n    float d = floor(mod(uv.y*2.,-a*6.));\n    \n    vec3 col = vec3(d/2.,-a,fract(a*4.));\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]], "test": "valid"}
{"id": "3t2cWW", "name": "Doughnut GodRay", "author": "Johnblu", "description": "光线步进渲染的甜甜圈，并且具有阴影和上帝光.", "tags": ["raymarching"], "likes": 6, "viewed": 103, "published": "Public", "date": "1594623334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fov 60.0\n#define beginCamPosition vec3(0.0, 0.0, -14.0)\n \n#define doughnutOffset 1.5\n#define doughnutRadius 0.6\n#define surfaceThreshold 1e-1\n \n#define planeHeight -4.0\n#define farClip 1e+4\n \n#define mainColor vec4(1.0,0.9,0.3,1.0)\n \nfloat plane_dist_estimator(in vec3 camPos, in vec3 viewDir)\n{\n    if(viewDir.y < 0.0 && camPos.y > planeHeight)\n    {\n        return abs(camPos.y - planeHeight) / abs(viewDir.y);\n    }\n    else if(viewDir.y > 0.0 && camPos.y < planeHeight)\n    {\n        return abs(camPos.y - planeHeight) / abs(viewDir.y);\n    }\n    return farClip;\n}\n \nfloat doughnut_dist_estimator(in vec3 surface_pos, in mat3 obj2WorldRot, in mat3 world2ObjRot)\n{\n    vec3 objPos = world2ObjRot * surface_pos;\n    objPos = vec3(objPos.x,0,objPos.z);\n    vec3 worldPos = obj2WorldRot * objPos;\n    \n    //一个平躺的甜甜圈\n    vec3 refPoint = normalize(worldPos) * doughnutOffset;\n    float len = length(surface_pos - refPoint);\n    return len - doughnutRadius;\n}\n \nvec3 surface_normal(in vec3 surface_pos, in mat3 obj2WorldRot, in mat3 world2ObjRot)\n{\n    vec3 objPos = world2ObjRot * surface_pos;\n    objPos = vec3(objPos.x,0,objPos.z);\n    vec3 worldPos = obj2WorldRot * objPos;\n    \n    //一个平躺的甜甜圈\n    vec3 refPoint = normalize(worldPos) * doughnutOffset;\n    return normalize(surface_pos - refPoint);\n}\n \nfloat surface_shadow(in vec3 surface_pos, in vec3 lightDir, in mat3 obj2WorldRot, in mat3 world2ObjRot)\n{\n    float dis = 0.1;\t//计算阴影必须有一个初始的距离\n    for(int i = 0; i < 32; ++i)\n    {\n        float delta = doughnut_dist_estimator(surface_pos + dis * -lightDir,obj2WorldRot,world2ObjRot);\n        dis += delta;\n        if (delta < surfaceThreshold)\n            return 0.0;\n    }\n    \n    return 1.0;\n}\n \nvec4 intersects(in vec3 camPos, in vec3 viewDir, in vec3 lightDir, in mat3 obj2WorldRot, in mat3 world2ObjRot,\n               out float resultDis)\n{\n    //射线查甜甜圈位置\n    float dis = 0.0;\n    for (int i = 0; i < 255; ++i)\n    {\n        float delta = doughnut_dist_estimator(camPos + dis * viewDir, obj2WorldRot, world2ObjRot);\n        dis += delta;\n        if (delta < surfaceThreshold)\n        {\n            resultDis = dis;\n            \n            //查询到甜甜圈\n            vec3 surface_pos = camPos+ viewDir * dis;\n        \tvec3 normalDir = surface_normal(surface_pos, obj2WorldRot, world2ObjRot);\n        \n        \tfloat dotv = dot(normalDir, -lightDir) * 0.5 + 0.5;\n        \tdotv = mix(0.1,1.0,dotv);\n        \treturn mainColor * dotv * 1.0;\n        }\n    }\n    \n    //射线查地面位置\n    dis = plane_dist_estimator(camPos, viewDir);\n    if(dis < farClip)\n    {\n        resultDis = dis;\n        \n        vec3 surface_pos = camPos+ viewDir * dis;\n        vec3 normalDir = vec3(0,1,0);\n        \n        float dotv = dot(normalDir, -lightDir) * 0.5 + 0.5;\n        dotv = mix(0.2,1.0,dotv);\n        \n        float interplate = mod(floor(surface_pos.x * 0.5) + floor(surface_pos.z * 0.5),2.0);\n        vec4 col = mix(vec4(0.5, 0.5, 0.5, 1),vec4(1, 1, 1, 1),interplate) * dotv;\n        float shadow = surface_shadow(surface_pos, lightDir, obj2WorldRot, world2ObjRot);\n        col = mix(mainColor * 0.5 * col,col,shadow);\n        \n        return mix(col, vec4(0.4,0.7,0.9,1), smoothstep(5.0,50.0,dis));\n    }\n    \n    //天空盒颜色\n    resultDis = farClip;\n    return vec4(0.4,0.7,0.9,1);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //甜甜圈的变换矩阵\n    float rotSpeed = iTime * 0.6;\n \n    vec3 tmpX0 = vec3(1,0,0);\n    vec3 tmpX1 = vec3(0,cos(rotSpeed),-sin(rotSpeed));\n    vec3 tmpX2 = vec3(0,sin(rotSpeed),cos(rotSpeed));\n    mat3 rotX = mat3(tmpX0,tmpX1,tmpX2);\n    \n    rotSpeed *= 2.0;\n    \n    vec3 tmpY0 = vec3(cos(rotSpeed),0,sin(rotSpeed));\n    vec3 tmpY1 = vec3(0,1,0);\n    vec3 tmpY2 = vec3(-sin(rotSpeed),0,cos(rotSpeed));\n    mat3 rotY = mat3(tmpY0,tmpY1,tmpY2);\n    \n    rotSpeed *= 2.0;\n    \n    vec3 tmpZ0 = vec3(cos(rotSpeed),-sin(rotSpeed),0);\n    vec3 tmpZ1 = vec3(sin(rotSpeed),cos(rotSpeed),0);\n    vec3 tmpZ2 = vec3(0,0,1);\n    mat3 rotZ = mat3(tmpZ0,tmpZ1,tmpZ2);\n    \n    mat3 obj2WorldRot = rotZ * rotX * rotY;\n    mat3 world2ObjRot = inverse(obj2WorldRot);\n    //甜甜圈的变换矩阵结束\n    \n    //摄像机旋转,拖动屏幕可以旋转摄像机\n    float radian = mix(-3.1415926,3.1415926,-iMouse.x / iResolution.x);\n    vec3 tmpCamY0 = vec3(cos(radian),0,sin(radian));\n    vec3 tmpCamY1 = vec3(0,1,0);\n    vec3 tmpCamY2 = vec3(-sin(radian),0,cos(radian));\n    mat3 rotCamY = mat3(tmpCamY0,tmpCamY1,tmpCamY2);\n    //摄像机旋转结束\n    \n    //------------------------------------------------------------------\n    \n    vec2 uv = (vec2(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0) / max(iResolution.x, iResolution.y)) * 2.0;\n    float tanValue = tan(radians(fov * 0.5));\n    float cameraDis = (iResolution.y / iResolution.x) / tanValue;\n    vec3 viewDir = normalize(vec3(uv, cameraDis));\t//这里通过fov确定每个像素的观察方向\n    viewDir = rotCamY * viewDir;\n    \n    float lightRotSpeed = iTime * 0.5;\n    vec3 lightDir = normalize(vec3(sin(-lightRotSpeed), -1, sin(lightRotSpeed * 2.0)));\n    \n    float resultDis;\n    vec3 camPosition = rotCamY * beginCamPosition;\n    fragColor = intersects(camPosition, viewDir, lightDir, obj2WorldRot, world2ObjRot, resultDis);\n    \n    //上帝光体积渲染\n    float sinV0 = sqrt(1.0 - pow(dot(normalize(vec3(0,0,0) - camPosition),lightDir),2.0));\n    float beginVertical = length((vec3(0,0,0) - camPosition)) * sinV0 - (doughnutOffset + doughnutRadius);\n    float endVertical = length((vec3(0,0,0) - camPosition)) * sinV0 + (doughnutOffset + doughnutRadius);\n\t\n    float sinV1 = sqrt(1.0 - pow(dot(lightDir,viewDir),2.0));\n    //这里算的是光线步进的开始距离与结束距离\n    float beginDis = beginVertical / sinV1;\n    float endDis = endVertical / sinV1;\n    \n    float totalRay = 0.0;\n    for (float i = beginDis; i < endDis; i += 0.2)\n    {\n        float totalDis = i;\n        if(totalDis > resultDis)\n        {\n            break;\n        }\n\t\tvec3 pos = camPosition + viewDir * totalDis;\n        float shadow = surface_shadow(pos, lightDir, obj2WorldRot, world2ObjRot);\n        totalRay += 1.0 - shadow;\n    }\n    \n    fragColor = mix(fragColor,mainColor,totalRay * 0.04);\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 303, 303, 576], [579, 579, 675, 675, 981], [984, 984, 1070, 1070, 1341], [1344, 1344, 1449, 1449, 1770], [1773, 1773, 1921, 1952, 3391], [3394, 3394, 3451, 3482, 6366]], "test": "error"}
{"id": "3t2czh", "name": "Warped Liquid Metal", "author": "mrange", "description": "Licence CC0: Liquid Metal\nSome experimenting with warped FBM and very very fake lighting turned out ok ", "tags": ["2d", "fbm", "warp"], "likes": 38, "viewed": 827, "published": "Public API", "date": "1593721238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Liquid Metal\n// Some experimenting with warped FBM and very very fake lighting turned out ok \n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat tanh_approx(float x) {\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat onoise(vec2 x) {\n  x *= 0.5;\n  float a = sin(x.x);\n  float b = sin(x.y);\n  float c = mix(a, b, psin(TAU*tanh_approx(a*b+a+b)));\n  \n  return c;\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm1(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm2(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 7; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm3(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\n\nfloat warp(vec2 p) {\n  vec2 v = vec2(fbm1(p), fbm1(p+0.7*vec2(1.0, 1.0)));\n  \n  rot(v, 1.0+iTime*0.1);\n  \n  vec2 vv = vec2(fbm2(p + 3.7*v), fbm2(p + -2.7*v.yx+0.7*vec2(1.0, 1.0)));\n\n  rot(vv, -1.0+iTime*0.21315);\n    \n  return fbm3(p + 1.4*vv);\n}\n\nfloat height(vec2 p) {\n  float a = 0.005*iTime;\n  p += 5.0*vec2(cos(a), sin(a));\n  p *= 2.0;\n  p += 13.0;\n  float h = warp(p);\n  float rs = 3.0;\n  return 0.35*tanh_approx(rs*h)/rs;\n}\n\nvec3 normal(vec2 p) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/iResolution.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx) - height(p - eps.yx);\n  \n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x*=iResolution.x/iResolution.y;\n \n  const vec3 lp1 = vec3(0.9, -0.5, 0.8);\n  const vec3 lp2 = vec3(-0.9, -1.5, 0.9);\n\n  float h = height(p);\n  vec3 pp = vec3(p.x, h, p.y);\n  float ll1 = length(lp1.xz - pp.xz);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n \n  vec3 n = normal(p);\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n \n  vec3 baseCol = vec3(1.0, 0.8, 0.6);\n\n  float oh = height(p + ll1*0.05*normalize(ld1.xz));\n  const float level0 = 0.0;\n  const float level1 = 0.125;\n  // VERY VERY fake shadows + hilight\n  vec3 scol = baseCol*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));\n\n  vec3 col = vec3(0.0);\n  col += baseCol*pow(diff1, 6.0);\n  col += 0.1*baseCol*pow(diff1, 1.5);\n  col += 0.15*baseCol.zyx*pow(diff2, 8.0);\n  col += 0.015*baseCol.zyx*pow(diff2, 2.0);\n  col += scol*0.5;\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2czh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 194, 194, 279], [281, 281, 305, 305, 375], [377, 377, 397, 397, 495], [497, 497, 518, 518, 547], [549, 549, 577, 577, 653], [655, 655, 677, 677, 805], [807, 807, 829, 829, 1396], [1398, 1398, 1418, 1418, 1792], [1794, 1794, 1814, 1814, 2188], [2190, 2190, 2210, 2210, 2584], [2587, 2587, 2607, 2607, 2833], [2835, 2835, 2857, 2857, 3017], [3019, 3019, 3040, 3073, 3281], [3283, 3283, 3320, 3320, 3569], [3571, 3571, 3628, 3628, 4620]], "test": "valid"}
{"id": "3t2yWW", "name": "Silver / Pell Spiral", "author": "jeyko", "description": "https://www.shadertoy.com/view/wljyWh       - I learned about this from this shader\nhttps://en.wikipedia.org/wiki/Silver_ratio  - Wikipedia page\nhttps://www.youtube.com/watch?v=7lRgeTmxnlg - Numberphile video ", "tags": ["spiral", "silver", "mean", "ratio", "pell"], "likes": 11, "viewed": 289, "published": "Public API", "date": "1594373688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// How can I make this zoom nicely?\n// The zoom is currently... number-crunched\n\n// https://www.shadertoy.com/view/wljyWh       - I learned about this from this shader\n// https://en.wikipedia.org/wiki/Silver_ratio  - Wikipedia page\n// https://www.youtube.com/watch?v=7lRgeTmxnlg - Numberphile video  \n\n\n#define ratio 1./(1. + sqrt(2.))\n\n\nfloat sdBox(vec2 p, float s){\n\tp = abs(p) - s;\n\treturn max(p.y, p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    float d = 10e6;\n    \n    uv /= pow(2.,mod(iTime,  2.543106606327)); // this line thanks to Fabrice! \n    \n    uv.x += sqrt(2.);\n    \n    \n\n    \n    float s = 1.;\n    \n    \n        \n    \n    float iters = 9.;\n    \n    vec2 p = uv;\n    \n    for(float i = 0.; i < 2.; i++){\n        if (i == 0.){\n            // left spiral\n            float firstBox = sdBox(uv, s);\n            d = min(d,abs(firstBox));\n            d = min(d,abs(max(length(uv - vec2(s,-s)) - s*2., firstBox)));\n        }\n        if (i == 1.){\n            // right spiral\n        \tp = uv; s = 1.;\n\n            p.x -= s*2. + s * ratio*2.;\n\n            p.x = - p.x;\n            p.y = - p.y;\n\n            float firstBox = sdBox(p, s);\n            d = min(d,abs(firstBox));\n            d = min(d,abs(max(length(p - vec2(s,-s)) - s*2., firstBox)));        \n        }\n        \n        \n        \n        for(float j = 0.; j < iters; j++){\n\n            float dSpiral;\n            if ( mod(j, 4.) == 0. ){\n                p.xy -= vec2(s,s);\n                s *= ratio;\n                p.xy -= vec2(s,-s);\n\n                dSpiral = length(p - vec2(-s,-s)) - s*2.;\n            } else if ( mod(j, 4.) == 1. ){\n                p.xy -= vec2(s,-s);\n                s *= ratio;\n                p.xy -= vec2(-s,-s);\n\n                dSpiral = length(p - vec2(-s,s)) - s*2.;\n            } else if ( mod(j, 4.) == 2. ){\n\n                p.xy -= vec2(-s,-s);\n                s *= ratio;\n                p.xy -= vec2(-s,s);\n\n                dSpiral = length(p - vec2(s,s)) - s*2.;\n            } else if ( mod(j, 4.) == 3. ){\n\n                p.xy -= vec2(-s,s);\n                s *= ratio;\n                p.xy -= vec2(s,s);\n\n                dSpiral = length(p - vec2(s,-s)) - s*2.;\n            }\n\n            float dBox = sdBox(p, s);\n\n            d = min(d,\n                    ( min( abs(dBox), max( dSpiral, dBox)))\n                   );\n        }\n    }\n    \n    \n    \n    col = mix(col,vec3(1),smoothstep(dFdx(uv.x),0.,abs(d)));\n    \n    col = pow(col,vec3(0.4545)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2yWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 367, 367, 409], [411, 411, 468, 468, 2643]], "test": "valid"}
{"id": "3t2yWz", "name": "toon flame", "author": "tukigp", "description": "I wanted a toon flame so I mixed RVA Game Jams Magic Flame Demo created by samlo with the fire toon shader created by floatvoid.\nAll credits to them", "tags": ["fire"], "likes": 13, "viewed": 262, "published": "Public", "date": "1594151232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FLAME MASK SHAPING\n#define FLAME_SIZE 2.2\n#define FLAME_WIDTH 1.3\n#define DISPLACEMENT_STRENGTH 0.3\n#define DISPLACEMENT_FREQUENCY 5.0\n#define DISPLACEMENT_EXPONENT 1.5\n#define DISPLACEMENT_SPEED 5.0\n#define TEAR_EXPONENT 0.7\n#define BASE_SHARPNESS 4.0\n\n// NOISE\n#define NOISE_SCALE 3.0\n#define NOISE_SPEED -2.7\n#define NOISE_GAIN 0.5\n#define NOISE_MULT 0.35\n\n// FLAME BLENDING\n#define FALLOFF_MIN 0.2\n#define FALLOFF_MAX 1.3\n#define FALLOFF_EXPONENT 0.9\n\n// COLOR\n#define BACKGROUND_MIN 0.0\n#define BACKGROUND_MAX 0.15\n#define RIM_EXPONENT 2.0\n#define BACKGROUND_COLOR_MIN vec3(1, 0.0, 0.)\n#define BACKGROUND_COLOR_MAX vec3(1.0, 0.3, 0.0)\n#define RIM_COLOR vec3(1.0, 0.9, 0.0)\n\n// GLOW\n#define FLICKER_SPEED 10.0\n#define FLICKER_STRENGTH 0.08\n#define GLOW_OFFSET vec2(0.0, 0.1)\n#define GLOW_EXPONENT 4.0\n#define GLOW_WIDTH 1.5\n#define GLOW_SIZE 0.4\n#define GLOW_STRENGTH 0.4\n#define GLOW_COLOR vec3(1.0, 0.8, 0.0)\n\n\nvec3 permute(vec3 x)\n{ \n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n            -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float pixelWidth = abs(float(fragCoord.x ) * float(iResolution.xy));\n\n    \n   \tfloat aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec2 p = uv - vec2(0.5 * aspect, 0.5);\n    vec2 glowP = p; // this is saved for when we do our glow\n    \n    // shape our base flame mask.\n    // first we squish a circle and displace it, then we turn it into a teardrop shape\n    p *= FLAME_SIZE;\n    p.x *= FLAME_WIDTH;\n    \n    float flameDisplacement = max(0.0, sin(iTime * DISPLACEMENT_SPEED + (p.y * DISPLACEMENT_FREQUENCY)) * DISPLACEMENT_STRENGTH * pow(uv.y - 0.1, DISPLACEMENT_EXPONENT));\n    p.x += flameDisplacement;\n    p.x += p.x / pow((1.0 - p.y), TEAR_EXPONENT); // teardrop shaping\n    \n    // next we create our base flame mask, it looks a bit like a spooky ghost\n    float gradient = length(p);\n    float base = 1.0 - pow(gradient, BASE_SHARPNESS);\n    \n\t// next we create our noise mask, which we will use to create the flickering part\n    // of the flame\n    //float noise = snoise((uv * NOISE_SCALE) + vec2(0.0, iTime * NOISE_SPEED)) * NOISE_MULT + NOISE_GAIN;\n    float up0 = snoise((uv *NOISE_SCALE) + vec2(0.0, iTime * NOISE_SPEED)) * NOISE_MULT + NOISE_GAIN;\n\tfloat up1 = 0.5 + snoise((uv *NOISE_SCALE) + vec2(0.0, iTime * NOISE_SPEED)) * NOISE_MULT + NOISE_GAIN;\n    \n    // define a gradient that we can use to make the flame fall off at the top,\n    // and apply it to BOTH the flame mask and the noise together\n    float flame = (base * up0*up1);\n    \n   \n    \n    float falloff = smoothstep(FALLOFF_MIN, FALLOFF_MAX, pow(uv.y, FALLOFF_EXPONENT));\n    flame = clamp(flame - falloff, -0.0, 1.0); // we have a flame!\n    \n    // time to give it some color! we will do this with two masks,\n    // a background mask, and a rim light mask\n    float background = smoothstep(BACKGROUND_MIN, BACKGROUND_MAX, flame);\n\tfloat rim = pow(1.0 - flame, RIM_EXPONENT) * background;\n    \n    // first we calculate our background color. I did a vertical gradient from dark purple to light purple,\n    // and it is multiplied by the background mask\n    vec3 color = mix(BACKGROUND_COLOR_MIN, BACKGROUND_COLOR_MAX, uv.y) * background;\n    \n    vec3 dark = mix( vec3(0.0), vec3( 1.0, 0.4, 0.0),  smoothstep(0.25,flame,pixelWidth) ) ;\n    vec3 light = mix( dark, vec3( 1.0, 0.8, 0.0),  smoothstep(0.7, flame,pixelWidth) ) ;\n    \n    // now we apply rim light (I did cyan). We mix over our current color using the rim light mask\n    color = mix(color, RIM_COLOR, light);\n    \n    // we could call it a day now, but lets add a little glow to give our flame a bit more ambience\n    // this time we'll make the glow flicker using noise! noise is a fantastic way to animate things as well\n    float glowFlicker = 1.0 + snoise(vec2(iTime * FLICKER_SPEED)) * FLICKER_STRENGTH;\n    glowP += GLOW_OFFSET;\n    glowP.x *= GLOW_WIDTH;\n    glowP *= GLOW_SIZE;\n    \n  \n\n    \n    vec3 glow = GLOW_COLOR * (pow(1.0 - length(glowP), GLOW_EXPONENT) * GLOW_STRENGTH * glowFlicker);\n    color += glow; \n    // all done!\n    \n    \n  \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2yWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[920, 920, 942, 942, 986], [990, 990, 1012, 1012, 1877], [1881, 1881, 1938, 1938, 5033]], "test": "valid"}
{"id": "3t2yzG", "name": "sd line animation", "author": "dtsmio", "description": "lines animation", "tags": ["sdlines"], "likes": 5, "viewed": 107, "published": "Public", "date": "1594691485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = min(1., max(0., dot(pa, ba)/dot(ba, ba)));\n    \n    return vec2(length(pa - ba * h), h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tuv *= 3.;\n    float time = iTime * 4.;\n    float sp = 2.5;\n    \n    float a = 0.1 + floor(time) * sp;\n    vec2 p1 = vec2(sin(a), cos(a));\n    vec2 p2 = vec2(sin(a + sp), cos(a + sp));\n    vec2 p3 = vec2(sin(a + sp * 2.), cos(a + sp * 2.));\n    \n    vec2 l1 = line(p1, p2, uv);\n    vec2 l2 = line(p2, p3, uv);\n\n    l1.x = smoothstep(0.04, 0.01, l1.x);\n    l2.x = smoothstep(0.04, 0.01, l2.x);\n    float prog1 = pow(fract(time), 0.8);\n    float prog2 = pow(fract(time), 2.);\n    \n    float al = max(smoothstep(prog2, prog1, l1.y) * l1.x, \n                   smoothstep(prog1, prog2, l2.y) * l2.x);\n    \n    vec3 col = vec3(0);\n    col += al;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2yzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 170], [173, 173, 230, 230, 965]], "test": "valid"}
{"id": "3tBcRc", "name": "Lissajous curve", "author": "VechirkoIgor", "description": "Lissajous curve", "tags": ["lissajouscurve"], "likes": 0, "viewed": 171, "published": "Public API", "date": "1594917059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat roundRadius = 0.06f * 800.0f;\n\nvec2 getRoundPos()\n{\n    vec2 pos = vec2( sin(iTime), cos(iTime/2.0f) );\n    \n    pos = pos / 2.0f;\n    pos = pos + vec2( 0.5f );\n    \n    return pos;\n}\n\nvec4 getBackgroundColor()\n{\n    return vec4( 0.3f, 0.3f, 0.3f, 1.0f );\n}\nvec4 getRoundColor()\n{\n    return vec4( 0.0f, 1.0f, 0.0f, 1.0f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float distToRoundCenter = length(getRoundPos()*iResolution.xy - fragCoord);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    if ( uv.x > 0.499f && uv.x < 0.501f )\n    {\n        fragColor = vec4( 1.0f, 0.0f, 0.0f, 1.0f );\n    }\n    else if ( uv.y > 0.498f && uv.y < 0.502f )\n    {\n        fragColor = vec4( 1.0f, 0.0f, 0.0f, 1.0f );\n    }\n    else if ( distToRoundCenter > roundRadius )\n    {\n         fragColor = getBackgroundColor();\n    }\n    else\n    {\n        fragColor = getRoundColor();\n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBcRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 190], [192, 192, 219, 219, 264], [265, 265, 287, 287, 332], [334, 334, 391, 391, 902]], "test": "valid"}
{"id": "3tBcWm", "name": "Music Cave", "author": "blackle", "description": "my qualifier round for the live code compo at solskogen 2020, ported to shadertoy. coded in 15 minutes live <:\nwatch the replay here: https://www.youtube.com/watch?v=5rjNcG7ioaU", "tags": ["livecode"], "likes": 21, "viewed": 434, "published": "Public API", "date": "1594478575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat edges;\nfloat comp(vec3 p) {\n  vec3 s = sin(p)*sin(p);\n  edges = max(max(edges,s.x),max(s.z,s.y));\n  p = asin(sin(p));\n  return dot(p,normalize(vec3(1)));\n}\n\nfloat stage;\nfloat cave;\nfloat pillars;\nfloat scene(vec3 p) {\n  edges = 0.;\n  float d1 = comp(erot(p,normalize(vec3(3,2,1)),0.5)+1.);\n  float d2 = comp(erot(p,normalize(vec3(2,1,3)),0.6)+2.);\n  float d3 = comp(erot(p,normalize(vec3(1,3,2)),0.7)+3.+iTime*mod(stage,2.));\n  cave = (d1+d2+d3)/3. - length(p.zy*vec2(1,.2))/3. + 2.;\n  pillars = length(asin(sin(p.xy/3.+2.))*3.)-.2 - pow(texture(iChannel0,vec2(abs(p.z)/400.,0)).r,4.)/2. - p.z*p.z/100.;\n  return min(cave,pillars);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\n//hello world\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  float t = iTime/60.*125.;\n  stage = floor(t/4.);\n  t += mod(stage,100.)*34.23;\n  vec3 cam = normalize(vec3(1.2+sin(stage),uv));\n  vec3 init= vec3(-4,0,0);\n  cam = erot(cam,vec3(1,0,0),t/6.*sign(cos(stage*32.3)));\n  if(cos(stage*7.)<0.)cam=cam.zxy;\n  init.x += mod(t,100.)*3.*sign(cos(stage*10.3));\n  vec3 p =init;\n  bool hit = false;\n  float dist;\n  float glow = 0.;\n  for (int i = 0; i < 150 && !hit ; i ++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    glow += smoothstep(.99,1.,edges)/(1.+abs(cave)*200.)*pow(abs(sin(p.x/40.+iTime)),20.)/2.;\n    glow += pow(texture(iChannel0,vec2(abs(p.z)/20.,0)).r,4.)/(1.+abs(pillars)*100.)/2.;\n    p+=cam*dist;\n  }\n  bool pl = pillars==dist;\n  float ms = step(0.999,edges);\n  float fog = smoothstep(80.,0.,distance(p,init));\n#define AO(p,n,t) smoothstep(-t,t,scene(p+n*t))\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float ao = AO(p,n,1.)*AO(p,n,.5)*AO(p,n,.1);\n  float sss = AO(p,vec3(0.7),1.);\n  float spec = length(sin(r.xy*3.)*.4+.6)/sqrt(2.);\n  vec3 matcol = pl ? vec3 (0.9,0.1,0.05) : vec3(0.8);\n  vec3 col = mix(spec,sss,.5)*matcol;\n  if(!pl)col *= 1.-ms;\n  col += pow(spec,10.);\n  fragColor.xyz = sqrt((hit ? col*fog*ao : vec3(0.03)) + glow*glow + glow*vec3(0.5,0.7,1));\n  fragColor *= 1.-dot(uv,uv)*.7;\n}", "image_inputs": [{"id": "XlS3Rt", "previewfilepath": "https://soundcloud.com/anamanaguchi/kei-feat-pochi", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/anamanaguchi/kei-feat-pochi", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBcWm.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[195, 195, 233, 233, 293], [308, 308, 328, 328, 456], [498, 498, 519, 519, 935], [937, 937, 956, 956, 1069], [1071, 1085, 1142, 1142, 2470]], "test": "error"}
{"id": "3tBczh", "name": "Mellifera I", "author": "sl2c", "description": "Apparently this construction on a right-angled polyhedron with 14 faces was one of the first hyperbolic 3-manifolds known.", "tags": ["circles", "hyperbolic", "horosphere"], "likes": 9, "viewed": 133, "published": "Public", "date": "1594073364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec3 z, inout float ds, in vec2 c, in float r, inout float t) {\n    z -= vec3(c,0.0);\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        ds *= r * r / dot(z,z);\n        z *= r * r / dot(z,z);\n    }\n    t = min(t, (dot(z,z)-r*r)/(2.0 * r * ds));\n    z += vec3(c,0.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3[3] colorizers = vec3[](\n        vec3(0.25,0.0,0.0),\n        vec3(0.0,0.3,0.0),\n        vec3(-0.13)\n    );\n    int[14] m = int[](3,0,1,2,0,1,2,0,2,1,0,2,1,3);\n    \n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    z *= 10.0; ds *= 10.0;\n    vec3 zh = vec3(z, 1.0);\n    \n    vec2[14] c; float[14] r;\n    float r1 = sqrt(sqrt(3.0) - sqrt(2.0));\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1;\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<6; i++) {\n        float theta = tau * float(i) / 6.0;\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+7] = r3;\n        c[i+7] = x3 * eit.yx;\n    }\n    float r4 = -1.0 / r1;\n    r[13] = r4; c[13] = vec2(0.0);\n    \n    \n    float period = -8.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    zh *= exp(-d); ds *= exp(-d);\n\t\n    bool[4] flips=bool[](false,false,false,false);\n    float[4] ts=float[](1.0,1.0,1.0,1.0);\n    for (int i=0; i<6; i++) {\n        for (int j=0; j<14; j++) {\n            flips[m[j]] = flips[m[j]] ^^ flip(zh, ds, c[j], r[j], ts[m[j]]);\n        }\n    }\n    vec3 col = vec3(0.5);\n    if (flips[3]) {\n        ts[3] = -ts[3];\n    }\n    for (int i=0; i<3; i++) {\n        if (flips[i]) {\n            ts[i] = -ts[i];\n        }\n        col += colorizers[i] * ts[i] * ts[3];\n    }\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBczh.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [], "test": "error"}
{"id": "3tByDm", "name": "Sine Line pt2", "author": "ShaderLyf", "description": "Trying to figure out mouse interaction to control individual strings. Think guitar app. ", "tags": ["sineline"], "likes": 3, "viewed": 89, "published": "Public", "date": "1594480714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adpated from: https://www.shadertoy.com/view/Xsl3WH by Nikos Papadopoulos, 4rknova / 2013\n// WTFPL\n\n#define A .4 // Amplitude\n#define V 9. // Velocity\n#define W 16. // Wavelength\n#define T .001 // Thickness\n#define S 1. // Sharpness\n#define Abba 0.000 // aberation\nint Str = 12; // String Amount\nfloat O1;\nfloat sine(vec2 p, float o, float w)\n{\n    float nw = abs(sin(iTime*0.9)*8.0);\n    float nw2 = (sin(iTime*0.08)*0.125);\n    return pow(T / abs((p.y + sin((p.x * nw+w + o)) * A*nw2)), S);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy * 1. - 1.;\n    vec3 s = vec3(0.0);\n    \n    for (int i = 0; i < Str; i++)\n    {\n        float sh = (1.0/float(Str))/2.0;\n        float sep = (1.0/float(Str)) * float(i);\n        \n        vec2 pos = vec2(p.x,p.y) + (sep+sh);\n       // s -= vec3(sine(pos, (iTime * V)*O1,W*O1-float(i)  ));\n        s.x += vec3(sine(pos-Abba, (iTime * V),W-float(i) )).x;\n        s.y += vec3(sine(pos, (iTime * V),W-float(i) )).y;\n        s.z += vec3(sine(pos+Abba, (iTime * V),W-float(i) )).z;\n    }  \n\tfragColor = vec4(s, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByDm.jpg", "access": "shaders20k", "license": "wtfpl-2.0", "functions": [[309, 309, 347, 347, 497], [499, 499, 556, 556, 1106]], "test": "valid"}
{"id": "3tByDW", "name": "Under ground", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 148, "published": "Public", "date": "1594304641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Data {\n    float interval;\n    vec3 pos0, pos1, dir0, dir1;\n};\n\nData data[] = Data[]( \n\tData(9., vec3(.3,1,-1),   vec3(0,.5,0),   vec3(1,0,1),  vec3(0,1,1)),\n    Data(8., vec3(0,.3,.6),   vec3(0,0,.6),   vec3(0,1,1),  vec3(1,1,1)),\n    Data(8., vec3(0,0,.4),    vec3(0,0,1.2),  vec3(1,0,-1), vec3(1,1,1)),\n    Data(8., vec3(-.8,.4,.6), vec3(-.5,.6,0), vec3(0,0,1),  vec3(1,0,1)),\n    Data(8., vec3(0,.4,.7),   vec3(.4,0,.7),  vec3(1,-1,0), vec3(0,1,1)),\n    Data(7., vec3(.8,.6,.3),  vec3(.2,-.8,0), vec3(1,0,1),  vec3(0,1,1))\n);\n\n#define PI acos(-1.)\n#define TAU PI*2.\n#define PIH PI*.5\n#define pmod(p,n)length(p)*sin(vec2(0.,PIH)+mod(atan(p.y,p.x),TAU/n)-PI/n)\n#define fold(p,v)p-2.*min(0.,dot(p,v))*v;\n\nfloat map(vec3 p)\n{\n\tfloat s = 1.0;\n    p.z=fract(p.z)-.5;\n\tfor(int i=0;i<20;i++)\n\t{\n\t    p.y += .15;\n\t    p.xz = abs(p.xz);\n\t    for(int j=0;j<2;j++)\n        {\n\t        p.xy = pmod(p.xy,8.);\n\t        p.y -= .18;\n\t    }\n\t    p.xy = fold(p.xy,normalize(vec2(1,-.8)));\n\t\tp.y = -abs(p.y);\n\t\tp.y += .4;\n\t    p.yz = fold(p.yz,normalize(vec2(3,-1)));\n\t\tp.x -= .47;\n\t\tp.yz = fold(p.yz,normalize(vec2(2,-7)));\n\t\tp -= vec3(1.7,.4,0);\n        float r2= 3.58/dot(p,p);\n        p *= r2;\n\t\tp += vec3(1.8,.7,.0);\n\t\ts *= r2;\n\t}\n\treturn length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx, size = data.length();\n\tfloat sam = 0.;\n    for(int i=0; i<size; i++) sam += data[i].interval;\n    float time = mod(iTime,sam);\n    sam = 0.;\n    for(idx=0; idx<size && time>sam; idx++)\n        sam += data[idx].interval;\n    Data P = data[idx-1];\n    float t = (time-sam+P.interval)/P.interval;\n    const float zoom = 3.;\n\tvec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = mix(P.pos0, P.pos1, t)*zoom,\n          w = normalize(mix(P.dir0, P.dir1, t)),\n          u = normalize(cross(w,vec3(0,1,0))),\n         rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n    float h = 0.0,d,i;\n    vec3 p;\n    for(i=1.;i<100.;i++)\n    {\n        p = ro+rd*h;\n        p /= zoom;\n\t    d = map(p);\n        if(d<0.001)break;\n        h += d;\n    }\n\tfragColor.xyz=30.*vec3(cos(p*1.5)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[713, 713, 732, 732, 1248], [1250, 1250, 1307, 1307, 2112]], "test": "error"}
{"id": "3tByR1", "name": "simple clock", "author": "jason82", "description": "thanks: iq and FabriceNeyret2", "tags": ["2d", "sdf", "line", "clock"], "likes": 9, "viewed": 245, "published": "Public API", "date": "1593669727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cycle 1.5\n#define scale 0.8\n#define bg vec3(0, 0.6627451, 0.6196078)\n#define PI 3.1415926\n#define PI2 6.2831853\n\nmat2 rotate(float deg) {\n  return mat2(cos(deg), sin(deg), -sin(deg), cos(deg));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float width, float blur) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  vec2 dir = normalize(ba);\n  float t = clamp(dot(pa, dir), 0., length(ba));\n  float dist = length(pa - dir * t);\n  return smoothstep(width - blur, width, dist);\n}\n\nvec3 hourPointer(vec2 uv, vec3 color, float time) {\n  float rate = fract(time / 12.0);\n  mat2 m = rotate(rate * PI2);\n  float d = line(uv, vec2(0,-0.03) * m, vec2(0,0.3) * m, 0.02, 0.005);\n  color = mix(vec3(0), color, d);\n  return color;\n}\nvec3 minutePointer(vec2 uv, vec3 color, float time) {\n  float rate = fract(time / 60.0);\n  mat2 m = rotate(rate * PI2);\n  float d = line(uv, vec2(0,-0.04) * m, vec2(0,0.4) * m, 0.015, 0.005);\n  color = mix(vec3(0), color, d);\n  return color;\n}\nvec3 secondPointer(vec2 uv, vec3 color, float time) {\n  float rate = fract(time / 60.0);\n  mat2 m = rotate(rate * PI2);\n  float d = line(uv, vec2(0,-0.05) * m, vec2(0,0.5) * m, 0.005, 0.005);\n  color = mix(vec3(0.9921568,0.0666667,0.0666667), color, d);\n  return color;\n}\n\nfloat circle(vec2 p, vec2 c, float radius, float blur) {\n  vec2 pc = p - c;\n  float dist = length(pc);\n  return smoothstep(radius - blur, radius, dist);\n}\n\nvec3 plate(vec2 uv, vec3 color) {\n  float d1 = circle(uv, vec2(0), 0.7, 0.005);\n  float d2 = circle(uv, vec2(0), 0.63, 0.005);\n\n  color = mix(vec3(0.4039215, 0.8235294, 0.7843137), color, d1);\n  color = mix(vec3(1), color, d2);\n\n  float r = length(uv);\n  float a = atan(uv.x, uv.y);\n  float ss = PI / 30.;\n  float hs = PI / 6.;\n  float st = fract(a / ss);\n  float mst = min(abs(1.-st), st);\n  float ht = fract(a / hs);\n  float mht = min(abs(1.-ht), ht);\n\n  if (r > 0.58 && r < 0.6 && mst < 0.06) {\n    float sd = smoothstep(0.06 - 0.03, 0.06, mst);\n    color = mix(vec3(0), color, sd);\n  }\n  if (r > 0.55 && r < 0.6 && mht < 0.1) {\n    float hd = smoothstep(0.1 - 0.03, 0.1, mst);\n    color = mix(vec3(0), color, hd);\n  }\n\n  return color;\n}\n\nvec3 shadow(vec2 uv, vec3 color, vec2 c, vec2 d, float dist) {\n  d = normalize(d);\n  float l = dot(uv, d);\n  float w = length(uv - d * l);\n  float rate = l / dist;\n  if (w > 0.7 || rate <= 0. || rate >= 1.) return color;\n\n  vec3 pm = mix(color, vec3(0), 0.12);\n  color = mix(pm, color, rate);\n  return color;\n}\n//t = iDate.w/60., m = floor(t)/60.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n  uv /= scale;\n\n    \n  float iSecond = iDate.w;\n  float iMinute = iSecond/60.;\n  float iHour = iMinute/60.;\n\n  // animate\n  float tt = mod(iTime, cycle) / cycle;\n  float ss = 1.0 + 0.5 * sin(tt * PI * 6.0 + uv.y * 0.5) * exp(-tt * 4.0);\n  uv *= vec2(0.7, 1.5) + ss * vec2(0.3, -0.5);\n\n  // mix some color\n  vec3 color = bg;\n  color = plate(uv, color);\n  color = hourPointer(uv, color, iHour);\n  color = minutePointer(uv, color, iMinute);\n  color = secondPointer(uv, color, iSecond);\n  color = shadow(uv, color, vec2(0), vec2(1, -1), 1.4);\n\n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 145, 145, 203], [205, 205, 266, 266, 468], [470, 470, 521, 521, 710], [711, 711, 764, 764, 954], [955, 955, 1008, 1008, 1226], [1228, 1228, 1284, 1284, 1382], [1384, 1384, 1417, 1417, 2124], [2126, 2126, 2188, 2188, 2436], [2475, 2475, 2532, 2580, 3263]], "test": "valid"}
{"id": "3tByRh", "name": "Jagarikin illusion", "author": "ciphered", "description": "This work was sort of a test to see if I could reproduce one of the many amazing illusions from Jagarikin.\nMore of his work: https://twitter.com/jagarikin\nColor linear interpolation by Fabrice Neyret", "tags": ["illusion", "perception", "opart", "jagarikin"], "likes": 3, "viewed": 310, "published": "Public API", "date": "1593645483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Very highly inspired by the work of Jagarikin \n// https://twitter.com/jagarikin\n//\n// I basically took his concept to understand how it could be implemented, before going into\n// further exploration. Please go check his work if you liked this one !\n//\n// From my understanding, the illusion of a motion comes from the shift in hue being applied\n// width a small offset on the borders. The brain was trained in extracting motion using the\n// colors, because usually in real life objects do not tend to change color, therefore a \n// change in color at a particular point is often due to a motion at the point. When an object\n// moves, a color on its surface is supposed to follow the motion of the object in the world \n// referential.\n//\n// I took the rainbow color interpolation from Fabrice Neyret \n// https://www.shadertoy.com/view/MtG3Wh\n// The color transitions are just so smooth and work so well in this context. Thanks to him !\n//\n\n#define PI 3.14159265359\n#define DELAY 0.17\n#define SIZE 0.15\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n\n\n// @author Fabrice Neyret \n// https://www.shadertoy.com/view/MtG3Wh\n// His color interpolation just works so well with this illusion !\nvec3 rainbow (float h) {\n\tvec4 O = mod(vec4(1,2,3,0)-3.*h, 3.); O = min(O,2.-O);     // linear rainbow\n  \tO = .5+.5*cos(6.283185*(h +vec4(0,1,-1,0)/3.));       // 1/j/j² rainbow \n    //O = pow(max(O,0.),vec4(1./2.2));\t\t// gamma correction\n    return O.rgb;\n}\n\n// some sort of lerp r g b r\n// looks bad\nvec3 hsv2rgb(float h)\n{\n    h = mod(h, 1.);\n    vec3 c1 = vec3(1,0,0);\n    vec3 c2 = vec3(0,1,0);\n    vec3 c3 = vec3(0,0,1);\n    return h < .33 ? mix(c1, c2, h/.33) : \n    \th < .66 ? mix(c2, c3, (h-.33)/.33)\n        : mix(c3, c1, (h-.66)/.33);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // time\n    float t = iTime * .9;\n    \n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    uv*= iResolution.y * .01;\n    vec2 id = floor(uv);\n    uv = fract(uv) - .5;\n    uv*= rot(clamp(cos(t*.3), -.2, .2)/.2*PI*.25+ id.x*id.y);\n    // square\n    vec2 s = smoothstep(SIZE, SIZE-0.01, abs(uv));\n    float sq =  s.x * s.y;\n    \n    float hueShift = (id.x*id.y)*.04 * pow(min(1., iTime/60.), 3.5);\n    \n    // left border\n    s = smoothstep(SIZE, SIZE-0.01, abs(uv + vec2(.03, 0)));\n    float lf = min(s.x * s.y, 1.-sq);\n    float lfH = t + DELAY + hueShift;\n    vec3 lfC = rainbow(lfH);\n    \n    // right border\n    s = smoothstep(SIZE, SIZE-0.01, abs(uv - vec2(.03, 0)));\n    float rt = min(s.x * s.y, 1.-sq);\n    float rtH = t - DELAY + hueShift;\n    vec3 rtC = rainbow(rtH);\n    \n    float ch = t + hueShift;\n    vec3 c = rainbow(ch);\n    \n\n    vec3 col = vec3(.5);\n    \n    col = mix(col, c, sq);\n    col = mix(col, lfC, lf);\n    col = mix(col, rtC, rt);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1198, 1222, 1222, 1457], [1459, 1501, 1524, 1524, 1746], [1749, 1749, 1806, 1818, 2816]], "test": "valid"}
{"id": "3tByRm", "name": "Vectors Overlaid Texture Offsets", "author": "BigotedSJW", "description": "was about to make my own vector field visualizer but someone, namely @reima and @morgan3d, beat me to it", "tags": ["2d", "vectors"], "likes": 2, "viewed": 90, "published": "Public", "date": "1593924429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//arrow plot stolen from https://www.shadertoy.com/view/ls2GWG by @reima and @morgan3d\n\n//reima's code starts here\n\nconst float ARROW_TILE_SIZE = 24.0;\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//Bigo's code starts here\n\nvec2 field(vec2 pos){\n\tvec2 uv = (pos.xy - iResolution.xy * 0.5) / (0.5*iResolution.y);\n    float offsetScale = 2.0*cos(iTime);\n    \n    vec2 offsetDir = normalize(uv);\n    \n    float distSq = dot(uv, uv);\n    \n    vec2 offsetOverall = offsetScale * distSq * offsetDir;\n    \n    vec2 texCoord = uv - offsetOverall;\n    \n    return texCoord;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float arrow_dist = arrow(fragCoord.xy,\n\t                         field(arrowTileCenterCoord(fragCoord.xy)) * ARROW_TILE_SIZE * 0.4);\n\n    vec4 arrow_col = vec4(1., 1.0, 1.0, clamp(arrow_dist, 0.0, 1.0));\n    \n    vec2 textCoord = field(fragCoord);\n    \n    vec4 field_col = texture(iChannel0, textCoord);\n\n    // Output to screen\n    fragColor = fragColor = mix(arrow_col, field_col, arrow_col.a);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 215, 252, 252, 318], [320, 372, 410, 410, 656], [658, 804, 833, 901, 1603], [1632, 1632, 1653, 1653, 1974], [1977, 1977, 2034, 2034, 2438]], "test": "error"}
{"id": "3tByzw", "name": "Bouncing Marble", "author": "koo1ant", "description": "Trying out some transformation matrices + using SDFs to fake lighting and shadow/AO. \nThe marble has a specular and bottom reflection made with offset'd SDFs as well. \nGot here experimenting with fake 3D. There are probably better ways to do this.", "tags": ["3d", "checkerboard", "ball", "bounce", "marble", "flyby"], "likes": 10, "viewed": 627, "published": "Public API", "date": "1593908657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define resolution iResolution\n\nprecision highp float;\n\nmat4 rotX(in float angle) {\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), - sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotY(in float angle) {\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1.0, 0, 0,\n        - sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return\n    (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nfloat sat(float v){\n    return clamp(v, 0.,1.);\n}\n\n// Fake a bouncing ball in screen-space UV\nvoid ball(inout float buf, vec2 uv, float phase, float radius, float bh) {\n    float bounce = abs(sin(t * 3.0 + phase)) * bh;\n    float bd = 1.00 + pow(abs(sin(t * 3.0 + 3.14 / 2.0 - 0.1 + phase)), 50.00) * 0.17;\n    float ballRadius = radius;\n    float shadowSize = abs(sin(t * 3.0 + phase)) * 1.00 + 1.00;\n    float a = atan(uv.y - bounce + 0.02, uv.x + -0.37);\n\n    // Shadow\n    float shadow = 1.0 - smoothstep(-0.5, 0.8, length(vec2(uv.x * (shadowSize*2.), uv.y * 1.75 * (shadowSize*2.)) - vec2(0.00, - 0.36)) - ballRadius + 0.0);\n    buf -= smoothstep(0.0, 0.8, shadow) * 0.8; // Soften the shadow a little bit\n\t\n    // Cut a hole in the buffer\n    buf *= step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius);\n\n    // Add specular\n    float mask = sat(1.0 - step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius));\n    float impulse = sin(t*6.+1.20); // Spin a little faster when it hits the ground\n    float spin = sin(a * 18.0 + ((t * 12.0) + impulse)) * 0.03;\n    float specular = smoothstep(\n        0.30 + spin,\n        -0.02,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) *  mask +\n        // Fake reflection\n        smoothstep(\n            0.30 + sin(a * 18.0 + t*10.) * 0.03,\n            +0.52,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) * mask;;\n\n    buf += specular;\n}\n\nvoid ground(inout float p, vec2 uv) {\n    // Sine checkers\n    p += step(sin(uv.y * 10.00) * sin(t), sin(uv.x * 10.0));\n}\n\nvoid light(inout float p, vec2 pv){\n    vec2 lightPos = vec2(pv.x, pv.y);\n    p *= 1.-smoothstep(0.0, 10., length(lightPos - vec2(sin(t), 0.0)));\n}\n\nvoid projection(inout vec2 pv){\n\t vec4 m =\n        vec4(pv.x, pv.y, 0.00, 0.00) *\n        rotY(sin(t * 1.0) * 0.1) *\n        rotX(0.60) *\n        1.2 + 0.2;\n    \n    pv /= abs(0.8 - m.z);\n}\n\nvec4 image()\n{\n    vec2 pv = setupSpace(gl_FragCoord.xy, resolution.xy); // Perspective UV\n    vec2 uv = setupSpace(gl_FragCoord.xy, resolution.xy); // Screen-space UV\n    float camPos = t; // Camera speed\n    float p; // Image\n    \n   \tprojection(pv);\n    \n    pv.y += camPos;\n   \n    // Scene\n    ground(p, pv);\n    light(p, vec2(pv.x, pv.y - camPos));\n    ball(p, vec2(uv.x + 0.180 + sin(t*0.9+0.4)*0.1 , uv.y + -0.40), 1.00 , 0.18, 0.2);\n    \n    vec3 color = vec3(p);\n    color.r += 0.1;\n    color.b += 0.05;\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = image();\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 99, 99, 233], [235, 235, 262, 262, 398], [400, 400, 441, 441, 518], [520, 520, 539, 539, 569], [571, 614, 688, 688, 2043], [2045, 2045, 2082, 2103, 2166], [2168, 2168, 2203, 2203, 2315], [2317, 2317, 2348, 2348, 2506], [2508, 2508, 2522, 2522, 3057], [3059, 3059, 3116, 3116, 3143]], "test": "valid"}
{"id": "3tffzN", "name": "Rotating Tunnel Thingy", "author": "julianlumia", "description": "Random sketch old sketch out of my archive, made it public", "tags": ["tunnel"], "likes": 3, "viewed": 113, "published": "Public", "date": "1596101002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox(vec3 p, vec3 s) {\np = abs(p)-s;\nreturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\nfloat g2;\n\nvec2 GetDist(vec3 p) {\nvec3 p2 = p;\nfloat gap = .1;\np2.z = mod(p.z + gap,2.0 * gap) - gap;\n        float r = 3.14159*2.*sin(p.z*0.2)+(iTime*.5);\n    mat2 R = mat2(cos(r), sin(r), -sin(r), cos(r));\n    p2.xy *= R ;  \nvec3 p3 = p;\n    \nfloat gap2 = 1.;\n    \np3.z = mod(p.z + gap2,2.0 * gap2) - gap2;  \n    \n    \nvec2 box2 = vec2(sdBox(p2-vec3(0,0,0), vec3(.6,.60,0.02)),2.); \nvec2 box22 = vec2(sdBox(p2-vec3(0,0,0), vec3(.5,.5,0.6)),4.); \nbox2.x = max(-box22.x,box2.x);\nvec2 box3 = vec2(sdBox(p3-vec3(sin(p.z+iTime*0.6)*0.5,cos(p.z+iTime*0.6)*0.5,0), vec3(0.01,0.01,1.)),5);\n//vec2 sphereg = vec2(length(p-vec3(cos(p.z+iTime*0.3)*0.5,sin(p.z+iTime*0.5)*0.5,iTime+2.)) - 0.3,5);\nvec2 sphereg = vec2(length(p-vec3(0.,0.,iTime+2.)) - .4,5)*1.;\nvec2 d = condmin(box2,box3);\nvec2 boxg = vec2(sdBox(p-vec3(sin(iTime*0.5)*0.5+0.1,cos(iTime*0.2)*0.5+0.2,iTime+2.), vec3(.1)),5);\ng1 +=1./(0.05+pow(abs(boxg.x),1.));\n//g2 +=1./(0.25+pow(abs(sphereg.x),10.));\n//d = condmin( d,boxg);\nd = condmin( d,sphereg);\nreturn d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<64; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<.000001||abs(t.x)>70.) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>100.) \nt.x=1.;\nt.x +=h.x*1.;\nreturn t;\n}\n\n\nfloat traceRef(vec3 ro, vec3 rd)\n{    \n float t = 0., d;\n for (int i = 0; i < 48; i++){\n d = GetDist(ro + rd*t).x;    \n if(abs(d)<.002 || abs(t)>100.) break;    \n t += d;\n}\nreturn t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p, vec3 n) {\nvec3 lightPos = vec3(sin(iTime*0.5)*0.5+0.2,cos(iTime*0.2)*0.5+0.2,iTime+2.);\nvec3 l = normalize(lightPos-p);\nfloat dif = clamp(dot(n, l)*.5+.5, 0., 1.);\nvec2 d = RayMarch(p+n*.001*5., l);\nif (d.x<length(lightPos-p)) dif *= 0.5;\nreturn dif;       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec3 col = vec3(0);\n// ro = vec3(cos(iTime)*0.2+0., sin(iTime)*0.5+0.2, iTime);\n    vec3 ro = vec3(0,0,iTime);\nvec3 ro2 = vec3(0., 0.,iTime+19.);   \nvec3 rd = vec3(uv.x,uv.y-0., 1.);\nvec2 d = RayMarch(ro, rd);\nfloat t =d.x *1.;   \nif(t>0.){\nvec3 p = ro + rd *t;\nvec3 baseColor = vec3(1.,1.,1.);\nif(d.y==1.) baseColor=vec3(sin(p.z*2.+iTime*4.)*0.2+0.5,.5,0.3);\nif(d.y==2.) baseColor=vec3(-sin(p.z*0.01*iTime)*0.5,0.0,0.1);\nif(d.y==3.) baseColor=vec3(0.,0.5,.5);\nif(d.y==10.) baseColor=vec3(0,0.,0.);   \nif(d.y==5.) baseColor=vec3(0.,1.,0.5);   \nvec3 n = GetNormal(p);  \nfloat dif = GetLight (p,n); \ncol = vec3(dif);  \ncol+=baseColor;   \nfloat fog = 1. / (1. + t * t * .1);\ncol *= vec3(fog);    \nif(d.y==5.){  \nt = traceRef(ro2 + rd*1., rd);\np = ro2 + rd *ro2;\nn = GetNormal(p);\nfloat dif = GetLight (p,n); \nn = vec3(dif);  \ncol += n *5. ;    \n} \n}\ncol *=g1*vec3(0.05);\nfloat fog = 1. / (1. + t * t * 1.);   \ncol *= vec3(fog);    \nfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tffzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 105], [107, 107, 145, 145, 212], [235, 235, 257, 257, 1242], [1244, 1244, 1277, 1277, 1470], [1473, 1473, 1507, 1507, 1657], [1659, 1659, 1682, 1682, 1866], [1869, 1869, 1901, 1901, 2151], [2153, 2153, 2210, 2210, 3223]], "test": "valid"}
{"id": "3tjcDm", "name": "Animated Sinusoid - TBOS 5.0", "author": "stungeye", "description": "Chapter 5 - The Book of Shaders - Shaping Functions\n\nSinusoidal background gradient with function plotted over top.", "tags": ["simple", "gradient", "sine", "tbos"], "likes": 1, "viewed": 202, "published": "Public API", "date": "1594565641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Working Through The Book of Shaders\n// Chapter 05 - Shaping Functions - https://thebookofshaders.com/05/\n// 5.0 - Animated Sinusoid - Details: https://shader-journey.netlify.app/docs/5-shaping-functions\n\n#define PI 3.14159265358979\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){ // (st = texture coordinates) (pct = percentage from 0.0 to 1.0)\n    \n  const float width_factor = 0.007;\n    \n  return  smoothstep(pct - width_factor, pct, st.y) \n          - smoothstep(pct, pct + width_factor, st.y);\n}\n\nvoid mainImage(out vec4 fragColor,  // Output (r, g, b, a) pixel color \n               in vec2 fragCoord) { // Input (x, y) image coordinate\n    \n\tconst vec3 plot_colour = vec3(1.,0.,1.); // Colour of our plot. \n    \n    vec2 st = fragCoord / iResolution.xy;    // Normalize texture coordinates from 0.0 to 1.0 in x and y.\n\n    float y = sin(st.x * PI + iTime);        // y is a sinusoid based on x position and time.\n          y = 0.5 * y + 0.5;                 // Scale and offset y to center plot.\n    \n    float plot = plot(st, y);                // Create a plot of y.\n    \n    vec3 colour = vec3(y, y, y);             // Black to white background gradient. Also: vec3(y) \n         colour *= 1. - plot;                // Remove gradient \"below\" where plot will be draw.\n         colour += plot * plot_colour;       // Paint the xy-plot.\n\n\tfragColor = vec4(colour, 1.0);           // Set pixel colour.\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 286, 317, 382, 538], [540, 540, 647, 680, 1447]], "test": "valid"}
{"id": "3tjcDV", "name": "Varying Circle Tiles", "author": "sauj123", "description": "Trying to get something like this: https://www.khanacademy.org/computer-programming/circles/1073977688", "tags": ["2d", "circle", "modulus"], "likes": 1, "viewed": 57, "published": "Public", "date": "1595416624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Instructions: Hold left mouse button and drag within the canvas\n// Credit for Ben Fry and Casey Reas: https://processing.org/examples/distance2d.html\n\n#define ROW_TILES 5.\n\n// Obtained from: https://www.shadertoy.com/view/Xt23Ry\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec2 transform(vec2 coord) {\n    vec2 uv = coord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;  // correct aspect ratio\n    uv *= ROW_TILES;\n    return uv;\n}\n\n// Given 0 <= t <= 1, f should follow this constraint: 0 <= f(t) <= 1\n// Ideally f(1) = 0\nfloat brightness(float t) {\n    return max(1.-pow(t, 4.),0.0);\n}\n\nfloat multiplier(vec2 center, float t) {\n    float a = 10., b = 1. + .1*rand(center*iTime), u = 0., s = 1.;\n    return a - (a - b) * (1. - exp( -pow(t-u,2.)/pow(s,2.) ));\n}\n\n// uv.x, uv.y in [0, 1]\n// center tells position of tile in canvas\nvec4 renderTile(vec2 uv, vec2 center) {\n    vec2 mouse = transform(iMouse.xy);\n    if (iMouse.z < 0.5)\n        mouse = transform(iResolution.xy/2.) + vec2(cos(iTime), sin(iTime));\n    uv -= .5;\n    uv *= multiplier(center, distance(mouse, center));\n    uv += .5;\n    vec3 col = vec3(0.,1.,1) * brightness(2.*distance(uv, vec2(.5,.5)));\n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = transform(fragCoord);\n\n    fragColor = renderTile(mod(uv, 1.), floor(uv)+.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 232, 252, 252, 320], [322, 322, 350, 350, 490], [492, 582, 609, 609, 646], [648, 648, 688, 688, 820], [822, 889, 928, 928, 1252], [1254, 1254, 1311, 1311, 1405]], "test": "valid"}
{"id": "3tjcRy", "name": "ValueNoise Sample", "author": "Johnblu", "description": "value噪音的几种表现形式", "tags": ["noise"], "likes": 3, "viewed": 79, "published": "Public", "date": "1594706977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash21(vec2 p)\n{\n    p = vec2( dot(p,vec2(612.1,946.7)),\n              dot(p,vec2(235.5,-354.3)));\n    \n    float vertexValue = -1.0 + 2.0 * fract(sin(p.x + p.y)*(4558.5353));\n    //以下是以三角函数改变顶点伪随机量的方式让纹理动起来，但是会出现周期性\n    //还有种让纹理动起来的方式是用更高维度的噪音图，其中一个维度是时间维度\n    vertexValue = sin(vertexValue * 3.1415926 + iTime);\n    return vertexValue;\n}\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\t\n    //以下两个是前人提出的缓和曲线\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\t//一阶导数连续\n    vec2 w = pf * pf * pf * (pf * pf * 6.0 - pf * 15.0 + 10.0);\t//二阶导数连续\n\n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x), \n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (vec2(fragCoord.x, fragCoord.y) / min(iResolution.x, iResolution.y));\n\tvec2 mouseUv = (vec2(iMouse.x, iMouse.y) / min(iResolution.x, iResolution.y));\n    \n    if(mouseUv.x < 1e-4 && mouseUv.y < 1e-4)\n    {\n        mouseUv = vec2(iResolution.x / iResolution.y * 0.5,0.5);\n    }\n    \n    vec2 divisionUv = uv;\n    uv = uv * (6.0);\n    float result = 0.0;\n    if(divisionUv.x < mouseUv.x && divisionUv.y > mouseUv.y)\n    {\n        result = value_noise(uv);\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x < mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * value_noise(uv);\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * value_noise(uv);\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * value_noise(uv);\t\tuv *= 2.0;\n        \n        result = result * 0.5 + 0.5;\n    }\n    else if(divisionUv.x > mouseUv.x && divisionUv.y < mouseUv.y)\n    {\n        result += 4.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    }\n\telse\n    {\n        result += 4.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 2.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n    \tresult += 1.0 / 7.0 * abs(value_noise(uv));\t\tuv *= 2.0;\n        \n        result = cos(result + uv.x * 0.1);\n    }\n    \n    fragColor = vec4(result,result,result,1);\n    float divisionLine = (1.0 - abs(mouseUv.x - divisionUv.x) * 400.0)\n        * (1.0 - abs(mouseUv.y - divisionUv.y) * 400.0);\n    divisionLine = clamp(divisionLine,0.0,1.0);\n    fragColor = mix(vec4(1,1,1,1),fragColor,divisionLine);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 481], [482, 482, 509, 509, 946], [948, 948, 1005, 1005, 2628]], "test": "valid"}
{"id": "3tjcWV", "name": "Sierpinski Star", "author": "dr2", "description": "Stellated octahedron from two sierpinskified tetrahedra", "tags": ["fractal", "tetrahedron", "kifs"], "likes": 12, "viewed": 284, "published": "Public API", "date": "1595408725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Sierpinski Star\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrTetDf (vec3 p, float d);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat Sierp3 (vec3 p)\n{\n  float s;\n  s = 1.;\n  for (int k = 0; k < 8; k ++) {\n    p.xy = (p.x + p.y > 0.) ? p.xy : - p.yx; \n    p.yz = (p.y + p.z > 0.) ? p.yz : - p.zy; \n    p.zx = (p.z + p.x > 0.) ? p.zx : - p.xz; \n    p = 2. * p - 1.;\n    s *= 0.5;\n  }\n  return s * PrSphDf (p, 2.5);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (float k = -1.; k <= 1.; k += 2.) {\n    q = p;\n    q.y *= k;\n    q.xz = Rot2D (q.xz, - k * pi / 6.);\n    q.xy = Rot2D (q.xy, pi / 2. -0.5 * acos (1./3.));\n    q.xz = Rot2D (q.xz, pi / 4.);\n    d = Sierp3 (q);\n    DMIN (1);\n    d = PrTetDf (q, 0.25);\n    DMIN (2);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltPos[4], ltDir, col, vn, c, dfTot, spTot;\n  float dstObj, at, vDotL, sh;\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 1., 3.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. -0.1 * pi * tCur);\n  }\n  ltPos[3] = vec3 (0., 3., 0.);\n  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.14 * pi * tCur)));\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (1., 1., 1., 1.);\n    else col4 = vec4 (1., 1., 0.5, 0.2);\n    dfTot = vec3 (0.);\n    spTot = vec3 (0.);\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.7, 0.95, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro, ltDir);\n      c = HsvToRgb (vec3 (0.25 * float (k), 1., 1.));\n      vDotL = max (dot (vn, ltDir), 0.);\n      dfTot += col4.rgb * c * at * sh * vDotL * vDotL;\n      spTot += col4.a * c * at * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    }\n    col = dfTot + spTot;\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.2 * pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = floor (tCur / 5.) + smoothstep (0.9, 1., mod (tCur / 5., 1.));\n    az += 0.22 * pi * t;\n    el += 0.2 * pi * sin (0.1 * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  zmFac = 5.5;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrTetDf (vec3 p, float d)\n{\n  vec2 e = vec2 (1., -1.);\n  return (max (max (dot (p, e.yxx), dot (p, e.xyx)), max (dot (p, e.xxy), dot (p, e.yyy))) - d) / sqrt (3.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcWV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[399, 399, 422, 422, 686], [688, 688, 710, 710, 1045], [1047, 1047, 1080, 1080, 1256], [1258, 1258, 1279, 1279, 1527], [1529, 1529, 1566, 1566, 1788], [1790, 1790, 1825, 1825, 3011], [3055, 3055, 3111, 3111, 4164], [4166, 4166, 4199, 4199, 4226], [4228, 4228, 4261, 4261, 4399], [4401, 4401, 4425, 4425, 4542], [4544, 4544, 4580, 4580, 4786], [4788, 4788, 4818, 4818, 4931]], "test": "error"}
{"id": "3tjcz1", "name": "Ball of grass", "author": "jarble", "description": "This object resembles a grassy or forested planet, or a ball of hair.", "tags": ["3d", "raymarching", "grass", "planet", "forest"], "likes": 2, "viewed": 273, "published": "Public API", "date": "1593731425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 twist(vec3 p){\n    vec3 p1 = p.yzx/1000.0;\n\treturn (sin(p1)+cos(p1))*500.0;\n}\n\nfloat planet_surface(vec3 p,float grass_scale){\n    vec3 p1 = p/5.0/size;\n    return length((sin(p1.yzx/vec3(length(sin(p1/grass_scale)))))*size) - size*1.5;\n}\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p = p/scale;\n    p += twist(p);\n    float grass_scale = 20.0;\n    float result = planet_surface(p,grass_scale);\n    for(float i = 2.0; i < 4.0; i++){\n    \tgrass_scale *= 1.5;\n        result = min(result,planet_surface(p,grass_scale));\n    }\n\n    return min(result,length(p)-30000.0)*scale + length(p/4000.0);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0)*2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(0,1,0)/2.0;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 2.0;\n    float t1 = iTime/speed;\n    vec3 eye = vec3(sin(t1),cos(t1),1.0)*1500.0;\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 s1 = twist(worldDir*1000.0)/1000.0;\n        fragColor = vec4(s1, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 540, 540, 603], [605, 605, 652, 652, 764], [767, 767, 802, 802, 1117], [1119, 1119, 1142, 1142, 1173], [1175, 1175, 1203, 1203, 1233], [1236, 1657, 1748, 1748, 2115], [2130, 2384, 2449, 2449, 2581], [2583, 2672, 2701, 2701, 3011], [3013, 3505, 3645, 3645, 4255], [4257, 4627, 4712, 4712, 5059], [5061, 5388, 5437, 5472, 5603], [5605, 5605, 5662, 5662, 6635]], "test": "valid"}
{"id": "3tjyDR", "name": "circle vs spiral illusion (203)", "author": "FabriceNeyret2", "description": "reference:\n[img]https://i.redd.it/7zm03eo01ma41.jpg[/img]", "tags": ["illusion", "2tweets", "perception", "short", "golf"], "likes": 13, "viewed": 240, "published": "Public API", "date": "1594127708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 203   without time\n#define S(r,s)  smoothstep (.01, -.01, abs(l-r) -.025 )  \\\n              * cos( s 18.* abs(a) - 79.*l )            //                  \nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    float l = length(U)/R.y, a = atan(U.x,U.y) - .3*iTime;\n    O += .5 + .2 * (   S(.8, - ) + S(.6, )  )\n                 * ( 1. +  sin(72.*a)   );}             /*\n //; O = sqrt(O)\n\n\n\n// --- 257 chars\n\n#define S(v)  smoothstep (.01, -.01, v )\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    float l = length(U), a = abs( atan(U.x,U.y) );\n    O-=O;\n    O += .4* (   S( abs(l-.8)-.02 ) * sin( -18.* a -6.3*l/.08 )\n               + S( abs(l-.7)-.02 ) * sin(  18.* a -6.3*l/.08 ) \n             )* (.5+.5*sin(72.*a))\n      + .5;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "3tjyDy", "name": "Animated HSB function plot", "author": "douira", "description": "Plots the given function using a HSB color.", "tags": ["colorful", "animated", "repeating", "mathematical"], "likes": 4, "viewed": 67, "published": "Public", "date": "1595277937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tileSize = 1000.0;\nfloat scale = 20.0;\nfloat rangeEnd = 1.0;\nfloat rangeStart = -1.0;\n\n//some nice functions to try\n//sin(x) * ((sin(y) + cos(x)) * sin(y) + cos(x)) * cos(y)\n//sin(cos(x) * sin(y) * x) * cos(sin(y) * cos(x) * y)\n//sin(cos(x) * sin(y) * 2.0 * sin(x * 0.2)) * cos(sin(y) * cos(x) * 2.0 * sin(y * 0.2))\n//sin(cos(iTime * 0.5 + x) * sin(iTime * 0.2 + y) * 2.0 * sin(x * 0.5) + cos(x * 0.25) * 0.3) * cos(sin(y) * cos(iTime - x) * 2.0 * sin(iTime * 0.3 + y * 0.2) + 2.0)\n\n\n//hsv2rgb is from https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float x = mod(uv.x, tileSize) * scale;\n    float y = mod(uv.y, tileSize) * scale;\n    \n    //=== put the function to plot here ===\n    float value = sin(cos(iTime * 0.5 + x) * sin(iTime * 0.2 + y) * 2.0 * sin(x * 0.5) + cos(x * 0.25) * 0.3)\n        * cos(sin(y) * cos(iTime - x) * 2.0 * sin(iTime * 0.3 + y * 0.2) + 2.0) + iTime * 0.03;\n    \n    value = (value - rangeStart) / (rangeEnd - rangeStart);\n    vec3 col = hsv2rgb(vec3(value, 1.0, 1.0));\n\n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 560, 582, 582, 751], [753, 753, 810, 860, 1504]], "test": "valid"}
{"id": "3tjyR3", "name": "Tunnel of Thorns", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/3t2czK]\"caves of steel\"[/url] fractal.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion", "cave"], "likes": 3, "viewed": 200, "published": "Public API", "date": "1594945554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define iterations 6\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float\n    MIN_DIST = 0.0,\n\tMAX_DIST = 100.0,\n\tEPSILON = 0.01,\n\tsize = 1000.0,\n\tscale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat vines(vec3 p,float size1){\n    p /= length(p)*2.0;\n    float s1 = 1.0;\n    return size-length((sin(p.yzx/s1)/s1+1.0+sin(p/vec3(length((p/50.0)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n\n    p /= scale*60.0; \n    //p = (2.0+cos(p/50.0))*100.0;\n    float size1 = 800.0,\n    result = vines(p,size1),\n    i = 15.0;\n    for(int j = 0; j < iterations; j++){\n        p = (sin(p.yzx/i+i)*i-sin(p)/i);\n        result = min(result,result-vines(p,size1)/(i));\n    }\n    return result*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale*10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N),\n    dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a,\n    light1Pos = eye,\n    light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye),\n    s = normalize(cross(f, up)),\n    u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    float t1 = (30.2+sin(iTime/2.0))*24.0;\n    vec3 eye = vec3(30.0+iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir,\n    K_a = surface_color(p),\n    K_d = K_a,\n    K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 590, 590, 724], [727, 727, 751, 751, 1052], [1054, 1054, 1082, 1082, 1159], [1161, 1582, 1673, 1673, 2044], [2059, 2313, 2378, 2378, 2510], [2512, 2601, 2630, 2630, 2940], [2942, 3434, 3574, 3574, 4163], [4165, 4535, 4620, 4620, 4952], [4954, 5281, 5330, 5365, 5486], [5488, 5488, 5545, 5545, 6560]], "test": "valid"}
{"id": "3tjyzc", "name": "Double Happiness", "author": "akanarika", "description": "HAPPY MARRIAGE!", "tags": ["raymarching"], "likes": 2, "viewed": 54, "published": "Public", "date": "1594971614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define EPS 0.001\n\nfloat getDist(in vec3 p) {\n    vec3 c = vec3(0, 1, -4);\n    vec3 s = vec3(3, .2, .2);\n    float d =length(max(abs(p - c) - s, 0.));\n    \n    c = vec3(0, -1, -4);\n    s = vec3(3, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, 1.7, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, 1.7, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, .3, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, -.3, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, -.3, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, .3, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, -1.7, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, -1.7, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, -2.3, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, -2.3, -4);\n    s = vec3(1, .2, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-2.2, -2, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-.6, -2, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(2.2, -2, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(.6, -2, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-2.2, 0, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-.6, 0, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(2.2, 0, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(.6, 0, -4);\n    s = vec3(.2, .3, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, 1.6, -4);\n    s = vec3(.2, .6, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, 1.6, -4);\n    s = vec3(.2, .6, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(-1.4, -1, -4);\n    s = vec3(.2, .6, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    c = vec3(1.4, -1, -4);\n    s = vec3(.2, .6, .2);\n    d = min(d, length(max(abs(p - c) - s, 0.)));\n    \n    d = min(d, p.y + 4.);\n    \n    return d;\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        float tt = getDist(p);\n        t += tt;\n        if (tt < EPS || t > MAX_DIST) break;\n    }\n    return t;\n}\n\nvec3 getNormal(in vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(EPS, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat getLight(in vec3 p) {\n\tvec3 light = vec3(0, 30, 50);\n    light.xz += 5. * vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(light - p);\n    vec3 n = getNormal(p);\n    float dif = clamp(0., 1., dot(l, n));\n    if (rayMarch(p + EPS * 2. * n, l) < length(light - p)) return dif * .9;\n    return dif ;\n}\n\nvec3 getBubble(in vec3 ro, in vec3 rd) {\n    float d = MAX_DIST;\n    float t = iTime;\n    vec3 sp = vec3(0, -.5, 0);\n    vec3 col = vec3(0);\n    for (int i = 0; i < 20; i++) {\n        d = min(d, max(0., length(sp.xy - rd.xy)));\n        float size = .1;\n        float c = smoothstep(size, size * (1. - .3), d);\n        c *= mix(.7, 1., smoothstep(size * .8, size, d));\n        col = max(col, c);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = vec3(0, 2.8, 2);\n    vec3 rd = normalize(vec3(uv.x, uv.y - .5, -1));\n    float d = rayMarch(ro, rd);\n    fragColor = vec4(getLight(ro + d * rd) * d * .1, 0, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 89, 89, 2711], [2713, 2713, 2753, 2753, 2958], [2960, 2960, 2987, 2987, 3172], [3174, 3174, 3201, 3201, 3482], [3484, 3484, 3524, 3524, 3902], [3904, 3904, 3959, 3959, 4204]], "test": "valid"}
{"id": "3tK3zt", "name": "VctrPortrait", "author": "kvick", "description": "portrait, unfinished, may never finish :|", "tags": ["portrait"], "likes": 9, "viewed": 159, "published": "Public", "date": "1593964220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE .1031\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime * 250.)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.01 / (dist2Line));\n    \n    f *= 0.1;\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t1., \t\t0.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        0., \t1., \t\t0.,\n        0.,\t\tcos(d),\t\tsin(d),\n        0.,\t\t-sin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    vec3 pCenter = vec3(-0., 0., 1.0);\n    p += pCenter;\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 face(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-1., 0.0), vec2(1., 0.0));\n    return color;\n}\n\n#define cp(a) (a), (a+1),\n#define ep(a) (a), (a+1)\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n\tfloat f;\n    \n    float iTime = iTime * 1.0;\n    vec3 color = vec3(0.);\n    \n    const int kPointCount = 28;\n    vec3[kPointCount] p = vec3[kPointCount](\n        //Face\n        \n        (vec3(-0.09,  0.28, 0)), // forehead\n        (vec3(-0.115,  0.175, 0)), // brow\n        (vec3(-0.109,  0.135, 0)), // bridge\n        (vec3(-0.095,  0.135, 0)),\n        (vec3(-0.109,  0.135, 0)), // bridge\n        (vec3(-0.175,  0.0, 0)), //nose tip\n    \t(vec3(-0.155,  -0.02, 0)), //nose tip lower\n        (vec3(-0.105,  -0.025, 0)), //nose base\n        (vec3(-0.101,  -0.048 , 0)), \n        (vec3(-0.110,  -0.10, 0)), //lip tip\n        (vec3(-0.090,  -0.11, 0)), //lip middle\n        (vec3(-0.070,  -0.119, 0)), //lip middle deep\n        (vec3(-0.090,  -0.11, 0)), //lip middle\n        (vec3(-0.100,  -0.125, 0)), //lip bottom\n        (vec3(-0.080,  -0.138, 0)), \n        (vec3(-0.085,  -0.19, 0)), //chin\n        (vec3(-0.045,  -0.21, 0)),\n        (vec3(0.06,  -0.2, 0)), //neck top\n        (vec3(0.1,  -0.32, 0)), //neck bottom\n        (vec3(0.225,  -0.26, 0)), //neck back\n        \n        //Hair\n        (vec3(0.3,  -0.4, 0)),\n        (vec3(0.5,  -0.5, 0)),\n        (vec3(0.6,  0.0, 0)),\n        (vec3(0.3,  0.4, 0)),\n        (vec3(-0.1,  0.4, 0)),\n        (vec3(-0.15,  0.3, 0)),\n        (vec3(-0.05,  0.3, 0)),\n        (vec3(0.3,  -0.4, 0))\n    );\n    \n    int edgeCounter = 0;\n    const int k_edgeMax = (kPointCount - 1) * 2;\n    const int k_lineCount = k_edgeMax / 2;\n    int[k_edgeMax] edges;\n    for (int n = 0; n < k_lineCount; n++) //Draw a continual line\n    {\n\t\tedges[edgeCounter] = edgeCounter - n;  edgeCounter++;\n        edges[edgeCounter] = edgeCounter - n;  edgeCounter++;\n    }\n    \n    /*\n\tedges[edgeCounter] = edgeCounter - 0;edgeCounter++;edges[edgeCounter] = edgeCounter - 0 ;edgeCounter++;lineCounter++;\n\tedges[edgeCounter] = edgeCounter - 1;edgeCounter++;edges[edgeCounter] = edgeCounter - 1 ;edgeCounter++;lineCounter++;\n    edges[edgeCounter] = edgeCounter - 2;edgeCounter++;edges[edgeCounter] = edgeCounter - 2 ;edgeCounter++;lineCounter++;\n    edges[edgeCounter] = edgeCounter - 3;edgeCounter++;edges[edgeCounter] = edgeCounter - 3 ;edgeCounter++;lineCounter++;\n\t*/\n        \n    //edges[edgeCounter] = edgeCounter;edges[edgeCounter + 1] = edgeCounter + 1;edgeCounter++;\n    //Face\n        //cp(0)cp(1)cp(2)cp(3)cp(4)cp(5)cp(6)cp(7)cp(8)cp(9)cp(10)cp(11)cp(12)cp(13)cp(14)cp(15)cp(16)cp(17)cp(18)cp(19)\n        //cp(20)cp(21)cp(22)cp(23)cp(24)cp(25)cp(26)cp(27)\n        //ep(k_edgeMax - 1)\n        \n        //Hair\n    \n    /*\n    const int k_edgeMax = (kPointCount - 1) * 2;\n    int[] edges = int[](\n        //Face\n        cp(0)cp(1)cp(2)cp(3)cp(4)cp(5)cp(6)cp(7)cp(8)cp(9)cp(10)cp(11)cp(12)cp(13)cp(14)cp(15)cp(16)cp(17)cp(18)cp(19)\n        cp(20)cp(21)cp(22)cp(23)cp(24)cp(25)cp(26)cp(27)\n        ep(k_edgeMax - 1)\n        \n        //Hair\n    );\n\t*/\n    \n    vec2[kPointCount] p_;\n    for (int i = 0 ; i < kPointCount; ++i)\n    {\n        p_[i] = pToS(p[i]);\n    }\n    \n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.003;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n    }\n    \n    //Color\n    color += vec3(0., 0.3, 0.8) * f * 1.;\n    \n    color += face(st);\n    \n    //Grid\n    vec3 gridColor = vec3(0.9, 0., 0.1) * 0.15;\n    float gridSpacing = 0.2;\n    color += gridColor * getLine(vec2(st.x, mod(st.y + 0.5, gridSpacing)), vec2(-1., 0.), vec2(1., 0.));\n    \n    float gamma = 0.59;\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n    //Invert colors\n    //color = vec3(1.0 - color.z);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tK3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 176, 176, 293], [295, 378, 422, 422, 448], [450, 450, 496, 496, 663], [665, 665, 708, 708, 964], [966, 966, 1012, 1012, 1281], [1283, 1283, 1311, 1311, 1475], [1477, 1477, 1505, 1505, 1676], [1678, 1678, 1706, 1706, 1872], [1874, 1874, 1893, 1893, 1996], [1998, 1998, 2018, 2018, 2313]], "test": "error"}
{"id": "3tlBzn", "name": "Drifting 2D pixel art cloud", "author": "Healthire", "description": "Pixelated drifting 2D cloud made from multiple layers of perlin noise", "tags": ["2d", "cloud", "pixel"], "likes": 6, "viewed": 174, "published": "Public", "date": "1595854736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define W0 0x3504f335u\n#define W1 0x8fc1ecd5u\n#define M 741103597u\n\nuint fast_hash(uint x, uint y) {\n    x *= W0;\n    y *= W1;\n    x ^= y;\n    x *= M;\n    return x;\n}\n\nfloat hash_to_float(uint h) {\n    return float(h >> 8u) * (1.0 / 16777216.0);\n}\n\nvec2 rand_vec(uvec2 p) {\n    float angle = hash_to_float(fast_hash(p.x, p.y)) * radians(360.);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin_noise(in vec2 point, vec2 wrap, float seed) {\n    vec2 point_i = floor(point);\n    vec2 point_f = fract(point);\n\n\tvec2 vec_tl = rand_vec(uvec2(mod(point_i + vec2(0., 0.), wrap) + vec2(seed)));\n\tvec2 vec_tr = rand_vec(uvec2(mod(point_i + vec2(1., 0.), wrap) + vec2(seed)));\n\tvec2 vec_bl = rand_vec(uvec2(mod(point_i + vec2(0., 1.), wrap) + vec2(seed)));\n\tvec2 vec_br = rand_vec(uvec2(mod(point_i + vec2(1., 1.), wrap) + vec2(seed)));\n\n\tvec2 u = point_f * point_f * (3.0 - 2.0 * point_f);\n    return mix(\n        mix(dot(vec_tl, point_f - vec2(0.0, 0.0)), dot(vec_tr, point_f - vec2(1.0, 0.0)), u.x),\n        mix(dot(vec_bl, point_f - vec2(0.0, 1.0)), dot(vec_br, point_f - vec2(1.0, 1.0)), u.x),\n        u.y\n    ) * 1.41;\n}\n\n\nfloat cloud_noise(vec2 uv, float freq, float seed, float time) {\n    vec2 wrap = vec2(24., 24.);\n    vec2 move = vec2(-time, -time) * wrap;\n    float v1 = abs(perlin_noise(uv * freq + move * vec2(-1.0, 1.0), wrap, seed));\n    float v2 = abs(perlin_noise(uv * freq * 2. + move * 1.5, wrap * 1.5, seed + wrap.x)) * 0.5;\n    float v3 = abs(perlin_noise(uv * freq * 4. + move * 2., wrap * 2., seed + wrap.x * 2.5)) * 0.25;\n\n    float x_mul = min(smoothstep(0.0, 0.5, uv.x), smoothstep(1.0, 0.5, uv.x));\n    float y_mul = min(smoothstep(0.0, 0.2, uv.y), smoothstep(1.0, 0.2, uv.y));\n\n    return (v1 + v2 + v3) * x_mul * y_mul * 1. - 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragCoord = floor(fragCoord / 2.0) * 2.0;\n    \n    vec3 light_dir = vec3(cos(iTime * 0.1), sin(iTime * 0.1), 0.0);\n    if (iMouse.z > 0.0) {\n        vec2 center = iResolution.xy / 2.;\n        light_dir = vec3(normalize(iMouse.xy - center), 0.);\n    }\n    \n    float morph_time = 200.0;\n    float freq = 1.5;\n    float height = cloud_noise(fragCoord / iResolution.xy, freq, 0., mod(iTime / morph_time, 1.0));\n    float other = cloud_noise((fragCoord - light_dir.xy) / iResolution.xy, freq, 0., mod(iTime / morph_time, 1.0));\n    float brightness = mix(0.8, 1.0, ceil(other - height));\n    \n    vec3 sky = vec3(0.1, 0.5, 0.9);\n    \n    height = min(ceil(max(height, 0.0)), 1.0);\n    fragColor = vec4(mix(sky, mix(sky, vec3(1.0), brightness), height), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 101, 101, 167], [169, 169, 198, 198, 248], [250, 250, 274, 274, 387], [389, 389, 447, 447, 1124], [1127, 1127, 1191, 1191, 1761], [1763, 1763, 1820, 1820, 2582]], "test": "valid"}
{"id": "3tScWd", "name": "Bandlimited fbm (box, 2D)", "author": "iq", "description": "A cheap (and not so good) way to prevent aliasing of fbm by removing frequencies as oscillations become smaller than a pixel. You can think of it as an LOD system. Move the mouse to compare naive fbm versus band-limited fbm.", "tags": ["procedural", "2d", "noise", "filter", "bandlimited"], "likes": 36, "viewed": 1413, "published": "Public API", "date": "1595832316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A cheap (and not so good) way to prevent aliasing of fbm by \n// removing frequencies as oscillations become smaller than a pixel.\n// You can think of it as an LOD system. Move the mouse to compare\n// naive fbm (left) versus band-limited fbm (right). More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nfloat noise( in vec2 p );\n\n// regular fbm\nfloat fbm( in vec2 p )\n{\n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        f += s*noise(p);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p;\n    }\n    return 0.5+0.5*f;\n}\n\n// band limited fbm\nfloat blfbm( in vec2 p )\n{\n    float w = length(fwidth(p)); // filter width\n    \n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        f += s*noise(p)*smoothstep(1.0,0.5,w);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p; // keep p and\n        w = 2.01*w;                        // w in synch\n    }\n    return 0.5+0.5*f;\n}\n\n// band limited fbm, same as above, but with explicit gradients\nfloat blfbm( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    float w = max(length(dpdx),length(dpdy));\n    \n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        f += s*noise(p)*smoothstep(6.0,0.5,w);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p; // keep p and\n        w = 2.01*w;                        // w in synch\n    }\n    return 0.5+0.5*f;\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// noise\n//===============================================================================================\n//===============================================================================================\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// simple (and bad!) value noise\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  3.0, 0.5, 0.0, 0.5 );\nconst vec4 sc1 = vec4( -4.0, 2.0,-5.0, 2.0 );\nconst vec4 sc2 = vec4( -4.0, 2.0, 5.0, 2.0 );\nconst vec4 sc3 = vec4(-30.0, 8.0, 0.0, 8.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out int matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n    matid = -1;\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc1.xyz); \n\t\tmatid = 2;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc2.xyz); \n\t\tmatid = 3;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc3.xyz); \n\t\tmatid = 4;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec2 texCoords( in vec3 pos, int mid )\n{\n    vec2 matuv;\n    \n    if( mid==0 )\n    {\n        matuv = pos.xz;\n    }\n    else if( mid==1 )\n    {\n        vec3 q = normalize( pos - sc0.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n    }\n    else if( mid==2 )\n    {\n        vec3 q = normalize( pos - sc1.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc1.w;\n    }\n    else if( mid==3 )\n    {\n        vec3 q = normalize( pos - sc2.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc2.w;\n    }\n    else if( mid==4 )\n    {\n        vec3 q = normalize( pos - sc3.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc3.w;\n    }\n\n\treturn 20.0*matuv;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*sin(0.1*iTime);\n\tro = vec3( 5.0*cos(an), 0.5, 5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 0.0;\n    \n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ;\n    int mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( mid!=-1 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = texCoords(     pos, mid );\n\t\tvec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;\n\t\tvec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytracer.\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = texCoords( pos, mid );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\n        if( p.x<th ) mate = vec3(1.0)*fbm( uv );\n        else         mate = vec3(1.0)*blfbm( uv, ddx_uv, ddy_uv );\n            \n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 1.0, 2.0, abs(p.x-th)/(2.0/iResolution.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tScWd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1593, 1608, 1632, 1632, 1821], [1823, 1843, 1869, 1869, 2205], [2207, 2271, 2325, 2325, 2658], [3079, 3079, 3142, 3142, 3365], [3367, 3367, 3425, 3425, 3533], [3535, 3535, 3589, 3589, 3775], [4179, 4179, 4236, 4236, 4340], [4342, 4375, 4401, 4401, 4692], [5293, 5293, 5388, 5404, 6502], [6504, 6504, 6544, 6544, 7185], [7188, 7188, 7233, 7233, 7344], [7346, 7346, 7417, 7417, 7974], [8378, 8378, 8447, 8447, 8820], [8823, 8823, 8880, 8880, 11038]], "test": "error"}
{"id": "3tSczK", "name": "Color by Something", "author": "yonatan", "description": "This started out as https://twitter.com/gaziya5/status/1277518357219205120", "tags": ["fractal"], "likes": 5, "viewed": 241, "published": "Public API", "date": "1594765975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r (iResolution.xy)\n#define t iTime\n\n#define M(q)q*=mat2(sin(t*.1-t/s+vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n\tfloat s,g,e,i,j,m;\n    for(;i++<20.;) {\n        vec3 p=g*vec3((FC.xy*2.-r)/r.y,1);\n        p.z--;\n        e=s=2.;\n        for(int i;i++<12;s+=s)M(p.xy),M(p.yz),p=abs(p)-.3,e=min(e,(length(p)+1.)/s),p+=p;g+=e;o.xyz+=p/s/e;\n    }\n    o.xyz*=log(8./e)*.005;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 138, 138, 411]], "test": "valid"}
{"id": "3tSyRK", "name": "jep_colorbands", "author": "Eindacor_DS", "description": "a fun one, for to to", "tags": ["fun"], "likes": 0, "viewed": 41, "published": "Public", "date": "1594751646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct harmonicSettings\n{\n    float rowCount; \t\t\t\t\t\t// number of vertical divisions\n    float cycleTime; \t\t\t\t\t\t// duration for the sync of all rows\n    float oscillationsPerCycleOfSlowest;  \t// oscillations of the slowest band per cycle\n    float thickness;\t\t\t\t\t\t// thickness of horizontal bands\n    bool showThickness;\n    bool showShade;\n    bool showMirror;\n};\n    \nvec3 rotateColor(vec3 color, float rotationX, float rotationY, float rotationZ) {\n    vec3 deNormalized = (color * 2.f) - vec3(1.f);\n    \n    mat3 rotationXMatrix = mat3(\n        1.f, 0.f, 0.f,\n    \t0.f, cos(rotationX), -sin(rotationX),\n    \t0.f, sin(rotationX), cos(rotationX)\n    ); \n    \n    mat3 rotationYMatrix = mat3(\n    \tcos(rotationY), 0.f, sin(rotationY),\n        0.f, 1.f, 0.f,\n        -sin(rotationY), 0.f, cos(rotationY)\n    );\n    \n    mat3 rotationZMatrix = mat3(\n    \tcos(rotationZ), -sin(rotationZ), 0.f,\n        sin(rotationZ), cos(rotationZ), 0.f,\n        0.f, 0.f, 1.f\n    );\n    \n    return ((deNormalized * rotationXMatrix * rotationYMatrix * rotationZMatrix) + vec3(1.f)) / 2.f;\n}\n    \nvec3 getColor(harmonicSettings settings, vec2 uv, float renderTime)\n{\n    int primaryIndex = 2;\n    int secondaryIndex = int(mod(float(primaryIndex) + 1.f, 3.f));\n    int tertiaryIndex = int(mod(float(secondaryIndex) + 1.f, 3.f));\n    \n    float rowIndex = floor(uv.y * settings.rowCount);    \n    float oscillations = settings.oscillationsPerCycleOfSlowest + rowIndex;\n    \n    float period = settings.cycleTime / oscillations; \n    \n    float twoPiR = 6.28318531;\n     \n    if (settings.showThickness)\n    {\n    \tsettings.thickness = settings.thickness * (1. - 2. * abs(uv.x - .5));\n    }\n     \n    // normalizes -1,1 sin values to 0,1\n    float xPos = (sin(twoPiR * renderTime / period) + 1.) / 2.;\n    \n    float baseColorVal = .5;\n    vec3 color = vec3(baseColorVal);\n    color[primaryIndex] = 1.f;\n    \n    float band1Delta = abs(xPos - uv.x);\n    if (band1Delta < settings.thickness)\n    {\n        color[secondaryIndex] += (1.f - band1Delta/settings.thickness/2.f) * 1.f - baseColorVal;\n    }\n    \n    float band2Delta = abs(xPos - (1. - uv.x));\n    if (true ||settings.showMirror && band2Delta < settings.thickness)\n    {\n        color[tertiaryIndex] += (1.f - band2Delta/settings.thickness/2.f) * 1.f - baseColorVal;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float renderTime = iTime;\n    uv.y += renderTime * .05;\n\n    // settings: rowCount, cycleTime, oscillations, thickness, showThickness, shade, mirror\n    harmonicSettings preset00 = harmonicSettings(8., 200., 4., .5, true, true, true);  \n    harmonicSettings preset01 = harmonicSettings(40., 120., 30., .25, true, true, true);\n    harmonicSettings preset02 = harmonicSettings(120., 120., 10., .25, true, true, true);\n    harmonicSettings preset03 = harmonicSettings(200., 200., 10., .25, false, true, false);\n    harmonicSettings preset04 = harmonicSettings(120., 240., 10., .02, true, true, true);\n    harmonicSettings preset05 = harmonicSettings(12., 1200., 10., .4, true, true, true);\n    \n    vec3 color = getColor(harmonicSettings(20., 200., 2., .3, true, true, true), uv, renderTime);\n    //vec3 color = getColor(preset00, uv, renderTime);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 450, 450, 1072], [1078, 1078, 1147, 1147, 2334], [2336, 2336, 2393, 2393, 3319]], "test": "valid"}
{"id": "3tSyW3", "name": "Color Grid 2", "author": "iq", "description": "Some sort of undefined colored grid thingy. Clearly inspired by [url]https://www.shadertoy.com/view/wl2yDV[/url], and [url]https://www.shadertoy.com/view/4dBSRK[/url]", "tags": ["procedural", "2d", "grid"], "likes": 21, "viewed": 664, "published": "Public API", "date": "1595449292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// A blend between \n//  https://www.shadertoy.com/view/4dBSRK\n// and\n//  https://www.shadertoy.com/view/wl2yDV\n\n\n// 0: triangles\n// 1: squares\n#define SHAPE 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 4.0*(2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    #if SHAPE==0\n    p.x += 0.5*p.y;\n    #endif\n    \n    vec2 f = fract(p);\n    vec2 i = floor(p);\n    \n    float id = fract(fract(dot(i,vec2(0.436,0.173))) * 45.0);\n    #if SHAPE==0\n    if( f.x>f.y ) id += 1.3;\n\t#endif\n    \n    vec3  col = 0.5+0.5*cos(0.7*id  + vec3(0.0,1.5,2.0) + 4.0);\n    float pha = smoothstep(-1.0,1.0,sin(0.2*i.x + 0.2*iTime + id*1.0));\n    \n    #if SHAPE==0\n\tvec2  pat = min(0.5-abs(f-0.5),abs(f.x-f.y)) - 0.3*pha;\n    #else\n\tvec2  pat = 0.5-abs(f-0.5) - 0.5*pha;\n    #endif\n    \n\tpat = smoothstep( 0.04, 0.07, pat );\n\n    fragColor = vec4( col*pat.x*pat.y, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSyW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[286, 286, 343, 343, 1001]], "test": "valid"}
{"id": "3tSyWW", "name": "Spider Boze", "author": "kaiware007", "description": "IK Test\nreference: \nhttps://www.shadertoy.com/view/Mss3zM\nhttps://www.shadertoy.com/view/XdB3Dw", "tags": ["raymarching", "glsl", "ik"], "likes": 4, "viewed": 88, "published": "Public", "date": "1594646113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 50\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define AA 1\n    \nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nstruct surface {\n\tfloat dist;\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec3(0,1,1), \t\t vec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec3(0.),        vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec3(1,0.7,0.6), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec3(1,0,0.1),   vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec3(1,0.3,0.4), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n#define SURF_CS(d) \t\t(surface(d, vec3(0.9), vec3(0,0,0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec3(0), vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec3(0,1,0), vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec3(0,0,1), vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec3(0.5,0.2,0.1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec3 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.2 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(MAX_DIST);\n    p = rotate(p, M_PI, vec3(0,1,0));\n\n    float at = iTime * 2.5 * M_PI2;\n    \n    vec3 q = opRep(p, vec3(3, 100., 3));\n    \n\tresult = sdBoze(q + vec3(0, -0.15, 0), vec3(2.5), 1.);\n\n    surface legMerge = SURF_NOHIT(MAX_DIST);\n    // leg\n    for(int i = 0; i < 4; i++)\n    {\n        float s = -sign(float(i) - 1.5);\n        float z = -0.25 + mod(float(i), 2.0) * 0.5;\n        float t2 = (i == 1 || i == 2 ? 1.0 : 0.0) * M_PI;\n        vec3 p0 = vec3(0.5*s, 0.0, z);\n        vec3 p2 = p0 + vec3(0.5*s, -0.25 + sin(at + t2) * -0.25, (0.1 + cos(at + t2) * 0.25) +z);\n        vec3 p1 = solve(p0, p2, 0.5, 0.5, vec3(0,0,-1)*s);\n\n        surface arm1 = SURF_LEG(sdCapsule(q, p0, p1, 0.1, 0.05));\n        surface arm2 = SURF_LEG(sdCapsule(q, p1, p2, 0.05, 0.01));\n        legMerge = opU(legMerge, opSU(arm1, arm2, 0.05));\n    }\n    \n    result = opSU(legMerge, result, 0.1);\n    \n    // background\n    surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.5, 0.), vec4(0,1,0,0)), p);\n    result = opU(result, bg1);\n\n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction) {\n    float t = 0.0;\n    \n    vec3 pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = abs(hit.dist);\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        /*\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n        */\n        t += d;\n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    if(d <= EPS){\n    \treturn surface(t, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n    \treturn surface(t, vec3(0), hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0,0,0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // test 2 Grid\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //uv += vec2(10.);\n    //uv = abs(uv);\n    /*\n    // plexus\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, surface mat, vec2 uv)\n{\n    vec3 col = vec3(0,1,0);\n    vec3 sky = SkyColor(ray);\n    \n    //float t = iTime * 1.0 + M_PI * 1.5;\n    //float r = 2.0;\n    vec3 lightPos = vec3(-0.6, 0.8, -0.5);\n    vec3 lightColor = vec3(0.98, 0.92, 0.89) * 1.0;\n\n    if (mat.dist >= MAX_DIST) {\n        col = sky;\n    } else {\n        vec3 result = vec3(0.);\n        vec3 nor = norm(p);\n\t\tvec3 sky = SkyColor(ray);\n        \n        col = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n        col = mix(col, sky, 1.0 - saturate(exp2(1.0 - mat.dist*0.3)));\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n        \n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(p);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    p = p - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    p = p + orientingNormal * OFFSET;\n                }\n\n\n                surface indirectHit = traceRay(p, ray);\n\n                p = p + indirectHit.dist * ray;\n                //float reflength = length(indirectPosition - p);\n                //p = indirectPosition;\n                mat = indirectHit;\n\n                result = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n\n                vec3 sky = SkyColor(ray);\n                dist += mat.dist;\n                \n                // Exponential distance fog\n                result = mix(result, sky, 1.0 - saturate(exp2(1.0 - dist*0.3)));\n\n                col += result * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n\n            }\n        }\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray);\n    \n    pos = p + mat.dist * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    \n        //float t = iTime * M_PI2 * -0.1;\n        float t = iTime * -1.0;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        float y = sin(t * M_PI2 * 0.5) * 0.1 + 1.5;\n        //float y = 1.5;\n        //float r = 2. + sin(t * 0.5)*0.5;\n        float r = 15.5;\n        //float theta = t + RAD90 + RAD90*0.25;\n        float theta = RAD90 + RAD90*0.25;\n        //float theta = t + RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        //vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n        //vec3 ta = vec3(0., 0.5, 0.);\n        vec3 ta = vec3(0. + t, -0.5, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n    \ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSyWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1291, 1291, 1328, 1328, 1560], [2008, 2008, 2031, 2031, 2104], [2106, 2106, 2127, 2127, 2197], [2199, 2199, 2222, 2222, 2301], [2304, 2304, 2326, 2326, 2743], [2746, 2746, 2807, 2807, 2945], [2948, 3008, 3034, 3034, 3900], [3902, 4090, 4113, 4113, 4216], [4218, 4238, 4259, 4259, 4393], [4395, 4414, 4436, 4436, 4569], [4571, 4591, 4613, 4613, 4738], [4839, 4839, 4875, 4875, 4903], [4905, 4905, 4951, 4951, 5007], [5009, 5009, 5040, 5040, 5131], [5133, 5133, 5183, 5183, 5301], [5303, 5303, 5364, 5364, 5495], [5497, 5497, 5534, 5534, 5623], [5625, 5625, 5695, 5695, 5829], [5831, 5831, 5895, 5895, 6012], [6014, 6014, 6047, 6073, 6104], [6106, 6106, 6131, 6131, 6150], [6151, 6151, 6176, 6176, 6195], [6196, 6196, 6232, 6232, 6260], [6262, 6262, 6321, 6321, 6634], [6636, 6636, 6669, 6669, 6734], [6736, 6760, 6812, 6812, 6931], [6933, 6990, 7027, 7068, 7151], [7153, 7153, 7192, 7364, 7473], [7475, 7475, 7524, 7524, 8083], [8085, 8085, 8124, 8170, 8255], [8257, 8257, 8298, 8408, 8522], [8537, 8588, 8625, 8625, 8647], [8649, 8649, 8692, 8692, 8714], [8716, 8716, 8760, 8760, 8781], [8783, 8783, 8835, 8835, 8934], [8937, 8937, 8982, 8982, 9411], [9413, 9413, 9434, 9434, 9502], [9504, 9504, 9544, 9544, 9669], [9672, 9672, 9707, 9707, 9855], [9857, 9857, 9891, 9891, 10067], [10069, 10069, 10104, 10104, 10139], [10141, 10141, 10178, 10178, 10213], [10215, 10386, 10471, 10471, 10548], [10550, 10593, 10668, 10668, 11060], [11062, 11068, 11120, 11120, 11276], [11278, 11278, 11338, 11338, 11379], [11381, 11596, 11627, 11627, 11676], [11678, 11678, 11705, 11705, 11743], [11745, 11745, 11774, 11774, 11812], [11814, 11814, 11841, 11841, 11890], [12149, 12149, 12170, 12170, 12309], [12335, 12335, 12367, 12367, 12480], [12482, 12482, 12514, 12514, 12654], [12656, 12656, 12689, 12689, 12920], [12922, 12922, 12945, 12945, 13524], [13526, 13526, 13551, 13551, 13712], [13714, 13714, 13757, 13757, 14779], [14781, 14781, 14847, 14847, 14969], [14971, 14971, 15016, 15016, 15187], [15189, 15189, 15257, 15257, 15475], [15695, 15695, 15716, 15716, 16778], [17298, 17298, 17347, 17347, 17645], [17647, 17647, 17700, 17700, 18585], [18851, 18919, 18947, 18947, 19074], [19076, 19166, 19229, 19229, 19435], [19437, 19503, 19567, 19737, 20368], [20370, 20370, 20407, 20407, 20497], [20499, 20499, 20525, 20525, 22073], [22249, 22249, 22270, 22270, 22318], [22320, 22320, 22381, 22466, 22665], [22667, 22667, 22740, 22832, 23032], [23034, 23034, 23076, 23156, 23210], [23212, 23212, 23261, 23261, 23309], [23311, 23311, 23384, 23441, 23656], [23658, 23658, 23678, 23678, 23703], [23890, 23890, 23940, 24024, 24382], [24384, 24384, 24439, 24496, 24756], [24758, 24758, 24854, 24854, 26241], [26445, 26445, 26478, 26534, 26720], [26722, 26722, 26761, 26761, 26804], [26806, 26822, 26895, 26895, 26979], [26981, 27107, 27177, 27177, 27460], [27462, 27462, 27562, 27562, 28355], [28357, 28357, 28424, 28424, 31053], [31055, 31055, 31095, 31095, 31228], [31230, 31230, 31272, 31272, 31450]], "test": "valid"}
{"id": "3tXBz8", "name": "FBM-Cloud", "author": "dekai", "description": "Fractal Brownian Motion", "tags": ["2d"], "likes": 5, "viewed": 186, "published": "Public", "date": "1595919247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy/2;\n\n    vec3 col = vec3(0.0);\n    \n    vec2 q = vec2(0.);\n    q.x = fbm( uv + 0.00*iTime);\n    q.y = fbm( uv + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( uv + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( uv + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(uv+r);\n\n    col = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    col = mix(col,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    col = mix(col,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n    \n    col = (f*f*f+.6*f*f+.5*f)*col;\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 138, 165, 165, 511], [513, 513, 539, 539, 832], [834, 834, 891, 891, 1637]], "test": "valid"}
{"id": "4lsBR7", "name": "TropicalWaves", "author": "kvick", "description": "waves", "tags": ["waves"], "likes": 0, "viewed": 41, "published": "Public", "date": "1593964162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 avg(vec3 a, vec3 b)\n{\n \treturn (vec3(a.x + b.x, a.y + b.y, a.z + b.z) * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col;\n    \n    col = vec3(uv.x, 0., 0.);\n    \n    col = avg(col, vec3(0., uv.y, 0.));\n    //col += avg(col, vec3(0., uv.y, 0.));\n    \n\t//col = avg(col, vec3(0., 0., 0.));\n    \n    if (uv.y + ((mod(uv.x * iTime * 0.05, 1.) * 2. - 1.)) < 0.1)\n    {\n        col = vec3(1.);\n        \n    }\n   \t\n    col *= vec3(0.35, 0., 0.) * fract(uv.x * 250.0);\n    \n    col = (mod(fragCoord.x, 2.) == 0.) ? vec3(1., 0., 0.) : vec3(1.);\n    \n    mat2x4 quad = mat2x4(\n        1., 0., 2., 0.,\n        3., 0., 4., 0.\n                        );\n    quad *= 0.25;\n    \n    col =  vec3(quad[0][0], 0., 0.);\n    \n    if(uv.x + sin(iTime * 1.0 + uv.y) * 0.1 > 0.25)\tcol += vec3(0., quad[0][2], 0.);\n    if(uv.x + sin(iTime * 1.5 + uv.y) * 0.1 < 0.5)\tcol += vec3(0., 0., quad[1][0]);\n    if(uv.x + sin(iTime * 3.0 + uv.y) * 0.1 > 0.75)\tcol += vec3(quad[0][0], 0., 0.);\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 84], [86, 86, 143, 143, 1076]], "test": "valid"}
{"id": "4sSfzD", "name": "Indra's Net", "author": "soma_arc", "description": "Not the orbit of disks but the orbit of circles.", "tags": ["2d", "fractal", "circleinversion"], "likes": 7, "viewed": 90, "published": "Public", "date": "1595204208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nfloat LINE_THRESHOLD = 0.0001;\nvec3 getLine(vec2 p1, vec2 p2){\n  float xDiff = p2.x - p1.x;\n  float yDiff = p2.y - p1.y;\n  if(abs(xDiff) < LINE_THRESHOLD){\n    //x = c\n    return vec3(1, 0, p1.x);\n  }else if(abs(yDiff) < LINE_THRESHOLD){\n    //y = c\n    return vec3(0, 1, p1.y);\n  }else{\n    //y = ax + b\n    return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);\n  }\n}\n\nfloat calcX(vec3 line, float y){\n  if(line.z == 0.){\n    return (y - line.y) / line.x;\n  }else{\n    return line.z;\n  }\n}\n\nfloat calcY(vec3 line, float x){\n  if(line.z == 0.){\n    return line.x * x + line.y;\n  }else{\n    return line.z;\n  }\n}\n\nvec2 calcIntersection(vec3 line1, vec3 line2){\n  if(line1.z == 0. && line2.z == 0.){\n    float x1 = 1.;\n    float x2 = 5.;\n    float y1 = calcY(line1, x1);\n    float y2 = calcY(line1, x2);\n\n    float x3 = 4.;\n    float x4 = 8.;\n    float y3 = calcY(line2, x3);\n    float y4 = calcY(line2, x4);\n\n    float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );\n    float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );\n    float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );\n\n    float lambda = ksi / delta;\n    float mu    = eta / delta;\n    return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));\n  }else{\n    if(line1.x == 1.){\n      return vec2(line1.z, calcY(line2, line1.z));\n    }else if(line1.y == 1.){\n      return vec2(calcX(line2, line1.z), line1.z);\n    }else if(line2.x == 1.){\n      return vec2(line2.z, calcY(line1, line2.z));\n    }\n    return vec2(calcX(line1, line2.z), line2.z);\n  }\n}\n\nconst vec2 commonCirclePos = vec2(0, 0);\nconst float commonCircleR = 100.;\nconst vec2 p = commonCirclePos + vec2(0, commonCircleR);\nconst vec2 q = commonCirclePos + vec2(-commonCircleR, 0);\nconst vec2 r = commonCirclePos + vec2(0, -commonCircleR);\nconst vec2 s = commonCirclePos + vec2(commonCircleR, 0);\n\nvec2 c1Pos, c2Pos, c3Pos, c4Pos;\nfloat c1R, c2R, c3R, c4R;\n\nvoid calcContactCircles(vec2 commonCirclePos, float commonCircleR){\n  vec2 pqMid = (p + q)/2.;\n  vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);\n  vec2 a = u * commonCircleR * (sin(iTime) * 6. + 6.72) + commonCirclePos;\n  c1Pos = a;\n  c1R = distance(a, p);\n\n  vec3 aq = getLine(a, q);\n  vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);\n  vec2 b = calcIntersection(aq, qrMidPer);\n  c2Pos = b;\n  c2R = distance(b, q);\n\n  vec3 br = getLine(b, r);\n  vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);\n  vec2 c = calcIntersection(br, rsMidPer);\n  c3Pos = c;\n  c3R = distance(c, r);\n\n  vec3 cs = getLine(c, s);\n  vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);\n  vec2 d = calcIntersection(cs, spMidPer);\n  c4Pos = d;\n  c4R = distance(d, s);\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 30;\nfloat loopNum = 0.;\nfloat DE(vec2 pos){\n    loopNum = 0.;\n\tbool cont = false;\n    vec3 lastCircle;\n    vec2 lastPos;\n    float lastDr = 1.;\n    float dr = 1.;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(length(pos - c1Pos) < c1R){\n            lastCircle = vec3(c1Pos, c1R);\n            vec2 diff = (pos - c1Pos);\n        \tlastDr = dr;\n            dr *= (c1R * c1R) / dot(diff, diff);\n            lastPos = pos;\n\t\t\tpos = circleInverse(pos, c1Pos, c1R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c2Pos) < c2R){\n            lastCircle = vec3(c2Pos, c2R);\n\t\t\tvec2 diff = (pos - c2Pos);\n        \tlastDr = dr;\n            dr *= (c2R * c2R) / dot(diff, diff);\n            lastPos = pos;\n            pos = circleInverse(pos, c2Pos, c2R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c3Pos) < c3R){\n            lastCircle = vec3(c3Pos, c3R);\n\t\t\tvec2 diff = (pos - c3Pos);\n        \tlastDr = dr;\n            dr *= (c3R * c3R) / dot(diff, diff);\n            lastPos = pos;\n            pos = circleInverse(pos, c3Pos, c3R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c4Pos) < c4R){\n            lastCircle = vec3(c4Pos, c4R);\n\t\t\tvec2 diff = (pos - c4Pos);\n        \tlastDr = dr;\n            dr *= (c4R * c4R) / dot(diff, diff);\n            lastPos = pos;\n            pos = circleInverse(pos, c4Pos, c4R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n        if(cont == false) {\n            if (loopNum > 0.) {\n            \treturn abs(distance(lastPos, lastCircle.xy) - lastCircle.z)/ lastDr;\t    \n            }\n            break;\n        }\n\t}\n\n\treturn 0.;//length(pos) - commonCircleR;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    calcContactCircles(commonCirclePos, commonCircleR);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 600.;\n\n        float d = DE(position);\n\n        if(loopNum > 0. && d < 2. ){/// (1. + .5 * log(loopNum))){\n            sum += hsv2rgb(vec3(0.04 * loopNum,1.0,1.0));\n        }else{\n            sum += vec3(0);\n        }\n    }\n    fragColor = vec4(sum/SAMPLE_NUM, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sSfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 91, 132, 132, 421], [454, 454, 485, 485, 799], [801, 801, 833, 833, 921], [923, 923, 955, 955, 1041], [1043, 1043, 1089, 1089, 1951], [2319, 2319, 2386, 2386, 3096], [3098, 3098, 3158, 3158, 3274], [3323, 3323, 3342, 3342, 4949], [4951, 4951, 4973, 4973, 5142], [5174, 5174, 5230, 5230, 5806]], "test": "valid"}
{"id": "4ttfW4", "name": " A Metaballs Study", "author": "vitasa", "description": "studying metaballs and mouse position", "tags": ["metaballs", "balls"], "likes": 2, "viewed": 75, "published": "Public", "date": "1594360458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TODO: add random positions and sin sizes, color per circle?\n\nprecision highp float;\n\nfloat ball(vec2 p, float fx, float fy, float ax, float ay) {\n\tvec2 r = vec2(p.x + sin(iTime * fx) * ax, p.y + cos(iTime * fy) * ay);\t\n\treturn 0.05 / length(r);\n}\n\nfloat cursor(vec2 p) {\n\tfloat offsetX = 1.8;\n\tfloat offsetY = 1.0;\n    float size = 0.2;\n    \tvec2 r = vec2(\n\t\toffsetX + p.x - iMouse.x/iResolution.x * (offsetX*2.0), \n\t\toffsetY + p.y - iMouse.y/iResolution.y * (offsetY*2.0)\n\t);\t\n    \treturn size / length(r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\t\n\tp.x *= iResolution.x / iResolution.y;\n\n\tfloat col = 0.0;\n\n\tcol += cursor(p);\n\t\n\t\n\tcol += ball(p, 1.0, 2.0, 0.1, 0.2);\n\tcol += ball(p, 1.5, 1.0, 0.4, 0.3);\n\tcol += ball(p, 0.1, 0.5, 0.6, 0.7);\n\n\t\n\tcol = max(mod(col, 0.4), min(col, 2.0));\n\t\n\tfragColor = vec4(\n\t\t//col * sin(iTime)/2.0, \n\t\tcol * 0.1,\n        col * 0.3, \n\t\tcol * 0.3, \n        1.0\n    \t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 148, 148, 249], [251, 251, 273, 273, 512], [514, 514, 571, 571, 994]], "test": "valid"}
{"id": "lld3Dn", "name": "gabakken lucht", "author": "Daedelus", "description": "preliminary experiments for Uplifting: https://www.pouet.net/prod.php?which=67972", "tags": ["gabakkenlucht"], "likes": 5, "viewed": 87, "published": "Public", "date": "1595944918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/* https://www.shadertoy.com/view/ldl3W8 */\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\t//return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x , out vec2 o )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2(n + g);\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n\tp *= mat2(ca, sa, -sa, ca);\n}\n\nfloat fField(vec3 p, out float m)\n{\n    float landscape = p.y + (sin(p.x) - sin(p.x + p.z)) * 0.3 + (sin(p.x * 3.0 + p.y * 8.0) - sin(p.x + p.z * 3.0)) * 0.05 + (sin(p.x * 8.0) - sin(p.x + p.z * 8.0)) * 0.01;\n    \n    vec2 cell;\n    vec3 c = voronoi(p.xz, cell);\n    landscape += clamp(c.x * 10.0, 0.0, 1.0) * 0.02;\n    landscape -= sin(c.x * 3.0) * 0.1;\n    \n    landscape += texture(iChannel0, p.xz * 0.02).x * 0.06 - texture(iChannel0, p.xz * 0.05).x * 0.03 + texture(iChannel0, p.xz * 0.2).x * 0.008 + texture(iChannel0, p.xz * 0.4).x * 0.003;\n    \n    float k = atan(p.x, p.z) * 9.0;\n    m = floor(fract(k / 3.14159265359 * 0.5) + 0.5);\n    float s = abs(sin(k));\n    p.y += -0.3 * length(p.xz);\n    p.y -= 2.0;\n    float balloon = length(p) - 1.0 - s * 0.035;\n\t\n    if(landscape < balloon)\n        m = 2.0;\n    return min(balloon, landscape);\n}\n\nfloat fField(vec3 p)\n{\n    float m;\n    return fField(p, m);\n}\n\nvec3 Normal(vec3 p, float s)\n{\n    vec2 e = vec2(0.005, 0.0);\n    return normalize(vec3(fField(p + e.xyy), fField(p + e.yxy), fField(p + e.yyx)) - s);\n}\n\n\nvec3 cellTileColor(vec3 p)\n{\n    vec2 cell;\n    vec3 c = voronoi(p.xz, cell);\n    \n\t// https://www.shadertoy.com/view/MslGD8\n    vec3 col = vec3(abs(sin(cell.y)), clamp(max(cell.x, cell.y) * 2.0, 0.6, 0.8), 0.3);\n\t\n    // borders\t\n    col = mix(vec3(0.1,0.2,0.15), col, smoothstep(0.01, 0.03, c.x));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\tvec3 is, c, fc, n, o = vec3(0.0, 1.0, -10.0 + iTime * 4.0), d = vec3(0.0, 0.0, 1.0);\n    pR(d.xz, uv.x * 0.3);\n    pR(d.yz, uv.y * 0.3 - sin(iTime) * 0.1 - 0.1);\n    pR(d.xz, iTime);\n    \n    float s, m, t = 0.1;\n    for(int i = 0; i < 70 ; ++i)\n    {\n        is = o + d * t;\n        s = fField(is, m) * 0.7;\n        t += s;\n        if(s <= 0.0 || t > 40.0)\n            break;\n    }\n    n = Normal(is, s);\n    fc = vec3(0.1, 0.5, 0.9);\n    vec3 l = vec3(0.5, 1.0, 0.0);\n    if(m == 2.0)\n    \tc = cellTileColor(is);\n    else\n    \tc = vec3(1.0, m, 0.0);\n    c *= (dot(n, l) * 0.5 + 0.5);\n    c = mix(c, fc, min(1.0, t / 40.0));\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lld3Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 45, 67, 188, 278], [280, 280, 320, 320, 1253], [1255, 1255, 1287, 1287, 1354], [1356, 1356, 1391, 1391, 2206], [2208, 2208, 2230, 2230, 2270], [2272, 2272, 2302, 2302, 2424], [2427, 2427, 2455, 2455, 2744], [2747, 2747, 2804, 2804, 3529]], "test": "error"}
{"id": "MdKGzy", "name": "Zzushi", "author": "Daedelus", "description": "sushi inspired by gyabo's tokyo demofest 2015 demonstration\n", "tags": ["sushiraymarchcheap"], "likes": 2, "viewed": 66, "published": "Public", "date": "1595944752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void R(inout vec2 plane, float angle)\n{\n    float sa = sin(angle);\n    float ca = cos(angle);\n    plane *= mat2(ca, -sa, sa, ca);\n}\n\n// Repeat only a few times: from indices <start> to <stop>\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat length8(vec3 p)\n{\n    vec3 m = pow(p, vec3(8.0));\n    return pow(m.x + m.y + m.z, 0.125);\n}\nfloat length6(vec3 p)\n{\n    vec3 m = pow(p, vec3(6.0));\n    return pow(m.x + m.y + m.z, 0.1666);\n}\nfloat length4(vec3 p)\n{\n    vec3 m = pow(p, vec3(4.0));\n    return pow(m.x + m.y + m.z, 0.25);\n}\nfloat length2(vec3 p)\n{\n    vec3 m = p * p;\n    return sqrt(m.x + m.y + m.z);\n}\n\nfloat topping(vec3 point)\n{\n    const float RADIUS = 2.0;\n    const float THICKNESS = 0.1;\n    \n    point.y -= RADIUS - 0.35;\n    \n    float outer = length(point) - RADIUS;\n    float box = sdBox(point, vec3(0.3, 3.0 * RADIUS, 0.5));\n    float inner = length(point) - RADIUS + THICKNESS;\n    \n    return max(-inner, max(box, outer));\n}\n\nfloat rice(vec3 point)\n{\n\tfloat seed = pModInterval1(point.z, 0.2, -1.0, 1.0);\n    return length2(point) - 0.3;\n}\n\nfloat plank(vec3 point)\n{\n    point.y -= 0.35;\n    float main = sdBox(point, vec3(1.2, 0.05, 0.8));\n    point.y -= 0.2;\n    point.x = abs(point.x) - 0.6;\n    float legs = sdBox(point, vec3(0.1, 0.1, 0.8));\n    return min(main, legs);\n}\n\nfloat filling( vec3 point){\n    return sdBox(point, vec3(0.1, 0.25, 0.1));\n        }\nfloat rice_cylinder( vec3 point){\n \tfloat height  = abs(point.y) - 0.2;   \n    return max(height, length(vec3 (point.x, 0.0, point.z)) - 0.25);\n}\nfloat seaweed( vec3 point){\n \tfloat height  = abs(point.y) - 0.19;   \n    return max(height, length(vec3 (point.x, 0.0, point.z)) - 0.27);\n}\n\n        \n\n\nvec2 sushi1(vec3 point, float a, float id ){\n        float b = rice(point);\n        float c = topping(point);\n        if(b<a)\n        {\n            a = b;\n            id = 1.0;\n        }\n        if(c<a)\n        {\n            a = c;\n            id = 2.0;\n        }\n        return vec2(a, id);\n    }\nvec2 sushi2 (vec3 point, float a, float id){\n    float d = filling(point);\n    float e = rice_cylinder(point);\n    float f = seaweed(point);\n    if (d<a){\n        a =d;\n        id= 2.;\n    }\n    if (e<a){\n    \ta =e;\n        id = 1.;\n    }\n    if (f < a){\n    \ta = f;\n        id = 3.;\n    }\n    return vec2(a , id);    \n    \n    \n    }\n\nvec2 fField(vec3 point)\n{\n    float a = plank(point);\n    float id = 0.0;\n    \n\tvec2 sushi_2 = sushi2(point, a, id);    \n    vec2 sushi_1 = sushi1(point, a, id);\n\tfloat b = sushi_2.x;\n    float id2 = sushi_2.y;\n    a = sushi_1.x;\n    id = sushi_1.y;\n\t\n    float w = sin(iTime) * 0.5 +0.5;\n    if (w < 0.5){ id = id2; };\n    float outa = mix(b, a, w);\n    return vec2(outa, id);\n}\n\n            \n            \nvec3 grad(vec3 p) {\n\tvec2 e = vec2(0.01, 0.0);\n\treturn (vec3(fField(p+e.xyy).x, fField(p+e.yxy).x, fField(p+e.yyx).x) - fField(p).x) / e.x;\n}\n\nconst int MAX_STEPS = 12;\nconst float NEAR_CLIP = 1.5;\nconst float FAR_CLIP = 5.0;\nconst float EPSILON = 0.03;\nconst float FOV = 0.3;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv * 2.0 - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // pixelate!\n    // uv = floor(uv * 25.0) / 25.0;\n    \n    vec3 origin = vec3(0.0, 0.0, -4.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    R(direction.xz, uv.x * FOV);\n    R(direction.yz, uv.y * FOV);\n    \n    R(direction.yz, -0.4);\n    R(origin.yz, -0.4);\n    R(direction.xz, iTime);\n    R(origin.xz, iTime);\n    \n    float dist = NEAR_CLIP;\n    float id;\n    for(int i = 0 ; i < MAX_STEPS ; ++i)\n    {\n        vec2 d = fField(origin + direction * dist);\n        if(d.x < EPSILON)\n            break;\n        dist += d.x;\n        id = d.y;\n        if(dist > FAR_CLIP)\n            break;\n    }\n    vec3 color;\n    if(id >= 3.0)\n        color = vec3(0.2, 0.8, 0.3);\n\telse if(id >= 2.0)\n\t\tcolor = vec3(0.6, 0.1, 0.15);\n    else if (id >= 1.0)\n\t\tcolor = vec3(0.8, 0.8, 0.75);\n    else\n\t\tcolor = vec3(0.4, 0.15, 0.05);\n        \n\tvec3 isect = origin + direction * dist;\n    vec3 normal = grad(isect);\n    \n    vec3 sunDir = normalize(vec3(0.5, -1.0, 0.4));\n    float sun = max(0.0, dot(normal, sunDir));\n    float bounce = max(0.0, dot(normal, vec3(-0.3, 0.7, 0.3)));\n    float fill = max(0.0, dot(normal, vec3(-0.3, -0.7, -0.5)));\n    \n    vec3 ambient = vec3(0.3, 0.4, 0.6);\n    vec3 sunCl = sun * vec3(1.0, 0.7, 0.3) * 2.0;\n    vec3 bounceCl = bounce * vec3(1.0, 0.8, 0.2);\n    vec3 fillCl = fill * vec3(0.0, 0.2, 0.2);\n    \n    vec3 diffCl = sunCl + bounceCl + fillCl;\n    float shadow = fField(isect + sunDir * 0.2).x;\n    if(shadow < 0.04)\n        diffCl = vec3(0.0);\n    \n    // float fog = 1.0 / (-0.5 + dist);\n    float fog = 1.0 - ((dist - NEAR_CLIP) / (FAR_CLIP - NEAR_CLIP));\n\tfragColor = vec4((diffCl + ambient) * color * fog, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKGzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 131], [133, 192, 265, 265, 551], [553, 553, 584, 584, 680], [682, 682, 705, 705, 779], [780, 780, 803, 803, 878], [879, 879, 902, 902, 975], [976, 976, 999, 999, 1055], [1057, 1057, 1084, 1084, 1391], [1393, 1393, 1417, 1417, 1506], [1508, 1508, 1533, 1533, 1743], [1745, 1745, 1772, 1772, 1829], [1830, 1830, 1863, 1863, 1975], [1976, 1976, 2003, 2003, 2116], [2129, 2129, 2173, 2173, 2426], [2427, 2427, 2471, 2471, 2761], [2763, 2763, 2788, 2788, 3142], [3170, 3170, 3189, 3189, 3311], [3449, 3449, 3506, 3506, 5274]], "test": "error"}
{"id": "MdlGWM", "name": "Simplex Hills", "author": "nikat", "description": "Simple raymarching through simplex value noise terrain.", "tags": ["3d", "raymarching", "terrain", "simplexnoise", "valuenoise"], "likes": 2, "viewed": 76, "published": "Public", "date": "1595957846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Created by Nikita Miropolskiy, nikat/2013\n */\n\nfloat random(vec2 c) {\n\treturn fract(sin(dot(c, vec2(115., 363.)))*1024.0);\n}\n\nfloat simplexvalue2d(vec2 p) {\n\t\tp*=4.0;\n\t\tfloat h = sqrt(0.33333);\n\t\tfloat z = p.y*h;\n\t\tvec2 q = vec2(z+z, p.x - z);\n\t\tvec2 f = fract(q);\n\t \tvec2 i = floor(q);\n\t \tfloat d = f.x+f.y-1.0;\n\t\tfloat r;\n\t\t\n\t\tif (d > 0.0) {\n\t\t\tr =  random(i + vec2(-1.0, 1.0))*(1.0-f.x)\n\t\t\t       + random(i)*(1.0-f.y)\n\t\t\t       + random(i + vec2( 0.0, 1.0))*d;\n\t\t} else {\n\t\t\tr =  random(i)*f.x\n\t\t\t       + random(i + vec2(-1.0, 1.0))*f.y\n\t\t\t       - random(i + vec2(-1.0, 0.0))*d;\n\t\t}\n\t\t\n\t\t//r = sqrt(r);\n\t\t//r = (3.0 - 2.0*r)*r*r;\n\t\tr = (10.0 - r*(15.0 - 6.0*r))*r*r*r;\n\t\treturn  r;\n}\n\nfloat raymarche(vec3 origin, vec3 direction)\n{\n\tfloat delt = 0.01;\n    float mint = 0.001;\n    float maxt = 4.0;\n    for( float t = mint; t < maxt; t += delt )\n    {\n        vec3 p = origin + direction*t;\n        float h = 0.3*simplexvalue2d( p.xz );\n        if( p.y < h )\n        {\n            return 0.3+0.7*simplexvalue2d( p.xz );\n        }\n    }\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pix = 2.0*fragCoord.xy - iResolution.xy;\n\tvec2 p = pix/iResolution.x;\n\tvec2 q = pix/iResolution.xy;\n\t\n\tfloat time = iTime*0.3;\n\t\n\tvec3 org = vec3(0.0,1.,-time);\n\tvec3 dir = (vec3(p.x*1.6+sin(time),-1.0+p.y,-1.5));\n\t\n\tfloat f = raymarche(org,dir);\n\n\tvec3 c;\n\tc = vec3(f);\n\t\n\tfloat vignet = sqrt(sqrt((q.x*q.x-1.0)*(q.y*q.y-1.0)));\n\tc *= vignet;\n\t\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 72, 72, 127], [129, 129, 159, 159, 692], [694, 694, 740, 740, 1061], [1064, 1064, 1121, 1121, 1502]], "test": "valid"}
{"id": "MlKyzt", "name": "PingPongPongPong", "author": "kvick", "description": "Pong", "tags": ["pong"], "likes": 1, "viewed": 57, "published": "Public", "date": "1593963878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat Circ(vec2 st, vec2 pCenter, float r)\n{\n    return smoothstep(0.0, 3./iResolution.y, length(st - pCenter) - (r * 0.5));\n}\n\nfloat Box(vec2 st, vec2 halfExtents)\n{\n    st = abs(st) - halfExtents;\n    return smoothstep(0., 3./iResolution.y, max(st.x, st.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 st = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float c = 1.;\n    for (float i = 0.; i < 1.; i += 1.0)\n    {\n        float phaser = 0.;//(sin(iTime) * 0.5 + 0.5);\n        float modTime = (iTime * 4.) + 6. * phaser + i * 1e-4;\n\t\t\n        const float PI = 3.1415;\n        const float halfPI = 3.1415 * 0.5;\n        c *= Circ(st, \n                  vec2(\n                      min(sin(modTime), 0.),\n                      sin((modTime + halfPI) * 0.5) * 0.5\n                  ), \n                  0.2);\n\n        st -= vec2(max(sin(modTime), 0.), 0.);\n\n        float direction = sign(fract(modTime/(4. * PI)) - .5);//rotation direction flips\n\t\n        float d = max(sin(modTime), 0.);\n        st = (d > 0.) ? Rotate(modTime * direction) * st : st;\n        c *= Box(st, vec2(0.05, 0.65));\n    }\n    \n    fragColor = vec4(vec3(1., 0., 0.) * c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 101, 101, 183], [185, 185, 223, 223, 319], [321, 321, 378, 378, 1287]], "test": "valid"}
{"id": "MltGz7", "name": "cavernous space", "author": "Daedelus", "description": "making old shaders public, experimenting with fake emissive lights via sdf, iirc this was 20 minutes as shader showdown practice", "tags": ["cavernousspace"], "likes": 8, "viewed": 112, "published": "Public", "date": "1595944782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOV 0.2\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\n\nfloat mapE(vec3 p, out float m)\n{\n    p.y += sin(p.z * 0.3) * 0.75;\n    m = sign(p.x);\n    p.x = abs(p.x);\n    p.x -= 1.0;\n    pR(p.xy, p.z);\n    p.x += sin(p.z * 0.125 + iTime) * 0.25;\n    return length(p.xy) - 0.01 - pow(sin(p.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 12.0) * 0.01;\n}\n\nfloat map(vec3 p, out float m)\n{\n    float dist = mapE(p, m);\n    \n    float cavern = -(length(p.xy * vec2(0.25, 1.0)) - 1.0) + texture(iChannel1, p.xz * 0.05).x - texture(iChannel1, p.xz * 0.25).x * 0.2;\n    if(cavern < dist)\n    {\n        dist = cavern;\n        m = 0.0;\n    }\n    \n    return dist;\n}\n\n#define NORMAL_FUNC(map, normal) float map(vec3 p){float m;return map(p, m);}vec3 normal(vec3 p, float s){vec2 e = vec2(0.01, 0.0);return normalize(vec3(map(p + e.xyy),map(p + e.yxy),map(p + e.yyx)) - s);}\n\nNORMAL_FUNC(map, normal)\nNORMAL_FUNC(mapE, normalE)\n\nvec4 triplanar(sampler2D tex, vec3 p, vec3 n)\n{\n    n = abs(n);\n    n /= n.x + n.y + n.z;\n    return texture(tex, p.yz) * n.x +\n        texture(tex, p.xz) * n.y +\n        texture(tex, p.xy) * n.z;\n}\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n};\n\nMaterial material(float m, vec3 is, vec3 n)\n{\n    Material o;\n    o.albedo;\n    o.emissive;\n    if(m == 0.0)\n    {\n        o.albedo = pow(triplanar(iChannel0, is * 0.5, n).xyz * 1.5, vec3(4.0));\n    }\n    else if(m == 1.0)\n    {\n        o.albedo = vec3(0.0);\n        o.emissive = vec3(0.0, 1.0, 1.0) + 2.0 * pow(sin(is.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 120.0);\n    }\n    else if(m == -1.0)\n    {\n        o.albedo = vec3(0.0);\n        o.emissive = vec3(1.0, 0.0, 1.0) + 2.0 * pow(sin(is.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 120.0);\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 nE, n, c, is, o = vec3(0.0, 0.0, iTime), d = vec3(0.0, 0.0, 1.0);\n    pR(d.xz, uv.x * FOV);\n    pR(d.yz, uv.y * FOV);\n    \n    float m, mE, s, t = 0.1;\n    for(int i = 0; i < 500; ++i)\n    {\n        is = o + d * t;\n        s = map(is, m) * 0.5;\n        t += s;\n        if(s<=0.0||t>40.0)\n            break;\n    }\n    \n    n = normal(is, s);\n    \n    s = mapE(is, mE);\n    nE = -normalE(is, s);\n    \n    Material mtl = material(m, is, n);\n    Material mtlE = material(mE, is, nE);\n    \n    float attenuation = pow(max(map(is + nE * s * 0.5) / (s * 0.5), 0.0), 0.25);\n    \n    c = mix(mtl.emissive + mtl.albedo * attenuation * mtlE.emissive * max(0.0, dot(n, nE)) / (1.0 + pow(s, 6.0)), mix(vec3(0.8, 0.6, 0.2), vec3(0.1, 0.3, 0.5), pow(abs(d.y), 0.25)), min(t / 40.0, 1.0));\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 49, 49, 119], [121, 121, 154, 154, 402], [404, 404, 436, 436, 706], [968, 968, 1015, 1015, 1166], [1226, 1226, 1271, 1271, 1781], [1783, 1783, 1840, 1840, 2728]], "test": "error"}
{"id": "tdjcWz", "name": "Aztec Walls", "author": "evvvvil", "description": "Winning shader made at REVISION 2020 demoparty Shader Showdown. Round 1 against Nusan / Cookies\nLive coded on stage in 25 minutes. Code was prepared before, not an improv.\nVideo of the battle is here: https://youtu.be/4GRD1gCX7fk?t=6058", "tags": ["fire", "demoscene", "particles", "beam", "glow", "pattern", "face", "revision", "dark", "walls", "inside", "aztec", "mexican"], "likes": 36, "viewed": 675, "published": "Public API", "date": "1594229593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Winning shader made at REVISION 2020 demoparty Shader Showdown. Round 1 against Nusan / Cookies\n// Video of the battle is here: https://youtu.be/4GRD1gCX7fk?t=6058\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,g2; vec3 np,bp,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 fb( vec3 p)\n{ \n    pp=p;pp.xz*=r2(.785);\n    vec2 h,t=vec2(bo(pp,vec3(4)),6);  \n    t.x=max(t.x,-(length(p)-1.));  \n    t.x=max(abs(abs(t.x)-.8)-.3,abs(p.y)-1.);  \n    t.x=max(t.x,abs(p.z)-3.5);\n    h=vec2(bo(pp,vec3(4)),3);  \n    h.x=max(h.x,-(length(p)-1.));  \n    h.x=max(abs(abs(h.x)-.8)-.15,abs(p.y)-1.3);\n    h.x=max(h.x,abs(p.z)-3.3);  \n    t=t.x<h.x?t:h;\n    h=vec2(bo(pp,vec3(4)),5);  \n    h.x=max(h.x,-(length(p)-1.));  \n    h.x=max(abs(abs(h.x)-.8)-.4,abs(p.y)-.7);  \n    h.x=max(h.x,abs(p.z)-3.7);  \n    t=t.x<h.x?t:h;\n    h=vec2(bo(pp,vec3(4)),6);  \n    h.x=max(h.x,-(length(p)-1.)); \n    h.x=max(abs(h.x),abs(p.y));  \n    h.x=max(h.x,abs(p.z)-3.);  \n    g+=0.1/(0.1+h.x*h.x*(10.-sin(bp.y*bp.z*.005+tt*5.)*9.));\n    t=t.x<h.x?t:h;   \n    t.x*=0.7;return t;\n}\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25;\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp(vec3 p)\n{\n    np=bp=p;\n    for(int i=0;i<4;i++){\n    \tnp=abs(np)-vec3(7,1.5,5);\n        np.xz*=r2(.3925);\n    }\n    vec2 h,t=fb(np);\n    h=fb(p*.085);h.x*=10.;\n    h.x=max(h.x,-(length(p.xz)-17.));  \n    t=t.x<h.x?t:h;   \t\n    h=vec2(.5*(abs(p.y)-4.+6.*texNoise(p.xz*.05).r),7);  \n    h.x=max(h.x,-(length(p.xz)-17.));        \n    t=t.x<h.x?t:h;    \n    h=vec2(length(abs(p.xz)-vec2(5.,0.))-.5+(np.y*.06),6);      \n    g2+=1./(0.1+h.x*h.x*(10.-cos(np.y*.2-tt*5.)*9.));    \n    t=t.x<h.x?t:h;   \n    h=vec2(length(abs(p.xz)-vec2(11.,29.))-.5+(np.y*.06),6);      \n    g+=1./(0.1+h.x*h.x*(10.-cos(np.y*.2-tt*5.)*9.));    \n    t=t.x<h.x?t:h;    \n    pp=p+vec3(0,sin(p.x*p.z*.01)*3.,0);pp.xz*=r2(sin(p.y*.1)*.7+tt);\n    h=vec2(length(sin(pp*.5-vec3(0,tt*5.,0))),6);  \n    h.x=max(h.x,(length(p.xz)-17.));  \n    g+=0.1/(0.1+h.x*h.x*(100.-sin(bp.y*bp.z*.005+tt*5.)*99.));\n    t=t.x<h.x?t:h;  \n    return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t= vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);       \n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y; \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=mix(vec3(sin(tt*.5)*5.,-cos(tt*.5)*50.,5.),vec3(cos(tt*.5-.5)*5.,35.,sin(tt*.5-.5)*45.),ceil(sin(tt*.5))),\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n  ld=normalize(vec3(.2,.5,.0));\n  v=vec2(abs(atan(rd.x,rd.z)),rd.y-tt*.2);  \n  co=fo=(vec3(.1)-length(uv)*.1-rd.y*.1)*3.*texNoise(v*.4).r;\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){ \n    po=ro+rd*t; \n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=mix(vec3(.7,.05,0),vec3(.5,.1,0),.5+.5*sin(np.x*.5));\n    if(z.y<5.) al=vec3(0);\n    if(z.y>5.) al=vec3(1);\n    if(z.y>6.) al=vec3(.7,.2,.1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);    \n    co=mix(mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(25.)),fo,min(fr,.2));\n    co=mix(fo,co,exp(-.000005*t*t*t)); \n  }pp=co+g*.2*mix(vec3(.7,.1,0),vec3(.5,.2,.1),.5+.5*sin(np.z*.2));\n  fragColor = vec4(pow(pp+g2*.2*vec3(.1,.2,.5),vec3(0.55)),1);\n} ", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 516, 516, 557], [558, 558, 575, 575, 618], [619, 619, 637, 637, 1395], [1396, 1396, 1419, 1419, 1621], [1622, 1622, 1639, 1639, 2531], [2532, 2532, 2561, 2561, 2736], [2826, 2826, 2883, 2883, 4032]], "test": "error"}
{"id": "tl2cRt", "name": "Velvet Chocolate Balls", "author": "koo1ant", "description": "This is from a demo submitted to Flashparty 2020 called \"A.S.A.C.\". It is my first raymarched stuff. Uses a tweaked Phong shading and I'm also offsetting the ray position backwards a bit. That seemed to help with the ball melting on the ground.", "tags": ["raymarching", "metaball", "goo"], "likes": 7, "viewed": 129, "published": "Public", "date": "1595141164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\n#define MAX_STEPS 200\n#define MAX_DIST 200.0\n#define SURFACE_DIST 0.01\n#define DEFAULT_SHADOW_ATT 0.5\n#define PROCESSED_LIGHTS 3\n#define AMBIENT_INTENSITY 0.2\n\nstruct DistanceInfo {\n    float dist; // Distance to object\n    int id; // Object ID\n};\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k*h * (1.0 - h);\n}\n\nvec2 gooBall(vec3 rp, vec3 frontPos, vec3 backPos, float radius, float fn) {\n    vec2 ret;\n    // Front ball\n    ret.x = length(rp - frontPos)\n        - radius - sin(rp.x * 5.0 + t*10.0) * 0.05 + sin(rp.y * 5.0 - t*1.0) * 0.01;\n    \n    // Back ball\n    ret.y = length(rp - backPos)      \n       - radius - sin(rp.x * 5.0 + t*10.0) * 0.05 + sin(rp.y * 1.0 - t*1.0) * 0.01;\n    return ret;\n}\n\nDistanceInfo map(vec3 rp)\n{\n    float ret;\n    float s[3];\n\n    // Gooball\n    float phase = -1.8;\n    float freq = 0.8;\n    float amp = 0.9;\n    float heigth = 1.0;\n    vec3 frontPos = vec3(0., sin(t * freq + phase) * (5. * amp) + heigth, 0.);\n    vec3 backPos = vec3(-1.7 + sin(t) * 1., sin(t * freq - .2 + phase) * (5. * amp) + heigth,0.);\n    vec2 gb = gooBall(rp, frontPos, backPos, 2., 0.);\n    s[0] = gb.x;\n    s[1] = gb.y;\n\n    // Plane\n    float plane = rp.y + sin(rp.x+t*8.)*0.15; //+ sin(rp.x + t*10.) * 0.2;\n\n    // Combine maps and set material data    \n    float dist = 1.0;\n    for(int i=0; i<2; i++){\n        dist = smin(dist, s[i], 0.45);\n    }\n    dist = smin(dist, plane,0.45);\n    \n    int id = 10;\n    return DistanceInfo(dist, id);\n}\n\n\nDistanceInfo march(vec3 ro, vec3 rd)\n{\n    vec3 color;\n    float md; // Marched distance\n    DistanceInfo di;\n    for(int i = 0; i < MAX_STEPS; i ++ ) {\n        vec3 rp = ro + rd * md + -0.71;\n        di = map(rp);\n        md += di.dist;\n        if (md > MAX_DIST || di.dist < SURFACE_DIST)break;\n    }\n    return DistanceInfo(md, di.id);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = map(p).dist; // Get distance to surface point\n    \n    // Normal trick from Art Of Code (using derivatives/slopes)\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d-vec3(map(p - e.xyy).dist, map(p - e.yxy).dist, map(p - e.yyx).dist);\n    \n    return normalize(n); // Return unit vector because we want a direction\n}\n\nstruct LightOutput {\n    float diffuse;\n    float specular;\n    float attenuation; // Used for shadows\n};\n\nstruct LightData {\n    vec3 position;\n    float intensity;\n};\n\nLightOutput light(vec3 ro, vec3 p, vec3 normal, LightData data) {\n    // Phong based\n    vec3 lv = normalize(data.position - p); // Get light vector at that point (light pos - surface pos)\n    float diffuse = max(dot(normal, lv), 0.0);\n    \n    // Specular\n    vec3 viewVector = normalize(p - ro);\n    vec3 lr = reflect(lv, normal);\n    float specular = smoothstep(0.,0.31,pow(max(dot(viewVector, lr), 0.0), 50.0)); // Calculate specular brigthness\n        \n    // Shadow (from Art Of Code)\n    float attenuation;\n    vec3 sv = vec3(p.x+0.00,p.y + 0.00,p.z+0.00);\n    float sd = march(sv + normal * SURFACE_DIST * 2.0, lv).dist;\n\n    return LightOutput(diffuse * data.intensity, specular * data.intensity, attenuation);\n}\n\nvec3 shade(vec3 rd, vec3 ro, DistanceInfo di) {\n    \n    vec3 p = ro + rd * di.dist; // Get point to surfaces\n    vec3 n = getNormal(p); // Get surface normal for point\n    \n    vec3 lightPos = vec3(1.35, 6.00, - -3.58 + sin(t * 0.5));\n    \n    LightOutput lights[3];\n    lights[0] = light(ro, p, n, LightData(lightPos, 0.7));\n    lights[1] = light(ro, p, n, LightData(lightPos + vec3(-18.85), 0.1));\n    lights[2] = light(ro, p, n, LightData(lightPos + vec3(55.00,0.00,64.00), 0.5));\n    \n    // Ambient color\n    vec3 ambient = vec3(AMBIENT_INTENSITY, AMBIENT_INTENSITY, AMBIENT_INTENSITY+0.34);\n    \n    // Object color\n    vec3 color = vec3(0.8196, 0.2353, 0.2353);\n    \n    if (di.id != -1) { // If we hit something, calculate color\n        float diffuse;\n        float specular;\n        float attenuation;\n        \n        // Accumulate lighting intensities from every light\n        for(int i = 0; i < PROCESSED_LIGHTS; i ++ ) {\n            diffuse += lights[i].diffuse;\n            specular += lights[i].specular;\n            attenuation += lights[i].attenuation;\n        }\n        \n        vec3 litColor = (ambient + diffuse) * color + specular;\n        \n        return litColor * (1.-attenuation);\n        \n    }else { // Else, we are in the skybox/background\n        return vec3(0);\n    }\n}\n\nvec4 image(vec2 fragCoord, vec2 uv) \n{\n    vec3 ro = vec3(-7.0, 6.35, -15.0); // Ray origin or camera position\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.00)) + vec3(0.8,-0.3,1.1);\n    \n    DistanceInfo di = march(ro, rd); // Get distance to scene objects\n    vec3 col = shade(rd, ro, di); // Fragment color. Calculate shading.\n    \n    return vec4(col, 1.0); \n}\n\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = setupSpace(fragCoord, iResolution.xy);\n    fragColor = image(fragCoord, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2cRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 305, 305, 406], [408, 408, 484, 484, 798], [800, 800, 827, 827, 1555], [1558, 1558, 1596, 1596, 1898], [1900, 1900, 1924, 1924, 2247], [2419, 2419, 2484, 2503, 3140], [3142, 3142, 3189, 3189, 4442], [4444, 4444, 4482, 4482, 4806], [4809, 4809, 4850, 4850, 4923], [4925, 4925, 4982, 4982, 5075]], "test": "valid"}
{"id": "tl2cWz", "name": "simplest 3d tutorial example", "author": "soggymongoose", "description": "two dots", "tags": ["3d"], "likes": 0, "viewed": 104, "published": "Public", "date": "1594269617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//credit to the art of code\n\n//Distance between camera ray and a point\nfloat distLine(vec3 ro, vec3 rd, vec3 p) {\n  return length(cross(p-ro, rd))/length(rd);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized uv from -.5 to .5 with respect to aspect ratio\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Camera\n    vec3 rayOri = vec3(0., 0., -2.);\n    vec3 rayDir = vec3(uv.x, uv.y, 0.)-rayOri;\n    \n    //Points\n    vec3 point = vec3(sin(iTime), .4, 2.+cos(iTime));\n    vec3 point2 = vec3(cos(iTime), -.4, 2.+sin(iTime)); \n \n    //Calculating the distance\n    float dist = min(distLine(rayOri, rayDir, point), distLine(rayOri, rayDir, point2));\n        \n    vec3 col = vec3(smoothstep(.2, .16, dist));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2cWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 71, 113, 113, 162], [164, 164, 221, 286, 824]], "test": "valid"}
{"id": "tl2czK", "name": "Reflective Balls", "author": "vipiao", "description": "Using ray marching to render multiple reflective balls on a reflective catwalk.", "tags": ["raymarching", "reflection", "animated"], "likes": 0, "viewed": 237, "published": "Public API", "date": "1594872789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Inspird by \"[TUT] RayMarching for Dummies!\".\n\n#define PI 3.1415926538\n\n#define MAX_STEPS 300\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(2.5, 1, 2.5, 1);\n    \n    vec3 p2 = p;\n    p2.y = mod(p.y+1., 5.)-1.;\n    float sphereDist =  length(p2-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 pos = ro;\n    vec3 posMod;\n    bool isRelective = true;\n    int numR = 0;\n    int occlusion = 0;\n    float curveFactor = -0.0005;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        // Reflection.\n        /*vec3 reflectionPoint = vec3(1.+iTime*5.,0,0);\n        vec3 reflectionNormal = normalize(vec3(-1,-0.5,0));\n        vec3 relPos = pos-reflectionPoint;\n        float proj = dot(relPos, reflectionNormal);\n        if(proj < 0.){\n        \tpos -= 2.*reflectionNormal * proj;\n            rd = reflect(rd, reflectionNormal);\n        }*/\n        \n        //\n        posMod.x = mod(pos.x, 5.);\n        posMod.y = pos.y;\n        posMod.z = mod(pos.z, 5.);\n        float dS = GetDist(posMod);\n        pos += rd*dS;\n        \n        // Curve.\n        vec3 sideways = normalize(vec3(-rd.z, rd.y, rd.x));\n        rd = normalize(rd + vec3(0,curveFactor*dS,0) + sideways*dS*0.002);\n        \n        dO += dS;\n        //if(dO>MAX_DIST || dS<SURF_DIST) break;\n        if(dS<SURF_DIST) {\n            if (pos.z >= 5. || pos.z <= 0. || pos.y > 5.) isRelective = false;\n            break;\n        }\n        occlusion ++;\n        if (i == MAX_STEPS-1){\n        \treturn dO/(pow(float(occlusion), 0.5)*0.1+1.);\n        }\n    }\n    // Reflect.\n    for(int j=0; j</*int(mod(iTime,5.))*/10 && isRelective; j++) {\n        numR++;\n        dO *= 1.;\n        vec3 normal;\n        if (pos.y < SURF_DIST) {\n            normal = vec3(0,1,0);\n        } else {\n            normal = normalize(posMod-vec3(2.5, 1, 2.5));\n        }\n        if (dot(rd,normal) < 0.) {\n        \trd = reflect(rd, normal);\n            numR++;\n        }\n        pos += rd*SURF_DIST*2.;\n\n        for(int i=0; i<MAX_STEPS; i++) {\n            // Reflection.\n            /*vec3 reflectionPoint = vec3(1.+iTime*5.,0,0);\n            vec3 reflectionNormal = normalize(vec3(-1,-0.5,0));\n            vec3 relPos = pos-reflectionPoint;\n            float proj = dot(relPos, reflectionNormal);\n            if(proj < 0.){\n                pos -= 2.*reflectionNormal * proj;\n                rd = reflect(rd, reflectionNormal);\n            }*/\n            \n            //\n            posMod.x = mod(pos.x, 5.);\n            posMod.y = pos.y;\n            posMod.z = mod(pos.z, 5.);\n            float dS = GetDist(posMod);\n            pos += rd*dS;\n        \n            // Curve.\n            vec3 sideways = normalize(vec3(-rd.z, rd.y, rd.x));\n        \trd = normalize(rd + vec3(0,curveFactor*dS,0) + sideways*dS*0.002);\n            \n            dO += dS;\n            //if(dO>MAX_DIST || dS<SURF_DIST) break;\n            if(dS<SURF_DIST) {\n            \tif (pos.z >= 5. || pos.z <= 0. || pos.y > 5.) isRelective = false;\n                break;\n            }\n            occlusion ++;\n            if (i == MAX_STEPS-1){\n                return dO/(pow(float(occlusion), 0.5)*0.1+1.);\n            }\n        }\n    }\n    /*for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }*/\n    return dO/(pow(float(occlusion), 0.5)*0.1+1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.+iTime*1.*5., 1.+0.15+cos(iTime*PI*.2)*1., cos(iTime*PI*.2*0.5+PI*0.5)*3.5*0.+4.);\n    //vec3 ro = vec3(0.+iTime*1.*5., 6.+cos(iTime)*3.5, 2.5+cos(iTime+PI*0.5)*3.5);\n    float angle = sin(iTime*0.2)*PI*0.5+PI;\n    //vec3 ro = vec3(0., 1., 0.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    float x = -rd.z*sin(angle + PI*0.) + rd.x*cos(angle + PI*0.);\n    float z = rd.x*sin(angle + PI*0.) + rd.z*cos(angle + PI*0.);\n    rd.x = x;\n    rd.z = z;\n    \n    float d = RayMarch(ro, rd);\n    col = vec3(d/150.);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2czK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 165, 165, 386], [388, 388, 422, 422, 3499], [3501, 3501, 3558, 3558, 4234]], "test": "valid"}
{"id": "tl2yD3", "name": "v3-2DCloudSea", "author": "jorge2017a1", "description": "v3-2DCloudSea", "tags": ["v32dcloudsea"], "likes": 1, "viewed": 64, "published": "Public", "date": "1595617879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Create  by JiepengTan@gmail.com\n\nfloat Remap(float oa,float ob,float na,float nb,float val){\n\treturn (val-oa)/(ob-oa) * (nb-na) + na;\n}\n\n\nfloat Wave(float layer,vec2 uv,float val)\n{\n\tfloat amplitude =  layer*layer*0.00004;\n\tfloat frequency = val*200.0*uv.x/layer;\n\tfloat phase = 9.*layer+ iTime/val;\n\t\n    return amplitude*sin(frequency+phase); \n}\n\t\n\nfloat Circle(vec2 uv,vec2 center,float size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\nfloat AngleCircle(vec2 uv,vec2 center,float size,float blur)\n{\n\tuv = uv - center;\n\tuv /= size;\n\tfloat deg = atan(uv.y,uv.x) + iTime * -0.1;\n\tfloat len = length(uv);\n\tfloat offs =( sin(deg*9.0)*3.+sin(deg*11.0+sin(iTime*6.0)*0.5))*0.05;\n\treturn smoothstep(1.+offs,1.-blur+offs,len);\n}\n\n\n\nfloat DrawCloud(vec2 uv,vec2 center,float size)\n{\n\tuv = uv - center;\n\tuv /= size;\n\tfloat col = Circle(uv,vec2(0.,0.),0.2,0.05);\n\tcol =col *  smoothstep(-0.1,-0.1+0.01,uv.y);\n\tcol += Circle(uv,vec2(0.15,-0.05),0.1,0.05);\n\tcol += Circle(uv,vec2(0.,-0.1),0.11,0.05);\n\tcol += Circle(uv,vec2(-0.15,-0.1),0.1,0.05);\n\tcol += Circle(uv,vec2(-0.3,-0.08),0.1,0.05);\n\tcol += Circle(uv,vec2(-0.2,0.),0.15,0.05);\n\treturn col;\n}\n\n\nfloat DrawClouds(vec2 uv)\n{\n\tuv.x += 0.03*iTime;\n\tuv.x = fract(uv.x+0.5) - 0.5;\n\tfloat col = DrawCloud( uv,vec2(-0.4,0.3),0.2);\n\tcol += DrawCloud( uv,vec2(-0.2,0.42),0.2);\n\tcol += DrawCloud( uv,vec2(0.0,0.4),0.2);\n\tcol += DrawCloud( uv,vec2(0.15,0.3),0.2);\n\tcol += DrawCloud( uv,vec2(0.45,0.45),0.2);\n\treturn col;\n}\n\nvec3 ProcessFrag(vec2 uv)  \n{\n\tvec3 col = vec3(0.0,0.0,0.0);\n\tfloat num = 0.;\n    const float LAYER =3.0;\n\t\n    for (float i=1.; i < LAYER; i++) \n    {\n\t\tfloat wave = 2.*Wave(i,uv,1.)+Wave(i,uv,1.8)+.5*Wave(i,uv,3.);\n\t\tfloat layerVal = 0.7-0.03*i + wave;\n\t\t\n        if(uv.y >layerVal)\n        {\n\t\t\tbreak;\n\t\t}\n        \n\t\tnum = i;//计算所在层的ID\n\t}\n\t\n    col = num*vec3(0.0,.03,1.0);//计算每一层的基本颜色\n\tcol += (LAYER - num) * vec3(.04,.04,.04);//颜色叠亮\n\t\n    if(num ==0.0)\n    {\n\t\t\t\t\t//添加海平面泛光\n\t\tfloat ry = Remap(0.7,1.0,1.0,0.0,uv.y);\n\t\t//col = lerp(vec3(0.1,0.6,0.9),vec3(0.1,0.7,0.9),ry);\n        col = mix(vec3(0.1,0.6,0.9),vec3(0.1,0.7,0.9),ry);\n        \n\t\tcol += pow(ry,10.)*vec3(0.9,0.2,0.1)*0.2;\n\t}\n\t\n    //调整UV为(-0.5,-0.5,0.5,0.5)方便绘图\n\tuv = uv - vec2(0.5,0.5);\n\t//添加太阳\n\t\tvec2 sunPos = vec2(0.3,0.35);\n\t\tfloat sun = Circle(uv,sunPos,0.06,0.05);\n\t\tfloat sunCircle = AngleCircle(uv,sunPos,0.08,0.05);\n\t\t//col = lerp( col ,vec3(0.9,0.6,0.15),sunCircle);\n    \tcol = mix( col ,vec3(0.9,0.6,0.15),sunCircle);\n\t\t//col = lerp( col ,fixed3(0.98,0.9,0.1),sun);\n    col = mix( col ,vec3(0.98,0.9,0.1),sun);\n\t\t//云\n\t\tcol += DrawClouds(uv);\n\t\treturn col;\n\t\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col =ProcessFrag(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 95, 95, 138], [141, 141, 184, 184, 350], [354, 354, 410, 410, 505], [507, 507, 569, 569, 790], [794, 794, 843, 843, 1208], [1211, 1211, 1238, 1238, 1526], [1528, 1528, 1557, 1557, 2744], [2747, 2747, 2804, 2854, 3074]], "test": "valid"}
{"id": "tl2yDV", "name": "Retro Neon", "author": "EDragon", "description": "A little sandbox of mine that I went a bit ham on", "tags": ["neon"], "likes": 6, "viewed": 152, "published": "Public", "date": "1595445401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define resolution iResolution\n#define time iTime\nmat2 rot(float a){\n\treturn mat2(cos(a), sin(a), sin(-a), cos(a));\n}\nvec2 rotate(vec2 v, vec2 o, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * (v-o) + o;\n}\n\n// shamelessly yoinked from https://shadertoy.com/view/MlsfRj\n\nvec2 TransformPlane(vec2 uv, vec2 center, float XRot, float YRot) {\n    // First Rotate around Y axis\n    vec2 RayDirection =  vec2(uv.x, 0.0);\n    vec2 A1 = vec2(0.0, -1.0);\n    vec2 B1 = RayDirection - A1;\n    vec2 C1 = rotate(vec2(-1.0, 0.0), vec2(center.x, 0.0), YRot);\n    vec2 D1 = rotate(vec2( 1.0, 0.0), vec2(center.x, 0.0), YRot) - C1;\n    // calculate intersection point\n    float u = ( (C1.y + 1.0) * D1.x - C1.x * D1.y ) / (D1.x*B1.y-D1.y*B1.x);\n    // position on the plane:\n    float sx = u * B1.x;\n \tfloat sy = u * uv.y;\n    // Now Rotate around X axis\n    RayDirection = vec2(sy, .0);\n    vec2 B2 = RayDirection - A1;\n    vec2 C2 = rotate(vec2(-1.0, 0.00), vec2(center.y, 0.0), XRot);\n    vec2 D2 = rotate(vec2( 1.0, 0.0), vec2(center.y, 0.0), XRot) - C2;\n    // calculate intersection point\n    float v = ( (C2.y + 1.0) * D2.x - C2.x * D2.y ) / (D2.x*B2.y-D2.y*B2.x);\n    // final position on the plane:\n    return vec2(v * sx, v * B2.x );\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = gl_FragCoord.xy / resolution.y;\n\tvec2 uv2 = (gl_FragCoord.xy-.5*resolution.xy) / resolution.y;\n\tvec2 uv3 = uv2;\n\tvec2 uv4 = uv2;\n\tvec2 uv = gl_FragCoord.xy / vec2(resolution.x*.6, resolution.y);\n\tvec2 st = gl_FragCoord.xy / vec2(resolution.x*.6, resolution.y);\n    vec2 coord = TransformPlane(uv-vec2(.833,.0), vec2(.0,.0),-.95, -.0);\n\n\tuv.y += .5;\n\tfloat m = .8;\n\tuv.y *= 1.*pow(uv.y, (ouv.y*5.))+m;\n\tuv.y -= m;\n    //uv.x = pow(uv.x,0.6);\n\t//uv.x *= (uv.y);\n\tuv2.y *= uv.y*75.;\n\tuv2.y += time*5.;\n\tcoord *= rot(-((iMouse.x+(resolution.x*.5))-(resolution.x))/resolution.x*6.275);\n\tst.y -= .05;\n\n\n\n\tuv.y -= time*.1;\n    coord.y -= time*.2;\n\n\tuv = fract(uv*10.);\n\tcoord = fract(coord*5.);\n\n\n\n\tfloat d = mix(.0, 1., smoothstep(.15, .145, distance(uv3, vec2(.0, .25))));\n\tfloat d2 = d;\n    float d3 = mix(.0, 1., smoothstep(.4, .1, distance(uv3, vec2(.0, .25))));\n\n\n\t\n\tfloat l = smoothstep(coord.x*1.333, .0, .05);\n\tfloat r = smoothstep(coord.x*.966, 1., .95);\n\tfloat b = smoothstep(coord.y , .0, .05);\n\tfloat t = smoothstep(coord.y, 1., .95);\n\n\tvec3 col = vec3(0.);\n\n\n\tfloat al = l*r*b*t;\n\tcol = vec3(1.-al);\n\tcol *= smoothstep(st.y, 1.5, .65);\n\n\tcol *= vec3(1., .0, 1.);\n    \n\tcol *= pow(col, vec3(.24545));\t//shhh, no witnesses\n\tcol *= 5.;\n\tfloat ni = clamp(.0, .0, (sin(time+uv2.y-.5)+.5));\n\tni = pow(ni,2.);\n\tvec3 dc = vec3(.8, .4, .1);\n\tvec3 dc2 = vec3(.8, .4, .1);\n\tuv4.y *= d2*2.;\n\tdc *= 1.+smoothstep(1., .0, 1.-uv4.y)-(1.-d);\n\tdc2 *= 1.+smoothstep(1., .0, 1.-uv4.y)-(1.-d3);\n\td *= ni;\n\tif (d <= .0 && uv3.y <= .21){\n\t\td2 *= d;\n\t}\n    uv3.y += -.175*cos(uv3.x)+.175;\n    float mi = smoothstep(.0, .5, uv3.y);\n\tvec3 mist = vec3(1., .1, .8);\n\tmist *= vec3(mi);\n\tcol += vec3(dc*d2*.65+dc2*.5+mist*.5);\n\tcol *= pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 68, 68, 117], [118, 118, 156, 156, 260], [325, 325, 392, 426, 1288], [1289, 1289, 1346, 1346, 3130]], "test": "valid"}
{"id": "tl2yWm", "name": "Assembly line", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wtByDw]\"Industrial machinery\"[/url] shader.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 1, "viewed": 227, "published": "Public API", "date": "1594586473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define iterations 3\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1,float i){\n    //p += sin(p.yzx+iTime*i*9.0)/(i*27.0); //animation\n    return size-length(sin(p/vec3(length(p/20.0)))*size1)/1.8;\n}\n\nfloat vines(vec3 p,float size1){\n\treturn vines(p,size1,1.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float multiplier = 3.0+sin(iTime/100.0);\n    float i = multiplier;\n\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p*i)/i;\n        result = vines(p,size1,i)/i;\n        i *= multiplier;\n    }\n    return (result)*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p *= sin(p);\n    float v = vines(p,1.0);\n    return sin(vec3(v*6.0,v*4.0,v*3.0))/5.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    vec3 eye = vec3(50.0,1.6,iTime/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 648, 704, 769], [771, 771, 803, 803, 833], [835, 835, 859, 859, 1193], [1195, 1195, 1223, 1242, 1326], [1328, 1749, 1840, 1840, 2204], [2219, 2473, 2538, 2538, 2670], [2672, 2761, 2790, 2790, 3105], [3107, 3599, 3739, 3739, 4349], [4351, 4721, 4806, 4806, 5153], [5155, 5482, 5531, 5566, 5697], [5699, 5699, 5756, 5756, 6747]], "test": "valid"}
{"id": "tl2yWR", "name": "Fractal tunnel", "author": "jarble", "description": "A simple tunnel, based on my [url=https://www.shadertoy.com/view/wljyWR]\"swiss cheese caves\"[/url] fractal.", "tags": ["3d", "raymarching", "fractal"], "likes": 5, "viewed": 215, "published": "Public API", "date": "1594152278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    return length(sin((p*(i+1.0)/size))*size) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult += planet_surface(p*i,i)/(i*i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*5.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 621, 621, 677], [679, 679, 714, 714, 942], [944, 944, 967, 967, 994], [996, 996, 1024, 1024, 1154], [1157, 1578, 1669, 1669, 1975], [1990, 2244, 2309, 2309, 2441], [2443, 2532, 2561, 2561, 2871], [2873, 3365, 3505, 3505, 4115], [4117, 4487, 4572, 4572, 4987], [4989, 5316, 5365, 5400, 5531], [5533, 5533, 5590, 5590, 6666]], "test": "valid"}
{"id": "tlBcD1", "name": " 大龙猫 - OpArt #1", "author": "totetmatt", "description": "Native attempt to implement opArt algo. (Based on book Graphisme Scientifique sur Micro-Ordinateur, R.Dony )\nStarted with simple implementation, then went crazy with simple glsl trick :p\n\nStill using some coordinate, wondering if it's possible to avoid it", "tags": ["opart"], "likes": 14, "viewed": 362, "published": "Public API", "date": "1594232170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.1415\n#define TAU 2.0*PI\n#define zero vec2(0.,0.)\n\n#define K .05\n#define RECUR 45.\n#define BASE_SIZE 1.0\nfloat det(vec2 a,vec2 b) {\n    return (a.x * b.y) - (a.t * b.x);\n}\nvec2 intersect(vec2 a, vec2 b,vec2 p,vec2 q) {\n       vec2 xdiff = vec2(a.x-b.x,p.x-q.x);\n       vec2 ydiff = vec2(a.y-b.y,p.y-q.y);\n      \n       float div = det(xdiff,ydiff);\n       \n       vec2 d = vec2(det(a,b),det(p,q));\n       return vec2(det(d,xdiff),det(d,ydiff))/div ;\n       \n    }\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec2 coord(float a,float r) {\n    return vec2(cos(a),sin(a))*r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv =( fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    uv +=vec2(cos(iTime),sin(iTime))*.1;\n    uv*=r(3.*sin(atan(uv.x,uv.y)*.45));\n    vec2 id = floor(uv);\n    uv=fract(uv)-.5;\n    float d = 0.;\n    vec3 col = vec3(0.);\n    float q = 6.+cos(floor(iTime)+pow(fract(iTime),2.))*2.;\n    float stepT = TAU/q;\n   \n   float D =1./20.;\n   \n   float loop_start;\n   float loop_end;\n   float stp;\n   if(mod(id.x,2.)==0.){\n      uv.x = -uv.x;\n      \n   } \n   if(mod(id.y,2.) == 0.){\n   uv.y = -uv.y;\n   }\n  \n   for(float j=0.;j<1.;j+=1./RECUR){\n        for(float i=0.;i<=TAU;i+=stepT) {\n         d += smoothstep(0.018,0.003,\n         sdSegment(uv,coord(i,BASE_SIZE), coord(i+stepT,BASE_SIZE)  ));\n      }\n      vec2 ipoint = intersect(zero,coord(0.+K,BASE_SIZE),coord(stepT,BASE_SIZE),coord(0.,BASE_SIZE));\n      float dst = length(ipoint);\n      uv*=1./dst;\n     uv *=r(K) ;\n    col += d*(palette(j + mod(iTime*.2,2.),vec3(.5),vec3(.5),vec3(1.),vec3(0.50, 0.10, 0.33))/RECUR);\n     \n    }\n     //col = mix(vec3(.1),vec3(.2,.3,.5),col);\n    //vec3 col = vec3(d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 144, 144, 184], [185, 185, 231, 231, 476], [477, 477, 529, 529, 648], [649, 649, 678, 678, 714], [715, 715, 731, 731, 789], [791, 791, 863, 863, 906], [907, 907, 962, 962, 2077]], "test": "valid"}
{"id": "tlBcDK", "name": "simple soft shadow", "author": "x33ch0u", "description": "soft shadow of objects", "tags": ["raymarching", "shadow"], "likes": 0, "viewed": 138, "published": "Public", "date": "1595453861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.141592653\n#define MAX_STEPS 100\n#define EPSILON 1e-3\n\nstruct Ray { vec3 o, d; };\n\n\n//we need a better ray function that can take camera pos, fov.\nRay getRay(vec2 uv, vec3 ori, vec3 dir, float len)\n{\n    dir = normalize(dir);\n    \n    vec3 right = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, dir));\n    vec3 center = ori + dir * len;\n    vec3 intersect = center + right * uv.x + up * uv.y;    \n     \n    return Ray(ori, normalize(intersect-ori));  \t\n}\n\nfloat sphereSDF(vec3 p, float s)\n{    \n    return length(p) - s;\n}\n\n\nfloat floorSDF(vec3 p)\n{\n    return p.y;\n}\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    //length(max(q, 0.0) represents the ouside of the distance\n    //min(0.0, maxcomp(q)) represents the inner of distance.    \n    return length(max(q,0.0)) + min(0.0, max(q.x,max(q.y,q.z)));\n}\n\nfloat sceneSDF(vec3 p)\n{\n    //return sphereSDF(p - vec3(-10.0, 0.0, -20.0), 4.0);\n    return min(floorSDF(p - vec3(0.0, -0.0, 0.0)),\n               boxSDF(p - vec3(sin(iTime) * 3.0, 3.0, -5.0), \n                      vec3(1.0, 2.0, 1.0)));\n    vec3 qos = vec3( fract(p.x+0.5)-0.5, p.yz );\n    return min( floorSDF(p.xyz-vec3( 0.0,0.00, 0.0)),\n                boxSDF(qos.xyz-vec3( 0.0,0.25, -1.5), \n                       vec3(0.2,0.4,0.2) ) );\n    \n    \n}\n\nvec3 normal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sceneSDF( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sceneSDF( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sceneSDF( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sceneSDF( pos + e.xxx ) );\n}\n\n\nfloat rayMarching(in Ray ray, out vec3 p)\n{\n    //a tradtional ray marching method\n\tfloat dist, depth = 0.0;\n    const float dfar = 500.0;      \n  \n    for (int i = 0; i < MAX_STEPS; i++) {\n\t\tp = ray.o + ray.d * depth;\n        dist = sceneSDF(p);\n        if (dist < EPSILON)\n            return dist;\n        depth += dist;\n        if (depth > dfar)\n            return dfar;\n    }       \n    return dfar;\n}\n\n\nfloat shadow(vec3 p, vec3 lo, float k)\n{\n    vec3 d = normalize(lo-p);\n    float mint = 0.1, maxt = length(lo-p);  \n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 30; i++) {\n        float h = sceneSDF(p+t*d);\n        res = min(res, k * h / t);\n        t += h;    \n        if (res < EPSILON || t > maxt)\n            return res;\n    }    \n    return res;\n}\n\nfloat AO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = sceneSDF( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n\nfloat lighting(vec3 p)\n{\n    vec3 n = normal(p);\n\tvec3 lightPos = vec3(7.0, 10.0, 0.0);\n    vec3 lightDir = normalize(lightPos - p);\n    \n    float amb = AO(p, n);\n    float intensity = max(0.0, dot(lightDir, n));\n    \n    return shadow(p, lightPos, 8.0) * intensity + amb * 0.2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 origin = vec3(-3.0, 2.0, 1.0);\n    vec3 dir = vec3(-0.0, 0.0, -1.0);\n    Ray ray = getRay(uv, origin, dir, 1.0);\n    vec3 p;\n    \n    float dist = rayMarching(ray, p);\n    if (dist >= 500.0) {\n    \tcol = vec3(0.0);    \n    } else {\n    \tcol = vec3(lighting(p));    \n    }        \n\t    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 161, 213, 213, 502], [504, 504, 538, 538, 570], [573, 573, 597, 597, 615], [617, 617, 647, 647, 867], [869, 869, 893, 951, 1325], [1327, 1327, 1350, 1350, 1570], [1573, 1573, 1616, 1655, 1978], [1981, 1981, 2021, 2021, 2353], [2355, 2355, 2385, 2385, 2651], [2654, 2654, 2678, 2678, 2935], [2938, 2938, 2995, 3045, 3500]], "test": "valid"}
{"id": "tlBcWd", "name": "Unicorn Torus (FieldFX)", "author": "blackle", "description": "coded in 25 minutes for shader showdown!", "tags": ["shadershowdown", "livecode"], "likes": 26, "viewed": 536, "published": "Public API", "date": "1595694469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    p = abs(p)-d;\n    return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat blob(vec3 p) {\n    p =asin(sin(p*10.))/10.;\n    return length(p);\n}\n\nfloat wallthing;\nfloat light;\nfloat t;\nfloat scene(vec3 p) {\n    vec2 tdim = vec2(3.,1.5);\n    float tdist = length(vec2(length(p.xy)-tdim.x,p.z))-tdim.y;\n    \n    vec3 pring = vec3(normalize(p.xy)*tdim.x,0);\n    vec3 pax = normalize(cross(pring,vec3(0,0,1)));\n    vec3 poff = p-pring;\n    float pang = atan(pring.x,pring.y);\n    float prot = sin(iTime+pang);\n    poff = erot(poff,pax,prot);\n    vec3 ploc = pring+poff;\n    vec3 pclos = pring+normalize(poff)*tdim.y;\n    \n    float wdth = dot(sin(pclos*2.),cos(pclos*2.))*.5+.3;\n    float blb = blob(pclos);\n    wallthing = box(vec2(blb,tdist), vec2(wdth,.2))-.05;\n    wallthing = min(wallthing, box(vec2(blb,tdist), vec2(.04,.4+sin(t*5.)*.2))-.01);\n    vec3 rtd=vec3(asin(sin(ploc.xy*2.))/2.,ploc.z);\n    float pillar = length(rtd.xy)-.02;\n    pillar = min(pillar, box(vec2(pillar,asin(sin(rtd.z*10.+t*6.))/10.),vec2(0.03,0.02))-.01);\n    light = length(vec2(wallthing,tdist))-.02;\n    light = min(light, box(vec2(pillar,asin(sin(rtd.z*10.+t*6.+11.))/10.),vec2(0.03,0.02))-.01);\n    \n    wallthing *= .9;\n    \n    return min(min(min(-tdist,wallthing), pillar),light);\n}\n\nvec3 norm (vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    t = iTime/60.*135.;\n    t = pow(sin(fract(t)*3.1415/2.)*.5+.5,10.)+floor(t);\n    vec3 cam = normalize(vec3(1.-dot(uv,uv)*.9+sin(t*1.5)*.4,uv));\n    vec3 init = vec3(-3.5,0,0)+cam*.1;\n    \n    cam = erot(cam, vec3(1,0,0), cos(t/2.)*.5);\n    cam = erot(cam, vec3(0,0,1), t/4.);\n    cam = erot(cam, vec3(0,0,1), .7+sin(t)*.5);\n    init = erot(init, vec3(0,0,1), t/4.);\n    \n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glo = 0.;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        glo += .05/(1.+abs(light)*30.);\n        p+=dist*cam*.7;\n    }\n    bool wt = wallthing == dist;\n    bool lt = light == dist;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    float ro = smoothstep(-.1,.1,scene(p+r*.1));\n    float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n    float diff = length(sin(n*2.)*.4+.6)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n    vec3 matcol = wt ? vec3(0.9,0.2,0.8) : vec3(0.04);\n    vec3 col = diff*matcol*ao + pow(spec,10.)*fres*ro;\n    col = abs(erot(col, normalize(sin(p*2.+iTime*2.+r)),1.));\n    if (lt) col = vec3(1);\n    fragColor.xyz = hit ? col : vec3(0.01);\n    fragColor.xyz = sqrt(fragColor.xyz+ glo*glo + glo*vec3(.2,.5,1));\n    fragColor.xyz *= 1.-dot(uv,uv)*.7;\n    fragColor.xyz *= 1.1;\n    fragColor.xyz = smoothstep(0.,1.,fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcWd.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 323, 323, 394], [396, 396, 416, 416, 469], [510, 510, 531, 531, 1591], [1593, 1593, 1613, 1613, 1726], [1728, 1728, 1785, 1785, 3260]], "test": "valid"}
{"id": "tlBczy", "name": "3D Wavelet Noise", "author": "blackle", "description": "An attempt to generalize https://www.shadertoy.com/view/wsBfzK to 3 dimensions and distort an SDF.", "tags": ["noise"], "likes": 34, "viewed": 722, "published": "Public API", "date": "1594676976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<5.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        //random rotation in 3d. the +.1 is to fix the rare case that g == vec3(0)\n        //https://suricrasia.online/demoscene/functions/#rndrot\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nvec3 distorted_p;\nfloat scene(vec3 p) {\n    //different noise for each dimension\n    p.x += WaveletNoise(p/2., iTime*3., 1.15)*.3;\n    p.y += WaveletNoise(p/2.+10., iTime*3., 1.15)*.3;\n    p.z += WaveletNoise(p/2.+20., iTime*3., 1.15)*.3;\n    distorted_p = p;\n    return box(p,vec3(1))-.3;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.2,uv));\n    vec3 init = vec3(-7.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 250 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam*.9;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 local_coords = distorted_p;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.05,.05,scene(p+vec3(.05)/sqrt(3.)));\n    float tex = WaveletNoise(local_coords*3., 0., 1.5)+.5;\n    float diff = mix(length(sin(n*2.)*0.5+0.5)/sqrt(3.),ss,.7)+.1;\n    float spec = length(sin(r*4.)*0.5+0.5)/sqrt(3.);\n    float specpow = mix(3.,10.,tex);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n    vec3 col = vec3(0.7,0.2,0.4)*diff + pow(spec,specpow)*frens;\n    float bgdot = length(sin(cam*3.5)*0.4+0.6)/sqrt(3.);\n    vec3 bg = vec3(.2,.2,.3) * bgdot + pow(bgdot, 10.)*2.;\n    fragColor.xyz = hit ? col : bg;\n    fragColor = sqrt(fragColor);\n    fragColor *= 1.- dot(uv,uv)*.6;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBczy.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 342, 387, 1047], [1049, 1049, 1070, 1070, 1102], [1104, 1104, 1131, 1131, 1215], [1235, 1235, 1256, 1297, 1508], [1510, 1510, 1529, 1529, 1645], [1647, 1647, 1704, 1704, 3131]], "test": "valid"}
{"id": "tlByDK", "name": "v3Waves.glsl", "author": "jorge2017a1", "description": "///source code of ShaderSketches", "tags": ["v3wavesglsl"], "likes": 2, "viewed": 68, "published": "Public", "date": "1595382794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n\nfloat wave(vec2 coord)\n{\n    float interval = iResolution.x * 0.04;\n    vec2 p = coord / interval;\n\n    float py2t = 0.112 * sin(iTime * 0.378);\n    float phase1 = dot(p, vec2(0.00, 1.00)) + iTime * 1.338;\n    float phase2 = dot(p, vec2(0.09, py2t)) + iTime * 0.566;\n    float phase3 = dot(p, vec2(0.08, 0.11)) + iTime * 0.666;\n\n    float pt = phase1 + sin(phase2) * 3.0;\n    pt = abs(fract(pt) - 0.5) * interval * 0.5;\n\n    float lw = 2.3 + sin(phase3) * 1.9;\n    return saturate(lw - pt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = vec3(wave(fragCoord.xy));\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 53], [57, 57, 81, 81, 549], [551, 551, 608, 608, 656]], "test": "valid"}
{"id": "tlByDm", "name": "Furry carpet", "author": "ruojake", "description": "Made a funny noise. Can't think of a use for this right now but I guess it looks kinda cool in its own right.", "tags": ["noise"], "likes": 4, "viewed": 273, "published": "Public API", "date": "1594763951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (CC BY 4.0) Kristian Sivonen 2020\n\nfloat hash13(vec3 p)\n{\n    p = fract(p * vec3(3.131, 5.411, 4.321));\n    p += dot(p.yzx, p + 51.23);\n\treturn fract(p.x*p.y*p.z);\n}\n\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * vec3(3.131, 5.411, 4.321));\n    p.xy += dot(p.yzx, p + 51.23);\n    p.z = dot(p.xy, vec2(2.13, 5.21));\n    return fract(p*p);\n}\n\nfloat hair(vec3 p, vec3 i, float t)\n{\n    float h = hash13(i);\n    float dir = dot(p , hash33(i) * 2. - 1.);\n    return sin(dir * (5. + sin(h * 431.52) * 3.) + t);\n}\n\nconst vec2 o = vec2(1.,0.);\n\nfloat noise(vec3 p, float t)\n{\n    vec3 i = floor(p);\n    vec3 f = smoothstep(0.,1.,p-i);\n    return \n        mix(\n            mix(\n                mix(hair(p,i,t),hair(p,i+o.xyy,t),f.x),\n                mix(hair(p,i+o.yxy,t),hair(p,i+o.xxy,t),f.x),\n                f.y),\n            mix(\n                mix(hair(p,i+o.yyx,t),hair(p,i+o.xyx,t),f.x),\n                mix(hair(p,i+o.yxx,t),hair(p,i+o.xxx,t),f.x),\n                f.y),\n            f.z);\n}\n\nfloat fbm(vec3 p, float t)\n{\n\tfloat res = 0.;\n    for (float i = 1.; i < 32.; i += i)\n    {\n    \tres += noise(p*i,t*i) / i;\n    }\n    return res * .25 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 p = vec3(uv * 20., iTime * .125);\n\n    float noise = fbm(p, iTime * .5);\n    \n    vec3 col = mix(vec3(0.), vec3(.8, .5, .3), noise);\n    \n    // lazy, grainy lighting\n    p.z = noise;\n    vec3 n = normalize(cross(dFdx(p), dFdy(p)));\n    col += smoothstep(.2, 1., dot(n, normalize(vec3(-.4, .5, .8)))) * vec3(.04, .03, .05);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByDm.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[38, 38, 60, 60, 168], [170, 170, 191, 191, 333], [335, 335, 372, 372, 500], [531, 531, 561, 561, 985], [987, 987, 1015, 1015, 1145], [1147, 1147, 1204, 1204, 1611]], "test": "valid"}
{"id": "tlByDR", "name": "Fractal vines", "author": "jarble", "description": "These strange hollow structures were created using a modified version of a [url=https://www.shadertoy.com/view/wtSyDR]\"vine forest.\"[/url]", "tags": ["3d", "raymarching", "fractal", "vines"], "likes": 2, "viewed": 173, "published": "Public API", "date": "1594091275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    //p += p.yzx;\n    p = cos(p/size1);\n    p = (cos(p/vec3(length((p/30.0)))))*size1;\n    return size-length(p);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    for(float i = 9.0; i < 729.0; i *= 9.0){\n    \t//float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*scale*40.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 621, 639, 737], [739, 739, 763, 763, 1106], [1108, 1108, 1136, 1136, 1284], [1287, 1708, 1799, 1799, 2105], [2120, 2374, 2439, 2439, 2571], [2573, 2662, 2691, 2691, 3001], [3003, 3495, 3635, 3635, 4245], [4247, 4617, 4702, 4702, 5049], [5051, 5378, 5427, 5462, 5593], [5595, 5595, 5652, 5652, 6748]], "test": "valid"}
{"id": "tlByDw", "name": "Wax on Dope", "author": "blackle", "description": "my attempt to recreate dope on wax during the final of a shader showdown. took 25 minutes and I'm just happy to have made ferris smile <:", "tags": ["livecode"], "likes": 13, "viewed": 291, "published": "Public API", "date": "1594497268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat malboge(vec3 p) {\n  return dot(sin(p), cos(p));\n}\n\nfloat box(vec3 p, vec3 d) {\n  p = abs(p)-d;\n  return length(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0.,k-abs(b-a))/k;\n  return min(a,b) - h*h*h*k/6.;\n}\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(vec3(0),vec3(k)-abs(b-a))/k;\n  return min(a,b) - h*h*h*k/6.;\n}\n\nfloat scene(vec3 p) {\n  p = erot(p, vec3(0,0,1), sin(p.z*10.)/5.*sin(iTime)/2.);\n  vec3 p2 = p;\n  p2.z += malboge(vec3(p.xy*10.+iTime/4.,0))*.02;\n  p2.z += malboge(erot(vec3(p.xy*4.+iTime/2.,0),vec3(0,0,1),.4))*.06;\n  p2.z += malboge(erot(vec3(p.xy*20.+iTime/2.,0),vec3(0,0,1),.8))*.01;\n  \n  p += malboge(p*20.)*.005;\n  p += malboge(erot(p,normalize(vec3(1,2,3)),.5)*8.)*.01;\n  p += malboge(erot(p,normalize(vec3(3,2,1)),.5)*30.)*.005;\n  float bx = box(p2,vec3(1,1,.3))-.05;\n  p-=vec3(0,0,abs(sin(iTime))*.7+.5);\n  p = erot(p,normalize(vec3(1,2,3)),iTime);\n  float sph = length(-smin(.2-abs(p),vec3(.15),.1)  )-.18;\n  return smin(bx,sph,.5);\n}\n\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize( scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2])  ));\n}\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvec3 skycol(vec3 p) {\n  \n  float s1 = length(sin(p*2.)*.5+.5)/sqrt(3.);\n  float s2 = length(sin(p*3.)*.5+.5)/sqrt(3.);\n  return pow(vec3(.2,0.1,0.4)*s1 + vec3(.4,0.1,.2)*s2,vec3(4)) + pow(max(dot(p,normalize(vec3(1))),0.),50.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  vec3 cam = normalize(vec3(1.5/*+fract(iTime/60.*26.*6.)/10.*/,uv));\n  vec3 init = vec3(-5,0,.3);\n  \n  float yrot = .6 + sin(iTime*.3)*.2;\n  float zrot = iTime/3.;\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  \n  \n  vec3 p =init;\n  bool hit = false;\n  vec3 atten = vec3(1);\n  for (int i = 0; i< 150 && !hit; i++) { \n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    \n  float thing = fract(dot(vec3(1),p+iTime/10.));\n    if (hit && thing < .5) {\n      hit = false;\n      dist = .1;\n      vec3 n = norm(p);\n      atten  *= (1.-abs(dot(n,cam))*.97)*vec3(0.9,0.7,0.5);\n      cam = reflect(cam,n);\n    }\n    p += cam *dist;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n  float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n  float fres = 1. - abs(dot(n,cam))*.98;\n  vec3 wax = vec3(.9)*diff + pow(spec,10.)*fres;\n  mat3 dsat = mat3(.4)+mat3(vec3(.2),vec3(.2),vec3(.2));\n  vec3 dope = vec3(0.6,0.25,0.1)*spec*spec*spec*2. + pow(spec,20.)*fres*2.;\n  float thing = fract(dot(vec3(1.),p+iTime/10.));\n  vec3 col = mix(dope,wax,step(.5,thing));\n  fragColor.xyz = dsat*dsat*sqrt(hit ? col*atten : skycol(cam)*atten);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByDw.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[195, 195, 233, 233, 293], [295, 295, 318, 318, 350], [352, 352, 379, 379, 455], [457, 457, 496, 496, 564], [565, 565, 601, 601, 679], [681, 681, 702, 702, 1324], [1327, 1327, 1346, 1346, 1461], [1463, 1463, 1496, 1496, 1661], [1663, 1663, 1684, 1684, 1892], [1894, 1894, 1951, 1951, 3289]], "test": "valid"}
{"id": "tlByRc", "name": "Connected Dots", "author": "PinetreeDev", "description": "connected dots with a crt effect.\nThanks to everyone in the comments for the discussion and help about the crt effect.", "tags": ["crt", "dots", "hypnotizing", "relaxing"], "likes": 8, "viewed": 191, "published": "Public", "date": "1594943112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define T (iTime)\n\n#define STRIPES_AMOUNT 435.2\n\nfloat DistanceLine(vec2 p, vec2 a, vec2 b)\n{\n \tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba*t);\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n\tfloat d = DistanceLine(p, a, b);\n    float m = S(.01, .0, d - .001);\n    \n    // if the length of the line segment is bigger han 1.2 = invisible\n    // .8 above fades in\n    m *= S(1.2, .8, length(a - b));\n    return m;\n}\n\nfloat Rnd(vec2 p)\n{\n    p = fract(p * vec2(284.4, 931.5));\n    p += dot(p, p + 24.5);\n    \n    return fract(p.x * p.y);\n}\n\nvec2 RndPoint(vec2 p)\n{\n    // X coordinate\n\tfloat n = Rnd(p);\n    // X & Y\n    return vec2(n, Rnd(p + n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    // Get a noise x, y value\n    vec2 n = RndPoint(id + offset) * T;\n    \n    return offset + sin(n) * .4;\n}\n\nfloat Dots(vec2 uv)\n{\n   \tvec2 grid = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    float m = 0.0;\n\tvec2 p[9];\n    \n    int i = 0;\n    for(float y= -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x<= 1.0; x++)\n        {\n        \tp[i++] = GetPos(id, vec2(x,y)); \n        }\n    }\n    \n    // Think of it as a matrix\n    // 0 1 2\n    // 3 4 5\n    // 6 7 8\n    for(int i =0; i<9; i++)\n    {\n    \tm += Line(grid, p[4], p[i]);\n        \n        vec2 j = (p[i] - grid) * 20.0;\n        float sparkle = 1./dot(j, j);\n        m += sparkle;\n    }\n    // Then we connect the 4 missing connections from this group\n    m += Line(grid, p[1], p[3]);\n    m += Line(grid, p[1], p[5]);\n    m += Line(grid, p[5], p[7]);\n    m += Line(grid, p[7], p[3]); \n\t\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // Thanks jaszunio15 for the help in the crt effect\n    vec2 uv = ((fragCoord - mod(fragCoord, vec2(3,4))) - .5*iResolution.xy)/iResolution.y;\n\n\tuv *= .5;\n\tfloat m = .0;    \n    vec2 grid = fract(uv) - .5;\n\t\n    // 4 layers of dots\n    for (float i = .0; i < 1.; i += 1./3.)\n    {\n        float z = fract(i + T * .01);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0., .2, z) * S(1., .6, z);\n        m += Dots(uv * size + i * 50.) * fade;\n    }\n    vec3 col = vec3(m);\n\t//col.rg = id * .2;\n    vec3 base = sin(T * vec3(.45, .123, .542)) * .4 + .6;\n    col *= base;\n    //if (grid.x > .48 || grid.y > .48) col = vec3(1.0, 0.0, 0.0);\n    \n    // Postprocess crt effect (is there a way to do this without the if statements?)\n    //int reminder = int(fragCoord.x) % 3;\n\t//if (reminder == 0) col.gb *= 0.0;\n\t//else if (reminder == 1) col.rb *= 0.0;\t\n\t//else col.rg *= 0.0;\n        \n\t//if (int(fragCoord.y) % 4 == 0) col *= 0.0;\n    // same thing but without if statements\n    col *= step(0.9, fract((fragCoord.x + vec3(0.499, 1.499, 2.499)) * 0.3333));\n\n    // ----------------------------------------\n        \n    //col = pow(col, vec3(.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 114, 114, 243], [245, 245, 281, 281, 504], [506, 506, 525, 525, 627], [629, 629, 652, 672, 738], [740, 740, 775, 805, 885], [887, 887, 908, 908, 1648], [1650, 1650, 1707, 1813, 2976]], "test": "valid"}
{"id": "tlByRG", "name": "menger-sponge-va-007", "author": "jorge2017a1", "description": "menger-sponge-va-007", "tags": ["mengerspongeva007"], "likes": 2, "viewed": 33, "published": "Public", "date": "1594649615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n\n\n\n#define PI2 6.28318530717\n#define PI 3.14159265358979323846264\n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//--------------------------------------------\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n//-------------------------------------    \n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.33;\n\t\n    \n    \n    float dist= sdBox( p, vec3(5.5, 0.5+sin(2.0*cos(fract(3.0))),4.0)  );\n    \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(5.0+2.0*cos(time), 0.25, 5.0+ 1.0*sin(time));\n    \n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 585, 585, 616], [618, 618, 649, 649, 740], [743, 743, 766, 766, 903], [905, 905, 935, 935, 1072], [1075, 1176, 1199, 1199, 1334], [1336, 1336, 1362, 1362, 1419], [1421, 1421, 1461, 1461, 1495], [1498, 1498, 1545, 1545, 1578], [1580, 1627, 1663, 1663, 1780], [1782, 1782, 1818, 1818, 1936], [1938, 2011, 2029, 2029, 2298], [2358, 2358, 2387, 2387, 2575], [2577, 2577, 2618, 2618, 2794], [2796, 2796, 2837, 2837, 2989], [2991, 2991, 3012, 3012, 3142], [3144, 3144, 3171, 3171, 3421], [3423, 3423, 3480, 3480, 3952]], "test": "valid"}
{"id": "tlffzH", "name": "hmm", "author": "CoolerZ", "description": "Trying out the band limited cosine from https://www.shadertoy.com/view/WtScDt", "tags": ["sound", "audio", "palette", "visualizer"], "likes": 2, "viewed": 96, "published": "Public", "date": "1596034457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trying out the band limited cosine from https://www.shadertoy.com/view/WtScDt\n#define CRAZINESS 1\n\nconst float PI = radians(180.);\nconst float PI2 = 2.*PI; // radians(360) might be 0 instead of 2*PI.\n\n#define Z(X) (.5+.5*(X))\n\n/*\nvec3 get_color(float t)\n{\n    const float F = PI2;\n    const float A = .5;\n    vec3 col = vec3(1,0,0)*Z(cos(F*t)) + vec3(0,1,0)*Z(cos(2.*F*t)) + vec3(0,0,1)*Z(cos(4.*F*t));\n    return col;\n}\n*/\n\n/*\nvec3 get_color(float t)\n{\n    const float F = PI2;\n    const float A = .5;\n    vec3 col = vec3(1,0,0)*Z(cos(F*t)) + vec3(0,1,0)*Z(cos(F*t-PI2/3.)) + vec3(0,0,1)*Z(cos(F*t-2.*PI2/3.));\n    return col;\n}\n*/\n\n// box-filted cos(x)\nfloat fcos(float x)\n{\n    float w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool mode = false;\nfloat mcos(float x){return mode ? cos(x) : fcos(x);}\n\nvec3 get_color(float t)\n{\n    const float F = PI2;\n    const float A = .5;\n    vec3 col = vec3(1,0,0)*Z(mcos(F*t)) + vec3(0,1,0)*Z(mcos(F*t-PI2/3.)) + vec3(0,0,1)*Z(mcos(F*t-2.*PI2/3.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = vec3(uv,0.);\n    //vec2 xy = uv;\n    vec2 xy = 2.*uv/dot(uv,uv);\n    xy.x += 20.*dot(normalize(uv), vec2(cos(iTime),sin(iTime)));\n    xy.x += 20.*dot(normalize(uv), vec2(0,1));\n    #if CRAZINESS\n    //float freq = .5+.5*dot(normalize(uv), vec2(1,0));\n    float freq = (atan(uv.y,uv.x)+PI)/PI2;\n    float amp = texture(iChannel0,vec2(freq,.25)).x;\n    xy *= amp;\n    //xy += cos(length(xy));\n    //xy -= cos(amp*length(xy.x));\n    //xy += cos(4.*amp*length(xy.y));\n    //xy -= cos(8.*amp*length(xy.x));\n    #endif\n    xy += iTime;\n    float threshold = sin(iTime)*iResolution.x/iResolution.y;\n    mode = uv.x < threshold;\n    vec3 col = min(get_color(xy.x),get_color(xy.y));\n    col = mix(col, vec3(0.), 1.-smoothstep(0.,.01, abs(uv.x-threshold)));\n    if(uv.y < -.9)col = get_color(uv.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mt2Gzt", "previewfilepath": "https://soundcloud.com/redphantom2/ektrix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/redphantom2/ektrix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlffzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[637, 658, 679, 679, 843], [907, 907, 927, 927, 959], [961, 961, 986, 986, 1165], [1167, 1167, 1224, 1274, 2281]], "test": "error"}
{"id": "tljcRd", "name": "Sphere over water", "author": "vipiao", "description": "Animated water and sphere over water", "tags": ["reflection", "water", "animated"], "likes": 10, "viewed": 284, "published": "Public API", "date": "1595215987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\n# define PI 3.1415926538\n/******************************************************************************/\n\nfloat waterFunction(in vec3 pos, in float time){\n\tconst int size = 6;\n    vec3 vecs[size] = vec3[](\n        vec3(1,2, 0.2),\n        vec3(0.5,0.5, 0.1),\n        vec3(-1.,0.2, 0.1),\n        vec3(0.,-0.5, 0.5),\n        vec3(2.,-2., 0.01),\n        vec3(-2.,5., 0.01)\n    );\n    float waveHeight = 0.;\n    for(int i=0; i<size; i++) {\n        // The speed of waves on water is independent on amplitude or wavelength.\n    \twaveHeight += sin(pos.x*vecs[i].x+pos.z*vecs[i].y+time*length(vecs[i].xy))*vecs[i].z;\n    }\n    return waveHeight;\n}\n\nfloat sdWater(in vec3 pos){\n    float waveHeight = waterFunction(pos, iTime);\n    \n\tfloat heightDiff = pos.y - waveHeight;\n    const float maxSlope = 1.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    float maxWaterHeight = 0.91; // 0.2+0.1+0.1+0.5+0.01+0.0. See waterFunction(.).\n    return max(nextDist, pos.y-maxWaterHeight);\n}\n\nvoid sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){\n\tsd = sdWater(pos);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdWater(pos - e.xyy),\n    \tsdWater(pos - e.yxy),\n    \tsdWater(pos - e.yyx)\n    ));\n}\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\n\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, out float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\nfloat marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    inout float dist, in float maxDist, in float minDist, out float nearest,\n    inout int numSteps, in int maxNumSteps,\n    inout vec3 color, out vec3 normal, out int returnCode\n){\n    float colorFrac = 1.;\n    float transparency = 0.75;\n    vec3 backgroundColor = vec3(0.1,0.2,0.5);\n    vec3 sphereColor = vec3(0,0,0);\n    vec3 waterColor = vec3(0,0,0.5);\n    vec3 lightDir = normalize(vec3(1,1,1));\n    nearest = maxDist;\n    \n    vec3 spherePosition = vec3(0,0,20);\n    spherePosition.y = waterFunction(spherePosition, iTime-0.5)+5.;\n    float sphereRadius = 4.;\n    for(int i=0; i<maxNumSteps; i++) {\n        float sdToWater = sdWater(pos);\n        float sdToSphere = sdSphere(pos, spherePosition, sphereRadius);\n        float sd = min(sdToWater, sdToSphere);\n        if(sd < nearest){\n        \tnearest = sd;\n        }\n        \n        numSteps++;\n        if(dist + sd + minDist > maxDist){\n            // Fill the remaining color.\n    \t\tcolor = mix(color, backgroundColor, colorFrac);\n            sd = maxDist-dist-sd-minDist;\n            dist += sd;\n            pos += dir*sd;\n            \n            returnCode = TOO_FAR;\n        \treturn sd;\n        }\n        if(sd <= minDist){\n            if(sdToWater < sdToSphere){\n            \tsdWaterNormal(/*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*inout float sd=*/sd);\n                color = mix(color, waterColor*dot(lightDir, normal), colorFrac);\n                colorFrac *= transparency;\n                if(dot(normal, dir) < 0.){\n                    dir = reflect(dir, normal);\n                    sd = max(sd, minDist*2.);\n                }\n            }else{\n            \tsdSphereNormal(\n                    /*in vec3 pos=*/pos, /*in vec3 center=*/spherePosition, /*in float radius=*/sphereRadius,\n                    /*inout vec3 normal=*/normal, /*out float sd=*/sd\n                );\n                color = mix(color, sphereColor*dot(lightDir, normal), colorFrac);\n                colorFrac *= transparency;\n                \n                if(dot(normal, dir) < 0.){\n                    dir = reflect(dir, normal);\n                    sd = max(sd, minDist*2.);\n                }\n            }\n        }\n        dist += sd;\n        pos += dir*sd;\n    }\n    \n    // Fill the remaining color.\n    color = mix(color, backgroundColor, colorFrac);\n    \n    //\n    returnCode = TOO_MANY_STEPS;\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 camPos = vec3(0.2, 3., 0.);\n    vec3 viewDir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    vec3 col = vec3(0.);\n    vec3 pos = camPos;\n    float dist = 0.;\n    float maxDist = 1000.*100.;\n    float minDist = 0.01;\n    int numSteps = 0;\n    int maxNumSteps = 400;\n    vec3 normal;\n    int returnCode;\n    float nearest;\n    \n    marchWorld(\n        /*vec3 pos=*/camPos, /*vec3 dir*/viewDir,\n        /*float dist=*/dist, /*float maxDist=*/maxDist, /*float minDist=*/minDist, /*out float nearest=*/nearest,\n        /*int numSteps=*/numSteps, /*int maxNumSteps=*/maxNumSteps,\n        /*vec3 color=*/col, /*vec3 normal=*/normal, /*int returnCode=*/returnCode\n    );\n    \n    // Mist.\n    //col = mix(col, vec3(0,0,1), 1. / (1. + exp(-float(numSteps)*0.1 + float(maxNumSteps) - 380.)));\n    \n    //col = vec3(dist/100.);\n    \n    // Ambient occlusion.\n    float factor = float(numSteps)/float(maxNumSteps);\n    col = mix(col, vec3(0.5,0.5,0.7), factor);\n    \n    float fieldPace = 0.2;\n    if(mod(iTime*fieldPace,4.0) <= 1.){\n        float fieldFrac = mod(iTime*fieldPace,1.0);\n        float fieldSmooth = 30.*fieldFrac+5.;\n        float depth = (float(maxNumSteps)+fieldSmooth*2.)*fieldFrac-fieldSmooth*2.;\n        float field = max(fieldSmooth-float(abs(numSteps - int(depth))), 0.)/fieldSmooth;\n        field *= (1.-fieldFrac);\n    \tcol.g += field;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljcRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[710, 710, 737, 737, 1064], [1066, 1066, 1133, 1133, 1306], [1308, 1308, 1369, 1369, 1411], [1413, 1413, 1512, 1512, 1753], [1755, 1755, 1990, 1990, 4187]], "test": "error"}
{"id": "tljcRW", "name": "Feathers in the Wind", "author": "BigWIngs", "description": "The end result of a YouTube tutorial I made.", "tags": ["tutorial", "wind", "feather", "feathers", "artofcode"], "likes": 35, "viewed": 803, "published": "Public API", "date": "1593881406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Feathers in the Wind - by Martijn Steinrucken aka BigWings 2020\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// An effect created for a YouTube tutorial. You can watch it here:\n// Part 1: https://youtu.be/68IFmCCy_AM\n// Part 2: https://youtu.be/hlM940IqpRU\n\n#define S smoothstep\n#define T (iTime*.5)\n\nmat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Feather(vec2 p) {\n\tfloat d = length(p-vec2(0,clamp(p.y, -.3, .3)));\n    float r = mix(.1, .03, S(-.3, .3, p.y));\n    float m = S(.01, .0, d-r);\n    \n    float side = sign(p.x);\n    float x = .9*abs(p.x)/r;\n    float wave = (1.-x)*sqrt(x) + x*(1.-sqrt(1.-x));\n    float y = (p.y-wave*.2)*80.+side*56.;\n    float id = floor(y+20.);\n    float n = fract(sin(id*564.32)*763.); \n    float shade = mix(.5, 1., n);\n    float strandLength = mix(.7, 1., fract(n*34.));\n    \n    float strand = S(.4, .0, abs( fract(y)-.5 )-.35);\n    strand *= S(.1,-.2, x-strandLength);\n    \n    d = length(p-vec2(0,clamp(p.y, -.45, .1)));\n    float stem = S(.01,.0, d+p.y*.025);\n    \n    return max(strand*m*shade, stem);\n}\n\nvec3 Transform(vec3 p, float angle) {\n\tp.xz *= Rot(angle);\n    p.xy *= Rot(angle*.7);\n    \n    return p;\n}\n\nvec4 FeatherBall(vec3 ro, vec3 rd, vec3 pos, float angle) {\n\t\n    vec4 col = vec4(0);\n    \n    float t = dot(pos-ro, rd);\n    vec3 p = ro + rd * t;\n    float y = length(pos-p);\n    \n    if(y<1.) {\n        float x = sqrt(1.-y*y);\n        vec3 pF = ro + rd * (t-x) - pos; // front intersection\n        float n = pF.y*.5+.5;\n        \n        pF = Transform(pF, angle);\n        vec2 uvF = vec2(atan(pF.x, pF.z), pF.y); // -pi<>pi, -1<>1\n        uvF *= vec2(.25,.5);\n        float f = Feather(uvF);\n        vec4 front = vec4(vec3(f), S(0., .6, f));\n        \n        front.rgb *= n*n;\n        \n        vec3 pB = ro + rd * (t+x) - pos; // back intersection\n        n = pB.y*.5+.5;\n        pB = Transform(pB, angle);\n        vec2 uvB = vec2(atan(pB.x, pB.z), pB.y); // -pi<>pi, -1<>1\n        uvB *= vec2(.25, .5);\n        float b = Feather(uvB);\n        vec4 back = vec4(vec3(b), S(0., .6, b));\n        back.rgb *= n*n;//*.5+.5;\n        \n    \tcol = mix(back, front, front.a);\n    }\n    col.rgb = sqrt(col.rgb);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy -.5;\n    \n    vec3 bg = vec3(.2, .2, .7)*(uv.y+.5)*2.5;\n    bg += vec3(.8, .6, .4)*(-uv.y+.5);\n    \n    vec4 col = vec4(bg, 0);\n\t\n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv, 1));\n   \n    for(float i=0.; i<1.; i+=1./80.) {\n        \n        float n = fract(sin(i*564.3)*4570.3);\n        float x = mix(-8., 8., fract(fract(n*10.)+T*.1))+M.x;\n        float y = mix(-2., 2., n)+M.y;\n        float z = mix(5., 0., i);\n        float a = T+i*563.34;\n        \n    \tvec4 feather = FeatherBall(ro, rd, vec3(x, y, z), a);\n        \n        feather.rgb = mix(bg, feather.rgb, mix(.3, 1., i));\n        feather.rgb = sqrt(feather.rgb);\n        \n        col = mix(col, feather, feather.a);\n    }\n    \n    col = pow(col, vec4(.4545)); // gamma correction\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljcRW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[403, 403, 422, 422, 478], [480, 480, 503, 503, 1182], [1184, 1184, 1221, 1221, 1290], [1292, 1292, 1351, 1351, 2317], [2319, 2319, 2376, 2376, 3252]], "test": "valid"}
{"id": "tljcWh", "name": "Paintball Multi Light", "author": "Mischawake", "description": "Trying out multiple light sources for generating diffuse and specular.", "tags": ["metaballs"], "likes": 13, "viewed": 240, "published": "Public", "date": "1594269728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nconst int nBalls = 40;\nconst int nLights = 4;\nconst int numColors = 3; //max 4\nconst float lightZ = -0.2;\n\nfloat random (float i){\n \treturn fract(sin(float(i)*43.0)*4790.234);   \n}\n\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.1);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    vec3(255./255., 77./255., 0./255.),\n    vec3(10./255., 84./255., 255./255.),\n    vec3(255./255., 246./255., 0./255.),\n    vec3(0./255., 192./255., 199./255.)\n   \n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n    vec3(230./255., 25./255., 56./255.),\n    vec3(230./255., 144./255., 25./255.),\n    vec3(0./255., 199./255., 152./255.),\n    vec3(10./255., 165./255., 255./255.)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n   \tint i;\n    \n    //settings to play with!\n    float threshold = 1.0;\n    float shadowIntensity = 0.5; \n    float specularIntensity = 0.75;\n    float specularPower = 300.0;\n    float rimIntensity = 3.; //2\n    float aoIntensity = 0.75; //75\n    float ambientBrightness =  0.5 + 0.5 * uv.y;\n    float lightFalloff = 0.5;\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.07;\n    float rf = 0.005;\n    float jiggle = sin(iTime*(2.0)) * 0.0125;\n    \n    float speed = 0.3;\n    \n    vec4[nBalls] balls;\n    vec4[nLights] lights;\n    \n    for( i = 0; i < nBalls; i++ ){\n    \n        float per = float(i)/float(nBalls);\n        float r = random( per * 7.0 + 0.32);\n        float r2 = random( per * 11.0 + 0.87 );\n        float r3 = random( per * 19.0 + 0.121 );\n        float time = iTime + r * 11. + r2 * 21.;\n        float x = 0.5 + sin(time*speed * (0.5 + 0.5 * r2))*(0.1 + 0.9 * r);\n        float y = 0.5 + cos(time*speed * (0.5 + 0.5 * r3))*(0.1 + 0.9 * r2);\n \n        int color = i % numColors;\n        float rd = rad + 0.9 * rad * sin(iTime*0.2 + r*13.0)*r;\n        \n        balls[i] = vec4( x, y, rd, color );\n        \n    }\n    \n    for( i = 0; i < nLights; i++ ){\n    \n        float per = float(i)/float(nBalls);\n        float r = random( per * 21.0 + 17.0 );\n        float r2 = random( per * 31.0 + 13.0 );\n        float r3 = random( per * 41.0 + 3.0 );\n        float time = iTime + r * 21. + r2 * 11.;\n        float x = 0.5 + sin(time*speed * (0.5 + 0.5 * r2))*(0.1 + 0.9 * r);\n        float y = 0.5 + cos(time*speed * (0.5 + 0.5 * r3))*(0.1 + 0.9 * r2);\n \n        lights[i] = vec4( x, y, 0.01, 1.0 );\n        \n    }\n\n    \n    int ballCount = nBalls;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] shaders = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    \n\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv);  \n        accumulators[idx] += inf;\n        shaders[idx] += calcNormal( balls[i], uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    vec3 normal = normalize(shaders[maxIdx]);\n \n      \n  \n    //basecolor\n    vec3 color = baseColor;\n    vec3 ambientColor = vec3(ambientBrightness);\n    if( rainbowMode )\n        ambientColor = avgColor * ambientBrightness;\n   \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    color += vec3(1.0) * rimIntensity * pow (rim, 2.0);\n    \n    color = color * (1.0 - shadowIntensity);\n    \n    for( i = 0; i < nLights; i++ )\n    {\n        vec4 light = lights[i];\n        vec3 lightDir = normalize( vec3(light.xy, lightZ) - vec3( uv, 0.0 ) ); \n        float intensity = min( 1.0, (lightFalloff * light.w) / pow( distance( light.xy, uv ), 2.0 ));\n        \n        //diffuse\n        float lighting = max(0.,dot( -normal, lightDir) );\n        lighting *= intensity;\n        color += max( (baseColor * lighting) - color, vec3(0.) );\n  \n        // specular blinn phong\n        vec3 dir = normalize(lightDir + vec3(0,0,-1.0) );\n        float specAngle = max(dot(dir, -normal), 0.0);\n        float specular = pow(specAngle, specularPower);\n        color += vec3(1.0) * specular * specularIntensity * intensity;\n    }\n    \n   \n    \n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor, color, smo);\n    \n    \n    for( i = 0; i < nLights; i++ )\n    {\n        vec4 light = lights[i];\n    \tfloat lightIntensity = calcInfluence( light, uv );\n       \tcolor += pow(lightIntensity,0.5) * 1.0 * light.w;    \n    }\n    \n                    \n    \n    fragColor = vec4( color, 1.0 );\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 205, 205, 255], [258, 258, 300, 300, 397], [399, 399, 438, 438, 483]], "test": "error"}
{"id": "tljczd", "name": "strange elephant ", "author": "CyanMARgh", "description": "Этот шейдер - анимированное представление фигурки перед печатью. (по аналогии с simple ufo)", "tags": ["raymarching", "figure"], "likes": 6, "viewed": 90, "published": "Public", "date": "1595176782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPos = vec3(0., .6, -5.5);\nfloat softShadow = 10.;\nfloat depthmax = 40.; \nconst float eps = 1e-4;\nvec3 backcol = vec3(1.,1.,1.)*1.;\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n//SDF operations\n//colored\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//uncolored\nfloat un(float d1, float d2){\n    return d1<d2?d1:d2;\n}\nfloat dif(float d1, float d2){\n    d2*=-1.;\n    return d1>d2?d1:d2;\n}\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//additioanal operations\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//SDF\nfloat sphere(vec3 pos){\n    return length(pos);\n}\nfloat plane(vec3 n, vec3 pos){\n    return dot(pos, n);\n}\nfloat capsule(vec3 a, vec3 b, float r1, float r2, vec3 p){\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\t\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                           return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylinder(vec3 a, vec3 b, float r, vec3 p){\n    p-=a;b-=a;\n    float k = dot(b,p)/dot(b,b);\n    float d1 = length(b*k-p)-r;\n    if(k>0.&&k<1.){\n        return d1;\n    }else{\n        float d2 = (abs(k-.5)-.5)*length(b);\n        if(d1>0.){            \n            return sqrt(d1*d1+d2*d2); \n        }else{\n            return d2;\n        }\n    }\n}\n//color functions\nvec3 checkerboard(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return vec3(1.)*((d.x+d.y+d.z)%2==0?1.:.8);\n}\n//scene SDF\nvec4 map(vec3 p){\n    //\"room\"\n    vec4 d0 = vec4(.9,.9,1.,plane(vec3(0.,1.,0.),p)+1.5);\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(0.,0.,-1.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(1.,0.,0.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,box(vec3(1.,1.,1.),p-vec3(0.,-2.,0.))));\n    d0.xyz *= checkerboard(p);\n\n    p+=vec3(.0,.1,.0);\n    \n    \n    vec4 body = vec4(1.,.7,.2,sphere(p-vec3(.0,-.25,0.))-.7);\n    //head\n    {\n        vec3 p_=p;\n        p_.yz*=ro(-.75);\n\t\tp_.z=abs(p_.z);    \n\t    p_.zy*=ro(.8);\n        p_.z=abs(p_.z);    \n\t    p_.zy*=ro(.4);\n        p_.z=abs(p_.z);    \n\t    p_.zy*=ro(.2);\n\t\tvec4 head = vec4(.8,.9,.3,capsule( vec3(0.,0.,0.), vec3(0.,1.2,0.), .4, .15,p_   ));\n    \tbody = cmix(body, head, .2);\n    }\n    //legs\n    {\n        vec3 p_=p;\n    \tp_.xz=abs(p_.xz);    \n\t    p_.xz*=ro(0.8);\n    \tvec4 leg = vec4(.7,.4,.1, sphere(p_-vec3(.0,-.9,.5))-.3);\n\t    body = cmix(body, leg, .05);\n    }\n    //eye\n\t{\n        vec3 p_=p;\n\t\tp_.x=abs(p_.x);    \n\t    p_.zx*=ro(1.3);\n\n        vec4 lid = vec4(.7,.4,.1, cylinder(vec3(0.,-.2,0.),vec3(0.,-.2,-.6),.3,p_));\n        body = cmix(body, lid, .4);\n        vec4 eye = vec4(1.,1.,1.,sphere(p_-vec3(0.,-.2,-.5))-.35);\n\t\teye = cun(eye, vec4(.2,.2,1.,sphere(p_-vec3(0.,-.2,-.56))-.3));\n\t\teye = cun(eye, vec4(.2,.2,.2,sphere(p_-vec3(0.,-.2,-.615))-.25));\n\n        body = cun(body,eye);\n    }\n    //nose\n    {\n        vec4 nose = vec4(.7,.4,.1, capsule(vec3(0.,.1,-.4),vec3(0.,-.8,-.8),.2,.1,p));\n        vec3 p_ = p;\n        p_.x=abs(p_.x);\n        vec4 tusk = vec4(.8,.8,.8, capsule(vec3(0.,-.1,-.4),vec3(.3,-.6,-.8),.1,.06,p_));\n        \n        body = cmix(body, nose,.1);\n        body = cun(body, tusk);\n    }\n    //cut\n    body = cdif(body, vec4(.8,.6,.1, plane(vec3(0.,1.,0.),p)+.9));\n\td0=cun(d0,body);\n    \n    return d0;\n}\n//normal vector by point\nvec3 norm(vec3 pos){\n    const vec2 e = vec2(eps,0.);\n    float d = map(pos).w;\n    return normalize(vec3(\n        map(pos + e.xyy).w-d,\n        map(pos + e.yxy).w-d,\n        map(pos + e.yyx).w-d\n    ));\n}\n\n//color and length of ray\nvec4 rayCast(vec3 eye, vec3 dir){\n    vec3 pos; float depth=0.,dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n        depth += dist;\n        if (dist < eps){\n            break;\n        }else if(depth>depthmax){\n            depth = depthmax+eps;\n            break;\n        }\n    }\n    rc.w=depth;\n    return rc;\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //direction calculation\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float angle = (1.2+cos(iTime*.4))*.6;\n    eye.xz*=ro(angle);\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n\n    //raymarching\n    vec4 rc = rayCast(eye, dir);\n    float depth = rc.w;\n\n    vec3 pos = eye+dir*depth;\n    vec3 n = norm(pos);\n    pos+=eps*n;\n    \n    vec3 col = rc.xyz;\n    vec3 lighting = vec3(.25);\n\n    if (depth < depthmax){\n\n        // adding 3 point lights and one directional light\n        lighting += getLight(pos, vec3(6., 8., 0.), n, vec3(1.,.9,.9), 15.,false);\n        lighting += getLight(pos, vec3(6., 8., -10.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(-10., 10., -2.), n, vec3(1.,1.,1.), 30.,false);\n        lighting += getLight(pos, vec3(2., 13., -10.), n, vec3(1.,.9,.9), 120.,true);\n        \n        //lighting -= getOcc(pos, n);\n\t\tcol *= lighting;\n    }else{\n        col=backcol;\n    }\n    \n    //compositing color, lighting and fog\n    fragColor = vec4(1.5*log(1.+ col)*exp(-0.003*depth), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 209, 236, 236, 266], [267, 267, 295, 295, 340], [341, 341, 381, 381, 484], [485, 497, 526, 526, 552], [553, 553, 583, 583, 622], [623, 623, 666, 666, 765], [767, 792, 811, 811, 871], [873, 879, 902, 902, 928], [929, 929, 959, 959, 985], [986, 986, 1044, 1044, 1574], [1575, 1575, 1601, 1601, 1688], [1689, 1689, 1737, 1737, 2038], [2039, 2057, 2083, 2083, 2164], [2165, 2177, 2194, 2207, 3977], [3978, 4003, 4023, 4023, 4208], [4210, 4236, 4269, 4269, 4667], [4668, 4699, 4768, 4768, 5175], [5176, 5206, 5237, 5237, 5634], [5636, 5650, 5704, 5733, 6865]], "test": "valid"}
{"id": "tljczV", "name": "Glass Fibre", "author": "_pwd_", "description": "An abstract, glass-looking field", "tags": ["raymarching", "refraction", "noise3d", "reflections", "dust"], "likes": 14, "viewed": 206, "published": "Public", "date": "1594890956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\n//\n// Glass Fibre\n// -> my attempt of an abstract, glass-looking field \n//\n//\n// references\n// \"Glass Field\" by Kali\n// from https://www.shadertoy.com/view/4ssGWr\n// https://www.shadertoy.com/view/XlsGWl\n//\n// Sound via soundcloud - Holon: As far as possible\n//\n// Shane´s sky\n// https://www.shadertoy.com/view/MscXRH        \n//\n// Shane´s mist/dust\n// https://www.shadertoy.com/view/4ddcWl \n//\n// Shane´s electric charge\n// https://www.shadertoy.com/view/4ttGDH    \n//\n//\n\n\n\n#define lightcol1 vec3(2.,.95,.85)\n#define lightcol2 vec3(1.,1.,1.)\n#define offset1 -1.85\n#define offset2 -1.75\n#define att 12.\n\n\nfloat time;\nfloat id;\nvec3 glow;\nvec3 sync;\n\n\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\n\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n\n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        if (t0>t) break; \n        \n        float sDi = length(lp-ro)/120.; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = n3D(ro2)*.65 + n3D(ro2*3.)*.25 + n3D(ro2*9.)*.1;\n\n        float n = c;\n        mist += n*sAtt;\n        \n        t0 += clamp(c*.25, .1, 1.);\n        \n    }\n    \n    return max(mist/48., 0.);\n\n}\n\n\n\n//Smooth min by IQ\nfloat smin( float a, float b )\n{\n    float k = 0.5;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3 rotZ(float a, vec3 v)\n{\n   return vec3(cos(a) * v.x + sin(a) * v.y, cos(a) * v.y - sin(a) * v.x, v.z);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// distance field\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat map(vec3 pos) {    \n\n\n    float t = -iTime;\n   \n    vec3 sp = pos;\n    vec3 np  = pos + vec3( 0.0, 0.0, 5.5);\n \n    t = -iTime;\n    np.z += sin(t) * 3.6;\n\n    \n\tvec3 A=vec3(6.);\n\tvec3 B=vec3(6.);\n\tvec3 p = abs(A-mod(sp,2.0*A));  //tiling fold by Syntopia\n    vec3 p1 = abs(B-mod(np,2.0*B)); //tiling fold by Syntopia\n\n\n\tfloat cyl   = length(p.xy)-.24;\n\tfloat cyl1  = length(p.zy)-.24;\n\tfloat cyl2  = length(p.xz)-.24;\n    \n    float prism = sdHexPrism( p1, vec2(0.75,2.05) );\n\n\tfor (int i=0; i<21; i++)\n\t{\n\n    \tfloat intensity = 1. / ( 1. + pow(abs(prism*att),2.3));\n    \tif(i == 2 && id == 0.) {\n    \t\tglow += vec3(1.,1.,0.) * intensity;\n    \t}\n        \n\t}    \n  \n\treturn min( prism, smin( smin( cyl, cyl1 ), cyl2 ) );\n\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// normals\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,0.001,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tmap(pos+e.yxx)-map(pos-e.yxx),\n\t\t\tmap(pos+e.xyx)-map(pos-e.xyx),\n\t\t\tmap(pos+e.xxy)-map(pos-e.xxy)\n\t\t\t)\n\t);\t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime*.285; \n\n\t\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: uv, ray\n\t//////////////////////////////////////////////////////////////////////////////////////\n\n\tfloat fft = texture(iChannel0, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n    \n\tvec2 uv      = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tuv.y        *= iResolution.y / iResolution.x;\n\tfloat fov    = min(( time*.2+.05),0.6 ); //animate fov at start\n\tvec3 ro      = vec3(cos(time)*12.0,sin(time*.5)*10., time * 18.0);\n    vec3 rd      = normalize(vec3(uv.xy*fov,1.)); \n    rd.z -= length(rd) * 0.86; //lens distort\n    rd = normalize(rd);\n    \n    \n    /*\n    rd.z -= length(rd) * 0.18; //lens distort\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.000001, 0.))));\n    \n    vec2 m = sin(vec2(1.57079632, 0) + iTime/4.);\n    rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);    \n\t*/\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: raymarching params\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n\tfloat total     = 0.5;\n\tfloat distfade  = 1.0;\n\tfloat glassfade = 1.0;\n\tfloat intens    = 1.0;\n\tfloat maxdist   = 120.0;\n\tfloat vol       = 0.0;\n\tvec3 spec       = vec3( 0.0 );\n\t\n\n    \n\n    //////////////////////////////////////////////////////////////////////////////////////        \n    // setup\n    // mouse interaction(s)   \n    ////////////////////////////////////////////////////////////////////////////////////// \n    \n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n    rd = rotate_y(rd,mouse.x * 9.0 + offset2);\n    if( mouse.y != 0. )  rd = rotate_x(rd,mouse.y*9.0+offset1); \n\n    \n    \n    \n    \n    //////////////////////////////////////////////////////////////////////////////////////        \n    // sky based on\n    // Shane´s\n    // https://www.shadertoy.com/view/MscXRH        \n    //////////////////////////////////////////////////////////////////////////////////////  \n    \n    vec3 sky = mix(vec3(0., 0., .5), vec3(0., 0., .7), rd.x*0.5 + 0.5);\n\tsky *= sqrt(sky); \n    vec3 cloudCol = mix(sky, vec3(1, .9, .8), 0.26);\n\n    \n    float ref    = 0.;\n\tvec3 light1  = normalize(vec3( -0.25,  0.25, 0.20 ) );\n\tvec3 light2  = normalize(vec3( -0.25,  -0.15, 0.10 ) );\n\n\n    vec3 p;\n \tfloat d;\n    vec3 preCol = vec3(0.);\n    glow = vec3(.0);\n\n\tfor ( int r=0; r<64; r++ ) {\n\t\t  \n          p = ro + total * rd;\n\t\t  d = map(p);\n\n\t\t  float distfade = exp(-1.5*pow(total/maxdist,1.5));\n\t\t  \n          intens=min(distfade,glassfade);\n\n\t\t// refraction\n\t\tif (d>0.0 && ref>.5) {\n\t\t\tref=0.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(rd,n)<-.5) rd=normalize(refract(rd,n,1./.87));\n\t\t\tvec3 refl=reflect(rd,n);\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.)*intens*.3;\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.)*intens*.3;\n\n\t\t}\n\t\tif (d<0.0 && ref<.05) {\n\t\t\tref=1.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(rd,n)<-.05) rd=normalize(refract(rd,n,.87));\n\t\t\tvec3 refl=reflect(rd,n);\n\t\t\tglassfade*=.45;\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.)*intens*0.3;\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.)*intens*0.3;\n\t\t}\n\t\t\n\t\ttotal+=max(0.001,abs(d)); //advance ray \n\t\tif (total > maxdist) break; \n\n\t\t//vol+=intens; //accumulate current intensity\n\t\tvol+=max(0.,0.5-d)*intens; //glow\n        \n        \n        //////////////////////////////////////////////////////////////////////////////////////        \n        // based on\n        // Shane´s\n        // https://www.shadertoy.com/view/4ttGDH          \n        //////////////////////////////////////////////////////////////////////////////////////          \n        \n        float hi = abs(mod(total/1. + iTime/3., 8.) - 8./2.)*2.;\n        vec3 cCol = vec3(.01, .05, 1)*vol*1./(.0006 + hi*hi*.2);\n        preCol += mix(cCol.yxz, cCol, n3D(p*3.));\n        \n       \n        rd.xy = cos(0.009  *d)*rd.xy + sin(0.009 * d)*vec2(-rd.y, rd.x);\n\n        \n\t}\n    \n    \n    //////////////////////////////////////////////////////////////////////////////////////        \n    // mist/dust based on\n    // Shane´s\n    // https://www.shadertoy.com/view/4ddcWl          \n    //////////////////////////////////////////////////////////////////////////////////////  \n \n\tfloat dust = getMist(ro, rd, vec3(-0.5,  1.5, -0.5), total)*(1. - smoothstep(0., 1., -rd.x - 0.35));//(-rd.y + 1.);\n    \n\n    \n\n\tvol=pow(vol,0.4)*0.12;\n\n\n\tvec3 col=vec3(vol)+vec3(spec)*1.4+vec3(.05);\n    col += glow*0.0065 *sync.r * 0.55;\n\n\n\n\tcol *= min( 1.0, time ); //fade in\n    col *= mix( col, sky, glassfade );\n    col  = mix( col, preCol, 0.000006 );\n\n    col += mix( col, sky, 0.1);\n    //col = mix(col, sky, smoothstep(0., 6.85, total/maxdist));\n    col = mix(col, sky*sky*2., 1. - 1./(1.+ total*total*.00001));//\n \n    \n    // More postprocessing. Adding some very subtle fake warm highlights.\n    vec3 fCol = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), sky, .5);\n    col = mix(fCol, col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.1 + .9);\n\t\n    \t\n    vec3 mistCol = vec3(0, 1.1, 1.9); // Probably, more realistic, but less interesting.\n    col += (mix(col, mistCol, 0.66)*0.46 + col*mistCol*5.)*dust;\n\n\n    \n\t// Vignette\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 0.11);\n\n         \n\tfragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": "XlS3zd", "previewfilepath": "https://soundcloud.com/mark-r-3/as-far-away-as-possible", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mark-r-3/as-far-away-as-possible", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[660, 660, 696, 696, 814], [816, 816, 852, 852, 969], [972, 972, 990, 990, 1300], [1303, 1303, 1365, 1365, 1820], [1824, 1843, 1875, 1875, 1983], [1986, 1986, 2022, 2022, 2333], [2336, 2336, 2364, 2364, 2445], [2640, 2640, 2661, 2661, 3369], [3558, 3558, 3581, 3581, 3751], [3755, 3755, 3812, 3812, 9235]], "test": "error"}
{"id": "tljyDV", "name": "v3Rows.glsl", "author": "jorge2017a1", "description": "v3Rows.glsl", "tags": ["v3rowsglsl"], "likes": 6, "viewed": 57, "published": "Public", "date": "1595444853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    vec2 coord = fragCoord.xy;\n    vec2 size = iResolution.xx / vec2(60.0, 15.0);\n\n    float y = coord.y / size.y;\n    float scr = 3.0 + 3.0 * fract(floor(y) * 12433.34);\n    float x = coord.x / size.x + scr * iTime;\n \n    float t = iTime * 1.1;\n    float t01 = fract(t);\n    float phase = floor(x) * 2353.48272 + floor(y) * 2745.32782 + floor(t);\n\n    float h = mix(\n        fract(sin(phase    ) * 1423.84),\n        fract(sin(phase + 1.0) * 1423.84),\n        smoothstep(0.8, 1.0, t01) * 1.3 - smoothstep(0.5, 0.8, t01) * 0.3\n    );\n\n    float c1 = (0.4 - abs(0.4 - fract(x))) / 0.8 * size.x;\n    float c2 = (h - fract(y)) * size.y;\n    float c = clamp(c1, 0.0, 1.0) * clamp(c2, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 91, 91, 818]], "test": "valid"}
{"id": "tljyWc", "name": "The dunnos", "author": "z0rg", "description": "A fun experiment with not so much code.\n", "tags": ["2d", "idunno", "dunnos", "theydunno"], "likes": 7, "viewed": 186, "published": "Public API", "date": "1595602142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\n\nfloat sat(float a)\n{\n    return clamp(a, 0., 1.);\n}\n\nfloat cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n// Thanks IQ :)\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    col = mix(vec3(33, 75, 166)/255., vec3(0.1), sat(length(uv)));\n    \n    int i = 0;\n    while (i < 4)\n    {\n        float xPos = float(i)*.2-.25;\n        \n        float yPos = (sin(float(i)*15.)*.2+.5)*mix(-1.,-8., sat(pow(sin(float(i)+iTime*0.9), 5.)));\n        float body = (sdSegment(uv, vec2(xPos*1.5, -1.), vec2(xPos,.3*yPos))-.05);\n        col = mix(vec3(0.), col, sat(body*200.));\n\t\tvec2 headP = vec2(xPos, .3*yPos);\n        vec2 blink = vec2(1., 1.-max(pow(sin(iTime*4.-float(i)*1.2), 50.), 0.1));\n        float eyes = min(cir((uv-headP-vec2(0.02, 0.002*abs(uv.x)))/blink,.01), cir((uv-headP-vec2(-0.02, 0.02*(uv.x)))/blink, .01));\n        col = mix(vec3(235, 202, 19)/255., col, sat(eyes*400.));\n        ++i;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\t \n    vec3 col = rdr(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyWc.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[427, 427, 445, 445, 506], [509, 509, 529, 529, 560], [562, 562, 590, 590, 616], [618, 634, 686, 686, 805], [807, 807, 826, 826, 1595], [1597, 1597, 1654, 1654, 1786]], "test": "valid"}
{"id": "tljyzK", "name": "mandelbrot deforme v2", "author": "jorge2017a1", "description": "mandelbrot deforme v2", "tags": ["mandelbrotdeformev2"], "likes": 1, "viewed": 50, "published": "Public", "date": "1594866192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modifcado por jorge flores.p.  --2020-jul\n//jorge2017a1\n\nint mandelbrotv1(vec2 uv) \n{\n    vec2 z = uv;\n    vec2 c=uv;\n    int numSteps = 256;\n    \n    int i;\n        \n    \n    for ( i = 0; i < numSteps; i++) \n    {\n        \n        if (dot(z, z) > 4.0) return i*10;\n        \n        \n        // (x+yi)^2 = (x+yi) * (x+yi) = x^2 + (yi)^2 + 2xyi = x^2 - y^2 + 2xyi\n        if (i==120)\n           c=c+vec2(-0.25,-0.2);       \n           z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        \n    }\n    \n    float r = (i == numSteps ? 0.0 : float(i)) / 100.0;\n    \n    \n    return 0;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinate, roughly -2 to +2\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy) * 2.0/ iResolution.x;\n    \n    \n    \n    \n    float scale = 2.0;\n    //vec2 translate = vec2(0.16,0.0252);\n    vec2 translate = vec2(-0.7485,0.1);\n    vec2 z, c;\n    \n    scale = 0.0001;\n    scale += abs(pow(sin(iTime*0.2),4.0)*2.0);\n    \n    c.x = 1.3333 * (uv.x - 0.5) * scale + translate.x;\n    c.y = (uv.y - 0.5) * scale + translate.y;\n\n    \n    \n    // Evaluate mandelbrot for this coordinate.\n    \n    float ret = float( mandelbrotv1(c)); \n    \n     vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Turn the iteration count into a color.\n    if (ret>0.0 )\n\tfragColor = vec4(sin(vec3(0.1, 0.2, 0.5) * ret), 1);\n    else\n     fragColor = vec4(col , 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 87, 87, 596], [600, 600, 657, 700, 1429]], "test": "valid"}
{"id": "tlKXDz", "name": "Foggy Flyover", "author": "ruojake", "description": "That's FBM terrain and volumetric fog checked off on the Shadertoy achievements!", "tags": ["3d", "raymarching", "terrain", "volume"], "likes": 10, "viewed": 381, "published": "Public API", "date": "1595189089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Foggy Flyover by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// Hash without sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --\n\n\nconst vec2 o = vec2(1., 0.);\n\nfloat noise(vec3 p)\n{\n\tvec3 pi = floor(p);\n    vec3 pf = smoothstep(0., 1., p - pi);\n    return mix(\n        mix(\n        \tmix(hash13(pi), hash13(pi+o.xyy), pf.x),\n            mix(hash13(pi+o.yyx), hash13(pi+o.xyx), pf.x),\n            pf.z\n        ),\n        mix(\n        \tmix(hash13(pi+o.yxy), hash13(pi+o.xxy), pf.x),\n            mix(hash13(pi+o.yxx), hash13(pi+1.), pf.x),\n            pf.z\n        ),\n    pf.y);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = smoothstep(0., 1., p - pi);\n    vec2 r = mix(vec2(hash12(pi), hash12(pi+o.yx)), vec2(hash12(pi+o), hash12(pi+1.)), pf.x);\n    return mix(r.x, r.y, pf.y);\n}\n\nconst mat2 ROT = mat2(.98, -.198, .198, .98);\n\n#define sat(v) clamp(v,0.,1.)\n\nfloat fbm(vec2 p, float o)\n{\n\tfloat res = 0.;\n   \tfor(float i = 1.; i < o; i += i)\n    {\n        res += noise(p*i) / i;\n    \tp = p * ROT;\n        o -= ROT[0][0] * .001 * sign(iTime);\n    }\n    return res;\n}\n\nfloat scene(vec3 p, float o)\n{\n\tfloat res = fbm(p.xz, o) * .5;\n    res *= 2.5 - res * res;\n    return .4 * (p.y + res - 1.5);\n}\n\nvec3 normal(vec3 p, float o)\n{\n\tfloat d = fbm(p.xz, o);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        fbm(p.xz - e, o),\n        d - 0.0011,\n        fbm(p.xz - e.yx, o)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t, 16.);\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nfloat clouds(vec3 p)\n{\n\tfloat res = noise(p * 4.) * 2.;\n    p.y -= iTime * .02;\n    res -= noise(p * 11.);\n\n    return sat(res * 4. * (1. - res));\n}\n\nvec3 material(vec3 p, vec3 n, float l, float t)\n{\n\tfloat noise0 = fbm(p.xz * 20., 32.);\n    float noise1 = fbm(p.xz * 310., 4.);\n    noise1 = 2. * noise1 - 1.;\n    float y = p.y;\n    t = sat(t * .03 - .1);\n    vec3 sunCol = vec3(1., .97, .85);\n    \n    vec3 forest = vec3(.03, .08, .01) + noise1 * .02;\n    forest += l * .1 * sunCol;\n    vec3 rock = vec3(.025) + noise1 * .01;\n    rock += l * sunCol * .3;\n    vec3 snow = vec3(.6, .6, .7);\n    snow += l * .4 * sunCol;\n    \n    vec3 res = mix(rock, forest, smoothstep(.8, .5, y + .2 * noise0) * n.y * (2. - n.y));\n    res = mix(res, snow, smoothstep(1.2 - t, 1.3 + t, y + .4 * noise0));\n    return mix(res, res * vec3(.5, .55, .9), smoothstep(.3, 0., l));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\tvec2 m = clamp((iMouse.xy / iResolution.xy) * 2. - 1., vec2(-1.), vec2(1.));\n    if (m == vec2(-1.,-1.)) m = vec2(0.);\n    \n    vec3 tgt = vec3(m.x * 2. + 10., m.y + 1.4, 2. + iTime * .3 - max(abs(m.x), abs(m.y) * .5) * 2.);\n    vec3 ro = vec3(10.,1.5, iTime * .3);\n    \n    vec3 rd = ray(ro, tgt, uv, .8);\n    float t = 0.;\n    vec3 p;\n    \n    if (rd.y < 0.)\n    {\n        for(int i = 0; i < 90; i++)\n        {\n            p = ro + rd * t;\n            float d = scene(p, 16.);\n            t += d * (1.25 - pow(abs(rd.y), 4.) + sat(t * .1 - 1.));\n            if (abs(d) < .001 * t || t > 30.) break;\n        }\n        t = t >= 30. ? 1000. : t;\n    }\n    else\n    {\n    \tt = 1000.;\n        p = ro + rd * t;\n    }\n    \n    float theta = .5 * 3.1415;\n    vec3 lDir = normalize(vec3(-sin(theta), .25, cos(theta)));\n    float dither = hash12(fragCoord + fract(iTime) * 200.);\n    \n    float maxl = .8;\n    vec3 cFog = vec3(.1,.15,.2);\n    vec4 fog = vec4(0.);\n    float ft = max(ro.y - maxl, 0.) / (-rd.y + .0001);\n    ft += dither * (.025 * ft + .1) * (1. - sat(-rd.y));\n    vec3 v = vec3(0.,iTime * -.02,0.);\n\tfloat h = 1. - abs(rd.y);\n    vec3 shadowCol = cFog * vec3(.4, .5, .7);\n    float l = 0.;\n    vec3 skyCol = mix(vec3(.7, .8, 1.), vec3(.1, .1, .4), sat(rd.y));\n    \n    vec3 col = vec3(0.);\n\tif (t < 500.)\n    {\n    \n        if(p.y <= maxl)\n            for(int i = 0; i < 35; i++)\n            {\n                float dt = .01 + h * .1;\n                ft += dt;\n\n                if (ft >= t) break;\n\n                vec3 fp = (ro + rd * ft);\n\n                if (rd.y >= 0. && fp.y > maxl) break;\n\n                float d = clouds(fp + v) * (maxl + h) * dt * 10.;\n                float fade = min(sat(maxl - fp.y), min(ft * .5, maxl - ft * .05));\n                fade *= fade;\n                d *= fade;\n                ft += min(sat(h - fade) * .03, t - ft);\n                if (d > .01)\n                {\n                    l = 0.;\n                    float s = shadow(fp, lDir, 15. - fp.y, 20.);\n                    if (s > .001)\n                    {\n                        s *= 2. - s;\n                        l = sat(s * (1. - clouds(fp + lDir * .1 + v) * 3. * fade));\n                    }\n                    float w = sat((.1 * l + .91) - fog.a);\n                    fog.rgb += mix(shadowCol, cFog + l, l) * d * w;\n                    fog.a += d * w;\n\n                    if (fog.a > .95) \n                    {\n                        fog.a = 1.;\n                        break;\n                    }\n                }\n            }\n\n        fog.rgb = mix(fog.rgb, skyCol, sat(t * .05 - .15));\n        fog.a = min(fog.a, 1.);\n\n\n        vec3 n = t < 10. ? t < 6. ? normal(p, 256.) : normal(p, 64.) : normal(p, 8.);\n        l = sat(dot(n, lDir) * .8 + .2);\n        float s = shadow(p + n * .1 + vec3(0.,.03,0.), lDir, 15., 14.);\n        float sun = smoothstep(.9995, 1., dot(rd,lDir));\t\n\n        col = rd.y <= 0. ? mix(\n            vec3(material(p, n, l * s, t)), \n            skyCol, \n            sat(t * .05 - .15)) : skyCol;\n        col += sun * 2. * smoothstep(1.,.9999, 30. - t);\n\n        col = mix(col, fog.rgb, fog.a * fog.a);\n    }\n    else col = skyCol;\n    \n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    col += (dither * .03 - .015) * col;\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXDz.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[114, 192, 214, 214, 331], [333, 333, 356, 356, 459], [498, 498, 519, 519, 914], [916, 916, 937, 937, 1128], [1208, 1208, 1236, 1236, 1414], [1416, 1416, 1446, 1446, 1543], [1545, 1545, 1575, 1575, 1739], [1741, 1741, 1797, 1797, 2144], [2146, 2146, 2199, 2199, 2357], [2359, 2359, 2381, 2381, 2507], [2509, 2509, 2558, 2558, 3216], [3218, 3218, 3274, 3274, 6702]], "test": "valid"}
{"id": "tllBRr", "name": "Rainbow Swirl Crinkle", "author": "t420babe", "description": "Rainbow swirl with tan and cos", "tags": ["rainbow"], "likes": 1, "viewed": 120, "published": "Public API", "date": "1595887338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec3 rainbow_swirl_crinkle(vec2 pos) {\n  vec3 color = vec3(0.0);\n\n  float speed = 1.1;\n  float zoom = 1.0;\n  pos *= zoom;\n\n  vec2 movement = vec2(iTime, 1.0);\n\n  for (int i = 1; i < 3; i++) {\n    pos.x += 0.5 / float(i) * tan(float(i) * 5.0 * pos.y + iTime / speed) + movement.x/ 20.00;\n    pos.y -= 1.5 / float(i) * cos(float(i) * 15.5 * pos.x + iTime / speed) + movement.y / 30.0;\n  }\n\n  float g = cos(pos.y + pos.y + 1.0) * 0.5 + 0.5;\n  float b = sin(pos.x + pos.x + 1.0) * 0.5 + 0.5;\n  float r = (tan(pos.x * pos.y) + tan(pos.y + pos.x)) * 0.5 + 0.5;\n\n  return vec3(g, b, r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    \n    vec3 color = rainbow_swirl_crinkle(pos);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 82, 82, 625], [628, 628, 685, 738, 865]], "test": "valid"}
{"id": "tlsBzn", "name": "Japanese Summer", "author": "butadiene", "description": "Japanese Summer, hurin", "tags": ["raymarching"], "likes": 10, "viewed": 223, "published": "Public API", "date": "1595880539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.141592;\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat cylin( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat hashira(vec3 p,vec2 s){\n  vec2 q = abs(p.xz);\n  vec2 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.x,m.y);\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat cup(vec3 p){\n  p.xy *= rot(PI);\n  p.y += 0.4;\n  float sd = abs(length(p)-0.4)-0.01;\n  float bd = box(p-vec3(0,-0.45,0),vec3(0.9,0.2,0.9));\n  return max(sd,-bd);\n}\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec4 sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n    \n    // if perfectly straight\n    if( abs(a)<0.001 ) return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n                 (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n                 (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n                 p.z );\n}\n\n\nvec4 rope1(vec3 p){\n     p.y += 1.;\n   p.x -= 1.;\n   p.yz *= rot(PI);\n\n   float an2 = 0.1*sin(iTime*1.9)*exp(fract(iTime*1.9/(PI*2.)))-0.2;\n   float le2 = 0.6;\n   float wi2 = 0.01;\n   vec4 d4 = sdJoint3DSphere(p, le2, an2, wi2 );\n   p.xy*= rot(-an2);\n   p -= vec3(0,le2/an2*sin(an2),0);\n   p.xy*= rot(-an2);\n   return vec4(p,d4.x);\n}\n\nvec4 cup1(vec3 p1){\n   vec4 rope1obj = rope1(p1);\n  vec3  p = rope1obj.xyz;\n   float d4 = rope1obj.w;\n   float scup = 1.6;\n   float d0 = cup(p*scup)/scup;\n   return vec4(p,min(d0,d4));\n}\n\nvec4 rope2(vec3 p1){\n  vec4 cupobj = cup1(p1);\n vec3  p = cupobj.xyz;\n  float d0 = cupobj.w;\n   p.xy *= rot(0.1*sin(iTime));\n   float an = 0.1*sin(iTime*2.)*exp(fract(iTime*2./(PI*2.)))-0.15;\n   float le = 1.2;\n   float wi = 0.01;\n   vec4 d1 = sdJoint3DSphere(p, le, an, wi );\n   p.xy*= rot(-an);\n   p -= vec3(0,le/an*sin(an),0);\n   p.xy*= rot(-an);\n   p.xz *= rot(iTime*4.+pow(abs(sin(iTime)),4.)*iTime*6.);\n   return vec4(p,min(d1.x,d0));\n}\n\nvec4 paper1(vec3 p1){\n     vec4 rope2obj = rope2(p1);\n  vec3 p = rope2obj.xyz;\n   float d1 = rope2obj.w;\n    float planex = 0.4;\n   float d2 = box(p-vec3(0,planex,0),vec3(0.01,planex,0.1));\n   return vec4(p,min(d2,d1));\n}\n\nfloat hurin(vec3 p){\n \n  \n\n vec4 paper1obj = paper1(p);\n p = paper1obj.xyz;\n float d2 = paper1obj.w;\n  //p.yz *= rot(time);\n  return d2;\n}\n\nfloat ueno(vec3 p){\n  vec3 sp = p;\n  sp.xy *=rot(0.5*PI);\n  sp.x = abs(sp.x)-0.8;\n  float d1 = hashira(sp,vec2(0.2,0.2));\n  sp = p;\n  float spkx = 2.6;\n  sp.x = mod(sp.x,spkx)-0.5*spkx;\n  float d2 = box(sp,vec3(0.1,0.8,0.2));\n  float d3 = box(p-vec3(0,1.8,0),vec3(100,0.2,3));\n  return min(min(d1,d2),d3);\n}\n\nfloat door(vec3 sp){\n  return box(sp-vec3(-7,-4,0),vec3(5,3,0.15));\n}\n\nfloat ana(vec3 p){\n  p.x += 0.2;\n  p.y +=0.15;\n  float k = 0.9;\n  p.xy = mod(p.xy,k)-0.5*k;\n  p.z = abs(p.z)-1.;\n  float d0 = box(p,vec3(0.38,0.38,0.95));\n  return d0;\n}\n\nfloat dist(vec3 p){\n  float d0 = ueno(p);\n  float d3 = door(p);\n  d3 = max(d3,-ana(p));\n\n  return min(min(d0,d3),hurin(p));\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy)-dist(p-e.xyy),\n    dist(p+e.yxy)-dist(p-e.yxy),\n    dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nvec3 woodoorlight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .5;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  float nof = fbm(p.xy*1.+p.z*0.3);\n  float nof2 = fbm(20.+p.xy*2.+.4*p.z);\n  vec3 alb = vec3(218.,143.,143.)/255.*(0.2+0.8*nof);\n  if(mod(nof*10.0,2.0)<0.2||mod(nof2*10.0,2.0)<0.2){\n    alb =vec3(0,0,0);\n  }\n  return dif*alb;\n}\n\nvec3 wooduplight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .5;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  float nof = fbm(40.+p.xy*1.+p.z*0.3);\n  float nof2 = fbm(30.+p.xy*2.+.4*p.z);\n  vec3 alb = 0.4*vec3(288.,143.,143.)/255.*(0.2+0.8*nof);\n  if(mod(nof*10.0,2.0)<0.2){\n    alb =vec3(0,0,0);\n  }\n  return dif*alb;\n}\n\nvec3 paperlight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .1;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  vec3 alb = vec3(1.0);\n  return dif*alb;\n}\n\nvec3 sky(vec3 vd,vec3 ld){\n  float dalp = pow(dot(ld,vd),6.);\n  vec3 blue = normalize(vec3(0.1,0.2,1.));\n  vec3 white = vec3(1);\n  vec3 scol= mix(blue,white,dalp);\n  float fbmem = fbm(6.*vd.yx+iTime*0.1);\n  return mix(vec3(0.1,0.3,0.9),scol+fbmem,clamp(vd.y*2.,0.,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\n    \n    \nvec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nvec2 pix = vec2(min(iResolution.x,iResolution.y)/64.);\n//p = floor(p*pix)/pix;\nvec3 ta = vec3(0,-2,0);\nvec3 ro = vec3(2,-3,5);\nro -= 1.0*(ta-ro);\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nfloat fov = 3.0;\nvec3 fcol = vec3(0);\nvec2 glv =vec2(0.0);//floor(gl_FragCoord.xy/2.);\n#define bokashi 8\nfor(int i = 0;i<bokashi;i++){\n  float fi = float(i);\n  vec3 rd = normalize(side*p.x+up*p.y+fov*cdir)+0.008*(vec3(random(vec2(glv+fi+200.)),random(vec2(glv+fi+100.)),random(glv+vec2(fi)))-vec3(0.5));\n  float d,t =0.;\n  float maxdis = 1000.;\n  float mindis = 0.001;\n  \n  for(int i = 0;i<34;i++){\n     d = dist(ro+rd*t);\n     t += d;\n     if(d<mindis||t>maxdis)break;\n  }\n   \n  vec3 col = vec3(0);\n  vec3 sp = ro+rd*t;\n  vec3 ld = normalize(vec3(0.5,1,-1));\n  vec3 vd = rd;\n  vec3 nor = getNormal(sp);\n  if(d<mindis){\n    col = abs(nor);\n    if(door(sp)<mindis){\n      col=woodoorlight(sp,ld,nor,vd);\n      if(0.1>abs(sp.z)&&(ana(sp)<mindis&&abs(nor.z)>0.9)){\n        col = paperlight(sp,ld,nor,vd);\n      }\n    };\n    if(ueno(sp)<mindis){\n    col=wooduplight(sp,ld,nor,vd);\n    }\n    if(rope1(sp).w<mindis){\n      col = clamp(mix(vec3(0.2,0.8,0.8),vec3(1,0.4,0.4),+0.25-rope1(sp).y),0.,1.);\n    }else if(cup1(sp).w<mindis){\n      vec3 scp = rope1(sp).xyz;\n      col = clamp(0.8-scp.yyy,0.,1.)*vec3(0.5,1.,1.5)+vec3(1,0,0)*step(fbm(scp.xy*20.),0.52);\n    }else if(rope2(sp).w<mindis){\n      col = vec3(0.2,0.8,0.8);\n    }else if(paper1(sp).w<mindis){\n      col = clamp(mix(vec3(1),vec3(1,0.4,0.4),paper1(sp).y),0.,1.);\n    }\n  }\n  else{\n    col = sky(vd,ld);\n  }\n  fcol += col;\n}\nfcol = fcol/float(bokashi);\n//col = abs(nor);\n//col = pow(col,vec3(1./2.2));\n\n\n\nfragColor=vec4(fcol,1);}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 87], [89, 89, 116, 116, 223], [225, 225, 251, 251, 595], [615, 615, 639, 639, 864], [866, 866, 907, 907, 966], [968, 968, 997, 997, 1088], [1090, 1090, 1115, 1115, 1212], [1214, 1214, 1232, 1232, 1382], [1384, 1437, 1462, 1462, 1481], [1482, 1482, 1552, 1586, 2167], [2170, 2170, 2189, 2189, 2503], [2505, 2505, 2524, 2524, 2691], [2693, 2693, 2713, 2713, 3135], [3137, 3137, 3158, 3158, 3358], [3360, 3360, 3380, 3380, 3498], [3500, 3500, 3519, 3519, 3807], [3809, 3809, 3829, 3829, 3878], [3880, 3880, 3898, 3898, 4049], [4051, 4051, 4070, 4070, 4176], [4178, 4178, 4201, 4201, 4361], [4363, 4363, 4417, 4417, 4725], [4727, 4727, 4780, 4780, 5072], [5074, 5074, 5126, 5126, 5249], [5251, 5251, 5277, 5277, 5523], [5525, 5525, 5582, 5632, 7464]], "test": "valid"}
{"id": "tlScRd", "name": "Raymarch Tests", "author": "Sassages", "description": "Test", "tags": ["raymarch"], "likes": 1, "viewed": 48, "published": "Public", "date": "1595158974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DISTANCE 100.0\n#define CLOSE_ENOUGH .01\n#define EPSILON .01\n#define SMOOTH_FACTOR 2.5\n\nvoid TRS (vec3 T, vec3 R, vec3 S)\n{\n    mat4 scale = mat4(S.x, 0, 0, 0,\n                       0, S.y, 0, 0,\n                       0, 0, S.z, 0,\n                       0, 0, 0, 1);\n    \n    float a = radians(R.x);\n    mat4 rotateX = mat4(1, 0, 0, 0,\n                        0, cos(a), -sin(a), 0,\n                        0, sin(a), cos(a), 0,\n                        0, 0, 0, 1);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat smoothMin(float dstA, float dstB, float k)\n{\n    float h = max(k - abs(dstA - dstB), .0) / k;\n    return min(dstA, dstB) - h * h * h * k * 1./6.;\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, .0, 1.);\n}\n\nvec3 saturate(vec3 v)\n{\n    return vec3(saturate(v.x), saturate(v.y), saturate(v.z));\n}\n\nfloat getNearestDistance(vec3 point)\n{\n    // sphere\n    float radius = 2.0;\n    vec3 pos = vec3(0, 2, 5);\n    float sphereDist = sdSphere(pos - point, radius);\n    \n    // box\n    pos = vec3(4. * sin(iTime), 2, 5);\n    vec3 dimensions = vec3(.9, .9, 1.8);\n    float boxDist = sdBox(pos - point, dimensions);\n    \n    // floor\n    float floorDist = point.y;\n    \n    float min1 = smoothMin(sphereDist, boxDist, SMOOTH_FACTOR);\n    //float min1 = min(sphereDist, boxDist);\n    \n    return min(min1, floorDist);\n}\n\nvec3 surfaceNormal( vec3 point )\n{\n    float leftDist = getNearestDistance(point - vec3(EPSILON, 0, 0));\n    float rightDist = getNearestDistance(point + vec3(EPSILON, 0, 0));\n    \n    float upDist = getNearestDistance(point + vec3(0, EPSILON, 0));\n    float downDist = getNearestDistance(point - vec3(0, EPSILON, 0));\n    \n    float forwardDist = getNearestDistance(point + vec3(0, 0, EPSILON));\n    float backwardDist = getNearestDistance(point - vec3(0, 0, EPSILON));\n    \n    return normalize(vec3(rightDist - leftDist, upDist - downDist, forwardDist - backwardDist));\n}\n\nfloat raymarch( vec3 origin, vec3 direction )\n{\n    float dist = 0.0;\n    \n    \n    while(dist < MAX_DISTANCE)\n    {\n        float step = getNearestDistance(origin);\n        dist += step;\n        \n        if(step < CLOSE_ENOUGH)\n            return dist;\n        \n        origin += step * direction;\n    }\n    \n    return MAX_DISTANCE;\n}\n\nfloat calcShadow( vec3 point, vec3 lightDir )\n{\n    vec3 normal = surfaceNormal(point);\n    vec3 origin = point + normal * CLOSE_ENOUGH * 2.;\n    \n    float distToLight = raymarch(origin, -lightDir);\n    \n    if(distToLight >= MAX_DISTANCE)\n        return 1.;\n    else\n        return 0.;\n}\n\nvec3 calcLightingForLight(vec3 normal, vec3 diffuseColor, vec3 lightDir, vec3 point, vec3 viewDir)\n{    \n    // Diffuse\n    float diffuseIntensity = 0.4;\n    vec3 diffuse = saturate(vec3(dot(-lightDir, normal))) * diffuseIntensity * diffuseColor;\n    \n    // Specular\n    vec3 halfVec = normalize(-viewDir - lightDir);\n    float power = 50.0;\n    vec3 specular = vec3(pow(saturate(dot(halfVec, normal)), power)) * 0.5;\n\n    return diffuse + specular;\n}\n\nvec3 calcLighting( vec3 point, vec3 viewDir )\n{\n    vec3 normal = surfaceNormal(point);\n    vec3 diffuseColor = vec3(0.3, 1.0, 0.3);\n    \n    // Light 1 - moving\n    vec3 lightDir = normalize(vec3(sin(iTime), -1, cos(iTime)));\n    vec3 light1 = calcLightingForLight(normal, diffuseColor, lightDir, point, viewDir);\n    float shadow = calcShadow(point, lightDir);\n    \n    // Light 2 - static\n    lightDir = normalize(vec3(-1., .8, 0.2));\n    vec3 light2 = calcLightingForLight(normal, diffuseColor, lightDir, point, viewDir) * 0.7;\n    \n    // Ambient\n    vec3 ambient = vec3(0.3) * diffuseColor;\n    \n    return shadow * (light1 + light2) + ambient;\n}\n\nvec3 calcDirection(vec2 fragCoord, float vertFOV)\n{\n    vec2 centeredCoords = fragCoord - iResolution.xy / 2.0;\n    float z = 0.5 * iResolution.y * tan(radians(0.5 * vertFOV));\n    \n    return normalize(vec3(centeredCoords, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayOrigin = vec3(0, 3, 0);\n    vec3 rayDirection = calcDirection(fragCoord, 90.0);\n    \n    float pixelDistance = raymarch(rayOrigin, rayDirection);\n    if(pixelDistance >= MAX_DISTANCE)\n    {\n        float grad = rayDirection.y * .7;\n        fragColor = vec4(.2,.6,1.,1) + grad;\n        return;\n    }\n\n    vec3 point = rayOrigin + rayDirection * pixelDistance;\n    vec3 col = calcLighting(point, rayDirection);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlScRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 134, 134, 481], [483, 483, 514, 514, 601], [603, 603, 638, 638, 662], [664, 664, 714, 714, 817], [819, 819, 844, 844, 875], [877, 877, 900, 900, 964], [966, 966, 1004, 1018, 1477], [1479, 1479, 1513, 1513, 2053], [2055, 2055, 2102, 2102, 2391], [2393, 2393, 2440, 2440, 2682], [2684, 2684, 2784, 2803, 3136], [3138, 3138, 3185, 3185, 3790], [3792, 3792, 3843, 3843, 4022], [4024, 4024, 4081, 4081, 4537]], "test": "valid"}
{"id": "tlScRG", "name": "menger-sponge-va-008", "author": "jorge2017a1", "description": "menger-sponge-va-008", "tags": ["mengerspongeva008"], "likes": 5, "viewed": 54, "published": "Public", "date": "1594649617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n\n\n\n#define PI2 6.28318530717\n#define PI 3.14159265358979323846264\n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\n\n//-------------------------------------------\n\n\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n//--------------------------------------------\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.33;\n\t\n    \n    \n    \n    vec3 q=vec3(0.5,-0.49,0.8);\n    float cx=10.0;\n    \n    float cz=15.0;\n    \n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    \n    \n    float dist= sdBox( p-q, vec3(5.5, 0.5, 4.0 ));\n    \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = mod(iTime * 0.5,500.0);\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    //vec3 ro = vec3(5.0+2.0*cos(time*0.4), 0.25, 5.0+ 1.0*sin(time));\n    vec3 ro = vec3(5.0+2.0*cos(time*0.4), 0.25, 1.5+ 1.0*sin(time));\n    \n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlScRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 585, 585, 616], [618, 618, 649, 649, 740], [793, 848, 871, 871, 1006], [1008, 1008, 1034, 1034, 1091], [1093, 1093, 1133, 1133, 1167], [1171, 1171, 1218, 1218, 1251], [1254, 1301, 1337, 1337, 1454], [1456, 1456, 1492, 1492, 1610], [1613, 1642, 1660, 1660, 2075], [2135, 2135, 2164, 2164, 2352], [2354, 2354, 2395, 2395, 2571], [2573, 2573, 2614, 2614, 2766], [2768, 2768, 2789, 2789, 2919], [2921, 2921, 2948, 2948, 3198], [3200, 3200, 3257, 3257, 3815]], "test": "valid"}
{"id": "tlScz3", "name": "Recursively orbiting moons", "author": "jarble", "description": "A moon orbits a moon, which orbits another moon of a moon of a planet.\nThe orbital periods aren't quite accurate: they should be calculated using Kepler's third law.", "tags": ["3d", "raymarching", "planet", "orbit"], "likes": 2, "viewed": 188, "published": "Public API", "date": "1594934229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/ttByRD\n//the renderer is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float planet_size = 1000.0;\nconst float size = 10.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat craters(vec3 p,float i){\n    float scale1 = 32.0;\n    p -= (i+sin(p.yzx/scale1))*scale1;\n    p /= planet_size;\n    p *= i;\n\treturn length(sin(i*p*length(sin(p))))*scale1*sqrt(scale1)/i;\n}\n\n\nfloat sphere(vec3 p,float radius){\n    return length(p)-radius;\n}\n\nfloat planet(vec3 p) {\n    return (sphere(p,planet_size))*scale/10.0;\n}\n\nfloat sceneSDF(vec3 p){\n    p /= scale;\n    float result = planet(p);\n    float scale = 1.0;\n    for(int i = 0; i < 4; i++){\n        scale *= 1.07;\n        //p = -p.yzx;\n        float t1 = iTime*scale*3.0;\n        p += scale*(p+5000.0*vec3(sin(t1),cos(t1),0));\n\n\t\tresult = min(result,planet(p));\n    }\n    return result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(1.0,.5,.3+sin(p+sin(p.yzx))/5.0)/1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 2.0;\n    vec3 eye = scale*(18.5+sin(iTime/speed)*.7)*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlScz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[379, 379, 409, 409, 572], [575, 575, 609, 609, 640], [642, 642, 664, 664, 713], [715, 715, 738, 738, 1037], [1039, 1039, 1067, 1067, 1123], [1125, 1546, 1637, 1637, 1943], [1958, 2212, 2277, 2277, 2409], [2411, 2500, 2529, 2529, 2839], [2841, 3333, 3473, 3473, 4083], [4085, 4455, 4540, 4540, 5312], [5314, 5641, 5690, 5725, 5856], [5858, 5858, 5915, 5915, 6898]], "test": "valid"}
{"id": "tlSyRz", "name": "Wobbly fractal tunnel", "author": "jarble", "description": "This fractal surface is generated using trigonometric functions at several different scales.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 189, "published": "Public API", "date": "1593556211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p1 += cos(p1+vec3(iTime));\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y/2.0),sin(p1.z/4.0)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = .1; i < 100.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(sceneSDF(p+vec3(1.0)),sceneSDF(p+vec3(2.0)),sceneSDF(p+vec3(3.0))))/2.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+dist)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*vec3(0.0,1.0,50.0)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[518, 518, 547, 547, 704], [706, 706, 730, 730, 976], [978, 978, 1006, 1006, 1110], [1112, 1533, 1624, 1624, 1941], [1956, 2210, 2275, 2275, 2407], [2409, 2498, 2527, 2527, 2837], [2839, 3331, 3471, 3471, 4081], [4083, 4453, 4538, 4538, 5300], [5302, 5629, 5678, 5713, 5844], [5846, 5846, 5903, 5903, 6814]], "test": "valid"}
{"id": "tlSyW3", "name": "Infinite Circle Loop", "author": "nokey", "description": "just practice", "tags": ["circle"], "likes": 0, "viewed": 46, "published": "Public", "date": "1595511249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    float d = 0.0;\n    \n    uv = uv * 2. - 1.;\n    \n    d = length(abs(uv) - .3) - iTime * .1;\n\n    fragColor = vec4(vec3(mod(d * 10., 1.)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 373]], "test": "valid"}
{"id": "tlXBR8", "name": "Tetrahedron SDF (rounded)", "author": "teadrinker", "description": "Is roundmax() a decent name? \nIs it known by some other name?", "tags": ["sdf", "tetrahedron", "tetrahedronsdf", "roundmax"], "likes": 2, "viewed": 294, "published": "Public API", "date": "1596228303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n\nA common problem when building sdf functions is that when\ncombining sdf distances (like for example from 2 planes) using\nmax(a,b) the result will have incorrect distance for the corners.\nFor many cases this is fine, and if not you can use a smooth union.\nHowever, there are cases, like morphing, where it is nicer to have\nsomething closer to an exact solution.\n\nI was trying to understand this problem better by looking at plots\nof 2D SDF functions when I realized that there seem to be a simple\ngeneral solution to this problem (I am not sure how useful it is,\nbut it seemed to work fine for a tetrahedron)\n\nroundmax() below can be used to combine SDF distances.\nIt's only correct if used with planes that are perpendicular,\nbut seem to work ok to raymarch for angles < 90 degrees.\n\nAngles > 90 degrees might cause ray marching to overshoot\n(but you could then use gamma space, pow(pow(a,g) + pow(a,g),1/g)\n instead of sqrt(a*a + b*b), for a more extreme warp of the space)\n\n\nbtw, If you need an exact tetrahedron sdf, iq posted one here:\n  https://www.shadertoy.com/view/ts3SRs\n\n*/\n\n\nfloat roundmax(float a, float b) \n{\n    return a > 0. && b > 0. ? length(vec2(a, b)) : max(a, b);\n}\n\nfloat roundmax(float a, float b, float c) \n{\n    return length(max(vec3(a, b, c), 0.0)) + min(max(max(a, b), c), 0.0);\n}\n\nfloat roundmax(float a, float b, float c, float d) \n{\n    return length(max(vec4(a, b, c, d), 0.0)) + min(max(max(a, b), max(c, d)), 0.0);\n}\n\nfloat sdTetrahedron(vec3 p, float size) // not exact!\n{\n    return roundmax(\n         (p.x + p.z) - p.y - size, \n        -(p.x + p.z) - p.y - size,\n         (p.x - p.z) + p.y - size, \n        -(p.x - p.z) + p.y - size\n    ) * (1. / sqrt(3.));\n}\n\nfloat sdTetrahedronFaster(vec3 p, float size) // not exact, no interior\n{\n    return length(max(vec4(\n         (p.x + p.z) - p.y - size,\n        -(p.x + p.z) - p.y - size,\n         (p.x - p.z) + p.y - size,\n        -(p.x - p.z) + p.y - size\n        ), 0.0)) * (1. / sqrt(3.));\n}\n\n\n\n\nfloat mapbasic( in vec3 pos )\n{\n    float roundness = 0.08 * (1. + sin(iTime));\n    return sdTetrahedron(pos-vec3(0.0, 0.35, 0.0), 0.25 - roundness * 1.3) - roundness;\n}\n\n\n// (this is using Inigo Quilez raymarching code)\n\n//------------------------------------------------------------------\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    float roundness = 0.08 * (1. + sin(iTime));\n    res = opU(res, vec2(mapbasic(pos), 1.5));\n    \n    return res;\n}\n\n\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0;// + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.3, 0.0 );\n    vec3 ro = ta + vec3( 1.5*cos(0.1*time + 7.0*mo.x), 0.4 + 1.0*mo.y, 1.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1091, 1091, 1126, 1126, 1190], [1192, 1192, 1236, 1236, 1312], [1314, 1314, 1367, 1367, 1454], [1456, 1456, 1511, 1511, 1700], [1702, 1702, 1775, 1775, 1980], [1985, 1985, 2016, 2016, 2154], [2448, 2448, 2473, 2473, 2488], [2490, 2490, 2520, 2520, 2553], [2555, 2555, 2580, 2580, 2732], [2908, 2976, 3027, 3027, 3232], [3234, 3234, 3274, 3274, 4084], [4086, 4148, 4226, 4249, 4637], [4639, 4703, 4735, 4735, 5305], [5307, 5307, 5349, 5349, 5658], [5660, 5736, 5800, 5821, 6054], [6056, 6056, 6121, 6140, 8563], [8565, 8565, 8617, 8617, 8794]], "test": "valid"}
{"id": "tlXcDS", "name": "reflecting sphere", "author": "flo72", "description": "this is a simple example for a perfectly reflecting sphere", "tags": ["raymarching", "reflection"], "likes": 4, "viewed": 727, "published": "Public", "date": "1594756565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST .01\n\nvec3 bgcolor=vec3(.5,.7,.9);\n\nvec3 rotateY(vec3 p, float alpha){\n\tfloat px=p.x;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    \n \tp.x=c*px-s*p.z;\n    p.z=s*px+c*p.z;\n    \n    return p;\n}\n\nvec3 rotateX(vec3 p, float alpha){\n\tfloat py=p.y;\n    float c=cos(alpha);\n    float s=sin(alpha);\n    \n \tp.y=c*py-s*p.z;\n    p.z=s*py+c*p.z;\n    \n    return p;\n}\n\n\nfloat plane(vec3 p){\n \tvec3(0,1,0);\n    float d=p.y;\n    return d;\n}\n\nfloat box( vec3 p, vec3 b, float r )\n{  \n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sphere(vec3 p,vec3 m){\n   // p.z= mod(p.z,10.);\n   // p.x= mod(p.x,10.);\n\tfloat d=length(p-m)-2.;  \n    return d;\n}\n\nfloat objdist(int k, vec3 p){\n   \n    if(k==0) return plane(p);\n    if(k==1) return box(p-vec3(0,1.5,8),vec3(1),0.5);\n    if(k==2) return sphere(p,vec3(5.*cos(iTime),2,8.+5.*sin(iTime)));\n\n}\nvec3 getcolor(vec3 p){\n    float[20] d;\n    vec3 planecol=vec3(.7,.7,.9);\n    if((mod(p.x,10.) > 5. && mod(p.z,10.) > 5.)||(mod(p.x,10.) < 5. && mod(p.z,10.) < 5.)) \n        planecol=vec3(.5);\n    vec3[] colors=vec3[](planecol,\n                   vec3(0.9,0.3,0.3),\n                   vec3(0));\n    \n    for(int k=0;k<3;++k) d[k]=objdist(k,p);\n    \n    float dist=MAX_DIST;\n    vec3 color=bgcolor;    \n    for(int i=0;i<3;i++){\n        if(d[i]<dist){\n            color=colors[i];\n            dist=d[i];\n        }\n    }\n    return color;\n}\n\n\nfloat getdist(vec3 p){\n    float[20] d;\n    \n    for(int k=0;k<3;++k) d[k]=objdist(k,p);\n    \n    float dist=MAX_DIST;\n    for(int i=0;i<3;i++){\n        if(d[i]<dist){\n            dist=d[i];\n        }\n    }\n    return dist;\n}\n\nvec3 getnormal(vec3 p){\n    float d=getdist(p);\n    vec2 e=vec2(.01,0.);\n    \n    vec3 n=d-vec3(getdist(p-e.xyy),\n                  getdist(p-e.yxy),\n                  getdist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat raymarch(vec3 ro, vec3 rd){\n    \n    float dist = 0.;\n    vec3 p = ro;\n    \n    for(int i=0; i < MAX_STEPS ; i++){\n     float d=getdist(p);\n        p += d*rd;\n        dist += d;\n        if(d < MIN_DIST || d > MAX_DIST) break;\n    }\n    \n    return dist;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro= vec3(0,6,-4);\n    vec3 rd= normalize(vec3(uv.x,uv.y,1));\n   // float alpha=(iMouse.x-.5*iResolution.x)/iResolution.x*3.14; \n   // float beta=(iMouse.y-.5*iResolution.y)/iResolution.y*3.14; \n    float beta=-.3;\n    rd=rotateX(rd,-beta);\n   // rd=rotateY(rd,-alpha);\n    \n    \n    float d=raymarch(ro,rd);\n    vec3 p=ro+d*rd;   \n    vec3 l=vec3(3.,6,.0);\n\tvec3 n=getnormal(p);\n    vec3 col=getcolor(p);   \n    int i=0;\n    //reflecting sphere\n    while(length(col)==0.&& i<2){\n      rd = normalize(rd-2.*dot(n,rd)*n);\n      d=raymarch(p+n*MIN_DIST*2.,rd);\n      p=p+d*rd;\n      col=getcolor(p); \n      n=getnormal(p);  \n    }\n    \n    vec3 pl = normalize(l-p);\n    vec3 v = normalize(pl-2.*dot(n,pl)*n);\n \t\n    \n   //diffuse reflection and ambient light\n    float amb=0.5;\n    float diff= clamp((1.-amb)*dot(n,pl)+amb*dot(n,normalize(ro-p)),.0,1.);\n    col *=diff;\n    \n     //reflection\t\n    float t=pow(clamp(dot(v,rd),0.,1.),20.);\n    col=t*vec3(1)+(1.-t)*col;\n    \n    //shadow\n     if(d<MAX_DIST){\n       float ds=raymarch(p+n*MIN_DIST*2.,pl);\n       if( ds < length(l-p)) col=col*0.2;\n     }\n    \n    //fog\n    t=pow(clamp(d/MAX_DIST,0.,1.),1.);\n    col= t*bgcolor+(1.-t)*col;\n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 130, 130, 257], [259, 259, 293, 293, 420], [423, 423, 443, 443, 491], [493, 493, 531, 531, 624], [626, 626, 654, 704, 747], [749, 749, 778, 778, 939], [1708, 1708, 1731, 1731, 1921], [1923, 1923, 1956, 1956, 2189], [2191, 2191, 2248, 2298, 3616]], "test": "error"}
{"id": "tlXfzH", "name": "3D practice", "author": "reatured", "description": "Try 3D objects", "tags": ["learning"], "likes": 2, "viewed": 108, "published": "Public", "date": "1595974280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec3 rd, vec3 ro, vec3 p){\n    float d = length(cross(p-ro, rd))/length(rd);\n    \n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    \n    vec3 ro = vec3(0.,0.,-2.); //camera position\n    vec3 rd = vec3(uv, 0.) - ro; //camera to canvas direction\n\n    vec3 p =vec3(sin(iTime) * 1.5, sin(iTime+0.5)/3., 2. + cos(iTime) * 1.); // ball position\n    float d = dist(rd, ro, p); \n    \n    vec3 p2 = vec3(0.,0.,2.);\n    float d2 = dist(rd, ro, p2);\n    \n    // Time varying pixel color\n    vec3 col =vec3(0.);\n    \n    float timeStamp = max(0.4 - 0.1*sin(iTime*10.), sin(iTime * 3.5));\n    \n    vec3 ball1Color = vec3 (smoothstep(0.1, 0.09,d));\n    //vec3 ball2Color = vec3 (smoothstep(0.7 *timeStamp, 0.69*timeStamp,d2));\n    vec3 ball2Color = vec3 (smoothstep(0.7, 0.69,d2));\n    col += ball1Color;\n    if(p2.z<p.z){\n    \tcol = max(vec3(0.), col - ball2Color);\n    }\n    col += ball2Color *vec3(0.2 , 0.5* (sin(uv.x + iTime - 1.6) + 0.4), 0.4);\n    \n\tcol.r -= d*1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 109], [111, 111, 168, 218, 1205]], "test": "valid"}
{"id": "ts2XW1", "name": "create a camera ", "author": "eclypse", "description": "create a camera ", "tags": ["camera"], "likes": 0, "viewed": 49, "published": "Public", "date": "1593727662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    float t = iTime;\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\t\n\tuv -= .5;\n\t\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = vec3(3. * sin(t), 0., -3. * cos(t));\n    \n    float zoom = 1.;\n    \n    vec3 lookAt = vec3(.5);\n    \n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 rd = i - ro;\n    \n    \n\t\n\tvec3 p = vec3(sin(t), 0., 3. + cos(t));\n\t\n\tfloat d = 0.;\n    \n    d += DrawPoint(ro, rd, vec3(0., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 1.));\n    \n\t\n\tfragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 88], [90, 90, 133, 133, 214], [216, 216, 273, 273, 1182]], "test": "valid"}
{"id": "tt2cRK", "name": "Apollonian-2020-v2", "author": "jorge2017a1", "description": "Apollonian-2020", "tags": ["apollonian", "2020"], "likes": 4, "viewed": 52, "published": "Public", "date": "1594863424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu..........\n//y modificado por Jorge flores///---2020-jul-15\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ITERATION 8\n\nvec4 orb;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n\n\n///---------------------------------------\nfloat intersectSDF(float distA, float distB) \n{\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n///---------------------------------------\n\n\nfloat apollonian(vec3 p)\n{\n   \tfloat scale = 1.0;\n\torb = vec4(9999.0); \n    float tmp;\n\t\n\tfor( int i=0; i < ITERATION;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n        float r2 = dot(p,p);\n        orb = min( orb, vec4(abs(p+ sin(p)),r2) );\n        float k = 1.8*cos(iTime*0.45)/ r2;\n\t\tp *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n    \n    \n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    vec3 q=p;\n\n    float d0=apollonian(p*0.41)*5.;;\n    //float d1=abs(p.y-0.02);\n    float d3 = box(q+vec3(0.,-2.,0.), vec3(4.,4.,4.0));\n    \n    float d=d0;\n    d= intersectSDF(d3, d0); \n    \n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n    \n    return normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\n                          map(p + e.yyx)-map(p - e.yyx)));\n    \n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.y * 2.0);\n\n    float t = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        float c = map(ro + rd*t);\n        if( c<0.5*pixel_size*t ) break;\n        t += c;\n        if( t>100.0 ) return -1.0;\n    }\n    return t;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    \n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( abs(res)<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tonemap(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\n\n\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n  \n    float tt=iTime*0.5;\n    \n    vec3 lookat = vec3(0.0, 1.5, 0.);\n\tvec3 ro = 1.4*vec3(-1.+2.0*cos(tt), 1.5,-4.5+2.0*sin(tt));\n    ro=get_mouse(ro);\n    \n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-12., 2.0, -5.));\n        \n        float ao = pow(clamp(orb.w*2.0,0.0,1.0), 1.2);\n        float c0=pow(clamp(orb.w, 0.0, 1.0), 2.);\n        float c1=pow(clamp(orb.x, 0.0, 1.0), 2.);\n    \tvec3 col0=c0*vec3(0.0,1.0,1.0);\n\t\tvec3 col1=vec3(1.);\n        col1 = mix(col1, vec3(0.4,1.0,0.5), clamp(3.5*orb.y,0.,1.));\n\n\n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float bac2=max(0.0, dot(n, -vec3(0.,1.,0.)));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 64.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.005, 32.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.5)*amb*ao;\n        lin+=vec3(2.5,1.8,0.7)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(1.,0.8,0.3)*bac2*ao;\n        lin+=vec3(spec*6.2)*sha;\n        \n       \tcol=(lin*col1-col0)*.2;\n        col=mix(col,vec3(0.), 1.0-exp(-0.001*t*t)); \n        col *= min(20000.0*exp(-0.74*t),1.0);\n\n     }\n    \n    col=tonemap(col);\n    //col=pow(col,vec3(1.3,1.,1.));\n    col=pow(clamp(col,0.0,1.0),vec3(0.25));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    \n    \n    \n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2cRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[351, 394, 441, 441, 473], [475, 475, 518, 518, 550], [552, 552, 600, 600, 633], [680, 680, 706, 706, 1025], [1027, 1027, 1054, 1054, 1153], [1155, 1155, 1174, 1174, 1384], [1386, 1386, 1411, 1411, 1629], [1631, 1631, 1674, 1674, 1928], [1930, 1930, 1995, 1995, 2268], [2270, 2270, 2292, 2292, 2478], [2484, 2528, 2545, 2545, 2616], [2641, 2733, 2759, 2759, 3022], [3026, 3026, 3083, 3083, 4933]], "test": "valid"}
{"id": "tt2cWh", "name": "Make Fun With Volumetric Cloud", "author": "shicz86", "description": "a modified version of volumetric cloud for learning purpose,inspired by kaneta、Keyaki、Sebastian Lague(Youtube).\nhttps://www.shadertoy.com/view/WdXGRj\nhttps://www.shadertoy.com/view/Wsf3Dl\nhttps://shaderbits.com/blog/creating-volumetric-ray-marcher/", "tags": ["volumetriccloudraymarching"], "likes": 18, "viewed": 338, "published": "Public", "date": "1594353261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ENABLE_JITTER 1\n#define ENABLE_SDF_SPHERE 0\nfloat jitter;\n#define MAX_STEPS 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2.\n\n//shift vec3\nmat3 m = mat3(0.,0.8,0.6,\n              -0.8,0.36,-0.48,\n              -0.6,-0.48,0.64);\n\n//1d noise function\nfloat hash11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n//value noise function\nfloat noise31(in vec3 n)\n{\n\tvec3 p = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = p.x+p.y*57.+p.z*113.;\n    float r = mix(mix(mix(hash11(q+0.),hash11(q+1.),f.x),\n                      mix(hash11(q+57.),hash11(q+58.),f.x),f.y),\n                  mix(mix(hash11(q+113.),hash11(q+114.),f.x),\n                      mix(hash11(q+170.),hash11(q+171.),f.x),f.y),f.z);\n    return r;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f = 0.5*noise31(p);p = m*p*2.02;\n    f += 0.25*noise31(p);p = m*p*2.03;\n    f += 0.125*noise31(p);p = m*p*2.01;\n    f += 0.0625*noise31(p);\n    return f;\n}\n\n//sdf of torus\nfloat sdfTorus(vec3 p,vec2 r)\n{\n\tvec2 q = vec2(length(p.xz)-r.x,p.y);\n    return length(q)-r.y;\n}\n\n//sdf of sphere\nfloat sdfSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\n//contructive solid geometry\nfloat intersectSdf(float distA,float distB)\n{\n\treturn max(distA,distB);\n}\n\nfloat unionSdf(float distA,float distB)\n{\n\treturn min(distA,distB);\n}\n\nfloat differenceSdf(float distA,float distB)\n{\n\treturn max(distA,-distB);\n}\n\nfloat sdfScene(vec3 p,vec2 r1,float r2)\n{\n\tfloat distA = sdfTorus(p,r1);\n    float distB = sdfSphere(p,r2);\n    return unionSdf(distA,distB);\n}\n\nfloat map(in vec3 p)\n{\n    //shift vec3 p to make more random\n\tvec3 q = p - vec3(0.,.5,1.);\n    float f = fbm(q);\n    \n    //params of torus\n    float sdfLevel = 1.;vec2 r1 = vec2(7.,.75);float r2 = .5;float pScaleFator = 1.85;float fScaleFator = 3.;\n    float d = 0.;\n#if ENABLE_SDF_SPHERE\n    d = sdfLevel-sdfScene(p*pScaleFator,r1,r2)+f*fScaleFator;\n#else\n    d = sdfLevel-sdfTorus(p*pScaleFator,r1)+f*fScaleFator;\n#endif\n    //min(max(0.,d),1.);\n    return clamp(d,0.,1.);\n}\n\nvec4 cloudRayMarching(vec3 camPos,vec3 viewRay,vec3 lightDir,float index)\n{\n    lightDir = normalize(lightDir);\n    vec3 lightEnergy = vec3(0.);\n    \n    vec3 ambientColor = vec3(0.15,0.45,1.1);\n    vec3 ambientSampleOffset = vec3(0.,0.2,0.);\n    float ambientSampleScaleFator = 1.;\n    \n    float stepSize = VOLUME_LENGTH/float(MAX_STEPS);\n    float shadowStepSize = SHADOW_LENGTH/float(SHADOW_STEPS);\n    \n    float curDensity = 0.;\n    float transmittance = 1.;\n    \n    //params 1:index < 0.5,you can change the density of three channel\n    float volumeDensity = 0.633;\n    float redChannelDensity = 0.5+0.4*sin(iTime*.5);\n    float shadowDensityScaleFator = 0.75;\n    vec3 shadowDensity = vec3(redChannelDensity,0.3,0.2)*shadowDensityScaleFator;//reference value of redChannelDensity:vec3(.9,0.1,0.3)\n    \n    //param 2:index >= 0.5,fixed density for three channel\n    float densityMultiply = 20.0;\n    float denstiyScaleFator = 0.75;\n    float shadowTermMultiply = 3.;\n    \n    if(index < 0.5) {ambientSampleScaleFator = .5;}else {ambientSampleScaleFator = .2;}   \n    \n    vec3 pos = camPos+viewRay*jitter*stepSize;\n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float curSample = map(pos);\n        if(curSample > 0.001)\n        {\n            vec3 lPos = pos;\n            float shadowDist = 0.;\n            for(int s = 0;s < SHADOW_STEPS;s++)\n            {\n                lPos += lightDir*shadowStepSize;\n                float lSample = map(lPos);\n                shadowDist += lSample;\n            }\n            if(index < 0.5)\n            {\n\t\t\t\tcurDensity = clamp(curSample*volumeDensity,0.,1.);\n                vec3 shadowTerm = exp(-shadowDist*shadowDensity);\n                lightEnergy += shadowTerm*curDensity*transmittance;\n            }\n            else\n            {\n            \tcurDensity = clamp((curSample/float(MAX_STEPS))*densityMultiply,0.,1.)*denstiyScaleFator;\n                float shadowTerm = exp(-shadowDist/float(SHADOW_STEPS)*shadowTermMultiply);\n                lightEnergy += shadowTerm*curDensity*transmittance;\n            }\n\n            transmittance *= 1.-curDensity;\n\n            //ambient color\n            lightEnergy += exp(-map(pos+ambientSampleOffset)*ambientSampleScaleFator)*curDensity*transmittance*ambientColor;\n        }\n        pos += viewRay*stepSize;\n    }\n    \n    return vec4(lightEnergy,transmittance);\n}\n\n//观察矩阵 view transform\nmat3 camera(vec3 camPos,vec3 lookAtPos,float rollDegree)\n{\n\tvec3 w = normalize(lookAtPos - camPos);\n    vec3 up = vec3(sin(rollDegree),cos(rollDegree),0.);\n    vec3 u = normalize(cross(w,up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t//[-iResolution.xy,iResolution.xy]/min(iResolution.x,iResolution.y)\n    //so x = [-iResolution.x/iResolution.y,iResolution.x/iResolution.y]\n    //and y = [-1,1]\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n#if ENABLE_JITTER\n    jitter = hash11(uv.x+uv.y*57.+iTime);\n#endif\n    \n    vec3 lightDir = vec3(1.,2.,1.);\n    vec3 lightColor = vec3(1.,.7,.3);\n    \n    //相机位置 camera pos\n    float camRotateRadius = 8.0;\n    float camRotateSpeed = 0.333;\n    float camPosY = -5.5;\n    vec3 camPos = vec3(cos(iTime*camRotateSpeed)*camRotateRadius,camPosY,sin(iTime*camRotateSpeed)*camRotateRadius);\n    \n    //相机盯着的位置 lookat pos\n    float lookAtPosY = -.5;\n    vec3 lookAtPos = vec3(0.,lookAtPosY,0.);\n    \n    //相机翻滚角 roll degree\n    float rollDegree = 0.;\n    mat3 viewMat = camera(camPos,lookAtPos,rollDegree);\n    \n    //成像平面距离z轴正向距离\n    float planeZ = 1.75;\n    vec3 rayOrigin = vec3(uv,planeZ);\n    //变换后的射线向量\n    vec3 viewRay = viewMat * normalize(rayOrigin);\n \n    //左右分屏切换不同效果\n    float uvMovingSpeed = 1.25;\n    float uvMovingScaleFator = 1.5;\n    float uvMoving = uv.x+sin(iTime*uvMovingSpeed)*uvMovingScaleFator;\n    \n    float index = 0.;\n    vec4 col = vec4(0.);\n    //volumetric cloud\n    if(uvMoving < 0.)\n    {\n    \tcol = cloudRayMarching(camPos,viewRay,lightDir,0.);\n    }\n    else\n    {\n    \tcol = cloudRayMarching(camPos,viewRay,lightDir,1.);\n    }\n    \n    //和天空背景色混合 color gradient\n    vec3 skyColorBottom = vec3(.3,.6,1.);\n    vec3 skyColorTop = vec3(.05,.35,1.);\n    float skyColorOffsetY  = 0.75;\n    vec3 result = col.rgb + mix(skyColorBottom,skyColorTop,uv.y+skyColorOffsetY)*col.a;\n    \n    float sunDot = clamp(dot(viewRay,normalize(lightDir)),0.,1.);\n    //控制阳光强度\n    float sunDotPower = 4.;\n    float lightMultiply = .25;\n    result += lightColor*pow(sunDot,sunDotPower)*lightMultiply;\n    \n    result *= vec3(smoothstep(0.0,0.02,abs(uvMoving)));\n    \n    //gamma correction\n    result = pow(result,vec3(1./2.2));\n    \n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2cWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 285, 308, 308, 344], [346, 369, 395, 395, 770], [772, 772, 791, 791, 961], [963, 978, 1009, 1009, 1075], [1077, 1093, 1126, 1126, 1149], [1151, 1180, 1225, 1225, 1253], [1255, 1255, 1296, 1296, 1324], [1326, 1326, 1372, 1372, 1401], [1403, 1403, 1444, 1444, 1546], [1548, 1548, 1570, 1609, 2026], [2028, 2028, 2103, 2103, 4392], [4394, 4424, 4482, 4482, 4678], [4680, 4680, 4737, 4900, 6875]], "test": "valid"}
{"id": "tt2yWK", "name": "SimpleScene", "author": "fayolle", "description": "Simple CSG scene", "tags": ["csg"], "likes": 2, "viewed": 44, "published": "Public", "date": "1595420735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\n// ----------------- code simple scene\nfloat sdDiff(float f1, float f2)\n{\n    return min(f1, -f2);\n}\n\nfloat cylinderX(in vec3 p, in vec3 c, float r)\n{\n    float dy, dz;\n    dy = p.y - c.y;\n    dz = p.z - c.z;\n    return r - sqrt(dy * dy + dz * dz);\n}\n\nfloat cylinderY(in vec3 p, in vec3 c, float r)\n{\n    float dx, dz;\n    dx = p.x - c.x;\n    dz = p.z - c.z;\n    return r - sqrt(dx * dx + dz * dz);\n}\n\nfloat cylinderZ(in vec3 p, in vec3 c, float r)\n{\n    float dx, dy;\n    dx = p.x - c.x;\n    dy = p.y - c.y;\n    return r - sqrt(dx * dx + dy * dy);\n}\n\n// unit cube centered at origin\nfloat cube(in vec3 p)\n{\n    vec3 pl = p + 0.5;\n    vec3 pr = 0.5 - p;\n    return min(min(min(pl.x, pr.x), min(pl.y, pr.y)), min(pl.z, pr.z));\n}\n\nfloat scene(in vec3 p)\n{\n    float cu = cube(p);\n    float cx = cylinderX(p, vec3(0.0, 0.0, 0.0), 0.25);\n    float cy = cylinderY(p, vec3(0.0, 0.0, 0.0), 0.25);\n    float cz = cylinderZ(p, vec3(0.0, 0.0, 0.0), 0.25);\n    return sdDiff(sdDiff(sdDiff(cu, cx), cy), cz);\n}\n\n// ----------------- end of code simple scene\n\n//------------------------------------------------------------------\n\nfloat map(in vec3 p)\n{\n    return -scene(p);\n}\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n    float res = -1.0;\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for (int i = 0; i < 70 && t < tmax; i++)\n    {\n        float h = map(ro + rd * t);\n        if (abs(h) < (0.0001 * t))\n        {\n            res = t;\n            break;\n        }\n        t += h;\n    }\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy) +\n                     e.yyx * map(pos + e.yyx) +\n                     e.yxy * map(pos + e.yxy) +\n                     e.xxx * map(pos + e.xxx));\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y, 0.0) * 0.3;\n    float t = castRay(ro, rd);\n\n    if (t != -1.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        col = 0.2 + 0.18 * sin(vec3(0.0, 0.5, 1.0));\n\n        vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));\n        vec3 hal = normalize(lig - rd);\n        float amb = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.2, 0.2, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n                    dif *\n                    (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n        vec3 lin = vec3(0.0);\n        lin += 3.80 * dif * vec3(1.30, 1.00, 0.70);\n        lin += 0.55 * amb * vec3(0.40, 0.60, 1.15);\n        lin += 0.85 * dom * vec3(0.40, 0.60, 1.30);\n        lin += 0.55 * bac * vec3(0.25, 0.25, 0.25);\n        lin += 0.25 * fre * vec3(1.00, 1.00, 1.00);\n        col = col * lin;\n        col += 7.00 * spe * vec3(1.10, 0.90, 0.70);\n\n        col = mix(col, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));\n    }\n    else\n    {\n        col = vec3(1.0, 1.0, 1.0);\n    }\n\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 + iTime * 1.5;\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro = ta + vec3(2.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 2.5 * sin(0.1 * time + 6.0 * mo.x));\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 tot = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++)\n        for (int n = 0; n < AA; n++)\n        {\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif\n\n            vec3 rd = ca * normalize(vec3(p, 2.5));\n            vec3 col = render(ro, rd);\n            col = pow(col, vec3(0.4545));\n            tot += col;\n#if AA > 1\n        }\n    tot /= float(AA * AA);\n#endif\n\n    fragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2yWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 53, 87, 87, 114], [116, 116, 164, 164, 264], [266, 266, 314, 314, 414], [416, 416, 464, 464, 564], [566, 598, 621, 621, 741], [743, 743, 767, 767, 1012], [1131, 1131, 1153, 1153, 1177], [1179, 1179, 1218, 1218, 1530], [1532, 1596, 1626, 1626, 1868], [1870, 1870, 1907, 1907, 3347], [3349, 3349, 3399, 3399, 3578]], "test": "valid"}
{"id": "tt2yWV", "name": "Basic Mandelbrot set display", "author": "Nrx", "description": "Basic Mandelbrot set display.\n\nAn anti-aliased version can be seen [url=https://www.shadertoy.com/view/Wl2cDt]here[/url].", "tags": ["mandelbrot"], "likes": 0, "viewed": 185, "published": "Public API", "date": "1595439666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C1\tvec2 (0.2, 0.55)\n#define C2\tvec2 (-0.743644, 0.131826)\n#define N\t900.0\n#define PI\t3.14159265358979\n\nmat2 Rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat Mandelbrot (in vec2 c)\n{\n\tvec2 m;\n\n\t#ifndef NO_OPTIM\n\tm = vec2 (c.x + 1.0, c.y);\n\tif (dot (m, m) < 0.0625) {\n\t\treturn 1.0;\n\t}\n\n\tm = vec2 (c.x - 0.25, c.y);\n\tfloat l = dot (m, m);\n\tif (c.x < sqrt (l) - 2.0 * l + 0.25) {\n\t\treturn 1.0;\n\t}\n\t#endif\n\n\tm = c;\n\tfor (float n = 0.0; n < N; ++n) {\n\t\tif (dot (m, m) > 256.0) {\n\t\t\treturn n / N;\n\t\t}\n\t\tm = vec2 (m.x * m.x - m.y * m.y, 2.0 * m.x * m.y) + c;\n\t}\n\treturn 1.0;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\tfloat time = iTime * 0.1;\n\tfloat zoom = 1.5 * pow (0.5, 18.0 * (0.5 - 0.5 * cos (time * 2.0)));\n\tfloat angle = PI * 6.0 * cos (time);\n\tvec2 translate = mix (C1, C2, smoothstep (-0.4, 0.4, sin (time)));\n\n\tc = zoom * Rotate (angle) * c + translate;\n\tfloat m = Mandelbrot (c);\n\tfragColor = vec4 (m, pow (m, 0.6), pow (m, 0.3), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2yWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 141, 141, 219], [221, 221, 251, 251, 638], [640, 640, 696, 696, 1092]], "test": "valid"}
{"id": "ttBcRV", "name": "Flying through glowing stars", "author": "mrange", "description": "License CC0: Flying through glowing stars\nThe result of playing around trying to improve an old shader", "tags": ["2d"], "likes": 11, "viewed": 357, "published": "Public API", "date": "1594818145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Flying through glowing stars\n//  The result of playing around trying to improve an old shader\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in vec3 co) {\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nfloat starn(vec2 p, float r, int n, float m) {\n  // From IQ: https://www.shadertoy.com/view/3tSGDy\n  // https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n  \n  // Minor tweak to use SABS over abs to smooth inner corners\n  // SABS: https://www.shadertoy.com/view/Ws2SDK\n\n  // next 4 lines can be precomputed for a given shape\n  float an = 3.141593/float(n);\n  float en = 3.141593/m;  // m is between 2 and n\n  vec2  acs = vec2(cos(an),sin(an));\n  vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n  float bn = mod(atan(p.x,p.y),2.0*an) - an;\n  p = length(p)*vec2(cos(bn),SABS(sin(bn), 0.15));\n  p -= r*acs;\n  p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n  return length(p)*sign(p.x);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  vec3 xyz = mix(back.xyz*back.w, front.xyz, front.w);\n  float w = mix(back.w, 1.0, front.w);\n  return vec4(xyz, w);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 planeCol(vec3 ro, vec3 rd, float n, vec3 pp) {\n  const float s = 0.5;\n  \n  vec2 p = pp.xy;\n  float z = pp.z;\n  vec2 dpy = dFdy(p);\n  float aa = length(dpy);\n\n  p -= (1.0+5.0*(pp.z - ro.z))*offset(z).xy;\n  \n  p *= s;\n  float r = hash(vec3(floor(p+0.5), n));\n  p = fract(p+0.5)-0.5;\n  rot(p, ((TAU*r+n)*0.25));\n  float d = starn(p, 0.20, 3 + 2*int(3.0*r), 3.0);\n  d -= 0.06;\n  d/=s;\n  \n  float ds = -d+0.03;\n  vec3 cols = hsv2rgb(vec3(337.0/360.0+0.1*sin(n*0.3), 0.8, 0.54+0.2*sin(n*0.3)));\n  float ts = 1.0 - smoothstep(-aa, 0.0, ds);\n  vec4 cs =  vec4(cols, ts*0.93);\n\n  float db = abs(d) - (0.06);\n  db = abs(db) - 0.03;\n  db = abs(db) - 0.00;\n  db = max(db, -d+0.03);\n    vec3 colb = vec3(1.0, 0.7, 0.5);\n  float tb = exp(-(db)*30.0*(1.0 - 10.0*aa));\n  vec4 cb = vec4(1.5*colb, tb);\n\n  vec4 ct = alphaBlend(cs, cb);\n\n  return ct;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + (2.0-tanh(length(p)))*ww);\n  \n  vec4 col = vec4(vec3(0.0), 1.0);\n\n  const float planeDist = 1.0;\n  const int furthest = 6;\n  const int fadeFrom = furthest-3;\n\n  float nz = floor(ro.z / planeDist);\n\n  for (int i = furthest; i >= 1; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n    \n    float pd = (pz - ro.z)/rd.z;\n    \n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n      \n      vec4 pcol = planeCol(ro, rd, nz+float(i), pp);\n      float fadeIn = 1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), pp.z-ro.z);\n      pcol.xyz *= sqrt(fadeIn);\n  \n      col = alphaBlend(col, pcol);\n    }\n  }\n  \n  return col.xyz*col.w;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm = TIME*0.65;\n  \n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+1.5*ddro, ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  \n  const float fadeIn = 2.0;\n    \n  return col*smoothstep(0.0, fadeIn, TIME);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcRV.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[419, 419, 441, 441, 610], [612, 612, 636, 636, 719], [721, 721, 767, 1066, 1455], [1457, 1457, 1497, 1497, 1616], [1618, 1618, 1651, 1651, 1736], [1738, 1738, 1760, 1760, 1894], [1896, 1896, 1919, 1919, 1995], [1997, 1997, 2021, 2021, 2099], [2101, 2101, 2152, 2152, 2939], [2941, 2941, 2997, 2997, 3687], [3689, 3689, 3726, 3726, 3934], [3936, 3936, 3965, 3965, 4355], [4357, 4357, 4409, 4409, 4571]], "test": "valid"}
{"id": "ttBcW3", "name": "Random Symbols", "author": "BackwardsCap", "description": "Randomly generated symbols", "tags": ["procedural", "circle", "random"], "likes": 7, "viewed": 252, "published": "Public API", "date": "1595603847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define PI 3.1415927\n#define SS(U) smoothstep(.05,0.,U)\n\nfloat rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1283,8941.1283)))*(12893.128933));\n}\n\nbool removed(float h, vec2 p)\n{\n    float h2 = rand(vec2(20.+h*(+floor(p.y))+10.84));\n    return h*dot(h,h2)*5.<=.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    \n    vec2 p = ((2.0*f-R)/R.y),u=p;\n    p = vec2(log(length(p.xy)), atan(p.y,p.x));\n    p*= (6.0/PI)*10.;\n    p+=vec2(p.y/3.34-iTime*3.,6.);    \n    vec2 lp = fract(p);\n    p=floor(p);\n    float hash = rand(p),\n          size = 4.;\n    vec3 col = vec3(0.);\n    if(!removed(hash, p))col=vec3(SS(length(lp-.5)-.4));       \n    p=mod(p+2.,vec2(size+2.*4.,10.));    \n    col*=min(length(u)*4.,1.);\n    if(abs(p.x)<=size&&abs(p.y)<=size)c.rgb=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 181], [183, 183, 214, 214, 301], [303, 303, 344, 344, 792]], "test": "error"}
{"id": "ttBcWy", "name": "球面坐标和平面坐标", "author": "limengfan", "description": "黎曼几何下，球面的平铺坐标和球面坐标的变换", "tags": [], "likes": 1, "viewed": 170, "published": "Public API", "date": "1595246144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pi = 3.14159265359;\n    \n    float theta = uv.y*pi;\n    float phi = uv.x*pi*2.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(vec3(theta,phi/2.0,0));\n    vec3 bcol = col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //float x = sin(theta)*cos(phi);\n    //float y = sin(theta)*sin(phi);\n    //float z = cos(theta);\n    \n    vec2 newuv = fragCoord/iResolution.yy;\n    if (newuv.x>1.0) {\n        fragColor = vec4(bcol,1.0);\n    }\n    else {\n        newuv *= 2.0;\n        newuv -= vec2(1,1);\n        if (length(newuv)>1.0 ){\n        \tfragColor = vec4(bcol,1.0);\n        }\n        else {               \n        \ttheta = acos(newuv.y);\n            //https://blog.csdn.net/zghforever/article/details/88644499\n            float c = newuv.x;\n            float a = cos(iTime) * sin(theta);\n            float b = sin(iTime) * sin(theta);\n            if (sin(iTime)>0.0) {\n                float t = (b+sqrt(b*b+a*a-c*c))/(a+c);\n                phi = 2.0*atan(t);\n            }\n            else {\n                float t = (b-sqrt(b*b+a*a-c*c))/(a+c);\n                phi = 2.0*atan(t);\n            }\n            \n    \t\t//phi = asin(newuv.x/sin(theta));\n    \t\tcol = 0.5 + 0.5*cos(vec3(theta,phi/2.0,0));\n    \t\tfragColor = vec4(col,1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1441]], "test": "valid"}
{"id": "ttBczh", "name": "Sinusoids Wave 2D - v4: bump", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/3lScRR[/url]\nWith bump map ( with constrant-contrast blending over 7x7 neighborhood )\n\nSee analytic derivatives version here: [url]https://www.shadertoy.com/view/wljyz1[/url]\n", "tags": ["bump", "2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 2, "viewed": 216, "published": "Public API", "date": "1593691779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/wtSczh\n// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y,  C,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    float d, o = 0., t = o;\n    for (int k=0; k<49; k++)\n        C = U - round((U+vec2(k%7-3,k/7-3))*.2) / .2 ,\n        V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(0.,1.-.05*dot(C,C)), d*=d*d*d,\n        o += sin( 36.*length(V) -0.*iTime +(U-.2*C).x ) * d   ,\n        t += d*d;\n    t = ( .5 + .1*o/sqrt(t) )* smoothstep(1.,-1.,U.y -37.);\n    O += sqrt( .4 + dot( vec2(dFdx(t),dFdy(t)) , cos(2.*iTime+vec2(0,11)) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 182, 182, 730]], "test": "valid"}
{"id": "ttByDK", "name": "v0TriLattice4.glsl", "author": "jorge2017a1", "description": "///source code of ShaderSketches", "tags": ["v0trilattice4glsl"], "likes": 6, "viewed": 70, "published": "Public", "date": "1595382905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///source code of ShaderSketches\n\nconst float PI = 3.14159265359;\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float sxf = fract(sx);\n    float offs = step(fract(1.0 - uv.y), sxf);\n    return vec2(floor(sx) * 2.0 + sxf + offs, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = sin(iTime * 1.2);\n\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n    uv.x += uv.y * s * 0.1;\n    vec2 p = uv2tri(uv * (8.0 + s));\n\n    float r1 = rand(floor(p) * 0.011 + 0.345) * PI * 2.0;\n    float r2 = rand(floor(p) * 0.007 + 0.789) * PI * 2.0;\n\n    p.x += p.y / 2.0; // unskew\n\n    vec2 dir = vec2(cos(r1), sin(r1));\n    float t = dot(p, dir) + r2 + iTime * 2.94;\n\n    float cr = sin(t * 1.000) * 0.4 + 0.61;\n    float cg = sin(t * 0.782) * 0.2 + 0.22;\n    float cb = sin(t * 0.751) * 0.3 + 0.32;\n\n    fragColor = vec4(cr, cg, cb, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 88, 88, 158], [160, 160, 182, 182, 357], [359, 359, 416, 416, 995]], "test": "valid"}
{"id": "ttByRy", "name": "magic wood", "author": "favarjooy86", "description": "No Description ", "tags": ["wood"], "likes": 1, "viewed": 49, "published": "Public", "date": "1594665759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col=vec3(0.5-.2*sin( 5.0*iTime +10.0*sin(9.0*uv.y) + 100.0*sin(16.0*uv.x) )+.2*sin(9.0*uv.y),0,0);\n    col.y=.5*col.x;\n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 363]], "test": "valid"}
{"id": "ttByWK", "name": "v0Discs4.glsl", "author": "jorge2017a1", "description": "v0Discs4.glsl", "tags": ["v0discs4glsl"], "likes": 5, "viewed": 61, "published": "Public", "date": "1595449875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 palette(float z)\n{\n    float g = 0.6 + 0.4 * sin(z * 8.0 + iTime * 2.0);\n    float b = 0.5 + 0.4 * sin(z * 5.0 + iTime * 3.0);\n    return vec3(1.0, g, b);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )    \n{\n    float scale = iResolution.y / 5.0;\n    vec2 p = fragCoord.xy / scale;\n\n    vec2 offs1 = vec2(iTime * 0.53, sin(iTime * 1.35) * 0.2);\n    vec2 offs2 = vec2(iTime * 0.81, sin(iTime * 1.19) * 0.2);\n\n    vec2 p1 = p + offs1;\n    vec2 p2 = p + offs2 - 0.5;\n\n    float z1 = rand(0.19 * floor(p1));\n    float z2 = rand(0.31 * floor(p2));\n\n    p1 = fract(p1) - 0.5;\n    p2 = fract(p2) - 0.5;\n\n    float s1 = 0.9 + sin(iTime * (0.6 + z1)) * 0.6;\n    float s2 = 0.9 + sin(iTime * (0.6 + z2)) * 0.6;\n\n    float d1 = (0.25 - abs(0.5 - fract(length(p1) * s1 * 10.0 + 0.26))) / (s1 * 10.0);\n    float d2 = (0.25 - abs(0.5 - fract(length(p2) * s2 * 10.0 + 0.26))) / (s2 * 10.0);\n\n    vec3 c1 = palette(z1) * saturate(d1 * scale);\n    vec3 c2 = palette(z2) * saturate(d2 * scale);\n\n    float a1 = saturate((0.5 - length(p1)) * scale);\n    float a2 = saturate((0.5 - length(p2)) * scale);\n\n    vec3 c1on2 = mix(c2 * a2, c1, a1);\n    vec3 c2on1 = mix(c1 * a1, c2, a2);\n\n    fragColor = vec4(mix(c2on1, c1on2, step(z1, z2)), 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 54], [56, 56, 77, 77, 147], [149, 149, 172, 172, 310], [314, 314, 375, 375, 1391]], "test": "valid"}
{"id": "ttByWm", "name": "noise fiddlin v2", "author": "surgery_waves", "description": "fasdf", "tags": ["noise", "random"], "likes": 0, "viewed": 41, "published": "Public", "date": "1594520693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st, vec2 coeff, float scaler) {\n    return fract(sin(dot(st.xy, coeff) * scaler));\n    }\n                 \nfloat noise (in vec2 st, vec2 coeff, float scaler) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i, coeff, scaler);\n    float b = random(i + vec2(1.0, 0.0), coeff, scaler);\n    float c = random(i + vec2(0.0, 1.0), coeff, scaler);\n    float d = random(i + vec2(1.0, 1.0), coeff, scaler);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n                 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvhalf = uv.xy / 2. * 0.5;\n    \n    float centerDist = distance(uv.xy, uvhalf);\n    \n    float pos = noise(uv.xy * 0.4 + 1.3 * sin(dot(1.-uv.yx, vec2(centerDist)) * centerDist + iTime * 0.75161), \n                      vec2(431.51,3330.311),\n                      23.21 + centerDist);\n  \n    // Time varying pixel color\n    vec3 col = iTime * pos / centerDist * vec3(uv.xy, sin(centerDist * 4. * radians(360.) + 3.))+vec3(0.10,0.3,0);\n\n    // Output to screen\n    fragColor = vec4(1. / col * vec3(0.33 * sin(iTime * 0.0014 * centerDist) + 0.251,\n                                0.144 + centerDist,\n                                centerDist),\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 110], [129, 129, 181, 181, 758], [779, 779, 836, 886, 1612]], "test": "valid"}
{"id": "ttByWt", "name": "Sky, Sun, Simple Lens flare", "author": "devugspe", "description": "This Shader Code made By Me and Open Source, so you can Use this Code without Credit ^_^ ", "tags": ["simple", "sun", "sky", "minecraft", "shader", "scattering", "lensflare", "lensflare", "atmosphere", "mcpe"], "likes": 3, "viewed": 305, "published": "Public", "date": "1595667839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n//  By Dimas Adiyaksa (Developer of Unreal Graphic Shader PE)\n\n//uniform vec2 iResolution;\n//uniform vec2 iMouse;\n//uniform float TIME;\n\n//#define time iTime\n//#define resolution iResolution\n#define saturate(x) clamp(x, 0., 1.)\n//#define gl_FragCoord fragCoord\n\nvec4 lensflare(vec2 uv, vec2 uvm){\n\tuv *= length(uv);\n\tfloat l1 = saturate (pow(1. -  length(uv - .5 * uvm), 7.))*.5;\n\n\tvec4 lensf = l1 * vec4(1, 0, 1, .3);\nreturn lensf;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mm = iMouse.xy /  iResolution.xy;\n\tmm.x *= iResolution.x / iResolution.y;\n\n\t// Sky\n\tvec4 sky = mix(vec4(.1, .3, .8, 1), vec4(.3, .7, 1, 1), uv.y);\n\n  if(mm.y == .0){\n\tmm += sin(iTime * .1);}\n\tfloat lp = length(uv - mm);\n\tfloat round = saturate(pow(1. - lp * 4., 10.));\n\tfloat gp = saturate(pow(1. - lp * 1., 6.));\n\n\t// Glare\n\tvec4 glare = vec4(.6, .2, .6, .01) * gp;\n\n\t// Sun\n\tvec4 sun = vec4(1) * round;\n\tsun += glare;\n\tsun += lensflare (uv, mm);\n\n\tfragColor = sky + sun;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 392, 392, 530], [532, 532, 587, 587, 1151]], "test": "valid"}
{"id": "ttByzG", "name": "It's a donut!", "author": "TheGreatMurloc", "description": "Eyy... a donut!", "tags": ["donut"], "likes": 1, "viewed": 53, "published": "Public", "date": "1594662474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\n#define BLUR 0.005\n\n//Converting rgb from 0-255 to 0-1 (Easier color picking)\nvec3 rgb(float r, float g, float b)\n{\n    vec3 col = vec3(r,g,b);\n    col /= 255.;\n    return col;\n}\n\nfloat donutMask(vec2 uv, float size, float thickness, float blur)\n{\n    //Main circle\n    float donut = smoothstep(size,size+blur,1.-length(uv));\n    \n    //The middle hole\n    donut -= smoothstep(size+thickness,size+thickness+blur,1.-length(uv));\n    \n    return donut;\n}\n\nfloat rect(vec2 uv, float width, float height, float blur)\n{\n    float mask = 1.;\n    mask *= smoothstep(abs(uv.x),abs(uv.x)+blur,width);\n    mask *= smoothstep(abs(uv.y),abs(uv.y)+blur,height);\n    return mask;\n}\n\n//Found this uv rotation somewhere on Stack overflow ^^\nvec2 rotateUV(vec2 uv, float rotation, float mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nfloat rnd(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rndLum(vec2 tile, float time, float id)\n{\n    return .5*(sin(time*rnd(tile+id))+1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\t//\tvec2(0,0) = center of the screen\n    uv.x *= iResolution.x / iResolution.y;\t//\t16/9 aspect\n    \n    vec3 col = vec3(0.);\n    \n    //Baked bottom--------------------------------------------------------------------\n    float bottomMask = donutMask(uv,.53,.35,BLUR);\n    vec3 bottCol = rgb(232.,195.,117.);\n    col = bottCol * bottomMask;\n    \n    \n    //Icing--------------------------------------------------------------------\n    //Icing distortion\n    vec2 uvDistort = uv;\n    uvDistort.x += (sin(uv.y * 35. + 26.35/* + iTime*/) + sin(uv.y * 15. + 51.15 /*+ iTime*/)) * .005;\n    uvDistort.y += (sin(uv.x * 45. + 65.05/* + iTime*/) + sin(uv.x * 30. + 41.35 /*+ iTime*/)) * .005;\n    \n    //Icing mask\n    float icing = donutMask(uvDistort,.56,.3,BLUR);\n    \n    //Adding icing to image\n    vec3 donutCol = rgb(247.,111.,246.); //Těsto\n    col = mix(col,donutCol,icing);       //Poleva\n    \n    \n    //Sprinkles--------------------------------------------------------------------\n    //Tiling\n    float tileScale = 20.;\n    vec2 tiledUV = fract(uv*tileScale);\n    vec2 tile = floor(uv*tileScale);\n    \n    //Random placing\n    tiledUV = rotateUV(tiledUV,rndLum(tile,523.321,tile.x)*PI,.5);\t//Rotation\n    tiledUV += vec2((rndLum(tile,1236.321,tile.x)-.5)*.9)*.5;\n    \n    \n    //Sprinkle mask\n    float sprinkles = rect(tiledUV-.5,.1,rnd(tile)*.1+.2,BLUR+.05);\n    sprinkles *= donutMask(uvDistort,.56,.3,.002);\n    sprinkles *= round(rnd(tile));\n    \n    //Random sprikle color\n    float colChangeSpd = iTime * 2.;\n    vec3 sprinkleCol = vec3(rndLum(tile,colChangeSpd,0.),rndLum(tile,colChangeSpd,1.),rndLum(tile,colChangeSpd,2.));\n    float lum = dot(sprinkleCol,vec3(.333333));\n    \n    //Adding them in\n    sprinkleCol += (1.-lum)*.6;\n    col = mix(col,sprinkleCol,sprinkles);\n    \n    //Wierd jiggly lines\n    /*//col = vec3(1.);\n    vec2 tiledUV = fract(uv*10.);\n    float noise;\n    ivec2 textureCoord;\n    textureCoord.x = int(abs(sin((iTime+uv.x)*.2)*512.));\n    textureCoord.y = int(abs(sin((iTime+uv.y)*.2)*512.));\n    \n    noise = texelFetch(iChannel0,textureCoord,0).r;\n    //noise = sin((iTime+uv.x+uv.y)*.5)*2.*PI;\n    tiledUV = rotateUV(tiledUV,noise*2.*PI,.5);\n    float sprinkles = rect(tiledUV-.5,.1,.3,.05);\n    col *= sprinkles;*/\n    \n\n    // Output to screen\n    //fragColor = texelFetch(iChannel0,ivec2(uv*512.*2.),0);\n    float alpha = dot(col,vec3(.5)) > .01 ? 0. : 1.;\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 110, 147, 147, 210], [212, 212, 279, 297, 484], [486, 486, 546, 546, 699], [701, 757, 808, 808, 979], [981, 981, 1001, 1001, 1073], [1075, 1075, 1122, 1122, 1167], [1169, 1169, 1226, 1276, 3762]], "test": "valid"}
{"id": "ttfcWl", "name": "Interference cinétique", "author": "ciphered", "description": "Having fun with interference patterns", "tags": ["interference", "optical", "vasarely"], "likes": 1, "viewed": 171, "published": "Public API", "date": "1593690860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Just having some fun\n//\n\n#define PI \t\t3.1415926\n#define PI2\t\t1.5707963\n\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define rand(n)  fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453)\n\n\n// @author Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    \n    // time for easier sequencing\n    float t = iTime / 60.0;\n \tfloat c = 0.0;\n    \n   \tvec2 smpos = vec2(-.2, .2);\n    if (t > .5) smpos+= vec2(cos(iTime), sin(iTime)) * .1 * (min(.7, t)-.5)/.2;\n    \n    // drawing circles\n    float l = (length(uv - smpos) - (cos(iTime*.1)*.5 + .7)) * 250.0;\n    float id = floor(l / PI + PI2) + floor(iTime * floor(mod(t*.5, .1) * 18.));\n    float r = hash11(id);\n    \n    \n    c = cos(l) * r;\n    \n    \n    // drawing circles\n    vec2 smpos2 = vec2(-.2 + cos(iTime) * .2, -.2 + sin(iTime) * .2);\n    if (t>.15) {\n        float rt = min(t-.15, .25) / .25;\n        smpos2 = (smpos2 + vec2(.4, .2) * rt) * rot(iTime * .5 * rt);\n    }\n    l = (length(uv - smpos2) - (cos(iTime*.2)*.5 + .7)) * 250.0;\n    id = floor(l / PI + PI2) + floor(iTime * floor(mod(t*.5, .1) * 18.));\n    r = hash11(id);\n    \n    \n    c+= cos(l) * r * clamp(cos(iTime) - .6, .4, .8);\n    \n    \n    if (t > .75) {\n    \t// drawing circles\n        vec2 smpos3 = vec2(2. + cos(iTime) * .4, 2. + sin(iTime) * .2);\n        l = (length(uv - smpos3) - (cos(iTime*.2)*.5 + .7)) * 250.0;\n        id = floor(l / PI + PI2) + floor(iTime * floor(mod(t*.5, .1) * 18.));\n        r = hash11(id);\n\n\n        c+= cos(l) * r * clamp(cos(iTime) - .6, .4, .8) * (t-.5)/.5;   \n    }\n  \n    \n    vec2 dr = smpos - smpos2;\n    float a = atan(dr.y, dr.x);\n    vec2 ruv = (uv - vec2(-.2, .2)) * rot(-a + PI*.5);\n    \n\tc*=.4 + .8 * smoothstep(.04, .01, abs(ruv.x));\n    \n    if (t>.25) {\n    \tc = mix(1.-c, c, cos((t-.25)*20.)*.5+.5);   \n    }\n    \n    // Output to screen\n    fragColor = c * vec4(1., 1., 0.92, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 274, 297, 297, 382], [385, 385, 442, 442, 2113]], "test": "valid"}
{"id": "ttjcRc", "name": "Subway", "author": "dean_the_coder", "description": "Inspired by visuals from 'Blender Guru' (https://youtu.be/nb6rSMAooDs), I was aiming for some realistic (by my standards!) lighting and atmosphere.\nI could do more, but alas my GPU can't handle it.\nAny visual or performance tips welcome!", "tags": ["3d", "raymarching", "glow", "subway"], "likes": 58, "viewed": 621, "published": "Public API", "date": "1595682030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Subway'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others\n// for sharing their knowledge!\n//\n// Comment-out 'MY_GPU_CAN_TAKE_IT' if your graphics card struggles.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MY_GPU_CAN_TAKE_IT  // Enable reflections.\n#define ZERO min(iTime, 0.0)\n#define MIN_DIST 0.0015\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h,r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2) {\n  vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n  return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 cappedMod(vec2 p, float c, vec2 l1, vec2 l2) {\n    return p - c * clamp(round(p / c), -l1, l2);\n}\n\nvec3 mirrorX(vec3 p, float d) {\n    p.x = abs(p.x) - d;\n    return p;\n}\n\nvec3 repeatXZ(vec3 p, float c, vec2 l1, vec2 l2) {\n    p.xz = cappedMod(p.xz, c, l1, l2);\n    return p;\n}\n\nfloat sdTactileSlab(vec3 p) {\n    p.z -= 0.4;\n    \n    // Main slab - ISO standard 40x40cm ! :)\n    const float gap = 0.015;\n    float d = sdBox(p, vec3(0.40 - gap, 0.05, 0.4 - gap));\n    \n    // Add the dimples.\n    p.y -= 0.01;\n    p.xz = cappedMod(p.xz + vec2(0.06666), 0.06666 * 2.0, vec2(2.), vec2(3.));\n    return min(d, sdCylinder(p, 0.0225, 0.05));\n}\n\nfloat sdTactileSlabStrip(vec3 p) {\n    p.xz = cappedMod(p.xz, 0.8, vec2(3.0, 0.0), vec2(4.0, 0.0));\n    return sdTactileSlab(p);\n}\n\nfloat sdPavingSlab(vec3 p) {\n    const float gap = 0.015;\n    return sdBox(p, vec3(0.5 - gap, 0.05, 0.5 - gap));\n}\n\nfloat sdThinPavingSlab(vec3 p) {\n    const float gap = 0.015;\n    return sdBox(p - vec3(0.0, 0.0, 0.2), vec3(0.5 - gap, 0.05, 0.2 - gap));\n}\n\nconst vec2 stepToStep = vec2(0.36, 0.66);\nconst float centerToWall = 0.4 * 7.0;\nconst float ceilingHeight = 6.0;\n\nconst vec3 lightPos1 = vec3(0.0, 4.5, 4.3);\nconst vec3 lightPos2 = vec3(0.0, 4.5, -0.6);\n\nfloat glow = 0.0;\nfloat flicker = 1.0;\n\n#define WALL_ID          1.5\n#define RAIL_ID          2.5\n#define STAIR_STRIP_ID   3.5\n#define MARBLE_ID        4.5\n#define TACTILE_TILE_ID  5.5\n#define FLOOR_TILE_ID    6.5\n\nvec2 sdStep(vec3 p) {\n    const float gap = 0.015;\n    \n    // Top edge.\n    float d1 = sdBox(p, vec3(1.4, 0.02, 0.02));\n   \n    if (d1 > 1.0)\n        return vec2(d1, STAIR_STRIP_ID); // Too far away from the step to bother rendering further.\n    \n    // Front facing surface.\n    p.y += 0.16 + 0.02;\n    float d2 = sdBox(p, vec3(1.4 - gap, 0.16 - gap, 0.02));\n    \n    // Vertical grout.\n    d1 = min(d1, sdBox(p - vec3(0.0, 0.0, gap), vec3(1.4, 0.16, 0.02)));\n    \n    // Horizontal surface.\n    p.yz += vec2(0.16 + 0.02, 0.32);\n    d2 = min(d2, sdBox(p, vec3(1.4 - gap, 0.02, 0.32 - gap)));\n\n    // Horizontal grout.\n    d1 = min(d1, sdBox(p + vec3(0.0, gap, 0.0), vec3(1.4, 0.02, 0.32 - gap)));\n    \n    return min2(vec2(d1, STAIR_STRIP_ID), vec2(d2, MARBLE_ID));\n}\n\nvec2 sdSteps(vec3 p) {\n    float i = max(0.0, floor(-p.z / stepToStep.y));\n    return sdStep(p + i * vec3(0.0, stepToStep));\n}\n\nfloat sdRailHolder(vec3 p) {\n    p.x -= 0.35;\n    return max(sdLink(p.yxz, 0.1, 0.25, 0.06), p.y);\n}\n\nvec2 sdWalls(vec3 p) {\n    const float gap = 0.015;\n    \n    vec3 op = p;\n\n    // Wall tiles.\n    p.yz = mod(p.yz, vec2(0.16, 0.22));\n    float d = sdBox(mirrorX(p, centerToWall), vec3(0.02, 0.16 - gap, 0.22 - gap)) - gap;\n\n    // Hand rails.\n    vec3 pp = mirrorX(op, centerToWall);\n    pp.xy -= vec2(-0.3, 1.3);\n    float d2 = 1e10;\n    \n    if (pp.y < 3.0) { // Skip stair rails if point is too far away.\n        d2 = sdCapsule(pp, vec3(0.0, 0.0, 1.0), vec3(0.0), 0.1);\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, 0.75)), 0.025);\n        pp.yz *= rot(-atan(stepToStep.x / stepToStep.y));\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, -0.75)), 0.0255);\n        d2 = min(d2, sdCapsule(pp, vec3(0.0), vec3(0.0, 0.0, -length(stepToStep * 11.0)), 0.1));\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, -length(stepToStep * 11.0) + 0.75)), 0.025);\n    }\n\n    if (p.x > 0.0) {\n        // Remove the parts of the right wall.\n        const float nearEndZ = -stepToStep.y * 12.0;\n        float farEndZ = 2.9;\n        float middleZ = mix(nearEndZ, farEndZ, 0.5);\n        float depthToInclude = farEndZ - nearEndZ;\n        pp = op;\n        pp.z -= middleZ;\n        d = max(d, sdBox(pp, vec3(3.0, 1000.0, depthToInclude / 2.0)));\n    }\n    \n    return min2(vec2(d, WALL_ID), vec2(d2, RAIL_ID));\n}\n\nvec2 sdCorridorSection(vec3 p) {\n    // Walls.\n    vec2 d1 = sdWalls(p);\n    if (p.y > 2.0)\n        return d1; // Too far away from the floor to bother rendering further.\n    \n    // Steps.\n    vec2 d2 = sdSteps(repeatXZ(p, 2.8, vec2(1.0, 0.0), vec2(1.0, 0.0)));\n\n    // Pre-stairs half strip.\n    float d = sdThinPavingSlab(repeatXZ(p, 1.0, vec2(3.0, 0.0), vec2(3.0, 0.0)));\n\n    // Tactile slabs.\n    p.z -= 0.4;\n    float d3 = sdTactileSlabStrip(p);\n    d3 -= 0.006 * mix(0.8, 1.0, texture(iChannel0, p.xz * 1.7).r);\n\n    // Floor.\n    d = min(d, sdPavingSlab(repeatXZ(p - vec3(0.0, 0.0, 0.8 + 0.5), 1.0, vec2(3.0, 0.0), vec2(3.0, 5.0))));\n    \n    return min2(vec2(d, FLOOR_TILE_ID), min2(d1, min2(d2, vec2(d3, TACTILE_TILE_ID))));\n}\n\nvec2 map(vec3 p, bool useGlow) {\n    // Side wire cover.\n    float d = sdBox(p - vec3(centerToWall - 0.1, 0.0, 1.8), vec3(0.07, 10.0, 0.07)) - 0.01;\n\n    // Overhead beam.\n    d = min(d, sdBox(p - vec3(0.0, ceilingHeight - 1.0, 1.8), vec3(centerToWall, 1.0, 0.07)) - 0.01);\n    \n    // Overhead pipe.\n    vec3 v = vec3(centerToWall - 1.0, ceilingHeight - 1.5, 0.0);\n    d = min(d, sdCapsule(p, v + vec3(0.0, 0.0, 2.9), v - vec3(0.0, 0.0, 100.0), 0.18));\n    d = min(d, sdCapsule(p, v + vec3(0.0, 0.0, 2.0), v + vec3(0.0, 0.0, 1.6), 0.22));\n    \n    // Overhead pipe clamps.\n    vec3 pp = p;\n    pp.z = abs(p.z - 1.8);\n    d = min(d, sdLink(pp - vec3(centerToWall - 1.0, ceilingHeight - 1.3, 0.9), 0.2, 0.2, 0.015));\n    d = min(d, sdLink(p - vec3(centerToWall - 1.0, ceilingHeight - 1.3, -2.0), 0.2, 0.2, 0.015));\n\n    // Ceiling lights.\n    pp -= vec3(0.0, ceilingHeight - 1.0, 2.5);\n    float lightFrame = max(sdBox(pp, vec3(1.0, 0.25, 0.06)), -sdBox(pp + vec3(0.0, 0.3, 0.0), vec3(0.95, 0.2, 0.1)));\n    d = min(d, lightFrame);\n    \n    // Only apply glow when marching, not calculating normals.\n    if (useGlow) {\n        float endFade = 1.0 - clamp((abs(p.x) - 0.8) / 0.2, 0.0, 1.0);\n        pp.y += 0.2;\n        float gd = sdCylinder(pp.yxz, 0.05, 0.92);\n        glow += endFade * 0.001 / (0.001 + gd * gd * 0.3) * mix(0.01, 1.0, p.z < 0.0 ? 1.0 : flicker);\n    }\n    \n    // Ceiling.\n    pp = p;\n    pp.xz *= rot(-3.1415 / 4.0);\n    float bump = texture(iChannel0, p.xz * 0.8).r * 0.01;\n    d = min(d, sdBox(pp - vec3(0.0, ceilingHeight, -20.0), vec3(10.0, 1.0, 20.0 + stepToStep * 12.0)) - bump);\n\n    // Base corridor.\n    vec2 d2 = sdCorridorSection(p);\n    \n    // Upper corridor.\n    p.yz -= stepToStep * 12.0;\n    p.z -= 9.0;\n    p.xz *= rot(-3.14159 / 4.0);\n    p.x -= 9.08;\n    \n    d2 = min2(d2, sdCorridorSection(p));\n    \n    return min2(vec2(d, WALL_ID), d2);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0001;\n    return normalize(e.xyy * map(p + e.xyy, false).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, false).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, false).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, false).x);\n}\n\nfloat calcAO(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d, false).x / d, 0.0, 1.0);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    float d = distance(p, lightPos);\n    \n    float shadow = 1.0;\n    vec3 st = (lightPos - p) / 30.0 * 0.8;\n    float std = length(st);\n    p += normalize(lightPos - p) * 0.01;\n    for (float i = ZERO; i < 30.0; i++) {\n        p += st;\n        shadow = min(shadow, max(map(p, false).x, 0.0) / (std * i));\n    }\n    \n    float falloff = pow(d / 20.0 + 1.0, 2.0);\n    return shadow / falloff;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 getMaterial(vec3 p, vec3 rd, vec3 n, float id) {\n    vec3 lightDir1 = normalize(lightPos1 - p);\n    vec3 lightDir2 = normalize(lightPos2 - p);\n    vec3 lightCol = vec3(1.0, 1.0, 1.1);\n\n    float spec = pow(\n        max(\n            max(\n                dot(reflect(lightDir1, n), rd) * flicker,\n                dot(reflect(lightDir2, n), rd)\n            ),\n            0.0\n        ),\n        50.0);\n\n    vec3 mat;\n    if (id == STAIR_STRIP_ID) {\n        mat = vec3(0.1);\n    } else if (id == MARBLE_ID) {\n        mat = vec3(smoothstep(0.0, 0.6, texture(iChannel0, (abs(n.y) < 0.1 ? p.xy : p.xz) * 1.4125).r));\n    } else if (id == TACTILE_TILE_ID) {\n        mat = vec3(0.9, 0.75, 0.21); // Yellow.\n        spec *= 0.8; // Reduce specular contribution.\n    } else if (id == FLOOR_TILE_ID) {\n        mat = vec3(mix(0.3, 0.5, texture(iChannel0, p.xz * 1.743).r));\n    } else mat = vec3(1.0); // White (Tiles, etc)\n\n    // Diffuse color.\n    float diff = max(max(0.0, dot(lightDir1, n) * flicker), dot(lightDir2, n));\n\n    // Fake ambient occlusion.\n    float occ = min(1.0, 0.2 + calcAO(p, n, 0.15) * calcAO(p, n, 0.05));\n\n    // Shadows from two light sources.\n    float sha = (calcShadow(p, lightPos1) * flicker + calcShadow(p, lightPos2)) / 2.0;\n\n    vec3 col = mat * lightCol * ((diff + spec) * sha + occ * 0.025);\n    \n    // Global 'glow' variable accumulates color as the\n    // scene is marched.\n    return col + min(glow, 1.0);\n}\n\nvoid march(vec3 ro, vec3 rd, out vec3 p, out vec2 h) {\n    float d = 0.01;\n    for (float steps = ZERO; steps < 60.0; steps++) {\n        p = ro + rd * d;\n        h = map(p, true);\n        \n        if (abs(h.x) < MIN_DIST * d) break; // We've hit a surface - Stop.\n        d += h.x * 0.9; // No hit, so keep marching.\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    flicker = step(0.25, sin(iTime) * texture(iChannel0, vec2(iTime * 0.1)).r);\n\n    // Camera.\n    float ft = fract(iTime / 5.0);\n    float phase = mod(floor(iTime / 5.0), 3.0);\n    \n    vec3 ro;\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(0.0, -0.5, ft) * -3.0 - 1.0,\n                  -1.0 + -6.0 * mix(0.5, 0.4, ft),\n                  -10.0);\n    } else if (phase == 1.0) {\n        ro = vec3(-3.0 * mix(0.0, 0.5, ft) - 1.0, 3.0, -4.0);\n        lookAt = lightPos2;\n    } else if (phase == 2.0) {\n        ro = vec3(0.5, -1.0 + -6.0 * (mix(0.25, 0.0, ft) - 0.5), -1.0);\n        lookAt = lightPos1 - mix(vec3(5.0, 3.5, -1.0), vec3(0.0), ft);\n    }\n    \n    vec3 rd = getRayDir(ro, lookAt, uv);\n    \n    // Raymarch.\n    vec2 h;\n    vec3 p;\n\tmarch(ro, rd, p, h);\n\n    // Materials and lighting.\n\tvec3 n = calcNormal(p);\n    vec3 col = getMaterial(p, rd, n, h.y);\n\n#ifdef MY_GPU_CAN_TAKE_IT\n    // Reflect on hand rails.\n    if (h.y == RAIL_ID) {\n        rd = reflect(rd, n);\n        march(p, rd, p, h);\n        col = mix(col, getMaterial(p, rd, n, h.y), 0.75);\n    }\n#endif\n    \n    // Fog.\n    col *= exp(-pow(distance(ro, p) / 30.0, 3.0) * 5.0);\n    \n    // Output to screen.\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjcRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[383, 383, 422, 422, 525], [527, 527, 546, 546, 622], [624, 624, 653, 653, 748], [750, 750, 794, 794, 905], [907, 907, 957, 957, 1080], [1082, 1082, 1134, 1134, 1240], [1242, 1242, 1289, 1289, 1494], [1496, 1496, 1523, 1523, 1555], [1557, 1557, 1608, 1608, 1659], [1661, 1661, 1692, 1692, 1732], [1734, 1734, 1784, 1784, 1839], [1841, 1841, 1870, 1870, 2199], [2201, 2201, 2235, 2235, 2331], [2333, 2333, 2361, 2361, 2447], [2449, 2449, 2481, 2481, 2589], [3010, 3010, 3031, 3031, 3779], [3781, 3781, 3803, 3803, 3907], [3909, 3909, 3937, 3937, 4009], [4011, 4011, 4033, 4033, 5324], [5326, 5326, 5358, 5372, 6063], [6065, 6065, 6097, 6121, 7945], [7947, 7947, 7972, 7972, 8200], [8202, 8202, 8241, 8241, 8300], [8302, 8302, 8343, 8343, 8737], [8825, 8825, 8866, 8866, 9007], [9009, 9009, 9062, 9062, 10449], [10451, 10451, 10505, 10505, 10775], [10777, 10777, 10834, 10834, 12217]], "test": "error"}
{"id": "ttjyWD", "name": "Planetoids", "author": "jarble", "description": "This galaxy of planets has an interesting fractal pattern.", "tags": ["3d", "raymarching", "planets"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1594417219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n//rotation from https://www.shadertoy.com/view/MlyBzG\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*10.0;\n\n\n\t\n    float result1 = 0.0;\n    const float size = 1000.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0*3.0; i *= 3.0){\n        //float d1 = 5.0;\n        float i2 = i*i;\n        p += sin(p.yzx/size/i2/5.0)*size;\n        p = sin(p/i/size)*i2*size;\n        result += (length(p)-size/i2)/i2;\n        p /= 1.1;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p += sin(p);\n    p /= scale*100.0;\n    return sin(vec3(sceneSDF(p*5.0)+.5,sceneSDF(p.yzx*2.0),sceneSDF(p.zxy*3.0)))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(40.0,0.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 641, 641, 1076], [1078, 1078, 1106, 1106, 1252], [1255, 1676, 1767, 1767, 2079], [2094, 2348, 2413, 2413, 2545], [2547, 2636, 2665, 2665, 2975], [2977, 3469, 3609, 3609, 4219], [4221, 4591, 4676, 4676, 5091], [5093, 5420, 5469, 5504, 5635], [5637, 5637, 5694, 5694, 6798]], "test": "valid"}
{"id": "ttlBRr", "name": "rotate0", "author": "pohy", "description": "rotate0", "tags": ["rotate0"], "likes": 0, "viewed": 96, "published": "Public API", "date": "1595886714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    \n    \n    //uv *= .5;\n\n    // Time varying pixel color\n    vec3 col;\n    \n    float c = 25.;\n    for (float i = 1.; i < c; i++) {\n\t\tfloat it = ((c - i) / c);\n        //vec2 pos = vec2(1. + float(i) * .1, .0);\n        //uv += pos;\n        float angle = posSin(iTime * .005) * 3.1415 * 4. * mod(i, 2.);//mouse.x * 3.1415;\n        vec2 rotUv = rotate(uv, angle);\n        \n        vec2 fractUv = uv;\n        fractUv *= 1.2;\n    \tfractUv = fract(fractUv) * sign(fractUv);\n        fractUv *= .9;\n        \n        //uv = mix(rotUv, fractUv, .1);\n        uv = rotUv;\n\n        float size = (i / c);// * (1. + posSin(iTime) * .2);\n        float d = length(uv - vec2(clamp(uv.x, -size, size), clamp(uv.y, -size, size)));\n        float rect = smoothstep(.001, .0, d) * it;\n        //vec3 color = vec3(it * posSin(iTime * i) * .1);\n        vec3 color = vec3(.1, .1 * mod(i, 2.), 1. * posSin(iTime * i * .1) * it);// * mod(iTime * .1, 1.);\n\n        col += color * rect;\n        //col += ((c - i) / c);\n    }\n    \n    \n    //col += d;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 126], [128, 128, 151, 151, 182], [184, 184, 241, 291, 1506]], "test": "valid"}
{"id": "ttlBz8", "name": "Purple Waves - TBOS 5.1", "author": "stungeye", "description": "Chapter 5 - The Book of Shaders - Shaping Functions\n\nThese hypnotic purple waves are part of my exploration of shaping functions.", "tags": ["waves", "trig", "shaping"], "likes": 1, "viewed": 205, "published": "Public API", "date": "1596030946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Working Through The Book of Shaders\n// Chapter 05 - Shaping Functions - https://thebookofshaders.com/05/\n// 5.1 - Shaping Function Gallery - Details: https://shader-journey.netlify.app/docs/5-shaping-functions\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897\n\n// A fun time with trig.\nfloat function(float x) {\n    float time = mod(iTime, 100. * PI); // Loop the animation.\n    x *= 20. * (sin(time / 50.));       // Change the scale over time.\n    return sin(x * sin(time * .2)) * sin(6. * x + cos(time * time * .001)) * .5  + .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st        = fragCoord.xy / iResolution.xy; // Normalize texture coords 0.0 to 1.0.\n  float gradient = function(st.x);                // Gradient value from function. \n  vec3 colour    = vec3(1., 0., 0.)               // Base colour.\n                   + vec3(0., .3, gradient);      // Tinted gradient colour.\n                 \n  fragColor = vec4(colour, 1.);                   // Set pixel colour.\n}\n\n// Kyle Geske - stungeye.com - Unlicense 2020 - https://unlicense.org\n// This is free and unencumbered software released into the public domain", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 313, 338, 338, 561], [564, 564, 621, 621, 1029]], "test": "valid"}
{"id": "ttlcWs", "name": "An Important PSA", "author": "amhall", "description": "When I started making this, the U.S. had nearly 25.7% of the world's coronavirus cases, despite having only 4.2% of the world's population.\n\nThis should not even be an issue.", "tags": ["raymarching", "mask", "coronavirus", "covid"], "likes": 11, "viewed": 269, "published": "Public API", "date": "1593859218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Anthony Hall, June 2020 (published July)\n// Wear a mask.\n// Especially relevant this Fourth of July weekend as more people will gather in large groups.\n// Of all things you can do to slow the spread, it is literally the easiest one.\n\n// In the U.S., over 132 thousand people have died due to COVID-19.\n// Let's think about how big 132,000 is.\n// If one person died every minute, it would take 3 months to reach 132,000.\n// If you flew 132,000 miles, you would go around the entire Earth over 5 times.\n// If you stacked 132,000 $1 bills, the stack would be over 48 feet (14.6 meters) tall.\n// The combined weight of 2 adult humpback whales is 132,000 pounds.\n// A 45 year old person that sleeps 8 hours per day would not have slept 132,000 hours in their entire life!\n// All this, and the death toll has not even caught up to the surge of new cases\n// that is happening as I write this.\n// Seriously. Wear a fucking mask.\n\n// If running at a high resolution or on a non-beefy GPU, pausing iChannel1 will\n// disable the beat effect for smoother motion\n\nconst float pi = 3.14159265359;\nconst float twoPi = 2.0 * pi;\nconst float root2Over2 = sqrt(2.0) / 2.0;\n\nconst int maxIters = 150;\nconst float epsilon = 0.011;\n\nconst float zThickness = 1.0; // Width of plane\nconst float zRepeat = 32.0; // Distance between each plane\nconst float maxZDistance = zRepeat*2.0 - zThickness; // Distance is only evaluated on Z axis!\n\n// Camera globals\nvec3 cameraPos = vec3(-0.5, 0., 0.); // Slightly off center to go through the letters better\nconst float minFov = 64.0 * pi/180.0; // FOV of min screen dimension\nvec3 lightPos; // set in mainImage\n\nconst vec3 skyColor = vec3(0.5, 0.75, 1.0);\nconst vec3 surfaceColor = vec3(1.0, 0.7, 0.45);\nconst float kAmbient = 0.25;\nconst float kDiffuse = 0.75;\nconst float kShadow = 0.45;\n\nconst float period = 4.0 / 16.0 * 15.0; // 6 measures\n\n// For the beat with time effect\n// When the framerate is low, this effect doesnt really work.\n// Set to 0 or pause the music channel to disable\nconst float beatIntensity = 0.2;\n\n// Smooth radius around letter boxes\nconst float smoothing = 0.2;\n\n// Texture size and depth for each axis\n// If tweaking these, know that shadows are only calculated\n// for surface normals not close to the z axis\nconst vec3 textureSize = vec3(4.0, 4.0, 10.0);\nconst vec3 textureDepth = vec3(0.1, 0.1, 0.2);\nconst float maxTextureDepth = max(max(textureDepth.x, textureDepth.y), textureDepth.z);\n\n// RepeatingPlane with width in Z axis\nfloat sdThiccPlane(vec3 point, float width) {\n    point.z += zRepeat / 2.0;\n    point.z = mod(point.z, zRepeat);\n    point.z -= zRepeat / 2.0;\n    \n    return abs(point.z) - width/2.0;\n}\n\n// Box described by bottom left point and (width, height)\nfloat sdBox(vec2 point, vec2 bottomLeft, vec2 dimensions)\n{\n    vec2 topRight = bottomLeft + dimensions;\n    vec2 center = (bottomLeft + topRight) / 2.0;\n\tpoint -= center;\n    \n    vec2 bounds = dimensions / 2.0;\n    \n    vec2 q = abs(point) - bounds;\n    return length(max(q,0.0)) + min(max(q.x, q.y),0.0);\n}\n\n// This one is really long so it's at the bottom\nfloat sdText(vec2 point);\n\n// Add texture r channel to plane distance field\nfloat textureDistance(vec2 point, float size, float depth) {\n    const mat2 textureRotate = mat2(\n        root2Over2, -root2Over2,\n        root2Over2, root2Over2);\n    \n    // Add a rotated version as well so it's less repetitive\n \tfloat noise1 = texture(iChannel0, mod(point, size) / size).r;\n    float noise2 = texture(iChannel0, mod(textureRotate * point, size) / size).r; \n    return depth * (noise1 + noise2) / 2.0;\n}\n\n// Returns the distance to the scene\nfloat scene(vec3 point) {\n    // Apply textures to distance field\n    point.x += textureDistance(point.yz + 0.1, textureSize.x, textureDepth.x);\n    point.y += textureDistance(-point.xz + 0.2, textureSize.y, textureDepth.y);\n    point.z += textureDistance(point.xy, textureSize.z, textureDepth.z);\n    \n    // Only investigate text after the slab has almost been hit\n    float slab = sdThiccPlane(point, zThickness);\n    if (slab <= epsilon + textureDepth.z * 1.5) {\n        float text = sdText(point.xy);\n    \treturn max(slab, -text);\n    }    \n    return slab;\n}\n\n// Simplified scene function for calculating shadows\nfloat shadowScene(vec3 point) {\n \tfloat slab = sdThiccPlane(point, zThickness);\n    float text = sdText(point.xy);\n    return max(slab, -text);\n}\n\n// Approximates the normal at an intersection by calculating the gradient of the scene\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        scene(vec3(point.x + epsilon, point.y, point.z)) - scene(vec3(point.x - epsilon, point.y, point.z)),\n        scene(vec3(point.x, point.y + epsilon, point.z)) - scene(vec3(point.x, point.y - epsilon, point.z)),\n        scene(vec3(point.x, point.y, point.z  + epsilon)) - scene(vec3(point.x, point.y, point.z - epsilon))));\n}\n\n// Approximates shadow and diffuse lighting\n// bro imagine wearing a mask\nvec3 shadeSurface(vec3 point) {\n    vec3 normal = estimateNormal(point);\n    float normalDotZ = dot(normal, vec3(0.0, 0.0, 1.0)); // declare because reused later\n      \n    // March a ray to calculate the shadow only if the normal not close to \n    // the z direction, so that it only tries to do this inside the letters\n    // (Currently for about 36 degrees away from z axis)\n    if (normalDotZ <= 0.8) {\n        // The ray marches in scene space but is pointed to the camera in absolute space\n        vec3 rayOrigin = point;\n\n        rayOrigin.z += zRepeat / 2.0;\n        rayOrigin.z = mod(rayOrigin.z, zRepeat);\n        rayOrigin.z -= zRepeat / 2.0;\n\n        vec3 rayPoint = rayOrigin;\n        vec3 rayDir = normalize(lightPos - point); // Direction should reflect actual z\n\n        // Start from a little far out to prevent bumps from being considered in the shadow\n        for (float t = maxTextureDepth; rayPoint.z <= zThickness/2.0 + textureDepth.z + epsilon;) {\n            rayPoint = rayOrigin + rayDir * t;\n\n            float dist = shadowScene(rayPoint);\n            if (dist <= epsilon) {\n                // Diffuse style lighting based on normal angle from z axis\n                // This isn't exactly how it works but it's cheap and still\n                // shows some geometry\n                float intensity = (normalDotZ + 1.0) / 2.0;\n                return kShadow * (kAmbient + kDiffuse * intensity) * surfaceColor;\n            }\n            t += dist;\n        }\n    }\n    vec3 color = kAmbient * surfaceColor;\n    \n    vec3 toLight = normalize(lightPos - point);\n    float intensity = max(dot(normal, toLight), 0.0);\n    \n    // No specular\n    color += kDiffuse * intensity * surfaceColor;\n    return color;\n}\n\n// Returns the result color of casting any ray\n// Normalizes direction input\nvec3 castRay(vec3 rayOrigin, vec3 rayDir) {\n    rayDir = normalize(rayDir);\n    \n    vec3 point = rayOrigin;\n    float t = 0.0;\n    vec3 color = skyColor;\n    \n    for (int i = 0; i < maxIters && abs(point.z - rayOrigin.z) < maxZDistance; i++) {\n     \tfloat dist = scene(point) * 0.9; // Reducing the distance a bit because the texture breaks the distance field\n        \n        if (dist <= epsilon) {\n            color = shadeSurface(point);\n        \tbreak;\n        }\n        t += dist;\n        point += dist * rayDir;\n    }\n    // Fade to sky after certain distance\n    float fade = smoothstep(zRepeat, maxZDistance, abs(point.z - rayOrigin.z));\n    return mix(color, skyColor, fade);\n}\n\n// have u tried wearing a mask?\n// ===================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert coords to [-1, 1] in minimum dimension\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 coord = (2.0*fragCoord - iResolution.xy) / minDimension;\n    \n\tvec3 rayDir = vec3(coord * tan(minFov/2.0), -1.0);\n    \n    // Add beat effect every measure (128 bpm)\n    float timeIn = iChannelTime[1] * 16.0 / 15.0;\n    float time = iTime + beatIntensity*pow( cos(twoPi * (timeIn)), 8.0);\n    \n    // Start from a little bit behind a plane, move forward one plane per period constant\n    cameraPos.z = zRepeat - zThickness/2.0 - 0.1 - time * zRepeat / period;\n    lightPos = vec3(-20.0, 28.0, cameraPos.z + 3.5);\n\n    fragColor = vec4(castRay(cameraPos, rayDir), 1.0);\n}\n// ===================================================\n\n// Tests whether inside a 2D box, smoothing radius and texture xy depth accounted for\nbool insideBox(vec2 point, vec2 bottomLeft, vec2 dimensions) {\n    vec2 topRight = bottomLeft + dimensions + smoothing + textureDepth.xy;\n    bottomLeft -= (smoothing + textureDepth.xy);\n    \n    return point.x >= bottomLeft.x &&\n        point.x <= topRight.x &&\n        point.y >= bottomLeft.y &&\n        point.y <= topRight.y;\n}\n\n// Tests whether inside a 1D region, smoothing radius and texture x depth accounted for\nbool insideBound(float t, float left, float width) {\n    float right = left + width + smoothing + textureDepth.x;\n    left -= (smoothing + textureDepth.x);\n    return t >= left &&\n        t <= right;\n}\n\n\n\n// This distance function actually results in a shape, which if you look at\n// very closely contains a very important message\nfloat sdText(vec2 point) {\n    // Total space occupied by text\n\tconst vec2 textSize = vec2(30.0, 19.0);\n    \n \tpoint.y *= -1.0;\n    point += textSize / 2.0;\n    vec2 originalPoint = point;\n    float result = maxZDistance;\n    \n    if (!insideBox(point, vec2(0.0, 0.0), textSize))\n        return result;\n    \n    // Further split region by row\n    // Within each row, we only need to check x bound for each letter\n    if (insideBox(point, vec2(2.0, 0.0), vec2(26.0, 5.0)))\n    {\n        // W\n        if (insideBound(point.x, 2.0, 5.0)) {\n            // Mirror about x = 4.5;\n            point.x = 4.5 - abs(point.x - 4.5);\n            result = sdBox(point, vec2(2.0, 0.0), vec2(1.0, 4.0));\n            result = min(result, sdBox(point, vec2(3.0, 4.0), vec2(1.0, 1.0)));\n            result = min(result, sdBox(point, vec2(4.0, 2.0), vec2(1.0, 2.0)));\n            point = originalPoint;\n        }\n\n        // E\n        else if (insideBound(point.x, 8.0, 3.0)) {\n            // Mirror about y = 2.5 then y = 1.5 for bars\n            point.y = 2.5 - abs(point.y - 2.5);\n            point.y = 1.5 - abs(point.y - 1.5);    \n            result = sdBox(point, vec2(8.0, 0.0), vec2(1.0, 5.0));\n            result = min(result, sdBox(point, vec2(8.0, 0.0), vec2(3.0, 1.0)));\n            point = originalPoint;\n        }\n\n        // A is repeating so move it to the end for better branch structure\n        \n        // R\n        else if (insideBound(point.x, 17.0, 4.0)) {\n            result = sdBox(point, vec2(17.0, 0.0), vec2(1.0, 5.0));\n            result = min(result, sdBox(point, vec2(20.0, 1.0), vec2(1.0, 1.0)));\n            result = min(result, sdBox(point, vec2(20.0, 3.0), vec2(1.0, 2.0)));\n            // Mirror about y = 1.5 for bar\n            point.y = 1.5 - abs(point.y - 1.5);\n            result = min(result, sdBox(point, vec2(17.0, 0.0), vec2(3.0, 1.0)));\n            point = originalPoint;\n        }\n        \n        // A\n        // Repeat A in same row\n        else if (point.x > 23.0)\n            point.x -= 12.0;\n        if (insideBound(point.x, 12.0, 4.0)) {\n            // Mirror about x = 14\n            point.x = 14.0 - abs(point.x - 14.0);\n            result = sdBox(point, vec2(12.0, 1.0), vec2(1.0, 4.0));\n            // Mirror about y = 1.5 for bar\n            point.y = 1.5 - abs(point.y - 1.5);\n            result = min(result, sdBox(point, vec2(13.0, 0.0), vec2(2.0, 1.0)));\n        }\n        //point = originalPoint;\n    }\n    // Second row\n    else if (insideBox(point, vec2(0.0, 7.0), vec2(30.0, 5.0)))\n    {\n        // F\n        if (insideBound(point.x, 0.0, 3.0)) {\n            result = sdBox(point, vec2(0.0, 7.0), vec2(1.0, 5.0));\n            // Mirror about y = 8.5 for bar\n            point.y = 8.5 - abs(point.y - 8.5);\n            result = min(result, sdBox(point, vec2(0.0, 7.0), vec2(3.0, 1.0)));\n            point = originalPoint;\n        }\n\n        // U\n        else if (insideBound(point.x, 4.0, 4.0)) {\n            // Mirror about x = 6\n            point.x = 6.0 - abs(point.x - 6.0);\n            result = sdBox(point, vec2(4.0, 7.0), vec2(1.0, 4.0));\n            result = min(result, sdBox(point, vec2(5.0, 11.0), vec2(2.0, 1.0)));\n            point = originalPoint;\n        }\n\n        // C is repeating so move it to the end for better branch structure\n        \n        // K\n        else if (insideBound(point.x, 13.0, 3.0)) {\n            // Mirror about y = 9.5\n            point.y = 9.5 - abs(point.y - 9.5);\n            result = sdBox(point, vec2(13.0, 7.0), vec2(1.0, 5.0));\n            result = min(result, sdBox(point, vec2(15.0, 7.0), vec2(1.0, 2.0)));\n            result = min(result, sdBox(point, vec2(14.0, 9.0), vec2(1.0, 1.0)));\n            point = originalPoint;\n        }\n        \n        \n        // I\n        else if (insideBound(point.x, 17.0, 3.0)) {\n            // Mirror about y = 9.5\n            point.y = 9.5 - abs(point.y - 9.5);\n            result = sdBox(point, vec2(17.0, 7.0), vec2(3.0, 1.0));\n            result = min(result, sdBox(point, vec2(18.0, 7.0), vec2(1.0, 5.0)));\n            point = originalPoint;\n        }\n        \n        // N\n        else if (insideBound(point.x, 21.0, 4.0)) {\n            \n            result = sdBox(point, vec2(22.0, 8.0), vec2(1.0, 1.0));\n            result = min(result, sdBox(point, vec2(23.0, 9.0), vec2(1.0, 1.0)));\n            // Mirror about x = 23 for sides\n            point.x = 23.0 - abs(point.x - 23.0);\n            result = min(result, sdBox(point, vec2(21.0, 7.0), vec2(1.0, 5.0)));\n            point = originalPoint;\n        }\n        \n        \n        // C\n        // Copy for G\n        else if (point.x > 25.0)\n            point.x -= 17.0;\n        if (insideBound(point.x, 9.0, 3.0)) {\n            // Mirror about y = 9.5\n            point.y = 9.5 - abs(point.y - 9.5);\n            result = sdBox(point, vec2(9.0, 8.0), vec2(1.0, 3.0));\n            result = min(result, sdBox(point, vec2(10.0, 7.0), vec2(2.0, 1.0)));\n        }\n        point = originalPoint;\n        \n        // The rest of G\n        if (insideBox(point, vec2(28.0, 9.0), vec2(2.0, 2.0))) {\n            result = min(result, sdBox(point, vec2(28.0, 9.0), vec2(2.0, 1.0)));\n            result = min(result, sdBox(point, vec2(29.0, 9.0), vec2(1.0, 2.0)));\n        }\n    }\n    // Third row\n    else if (insideBox(point, vec2(6.0, 14.0), vec2(18.0, 5.0)))\n    {\n        // M\n        if (insideBound(point.x, 6.0, 5.0)) {\n            // Mirror about x = 8.5\n            point.x = 8.5 - abs(point.x - 8.5);\n            result = sdBox(point, vec2(6.0, 14.0), vec2(1.0, 5.0));\n            result = min(result, sdBox(point, vec2(7.0, 15.0), vec2(1.0, 1.0)));\n            result = min(result, sdBox(point, vec2(8.0, 16.0), vec2(1.0, 1.0)));\n            point = originalPoint;\n        }\n        \n        // A\n        else if (insideBound(point.x, 12.0, 4.0)) {\n            // Mirror about x = 14\n            point.x = 14.0 - abs(point.x - 14.0);\n            result = sdBox(point, vec2(12.0, 15.0), vec2(1.0, 4.0));\n            // Mirror about y = 15.5 for bar\n            point.y = 15.5 - abs(point.y - 15.5);\n            result = min(result, sdBox(point, vec2(13.0, 14.0), vec2(2.0, 1.0)));\n            point = originalPoint;\n        }\n        \n        // S\n        else if (insideBound(point.x, 17.0, 3.0)) {\n            // In the lower half, mirror about y = 16.5 and flip (not mirror) about x = 18.5\n            // Not sure of a good way to do this without branching\n            if (point.y > 16.5) {\n             \tpoint.y = 16.5 - abs(point.y - 16.5);\n                point.x = 2.0 * 18.5 - point.x;\n            }\n            result = sdBox(point, vec2(18.0, 14.0), vec2(2.0, 1.0));\n            result = min(result, sdBox(point, vec2(17.0, 15.0), vec2(1.0, 2.0)));\n            result = min(result, sdBox(point, vec2(17.0, 16.0), vec2(3.0, 1.0)));\n            point = originalPoint;\n        }\n        \n        // K\n        else if (insideBound(point.x, 21.0, 3.0)) {\n            // Mirror about y = 16.5\n            point.y = 16.5 - abs(point.y - 16.5);\n            result = sdBox(point, vec2(21.0, 14.0), vec2(1.0, 5.0));\n            result = min(result, sdBox(point, vec2(23.0, 14.0), vec2(1.0, 2.0)));\n            result = min(result, sdBox(point, vec2(22.0, 16.0), vec2(1.0, 1.0)));\n            //point = originalPoint;\n        }\n    }\n    \n    return result - smoothing;\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2454, 2493, 2538, 2538, 2679], [2681, 2739, 2798, 2798, 3048], [3126, 3175, 3235, 3235, 3597], [3599, 3636, 3661, 3701, 4200], [4202, 4255, 4286, 4286, 4400], [4402, 4489, 4522, 4522, 4878], [4880, 4954, 4985, 4985, 6685], [6687, 6764, 6807, 6807, 7452], [7454, 7541, 7598, 7652, 8292], [8349, 8435, 8497, 8497, 8765], [8767, 8855, 8907, 8907, 9056], [9060, 9186, 9212, 9248, 16542]], "test": "error"}
{"id": "ttsBRr", "name": "Rainbow Warp", "author": "t420babe", "description": "Three modifications of rainbow using tangent and cosine functions. Each design runs for 10 seconds", "tags": ["rainbow"], "likes": 1, "viewed": 121, "published": "Public API", "date": "1595888333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec3 rainbow_warp(vec2 pos) {\n  vec3 color = vec3(0.0);\n\n  float speed = 1.0;\n  float zoom = 1.25;\n  pos *= zoom;\n\n  float mod_time = mod(iTime, 30.0);\n  vec2 denominator = vec2(2.0, 10.0);\n    \n   if (mod_time < 10.0) {\n        denominator =vec2(20.0, 100.0);\n   } else if(mod_time < 20.0) {\n        denominator = vec2(1.0, 1.0);\n   }\n  vec2 movement = vec2(13.0, iTime);\n\n  for (int i = 1; i < 3; i++) {\n    pos.x += 0.03 / float(i) * tan(float(i) * 5.0 * pos.y + iTime / speed) + movement.x/ denominator.x;\n    pos.y += 0.5 / float(i) * cos(float(i) * 3.0 * pos.x + iTime * speed) + movement.y / denominator.y;\n  }\n\n  float g = cos(pos.y + pos.y + 1.0) * 0.5 + 0.5;\n  float b = sin(pos.x + pos.x + 1.0) * 0.5 + 0.5;\n  float r = (tan(pos.x * pos.y) + tan(pos.y + pos.x)) * 0.5 + 0.5;\n\n  return vec3(g, b, r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    \n    vec3 color = rainbow_warp(pos);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 73, 856], [859, 859, 916, 969, 1087]], "test": "valid"}
{"id": "ttsBzN", "name": "Slanted Capped Cone", "author": "mskr", "description": "The caps of this capped cone can be oriented by individual normals.\nBased on David Eberly's GeometricTools.com (Line-Cone intersection).\nUsed iq's Ray-Capped-Cone intersection as scene template.", "tags": ["intersection"], "likes": 1, "viewed": 57, "published": "Public", "date": "1596223477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//\n// Intersection of a ray and a capped cone oriented in an arbitrary direction\n//\n//\n// Other cone functions:\n//\n// Cone bbox:         https://www.shadertoy.com/view/WdjSRK\n// Cone distance:     https://www.shadertoy.com/view/tsSXzK\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n//\n//\n// Other intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n\n#define Real float\n#define Real3 vec3\n#define fabs abs\n#define INFINITY 3.402823e+38\n\n\n/**\n* Ray in 3-space\n*/\nstruct Ray3 {\n    Real3 origin, direction;\n} ;\n\n\n/**\n* Cone in 3-space.\n* The cone has vertex V, unit-length axis direction D, angle theta in (0,pi/2).\n* Also a height and cap position are defined along the axial ray.\n* The cone vertex is the ray origin and the cone axis direction is the\n* ray direction. The direction must be unit length. The angle must be\n* in (0,pi/2). The height must be in (0,+infinity), where +infinity is INFINITY.\n*/\nstruct Cone3 {\n    Ray3 ray;\n    Real angle;\n    Real height;\n    Real cap; // to cap the pointy end, set this to a value in (0,height)\n    Real3 heightNormal;\n    Real3 capNormal;\n};\n    \n/**\n* Line in 3-space\n*/\nstruct Line3 {\n    Real3 start;\n    Real3 end;\n};\n    \n/**\n*\n*/\nstruct Plane3 {\n    Real3 middle;\n    Real3 normal;\n};\n\n\n/*\n* Distance of p to plane with origin o and normalized normal n\n*/\nReal calcPointPlaneDistance(Real3 p, Real3 o, Real3 n) {\n    Real a = dot(o, n);\n    a -= dot(n, p);\n    a /= dot(n, n);\n    return fabs(a);\n}\n\n\n/*\n* An intersection routine for rays and planes\n*/\nReal intersectPlane(Real3 pos, Real3 dir, Real3 middle, Real3 normal) {\n    Real a = dot(dir, normal);\n    if (a > -1e-6) return -1.0; // facing away\n    Real b = dot(middle - pos, normal);\n    if (b > -1e-6) return -1.0; // behind plane\n    return b / a;\n}\n\n\n/**\n* Get point rotated 90 degrees around vector (counter-clockwise).\n* Basically application of rotation matrix with simplified sines and cosines.\n* https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n*/\nReal3 rotate90PointAroundVector(Real3 vector, Real3 point) {\n    Real3 u = normalize(vector);\n    return Real3(\n        point.x * (u.x*u.x) + point.y * (u.x*u.y-u.z) + point.z * (u.x*u.z+u.y),\n        point.x * (u.y*u.x+u.z) + point.y * (u.y*u.y) + point.z * (u.y*u.z-u.x),\n        point.x * (u.z*u.x-u.y) + point.y * (u.z*u.y+u.x) + point.z * (u.z*u.z));\n}\n\n\n/**\n* Get point on plane that minimizes distance to another point\n* http://immersivemath.com/ila/ch03_dotproduct/ch03.html#ex_dp_ortho_proj_onto_plane\n*/\nReal3 projectPointToPlane(Plane3 plane, Real3 point) {\n    Real3 v = point - plane.middle;\n    Real3 proj = (dot(v, plane.normal) / pow(length(plane.normal), 2.)) * plane.normal;\n    return v - proj;\n}\n\n/**\n* David Eberly, Geometric Tools, Redmond WA 98052\n* Copyright (c) 1998-2018\n* Distributed under the Boost Software License, Version 1.0.\n* http://www.boost.org/LICENSE_1_0.txt\n* http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt\n* File Version: 3.0.2 (2018/10/05)\n*\n*   type  intersect  valid data\n*   0     none       none\n*   1     point      parameter[0] = parameter[1], finite\n*                    point[0] = point[1]\n*   2     segment    parameter[0] < parameter[1], finite\n*                    point[0,1] valid\n*   3     ray        parameter[0] finite, parameter[1] maxReal\n*                    point[0] = rayOrigin, point[1] = lineDirection\n*   4     ray        parameter[0] -maxReal, parameter[1] finite\n*                    point[0] = rayOrigin, point[1] = -lineDirection\n*   5     line       parameter[0] -maxReal, parameter[1] maxReal,\n*                    point[0] = lineOrigin, point[1] = lineDirection\n* If the cone height h is finite, only types 0, 1, or 2 can occur.\n* https://www.geometrictools.com/Documentation/IntersectionLineCone.pdf\n*/\nReal intersectCone(Real3 lineOrigin, Real3 lineDirection, Cone3 cone, out Real3 outNormal) {\n    int type;\n    float parameter0;\n    float parameter1;\n    // The cone has vertex V, unit-length axis direction D, angle theta in\n    // (0,pi/2), and height h in (0,+infinity).  The line is P + t*U, where U\n    // is a unit-length direction vector.  Define g = cos(theta).  The cone\n    // is represented by\n    //   (X-V)^T * (D*D^T - g^2*I) * (X-V) = 0,  0 <= dot(D,X-V) <= h\n    // The first equation defines a double-sided cone.  The first inequality\n    // in the second equation limits this to a single-sided cone containing\n    // the ray V + s*D with s >= 0.  We will call this the 'positive cone'.\n    // The single-sided cone containing ray V + s * t with s <= 0 is called\n    // the 'negative cone'.  The double-sided cone is the union of the\n    // positive cone and negative cone.  The second inequality in the second\n    // equation limits the single-sided cone to the region bounded by the\n    // height.  Setting X(t) = P + t*U, the equations are\n    //   c2*t^2 + 2*c1*t + c0 = 0,  0 <= dot(D,U)*t + dot(D,P-V) <= h\n    // where\n    //   c2 = dot(D,U)^2 - g^2\n    //   c1 = dot(D,U)*dot(D,P-V) - g^2*dot(U,P-V)\n    //   c0 = dot(D,P-V)^2 - g^2*dot(P-V,P-V)\n    // The following code computes the t-interval that satisfies the quadratic\n    // equation subject to the linear inequality constraints.\n    \n    Real t;\n    \n    // Handle degenerate case, when there is no cone direction.\n    // We interpret the cone for our use case as an annulus in the xy plane.\n    // Cap and height are interpreted as inner and outer radii of the annulus.\n    if (cone.ray.direction.x==0.0&&cone.ray.direction.y==0.0&&cone.ray.direction.z==0.0) {\n        Real3 normal = normalize(Real3(0,0,-sign(lineDirection.z)));\n        t = intersectPlane(lineOrigin, lineDirection, cone.ray.origin, normal);\n        if (t > 0.0) {\n            Real3 p = lineOrigin + t * lineDirection;\n            Real r = length(p.xy - cone.ray.origin.xy);\n            if (r >= cone.cap && r <= cone.height) {\n                outNormal = normal;\n                return t;\n            }\n        }\n        return -1.0;\n    }\n\n    Real3 PmV = lineOrigin - cone.ray.origin;\n    Real DdU = dot(cone.ray.direction, lineDirection);\n    Real DdPmV = dot(cone.ray.direction, PmV);\n    Real UdPmV = dot(lineDirection, PmV);\n    Real PmVdPmV = dot(PmV, PmV);\n    Real cosAngle = cos(cone.angle);\n    Real cosAngleSqr = cosAngle * cosAngle;\n    Real c2 = DdU * DdU - cosAngleSqr;\n    Real c1 = DdU * DdPmV - cosAngleSqr * UdPmV;\n    Real c0 = DdPmV * DdPmV - cosAngleSqr * PmVdPmV;\n\n    if (c2 != Real(0))\n    {\n        Real discr = c1 * c1 - c0 * c2;\n        if (discr < Real(0))\n        {\n            // The quadratic has no real-valued roots.  The line does not\n            // intersect the double-sided cone.\n            type = 0;\n            return -1.0;\n        }\n        else if (discr > Real(0))\n        {\n            // The quadratic has two distinct real-valued roots.  However, one\n            // or both of them might intersect the negative cone.  We are\n            // interested only in those intersections with the positive cone.\n            Real root = sqrt(discr);\n            Real invC2 = (Real(1)) / c2;\n            bool found1 = false;\n            bool found2 = false;\n\n            t = (-c1 - root) * invC2;\n            if (DdU * t + DdPmV >= Real(0))\n            {\n                parameter0 = t;\n                found1 = true;\n            }\n\n            t = (-c1 + root) * invC2;\n            if (DdU * t + DdPmV >= Real(0))\n            {\n                if (!found1) parameter0 = t;\n                else parameter1 = t;\n                found2 = true;\n            }\n\n            if (found2)\n            {\n                // The line intersects the positive cone in two distinct\n                // points.\n                type = 2;\n                if (parameter0 > parameter1)\n                {\n                    Real tmp = parameter0;\n                    parameter0 = parameter1;\n                    parameter1 = tmp;\n                }\n            }\n            \n            else if (found1)\n            {\n                // The line intersects the positive cone in a single point and\n                // the negative cone in a single point.  We report only the\n                // intersection with the positive cone.\n                if (DdU > Real(0))\n                {\n                    // Line enters positive cone at t==parameter[0]\n                    // and keeps intersecting until t==INFINITY,\n                    // in case there is no cone height constraint.\n                    type = 3;\n                    parameter1 = INFINITY;\n                }\n                else\n                {\n                    // Line comes from t==-INFINITY and enters positive\n                    // cone at t==parameter[0] (assuming no height constraint).\n                    type = 4;\n                    parameter1 = parameter0;\n                    parameter0 = -INFINITY;\n                }\n            }\n            else\n            {\n                // The line intersects the negative cone in two distinct\n                // points, but we are interested only in the intersections\n                // with the positive cone.\n                type = 0;\n                return -1.0;\n            }\n        }\n        else  // discr == 0\n        {\n            // One repeated real root; the line is tangent to the double-sided\n            // cone at a single point.  Report only the point if it is on the\n            // positive cone.\n            t = -c1 / c2;\n            if (DdU * t + DdPmV >= Real(0))\n            {\n                type = 1;\n                parameter0 = t;\n                parameter1 = t;\n            }\n            else\n            {\n                type = 0;\n                return -1.0;\n            }\n        }\n    }\n    else if (c1 != Real(0))\n    {\n        // c2 = 0, c1 != 0; U is a direction vector on the cone boundary\n        t = -(Real(0.5))*c0 / c1;\n        if (DdU * t + DdPmV >= Real(0))\n        {\n            // The line intersects the positive cone and the ray of\n            // intersection is interior to the positive cone.\n            if (DdU > Real(0))\n            {\n                type = 3;\n                parameter0 = t;\n                parameter1 = INFINITY;\n            }\n            else\n            {\n                type = 4;\n                parameter0 = -INFINITY;\n                parameter1 = t;\n            }\n        }\n        else\n        {\n            // The line intersects the negative cone and the ray of\n            // intersection is interior to the positive cone.\n            type = 0;\n            return -1.0;\n        }\n    }\n    else if (c0 != Real(0))\n    {\n        // c2 = c1 = 0, c0 != 0.  Cross(D,U) is perpendicular to Cross(P-V,U)\n        type = 0;\n        return -1.0;\n    }\n    else\n    {\n        // c2 = c1 = c0 = 0; the line is on the cone boundary.\n        type = 5;\n        parameter0 = -INFINITY;\n        parameter1 = +INFINITY;\n    }\n\n    // Post processing for bounded cones (cap,height)\n    if (cone.height < INFINITY)\n    {\n        if (DdU != Real(0))\n        {\n            // Ignore intersections outside\n            if (type > 0) {\n                Real3 p0 = lineOrigin + parameter0 * lineDirection;\n                Real3 p1 = lineOrigin + parameter1 * lineDirection;\n                \n                Real3 capPoint = cone.ray.origin + cone.cap * cone.ray.direction;\n                Real3 heightPoint = cone.ray.origin + cone.height * cone.ray.direction;\n                \n                bool p0outsideCap = dot(cone.capNormal, p0 - capPoint) > 0.0;\n                bool p0outsideHeight = dot(cone.heightNormal, p0 - heightPoint) > 0.0;\n                \n                bool p1outsideCap = dot(cone.capNormal, p1 - capPoint) > 0.0;\n                bool p1outsideHeight = dot(cone.heightNormal, p1 - heightPoint) > 0.0;\n                \n                bool p0outside = p0outsideCap || p0outsideHeight;\n                bool p1outside = p1outsideCap || p1outsideHeight;\n                if (p0outside && p1outside) type = 0;\n                else if (p0outside) parameter0 = parameter1;\n                else if (p1outside) parameter1 = parameter0;\n            }\n        }\n        else if (type > 0)\n        {\n            if (DdPmV > cone.height || DdPmV < cone.cap)\n            {\n                type = 0;\n            }\n        }\n    }\n\n    if (type > 0) {\n        // Extract smallest path length to intersection\n        Real t = parameter0;\n\n        // Calc normal\n        Real3 p = lineOrigin + t*lineDirection;\n        Real3 grad = normalize(p - cone.ray.origin);\n        Real3 normal = normalize(cross(grad, cross(grad, cone.ray.direction)));\n        outNormal = normal;\n\n        // Return smallest path length to intersection\n        return t;\n    } else {\n        return -1.0;\n    }\n}\n\nvec3  A = vec3(-.5 ,0, 0);\nvec3  B = vec3(-.2, .3, 0);\nfloat Ra = 0.2;\nfloat Rb = 0.1;\nvec3 Na = vec3(-1, 0, 0);\nvec3 Nb = vec3(1, 0, 0);\n\nvec3  A2 = vec3(-.2, .3, 0);\nvec3  B2 = vec3(.4, .4, 0);\nfloat Ra2 = 0.1;\nfloat Rb2 = 0.2;\nvec3 Na2 = vec3(-1, 0, 0);\nvec3 Nb2 = vec3(1, 0, 0);\n\nvec4 iCappedConeDE( in vec3  ro, in vec3  rd, \n                  in vec3  pb, in vec3  pa, \n                  in float rb, in float ra, vec3 na, vec3 nb )\n{\n    if (rb < ra) {\n        float tmp = ra;\n        ra = rb;\n        rb = tmp;\n        vec3 tmp2 = pa;\n        pa = pb;\n        pb = tmp2;\n        vec3 tmp3 = na;\n        na = nb;\n        nb = tmp3;\n    }\n    \n    float slope = (rb - ra) / distance(pa, pb);\n    float pzero = -ra / slope;\n    vec3 coneDir = normalize(pb - pa);\n    vec3 coneOrigin = pa + pzero * coneDir;\n    float coneAngle = atan(slope);\n    float coneCap = distance(pa, coneOrigin);\n    float coneHeight = distance(pb, coneOrigin);\n    \n    vec3 normal;\n    float t = intersectCone(ro, rd, Cone3(Ray3(coneOrigin, coneDir), coneAngle, \n                                          coneHeight, coneCap, na, nb), normal);\n    return vec4(t, normal);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec4 iCappedConeIQ( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb, vec3 na, vec3 nb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(rd,ba);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float m9 = dot(ob,ba); \n    \n    // caps\n    if( m1<0.0 )\n    {\n        if( dot2(oa*m2-rd*m1)<(ra*ra*m2*m2) ) // delayed division\n            return vec4(-m1/m2,-ba*inversesqrt(m0));\n    }\n    else if( m9>0.0 )\n    {\n        float t = -m9/m2;                     // NOT delayed division\n        if( dot2(ob+rd*t)<(rb*rb) )\n            return vec4(t,ba*inversesqrt(m0));\n    }\n    \n    // body\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    float k2 = m0*m0    - m2*m2*hy;\n    float k1 = m0*m0*m3 - m1*m2*hy + m0*ra*(rr*m2*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    float t = (-k1-sqrt(h))/k2;\n    float y = m1 + t*m2;\n    if( y<0.0 || y>m0 ) return vec4(-1.0); //no intersection\n    return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n}\n\n\n// 2D cross-section space\nvec2 project(vec3 p, vec3 radialDir, vec3 origin) {\n\tvec3 startPos = A, endPos = B;\n    vec3 tubeDir = normalize(endPos-startPos);\n    vec3 tmp = (p - origin);\n    return vec2(dot(tmp, tubeDir), dot(tmp, radialDir));\n}\n\nvec3 unproject(vec2 p, vec3 radialDir, vec3 origin) {\n\tvec3 startPos = A, endPos = B;\n    vec3 tubeDir = normalize(endPos-startPos);    \n    return origin + tubeDir * p.x + radialDir * p.y;\n}\n\nvec2 intersect(vec2 A, vec2 B, vec2 C, vec2 D) {\n    float x1 = A.x, y1 = A.y, x2 = B.x, y2 = B.y;\n    float x3 = C.x, y3 = C.y, x4 = D.x, y4 = D.y;\n    return vec2(\n        ((x1*y2-y1*x2)*(x3-x4) - (x1-x2)*(x3*y4-y3*x4)),\n        ((x1*y2-y1*x2)*(y3-y4) - (y1-y2)*(x3*y4-y3*x4)))\n        / ((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4));\n}\n\nvoid connect(vec3 nextPos, vec3 radialDir, vec3 nextRadialDir, float radius[2], float nextRadius, vec3 projOrigin,\n             out vec2 E, out vec2 F, out vec2 G, out vec2 H) {\n\tvec3 startPos = A, endPos = B;\n    vec2 A = project(startPos +radialDir*radius[0],      radialDir, projOrigin);\n    vec2 B = project(endPos   +radialDir*radius[1],      radialDir, projOrigin);\n    vec2 C = project(endPos   +nextRadialDir*radius[1],  radialDir, projOrigin);\n    vec2 D = project(nextPos  +nextRadialDir*nextRadius, radialDir, projOrigin);\n    vec2 A_ = project(startPos-radialDir*radius[0],      radialDir, projOrigin);\n    vec2 B_ = project(endPos  -radialDir*radius[1],      radialDir, projOrigin);\n    vec2 C_ = project(endPos  -nextRadialDir*radius[1],  radialDir, projOrigin);\n    vec2 D_ = project(nextPos -nextRadialDir*nextRadius, radialDir, projOrigin);\n    E = intersect(A,B,C,D);\n    F = intersect(A_,B_,C_,D_);\n    G = intersect(E,F,vec2(-1,0),vec2(1,0));\n    H = intersect(E,F,project(endPos,radialDir,projOrigin), project(nextPos,radialDir,projOrigin));\n}\n\nvec3 findOrthogonalVector(vec3 v) {\n    vec3 b = cross(v, vec3(0, 0, 1));\n    if (dot(b, b) < 0.01) {\n        b = cross(v, vec3(0, 1, 0));\n    }\n    return b;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 startPos = A, endPos = B;\n    vec3 nextPos = B2;\n    vec3 tubeDir = normalize(B-A);\n    vec3 radialDir = findOrthogonalVector(tubeDir);\n    vec3 nextTubeDir = normalize(nextPos-endPos);\n    vec3 nextRadialDir = normalize(cross(cross(nextTubeDir, radialDir), nextTubeDir));\n    float radius[2];\n    radius[0] = Ra;\n    radius[1] = Rb;\n    float nextRadius = Rb2;\n    vec3 radialDirCross = cross(tubeDir, radialDir);\n    vec3 nextRadialDirCross = cross(nextTubeDir, nextRadialDir);\n    \n    vec2 E, F, G, H;\n    connect(nextPos, radialDir, nextRadialDir, radius, nextRadius, endPos, E, F, G, H);\n    vec3 B_connected = unproject(G, radialDir, endPos);\n    vec3 A2_connected = unproject(H, radialDir, endPos);\n    vec3 planeVec1 = unproject(F, radialDir, endPos) - unproject(E, radialDir, endPos);\n    connect(nextPos, radialDirCross, nextRadialDirCross, radius, nextRadius, endPos, E, F, G, H);\n    vec3 planeVec2 = unproject(F, radialDirCross, endPos) - unproject(E, radialDirCross, endPos);\n    vec3 connectionNormal = cross(normalize(planeVec1), normalize(planeVec2));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        \n        // raytrace\n        //vec4 tnor = iCappedConeDE( ro, rd, A2, B2, Ra2, Rb2, Na2, Nb2 );\n        vec4 tnor = iCappedConeDE( ro, rd, A2_connected, B2, Ra2, Rb2, -connectionNormal, Nb2 );\n        //vec4 tnor = iCappedConeIQ( ro, rd, A, B, Ra, Rb, Na, Nb );\n\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 lightsource = vec3(1,0,0);\n        vec3 col = vec3(0.0);\n        if( t>0.0 )\n        {\n                col = vec3(clamp(dot(tnor.yzw, lightsource), 0., 1.)) + vec3(.05);\n        }\n        \n        // raytrace 2\n        //tnor = iCappedConeDE( ro, rd, A, B, Ra, Rb, Na, Nb );\n        tnor = iCappedConeDE( ro, rd, A, B_connected, Ra, Rb, Na, connectionNormal );\n        \n        if (tnor.x < t || t < 0.0) {\n            t = tnor.x;\n\n            // shading/lighting\t 2\n            if( t>0.0 )\n            {\n                col = vec3(clamp(dot(tnor.yzw, lightsource), 0., 1.)) + vec3(.05);\n            }\n        }\n\n        // gamma\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBzN.jpg", "access": "shaders20k", "license": "mit", "functions": [[3116, 3185, 3241, 3241, 3327], [3330, 3382, 3453, 3453, 3639], [3642, 3877, 3937, 3937, 4234], [4237, 4391, 4445, 4445, 4592], [4594, 5665, 5757, 5757, 14605], [14891, 14891, 15047, 15047, 15762], [15764, 15764, 15789, 15789, 15808], [15810, 15810, 15966, 15966, 17054], [17057, 17083, 17134, 17134, 17301], [17303, 17303, 17356, 17356, 17494], [17496, 17496, 17544, 17544, 17824], [17826, 17826, 18003, 18003, 18890], [18892, 18892, 18927, 18927, 19052]], "test": "valid"}
{"id": "ttScDK", "name": "v3Zebra.glsl", "author": "jorge2017a1", "description": "///source code of ShaderSketches", "tags": ["v3zebraglsl"], "likes": 14, "viewed": 96, "published": "Public", "date": "1595382742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float pi = 3.14159265359;\n    float size = iResolution.y / 10.0; // cell size in pixel\n\n    vec2 p1 = fragCoord.xy / size; // normalized pos\n    vec2 p2 = fract(p1) - 0.5; // relative pos from cell center\n\n    // random number\n    float rnd = dot(floor(p1), vec2(12.9898, 78.233));\n    rnd = fract(sin(rnd) * 43758.5453);\n\n    // rotation matrix\n    float phi = rnd * pi * 2.0 + iTime * 0.4;\n    mat2 rot = mat2(cos(phi), -sin(phi), sin(phi), cos(phi));\n\n    vec2 p3 = rot * p2; // apply rotation\n    p3.y += sin(p3.x * 5.0 + iTime * 2.0) * 0.12; // wave\n\n    float rep = fract(rnd * 13.285) * 8.0 + 2.0; // line repetition\n    float gr = fract(p3.y * rep + iTime * 0.8); // repeating gradient\n\n    // make antialiased line by saturating the gradient\n    float c = clamp((0.25 - abs(0.5 - gr)) * size * 0.75 / rep, 0.0, 1.0);\n    c *= max(0.0, 1.0 - length(p2) * 0.6); // darken corners\n\n    vec2 bd = (0.5 - abs(p2)) * size - 2.0; // border lines\n    c *= clamp(min(bd.x, bd.y), 0.0, 1.0);\n\n    fragColor = vec4(c);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttScDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1086]], "test": "valid"}
{"id": "ttScRh", "name": "Logic vs Math", "author": "Oggbog", "description": "Hello, just a quick question. Which method of drawing a square is more efficient? Logic or Math? I've included a bit of domain distortion to see the effect on both methods.", "tags": ["question"], "likes": 0, "viewed": 158, "published": "Public API", "date": "1593682515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // simple domain distortion\n    uv.y += sin(uv.x*40.+iTime*4.)*.05;\n    \n\t// logic square\n    float s1 = (uv.x>-0.4 && uv.x<-0.2 && uv.y>-.1 && uv.y<0.1) ? 1.0 : 0.0;\n    \n    // math square\n    float s2 = step(0.2,uv.x) - step(0.4,uv.x);\n    s2 *= step(-0.1,uv.y) - step(0.1,uv.y);\n    \n    \n    fragColor = vec4(s1,s2,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttScRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 458]], "test": "valid"}
{"id": "ttScWK", "name": "v3GradNoise3.glsl", "author": "jorge2017a1", "description": "v3GradNoise3.glsl", "tags": ["v3gradnoise3glsl"], "likes": 2, "viewed": 64, "published": "Public", "date": "1595449924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 fade(vec3 x) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\n\nvec3 phash(vec3 p)\n{\n    p = fract(mat3(1.2989833, 7.8233198, 2.3562332,\n                   6.7598192, 3.4857334, 8.2837193,\n                   2.9175399, 2.9884245, 5.4987265) * p);\n    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;\n    return normalize(fract(p) * 2.0 - 1.0);\n}\n\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float d000 = dot(phash(ip), fp);\n    float d001 = dot(phash(ip + vec3(0, 0, 1)), fp - vec3(0, 0, 1));\n    float d010 = dot(phash(ip + vec3(0, 1, 0)), fp - vec3(0, 1, 0));\n    float d011 = dot(phash(ip + vec3(0, 1, 1)), fp - vec3(0, 1, 1));\n    float d100 = dot(phash(ip + vec3(1, 0, 0)), fp - vec3(1, 0, 0));\n    float d101 = dot(phash(ip + vec3(1, 0, 1)), fp - vec3(1, 0, 1));\n    float d110 = dot(phash(ip + vec3(1, 1, 0)), fp - vec3(1, 1, 0));\n    float d111 = dot(phash(ip + vec3(1, 1, 1)), fp - vec3(1, 1, 1));\n    fp = fade(fp);\n    return mix(mix(mix(d000, d001, fp.z), mix(d010, d011, fp.z), fp.y),\n               mix(mix(d100, d101, fp.z), mix(d110, d111, fp.z), fp.y), fp.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    vec3 p = vec3(fragCoord.xy * 10.0 / iResolution.y, iTime);\n    fragColor = vec4(noise(p) / 2.0 + 0.5);\n}\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttScWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 71], [73, 73, 93, 93, 372], [374, 374, 395, 395, 1135], [1137, 1137, 1199, 1199, 1308]], "test": "valid"}
{"id": "ttsfRr", "name": "Mediterranean tiles", "author": "carolhmj", "description": "Shader following The Art of Code's video about KIFS fractals. I used the same method he used to build the first snowflake to repeat more snowflakes.", "tags": ["fractal", "kifs"], "likes": 3, "viewed": 62, "published": "Public", "date": "1595897068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ZOOM 15.\n\nvec2 N(float angle) {\n\treturn vec2(sin(angle), cos(angle));\n}\n\nfloat sigmoid(float x) {\n\treturn 1./(1.+.6*exp(-x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n \n    float mult = 1. + MAX_ZOOM*sigmoid(sin(iTime*.08)*5.);\n    uv *= mult;\n    \n    vec3 col = vec3(0);\n       \n    vec2 n;\n    float d;\n    \n    for (int i = 0; i < int(mult); i++) {\n        uv = abs(uv);\n        vec2 delta = vec2(.25,0.); // Distance between repetitions - increase this to make then repeat farther away from each other\n        uv -= delta;\n        n = N((1./3.)*3.1415);\n        d = dot(uv-vec2(.5,0.), n);\n        uv -= n*max(0., d)*2.;\n        uv += delta;\n    }\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.)*3.1415)*.5;\n    \n    n = N((5./6.)*3.1415);\n    d = dot(uv-vec2(.5,0.), n);\n    uv -= n*max(0., d)*2.;\n    \n    n = N((2./3.) * 3.1415);\n    uv.x += .5;\n    float scale = 1.;\n    for (int i = 0; i < 4; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n\n        // The shape is symmetrical around the x-axis, so we only have\n        // to worry about half of the x coordinates\n        uv.x = abs(uv.x);\n        // Make the line wider (both sides will measure .5 more)\n        uv.x -= .5;\n        // Bend the line around a normal\n        uv -= n*min(0., dot(uv, n))*2.;\n    }\n    \n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    col += smoothstep(1./iResolution.y, .0, d/(scale*mult));\n    uv /= scale;\n    col += texture(iChannel0, uv*2.-iTime*.02).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 43, 43, 83], [85, 85, 109, 109, 139], [141, 141, 198, 198, 1649]], "test": "error"}
{"id": "ttSyR3", "name": "Cube Fall", "author": "shau", "description": "quick sketch, rendering some cubes using partitioned space marching from Nimitz", "tags": ["3d"], "likes": 44, "viewed": 626, "published": "Public", "date": "1595088831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/**\n * Loosley inspired by GIF animation on Pouet\n * and Sparse grid marching by Nimitz\n **/\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .005\n#define FAR 140.\n#define T iTime\n#define TORUS vec2(40.0,18.0)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Nimitz\n//https://www.shadertoy.com/view/XlfGDs\nconst float c = 1.0;\nconst float ch = c * 0.5;\nconst float ch2 = ch + 0.01;\nfloat dBox(vec3 ro, vec3 rd)  \n{\n    vec3 m = 1. / rd;\n    vec3 t = -m * ro + abs(m) * ch2;\n\treturn min(min(t.x, t.y), t.z);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796,0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr,0.,1.);\n}\n\n//Dave Hoskins - Hash without sin\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//SDF functions IQ\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat boxedTorus(vec3 p, vec3 rd)\n{\n    float AT = T*0.4;\n    vec3 q = p;\n    q.yz *= rot(AT);\n    rd.yz *= rot(AT);\n    vec3 qd = fract(q/c)*c -ch;\n    vec3 qid = floor(q/c) + 0.5;\n    vec2 h2 = hash23(qid);\n    float t = dBox(qd, rd); //Base distance is cell exit distance\n    if (sdTorus(floor(q/c)+.5,TORUS) < 0. && p.y < 0.)\n    {\n        qd.yz *= rot(h2.y + h2.x*T);\n        qd.zx *= rot(h2.x + h2.y*T);\n        t = min(t, sdBox(qd, vec3(0.3)));    \n    }\n    return t;\n}\n\nfloat boxedWall(vec3 p, vec3 rd)\n{\n    float AT = T*0.4;\n    p.y += AT * 25.;\n    vec3 qd = fract(p/c)*c -ch;\n    vec3 qid = floor(p/c);\n    vec2 h2 = hash23(qid);\n    float t = dBox(qd, rd); //Base distance is cell exit distance\n    if (p.z > (TORUS.x - TORUS.y))\n    {\n        qd.yz *= rot(h2.y + h2.x*T);\n        qd.zx *= rot(h2.x + h2.y*T);\n        t = min(t, sdBox(qd, vec3(0.3)));    \n    }\n    return t;\n}\n\nfloat map(vec3 p, vec3 rd) \n{    \n    return min(boxedTorus(p, rd), boxedWall(p, rd));\n}\n\nvec3 normal(vec3 p, vec3 rd) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz, rd);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec3 pc = vec3(0),\n         lp = vec3(-10,8,-8),\n        sc = rotHue(vec3(1,0.5,0.1), T*0.3);\n\n    float t = 0.0, mint = FAR;   \n    for (int i=0; i<360; i++)\n    {\n        float ns = map(ro + rd*t, rd);\n        if (ns<EPS)\n        {\n            break;\n        }\n        t += ns;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n    }\n    \n    if (t>0.0)\n    {\n        mint = t;\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p,rd);\n        vec3 ld = normalize(lp - p);\n        float lt = length(lp - p); \n        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 32.0);\n        \n        pc += sc*0.4*max(0.05,dot(ld,n)) / (1. + lt*lt*0.02);\n        pc += sc*spec*2.;\n        pc += vec3(0.6,0.1,0.8)*0.01*max(0.,n.y);\n    }\n\n    pc *= exp(-0.06 * mint); \n    pc = pow(pc,vec3(.43545));\n    \n    return vec4(pc,mint);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float AT = T - 4.1;\n    vec3 pc = vec3(0),\n         la = vec3(0,-10,TORUS.x),\n         ro = vec3(sin(AT*0.2)*20.,\n                   -20.0,\n                   -5. + cos(AT*0.31)*3.);\n    ro.y -= ro.x*ro.x*0.02*sin(AT*0.3);\n    \n    float fl = 1.4;\n    mat3 cam = camera(la,ro,0.);  \n\n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,fl));        \n    vec4 scene = render(ro,rd);\n    pc = scene.xyz;\n\n    pc = 1.15*pow(pc,vec3(0.9,0.95,1.0)) + vec3(-0.04,-0.04,0.0); //IQ\n    pc = pow(pc,vec3(0.80,0.85,0.9));\n    pc *= 1. / (1. + length(uv)*length(uv)*0.2);\n\n    C = vec4(pc*2.4,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSyR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[399, 428, 447, 447, 493], [620, 620, 652, 652, 746], [748, 905, 935, 935, 1301], [1303, 1337, 1359, 1359, 1478], [1480, 1499, 1531, 1531, 1605], [1607, 1607, 1637, 1637, 1732], [1734, 1734, 1769, 1769, 2211], [2213, 2213, 2247, 2247, 2625], [2627, 2627, 2656, 2656, 2715], [2717, 2717, 2748, 2748, 2936], [2938, 2938, 2969, 2969, 3833], [3835, 3840, 3881, 3881, 4052], [4054, 4054, 4090, 4090, 4704]], "test": "valid"}
{"id": "ttSyRd", "name": "stolen mandelbrot", "author": "feedme", "description": "to convert", "tags": ["learning"], "likes": 4, "viewed": 236, "published": "Public API", "date": "1595082241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define distfar 6.0\n#define iterations 4\n\nfloat calcfractal(vec3 coord) {\n    vec3 orbit = coord;\n    float dz = 1.0; // darkness again\n    \n    for (int i=0; i<iterations; i++) {\n        \n        float r = length(orbit);\n    \tfloat o = acos(orbit.z/r);\n    \tfloat p = atan(orbit.y/orbit.x);\n        \n        dz =12.0*r*r*r*r*r*r*r*dz + 1.0; // this effected darkness and tone\n        \n        r = r*r*r*r*r*r*r;\n        o = 4.0*o;                // alter the fractal\n        p = 16.0*p;               // alter the fractal / vertical division\n        \n        orbit = vec3( r*sin(o)*cos(p), r*sin(o)*sin(p), r*cos(o) ) + coord;\n        \n        if (dot(orbit,orbit) > 1.544) break; // changing this changed the fractal itself, going to 1 to reset\n    }\n    float z = length(orbit);\n    return 0.6*z*log(z)/dz; // shadows\n}\n\nvec2 map(vec3 p) {\n    return vec2(calcfractal(p.xzy),1.0);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.2;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return vec3(t, h.y, i);\n        t += h.x;\n    }\n    return vec3(0.0);\n}\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0801,0.0); // moving highlights?\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 0.;\n    float t = 0.1;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>1.0) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 4.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0)*uv-1.0;                            // size from bottom left // second no. horizontal align\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-1.4);  // horizontal cam // vertical cam // distance\n    vec3 rd = normalize(vec3(uv,1.5));\n    float the = 3.0*sin(iTime/30.0-1.0); // vertical axis set zero\n    mat2 rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.yz *= rmat;\n    ro.yz *= rmat;\n    the = iTime/30.0; // turn speed // higher is slower\n    rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.xz *= rmat;\n    ro.xz*= rmat;\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.); // BACKGROUND COLOUR\n    \n    if (t.z > 0.0) {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor = calcnormal(pos);\n        vec3 lig = normalize(vec3(0.3,1.0,0.3)); // light direction?\n        vec3 rdy = dot(nor, rd) * nor;\n        vec3 rdx = rd - rdy;\n        vec3 ref = rdx - rdy;\n        \n        float occ = clamp(0.0,1.0,1.0/(1.0+pow(t.z/30.0,3.0)));\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0,dot(lig,nor));\n        float sky = max(0.0,nor.y); // brightness / dodge\n        float ind = max(0.0,dot(-lig,nor));\n        float spec = pow( max(0.0,dot(ref,lig)) , 20.0);\n        \n        col  = dif*vec3(0.9,0.8,0.7)*vec3(sha);\n        col += sky*vec3(0.16,0.20,0.24)*occ;\n        col += ind*vec3(0.40,0.48,0.40)*occ;\n        col += 0.1*occ;\n        col += spec*sha*vec3(0.9,0.8,0.7);\n\n        \n        col = pow(col,vec3(0.45));\n    }\n    \n\tfragColor = vec4(col,1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 73, 73, 822], [824, 824, 842, 842, 885], [887, 887, 917, 917, 1140], [1142, 1142, 1167, 1167, 1388], [1390, 1390, 1427, 1427, 1683], [1686, 1686, 1743, 1743, 3337]], "test": "valid"}
{"id": "ttSyzh", "name": "Spectral Duck", "author": "dr2", "description": "Duck(s) covered with a thin oil layer (pseudo: Newton's Rings)", "tags": ["reflection", "interference", "optics"], "likes": 7, "viewed": 220, "published": "Public API", "date": "1593687276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Spectral Duck\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, vuPos, dukPos, eyePos;\nfloat tCur, dstFar, roomRd, roomHt, sclFac;\nint idObj;\nconst int idFrm = 1, idWl = 2, idFlrCl = 3, idTbl = 4, idLeg = 5, idLit = 6,\n   idBdy = 7, idBk = 8, idEye = 9;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat DuckDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 cs, r;\n  float d, h, s;\n  dMin /= sclFac;\n  p /= sclFac;\n  cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  DMIN (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  DMIN (idBdy);\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dMin, 0.1);\n  DMIN (idBdy);\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= -0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 0.5 * h)), dMin, 0.01);\n  DMIN (idBk);\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - eyePos, 0.125);\n  DMIN (idEye);\n  return 0.9 * sclFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, nw, w;\n  dMin = dstFar;\n  nw = 9.;\n  q = p;\n  q.y -= roomHt;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nw * atan (q.z, - q.x) / (2. * pi) + 0.5) / nw);\n  q.x += roomRd;\n  w = roomRd * tan (pi / nw);\n  d = max (q.x, - PrBox2Df (q.yz, vec2 (roomHt - 0.2, w - 0.2)));\n  DMIN (idFrm);\n  d = q.x + 0.25;\n  DMIN (idWl);\n  d = roomHt - abs (q.y);\n  DMIN (idFlrCl);\n  q = p;\n  q.y -= 1.;\n  d = PrCylDf (q.xzy, 0.6, 0.02);\n  DMIN (idTbl);\n  q = p;\n  q.y -= 0.5;\n  q.xz += 0.02 * sin (7. * pi * q.y + vec2 (0.5 * pi, 0.));\n  d = PrCylDf (q.xzy, 0.03, 0.5);\n  DMIN (idLeg);\n  q = p;\n  d = PrCylDf (q.xzy, 0.2, 0.04 * (1. - 0.6 * smoothstep (0.1, 0.2, length (q.xz))));\n  DMIN (idLeg);\n  q = p - dukPos;\n  dMin = DuckDf (q, dMin);\n  if (! isSh) {\n    q = p;\n    q -= ltPos;\n    d = PrSphDf (q, 0.1);  \n    DMIN (idLit);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (h, 0.02, 0.2);\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, refCol, vn, ltVec, ltDir, ve;\n  float dstObj, w, sx, ld, sh;\n  const int nRef = 5;\n  sclFac = 0.4;\n  eyePos = vec3 (0.26, 0.825, -0.6);\n  col = vec3 (0.);\n  refCol = vec3 (1.);\n  isSh = false;\n  for (int n = VAR_ZERO; n < nRef; n ++) {\n    dstObj = ObjRay (ro, rd);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (n < nRef - 1 && dstObj < dstFar && idObj == idWl) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refCol *= 0.8;\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idBdy) {\n      w = -0.6 - 1.2 * dot (rd, vn);\n      col4.rgb = mix (HsvToRgb (vec3 (mod (w + 0.3, 1.), 1., 1.)),\n         HsvToRgb (vec3 (mod (w - 0.3, 1.), 1., 1.)), 0.5);\n      col4 = vec4 (mix (HsvToRgb (vec3 (mod (w, 1.), 1., 1.)), col4.rgb, 0.5), 0.2);\n    } else if (idObj == idBk) {\n      col = vec3 (0.3, 0.1, 0.);\n      col4 = vec4 (col, 0.2);\n    } else if (idObj == idEye)  {\n      sx = sign (ro.x);\n      ve = eyePos * sclFac;\n      ve.x *= sx;\n      ve = RotToDirLim (normalize (vuPos - dukPos - ve), vec3 (sx, 0., 0.),\n         ro - dukPos - ve, 0.35 * pi);\n      col4 = vec4 (vec3 (0.5, 1., 0.5) * (1. - 0.9 * step (length (ve.yz) / sclFac, 0.05 +\n         0.01 * SmoothBump (0.25, 0.75, 0.25, mod (8. * atan (ve.z, - ve.y) / pi, 1.)))), -2.);\n    } else if (idObj == idFrm) {\n      col4 = vec4 (0.5, 0.2, 0., 0.1);\n    } else if (idObj == idWl) {\n      col4 = vec4 (0.1, 0.3, 0., 0.);\n    } else if (idObj == idFlrCl) {\n      col4 = (ro.y < roomHt) ? vec4 (0.35, 0.3, 0.2, 0.) : vec4 (0.7, 0.7, 1., 0.);\n    } else if (idObj == idTbl) {\n      col4 = vec4 (0.85, 0.95, 0.9, 0.2);\n      if (vn.y > 0.99) col4 = mix (vec4 (0.5, 0.7, 0.4, 0.1), col4, \n         smoothstep (0.015, 0.02, abs (Fbm2 (vec2 (4., 1.) * ro.xz) - 0.4)));\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    } else if (idObj == idLit) {\n      col4 = vec4 (1., 1., 0.7, -1.);\n    }\n    if (idObj == idFlrCl || idObj == idFrm) vn = VaryNf (32. * ro, vn, 0.2);\n    if (col4.a >= 0.) {\n      isSh = true;\n      ltVec = ltPos - ro;\n      ld = length (ltVec);\n      ltDir = ltVec / ld;\n      if (idObj == idBdy) col4.rgb = mix (vec3 (0.5, 0.3, 0.3), col4.rgb,\n         smoothstep (-0.2, 0.2, dot (vn, ltDir)));\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir, ld);\n      col = refCol * (col4.rgb * (0.2 + 0.3 * max (- dot (vn, ltDir), 0.) +\n         0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    } else if (col4.a == -1.) col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n    else if (col4.a == -2.) col = col4.rgb;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, ltAz, ltEl;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 2. * pi * sin (0.005 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  roomRd = 6.;\n  roomHt = 2.;\n  ro = vec3 (0.6 * roomRd * cos (el) * sin (az + vec2 (0.5 * pi, 0.)),\n     0.9 * roomHt * sin (el)).xzy;\n  ro.y += roomHt;\n  dukPos = vec3 (0., 1.21, 0.);\n  vd = normalize (dukPos - ro);\n  u = - vd.y * vd;\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (u.x, 1. + u.y, u.z) / sqrt (1. - vd.y * vd.y), vd);\n  vuPos = ro;\n  zmFac = 3.;\n  dstFar = 20.;\n  ltAz = 0.1 * pi * tCur;\n  ltEl = 0.15 * pi * sin (2.3 * ltAz);\n  ltPos = vec3 (0.5 * roomRd * cos (ltEl) * sin (ltAz + vec2 (0.5 * pi, 0.)),\n     0.8 * roomHt * sin (ltEl)).xzy;\n  ltPos.y += 1.4 * roomHt;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = max (dot (v1, v2), cos (aMax));\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSyzh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[990, 990, 1025, 1025, 2245], [2247, 2247, 2269, 2269, 3122], [3124, 3124, 3157, 3157, 3340], [3342, 3342, 3363, 3363, 3618], [3620, 3620, 3671, 3671, 3954], [3956, 3956, 3991, 3991, 6660], [6662, 6662, 6718, 6718, 8274], [8276, 8276, 8309, 8309, 8398], [8400, 8400, 8433, 8433, 8460], [8462, 8462, 8504, 8504, 8555], [8557, 8557, 8592, 8592, 8654], [8656, 8656, 8700, 8700, 8775], [8777, 8777, 8822, 8822, 8925], [8927, 8927, 8984, 8984, 9067], [9069, 9069, 9126, 9126, 9300], [9302, 9302, 9332, 9332, 9445], [9447, 9447, 9478, 9478, 9542], [9544, 9544, 9568, 9568, 9685], [9719, 9719, 9743, 9743, 9855], [9857, 9857, 9882, 9882, 10068], [10070, 10070, 10091, 10091, 10246], [10248, 10248, 10277, 10277, 10489], [10491, 10491, 10530, 10530, 10715]], "test": "error"}
{"id": "ttVGzG", "name": "Hexagon lighting", "author": "Atchafalaya", "description": "Playing around with some hexagon algorithms for my first shader", "tags": ["hexagons"], "likes": 2, "viewed": 55, "published": "Public", "date": "1595416259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define Focal 1000\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Material as follow, ambiant, diffuse, specular, shininess.\nvec4 material() { return vec4(0.3, 0.5, 0.8, 0.9); }\n\nvec2 transformToHexBase(vec2 uv, float hexSize)\n{\n    mat2 toHexBase = mat2(sqrt(3.), 0., -1., 2.)/(3. * 2. * hexSize);\n    return toHexBase * uv;\n}\n\nivec2 roundHex(vec2 f)\n{\n    float fq = f.x;\n    float fr = f.y;\n    float q = round(fq);\n    float r = round(fr);\n    float s = round(-fq -fr);\n    vec3 diff = vec3(abs(q-fq), abs(r-fr), abs(s + fq + fr));\n    if (diff.x > diff.y && diff.x > diff.z) { q = -r -s; }\n    else if (diff.y > diff.z) \t\t\t\t{ r = -q -s; }\n    else \t\t\t\t\t\t\t\t\t{ s = -q -r; }\n    return ivec2(q, r);\n}\n\nvec3 getViewer(vec2 uv)\n{\n    return normalize(vec3(-uv, -Focal));\n}\n\nvec3 getNormal(vec2 uv, float hexSize)\n{\n    float hexHeight = 0.05;\n    float halfsqrt3 = sqrt(3.)/2.;\n    ivec2 ihexCoord = roundHex(transformToHexBase(uv, hexSize));\n    vec2 hexCoord = vec2(ihexCoord.x, ihexCoord.y);\n    mat2 toUVBase = mat2(sqrt(3.), 0., sqrt(3.)/2., 3./2.) * 2.*hexSize;\n    vec2 hexCenter = toUVBase * hexCoord;\n    vec2 diff = uv - hexCenter;\n    if (diff.x == 0.) return normalize(vec3(0., sign(diff.y) * hexHeight, -hexSize));\n    if (abs(atan(diff.y/diff.x)) < PI/6.)\n    {\n        return normalize(vec3(sign(diff.x) * hexHeight, 0., -halfsqrt3 * hexSize));\n    }\n    else if (atan(diff.y/diff.x) > PI/6.)\n    {\n        return normalize(vec3(rot2(PI/3.)*vec2(sign(diff.y) * hexHeight, 0.), -halfsqrt3 * hexSize));\n    }\n\telse if (atan(diff.y/diff.x) < -PI/6.)\n    { \n        return normalize(vec3(rot2(-PI/3.)*vec2(sign(-diff.y) * hexHeight, 0.), -halfsqrt3 * hexSize));\n    }\n    else { return vec3(length(diff)); }\n}\n\nvec3 getColor(vec2 uv, float hexSize)\n{\n    float t = 0.5 - uv.y;\n    float r = max(0., 1. - 3. * t) + min(max(0.,1.5 * t-1.), 1.);\n    float g = min(1., 1. - 3.*abs(t-1./3.));\n    float b = min(1., 1. - 3.*abs(t-2./3.));\n\treturn vec3(r,g,b);\n}\n\nvec3 phongIlluminate(vec2 uv, vec3 lightPos, float hexSize)\n{\n    vec3 viewer = getViewer(uv);\n    vec3 normal = getNormal(uv, hexSize);\n    vec3 objectPos = vec3(uv, 0.);\n    \n    vec3 L = normalize(lightPos - objectPos);\n    vec3 R = normalize(2.*dot(L,normal)*normal - L);\n    viewer = normalize(viewer - objectPos);\n    \n    if (dot(L, normal) > 0. && dot(viewer, normal) > 0.)\n    {\n        float kd = material().y;\n        float ks = material().z;\n        float shi = material().w;\n        float I = kd*dot(L, normal);\n        if (dot(R, viewer) > 0.)\n        {\n            I += pow(ks*dot(R, viewer), shi);\n        }\n        \n        return I*getColor(uv, hexSize);\n\t}\n    else\n    {\n        return vec3(0.);\n\t}\n}\n\nvec3 rayTrace(vec2 uv, float hexSize)\n{\n    vec3 result;\n    vec3 lightPos1 = float(Focal) * vec3(sin(iTime), -1./3., -abs(cos(iTime)));\n    result += phongIlluminate(uv, lightPos1, hexSize);\n    vec3 lightPos2 = vec3(sin(0.1*iTime), cos(0.1*iTime), -Focal);\n    result += phongIlluminate(uv, lightPos2, hexSize);\n    vec3 lightPos3 = vec3(-sin(0.1*iTime), -cos(0.1*iTime), -Focal);\n    result += phongIlluminate(uv, lightPos3, hexSize);\n    return result / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n    float hexSize = 0.05;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n\tfloat scrWidth = iResolution.x/iResolution.y;\n\tfloat scrHeight = 1.;\n    uv.x *= scrWidth;\n    mousePos.x *= scrWidth;\n    uv -= vec2(scrWidth, scrHeight)/2.;\n    \n    vec3 col = rayTrace(uv, hexSize);\n\tfragColor = vec4(pow(col, vec3(0.6)), 1.0);\n\n    /*\n    mousePos -= vec2(scrWidth, scrHeight)/2.;\n    \n    ivec2 qr = roundHex(transformToHexBase(uv, hexSize));\n    int q = qr.x;\n    int r = qr.y;\n\tivec2 mouseqr = roundHex(transformToHexBase(mousePos, hexSize));\n    if (q == mouseqr.x && r == mouseqr.y)\n    {\n        fragColor = vec4(0.8, 0.8, 1., 1.);\n    }\n    else\n    {\n        // Output to screen\n        fragColor = vec4(abs(float(q)/6.),\n                         abs(float(r)/4.) ,\n                         0.0,\n                         1.0);\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 87, 87, 145], [147, 209, 226, 226, 261], [263, 263, 312, 312, 411], [413, 413, 437, 437, 786], [788, 788, 813, 813, 856], [858, 858, 898, 898, 1804], [1806, 1806, 1845, 1845, 2050], [2052, 2052, 2113, 2113, 2772], [2774, 2774, 2813, 2813, 3237], [3239, 3239, 3296, 3314, 4254]], "test": "valid"}
{"id": "wdjczW", "name": "Circle glow animation", "author": "nicolaecodreanu", "description": "2D animation with circles. \nInspired from other shadertoy examples.", "tags": ["2d", "circle", "animation"], "likes": 12, "viewed": 124, "published": "Public", "date": "1594909304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define ANIMATION_TIMESCALE 0.5\n#define ANIM_FUNC Quart\n#define polar(a) vec2(cos(a),sin(a))\n#define rotate(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\nfloat sdCircle(in vec2 p, in float r) \n{\n \treturn length(p) - r;   \n}    \n\nfloat Quart(float s, float e, float t)\n{\n    t = clamp((t - s) / (e - s), 0.0, 1.0);\n    return 1.0 - pow(1.0 - t, 4.0);\n}\n\nfloat exponentialOut(float s,float e,float t) {\n  \tt = clamp((t - s) / (e - s),0.0,1.0);\n  \treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float px = 1.5 / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    //----------circle\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n        //setup timer loop\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, 3.0);\n        \n        //setup animation\n        float fillIn = ANIM_FUNC(0.0, 1.0, t);\n        float fadeOut = ANIM_FUNC(2.0, 3.0, t);\n        \n        //setup mask\n        float v = fillIn * (TWOPI + 0.3); //value\n        float i = v - 0.3; //interval \n        float a = mod(atan(uv.y, uv.x) - 0.5 * PI, TWOPI); //positive values in interval [0, TWOPI]\n        float fillMask = 1.0 - smoothstep(i, v, a);\n        float mask = fillMask - fadeOut;\n        \n        //draw circle\n        float r = 0.3;\n        float d = sdCircle(cv, r);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(0.0, px, abs(d))) * mask);\n    }\n   \n    //----------satellites\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n        //setup timer loop\n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //rotation\n        float rotation = exponentialOut(0.0, 1.0, t);\n        cv *= rotate(t * 0.1 * rotation);\n        \n        //positions\n        const float cnt = 4.0;\n        vec2 dirs[int(cnt)];\n        for(float i = 0.0; i < cnt; i++) \n        {\n            dirs[int(i)] = polar(i * TWOPI / cnt + PI * 0.5);\n        }\n        \n        for(float i = 0.0; i < cnt; i++) \n        {\n            //setup animation\n            float show = (0.5 / cnt) * i;\n            float fadeIn = ANIM_FUNC(show, show + 0.1, t);\n            float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n            \n            //setup mask\n           \tfloat mask = fadeIn - fadeOut;\n            \n            //draw sattelites\n            float d = sdCircle(cv - dirs[int(i)] * 0.3, 2.0 * px);\n            col = mix(col, vec3(1.0), (1.0 - smoothstep(-px, px, d)) * mask);\n        }\n    }\n    \n    //----------dotted circle\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n    \t//setup timer loop\n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //setup animation\n        float fadeIn = ANIM_FUNC(0.0, 1.0, t);\n        float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n        float scaleUp = exponentialOut(0.0, 1.0, t);\n        \n        //setup mask\n        float mask = fadeIn - fadeOut;\n        \n        //draw circle\n        float r = 0.18 + scaleUp * 0.1;\n        float d = sdCircle(cv, r);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(-3.0 * px, 1.0 * px, abs(d))) * mask);\n    }    \n    \n    //----------dotted sattelites\n    {\n        //circle uv\n        vec2 cv = uv;\n        \n        //setup timer loop\n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //rotation\n        float rotation = exponentialOut(0.0, 1.0, t);\n        cv *= rotate(t * 0.2 * -rotation);\n        \n        //positions\n        const float cnt = 100.0;\n        vec2 dirs[int(cnt)];\n        for(float i = 0.0; i < cnt; i++)\n        {\n        \tdirs[int(i)] = polar(i * TWOPI / cnt);\n        }    \n        \n        for(float i = 0.0; i < cnt; i++)\n        {\n         \t//setup animation\n            float fadeIn = ANIM_FUNC(0.0, 1.0, t);\n            float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n            float scaleUp = exponentialOut(0.0, 1.0, t);\n            \n            //setup mask\n            float mask = fadeIn - fadeOut;\n            \n            //draw sattelites\n            float d = sdCircle(cv - dirs[int(i)] * (0.18 + scaleUp * 0.1), px * 0.5);\n            col = mix(col, vec3(1.0), (1.0 - smoothstep(-2.0 * px, px, d)) * mask);\n        }           \n    }    \n   \n    //----------glowing circle\n    {\n    \t//circle uv\n        vec2 cv = uv + vec2(-0.03, 0.03);\n        \n        //setup timer loop\n        const float loop = 30.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n        \n        //rotation\n        float rotation = exponentialOut(0.0, 1.0, t);\n        cv *= rotate(t * 0.5 * -rotation);\n        \n        //deformation\n        cv += variation(cv, vec2(0.0, 2.0), 0.5, 1.0);\n        \n        //setup animation\n        float fadeIn = ANIM_FUNC(0.5, 2.0, t);\n        float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n        \n        //setup mask\n        float mask = fadeIn - fadeOut;\n        \n        //draw circle\n        float a = atan(cv.y, cv.x);\n        float r = 0.3;\n        float d = sdCircle(cv, r);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(-10.0 * px, 2.0 * px, abs(d))) * mask);\n        col = mix(col, vec3(1.0), (1.0 - smoothstep(-30.0 * px, 10.0 * sin(a) * px, abs(d))) * smoothstep(px, -px, d) * mask);\n    }    \n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 241, 241, 270], [276, 276, 316, 316, 398], [400, 400, 447, 447, 542], [544, 544, 608, 608, 707], [710, 710, 767, 767, 5668]], "test": "error"}
{"id": "wdScRd", "name": "Futuristic Tunnel", "author": "julianlumia", "description": "Some random sketch I found\n", "tags": ["futuristic"], "likes": 42, "viewed": 2988, "published": "Public", "date": "1593555778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 60\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n//---------\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\n\nvec2 path(float z){\n float x = sin(z) - 4.0 * cos(z * 0.3) - .5 * sin(z * 0.12345);\n float y = cos(z) - 4. * sin(z * 0.3) - .5 * cos(z * 2.12345);\n return vec2(x,y);\n}\nvec2 path2(float z){\n float x = z;\n float y = cos(z) - 10. * sin(z * 0.3) - .01 * cos(z * .14);\n return vec2(x,y);\n}\n\n\nvec2 modA (vec2 p, float count) {\n float an = TAU/count;\n float a = atan(p.y,p.x)+an*.5;\n a = mod(a, an)-an*.5;\n return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat smin (float a, float b, float r)\n{\n float h = clamp(.5+.5*(b-a)/r,0.,1.);\n return mix(b, a, h) - r*h*(1.-h);\n}\n\n\n//----\n\n\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\n\nvec2 GetDist(vec3 p) {\n    \n vec2 o2 = path2(p.z) / 4.;\n p = vec3(p.x,p.y,p.z)-vec3(o2.x,o2.y,0.);  \n    \n    \n vec2 d;\n vec3 p2 = p;\n float gap = 1.;\n p2 = mod(p + gap,2.0 * gap) - gap;\n\n     vec3 p4 = p;\n     float gap2 = 1.;\n\n p4.z = mod(p.z + gap2,2.0 * gap) - gap;\n    \n vec2 box = vec2(sdBox(p2-vec3(0,0.,.0), vec3(.1,1.,.95)),3);\n vec2 box2 = vec2(sdBox(p2-vec3(0.,0.,.0), vec3(.8,.2,.95)),3);\n vec2 box3 = vec2(sdBox(p2-vec3(0,0.,0), vec3(.4,sin(p.x*1.+2.8)+0.4,.95)),3);\n p2 = vec3( p- vec3(1.,1.,p.z-1.)); \n float the = iTime *-.5;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float size = .4;\n p2 = abs(p2)-.2;\n vec2 dbox2 = vec2(sdBox( p2,vec3(size)),3);\n vec2 dbox20 = vec2(sdOctahedron( p2,(size)),3);\n dbox2.x = mix (dbox2.x,dbox20.x,1.2);\n p2 = vec3( p- vec3(1.,1.,p.z+0.5)); \n the = iTime *-0.2;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.4;\n p2.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2 = abs(p2)-1.2;\n vec2 dbox4 = vec2(sdSphere( p2-vec3(0.,-0.,-.0),(.02)),1);\n vec3 p3 = vec3( p- vec3(1.,1.,p.z-1.)); \n the = iTime *-.5;\n p3.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p3.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox5 = vec2(sdBox( p3,vec3(.2)),1);\n\n g3 +=1./(0.1+pow(abs(dbox4.x),5.));\n g4 +=1./(1.+pow(abs(dbox5.x),1.));\n box = condmin(box3,box);\n box = condmin(box2,box);\n vec2 o = path(p.z) / 4.0;\n p = vec3(p)-vec3(1,1.,1.);\n p.xy *= rz2(p.z*sin(1.+250.));    \n float cyl2wave = 1.+1.5*(sin(p.z+t*5.)*.1);\n float cylfade = 1.+smoothstep(.0,5.,abs(p.z+iTime*1.));\n float cyl2r = 0.01*cyl2wave*cylfade;\n float cylT = 1.;\n float cylC = 1.;\n vec2 cyl2p = modA(p.xy, (abs(sin(t*1.)+4.)))-vec2(cyl2wave, 0)*cylfade;   \n vec2 cyl2 = vec2(cyl(cyl2p, cyl2r),1);\n vec3 cubP = p;\n      vec2 box7 = vec2(sdBox(p4-vec3(1,1.,0.), vec3(1.,.5,.4)),1);\n\n float cubC = .1;\n cubP.z = mod(cubP.z, cubC)-cubC*.01;\n cubP.xy *= rz2(t*1.);\n vec2 cub =vec2(cube(cubP,vec3(.1*cyl2wave*cylfade)),3.);\n vec2 ebox = condmin(cyl2,box);\n ebox = condmin(ebox,dbox2);\n ebox.x =(max(ebox.x,-box7.x));\n\n g1 +=1./(.01+pow(abs(cub.x),2.));\n g2 +=1./(.01+pow(abs(cyl2.x),2.));\n d = ebox;\n return d ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *.7;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 20; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>100.) break;\n  t += d * 1.;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 a = path2(iTime * 1.0)*1.0;\n vec3 o = vec3(a / 4.0,iTime);   \n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 eye = 1.0*vec3(o)-vec3(-1.,-1.,0);\n float   the = (iTime*.3);\n vec3 hoek = vec3(1,1.,1);  \n the = (iTime*.2)-2.5;\n//hoek.yz *= mat2(cos(the), -sin(the), sin(the), cos(the))*100.;\n// hoek.xz *= mat2(cos(the), -sin(the), sin(the), cos(the))*50.;\n\n mat3 camera = setCamera( eye, hoek,4.7);\n float fov = .6;\n vec3 dir = camera * normalize(vec3(uv, fov));\n float lensResolution = 1.5;\n float focalLenght =1.;\n float lensAperture = .02;\n float inc = 1./lensResolution;\n float start = inc/2.-1.;\n vec3 focalPoint = eye + (dir * focalLenght);\n for (float stepX = start; stepX < 0.5; stepX+=inc){\n for (float stepY = start; stepY < .5; stepY+=inc){\n vec2 shiftedOrigin = vec2(stepX, stepY) * lensAperture;\n  if (length(shiftedOrigin)<(lensAperture/1.5)){\n  vec3 shiftedRayOrigin = eye;\n  shiftedRayOrigin.x += shiftedOrigin.x;\n  shiftedRayOrigin.y += shiftedOrigin.y;\n  vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n  vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n  float t =d.x *1.;   \n   if(t>.001){\n    vec3 baseColor = vec3(0.,0.,0.);\n    shiftedRayOrigin += shiftedRay * t;\n    vec3 sn = GetNormal(shiftedRayOrigin);\n    shiftedRay = reflect(shiftedRay, sn);\n    if(d.y==3.) traceRef(shiftedRayOrigin +  shiftedRay*.1, shiftedRay);\n    }\n   }\n  }\n }\n vec3 d = vec3(0.);\n// d *= marchCount * vec3(1., 1.,1.) * 1.;\nd +=g1*vec3(0.0003)*abs(vec3(sin(iTime-1.)+0.5+0.5,sin(iTime-2.5)+0.5+0.5,sin(iTime-2.)+0.5+0.5)*.5);    \nd +=g2*vec3(0.0002)*vec3(cos(iTime),1,1);    \nd +=g3*vec3(0.003)*vec3(abs(sin(iTime-2.)),.5,1.)*abs(cos(iTime*0.5));    \n d +=g4*vec3(0.002)*vec3(abs(sin(iTime)),0,0);    \n vec3 sky = vec3(1., 1., 1.);\n d = mix(sky, d, 1.0/(d.x*d.x/1./1.*.1+1.)); \nd*= .9;\n fragColor = vec4(d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 152, 152, 203], [204, 204, 233, 233, 255], [256, 256, 285, 285, 320], [322, 322, 341, 341, 489], [490, 490, 510, 510, 606], [609, 609, 642, 642, 761], [763, 763, 803, 803, 879], [893, 893, 931, 931, 998], [1000, 1000, 1038, 1038, 1089], [1091, 1091, 1110, 1110, 1177], [1180, 1180, 1213, 1213, 1238], [1240, 1240, 1269, 1269, 1347], [1390, 1390, 1412, 1412, 3717], [3720, 3720, 3753, 3753, 3964], [3985, 3985, 4016, 4016, 4250], [4253, 4253, 4295, 4295, 4449], [4451, 4451, 4502, 4502, 4663], [4665, 4665, 4688, 4688, 4872], [4875, 4875, 4932, 4932, 6815]], "test": "valid"}
{"id": "wdsSzl", "name": "boxes in space", "author": "kvick", "description": "I had other variants of this but they all broke", "tags": ["box"], "likes": 7, "viewed": 218, "published": "Public", "date": "1593964477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n#define PI2 6.28318530718\n\n//Draw line start\n#define DLS(adef) b = adef;\n//Draw line next\n#define DLN(bdef) a = b; b = bdef; color += vec3(1.0, 0., 0.) * getLine(st, a, b);\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE 3.10432424231\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 15.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\n//--------------------------------------------------------------------------------\nfloat Smoothstep(float x, float v0, float v1) \n{\n\tx = x*x*(3.0-2.0*x);\n\treturn (v1-v0)*x + v0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    const float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.001 / (dist2Line));\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t0., \t\t1.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        1., \t0., \t\t0.,\n        0.,\t\tcos(d),\t\t-sin(d),\n        0.,\t\tsin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    p = rotY(p, iTime * 0.);\n    p = rotX(p, -0.85 + sin(iTime * 0.2) * 0.1 + 0.1);\n    p = rotZ(p, 0.0);\n    \n    //vec3 pCenter = vec3(-0., 0., pow(max(mod(-iTime * 25.0, 102.0), 4.), 0.25) * 0.75);\n    vec3 pCenter = vec3(0.15, 0.35, -1.45);\n    p += pCenter;\n    \n    p.x += sin(p.z * 1.0);\n    //p.y += cos(p.z * 1.0);\n    //p.y = cos(p.z * 1.0);\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 hill(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-1.0, 0.1), vec2(viewAngle, 0.) + vec2(-0.5, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.5, 0.2), vec2(viewAngle, 0.) + vec2(-0.1, 0.4));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.1, 0.4), vec2(viewAngle, 0.) + vec2(0.4, 0.2));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.4, 0.2), vec2(viewAngle, 0.) + vec2(0.8, 0.1));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.6, 0.0), vec2(viewAngle, 0.) + vec2(1.0, 0.2));\n    \n    //HillPeak\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.3, 0.3), vec2(viewAngle, 0.) + vec2(-0.18, 0.32));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.18, 0.32), vec2(viewAngle, 0.) + vec2(-0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(-0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.01, 0.31));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.01, 0.31), vec2(viewAngle, 0.) + vec2(0.09, 0.29));\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(viewAngle, 0.) + vec2(0.09, 0.29), vec2(viewAngle, 0.) + vec2(0.15, 0.3));\n    \n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-1., 0.0), vec2(1., 0.0));\n    return color;\n}\n\nvec3 cube(vec2 st, vec3 pos, float scale, vec3 color)\n{\n \tfloat f = 0.;\n    float yScale = 1.0;\n    \n    vec3[] p = vec3[](\n        (vec3(-scale, -scale * yScale, -scale)),\n    \t(vec3(-scale,  scale * yScale, -scale)),\n        (vec3( scale,  scale * yScale, -scale)),\n    \t(vec3( scale, -scale * yScale, -scale)),\n        \n        (vec3(-scale, -scale * yScale, scale)),\n    \t(vec3(-scale,  scale * yScale, scale)),\n     \t(vec3( scale,  scale * yScale, scale)),\n        (vec3( scale, -scale * yScale, scale))\n    );\n    \n    vec2[8] p_;\n    for (int i = 0 ; i < 8; ++i)\n    {\n        p_[i] = pToS(p[i] + pos);\n    }\n    \n    const int k_edgeMax = 8 * 3;\n    int[] edges = int[](\n        \n        0, 1,\n        1, 2,\n        2, 3,\n        3, 0,\n\t\t       \n\n        //Top\n        4, 5,\n        5, 6,\n        6, 7,\n        7, 4,\n       \n        //Draw connecting lines\n        \n        0, 4,\n        1, 5,\n        2, 6,\n        3, 7\n\t\t\n\n    );\n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.001;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n        \n    }\n    \n    //Color\n    return color * f * 0.18;   \n}\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n    //Cool warpy look\n    //st = vec2(pow(pow(st.x, st.x), 2.), pow(st.y, 2.));\n    \n\tfloat f = 0.;\n    vec3 color = vec3(0.);\n    \n    for (float i = 0.; i < 11.0; i += 2.0)\n    {\n        float jMod = (floor(Hash(i) * 8.0));\n        for (float j = -15.0 + jMod; j < 1.0 + jMod; j += 1.0)\n    \t{\n        \tconst float scale = 0.045;\n            const float scaleFactor = (scale + scale * 1.5);\n            const float loopFactor = (0.9 * scaleFactor);\n            \n            vec3 colorCube = vec3(1., 0.3, 0.8);\n            \n            const vec3 colorA = vec3(1.0, 1.0, 0.0);\n            const vec3 colorB = vec3(0.0, 1., 1.0);\n            const vec3 colorC = vec3(1.0, 0.0, 1.0);\n            const vec3 colorNeutral = vec3(1.0, 1.0, 1.0);\n            const vec3 color_Destroyed = vec3(0.0);\n            \n            //vec3 color_threat = vec3(0., 0, 0.);\n            vec3 color_threat = vec3(0.5 + 2.0 * (sin(iTime * 52.0) * 0.5 + 0.5), 0.0, 0.0);\n            \n            float randomFract = Hash(i * j - floor(iTime * 0.03 / loopFactor));\n            colorCube = randomFract < 0.15 ? colorA : \n            \t\t\trandomFract < 0.35 ? colorB : \n            \t\t\trandomFract < 0.5 ? colorC : \n            \t\t\trandomFract < 0.7 ? colorNeutral : \n            \t\t\t//randomFract < 0.9 ? color_Destroyed :\n            \t\t\tcolor_Destroyed;\n            \n            //drawing a line?\n            colorCube = j == (-5.0 + floor(iTime * 0.03 / loopFactor)) ? vec3(3.2, 3., 3.): colorCube;\n            \n            //green cube\n            colorCube = i == 3.0 && j == (-15.0 + floor(iTime * 0.03 / loopFactor)) ? vec3(1.2, 8., 5.): colorCube;\n            \n            //colorCube = vec3(1.);\n            \n            float tickTock = floor(mod(iTime, 2.0));\n            tickTock = sin(iTime) * 0.5 + 0.5;\n            colorCube = mix(colorCube, vec3(1.0, 0.3, 0.3), tickTock);\n            \n        \tcolor += cube(st, vec3(i * scaleFactor * 1.1, j * loopFactor + mod(iTime * 0.03, loopFactor), i * 0.025), scale, colorCube);\n    \t}\n    }\n    \n    float gamma = Smoothstep(st.y, 2.19, 4.0);\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 357, 357, 474], [476, 559, 603, 603, 629], [631, 714, 762, 762, 810], [812, 812, 845, 845, 910], [912, 912, 958, 958, 1125], [1127, 1127, 1170, 1170, 1426], [1428, 1428, 1474, 1474, 1724], [1726, 1726, 1754, 1754, 1918], [1920, 1920, 1948, 1948, 2119], [2121, 2121, 2149, 2149, 2315], [2317, 2317, 2336, 2336, 2734], [2736, 2736, 2756, 2756, 4383], [5979, 6062, 6119, 6119, 8474]], "test": "error"}
{"id": "wdsyRn", "name": "Gyroids Ashes and Flames", "author": "deliaev", "description": "Made by following this tutorial https://www.youtube.com/watch?v=-FvnsYbzpfc", "tags": ["tutorial", "gyroids"], "likes": 2, "viewed": 60, "published": "Public", "date": "1595439545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\nvec3 Transform(vec3 p) {\n    p.xy *= Rot(p.z*.15);\n    p.z -= iTime*.1;\n    p.y += .3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = Transform(p);\n    float box = sdBox(p, vec3(1));\n    \n    float g1 = sdGyroid(p, 5.45, .03, 1.5);\n    float g2 = sdGyroid(p, 10.212, .03, .3);\n    float g3 = sdGyroid(p, 21.512, .03, .3);\n    float g4 = sdGyroid(p, 34.23, .03, .3);\n    float g5 = sdGyroid(p, 60.67, .029, .3);\n    float g6 = sdGyroid(p, 122.12, .03, .3);\n    float g7 = sdGyroid(p, 250.17, .028, .3);\n    \n    //float g = min(g1, g2); //union\n    //float g = max(g1, -g2); //subtraction\n    \n    g1 -= g2*.2;\n    g1 -= g3*.2;\n    g1 += g4*.12;\n    g1 += g5*.15;\n    g1 -= g6*.18;\n    g1 += g7*.2;\n    float d = g1*.8;\n    //float d = max(box, g1*.8);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.016, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Background(vec3 rd) {\n \tvec3 col = vec3(0);\n    float t = iTime;\n    float y = rd.y*.5+.5;\n    col += (1.-y)*vec3(1.,.4,.1)*2.;\n    \n    float a = atan(rd.x, rd.z);\n    float flames = sin(a*10.+t)*sin(a*7.-t)*sin(a*6.);\n    flames *= S(.8, .5, y);\n    col += flames;\n    col = max(col, 0.);\n    col += S(.5, 0., y);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    uv += sin(uv*20.+t)*.005;\n    \n    vec3 ro = vec3(0, 0, -.05);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 lookat = vec3(0);\n    vec3 rd = GetRayDir(uv, ro, lookat, .8);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n        float height = p.y;\n        p = Transform(p);\n    \tfloat dif = n.y*.5+.5;\n    \tcol += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.212, .03, .3);\n        col *= S(-.1, .06, g2);\n        \n        float crackWidth = -.02+S(0., -.5, n.y)*.05;\n        float cracks = S(crackWidth, -.03, g2);\n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.05, 8.7, .03, .0);\n        cracks *= g3*g4*40.+.1*S(.2, .0, n.y);\n        col += cracks*vec3(1.,.4,.1)*3.;\n        float g5 = sdGyroid(p-vec3(0,t,0), 3.87, .03, .0);\n        \n        col += g5 * vec3(1.,.4,.1);\n        \n        col += S(0., -2., height)*vec3(1.,.4,.1);\n    }\n    col = mix(col, Background(rd), S(0., 7., d));\n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    col *= 1.-dot(uv, uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsyRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[357, 357, 376, 376, 452], [454, 454, 483, 483, 564], [566, 566, 632, 632, 711], [712, 712, 736, 736, 814], [816, 816, 839, 839, 1486], [1488, 1488, 1522, 1522, 1733], [1735, 1735, 1759, 1759, 1949], [1951, 1951, 2001, 2001, 2196], [2198, 2198, 2224, 2224, 2536], [2538, 2538, 2595, 2595, 3904]], "test": "valid"}
{"id": "WdtXRH", "name": "Torus Tutorial", "author": "deliaev", "description": "tutorial taken from this video https://www.youtube.com/watch?v=rA9NmBRqfjI", "tags": ["raytracing", "torus", "tutorial"], "likes": 3, "viewed": 89, "published": "Public", "date": "1595439653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n    float t = iTime * .2;\n\t\n    uv *= mat2(cos(t), -sin(t), sin(t), cos(t));\n    vec3 ro = vec3(0,0,-1);\n    vec3 lookat = mix(vec3(0),vec3(-1, 0, -1), sin(t*1.56)*.5+.5);\n    float zoom = mix(.1, .6, sin(t)*.5+.5);\n    \n    vec3 f = normalize(lookat - ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i - ro);\n\n    float radius = mix(.3, .5, sin(t*.4)*.5+.5);\n    float dS, dO;\n    vec3 p;\n    \n    for (int i=0; i<100; i++) {\n     \tp = ro + rd * dO;\n        dS = -(length(vec2(length(p.xz)-1., p.y)) - radius);\n        if (dS < .001) break;\n        dO += dS;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (dS<.001) {\n        float x = atan(p.x, p.z) + t*.5;\n        float y = atan(length(p.xz)-1., p.y);\n     \tfloat bands = sin(y*10.+x*20.);\n        float ripples = sin((x*10.-y*30.)*3.)*.5+.5;\n        float waves = sin(x*2.-y*6.+t*10.);\n        float b1 =smoothstep(-.2,.2, bands);\n        float b2 =smoothstep(-.2,.2, bands-.5);\n        float m = b1*(1.-b2);\n        m = max(m, ripples * b2 * max(0.,waves));\n        m += max(0., waves*.5*b2);\n        col += mix(m, 1.-m, smoothstep(-.3, .3, sin(x*2.+t)));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1387]], "test": "valid"}
{"id": "WdXfD4", "name": "Tutorial from progur", "author": "landicefu", "description": "https://progur.com/2017/03/how-to-create-animated-shaders-in-shadertoy.html", "tags": ["tutorial"], "likes": 1, "viewed": 158, "published": "Public API", "date": "1593749481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMOOTH_EDGE_LENGTH 0.01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // value between 0~1 based on current frame\n    float frame = (float(iFrame % 400)) / 400.0;\n \n    // Normalize the coordinate to 0-1 based on height of the view port\n    // Assume the view port is (1200, 600), (300, 300) -> (0.5, 0.5)\n    vec2 uv = fragCoord.xy / iResolution.yy;\n\n\tvec2 center1 = vec2(0.4 + frame, 0.5);\n    float radius1 = 0.3;\n    float distance1 = distance(center1, uv);\n    float red = smoothstep(radius1, radius1 - SMOOTH_EDGE_LENGTH, distance1);\n\n\tvec2 center2 = vec2(0.8 - frame, 0.5);\n    float radius2 = 0.1;\n\tfloat distance2 = distance(center2, uv);\n\tfloat green = smoothstep(radius2, radius2 - SMOOTH_EDGE_LENGTH, distance2);\n\n\tvec4 redColor = vec4(red, 0, 0, 1);\n\tvec4 greenColor = vec4(0, green, 0, 1);\n\tvec4 sum = redColor + greenColor;\n\tfragColor = sum; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "wl2cDV", "name": "v3Sliders.glsl", "author": "jorge2017a1", "description": "v3Sliders.glsl", "tags": ["v3slidersglsl"], "likes": 2, "viewed": 37, "published": "Public", "date": "1595449160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 spectrum;\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 1.2;\n    //vec3 spectrum;\n\n    float rep = 2.0 + pow(rand(vec2(floor(t))), 2.0) * 100.0;\n    vec2 p0 = fragCoord.xy / vec2(20.0, iResolution.y / rep);\n    vec2 p1 = floor(p0);\n    vec2 p2 = fract(p0);\n\n    float r = rand(p1 + floor(t) * 0.11356);\n    float x = 1.0 - p2.y;\n    float sp = mix(spectrum.x * 2.0, spectrum.y * 4.0, r > 0.5 ? 1.0 : 0.0);\n    float th = fract(t - min(1.0, sp * (1.0 + r * 2.0)));\n    float c = step(smoothstep(0.0, 1.0, th), x);\n\n    fragColor = vec4(c);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2cDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 36, 36, 106], [108, 108, 165, 165, 672]], "test": "valid"}
{"id": "wl2cWG", "name": "Another fractal cave system", "author": "jarble", "description": "This cave system is generated using trigonometric functions.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 2, "viewed": 228, "published": "Public API", "date": "1595286772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat caves(vec3 p,float size1){\n    float i = size1;\n    //p = ((cos(p/size1)/i))*i;\n    vec3 s1 = sin(p.yzx/50.0);\n    p += s1*50.0;\n    p = (sin(p/vec3(50.0+length(s1))))*size1;\n    return size-length(p);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*10.0;\n\tp -= 100.0;\n    float size1 = 1000.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 3; k++){\n        p /= i;\n        result = min(caves(p*i,size1),result);\n        i *= 5.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return (-result-200.0)*scale/4.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return vec3(.8,.3,.3)*(sin(vec3(sceneSDF(p*5.0))))/4.0+vec3(.5,.4,.4);\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t1 = iTime/2.0;\n    vec3 eye = vec3(7.0+cos(t1),-7.0-sin(t1),2.0+sin(t1));\n    \n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2cWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 622, 622, 799], [801, 801, 825, 825, 1149], [1151, 1151, 1179, 1179, 1288], [1292, 1713, 1804, 1804, 2116], [2131, 2385, 2450, 2450, 2582], [2584, 2673, 2702, 2702, 3012], [3014, 3506, 3646, 3646, 4256], [4258, 4628, 4713, 4713, 5060], [5062, 5389, 5438, 5473, 5604], [5606, 5606, 5663, 5663, 6808]], "test": "valid"}
{"id": "Wl2cWK", "name": "00-b: Cell Sphere", "author": "yarn", "description": "learn", "tags": ["learn"], "likes": 0, "viewed": 29, "published": "Public", "date": "1595383989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// todo moon orbiting and casting a shadow + stars/nebulae\n\nvec3 normal_at(vec3 s_c, vec3 point) {\n\treturn normalize(point - s_c);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio; // unstretch\n    uv.x += (1.0 - aspect_ratio) / 2.0; // centre\n    \n    //vec2  mouse_loc = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n\t//vec2 mouse_loc = vec2(0.5) + 0.2*vec2(sin(0.05 * iTime), cos(0.05 * iTime));\n    vec2 mouse_loc = vec2(0.5);\n \n    //vec3 sphere_centre = vec3(0.2);\n    vec3 sphere_centre = vec3(mouse_loc.x, 0.3, mouse_loc.y);\n    float sphere_radius = 0.2;\n    \n    vec3 ray_origin = vec3(uv.x, -1.0, uv.y); // view plane at z = -1.0\n    \n    vec3 ray_dir = vec3(0.0, 1.0, 0.0); // straight from view plane\n    \n    float t = iTime * 5.0;\n    \n    vec3 light_pos = vec3(0.5 + 0.3 * sin(0.3 * t), 0.3 + 0.2*sin(0.5 * t), 0.5 + 0.3 * cos(0.3 * t));\n    \n    vec3 col;\n    \n    float root = pow(dot(ray_dir, ray_origin - sphere_centre) , 2.0) - pow(length(ray_origin - sphere_centre), 2.0) + pow(sphere_radius, 2.0);\n    \n    if (root < 0.0) {\n    \tcol = vec3(0.0);   \n    } else {\n        float t = -(dot(ray_dir, ray_origin - sphere_centre)) - sqrt(root);\n        //col = vec3(1.0 - 0.7*t);\n        vec3 light_dir = -normalize(sphere_centre - light_pos);\n        col = vec3(dot(light_dir, (normal_at(sphere_centre, ray_origin +  t * ray_dir)))); \n        col = vec3(step(0.1, col.x));\n        col *= vec3(1.0, 0.5, 0.0);\n    }\n    \n    float light_point = step(distance(uv, vec2(light_pos.x, light_pos.z)), (0.3 - 0.2*sin(0.5 * t)) * 0.03);\n    \n    if (light_point > 0.95) {\n     \tcol = vec3(0.0, 0.3 - 0.2*sin(0.5 * t), 0.0);   \n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 98, 98, 135], [137, 137, 194, 194, 1831]], "test": "valid"}
{"id": "Wl2cWR", "name": "jjj concetric squares rotating", "author": "jjj", "description": "concetric squares rotating, pga", "tags": ["squares", "pga2"], "likes": 6, "viewed": 107, "published": "Public", "date": "1594125739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_time iTime\n#define u_resolution iResolution\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_SQRT_2 1.4142135623731\n\n\n#define mvec2 float[8]\n\n\n\n// basis vectors\n// \"1\",\"e0\",\"e1\",\"e2\",\"e01\",\"e20\",\"e12\",\"e012\"\n\nmvec2 conjugate (mvec2 mv) {\n    return mvec2 (mv[0], -mv[1], -mv[2], -mv[3], -mv[4], -mv[5], -mv[6], mv[7]);\n}\n\nmvec2 reverse (mvec2 mv) {\n    return mvec2 (mv[0], mv[1], mv[2], mv[3], -mv[4], -mv[5], -mv[6], -mv[7]);\n}\n\nmvec2 dual(mvec2 mv) {\n    return mvec2(mv[7], mv[6], mv[5], mv[4], mv[3], mv[2], mv[1], mv[0]);\n}\n\nmvec2 Involute (mvec2 mv) {\n    return mvec2( mv[0], -mv[1], -mv[2], -mv[3], mv[4], mv[5], mv[6], -mv[7] );\n}\n\n// The geometric product.\nmvec2 mul (mvec2 a, mvec2 b)\n{\n    return mvec2 (\n        b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[6]*a[6],\n        b[1]*a[0]+b[0]*a[1]-b[4]*a[2]+b[5]*a[3]+b[2]*a[4]-b[3]*a[5]-b[7]*a[6]-b[6]*a[7],\n        b[2]*a[0]+b[0]*a[2]-b[6]*a[3]+b[3]*a[6],\n        b[3]*a[0]+b[6]*a[2]+b[0]*a[3]-b[2]*a[6],\n        b[4]*a[0]+b[2]*a[1]-b[1]*a[2]+b[7]*a[3]+b[0]*a[4]+b[6]*a[5]-b[5]*a[6]+b[3]*a[7],\n        b[5]*a[0]-b[3]*a[1]+b[7]*a[2]+b[1]*a[3]-b[6]*a[4]+b[0]*a[5]+b[4]*a[6]+b[2]*a[7],\n        b[6]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[6],\n        b[7]*a[0]+b[6]*a[1]+b[5]*a[2]+b[4]*a[3]+b[3]*a[4]+b[2]*a[5]+b[1]*a[6]+b[0]*a[7]\n    );\n}\n\nmvec2 mul (mvec2 a, float b) {\n    return mvec2(a[0]*b, a[1]*b, a[2]*b, a[3]*b, a[4]*b, a[5]*b, a[6]*b, a[7]*b);\n}\n\nmvec2 mul (float a, mvec2 b) {\n    return mul(b,a);\n}\n\nmvec2 meet(mvec2 a, mvec2 b)\n{\n    return mvec2(\n\t    b[0]*a[0],\n    \tb[1]*a[0]+b[0]*a[1],\n    \tb[2]*a[0]+b[0]*a[2],\n\t    b[3]*a[0]+b[0]*a[3],\n    \tb[4]*a[0]+b[2]*a[1]-b[1]*a[2]+b[0]*a[4],\n\t    b[5]*a[0]-b[3]*a[1]+b[1]*a[3]+b[0]*a[5],\n    \tb[6]*a[0]+b[3]*a[2]-b[2]*a[3]+b[0]*a[6],\n\t    b[7]*a[0]+b[6]*a[1]+b[5]*a[2]+b[4]*a[3]+b[3]*a[4]+b[2]*a[5]+b[1]*a[6]+b[0]*a[7]\n    );\n}\n\nmvec2 join(mvec2 a, mvec2 b) {\n\treturn mvec2(\n\t\tb[0]*a[7]+b[1]*a[6]+b[2]*a[5]+b[3]*a[4]+b[4]*a[3]+b[5]*a[2]+b[6]*a[1]+b[7]*a[0],\n\t\tb[1]*a[7]+b[4]*a[5]-b[5]*a[4]+b[7]*a[1],\n\t\tb[2]*a[7]-b[4]*a[6]+b[6]*a[4]+b[7]*a[2],\n\t\tb[3]*a[7]+b[5]*a[6]-b[6]*a[5]+b[7]*a[3],\n\t\tb[4]*a[7]+b[7]*a[4],\n\t\tb[5]*a[7]+b[7]*a[5],\n\t\tb[6]*a[7]+b[7]*a[6],\n\t\tb[7]*a[7]\n\t);\n}\n\nmvec2 inner(mvec2 a, mvec2 b) {\n    return mvec2(\n        b[0]*a[0]+b[2]*a[2]+b[3]*a[3]-b[6]*a[6],\n        b[1]*a[0]+b[0]*a[1]-b[4]*a[2]+b[5]*a[3]+b[2]*a[4]-b[3]*a[5]-b[7]*a[6]-b[6]*a[7],\n        b[2]*a[0]+b[0]*a[2]-b[6]*a[3]+b[3]*a[6],\n        b[3]*a[0]+b[6]*a[2]+b[0]*a[3]-b[2]*a[6],\n        b[4]*a[0]+b[7]*a[3]+b[0]*a[4]+b[3]*a[7],\n        b[5]*a[0]+b[7]*a[2]+b[0]*a[5]+b[2]*a[7],\n        b[6]*a[0]+b[0]*a[6],\n        b[7]*a[0]+b[0]*a[7]\n    );\n}\n\nfloat norm( mvec2 mv) { \n    return sqrt(abs(mul(mv, conjugate(mv))[0]));\n}\n\nfloat inorm(mvec2 mv) { \n    return mv[1] != 0.0 ? mv[1] : mv[7] != 0.0 ? mv[7] : norm(dual(mv));\n}\n\nmvec2 normalize2(mvec2 mv) {\n    return mul(mv, 1./norm(mv));\n}\n\nmvec2 add (mvec2 a, float b) {\n    return mvec2(a[0]+b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]);\n}\n\nmvec2 add (float a, mvec2 b) {\n    return add(b,a);\n}\n\n\n\n\nmvec2 apply( mvec2 transformation, mvec2 target) {\n    return mul(mul(transformation, target), reverse(transformation));\n}\n\n\n\n\nmvec2 point( vec2 p ) {\n    return mvec2 (0., 0., 0., 0., p.x, p.y, 1., 0.);\n}\n\nvec2 point( mvec2 p ) {\n    return vec2( p[4], p[5]);\n}\n\nmvec2 line( vec2 p ) {\n    return mvec2 (0., 0., p.x, -p.y, 0., 0., 0., 0.);\n}\n\nmvec2 line( vec2 p1, vec2 p2 ) {\n    return join(point(p1), point(p2));\n}\n\nmvec2 dir( vec2 p ) {\n    return mvec2 (0., 0., 0., 0., p.x, p.y, 0., 0.);\n}\n\n\n\n\n\nmvec2 rot( float rad, vec2 p) {\n    return add(cos(rad*.5), mul(point(p), sin(rad*.5)));\n}\n\nmvec2 rot( float rad) {\n    return rot(rad, vec2(0.));\n}\n\nmvec2 orth_trans( vec2 d) {\n    return add(1., dir(d));\n}\n\nmvec2 trans(vec2 d) {\n    mvec2 r = rot(radians(90.));\n    \n    return add(1., apply(r, dir(d)));\n    \n}\n\nfloat oscilate(float min, float max, float freq) {\n    return (sin(u_time)*freq+.5)*(max-min) + min;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float COUNT = 20.;\n    float THICKNESS = oscilate(0.1, 0.9,  0.5) * .5; // oscilate(0.1, 0.9,  0.5);  // .5\n    float DRAG = oscilate(0.2, 2.0,  0.2); // oscilate(0.2, 3.0,  0.5); // .5 or 1.2\n    float CYCLE_LENGTH = 1.5; // oscilate(1.0, 1.5,  0.2); // oscilate(1.0, 2.0,  0.05); // 1.5\n    float SHARPNESS = 100./u_resolution.y; // 10.\n    float SPEED = 1.0; // doesn't oscilate nicely\n\n\n    // Normalized pixel coordinates (from -1 to 1)\n    float resScale = 1.0/min(u_resolution.x, u_resolution.y);\n    vec2 p = (fragCoord.xy*2.0 - u_resolution.xy)*resScale;\n    float dist = abs(length(p)*COUNT);\n\n    float c = 0.;\n    for (float i = max(1., trunc(dist/M_SQRT_2)); i < min(dist+1., COUNT); i += 1.) {\n        float angleMixFactor = smoothstep(0., 1., \n            mod(u_time*SPEED -i*DRAG/COUNT, CYCLE_LENGTH) );\n\n        float rad = -M_PI * .5 * angleMixFactor; // from 0 to 90 degrees\n        mvec2 R = rot(rad);\n\n        vec2 rp = abs(point(apply(R, point(p))));\n        float d = max(rp.x,rp.y) * COUNT;\n        float e =\n            smoothstep(i, i-SHARPNESS, d-THICKNESS) *\n            smoothstep(i-SHARPNESS, i, d+THICKNESS)\n        ;\n        c = max(c, e);\n    }\n    \n    vec3 col = vec3(c);\n\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 256, 256, 339], [341, 341, 367, 367, 448], [450, 450, 472, 472, 548], [550, 550, 577, 577, 659], [661, 687, 717, 717, 1296], [1298, 1298, 1328, 1328, 1412], [1414, 1414, 1444, 1444, 1467], [1469, 1469, 1499, 1499, 1843], [1845, 1845, 1875, 1875, 2189], [2191, 2191, 2222, 2222, 2640], [2642, 2642, 2665, 2665, 2717], [2719, 2719, 2742, 2742, 2818], [2820, 2820, 2848, 2848, 2883], [2885, 2885, 2915, 2915, 2985], [2987, 2987, 3017, 3017, 3040], [3045, 3045, 3095, 3095, 3167], [3172, 3172, 3195, 3195, 3250], [3252, 3252, 3275, 3275, 3307], [3309, 3309, 3331, 3331, 3387], [3389, 3389, 3421, 3421, 3462], [3464, 3464, 3485, 3485, 3540], [3546, 3546, 3577, 3577, 3636], [3638, 3638, 3661, 3661, 3694], [3696, 3696, 3723, 3723, 3753], [3755, 3755, 3776, 3776, 3859], [3861, 3861, 3911, 3911, 3963], [3965, 3965, 4022, 4022, 5274]], "test": "valid"}
{"id": "wl2czV", "name": "Ascending Love", "author": "Flopine", "description": "Here is a version of a live coding session made during Infinite Lives Chiptune concert, alongside ThronoCrigger STRATOSPHERIC music <3 \nGO LISTEN HIS JAM https://thronocrigger.bandcamp.com/  :P \n", "tags": ["raymarching", "cube", "distortion", "isometric", "live"], "likes": 10, "viewed": 213, "published": "Public", "date": "1594893434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// You can disabled the distortion effect to see the scene better by commenting this line \n// V\n#define DISTORTION\n\n#define ITER 64.\n#define PI acos(-1.)\n#define TAU 6.283183\n\n#define BPM (113./60.)\n#define ft(speed) fract(iTime*speed)\n#define bouncy(speed) sqrt(abs(sin(ft(speed)*TAU)))\n#define sw(speed) floor(sin(ft(speed)*TAU)+1.)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.01,fwidth(val-thre)))\n#define equiratio vec2(1., sqrt(3.)/3.)\n\nstruct OBJ\n{\n    float d;\n    vec3 color;\n};\n\nOBJ minobj (OBJ a, OBJ b)\n{\n    if (a.d<b.d) return a;\n    else return b;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x) + per/2.;\n    float id = floor(a/per);\n    a = mod(a,per)-per/2.;\n    p = vec2(cos(a),sin(a))*length(p);\n    return id;\n}\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p) - d;\n    if (p.y > p.x) p = p.yx;\n}\n\nvec3 pal (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+vec3(0., 0.36, 0.64)));}\n\nOBJ travelers (vec3 p)\n{\n    p.xz *= rot(ft(BPM/8.)*TAU);\n\n    vec3 ctrav = vec3(0.);\n    p.y -= bouncy(BPM/2.);\n    float tid = moda(p.xz,3.);\n    p.x -= 1.8+sin(ft(BPM/8.)*TAU);\n\n    if (tid == 0.) ctrav = vec3(1.,0.,0.4);\n    else if (tid == 1.) ctrav = vec3(0.95,0.8,0.);\n        else if (tid == -1.) ctrav = vec3(0.,0.4,1.);\n\n            OBJ travs = OBJ(box(p,vec3(0.5)),vec3(ctrav));\n\n        return travs;\n}\n\nfloat setper = 12.;\nOBJ grid (vec3 p)\n{\n    p.y = mod(p.y,setper)-setper*0.5;\n    OBJ gr;\n    mo(p.xz,vec2(1.5));\n    p.x -= 2.5;\n    gr.d = sc(p,0.1);\n    gr.color = pal(p.y,vec3(PI/2.));\n\n    return gr;\n}\n\nOBJ cages (vec3 p)\n{\n    p.y = mod(p.y-setper*0.5,setper)-setper*0.5; \n    mo(p.yz, vec2(2.));\n    p.y += 0.2;\n    mo(p.xz, vec2(2.));\n    p.x -= 4.;\n    float dcag = max(-sc(p,0.8),box(p,vec3(1.)));\n\n    return OBJ(dcag, vec3(.7));\n}\n\nOBJ poles (vec3 p)\n{\n    p.xz *= rot(p.y*0.05);\n    p.y = mod(p.y,setper)-setper*0.5; \n    mo(p.xz,vec2(5.));\n\n    float dpo = box(p,vec3(0.1,10.,0.1));\n    vec3 cpo = vec3(0.1,0.9,0.2);\n    return OBJ (dpo, cpo);  \n}\n\nOBJ CubeGF (vec3 p)\n{\n    p.y += 2.;\n    p.xz *= rot(ft(0.2)*TAU);\n    p.x = abs(p.x) -1.5;\n    float dcgf = box(p,vec3(0.3));\n    return OBJ(dcgf, vec3(0.8,0.1,0.6));\n}\n\nOBJ sets (vec3 p)\n{\n    p.y += iTime*BPM*2.;\n\n    OBJ s;\n    s = grid(p);\n    s = minobj(s,cages(p));\n    s = minobj(s,poles(p));\n\n    return s;\n}\n\nOBJ SDF (vec3 p)\n{\n    vec3 pp = p;\n    pp.yz *= rot(-atan(1./sqrt(2.)));\n    pp.xz *= rot(PI/4.);\n    OBJ scene = sets(pp);\n    scene = minobj(scene, travelers(pp));\n    scene = minobj(scene, CubeGF(pp));\n    return scene;\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat tris (vec2 uv)\n{return sign(fract(uv.x+0.5*uv.y)-fract(uv.y));}\n\nfloat trap (vec2 uv, vec2 s)\n{return max(abs(uv.y),abs(dot(uv,s)));}\nfloat trapz (vec2 uv)\n{\n    float width = 1.73*(1./length(normalize(equiratio)));\n    float height = 1.;\n    vec2 period = vec2(width,height)*4.;\n    uv = mod(uv,period)-period*0.5;\n    float uvx = abs(uv.x)-width;\n    float uvy = abs(uv.y)-height;\n    float d = AAstep(1.,trap(vec2(uvx,uvy),normalize(equiratio))); \n    d += (uv.x>0. && uv.y>0. || uv.x<0. && uv.y<0.) ? 0.5 : 0.;\n    return clamp(d,0.,1.);\n}\n\nfloat wave (vec2 uv)\n{\n    return smoothstep(0.1,\n                      0.2, \n                      sin(abs(length(uv+vec2(0.1,-0.1))-ft(BPM))*PI)\n                     );\n}\n\nfloat masks (vec2 uv)\n{\n    float zerotofour = floor(mod(iTime*(BPM),3.));\n    switch (int(zerotofour))\n    {\n        case 0: return tris(uv*6.)*0.5;\n        case 1: return trapz(uv*20.);\n        case 2: return 1.-wave(uv*5.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    #ifdef DISTORTION\n    \tuv += masks(uv)*0.05;\n    #endif\n\n    vec3 ro = vec3(uv*4.,-30.),\n        rd = vec3(0.,0.,1.),\n        l = normalize(vec3(-1.,2.,-1.)),\n        p = ro,\n        col = vec3(0.,0.,0.03);\n\n    OBJ obj;\n    bool hit = false;\n    for(float i=0.; i<ITER; i++)\n    {\n        obj = SDF(p);\n        if (obj.d<0.001)\n        {\n            hit = true; break;\n        }\n        p += obj.d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,l)*.5+.5;\n        vec3 clight = mix(vec3(0.03),vec3(0.,0.,0.08),light);\n        col = vec3(obj.color)*light;\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [{"id": "4lS3zd", "previewfilepath": "https://soundcloud.com/thronocrigger/so-hot-youre-hurting-my-feelings-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/thronocrigger/so-hot-youre-hurting-my-feelings-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2czV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[873, 873, 900, 900, 948], [950, 950, 978, 978, 1063], [1065, 1065, 1093, 1093, 1169], [1171, 1171, 1209, 1209, 1384], [1386, 1386, 1417, 1417, 1468], [1470, 1470, 1498, 1498, 1562], [1564, 1564, 1588, 1588, 1978], [2000, 2000, 2019, 2019, 2186], [2188, 2188, 2208, 2208, 2422], [2424, 2424, 2444, 2444, 2641], [2643, 2643, 2664, 2664, 2812], [2814, 2814, 2833, 2833, 2960], [2962, 2962, 2980, 2980, 3187], [3189, 3189, 3211, 3211, 3333], [3335, 3335, 3357, 3357, 3404], [3406, 3406, 3436, 3436, 3474], [3475, 3475, 3498, 3498, 3884], [3886, 3886, 3908, 3908, 4058], [4060, 4060, 4083, 4083, 4294], [4296, 4296, 4353, 4353, 5063]], "test": "error"}
{"id": "wl2yDD", "name": "jep_mandelbrot", "author": "Eindacor_DS", "description": "mandelbrot set fractal visualization", "tags": ["fractal"], "likes": 0, "viewed": 64, "published": "Public", "date": "1594436123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getNewZ(vec2 z, vec2 c) {\n    float newY = 2.f * z.x * z.y + c.y;\n    float newX = (z.x * z.x) + (z.y * z.y * -1.f) + c.x;\n    return vec2(newX, newY);\n}\n\nint getIterationsBeforeExplosion(vec2 pos, int iterationLimit) {\n    float magnitudeThreshold = 2.f;\n    float realValue = pos.x;\n    float imaginaryValue = pos.y;\n    vec2 z = vec2(0.f, 0.f);\n    for (int i = 0; i < iterationLimit; i++) {\n        z = getNewZ(z, pos);\n        if (distance(z, vec2(0.f, 0.f)) > magnitudeThreshold) {\n         \treturn i;   \n        }\n    }\n    \n    return iterationLimit;\n}\n\nvec3 getColor(float value) {\n    vec3 red = vec3(1.f, 0.f, 0.f);\n    vec3 green = vec3(0.f, 1.f, 0.f);\n    vec3 blue = vec3(0.f, 0.f, 1.f);\n    \n    if (value < .5f) {\n        return mix(blue, green, value * 2.f);\n    } else {\n        return mix(green, red, (value - .5f) * 2.f);\n    }\n\t\n}\n\nvec2 getRotatedPosition(float currentTime, vec2 pos) {\n    float rotationSpeed = .1f;\n    float viewRotationTime = currentTime * rotationSpeed;\n    mat2 viewRotationMatrix = mat2(\n        cos(viewRotationTime), -sin(viewRotationTime),\n        sin(viewRotationTime), cos(viewRotationTime)\n    );\n    return pos * viewRotationMatrix;\n}\n\nfloat getMagnification(float currentTime) {\n    float totalZoomTime = 21.f;\n    float timeScale = .5f;\n    float adjustedTime = currentTime * timeScale;\n  \n    float zoomTime = mod(adjustedTime, totalZoomTime);\n    if (int(mod(adjustedTime / totalZoomTime, 2.f)) == 1) {\n        zoomTime = totalZoomTime - zoomTime;\n    }\n    \n    return pow(2.f, zoomTime);\n}\n\nvec3 rotateColor(vec3 color) {\n    vec3 deNormalized = (color * 2.f) - vec3(1.f);\n    \n    float xRotationTime = iTime / 2.1f;\n    float yRotationTime = iTime / 2.3f;\n    float zRotationTime = iTime / 2.4f;\n    \n    mat3 rotationXMatrix = mat3(\n        1.f, 0.f, 0.f,\n    \t0.f, cos(xRotationTime), -sin(xRotationTime),\n    \t0.f, sin(xRotationTime), cos(xRotationTime)\n    ); \n    \n    mat3 rotationYMatrix = mat3(\n    \tcos(yRotationTime), 0.f, sin(yRotationTime),\n        0.f, 1.f, 0.f,\n        -sin(yRotationTime), 0.f, cos(yRotationTime)\n    );\n    \n    mat3 rotationZMatrix = mat3(\n    \tcos(zRotationTime), -sin(zRotationTime), 0.f,\n        sin(zRotationTime), cos(zRotationTime), 0.f,\n        0.f, 0.f, 1.f\n    );\n    \n    return ((deNormalized * rotationXMatrix * rotationYMatrix * rotationZMatrix) + vec3(1.f)) / 2.f;\n}\n\n#define antiAlias 2\n//#define SHOW_TARGET\n#define ROTATE_VIEW\n#define INVERT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 focalPoint = vec2(0.0495f, .655f);\n    focalPoint = vec2(0.2008f, .555f);\n    focalPoint.x /- aspectRatio;\n    \n    vec3 outColor = vec3(0.f);\n    \n    for (int m=0; m<antiAlias; m++) {\n        for (int n=0; n<antiAlias; n++) {\n            vec2 uv = (fragCoord + vec2(float(m), float(n))/float(antiAlias))/iResolution.xy;\n            vec2 graphPosition = (uv * 2.f - vec2(1.f, 1.f)) / getMagnification(iTime);\n\n            graphPosition.x /= aspectRatio; \n\n#ifdef ROTATE_VIEW\n            graphPosition = getRotatedPosition(iTime, graphPosition);\n#endif\n            graphPosition += focalPoint;\n\n            int iterationLimit = 200;\n            int stableIterations = getIterationsBeforeExplosion(graphPosition, iterationLimit);\n            \n            if (stableIterations >= iterationLimit) {\n\t\t\t\toutColor += vec3(0.f);\n            } else {\n                outColor += rotateColor(vec3(getColor(float(stableIterations) / float(iterationLimit))));\n            }\n        }\n    }\n    \n    outColor /= float(antiAlias*antiAlias);         \n    \n#ifdef SHOW_TARGET\n        float crosshairWidth = 1.f;\n        if ((abs(fragCoord.x - iResolution.x/2.f) < crosshairWidth || abs(fragCoord.y - iResolution.y/2.f) < crosshairWidth)) {\n            outColor = vec3(1.f) - outColor;\n        }\n#endif\n\n#ifdef INVERT\n    fragColor = vec4(vec3(1.f) - outColor, 1.f);\n#else\n    fragColor = vec4(outColor, 1.f);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 158], [160, 160, 224, 224, 565], [567, 567, 595, 595, 856], [858, 858, 912, 912, 1191], [1193, 1193, 1236, 1236, 1552], [1554, 1554, 1584, 1584, 2379], [2459, 2459, 2516, 2516, 3984]], "test": "valid"}
{"id": "wl2yDt", "name": "Cloth generator", "author": "michael0884", "description": "hm", "tags": ["hm"], "likes": 12, "viewed": 328, "published": "Public API", "date": "1595769350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Pseudo3D Fur\" by michael0884. https://shadertoy.com/view/tlBcRz\n// 2020-07-26 09:58:24\n\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define center R*0.5\n#define L 1.\n#define P 50.\n\n#define A 100.\n#define light_dir normalize(vec3(0.36,0.6,0.7))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p, out vec2 grad)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 pfs = sin(pf*PI);\n   \n   const vec2 a = vec2(0.,1.);\n   \n   float a00 = hash12(pi+a.xx);\n   float a01 = hash12(pi+a.xy);\n   float a10 = hash12(pi+a.yx);\n   float a11 = hash12(pi+a.yy);\n   \n   float x1 = mix(a00, a01, pfc.y);\n   float x2 = mix(a10, a11, pfc.y);\n   float y1 = mix(a00, a10, pfc.x);\n   float y2 = mix(a01, a11, pfc.x);\n    \n   grad = vec2((x2 - x1)*pfs.x, (y2 - y1)*pfs.y);\n   \n   return 0.5 + 0.5*mix(x1, x2, pfc.x);\n}\n\nvec4 dir(vec2 p, vec2 freq, float phase)\n{\n    float x = dot(p, freq) + phase;\n    return vec4(cos(x), sin(x), -freq.x*sin(x), freq.y*cos(x));\n}\n\nvec4 wind(vec2 p, float t)\n{\n    t*=5.;\n    \n    vec4 dx = 0.04*dir(p, vec2(-0.3, -0.5), 1.133*t)+\n              0.1*dir(p, vec2(0.1, 0.11), 0.431*t)+\n              0.2*dir(p, vec2(-0.12, 0.1), 0.256*t);\n    return 0.6*dx;\n}\n\nvec3 clothl(vec2 p, out vec2 GRAD)\n{\n    vec3 f = vec3(0.);\n    vec3 d = vec3(0., 0., 1.);\n    GRAD = vec2(0.);\n    for(int i = 0; i < 2; i++)\n    {\n        vec2 grad;\n        f += perlin(d.z*p + d.xy + vec2(i)*1e3, grad)*vec3(1.);\n        GRAD += d.z*grad;\n        d = vec3(d.x,d.y,0.3)*d + vec3(2.64, 1.5446, 0.);\n    }\n    return f;\n}\n\n#define cell_s 0.2\nvec3 cloth_pattern(vec2 pos, out vec3 normal)\n{\n    //create the weaving pattern\n    vec2 g1, g2;\n    const vec2 strand = vec2(0.02, 1.5); \n \tvec3 a = vec3(1.,.7,0.)*clothl(strand*pos, g1);\n    vec3 b = 1.2*vec3(1.,0.2,0.25)*clothl(strand.yx*pos, g2);\n    //checker modulation\n    float M = (2.*smoothstep(-0.5,0.5,sin(PI*pos.x*cell_s)) - 1.)*\n        \t  (2.*smoothstep(-0.5,0.5,sin(PI*pos.y*cell_s)) - 1.);\n    float Ma = smoothstep(-0.2,0.2,M);\n    normal = normalize(vec3(2.*mix(g1*strand, g2*strand.yx, Ma),1.));\n    return 3.*mix(a,b,Ma);\n}\n\nvec4 cloth(vec2 p)\n{\n    vec4 col = vec4(0.);\n    vec4 dx = wind(p*0.1, iTime);\n    //displacement normal\n    vec3 normal = normalize(vec3(-A*dx.zw, 1.));\n  \t//diceplacement\n    vec2 pos = p + A*dx.xy; \n    \n    //texture\n    vec3 c, N;\n    c = cloth_pattern(pos, N);\n    \n    //cloth normal modulation\n    normal = normalize(1.6*normal + N);\n    \n    // magic shading stuff\n\tfloat d = clamp(dot(normal, light_dir), 0., 1.);\n    float s = pow(d, 20.);\n    float B = 0.08*d + 0.05 + 0.2*s; //brightness\n    col = vec4(B*c,1.); //blend\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n   \t\n    fragColor = tanh(2.*cloth(0.5*fragCoord));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 283, 283, 400], [402, 402, 439, 439, 961], [963, 963, 1005, 1005, 1107], [1109, 1109, 1137, 1137, 1333], [1335, 1335, 1371, 1371, 1672], [1693, 1693, 1740, 1773, 2238], [2240, 2240, 2260, 2260, 2795], [2797, 2797, 2854, 2879, 2933]], "test": "valid"}
{"id": "wl2yDV", "name": "v3TriLattice6.glsl", "author": "jorge2017a1", "description": "v3TriLattice6.glsl", "tags": ["v3trilattice6glsl"], "likes": 16, "viewed": 249, "published": "Public", "date": "1595445479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float offs = step(fract(1.0 - uv.y), fract(sx));\n    return vec2(floor(sx) * 2.0 + offs, floor(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y * 8.0;\n\n    vec3 p = vec3(dot(uv, vec2(1.0, 0.5)), dot(uv, vec2(-1.0, 0.5)), uv.y);\n    vec3 p1 = fract(+p);\n    vec3 p2 = fract(-p);\n\n    float d1 = min(min(p1.x, p1.y), p1.z);\n    float d2 = min(min(p2.x, p2.y), p2.z);\n    float d = min(d1, d2);\n\n    vec2 tri = uv2tri(uv);\n    float r = rand(tri) * 2.0 + tri.x / 16.0 + iTime * 2.0;\n    \n    \n    //float c = step(0.2 + sin(r) * 0.2, d);\n    //por iq correccion\n\tfloat c = smoothstep(-0.02,0.0,d-0.2*(1.0+sin(r)));\n    \n    fragColor = vec4(c, c, c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [93, 93, 115, 115, 270], [272, 272, 329, 329, 908]], "test": "valid"}
{"id": "wl2yRD", "name": "Color Warp", "author": "yozic", "description": "Inspired by https://www.shadertoy.com/view/MsyGRm", "tags": ["colorful", "psychedelic", "trippy"], "likes": 22, "viewed": 580, "published": "Public API", "date": "1593890174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WARP true\n#define BALLS 10.\n#define CONTRAST 3\n#define GLOW .1\n#define ORB_SIZE 0.492519\n#define PI 3.14159265359\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= 2.2;\n  fragColor = vec4(0.);\n  float dist = distance(uv, vec2(0.));\n  uv = WARP ? uv * kale(uv, vec2(0.), 2.) : uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t = iTime/2. - i * PI / BALLS * cos(iTime / i);\n    vec2 p = vec2(cos(t), sin(t)) / sin(i / BALLS * PI / dist + iTime);\n    vec3 c = cos(vec3(0, 5, -5) * PI * 2. / PI + PI * (iTime / (i+1.) / 5.)) * (GLOW) + (GLOW);\n    fragColor += vec4(vec3(dist * .35 / length(uv - p * ORB_SIZE) * c), 1.0);\n  }\n  fragColor.xyz = pow(fragColor.xyz, vec3(CONTRAST));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 170, 170, 411], [413, 413, 469, 469, 1085]], "test": "valid"}
{"id": "Wl2yWh", "name": "incoming taunt", "author": "RomaNPE", "description": "Animated segments for incoming taunt animation", "tags": ["segment", "aniamted"], "likes": 1, "viewed": 59, "published": "Public", "date": "1594297550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distance_to_line_segment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0 );\n    return length(pa - h * ba);\n}\n\nvec3 pal(float progress) {\n\treturn mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), progress);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 sa = vec2(-1.0, 0.0);\n    vec2 sb = vec2(0.2, 0.1);\n    vec2 sc = vec2(-0.2, -0.1);\n    vec2 sd = vec2(1.0, 0.0);\n    \n    vec2 se = vec2(-0.9, 0.01);\n    vec2 sf = vec2(-0.85, 0.06);\n    \n    vec2 sg = vec2(-0.9, -0.02);\n    vec2 sh = vec2(-0.85, -0.06);\n        \n    float progress = sin(iTime * 0.2);\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.yy;\n    float line_radius = mix(0.025, 0.01, uv.x  + 1.0 );\n    \n   \tvec2 a = sd;\n    vec2 b = sd;\n    vec2 c = sd;\n    vec2 d = sd;\n    \n        c = mix(sd, sc, smoothstep(0.0, 0.2, progress));\n    \tb = c;\n        a = c;\n   \n    if (progress >= 0.2) {\n     \tb = mix(sc, sb, smoothstep(0.2, 0.4, progress));\n        d = mix(sd, sc, smoothstep(0.22, 0.42, progress));\n        a = b;\n        c = sc;\n    }\n    \n    if (progress >= 0.4) {\n     \ta = mix(sb, sa, smoothstep(0.4, 0.6, progress));\n        b = sb;\n        c = mix (sc, sb, smoothstep(0.42, 0.62, progress));\n        d = mix(sd, c, smoothstep(0.22, 0.42, progress));\n    }\n    \n    if (progress >= 0.6) {\n        a = sa;\n        b = mix(sb, sa, smoothstep(0.62, 0.82, progress));\n        c = mix (sc, b, smoothstep(0.42, 0.62, progress));\n        d = b;\n    }\t\n    \n    float dist0 = distance_to_line_segment(uv, a, b);\n    float dist1 = distance_to_line_segment(uv, b, c);\n    float dist2 = distance_to_line_segment(uv, c, d);\n    \n    // combine distances\n    float dist = min(min(dist0, dist1), dist2);\n    \n    if (progress >= 0.9) {\n         line_radius = 0.004;\n     \ta = se;\n        b = mix(se, sf, smoothstep(0.9, 0.95, progress));\n        c = sg;\n        d = mix(sg, sh, smoothstep(0.9, 0.95, progress));\n        \n        dist1 = distance_to_line_segment(uv, a, b);\n    \tdist2 = distance_to_line_segment(uv, c, d);\n    \n    \tdist = min(dist1, dist2);\n    }\n    \n    if (progress >= 0.95) {\n       \n     \ta = mix(se, sf, smoothstep(0.95, 1.0, progress));\n        b = sf;\n        c = mix(sg, sh, smoothstep(0.95, 1.0, progress));\n        d = sh;\n        \n        dist1 = distance_to_line_segment(uv, a, b);\n    \tdist2 = distance_to_line_segment(uv, c, d);\n    \n    \tdist = min(dist1, dist2);\n    }\n   \n    \n    // get antialiased line segments from distance\n    float brightness = smoothstep(line_radius + 0.015, line_radius, dist);\n    \n    vec3 baseColor = pal(sin(iTime * 0.2));\n    vec3 result = mix(vec3(0.0), baseColor, brightness);\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 67, 67, 197], [199, 199, 225, 225, 292], [294, 294, 348, 348, 2775]], "test": "valid"}
{"id": "Wl2yWw", "name": "Xor \"automaton\"", "author": "jarble", "description": "Another modification of my [url=https://www.shadertoy.com/view/wtlcR8]modified \"Circuit Diagram2.\"[/url] It looks almost like a cellular automaton.", "tags": ["xor"], "likes": 3, "viewed": 188, "published": "Public API", "date": "1594530822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Circuit Diagram2\" by ntsutae (modified by jarble)\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y);\n  int r = (x+y+int(iTime*50.0))^(x-y);\n  bool b = abs(r*r*r/(y+x)) % (999970) < 100000;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 215, 215, 407]], "test": "valid"}
{"id": "wl2yzd", "name": "Square Gradient Droplets", "author": "peterszerzo", "description": "A square-based shader with simple two-point gradients.", "tags": ["gradient", "square", "droplets"], "likes": 5, "viewed": 82, "published": "Public", "date": "1595347876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist2(vec2 v, vec2 a, vec2 b) {\n    return distance(v, a) * distance(v, b);\n}\n\nfloat getGradient(float remainder, vec2 uv) {\n    if (remainder == 0.0) {\n        return dist2(uv, vec2(0.2), vec2(0.2, 0.8));\n    } else if (remainder == 1.0) {\n        return dist2(uv, vec2(0.6, 0.9), vec2(0.2, 0.2));\n    } else if (remainder == 2.0) {\n        return dist2(vec2(1.0) - uv, vec2(0.5, 0.5), vec2(0.9, 0.2));\n    } else {\n        return dist2(vec2(uv.x, 1.0 - uv.y), vec2(0.9), vec2(0.8));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.x;\n    \n    vec2 uvGrid = uv * (11.0 + 11.0) + 7.0;\n    \n    vec2 uvIndices = floor(uvGrid);\n    \n    vec2 uvLocal = fract(uvGrid);\n    \n    float remainder = mod(uvIndices.x * uvIndices.y, 4.0);\n    \n    float gradient = getGradient(remainder, uvLocal);\n    \n    fragColor = vec4(\n        mix(\n            vec3(235.0, 75.0, 152.0) / 255.0,\n            vec3(90.0, 100.0, 242.0) / 255.0,\n            0.5 + 0.5 * cos(0.1 * iTime)\n        ) *\n        (vec3(0.3) + 0.7 * vec3(\n            sin(3.0 * uvIndices.x * uvIndices.y +\n            7.0 * uvIndices.y * uvIndices.y +\n            iTime * 0.5) +\n            gradient * 0.3\n        )) * 0.8,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 83], [85, 85, 130, 130, 498], [500, 500, 555, 555, 1255]], "test": "valid"}
{"id": "wl2yzt", "name": "Flying through psychedelic mist", "author": "mrange", "description": "License CC0: Flying through psychedelic mist\nMessing around with colors and FBM. \nSet BPM to some value that match your music.", "tags": ["2d", "fbm", "colorful"], "likes": 21, "viewed": 620, "published": "Public API", "date": "1595152447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Flying through psychedelic mist\n// Messing around with colors and FBM. \n\n// Set BPM to some value that match your music.\n#define BPM             30.0\n\n#define GAMMAWEIRDNESS\n#define QUINTIC\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rotSome          = MROT(1.0);\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#ifdef QUINTIC\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nvec3 alphaBlendGamma(vec3 back, vec4 front, vec3 gamma) {\n  vec3 colb = max(back.xyz, 0.0);\n  vec3 colf = max(front.xyz, 0.0);;\n  \n  colb = pow(colb, gamma);\n  colf = pow(colf, gamma);\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return pow(xyz, 1.0/gamma);\n}\n\nvec3 offset_0(float z) {\n  float a = z;\n  vec2 p = vec2(0.0);\n  return vec3(p, z);\n}\n\nvec3 offset_1(float z) {\n  float a = z/3.0;\n  vec2 p = -2.0*0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 offset(float z) {\n  return offset_1(z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return mix(1.5*vec3(0.75, 0.75, 1.0), vec3(0.0), length(2.0*rd.xy));\n}\n\nfloat height(vec2 p, float n, out vec2 diff) {\n  const float aan = 0.45;\n  const float ppn = 2.0+0.2;\n  \n  float s = 0.0;\n  float d = 0.0;\n  float an = 1.0;\n  vec2 pn = 4.0*p+n*10.0;\n  vec2 opn = pn;\n\n  const int md = 1;\n  const int mx = 4;\n  \n  for (int i = 0; i < md; ++i) {\n    s += an*(vnoise(pn)); \n    d += abs(an);\n    pn *= ppn*rotSome;\n    an *= aan; \n  }\n\n  for (int i = md; i < mx; ++i) {\n    s += an*(vnoise(pn)); \n    d += abs(an);\n    pn *= ppn*rotSome;\n    an *= aan; \n    pn += (3.0*float(i+1))*s-TIME*5.5;     // Fake warp FBM\n  }\n\n  s /= d;\n\n  diff = (pn - opn);\n\n  return s;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float aa, float n) {\n  vec2 p = pp.xy;\n  float z = pp.z;\n  float nz = pp.z-ro.z;\n  \n  vec2 diff;\n  vec2 hp = p;\n  hp -= nz*0.125*0.5*vec2(1.0, -0.5);\n  hp -= n;\n  float h = height(hp, n, diff);\n  float gh = (vnoise(0.25*(p+vec2(n))));\n  h *= mix(0.75, 1.0, gh);\n  h = abs(h);\n  \n  vec3 col = vec3(0.0);\n  col = vec3(h);\n  float huen = (length(diff)/200.0);\n  float satn = 1.0;\n  float brin = h;\n  col = hsv2rgb(vec3(huen, satn, brin));\n  \n  float t = sqrt(h)*(smoothstep(0.0, 0.5, length(pp - ro)))*smoothstep(0.0, mix(0.4, 0.75, pow(psin(TIME*TAU*BPM/60.0), 4.0)), length(p));\n  return vec4(col, t);\n}\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n//  vec3 rd = normalize(p.x*uu + p.y*vv + (3.00-1.0*tanh(lp))*ww);\n  vec3 rd = normalize(p.x*uu + p.y*vv + (2.00+tanh(lp))*ww);\n\n  float planeDist = 1.0-0.25;\n  const int furthest = 6;\n  const int fadeFrom = furthest-4;\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);  \n  \n  vec3 col = skyCol;\n\n  for (int i = furthest; i >= 1 ; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n    \n    float pd = (pz - ro.z)/rd.z;\n    \n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n   \n      float aa = length(dFdy(pp));\n\n      vec4 pcol = plane(ro, rd, pp, aa, nz+float(i));\n      float nz = pp.z-ro.z;\n      float fadeIn = (1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), nz));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      vec3 gamma = std_gamma;\n#ifdef GAMMAWEIRDNESS\n      float ga = pp.z;\n      vec3 gg = vec3(psin(ga), psin(ga*sqrt(0.5)), psin(ga*2.0));\n      gamma *= mix(vec3(0.1), vec3(10.0), gg);\n#endif\n      col = alphaBlendGamma(col, pcol, gamma);\n    } else {\n      break;\n    }\n    \n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm = TIME;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yzt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[490, 490, 512, 512, 681], [683, 683, 707, 707, 774], [776, 776, 797, 797, 826], [828, 828, 850, 850, 1426], [1428, 1428, 1485, 1485, 1687], [1689, 1689, 1713, 1713, 1773], [1775, 1775, 1799, 1799, 1941], [1943, 1943, 1965, 1965, 1989], [1991, 1991, 2014, 2014, 2089], [2091, 2091, 2115, 2115, 2194], [2196, 2196, 2229, 2229, 2302], [2304, 2304, 2350, 2350, 2899], [2901, 2901, 2959, 2959, 3541], [3542, 3542, 3598, 3598, 4780], [4782, 4782, 4819, 4819, 5027], [5029, 5029, 5058, 5058, 5381], [5383, 5383, 5435, 5435, 5597]], "test": "error"}
{"id": "Wl2yzW", "name": "<><> Echeveria II", "author": "steve_w", "description": "Echeveria II by tdhooper with a mic input modulator.\n\nSee <><> DJ section for basic beat detection.\n\n\nhttps://www.shadertoy.com/view/WtGXWm by ", "tags": ["beat", "microphone", "dj"], "likes": 8, "viewed": 270, "published": "Public", "date": "1593858743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define AA 3\n#define AO\n//#define GIF\n\n// voronoi - adapted from iq https://www.shadertoy.com/view/ldl3W8\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi( in vec2 x )\n{\n    vec2 cell = floor(x);\n\n    float d = 1e12;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 offset = vec2(float(i),float(j));\n        vec2 pos = hash2( cell + offset );\n        vec2 r = cell + offset + pos;\n        d = min(d, length(x - r));\n    }\n\n    return d;\n}\n\n// HG_SDF \n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n\n// Modelling\n\nfloat time;\nbool lightingPass;\nmat3 modelMat;\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n};\n\nModel leaf(vec3 p, vec3 cellData) {\n    //cellData = vec3(0,0,.1);\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    //cell.x = 0.;\n    //cell.y = .1;\n    //cellTime = .2;\n\n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    // orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n    len = pow(len, .33);\n    float llen = len;\n\n\n    if (cellTime > 0.) {\n\n        // wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        // wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,.4));\n        float wedge2 = -dot(p, n);\n        wedge2 = max(wedge2, dot(p, n * vec3(1,1,-1)));\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len / 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - .05;\n        d2 = max(d2, top);\n        \n        float d3 = smax(d2, wedge, .05);\n        float d4 = smax(d2, wedge2, .05);\n        wedges = smin(wedge, wedge2, .01);\n        d3 = smin(d3, d4, .01);\n        d = d3;\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz / len;\n        return Model(d, p, uv, cell, wedges, slice, len);\n    }\n\n\treturn Model(d, p, vec2(0), vec2(0), 0., 0., 0.);\n}\n\nvec3 calcAlbedo(Model model) {    \n    vec3 col = vec3(.15,.15,.4);\n\n\tvec3 p = model.p;\n    float len = model.len;\n    vec2 cell = model.cell;\n    float wedges = model.wedges;\n    float slice = model.slice;\n    vec2 uv = model.uv;\n    \n    float v = voronoi((uv+4.)*30.);\n    float v2 = voronoi((uv+4.)*4.+cell.x);\n\n    col = mix(col, vec3(.125,.2,.4), 1.-v2);\n    float tip = length(p - vec3(0,.2,len*.9));\n\n    tip = smoothstep(.5, .0, tip);\n    tip *= smoothstep(.07, .0, abs(slice+.01));\n    tip *= smoothstep(-.2, .0, wedges);\n    tip = pow(tip, 1.5);\n    col = mix(col, vec3(1,.2,.5), tip);\n\n    float vs = 1.-uv.y*1.;\n    vs *= smoothstep(.0, -.1, wedges);\n    vs *= smoothstep(.0, .05, abs(slice));\n    v = smoothstep(vs + .1, vs - .5, v*1.5);\n    col = mix(col, vec3(.05,.05,.2), v*v2);\n\n    col *= mix(vec3(1), vec3(.5,5.,1.8), smoothstep(.2, 1.8, cell.y) * .75);\n  \n    return col;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t\n) {\n\n    float sz = maxBloomOffset + PI / 2.;\n\n    cell = transform * cell;\n\n    // Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    // Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch / sz / stretchStart;\n    cell.y = max(cell.y, .5/stretchStart); // clamp, not sure why this magic number\n    cell.y /= stretch / sz / stretchStart;\n    cell = transform * cell;\n\n    // Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    // calculate cell time\n    float y = cell.y * (stretch / sz);\n    float cellAppearTime = (stretchStart - y) / (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x / cc.y);\n    float scale = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1./scale,0,0,1./scale);\n\tphyllotaxis = mRot * mScale;\n}\n\nModel bloom(vec3 p, float t) {\n\n    p.y -= .05;\n\n    vec2 move = vec2(0, t);\n    float stretchStart = .25;\n    float stretchEnd = 1.;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI / 2.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n\n\tModel res = Model(1e12, p, vec2(0), vec2(0), 0., 0., 0.);\n    //res.d = length(p) - 1.; return res;\n\n    // compile speed optim from IQ\n    for( int m=min(iFrame,0); m<3; m++ )\n    for( int n=min(iFrame,0); n<3; n++ )\n    {\n    \tres = opU(res, leaf(p, calcCellData(cell, vec2(m, n) - 1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t)));\n    }\n\n    return res;\n}\n\nModel map(vec3 p) {\n    p *= modelMat;\n    float t;\n    \n    float bound = length(p) - 1.3;\n    if (bound > .01 && ! lightingPass) {\n\t\treturn Model(bound, p, vec2(0), vec2(0), 0., 0., 0.);\n    }\n\n    pR(p.xy, time * -PI);\n\n    vec3 pp = p;\n    \n    float side = sign(p.y);\n    p.y = abs(p.y);\n\tp.z *= side;\n\n    t = time + .5 * side;\n    t = sin(t * PI - PI/2.) * .5 + .5;\n    pR(p.xz, time * PI);\n    Model model = bloom(p, t);\n    \n    if (abs(p.y) < .34) {\n        p = pp;\n    \tside *= -1.;\n        p.yz *= side;\n        t = time + .5 * side;\n    \tt = sin(t * PI - PI/2.) * .5 + .5;\n        pR(p.xz, time * PI);\n        Model model2 = bloom(p, t);\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/3dyXzD\nvec3 randDir( vec3 n, vec2 seed ) {\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n    vec3  vv = cross( uu, n );\n    \n    float ra = sqrt(seed.y);\n    float rx = ra*cos(6.2831*seed.x); \n    float ry = ra*sin(6.2831*seed.x);\n    float rz = sqrt( 1.0-seed.y );\n    vec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nfloat hitLength(vec3 pos, vec3 dir, float maxDist) {\n    float len = 0.;\n    const int steps = 15;\n    float dist = maxDist / float(steps);\n    vec3 rayPos;\n    for (int i = 0; i < steps; i++) {\n        len += dist;\n        dist = map(pos + dir * len).d;\n        if (abs(dist) < .001) {\n            break;\n        }\n        if (len > maxDist) {\n            len = maxDist;\n            break;\n        }\n    }\n    return len / maxDist;\n}\n\nfloat calcAO(vec3 pos, vec3 nor, vec2 seed, float maxDist) {\n    float len = 0.;\n    const float SAMPLES = 3.;\n    for (float x = 0.; x < SAMPLES; x++)\n    for (float y = 0.; y < SAMPLES; y++)\n    {\n        vec2 s = seed + vec2(x, y) / SAMPLES;\n        s = hash2(s);\n        vec3 dir = randDir(nor, s);\n        len += hitLength(pos, dir, maxDist);\n    }\n\n    len /= SAMPLES * SAMPLES;\n    return len;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nmat3 rotX(float a) {\n    return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));\n}\n\nmat3 rotY(float a) {\n    return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));\n}\n\nmat3 rotZ(float a) {\n    return mat3(cos(a),-sin(a),0, sin(a),cos(a),0, 0,0,1);\n}\n\nfloat pat(vec2 uv) {\n    vec2 p = vec2(atan(uv.x/uv.y), log(length(uv)));\n   \n   \tp *= phyllotaxis;\n    p = p * 4.;\n    \n    p -= vec2(0,8) * time;\n\n    p = mod(p, 1.);\n    float d = length(p - .5) - .1;\n    float fw = fwidth(d);\n\n    d = abs(d) - .01;\n    d /= fw;\n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime / 4., 1.) + .35;\n\n\n    // <><> DJ[BEGIN]\n\n\t\n\t// TODO: Find iTime assign, wire in to that & iChannel0 with a mic input into it.\n\t\n    const float _time_scale = 0.65f;\n    const float _wave_scale = 0.01f;\n    const float _fft_scale = 0.5f;\n\n    vec2 _uv = fragCoord.xy / iResolution.xy;\n    int _tx = int(_uv.x*512.0);\n\tfloat _wave = texelFetch( iChannel0, ivec2(_tx,1), 0 ).x;\n\n    int _fft_tx = 0;\n    float _fft  = texelFetch( iChannel0, ivec2(_tx,0), 0 ).x;\n\n    const int BEAT_RANGE = 50;\n    float _beat = 0.0f;\n    for (int beat=0;beat<BEAT_RANGE;beat++)\n        _beat += texelFetch( iChannel0, ivec2(beat,0), 0 ).x; //fft\n    _beat *= _fft_scale;\n    _beat /= float(BEAT_RANGE);\n    \n    time = mTime * _time_scale;\n    time += _beat;\n    time += _wave * _wave_scale;\n    \n    // <><> DJ[END]\n\n\n\n    //time = mTime;\n\n\n\n\n\n\n\n\n\n\n    \n    calcPhyllotaxis();\n    modelMat = rotZ(-.9) * rotX(.05) * rotY(-1.1);\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    // time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 camPos = vec3(0,0,-2.6);\n        #ifdef GIF\n        \tcamPos.z = -2.8;\n       \t#endif\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-.05,0), 0.);\n        vec3 rayDirection = normalize( camMat * vec3(p.xy,1.8) );\n\n        vec3 rayPosition = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        Model model;\n\n        lightingPass = false;\n        \n        for (int i = 0; i < 300; i++) {\n            rayLength += dist;\n            rayPosition = camPos + rayDirection * rayLength;\n            model = map(rayPosition);\n            dist = model.d;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 5.) {\n                bg = true;\n                break;\n            }\n        }\n        \n        lightingPass = true;\n        \n        col = vec3(.4,.4,1);\n        #ifndef GIF\n        \tcol = mix(col, vec3(.0,1.5,1.5)*1.5, (1.-pat(p))*.5);\n        \tcol = mix(col, vec3(.63,.7,1), smoothstep(2.5, .5, length(p)));\n        #else\n        \tcol = mix(col, vec3(.63,.7,1), .95);\n        #endif\n        col *= vec3(.9,1.,1.);\n        col += .1;\n        \n        //bg = true;\n        \n        if ( ! bg) {\n\n            vec3 pos = rayPosition;\n            vec3 rd = rayDirection;\n            vec2 seed = hash2(p + time);\n            \n            #ifndef AA\n            \tseed *= .0000001;\n            #endif\n            \n            vec3  nor = calcNormal(pos);\n            \n            float occ = 1.;\n            #ifdef AO\n            \tocc = calcAO(pos, nor, seed, .85);\n            \tocc = clamp(pow(occ*1.25, 1.5), 0., 1.);\n            #endif\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            vec3 lin = vec3(0);\n            lin += 1.70 * amb * vec3(1.30,1.00,0.70) * occ;\n            lin += 0.90 * amb * vec3(0.30,0.80,1.30);\n            lin += 1.00 * fre * vec3(1.00,1.00,1.00) * occ;\n\n\n            vec3 albedo = calcAlbedo(model);\n            col = albedo * lin;\n            \n            //col *= mix(vec3(1), vec3(.0,.5,.7)*.5, 1.-occ);\n\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    col = tot;\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 131, 131, 224], [226, 226, 254, 254, 555], [636, 636, 668, 668, 713], [715, 715, 753, 753, 864], [866, 866, 905, 905, 936], [938, 938, 988, 988, 1031], [1033, 1033, 1074, 1074, 1118], [1301, 1301, 1336, 1367, 3061], [3063, 3063, 3093, 3093, 3957], [3959, 3959, 4157, 4157, 4906], [4908, 4908, 4937, 4937, 5009], [5029, 5029, 5053, 5053, 5310], [5312, 5312, 5342, 5342, 6162], [6164, 6164, 6183, 6183, 6877], [6879, 6948, 6974, 6974, 7175], [7177, 7218, 7253, 7253, 7565], [7567, 7567, 7619, 7619, 8001], [8003, 8003, 8063, 8063, 8405], [8407, 8407, 8471, 8471, 8649], [8651, 8651, 8671, 8671, 8732], [8734, 8734, 8754, 8754, 8815], [8817, 8817, 8837, 8837, 8898], [8900, 8900, 8920, 8920, 9212]], "test": "error"}
{"id": "WlBcD3", "name": "Somewhere In Colorado.", "author": "Plento", "description": "I'm a little bit rock and roll", "tags": ["2d", "mountains", "house", "recreation", "southpark"], "likes": 19, "viewed": 332, "published": "Public API", "date": "1595535519", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box(vec2 uv, vec2 dim, float b){\n    uv = abs(uv);\n    float bx = ss(b, -b, uv.y - dim.y );\n    bx *= ss(b, -b, uv.x - dim.x);\n    return bx;\n}\n\nvec3 frameCol = 0.9*vec3(0.4, 0.3, 0.1);\nvec3 winCol = .8*vec3(0.3, 0.9, 0.9);\n\nvec4 ground(vec2 uv){\n    float y = uv.y + 0.5;\n    float a = 1.-step(.21, y);\n    float sw = .6 * ss(-.1, 0.1, abs(cos(10.*(-uv.x + uv.y*2. + .12))));\n    vec3 col = mix(vec3(.16), mix(vec3(.34), vec3(sw), step(.115, y)), step(.1, y));\n    col = mix(col, vec3(1), step(.21, y));\n    return vec4(col, a);\n}\n\n\nvec4 fence(vec2 uv){\n    float a = ss(.0543,.054, abs(uv.y+.05));\n \tvec3 col = .9*vec3(0.9, 0.76, 0.6) * a;   \n    col *= ss(-.3, .3, abs(sin(uv.x*140.)));\n    return vec4(col, a);\n}\n\n\n\nvec4 mountains(vec2 uv){\n    uv.y -= .12;\n    vec3 col = vec3(0);\n    float a = 0.;\n    float snow = 0.;\n    \n    for(float i = 0.; i < 2.; i++){ \n        uv.x += iTime*.05;\n        \n        float ht = texture(iChannel0, uv*16.).x;\n        \n        float nse = cos(uv.x*14. + i*345.)*.01 + cos(uv.x*44. + i*123.)*.003\n            + cos(uv.x*2. + i*654.)*.01;\n        \n        vec2 p = uv + nse;\n        float t = (1.3-i*.02)*p.x*.8 + i*9.;\n        float h = .06*asin(sin(6.*t + 2.5*i)*0.999);\n        float c = ss(.104,.1, p.y - h - i*.01 + .02);\n    \ta = mix(a, 1., c);\n        \n    \tcol = mix(col, mix(vec3(.2, .3, .3),1.3*vec3(0.13, 0.26, 0.18),i), c);\n        col +=ht*.06;\n    \tsnow = ss(.66, .674, (uv.y + 0.522)+nse*1.4);\n    \tcol = mix(col, vec3(3), snow); \n    }\n    return vec4(col, a);\n}\n\n\nfloat snow(vec2 uv){\n    float nse = cos(uv.x*60.)*.001 + cos(uv.x*170.)*.0006 + cos(uv.x*10. + 24.32)*.003\n        + cos(uv.x*30. + 65.32)*.003;\n    uv.y += nse;\n \tfloat a = ss(.1,.1038, abs(uv.y+.2));   \n    vec3 col = vec3(0);\n    return a;\n}\n\nfloat houseShape(vec2 uv, vec2 dim){\n    float ox = dim.x;\n    dim.x -= uv.y;\n    dim.x = min(ox, dim.x);                      \n    return box(uv, dim, .001);\n}\n\nvec4 roofShape(vec2 uv){\n    float p = uv.x;\n    \n    uv.x = abs(uv.x);\n    uv *= rot(7.05);\n    \n    float a = box(uv-vec2(-0.13, .32), vec2(.2, .01), .0001);\n    vec3 col = frameCol * a;\n    \n    if(uv.y < 0.321)\n    \tuv.y -= (cos(p*171.)*.01 + cos(p*50.)*.003 + cos(p*70.)*.005);\n    \n    float snow = box(uv-vec2(-0.13, .33), vec2(.21, .008), .005);\n    col += vec3(6.) * snow;\n    \n    a += snow;\n    return vec4(col, a);\n}\n\n\nvec4 house(vec2 uv, vec3 hc, bool front){\n    vec3 col = hc;\n    \n    float a = houseShape(uv-vec2(0., .21), vec2(0.24, 0.35));\n    vec2 p = (uv - vec2(0., 0.17)) * 6.5;\n    \n    vec2 b = vec2(0.91, 1.3);\n    vec2 wv = mod(p + 0.5*b, b) - 0.5*b;\n    \n    if(front){\n    \tfloat glass = box(wv, vec2(.26, .28), .001);\n    \tfloat frame = box(wv, vec2(.22, .24), .001);\n    \tframe *= step(.01, abs(wv.x))*step(.01, abs(wv.y));\n    \n        glass += frame;\n    \n    \tvec3 window = mix(frameCol, winCol, step(2., glass));\n    \n    \tglass *= 1.-step(.26, uv.y);\n    \n    \tcol = mix(col, window, min(glass*3., 1.));\n    \n    \tfloat dr = box(uv-vec2(0., -0.04), vec2(.048, .076), .001);\n    \tfloat doorframe = box(uv-vec2(0., -0.04), vec2(.04, .07), .001);\n    \tfloat des = sdBox(uv-vec2(-0.02, 0.), vec2(.01, .02));\n        des = min(des, sdBox(uv-vec2(0.02, 0.), vec2(.01, .02)));\n        des = min(des, length(uv-vec2(0.02, -0.045))-.005);\n    \tcol = mix(col, .7*vec3(0.9, 0.8, 0.7), doorframe);\n    \tcol *= max(ss(.0,.0005, abs(des) - .001), 0.7);\n        \n    \tdr -= doorframe;\n    \tcol = mix(frameCol, col, 1.-dr);\n    \n    \tfloat steps = box(uv - vec2(0., -.137), vec2(.1, .005), .001);\n    \tsteps += box(uv - vec2(0., -.126), vec2(.08, .005), .001);\n   \t \tsteps += box(uv - vec2(0., -.115), vec2(.06, .005), .001);\n    \n    \tcol = mix(col, vec3(.5), steps);\n    }\n    \n    return vec4(col, a);\n}\n\n\nvec4 garage(vec2 uv, vec3 hc){\n    vec3 col = hc;\n \tfloat a = houseShape(uv-vec2(0.55, .068), vec2(0.20, 0.22));   \n    float door = box(uv-vec2(0.55, -0.05), vec2(.15, .1), .001);\n    col = mix(col, frameCol*ss(-.5, .5,abs(sin(uv.y*150. + 1.5))), door);\n    col *= max(min(abs((uv.y-.07)*310.), 1.), .8);\n    return vec4(col, a);\n}\n \n\nvec4 walkway(vec2 uv){\n    vec3 col = vec3(0);\n \t\n    vec2 p = uv-vec2(0.48, 0.08);\n    vec2 def = cos(uv*30.) * .01 + cos(uv*60. + 123.32) * .005 + cos(uv*250. + 123.32)*.0018;\n    p += def;\n    \n    p.x -= sin(p.y*8.)*.5;\n    p.y += cos(p.x*4.)*.1;\n    \n    float a = box(p - vec2(0.0, -0.2), vec2(.085, .1), .005);\n    \n    col = vec3(.65) * a;\n    \n    uv += def;\n    float w2 = box(uv - vec2(0.55, -0.22), vec2(.1 - uv.y*.4, .175), .002);\n    \n    a = min(a+w2, 1.);\n    col = mix(col, vec3(.65), a);\n    \n    return vec4(col, a);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 p = uv;\n    \n    uv.x += iTime*.2;\n    \n    vec3 col = vec3(.7, 0.9, 1.0);\n    \n    float spc = 1.8;\n    vec2 b = vec2(spc, 0.0);\n    vec2 ruv = mod(uv + 0.5*b, b) - 0.5*b;\n    ruv.x += .3;\n    float id = floor((uv.x - .5)/spc);\n    \n    \n    float ht = texture(iChannel0, uv*16.).x;\n    \n    // Mountains\n    vec4 mnt = mountains(p);\n    col = mix(col, mnt.rgb, mnt.a);\n    \n    \n   \n    float spc2 = 1.1;\n    vec2 b2 = vec2(spc2, 0.0);\n    vec2 p2 = p-vec2(0.0, 0.);\n    p2.x += iTime*.13;\n    vec2 ruv2 = mod(p2 + 0.5*b2, b2) - 0.5*b2;\n    ruv2.x += .3;\n    float id2 = floor((p2.x - .5)/spc2);\n    \n    float ht2 = texture(iChannel0, p2*16.).x;\n    \n    vec3 hcb = .2 + .5 * hash31(id2*223.32 + 88.);\n    hcb += ht2*.15;\n    \n    vec4 bhse = house((ruv2 - vec2(0.0, 0.))*1.8, hcb, false);\n    col = mix(col, bhse.rgb*.8, bhse.a);\n    vec4 rf3 = roofShape(ruv2*1.9);\n    col = mix(col, rf3.rgb, rf3.a);\n        \n    \n    // Fence\n    vec4 fnc = fence(uv);\n    col = mix(col, fnc.rgb, fnc.a);\n    \n    \n    // Snowy yard\n    float snw = snow(uv);\n    col = mix(vec3(1), col, snw);\n    \n    \n    // walkway/ driveway\n    vec4 wlk = walkway(ruv);\n    col = mix(col, wlk.rgb, wlk.a);\n    \n    \n    // Sidewalk and road\n    vec4 gnd = ground(uv);\n    col = mix(col, gnd.rgb, gnd.a);\n    \n    // house color\n    vec3 hc = .2 + .5 * hash31(id*623.32 + 5.);\n    hc += ht*.15;\n    \n    // house\n    vec4 hse = house(ruv, hc, true);\n    col = mix(col, hse.rgb, hse.a); \n    \n    vec2 pc = ruv;\n    pc.xy += cos(uv.yx*40.+3.)*.005 + cos(uv.yx*80.+324.3)*.002 + cos(uv.yx*180.+324.3)*.001;\n    float det = box(pc-vec2(-0.42, -.18), vec2(.33, .05), .002);\n    det += box(-pc-vec2(-0.17, .143), vec2(.07, .01), .002);\n    col = mix(col, vec3(1), det);\n    \n    \n    // roof\n    vec4 roof = roofShape(ruv);\n    col = mix(col, roof.rgb, roof.a);\n    \n    // garage\n    vec4 grg = garage(ruv, hc);\n    col = mix(col, grg.rgb, grg.a); \n    \n    // garage roof\n    vec4 groof = roofShape(1.2*ruv-vec2(0.66, -0.13));\n    col = mix(col, groof.rgb, groof.a);\n    \n    \n    f = vec4(col, 1.0);\n    \n}\n\n\n\n\n\n\n", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 164], [166, 166, 187, 187, 320], [321, 321, 357, 357, 437], [438, 438, 476, 476, 587], [669, 669, 690, 690, 975], [978, 978, 998, 998, 1160], [1164, 1164, 1188, 1188, 1962], [1965, 1965, 1985, 1985, 2210], [2212, 2212, 2248, 2248, 2372], [2374, 2374, 2398, 2398, 2802], [2805, 2805, 2846, 2846, 4199], [4202, 4202, 4232, 4232, 4534], [4538, 4538, 4560, 4560, 5075], [5077, 5077, 5117, 5117, 7248]], "test": "error"}
{"id": "WlBcDh", "name": "Fire on Black", "author": "brunoliv", "description": "this is a copy shader without a background", "tags": ["fire"], "likes": 15, "viewed": 428, "published": "Public API", "date": "1594185878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I started working a bit on the colors of Remix 2, ended up with something like this. :)\n// Remix 2 here: https://www.shadertoy.com/view/MtcGD7\n// Remix 1 here: https://www.shadertoy.com/view/llc3DM\n// Original here: https://www.shadertoy.com/view/XsXXRN\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.1, 0.9);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p += sin(p.yx*4.0+vec2(.2,-.3)*iTime)*0.04;\n    p += sin(p.yx*8.0+vec2(.6,+.1)*iTime)*0.01;\n    \n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.3+1.0*sin(iTime+0.5)/2.0);\n    float qb = fbm(p - iTime * 0.4+0.1*cos(iTime)/2.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/2.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/15.0)-4.0;\n    float q4 = fbm(p - iTime * 1.4 - 20.0*sin(iTime)/14.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(1.0/(pow(c+1.61,vec3(4.0))) * cos(shift * fragCoord.y / iResolution.y));\n    \n    color=vec3(1.0,.2,.05)/(pow((r.y+r.y)* max(.0,p.y)+0.1, 4.0));;\n    color += (texture(iChannel0,uv*0.6+vec2(.5,.1)).xyz*0.01*pow((r.y+r.y)*.65,5.0)+0.055)*mix( vec3(.9,.4,.3),vec3(.7,.5,.2), uv.y);\n    color = color/(1.0+max(vec3(0),color));\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 278, 278, 352], [354, 354, 375, 375, 581], [583, 583, 602, 602, 787], [789, 789, 846, 846, 2375]], "test": "error"}
{"id": "wlBcDK", "name": "Circuits II", "author": "Kali", "description": "Coded during Flashparty 2020 online music compos ", "tags": ["2d", "fractal", "fake3d"], "likes": 36, "viewed": 431, "published": "Public", "date": "1595356938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 fractal(vec2 p) \n{\n   \tp=vec2(p.x/p.y,1./p.y);\n\tp.y+=iTime*sign(p.y);\n    p.x+=sin(iTime*.1)*sign(p.y)*4.;\n    p.y=fract(p.y*.05);\n    float ot1=1000., ot2=ot1, it=0.;\n\tfor (float i=0.; i<10.; i++) {\n    \tp=abs(p);\n        p=p/clamp(p.x*p.y,0.15,5.)-vec2(1.5,1.);\n        float m=abs(p.x);\n        if (m<ot1) {\n        \tot1=m+step(fract(iTime*.2+float(i)*.05),.5*abs(p.y));\n            it=i;\n        }\n        ot2=min(ot2,length(p));\n    }\n    \n    ot1=exp(-30.*ot1);\n    ot2=exp(-30.*ot2);\n    return hsv2rgb(vec3(it*.1+.5,.7,1.))*ot1+ot2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float aa=6.;\n    uv*=rot(sin(iTime*.1)*.3);\n    vec2 sc=1./iResolution.xy/(aa*2.);\n    vec3 c=vec3(0.);\n    for (float i=-aa; i<aa; i++) {\n        for (float j=-aa; j<aa; j++) {\n\t\t    vec2 p=uv+vec2(i,j)*sc;\n        \tc+=fractal(p);\n        }\n    }\n    fragColor = vec4(c/(aa*aa*4.)*(1.-exp(-20.*uv.y*uv.y)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 192], [194, 194, 213, 213, 269], [271, 271, 294, 294, 818], [820, 820, 877, 877, 1277]], "test": "valid"}
{"id": "WlBcDm", "name": "memories of pixel sea", "author": "Cheburum", "description": "2d sub pixels effect", "tags": ["2d"], "likes": 5, "viewed": 89, "published": "Public", "date": "1594490163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float steps = 25.,\n     maxRad = 500.;\n\nfloat get_layer(vec2 uv){\n    float timeModifier = ( sin(iTime/5.) + 1.3 ) / 2., i,\n          step_k = floor( steps * timeModifier ) / steps * maxRad;\n    vec2 k = exp2( sin(step_k*uv) );\n    i = 1.- (k.x + k.y) / 4.;    \n    return i*i*i;\n}\n\n#define rotate(a)  mat2(cos(a), sin(a), -sin(a), cos(a));\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    float a =   sin(iTime/5.) *U.x\n              + cos(iTime/5.)\n              + texture(iChannel0, vec2(0)).r / 4.;\n    U *= rotate(a);\n\n    O =   clamp(texture(iChannel0, U).r*4., 1., 4.) // music\n        * vec4( get_layer(U),\n                get_layer(U + vec2(.4,0) ),\n                get_layer(U + vec2(0,-.4)),\n                1 );\n}", "image_inputs": [{"id": "XtB3Rt", "previewfilepath": "https://soundcloud.com/thump/hvob-azrael", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/thump/hvob-azrael", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 65, 65, 281], [342, 342, 380, 380, 745]], "test": "error"}
{"id": "WlBcDt", "name": "Wobbling box", "author": "Jakowlew", "description": "-", "tags": ["jakowlew"], "likes": 4, "viewed": 257, "published": "Public API", "date": "1595629529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 60;\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Operations\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Primitives\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdScene(vec3 p)\n{\n    p = rotateY(iTime / 2.0) * p;\n    \n    float res = MAX_DIST;\n    \n    { // Box\n    float box = sdBox(p, vec3(.9) +  + 0.1*sin(3.*iTime)) - .1;\n    \n    float clipSphere = sdSphere(p, 1.5 + 0.1*sin(3.*iTime));\n    res = opUnion(res, opIntersection(box, clipSphere));\n    \n    float subSphere = sdSphere(p, 1.3);\n    res = opSubtraction(res, subSphere);\n    }\n    \n    { // Center ball\n    float sphere = sdSphere(p, .4);\n    res = opUnion(res, sphere);   \n    }\n    \n    { // Side balls   \n    float angle = 6.28 / 4.;\n    float sector = round(atan(p.z, p.x) / angle);\n    \n    vec3 q = p;\n    float an = sector * angle;\n    q.xz = mat2(cos(an), -sin(an), sin(an), cos(an)) * q.xz;\n    \n    \n    float sphere = sdSphere(q + vec3(-1.5 + 0.5*sin(3.*iTime), 0, 0), .4 - 0.1*sin(3.*iTime));\n    res = opUnion(res, sphere);\n    }\n    \n    // Wobble\n    res *= inversesqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    // Displacement\n    res += .3*sin(sin(1.*iTime)*25.*p.x)*.3*sin(sin(1.*iTime)*25.*p.y)*.3*sin(sin(1.*iTime)*25.*p.z);\n    return res;\n} \n\n\n// Raymarching\nfloat rayMarch(vec3 eye, vec3 marchingDirection, float start, float end, int maxSteps) {\n    float depth = start;\n    for (int i = 0; i < maxSteps; ++i) {\n        float dist = sdScene(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\n// Lightning\nvec3 estimateNormal(vec3 p)\n{\n    float pDist = sdScene(p);\n    return normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)) - pDist,\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)) - pDist,\n        sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - pDist\n    ));\n}\n\nvec3 phongIllumination(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N),0.,1.); \n    //float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 lightScene(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongIllumination(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongIllumination(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup camera\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);    \n    //vec3 eye = vec3(0., 0., 10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    // Calc SDF\n    float dist = rayMarch(eye, worldDir, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n\t\tfragColor = vec4(0);\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    //vec3 K_a = vec3(1.0, .19, .0);\n    vec3 K_a = 0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4));\n    //vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = lightScene(K_a, K_d, K_s, shininess, p, eye);\n    \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 151, 151, 298], [300, 300, 327, 327, 474], [476, 476, 503, 503, 650], [652, 666, 703, 703, 728], [730, 730, 773, 773, 799], [801, 801, 845, 845, 870], [872, 872, 924, 924, 1023], [1025, 1025, 1083, 1083, 1183], [1185, 1185, 1244, 1244, 1343], [1345, 1359, 1392, 1392, 1420], [1422, 1422, 1453, 1453, 1540], [1542, 1542, 1575, 1575, 1640], [1642, 1642, 1665, 1665, 2705], [2709, 2724, 2812, 2812, 3107], [3109, 3109, 3174, 3174, 3306], [3308, 3308, 3357, 3392, 3523], [3526, 3539, 3568, 3568, 3803], [3805, 3805, 3942, 3942, 4577], [4579, 4579, 4657, 4657, 5451], [5453, 5453, 5510, 5530, 6467]], "test": "valid"}
{"id": "wlBcDV", "name": "Drunk Stars", "author": "timeisbeautifulhere", "description": "These stars will help mellow you out.\n\nMess around with some constants, PALETTE, or STARS to change behavior.", "tags": ["lines", "intersection", "star", "rotating", "expanding"], "likes": 2, "viewed": 245, "published": "Public API", "date": "1595371362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Grab a slice\n#define PI 3.14159\n\n//How thicc the lines are.\n#define LINE_WIDTH 0.01\n\n//How fast the stars expand.\n//Higher value is more \"explosive\"\n#define EXPAND_RATE 0.1\n\n//Decide when stars should start to loop back.\n//Affects how close each star renders.\n#define MAX_RADIUS 8.0\n\n//How fast the stars spin.\n#define ROTATION_RATE 0.25\n\n//Arrays of stars, in order, to display\n#define NUM_STARS 6\nint STARS[NUM_STARS] = int[](5,6,7,8,9,10);\n\n//Color palette to cycle through for lines.\n#define PALETTE_LENGTH 7\nvec3[PALETTE_LENGTH] PALETTE = vec3[](\n    vec3(1.0,0.0,0.0),\n    vec3(0.0,1.0,0.0),\n    vec3(0.0,0.0,1.0),\n    vec3(1.0,1.0,0.0),\n    vec3(0.0,1.0,1.0),\n    vec3(1.0,0.0,1.0),\n    vec3(1.0,1.0,1.0)\n);\n\n//Equations for finding coefficients for line\n//ax + by + c = 0\n//https://math.stackexchange.com/questions/637922/how-can-i-find-coefficients-a-b-c-given-two-points\nfloat line_a(vec2 pa, vec2 pb){\n    return pa.y-pb.y;\n}\nfloat line_b(vec2 pa, vec2 pb){\n    return (-1.0) * (pa.x-pb.x);\n}\nfloat line_c(vec2 pa, vec2 pb){\n    return (pa.x*pb.y)-(pb.x*pa.y);\n}\n\n//True if (x,y) is on a line between pa and pb\nbool onLine(float x, float y, vec2 pa, vec2 pb){\n    float a = line_a(pa,pb),\n        b = line_b(pa,pb),\n        c = line_c(pa,pb);\n    \n    if(abs(a)<0.0001 && abs(b)>0.0001){\n        //Horizontal line\n        return abs(pa.y-y) < LINE_WIDTH;\n    }\n    \n    if(abs(b)<0.0001){\n    \t//Vertical line\n        return abs(pa.x-x) < LINE_WIDTH;\n    }\n    \n    //Distance from line: |ax0+by0+c| / sqrt(a^2 + b^2)\n    float dist = abs(a*x + b*y + c) / sqrt((a*a)+(b*b));\n    \n    return dist < LINE_WIDTH;\n}\n\n//Expect [-1,1]\nvec2 to_polar(vec2 uv){\n    return vec2(\n        atan(uv.y/uv.x), //degree\n        length(uv) //radius\n    );\n}\n\nvec2 to_cartesian(vec2 pc){\n    return vec2(\n        pc.y * cos(pc.x),\n        pc.y * sin(pc.x)\n    );\n}\n\n//Get point x of a star defined by n points around the origin,\n//with a certain radius.\nvec2 star_point(int total_points, int current_point, float radius, float rotation){\n    float angle = (2.0*PI*float(current_point))/float(total_points);\n    \n    vec2 point = vec2(\n        angle + rotation,\n        radius\n    );\n    \n    return to_cartesian(point);\n}\n\n//Get the color of a point if it happens to be on a star\n//defined by n points around the origin, of a specified radius.\n//Expect uv to be normalized [-1,1].\n//Returns a color if it collides with a star point, with nonzero alpha.\n//Returns black, with 0 alpha if no collision.\nvec4 star_collision(vec2 uv, int total_points, float radius, float rotation){\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    \n    for(int i=0; i<total_points; i++){\n        int target = (i+2)%total_points;\n        \n        vec2 p1 = star_point(total_points, i, radius, rotation);\n        vec2 p2 = star_point(total_points, target, radius, rotation);\n        \n        if(onLine(uv.x,uv.y,p1,p2)){\n            col = vec4(PALETTE[i%PALETTE_LENGTH], 1.0);\n            \n            float combined_dist =\n                distance(uv, p1) +\n                distance(uv, p2);\n            \n            col*=(1.0/pow(combined_dist*1.0, 2.0));\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = ((2.0)*fragCoord)/iResolution.xy - 1.0;\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // How large of a radius between each star rendered.\n    float dist_between_stars = MAX_RADIUS / float(NUM_STARS);\n    \n    float first_radius = iTime*EXPAND_RATE;\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    //Check each star in STARS for an intersection\n    for(int i=0; i<NUM_STARS; i++){\n        int cur_points = STARS[i];\n        float cur_radius = first_radius - (float(i)*dist_between_stars);\n        \n        if(cur_radius<0.0)\n            break;\n        \n        cur_radius = mod(cur_radius, MAX_RADIUS);\n        \n        float cur_rotation = mod(iTime*ROTATION_RATE, 2.0*PI);\n        if(i%2==1)\n            cur_rotation*=-1.0;\n        \n        vec4 result = star_collision(uv, cur_points, cur_radius,cur_rotation);\n        vec4 result2 = star_collision(uv, cur_points, cur_radius,(-1.0)*cur_rotation);\n        if(result.a > 0.0)\n            col = result.xyz;\n        if(result2.a > 0.0)\n            col = result2.xyz;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[719, 884, 915, 915, 939], [940, 940, 971, 971, 1006], [1007, 1007, 1038, 1038, 1076], [1078, 1125, 1173, 1173, 1625], [1627, 1643, 1666, 1666, 1754], [1756, 1756, 1783, 1783, 1860], [1862, 1950, 2033, 2033, 2217], [2219, 2496, 2573, 2573, 3162]], "test": "valid"}
{"id": "WlBcDz", "name": "My Very First Working Raymarcher", "author": "Zi7ar21", "description": "EPIC OH MY GOSH I DID IT", "tags": ["3d", "ray", "raymarch", "sphere", "raymarcher", "first"], "likes": 1, "viewed": 187, "published": "Public API", "date": "1594074818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCHES 256\n#define MAX_DISTANCE 8.0\n#define COLLISION_DISTANCE 0.01\n\n// Distance Estimator\nfloat sphere(vec3 point) {\n\tvec4 spheredef = vec4(0, 0, 2.5, 2);\n    \n    float sphereDist =  length(point-spheredef.xyz)-spheredef.w;\n    return sphereDist;\n}\n\n// March a Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*dO;\n        float dS = sphere(raypos);\n        dO += dS;\n        if(dO>MAX_DISTANCE || dS<COLLISION_DISTANCE) break;\n    }\n    \n    return dO;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade with Lights\nfloat shade(vec3 march) {\n    vec3 lightposition = vec3(0, 4, 0);\n    lightposition.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lighting = normalize(lightposition-march);\n    vec3 surfacenormal = normal(march);\n    \n    float diffuseshade = clamp(dot(surfacenormal, lighting), 0., 1.);\n    float distancesurf = raymarch(march+surfacenormal*COLLISION_DISTANCE*2., lighting);\n    if(distancesurf<length(lightposition-march)) diffuseshade *= .1;\n    \n    return diffuseshade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 45.0;\n\tvec3 camerapos = vec3(0.0, 0.0, 0.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Shaded Pixel Color\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    float diffuse = shade(march);\n    col = vec3(diffuse);\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 104, 130, 130, 263], [265, 280, 325, 325, 566], [568, 582, 608, 608, 827], [829, 850, 875, 875, 1328], [1330, 1330, 1387, 1411, 2084]], "test": "valid"}
{"id": "WlBcRm", "name": "low poly box (0 triangles)", "author": "samzanemesis", "description": "@samzanemesis\ninspired by a gag chain from twitter\nbox intersection code from https://www.shadertoy.com/view/ld23DV", "tags": ["box", "lowpoly", "joke"], "likes": 2, "viewed": 289, "published": "Public API", "date": "1593935984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @samzanemesis\n// inspired by a gag chain from twitter\n// box intersection code from https://www.shadertoy.com/view/ld23DV\n\nfloat cubeTex[] = float[](\n0.35,0.35,0.35,0.35,0.35,0.35,0.35,0.35,\n0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.35,0.35,0.35,0.35,0.35,0.5,\n0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,\n0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7);\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat sampleCubeTexture(vec2 uv)\n{\n    uv += 0.3;\n    uv /= 0.6;\n    return cubeTex[int(uv.x*8.0) + ( int(uv.y*8.0) * 8 ) ];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // rotate and translate box\t\n\tmat4 txi = translate( 0.0, 0.0, 0.0 ); \n    if(iMouse.w > 0.1)\n    {\n    \tmat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), -iMouse.x * 0.01 );\n    \trot *= rotationAxisAngle( normalize(vec3(1.0,0.0,0.0)), -iMouse.y * 0.01 );\n        txi*= rot;\n    }\n\tmat4 txx = inverse( txi );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat oid = 0.0;\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{\n\t\tpos = ro + h*rd;\n        if( mod(pos.z,1.0) < 0.02 || mod(pos.x,1.0) < 0.02 )\n        {\n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n        }\n\t}\n\n\t// trace box\n\tvec3 box = vec3(0.3,0.3,0.3) ;\n\tvec4 res = iBox( ro, rd, txx, txi, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\ttmin = res.x; \n\t\tnor = res.yzw;\n\t\toid = 2.0;\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.3);\n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // Floor\n\t\tfloat occ = 1.0;\n\t\tfloat mate = 1.0;\n\t\tif( oid<1.5 ) // plane\n\t\t{\n\t\t    mate = 0.4;\n\t\t}\t\t\n\t\telse // box\n\t\t{\n            // recover box space data (we want to do shading in object space)\t\t\t\n\t\t    vec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n            mate = abs(onor.x)*sampleCubeTexture(opos.zy) + \n                   abs(onor.y)*0.5 + \n                   abs(onor.z)*sampleCubeTexture(opos.xy);\n\n\t\t}\n\t\t\n        // material * lighting\t\t\n\t\tcol = vec3(mate);\n\t}\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 507, 584, 621, 1139], [1142, 1142, 1189, 1189, 1589], [1591, 1591, 1636, 1636, 1752], [1882, 1882, 1939, 1939, 3860]], "test": "error"}
{"id": "WlBcWc", "name": "fractal configurations", "author": "stb", "description": "Nothing fundamentally new about this shader. Just a circle inversion fractal, with a fisheye warp.", "tags": ["2d", "fractal", "invert", "circle", "warp", "ball", "fisheye", "inversion"], "likes": 12, "viewed": 135, "published": "Public", "date": "1595473509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tfractal configurations\n\t202 stb\n\tfree code is free\n\n\tUpdate: removed vestiges from previous code, cleaned up some other things.\n*/\n\n#define PI 3.14159265\n#define RPT(a) vec2(sin(a), cos(a))\n#define T .33 * iTime\n\nvec2 cInvMir(vec2 p, vec2 o, float r) {\n    return length(p-o)<r ? (p-o) * r * r / dot(p-o, p-o) + o : p;\n}\n\nvec3 map(vec2 p) {\n    return\n        .5 + .5 * vec3(\n            cos(dot(p, RPT(T))),\n            cos(dot(p, RPT(T+PI/3.))),\n            cos(dot(p, RPT(T-PI/3.)))\n       );\n}\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvoid mainImage(out vec4 fo, in vec2 fc) {\n\tvec2 res = iResolution.xy;\n\tvec2 p = .5 * (fc-res/2.) / res.y;\n\t\n    float ball = 1. - dot(p, p);\n    p /= ball;\n    p += RPT(.77*T);\n    \n    // fractal stuff\n\tfor(float i=0.; i<32.; i++) {\n    \tvec2 h = mix( hash22(vec2(i, floor(T))), hash22(vec2(i, floor(T+1.))), pow(smoothstep(0., 1., fract(T)), 8.));\n        p = cInvMir(.8*p, .5-h, .37);\n\t}\n    \n\tfo = vec4((ball*4.7-3.3) * (map(p*3.)-length(p)/4.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 256, 256, 324], [326, 326, 344, 344, 501], [625, 625, 646, 646, 781], [783, 783, 824, 824, 1239]], "test": "valid"}
{"id": "WlBcWd", "name": "log_polar_thingy_0", "author": "balkhan", "description": "toying with this space: https://www.osar.fr/notes/logspherical/", "tags": ["3d", "raymarching", "logpolar"], "likes": 10, "viewed": 110, "published": "Public", "date": "1595867725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by balkhan\n*/\n\n\n\n#define I_MAX\t\t400\n#define E\t\t\t0.0001\n#define FAR\t\t\t2.\n\n#define\tFUDGE\t\t1.\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\th;\nvec3\tvolumetric;\nvec2\tmous;\n\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n#define SCALE 2.0/PI\n\nfloat sdf(in vec3 pos3d)\n{\n    vec2 pos2d = pos3d.xz;\n    \n    float r = length(pos2d);\n    float ata = atan(pos2d.y, pos2d.x);\n    pos2d = vec2(\n        log(r)+iTime*-.25+sin(ata*.25+.2290035)*2.28\n        ,\n        iTime*.125+ata\n    \t);\n    pos2d *= SCALE;\n    pos2d = fract(pos2d) - 0.5;\n    float mul = r;///SCALE;\n    float ret = \n        (\n            mylength(vec2(pos2d.x, pos3d.y/mul+.0*(pos3d.y+.205)/(mul)))\n            - .1252125\n        ) * mul/SCALE\n        ;\n//    ret = max(ret, -(length(vec2(pos2d.x, (fract(pos3d.x*20./mul)-.50)/(20.)) )-.0120023));\n    ret = min(ret, (mylength(vec2(pos2d.x, (fract(pos3d.x*9./mul)-.50)/(9.)) )+.055-.050023*(1.42504041+pos3d.y*1./mul))*mul/SCALE);\n    \n    // middle tentacles\n    ret = min(ret, (mylength(vec2(\n        ( fract(pos2d.x*2.-.0)-.5)/2.\n        , \n                                  ( fract((pos3d.y/mul+-2.20485)*.25)-.5)/2.\n                                  //(fract(pos3d.x*3./mul)-.50)/(3.)\n                            ))-.005125050023*1.*(.1+pos3d.y/mul) )*mul/SCALE);\n\n    ret = min(ret, \n              \n              max(\n                  -(length(pos3d.zx)-.015)\n                  ,\n                  (mylength(vec2(\n        ( (pos2d.x*1.-.0)-.5*.0)/1.-.0\n        , \n                                  (.25+ fract((pos3d.x*1./mul+-0.020485*.0+-.125*.25*.0)*9.)-.5)/9.\n                                  //(fract(pos3d.x*3./mul)-.50)/(3.)\n                            ))\n                    +.05-.050023*-(-0.7050+pos3d.y*1./mul)*step(-.50, pos3d.y/mul))*mul/SCALE)\n                    //-.02512505125050023*1. )*mul/SCALE);\n              );\n    ret =\n        min(\n            ret\n            ,\n        (\n            mylength(vec2(pos2d.x, pos3d.y/mul+.5+.0*(pos3d.y+.205)/(mul)))\n            - .025252125\n        ) * mul/SCALE\n            )\n        ;\n    ret = max(ret, pos3d.y/mul+.05+.0*-.003125*-.750);\n    h += vec3(.69, .5, .34)/max(.01, ret*70000. + 40.501510);\n    return ret*1.*1.;\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    volumetric *= 0.;\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2\tR = iResolution.xy;\n\tvec2\tuv  = vec2((f.xy-.5*R.xy)/R);\n\tvec3\tdir = normalize(vec3(uv*vec2(1.,-1.), 1.));//camera(uv);\n    vec3\tpos = vec3(-.0, -.2105017501050*.450+.033, -2.0*.0-.2525045);\n    mous = (iMouse.xy-R*.5) / R;\n    \n\n    vec4\tinter = (march(pos, dir));\n//    col += volumetric;\n    if (inter.y <= E*1.)\n    {\n        col += smoothstep(.125, .9, 1.-.750*inter.w)*vec3(0.9, .75, .524);\n        /*\n        \n        vec3\tv = pos+(inter.w-E*0.)*dir;\n\t    vec3\tn = calcNormal(v, E*.1, dir);\n\t    vec3 ref = reflect(dir,n);\n        */\n        vec3\tv = pos+(inter.w-E*0.)*dir;\n        vec3\tn = calcNormal(v, E*.5, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(-100.0, 60.0, -50.0);\n\t\tvec3\tlight_color = vec3(.1, .4, .7);\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 5.);\n        col.xyz += light_color * (specular)+ diffuse * vec3(.51,.515, .53);\n\t    col += h*-.235025;  \n    }\n    c_out =  vec4(col, h.x);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tret = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = sdf(p);\n        dist.y += dist.x*FUDGE;\n        if ( dist.x < E || dist.y > FAR)\n            break;\n    }\n    ret.w = dist.y;\n    ret.y = dist.x;\n    return (ret);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    ret = max(p.x, max(p.y, p.z));\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    \n    ret = max(p.x, p.y);\n\n    return ret;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[484, 484, 510, 510, 2447], [2449, 2449, 2492, 2492, 3635], [3637, 3637, 3669, 3669, 4032], [4048, 4048, 4072, 4072, 4165], [4167, 4167, 4191, 4191, 4275], [4277, 4277, 4318, 4318, 4386], [4389, 4389, 4429, 4429, 4504], [4506, 4506, 4556, 4556, 4816], [4818, 4818, 4840, 4840, 5046]], "test": "error"}
{"id": "wlBcWt", "name": "raymarching simplex noise", "author": "CoolerZ", "description": "Raymarching throuhg simplex noise in 3d.", "tags": ["raymarching", "noise", "simplex", "pathtracing"], "likes": 5, "viewed": 109, "published": "Public", "date": "1595698609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nBased on http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\nThe pdf gives details and code for both perlin and simplex noise in Java.\n*/\n#define R2 .6\n#define A .5\n#define F 1.\n\nconst vec3[] grad = vec3[](\n    vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n\tvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n\tvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1)\n);\n\nconst int perm[] = int[](151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\nint hash(ivec3 p)\n{\n    return perm[p.x+perm[p.y+perm[p.z]]]%12;\n}\n\nvec3 skew(vec3 p)\n{\n    return p+(p.x+p.y+p.z)/3.;\n}\n\nvec3 unskew(vec3 p)\n{\n    return p-(p.x+p.y+p.z)/6.;\n}\n\nfloat simplex3d(vec3 xyz)\n{\n    vec3 ijk = floor(skew(xyz));\n    vec3 XYZ0 = unskew(ijk);\n\n    vec3 xyz0 = xyz - XYZ0;\n\n    // vec3 ijk1, ijk2;\n\n    vec3 ijk1 =\n        float(xyz0.x >= xyz0.y && xyz0.x >= xyz0.z)*vec3(1,0,0) +\n        float(xyz0.y >= xyz0.x && xyz0.y >= xyz0.z)*vec3(0,1,0) +\n        float(xyz0.z >= xyz0.x && xyz0.z >= xyz0.y)*vec3(0,0,1);\n\n    vec3 ijk2 =\n        float(xyz0.x < xyz0.y && xyz0.x < xyz0.z)*vec3(0,1,1) +\n        float(xyz0.y < xyz0.x && xyz0.y < xyz0.z)*vec3(1,0,1) +\n        float(xyz0.z < xyz0.x && xyz0.z < xyz0.y)*vec3(1,1,0);\n\n    /*\n    if(xyz0.x >= xyz0.y)\n    {\n        if(xyz0.y >= xyz0.z)\n        {\n            ijk1 = vec3(1,0,0);\n            ijk2 = vec3(1,1,0);\n        }\n        else if(xyz0.x >= xyz0.z)\n        {\n            ijk1 = vec3(1,0,0);\n            ijk2 = vec3(1,0,1);\n        }\n        else\n        {\n            ijk1 = vec3(0,0,1);\n            ijk2 = vec3(1,0,1);\n        }\n    }\n    else\n    {\n        if(xyz0.y < xyz0.z)\n        {\n            ijk1 = vec3(0,0,1);\n            ijk2 = vec3(0,1,1);\n        }\n        else if(xyz0.x < xyz0.z)\n        {\n            ijk1 = vec3(0,1,0);\n            ijk2 = vec3(0,1,1);\n        }\n        else\n        {\n            ijk1 = vec3(0,1,0);\n            ijk2 = vec3(1,1,0);\n        }\n    }\n\t*/\n\n    vec3 xyz1 = xyz0 - unskew(ijk1);\n    vec3 xyz2 = xyz0 - unskew(ijk2);\n    vec3 xyz3 = xyz0 - unskew(vec3(1,1,1));\n\n   \tivec3 IJK = ivec3(ijk) & 0xFF;\n    int gi0 = hash(IJK);\n    int gi1 = hash(IJK + ivec3(ijk1));\n    int gi2 = hash(IJK + ivec3(ijk2));\n    int gi3 = hash(IJK + ivec3(1,1,1));\n\n    float n0 = pow(max(R2 - dot(xyz0, xyz0), 0.), 4.)*dot(grad[gi0], xyz0);\n    float n1 = pow(max(R2 - dot(xyz1, xyz1), 0.), 4.)*dot(grad[gi1], xyz1);\n    float n2 = pow(max(R2 - dot(xyz2, xyz2), 0.), 4.)*dot(grad[gi2], xyz2);\n    float n3 = pow(max(R2 - dot(xyz3, xyz3), 0.), 4.)*dot(grad[gi3], xyz3);\n\n    return 32.*(n0+n1+n2+n3);\n}\n\nfloat noise(vec3 pos)\n{\n    float x0 = A*simplex3d(pos*F);\n    float x1 = A*A*simplex3d(pos*F*2.);\n    float x2 = A*A*A*simplex3d(pos*F*4.);\n    float x3 = A*A*A*A*simplex3d(pos*F*8.);\n    float x4 = A*A*A*A*A*simplex3d(pos*F*16.);\n\n    return 4.*(x0 + x1 + x2 + x3 + x4);\n}\n\n#define MAX_ITERS 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 4.;\n    // vec3 camera_pos = vec3(2.*cos(iTime), 0., 2.*sin(iTime));\n    // vec3 camera_pos += vec3(0., 0., 2.+sin(iTime));\n    // vec3 camera_lookat = vec3(0.);\n    vec3 camera_pos = vec3(0., 0., -iTime);\n    vec3 camera_lookat = camera_pos + vec3(0., 0., -1.);\n    vec3 camera_forward = normalize(camera_lookat - camera_pos);\n    vec3 world_up = vec3(0., 1., 0.);\n    vec3 camera_right = normalize(cross(camera_forward, world_up));\n    vec3 camera_up = normalize(cross(camera_right, camera_forward));\n    float focal_dist = 1.;\n    vec3 pixel_pos = camera_pos + focal_dist*camera_forward + uv.x*camera_right + uv.y*camera_up;\n\n    vec3 ray_o = camera_pos;// pixel_pos;\n    vec3 ray_d = normalize(pixel_pos - camera_pos);\n\n    vec3 acc = vec3(0.);\n    vec3 d = vec3(0.);\n\n    for(int i=0; i<MAX_ITERS; i++)\n    {\n        acc.x += noise(ray_o + d.x*ray_d);\n        acc.y += noise(ray_o + d.y*ray_d);\n        acc.z += noise(ray_o + d.z*ray_d);\n        d += vec3(0.01, 0.02, 0.04);\n        if(acc.x > 100.)break;\n    }\n\n    // vec3 col = vec3(simplex3d(vec3(uv, iTime)));\n    vec3 col = vec3(acc*.01);\n    // vec3 col = pow(acc*.05, vec3(4.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2246, 2246, 2265, 2265, 2312], [2314, 2314, 2333, 2333, 2366], [2368, 2368, 2389, 2389, 2422], [2424, 2424, 2451, 2451, 4349], [4351, 4351, 4374, 4374, 4625], [4650, 4650, 4705, 4705, 6001]], "test": "error"}
{"id": "WlBczG", "name": "Hyperbolic Poincare Tiling", "author": "Shane", "description": "A basic hyperbolic Poincare tiling example to provide a basis for anyone who'd like to make one.", "tags": ["escher", "truchet", "geometry", "art", "hyperbolic", "impossible", "poincare"], "likes": 39, "viewed": 607, "published": "Public API", "date": "1594822024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tHyperbolic Poincare Tiling\n\t--------------------------\n\n\n\tThis is a simpler hyperbolic polygonal tiling of the Poincare disc that\n    I've put together to accompany the more involved example I posted earlier.\n\n\tIn regard to the Poincare disc side of things, it was helpful to reference\n\tMLA, SL2C and STB's examples -- All authors have really nice work on here,\n\twhich is well worth the look. STB provided me with the link that he used\n    for his \"Hyperbolic Poincaré transformed\" example which enabled me to \n\tstreamline the setup code quite a bit. In fact, I'd imagine that once \n    someone like Fabrice Neyret gets a hold of it, you'll see a two tweet\n\tPoincare tiling. :)\n\n    Anyway, the code is very basic, but I've put in a reasonably thorough\n\texplanation, along with some useful links, so hopefully that'll be enough\n\tto give people a start.\n\n\tBy the way, the default setting is the standard triangle configuration\n\tyou'll see around. However, I've colored the triangle segments to match\n    ajoining ones, and put lines from the triangle center to the vertices to \n    produce the cube look. This is one of countless arrangements and patterns \n    that you may have seen around. I'm hoping others will put up a few more on \n    Shadertoy at some stage.\n\n\n\n    Poincare disc examples:\n\n    // The hyperbolic transformation itself is based on STB's example here,\n    // which I'm assuming was in turn based on a slide presentation by\n    // Vladimir Bulatov: http://www.bulatov.org/math/1001/index.html\n\t//\n    Hyperbolic Poincaré transformed - stb\n\thttps://www.shadertoy.com/view/3lscDf\n\n\n\t// Like everyone else, I love the following example. However, be warned that \n    // it involves complex geometry. :)  Seriously though, Mattz can come up with \n    // solutions to problems in a few minutes that have utterly confounded me for \n    // weeks.\n    //\n\tHyperbolic Wythoff explorer - mattz \n\thttps://www.shadertoy.com/view/wtj3Ry\n\n\n    // The shader that this particular one accompanies.\n    Hyperbolic Poincare Weave - Shane\n    https://www.shadertoy.com/view/tljyRR\n\n*/\n\n// Here's a more Earth tone-looking palette for people who require something\n// less cheery looking... OK, by \"people,\" I mean, me. :D\n//#define EARTH_TONES\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// P represents the number of polygon vertices, and Q is the number of \n// adjacent polygons to each vertex within the Poincare disc.\n//\n// For tilings to work, the following must be true: (P − 2)*(Q − 2)>4.\n//\n// For instance, 3 and 7 will work, but 4 and 4 will not.\n//\n// 3-7, 3-8, 4-5 , 5-4, 6-4, 7-3.\n//\nconst int N\t\t= 3;\t// Polygon vertices.\nconst int Q\t\t= 8;\t// Polygons meeting at a vertex.\n\n#define PI\t\t3.14159265\n#define TAU\t    6.28318531\n\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec3 initDomain(){\n    \n\t// There are quite a few ways to calculate the initial circular domain \n    // values, simply because there are several solutions to the same geometric \n    // problems, which is all this is. In fact, as geometric situations go,\n    // this is not a particularly difficult one to solve.\n    \n    // Essentially, you're going to be reflecting points about polygonal edges, \n    // so you'll need the distance from your initial circle center to that of \n    // the center of the circle that runs adjacent to the current domain edges in\n    // order to perform a hyperbolic reflection. You'll need the radius of that \n    // circle as well. The distance and radius will depend directly upon how\n    // how many edges your polygon has and how many adjacent polygons (the\n    // number that meet at a vertex point) there are.\n\n    // The following is some highschool level circle and triangle geometry to \n    // get the values we're after. Of course, none of this will mean much without \n    // some imagery to refer to. Shadertoy user, SLB, provided me with a link\n    // to a setup image that made life much easier. Without too much trouble,\n    // it's possible to use whatever trigonometric identities you want to \n    // arrive at the following. In fact, with more effort, I'm pretty sure it'd\n    // be possible to do better. Here's the link:\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n    //\n    // I also find the imagery on the following page helpful as well:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n   \n    float a = sin(PI/float(N)), b = cos(PI/float(Q));\n\tfloat d2 = cos(PI/float(N) + PI/float(Q))/a;\n\tfloat r2 = 1./(b*b/a/a - 1.);\n\t// Distance between adjacent polygon centers, the adjacent polygon radius,\n    // and the current polygon radius. We're assuming no negatives, but I'm \n    // capping things above zero, just in case.\n\treturn sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));  \n   \n\n}\n\n// Gloable polygon value. Not used here, but normally, it'd be the focus.\n//float gPoly;\n\n// Count variable, which is seful for all kinds of things. It's a measure\n// of how many iterations were required to get to the current polygon.\n// The center polygon would have a count of one, and should increase as we \n// radiate outwards.\nfloat count;\n\n\n// Hyperbolically reflecting the polygon across each of it's edges\n// via an inverse Mobius transform.\nvec2 transform(vec2 p, vec3 circ) {\n    \n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n     \n    float ia = (floor(atan(p.x, p.y)/TAU*float(N)) + .5)/float(N);\n    vec2 vert = rot2(ia*TAU)*vec2(0, circ.x);\n   \n    float rSq = circ.y*circ.y;\n    \n    // Circle inversion, which relates back to an inverse Mobius\n    // transformation. There are a lot of topics on just this alone, but \n    // the bottom line is, if you perform this operation on a point within\n    // the Poincare disk, it will be reflected. It's similar to the\n    // \"p /= dot(p, p)\" move that some may have used before.\n    vec2 pc = p - vert;\n    float lSq = dot(pc, pc);\n    \n    // If the distance (we're squaring for speed) from the current point to\n    // any vertex point is within the circle limits, hyperbolically reflect it.\n    if(lSq<rSq){\n         \n        p = pc*rSq/lSq + vert;\n        //p = rot2(TAU/float(N))*p; // Experimenting with rotation.\n        \n        // Maintaining chirality. I can thank MLA for this bit. If you \n        // don't do this, the coordinates will lose their polarity...\n        // I originally didn't do this. :D\n        //p.x = -p.x;\n        \n        // If we have a hit, increase the counter. This value can be useful\n        // for coloring, and other things.\n        count++;\n         \n    }\n    \n   \n    /* \n    // If you're after a CSG polygon to work with, the following should work.\n    // I've lazily set it to a global, but there'd be cleaner ways to work \n    // the calculations in.\n    float poly = (length(p) - circ.z);\n    poly = max(poly, -(length(pc) - circ.y));\n    gPoly = min(gPoly, poly);\n    */\n    return p;\n}\n\n\n// Very handy. I should write my own, but this works. I\n// rearranged it a bit, but it's the same function.\n//\n// Smooth Floor - Anastadunbar \n// https://www.shadertoy.com/view/lljSRV\nfloat floorSm(float x, float c) {\n    \n    float ix = floor(x); x -= ix;\n    return (pow(x, c) - pow(1.- x, c))/2. + ix;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// Mouse pointer inversion.\nvec2 mouseInversion(vec2 p){\n    \n    // Mouse coordinates.\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    // Hack for the zero case instance. If someone has a better way,\n    // feel free to let me know.\n    if(length(m) < 1e-3) m += 1e-3; \n    // A hack to stop some craziness occurring on the border.\n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n    \n    // Taking the mouse point and inverting it into the circle domain.\n    // Feel free to check some figures, but all will get mapped to \n    // values that lie within circle radius.\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m; \n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x; // Keep chirality. MLA does this. \n    \n    return p;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // Aspect correct coordinates: Actually, fragCoord is already in \n    // aspect correct form, so shifting and scaling is all that is\n    // required in this particular pixel shader environment.\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    /*\n    // Moving to the half plane model.\n    const float sc = 2.;\n    uv.y += sc/2. + 1.;\n    uv /= dot(uv, uv)/sc;\n    uv.y -= 1.; \n    */\n    \n    // Contracting things just a touch to fit the Poincare domain on \n    // the canvas.\n    uv *= 1.05;\n    \n     \n    // Hyperbolic the hyperbolic... I made that up, but it spherizes things \n    // a bit, which looks interesting.\n    //uv *= (1. + dot(uv, uv))/2.;\n   \n    \n    // Poincare coordinates.\n    vec2 p = uv;\n   \n\n    // A bit of mouse inversion and rotation to begin with. You'll\n    // see this a lot in various hyperbolic examples, and others.\n    p = mouseInversion(p);\n        \n    // Perform some free rotation.\n    p = rot2(iTime/16.)*p;\n    \n   \n    // Inversion count. It's used for all kinds of things, like \n    // random number production, etc.\n    count = 0.;\n    \n    // Globale polygon value. Not used here, but I'll use it when I make\n    // an extruded raymarched version.\n    //gPoly = 1e5;\n    \n    // Filling in the domain origin information: From left to right, it \n    // returns the distance between adjacent polygon centers, the adjacent \n    // polygon radius, and the current polygon radius. These values remain\n    // the same for all polygons throughout the hyperbolic plane, so this \n    // is all that's required to tile the disc.\n    vec3 domInfo = initDomain();    \n    \n    // Handling the imagery outside the Poincare circle domain by inverting or\n    // mirroring it back into the circle so that it shows up... or something\n    // to that effect... It's been a while. Either way, this is what you do\n    // if you want to see the outside pattern. :)\n    //\n    // By the way, if you want to get more of an intuitive feel for circle \n    // inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n    // https://www.youtube.com/watch?v=sG_6nlMZ8f4\n    if(length(p)> 1.) p /= dot(p, p); \n  \n    \n    // Performing multiple reflective inversions to fill out the disk. Due \n    // to the nature of the hyperbolic transform, the polygon tiles get \n    // smaller as you approach the outer disk, and never reach the edge. \n    // There are a bunch of proofs in complex analysis that illustrate\n    // this, but nothing shows it as well as a computer program. :)\n    // Drop the number of iterations and you'll see the process unfold.\n    //\n    // One more important thing I should mention is that there's a test\n    // within the transform function (if you're outside the domain) that \n    // would allow you to break early, but I'm bypassing that for \n    // simplicity. The function is cheap, so I'm letting it run through, \n    // but when speed is an issue, it should be considered.\n    for(int i=0; i<24; i++){\n        p = transform(p, domInfo);\n    }\n    \n    \n    // From here on in, it's just rendering code. None of it is difficult, or\n    // particularly interesting. Once you have the local cell coordinates,\n    // you can render whatever you want. In this case, I've produced some\n    // colors according to whatever polygon segment where in, some dark \n    // center to polygon vertex point lines, and some shading lines with a\n    // dark box -- The last two are based on the center to edge mid point \n    // lines. All very simple.\n  \n   \n    // Vertex lines and edge mid point lines, and points.\n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    \n    // Initial point set to the boundary of whatever circle we're in.\n    vec2 v0 = vec2(0, domInfo.z), m0;\n    \n    // I'm being lazy and looping around the polygon vertices and mid\n    // points to produce the line information. I could just as easily\n    // do the repeat polar thing. I also believe it's easier to read for\n    // those trying to decipher this.\n    for(int i = 0; i<N; i++){\n\n        // Mid edge points. Note that interpolating from one edge vertex\n        // to the other won't give the correct results due to the\n        // hyperbolic nature of the local space, so we're rotating between\n        // vertex points and setting the distance do the correct distance\n        // measured out in the initialization function.\n        m0 = (rot2(PI/float(N))*v0)*(domInfo.x - domInfo.y)/domInfo.z;\n         \n        // Center to vertex distances. \n        ln = min(ln, lBox(p, vec2(0), v0, .007));\n        // Center to edge mid point distances. \n        ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n        \n        // Vertex points.\n        pnt = min(pnt, length(p - v0));\n \n        // Rotating to the next vertex point.\n        v0 = rot2(TAU/float(N))*v0;\n    }\n    \n \n    // Setting a ring distance field, then using that to add more to the \n    // smoothing factor to alleviate aliasing around the borders. It's \n    // hacky, and no substitute for super sampling, but it works well \n    // enough here.\n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;//(count*count + 1.);//fwidth(shape);// \n\n \n    \n    // Setting the color, according to the polygon segment angle. It works\n    // well for this configuration, and others where the adjacent polyongs,\n    // Q are even, but breaks with odd Q, in which case you have to render in\n    // other lines.\n    float angl = mod(atan(p.x, p.y), TAU)*float(N)/TAU;\n    float triSeg = floorSm(angl, .15);  // Note the smooth floor function.\n    triSeg = (triSeg + .5)/float(N);\n\n    // IQ's versatile palette routine. It's one of my favorites.\n    #ifdef EARTH_TONES\n    vec3 oCol = .55 + .45*cos(triSeg*TAU/3.5 + vec3(0, 1, 2)/1.1);\n    #else\n    vec3 oCol = .55 + .45*cos(triSeg*TAU + vec3(0, 1, 2)).yxz;\n    #endif\n    \n    // Line pattern.\n    //float pat = clamp(sin(ln2*TAU*40.)*2. + 1., 0., 1.)*.4 + .8;\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n    \n    // Some subtle polygon segment (cube face) shading.\n    float sh = clamp(.65 + ln/domInfo.z*4., 0., 1.);\n    \n    // The background color. It looks interesting enough like this, but the lines\n    // give it additional depth.\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    // Rendering the lines.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    // The dark boxes on the inside of the ring only.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - .085)));\n\n    \n    // Polygon vertex points and central point.\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    \n    // A quick background image... Definitely needs more effort. :)\n    #ifdef EARTH_TONES\n    vec3 bg = vec3(.85, .4, .3);//.55 + .45*cos(TAU/6. + vec3(0, 1, 2)/1.2);\n    #else\n    vec3 bg = vec3(.4, .2, 1);\n    #endif\n    bg *= .3*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n   \n    // Putting in the outer ring. I did this in a hurry, so you could do it in\n    // fewer steps for sure. Think of it as a lesson on what not to do. :D\n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    /*\n    // Dial markings -- Hours and seconds, for whatever reason. Hmmm, might be too much,\n    // so I'm leaving it out. Yet, another five minutes I'll never get back. :D\n    uv = rot2(iTime/16.)*uv; float ang = atan(uv.x, uv.y)/TAU;\n    float dial = abs(fract(ang*12.) - .5)*2. - .025;\n    dial = min(abs(fract(ang*60.) - .5)*2. - .05, dial);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., max(abs(cir - 1.) - .03, dial)))*.95);\n    */\n    // Shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n\n  \n    // Toning things down ever so slightly. \"1. - exp(col*a)\" is used as a toning\n    // device... I'm toning things down a little bit. I prefer not to post process\n    // too much, but sometimes, it can help tie things together when the\n    // background tones don't match the foreground, and so forth. Sometimes, \n    // multiplying everything by a single subtle sepia color, or whatever can help\n    // tie things together overall. Anyway, comment the line out, and you'll see\n    // that it tones down the highlights just a little.    \n    col = mix(col, 1. - exp(-col), .35);\n    \n    // Rough gamma correction, then present to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2252, 2285, 2307, 2307, 2365], [2824, 3292, 3310, 4902, 5299], [5648, 5751, 5786, 6054, 7610], [7613, 7797, 7830, 7830, 7919], [7921, 7952, 7985, 7985, 8072], [8074, 8313, 8358, 8358, 8521], [8523, 8551, 8579, 8610, 9336], [9339, 9339, 9394, 9602, 18445]], "test": "valid"}
{"id": "WlByDR", "name": "Soundsystem Led Show", "author": "julianlumia", "description": "proof of concept sketch to test some ideas for a potential lighting system in my speakers", "tags": ["light", "disco", "soundsystem"], "likes": 9, "viewed": 210, "published": "Public", "date": "1594060673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define COMPILMENTARYCOLORS 1\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//square wave function\nfloat funcs( in float x,float speed )\n{\n    \n    x *= speed;\n    \n    float h = fract(x)-0.5;\n    \n    float s = -sign(h);\n    \n    return s;\n}\n\n\n\nuniform vec2 u_resolution;\nuniform float u_time;\n//book of shaders\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n//mapping function from bigwings\nfloat map(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\n\n//--------------voronoi noise\n\n\n\nvec2 N22(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y*a.z));\n}\n\nfloat voronoi(vec2 uv){\n\n\t\n    float m = 0.;\n\t//float cellIindex = 0.;\n    float minDist = 10.;\n    float t = iTime;\n  //  float cellamound = 50.;\n   \n      //  uv*=scale;\n       vec2 gv = fract(uv)-.5;        \n       //create id system for every vekk\n       vec2 id = floor(uv);\n       vec2 cid = vec2(0);\n\t\tfor(float y =-1.; y<=1.; y++){\n            for(float x =-1.; x<=1.; x++){\n                vec2 offs = vec2(x,y);\n                \n                vec2 n = N22(id+offs);\n\t\t\t\tvec2 p = offs+sin(n*t)*.5; \n                float d = length(gv-p);\n                         m+= smoothstep(.05,.1,d);\n\n                  if(d<minDist){\n        minDist= d;\n        cid = id+offs;\n                  }\n              }     \n           }\n\n        \n       return minDist;\n        \n\n\n}\n\n\nfloat ov(vec2 p) {\n    float v = 0.0;\n    float a = 0.4;\n    for (int i = 0;i<2;i++) {\n        v+= voronoi(p)*a;\n        p*=2.0;\n        a+=0.5;\n    }\n    return v;\n}\n\n//------------------\n\n\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\n vec3 subp;\nfloat GetDist(vec3 p) {\n float the = sin(p.y*.1+iTime*.5)*.5+0.;\n //p.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n      the = sin(p.x*.5+iTime*1.)*.15+0.;\n\n   //  p.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n      the = (sin((p.x*.05)+iTime*.2)*.2+0.);\n\n     //p.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n\n vec3 p7 = p;\n float gap = 4.2;\n p.x = abs(p.x)-2.3;\n p.x = abs(p.x)-2.3;\n p.x = abs(p.x)-2.3;\n vec3 p6 = p;\n float d;\n gap = 3.;\n p.x = abs(p.x)-1.1;\n float plane2 = dot(p-vec3(1,1,1),normalize(vec3(0.,0.,0.2)))-0.;\n p -= vec3(-3.,-0,-0.); \n vec3 p4 = p;  \n the = 2.7;\n p4 -= vec3(3,1.73,-1.4);\n p4.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float box7 = sdBox(p4-vec3(0,1,0), vec3(1,0.02,.6));\n vec3 p5 = p;  \n the = 2.6;\n p5 -= vec3(3.,0.73,-.9);\n p5.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n p5.x = abs(p5.x)-.5;\n float box8 = sdBox(p5-vec3(0,1,0), vec3(0.05,1.3,.5));\n vec3 p3 = p;  \n the = 2.5;\n p3 -= vec3(3,1.,-.5);\n p3.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float box6 = sdBox(p3-vec3(0,1,0), vec3(1,0.05,.4));\n\n    //\n    ///led hogscoops bar\n    float lsub = sdBox(p3-vec3(0,1.0,0.5), vec3(1.,0.05,.1));\n\t\n    float hsub = sdBox(p3-vec3(0,-.2,1.), vec3(1.,0.05,.1));\n\n\n    \n    vec3 p2 = p;  \n     the = 2.2;\n\tp2 -= vec3(3,2.6,-0.6);\n    p2.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    float box5 = sdBox(p2-vec3(0,1,0), vec3(1,0.05,1.2));\n float x = sdCapsule(p2,vec3(0,2.,0.),vec3(0,1.2,-.2),.8);\n    \n   \n    \n    vec3 conusp = p2;\n         conusp += vec3(0.,-0.3,0.);\n    \n     float y = sdCapsule(conusp,vec3(0,2.,0.),vec3(0,1.,-0.2),.8);\n     conusp += vec3(0.,abs(sin(iTime))-0.,0.);\n float z = sdCapsule(conusp,vec3(0,4.,0.),vec3(0,1.,-0.2),.7);\n\n    \n    \n    //buitenkant sub\n    float box2 = sdBox(p-vec3(3,1,0), vec3(1,2,2));\n\n    // led y as sub\n    \n     subp = p-vec3(3.,1,.8);\n   // spherepos = subp;\n    subp.x = (abs(subp.x)-0.85); \n    \n  //  subp+=vec3(0.02,0,.1);\n    //spherepos = subp;\n   // subp.x = (abs(subp.x)); \n    \n        float ysubbox2 = sdBox(subp-vec3(0.02,0,.1), vec3(.08,2.,.1));\n\n   // subp.x = (abs(subp.x)+0.3); \n        float ysub = sdBox(subp+vec3(0.05,0,.1), vec3(.08,2.,.01));\n\n    \n    \n    x = max(min(z,-(max(x,(y)))),(box5));\n\n\tbox2 = abs(box2)-0.05;\n    float op2 =  max(plane2, min(box8,box2));\n    \n\n    \n    \n    \n    \n    \n    d = min(op2,min(x,(min(box7,box6))));\n    \n    \n    \n    \n    \n    \n    \n    p = p6;\n    p += vec3(2,0,0);\n      float boxkick = sdBox(p-vec3(2,4.,0), vec3(1.8,0.8,1.1));\n          float frontkick = sdBox(p-vec3(2,4.,.9), vec3(1.8,0.8,.03));\n          float bafflekick = sdBox(p-vec3(2,4.,0.8), vec3(0.2,0.8,.5));\n          float bafflemiddle = sdBox(p-vec3(2,4.,0.45), vec3(0.2,0.02,1.5));\n\n       the = 2.5;\n    p.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n     p += vec3(-2,4.9,1.9);\n      p.x =abs(p.x)-1.;\n        conusp = p;\n         conusp += vec3(0.,-1.,1.);\n    \n      y = sdCapsule(conusp,vec3(0,1.,-0.),vec3(0,0,0.5),.7);\n \n          x = y;\n      conusp += vec3(0.0,-1.,.6);\n      y = sdCapsule(conusp,vec3(0,.35,-0.),vec3(0,1,.0),.6);\n    \n    \tboxkick = abs(boxkick)-0.05;\n    \tboxkick = max(plane2,min(max(-bafflekick,max(frontkick,-max(x,-y))),min(bafflemiddle,boxkick)));\n        d = min(d,boxkick);\n    \n      p = p6;\n      float midbox = sdBox(p-vec3(0,6.,0), vec3(.9,1.,1.1));\n    \n          float between = sdBox(p-vec3(0,6.,-0.4), vec3(.3,1.,.02));\n\n    \n    vec3 bendp = p; \n    bendp.x = abs(bendp.x)-0.2;\n    bendp += vec3(-.3,-6.,-0.4);\n    the = sin(bendp.x*.7+0.4);\n    bendp.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n          float bafle1 = sdBox(bendp, vec3(.01,1.,.7));\n\n        \tmidbox = abs(midbox)-0.03;\n     p += vec3(-0,-6.,.5);\n          p.y =abs(p.y)+2.8;\n\n       the = 2.5;\n    p.zy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n     \n\n   p += vec3(-0,4.,1.9);\n        conusp = p;\n     \n         conusp += vec3(0.,-1.,1.);\n \n      y = sdCapsule(conusp,vec3(0,1.,0.),vec3(0,0,1.5),.35);\n x = y;\n  \n    \n\n            d = max(plane2,min(d,min(bafle1,min(midbox,max(between,-x)))));\n\n\n    p = p6;\n vec3 bendp2 = p;\n      bendp2.x = abs(bendp2.x)+.02;\n\n    \tbendp2 -= vec3(.3,7.5,.6);\n\n    the = sin(bendp2.x*1.3+0.4);\n    bendp2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n          float bafle2 = sdBox(bendp2, vec3(.01,.4,.7));\n    \n    p += vec3(0,-7.1,-1);\n      float topbox = sdBox(p-vec3(0.,0.4,0.), vec3(.8,.4,2.));\n topbox = abs(topbox)-0.06;   \n p = p7;\n float sphereg = (length(p+vec3(sin(iTime)*11.,sin(iTime*1.)*3.+3.,(cos(iTime))*12.))-1.);\n float ground = sdBox(p-vec3(0,6.,0), vec3(10,7.,15));\n float sphereg3 = (length(p+vec3(0.,sin(iTime)*0.+0.,0.))-12.);\n vec3 grondp = p;       \n gap = .8;\n grondp.y = mod(grondp.y + gap,2.0 * gap) - gap;\n float ground2 = sdBox(grondp-vec3(0,-.6,0), vec3(14.,.2,14));\n p.x = abs(p.x)-3.3;\n p.x = abs(p.x)-3.3;\n p.x = abs(p.x)-3.3;\n float sphereg2 = sdBox(p+vec3(0.5,-3.5,0.), vec3(.1,.5,0.1));\n float sphereg24 = sdBox(p+vec3(2.,-0.5,0.), vec3(.1,.5,0.1));\n float sphereg4 = sdBox(p+vec3(1.,(sin(iTime)*0.5+2.)+-8.5,-0.1), vec3(.1,.5,0.1));\n     float bkgrnd = sdBox(p+vec3(1.,-3.5,-5.), vec3(.1,.5,0.1));\n\n d = min(d,max(plane2,min(topbox,bafle2)));\n d = min(sphereg2,d);\n ground =max(sphereg3,-ground);\n    \n    \n///ledlampen\n  //  ysubbox2\n        d = min(ysubbox2,d); \n        d = min(lsub,d);\n      d = min(ysub,d);\n      d = min(hsub,d);\n    \n    \n    \n    \n   g1 +=4./(0.06+pow(abs(  y  ),2.));\n  \n\n    \n    \n    \n d = min(d,ground);\ng4 +=4./(0.006+pow(abs(lsub),sin(iTime)+1.));\n// g3 +=.05/(.2+abs(sphereg2*sphereg2));\n //g3 +=1./(.4+abs(ysub*ysub));\n\n   \n g3 +=4./(0.06+pow(abs(ysub),1.));\n   \n //  g2 +=1./(.0001+pow(abs(hsub),2.));\n    \n    \n //g4 +=1./(.005+pow(abs(ysub),(abs(sin(p.x*1.+iTime))*1.)));\n //g3 +=.05/((sin(p7.x*0.01+iTime*1.)*0.5+0.5)*0.5+sphereg24*sphereg24);\n    //g2 +=1./((sin(p7.x*0.1+iTime*2.)*0.5+0.5)*0.5+pow(abs(bkgrnd),4.));\ng3 +=.01/(.01+pow(abs(z),5.));\n\n return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS*1.;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0., 1.5, -1.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*.01, l);\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\nconst float PI = 3.14159265359;\n\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n        ao += (l - max(GetDist( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = 0.005;\n    float shadow = 1.0;\n    while(d < maxDist)\n    {\n        float t = GetDist(r0 + d * rd);\n        if(t < 0.004) return 0.0;\n        d += t;\n        shadow = min(shadow, 30.0 * (t / d));\n    }\n    return shadow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 colout = vec3(0);\n    \n    vec3 ro = vec3(0, 2.5, 13.);\n\n    vec3 rd = R(uv, ro, vec3(1,4.0,-10.), 1.);\n\n    float d = RayMarch(ro, rd);\n    vec3 p;\n    if(d<MAX_DIST) {\n\n    \t p = ro + rd * d;\n   \n\n    \tfloat dif = GetLight(p);\n   colout += vec3(dif);\n                              vec3 n = GetNormal(p.xyz);\n\n         float a = ambientOcclusion(p,n, .5, 1.);\ncolout *= a+2.;\n        \n   //       col = mix( col, vec3(1.0,1.0,0.0),\n   //     (1.0-smoothstep(0.0,0.01,abs(length(uv-vec2(0.0,0.5))-0.35)))*\n    //    texelFetch( iChannel0, ivec2(KEY_UP,1),0 ).x);\n \n        \n        \n  //---------------------------      \n        \n           \n    \n ///scaling\n const float scaleFactor = 5.0;\n const float invScaleFactor = 1.0 / scaleFactor;\n\n vec2 uv4 = floor(uv * scaleFactor) * invScaleFactor;\n  \n vec2 m = iMouse.xy/iResolution.xy;\n vec4 col5;\n vec2 uv2 = uv;\n //color logic\n  vec3 color = vec3(0.0);\n  if(  m.x > 0.0 && m.x < 1. && m.y > .0)\n   {\n     m.y =abs(m.y-0.5)*2.+0.;\n    }\n  float h = fract(abs(sin(iTime*0.1)));\n  float s = abs(sin(iTime*0.1));\n  float b = abs(m.y)*1.;\n\n vec4 fout;\n float uvy = .5;   \n vec3 col;\n vec3 col2;\n vec3 col3;\n \n col = vec3(  hsb2rgb(vec3(h,s,1.)));  \n\n    \n// float saturation = s;\n //x is this is the the harmonic seperation value of the 2nd and 3rd color in relation to the the 1st one (most left)\n //x = 0. is just the comlimentary color and x=0.35 would form a triangular relation ship on the color spectrum)\n //(more obvious if the saturation is set to 1. instead of the sinewave ) \n // set COMPILMENTARYCOLORS to 0 to turn of the complimentary relationship\n \n //controllllls\n //zet chase aan en uit , 1 = uit   \n float  chase =0.;   \n float chasespeed = .5; \n \n //color divergance   \n float x=0.25;\n \n //external saturation\n float saturation = 1.;\n col *= saturation;\n    \n    \n //gating logic========================   \n if(col.x > col.y && col.x > col.z){\n  col2= vec3(col.x-x,col.y+x,col.z);  \n   if(COMPILMENTARYCOLORS == 1)\n    {\n     col2 = vec3(map(0.,1.,1.,0.,col2.x),map(0.,1.,1.,0.,col2.y),map(0.,1.,1.,0.,col2.z));\n    }\n }\n  \n if(col.x > col.y && col.x > col.z){  \n  col3= vec3(col.x-x,col.y,col.z+x);    \n   if(COMPILMENTARYCOLORS == 1)\n    {\n     col3 = vec3(map(0.,1.,1.,0.,col3.x),map(0.,1.,1.,0.,col3.y),map(0.,1.,1.,0.,col3.z));\n    }\n }\n    \n if(col.y > col.x && col.y > col.z){\n  col2= vec3(col.x+x,col.y-x,col.z);  \n  if(COMPILMENTARYCOLORS == 1)\n   {\n    col2 = vec3(map(0.,1.,1.,0.,col2.x),map(0.,1.,1.,0.,col2.y),map(0.,1.,1.,0.,col2.z));\n   }  \n}\n    \n if(col.y > col.x && col.y > col.z){\n  col3= vec3(col.x,col.y-x,col.z+x);    \n  if(COMPILMENTARYCOLORS == 1)\n   {\n    col3 = vec3(map(0.,1.,1.,0.,col3.x),map(0.,1.,1.,0.,col3.y),map(0.,1.,1.,0.,col3.z));\n   }\n }    \n    \n if(col.z > col.x && col.z > col.y){\n  col2= vec3(col.x,col.y+x,col.z-x);\n  if(COMPILMENTARYCOLORS == 1)\n   {\n    col2 = vec3(map(0.,1.,1.,0.,col2.x),map(0.,1.,1.,0.,col2.y),map(0.,1.,1.,0.,col2.z));\n   }\n }\n    \n if(col.z > col.x && col.z > col.y){\n  col3= vec3(col.x+x,col.y,col.z-x);   \n  if(COMPILMENTARYCOLORS == 1)\n   {\n    col3 = vec3(map(0.,1.,1.,0.,col3.x),map(0.,1.,1.,0.,col3.y),map(0.,1.,1.,0.,col3.z));        \n   }\n }  \n    \n\n //OUTPUT TO SCREEN===============\n\n  col = vec3(col.x,col.y,col.z); \n //movement pattern\n  col *= sin(abs(uv4.x-0.15)*2.+-iTime*2.)*1.;\n   //   col = abs(col);\n  //CHASE pattern\n  if(funcs(iTime+.0,chasespeed)==1.){\n  // col *= chase;\n   }\n      col *= sin(iTime+1.)*0.5+0.5;\n\n    // fout = vec4(col,1.);   \n \n \n\n  //movement pattern\n // col2 = vec3(x);\n  vec3 b1 = vec3(0.0);\n  vec3 a1 = vec3(col2);\n   col2 = vec3(mix(a1, b1, smoothstep(0.0, 1., ov(uv*3.))));        \n       \n  //CHASE pattern  \n  if(funcs(iTime+.33,chasespeed)==1.){\n  //col2 *= chase;\n  }\n    col2 *= sin(iTime+2.)*0.5+0.5;\n    \n    \n    \n    \n    \n// else if(  uv.x > 0.66 && uv.x < 1. && uv.y < uvy && uv.y > 0.0)\n// {\n   // uv.x-=.83;\n   // uv.y-=.25;\n   \t //make it less circulair\n   \t //  uv *= abs(uv-0.)*1.;\n    float\tangle = atan(0.5, 0.6);\n    uv *= 1.;\n    float \tl = length(uv*1.);\n    l= sin((angle*1. - iTime*1.) +l)  ;\n\tcol3*=abs(l);\n     \n     \n  //CHASE pattern  \n     if(funcs(iTime+.66,chasespeed)==1.){\n   //  col3 *= chase;\n     }\n\n          col3 *= sin(iTime+3.)*0.5+0.5;\n\n\n  //fout = vec4(col3,1.0);\n// }\n  \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n   //------------------------------------     \n        \n        colout *=g2*vec3(0.01)*vec3(0,0.,0.)*.10+.15;\n\t\t//col +=g4*vec3(0.002)*vec3(.5)*0.1;   \n        \n        colout+=g3*vec3(0.1)*vec3(mix(col3,col2,sin(iTime*0.5)*0.5+0.5))*.10+.15;   \n colout+=g1*vec3(0.01)*vec3(mix(col3,col2,0.))*.10+.15;;   \n colout+=g4*vec3(0.01)*vec3(col)*.10+.15;   \n\n   vec3 sky = vec3(0., 0., 0.);\ncolout *= mix(sky, colout, 4./(d*d/1./.2*.05+1.0));    \n\n   \n    }\n                     vec3 sky = vec3(1., 1., 1.);\n//col *= mix(sky, col, ./(d*d/.1/.1*1.+1.)); \n      \n // col*=5.;\n  colout=smoothstep(0.0,1.50,colout);\n  colout=pow(colout, vec3(0.4545));\n    \n     \n    \n    \n    fragColor = vec4(colout,1.0);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 102, 141, 141, 245], [298, 316, 342, 342, 772], [774, 848, 874, 874, 1106], [1109, 1142, 1198, 1198, 1231], [1267, 1267, 1285, 1285, 1420], [1422, 1422, 1445, 1445, 2199], [2202, 2202, 2220, 2220, 2368], [2463, 2463, 2482, 2482, 2558], [2560, 2560, 2601, 2601, 2692], [2694, 2694, 2744, 2744, 2912], [2914, 2914, 2965, 2965, 3275], [3277, 3277, 3308, 3308, 3376], [3378, 3378, 3407, 3407, 3488], [3554, 3554, 3577, 3577, 9566], [9568, 9568, 9602, 9602, 9816], [9818, 9818, 9842, 9842, 10032], [10034, 10034, 10058, 10058, 10283], [10285, 10285, 10327, 10327, 10522], [10581, 10581, 10602, 10602, 10720], [10722, 10722, 10754, 10754, 10857], [10858, 10858, 10903, 10903, 10995], [10997, 10997, 11081, 11081, 11475], [11479, 11479, 11526, 11526, 11763], [11766, 11766, 11823, 11823, 17222]], "test": "error"}
{"id": "WlByDW", "name": "Confusion", "author": "julianlumia", "description": "I made a thing..", "tags": ["2d"], "likes": 8, "viewed": 83, "published": "Public", "date": "1594306090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y*.2;    \n    float dp = dot(uv,uv);\n\tuv /= dp;\n    uv.x=sin(uv.x-1.5);\n    uv *= .5;\n    float a = atan(uv.y,uv.x);\n\tfloat t = iTime*.3;\n    float r2 = max( .0,  abs(sin(t*.5))*6. - length(uv) );\n    t += r2 * r2 *cos(r2+t )+a *1.;        \n    uv *= mat2( cos(t), sin(t), cos(t), cos(t) );\n    vec3 col = .1 + cos(uv.y *(cos(t)*2.+0.5) +t) *sin(iTime+uv.yxy);    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 513]], "test": "valid"}
{"id": "wlByRV", "name": "Textured Tunnel", "author": "voax", "description": "stripped down version of https://www.shadertoy.com/view/XllBRB\nadded some parameters; mouse controls curvature/squareness", "tags": ["3d", "tunnel", "textured", "curved"], "likes": 10, "viewed": 133, "published": "Public", "date": "1594826580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed \t = 4.0;\nfloat squareness = 1.0;\nfloat swirl\t\t = 0.2;\nfloat fadeout\t = 1.0;\nvec2 curvature \t = vec2(2.0, 2.0);\nvec3 bg \t\t = vec3(1,1,1);\n\n#define EPS 0.005\n#define FAR 40.0 \n#define PI 3.14159265359\n#define T iTime\n#define NTILES 1.0\n\nstruct Scene {\n    float t;\n    vec2 walluv;\n    vec2 uvr;\n};\n    \nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nvec3 path(float t) {\n    vec2 ab = vec2(sin(t * PI / 16.0 + 1.5707963 * 1.0),\n        \t\t   cos(t * PI / 16.0));\n    return vec3(ab * curvature, t);    \n}\n\nScene map(vec3 rp) {\n    rp.xy -= path(rp.z).xy;\n    rp.xy = rot(rp.z * swirl) * rp.xy;\n    \n    float r1 = length(rp.xy);\n    float r2 = pow( pow(rp.x*rp.x,4.0) + pow(rp.y*rp.y,4.0), 1.0/8.0 );\n    float r = mix(r1,r2, squareness);\n    \n    float a = atan(rp.y,rp.x);\n    \n    vec2 uv = vec2(a / PI, rp.z);\n    vec2 uvr = vec2(abs(a) / PI, rp.z);\n\n    float tun = 1.7 - r;\n\n    return Scene(tun, uv, uvr);\n}\n\nScene march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    vec2 walluv = vec2(0.0);\n    vec2 walluvr = vec2(0.0);\n    vec2 cellid = vec2(0.0);\n    float edge1 = 0.0;\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        Scene scene = map(rp);\n        if (scene.t < EPS || scene.t > FAR) {\n            walluv = scene.walluv;\n            walluvr = scene.uvr;\n            break;\n        }\n        t += scene.t;\n    }\n    \n    return Scene(t, walluv, walluvr);\n}\n\nvec3 colour(Scene scene) {\n    return textureGrad(iChannel0, scene.walluv, dFdx(scene.uvr), dFdy(scene.uvr)).xyz; // uvr: https://www.iquilezles.org/www/articles/tunnel/tunnel.htm\n}\n\nvoid setupCamera(vec2 fragCoord, out vec3 ro, out vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float ct = T * speed;\n\n    vec3 lookAt = vec3(0.0, 0.0, ct);\n    ro = lookAt + vec3(0.0, 0.0, -5.0);\n\n    lookAt.xy += path(lookAt.z).xy;\n    ro.xy += path(ro.z).xy;\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iMouse.z > 0.5) {\n     \tcurvature *= iMouse.x/iResolution.x;\n        squareness *= iMouse.y/iResolution.y;\n    }\n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n\n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n\n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        pc = colour(scene) / (scene.t * 0.5);\n        mint = scene.t;\n    }\n    else\n        pc = bg;\n    \n    pc = mix(pc, bg, fadeout * pow(scene.t/FAR, 2.0));\n        \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlByRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 333, 333, 379], [380, 380, 400, 400, 462], [464, 464, 484, 484, 617], [619, 619, 639, 639, 1027], [1029, 1029, 1060, 1060, 1509], [1511, 1511, 1537, 1537, 1692], [1694, 1694, 1754, 1754, 2236], [2238, 2238, 2293, 2293, 2818]], "test": "error"}
{"id": "WlByRW", "name": "Tuto: Jacobians and undistortion", "author": "FabriceNeyret2", "description": "Distorted parameterization (checker) where red circles are drawn.\nJacobian matrix store the local distorted frame. Assuming distortion locally flat:\n-> U*inv(J) is back to undistorted frame : green circles.\ndet(J) shows compression of distortion.", "tags": ["screenspace", "fwidth", "tuto", "jacobian"], "likes": 24, "viewed": 703, "published": "Public API", "date": "1593775674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- Computing Jacobian to cancel distortions\n// See also: managing discontinuity when computing hardware derivatives https://www.shadertoy.com/view/WlScRW\n\n#define Circle(U,r) smoothstep(50./R.y,0., abs(length(U)-r)-.02 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y, I, L;                  // normalized coordinates\n    \n    U += .5*U*mat2(cos(2.*U+iTime),sin(2.*U-iTime));   // distorted coordinates \n    U *= 4.; \n    \n    I =floor(U); L = 2.*fract(U)-1.;                   // draw distorted checker\n    O = vec4 (.4*mod(I.x+I.y,2.) );\n    \n    O.r += Circle(L,.4);                               // draw circle in distorted space\n    \n    mat2 J = transpose(mat2(dFdx(U),dFdy(U))) *R.y/8.; // the Jacobian store the local distorted frame\n    L *= inverse(J);                                   // undistort by applying the inverse transform\n // or if you prefer right-multiplying matrices :\n // mat2 J = mat2(dFdx(U),dFdy(U)) *R.y/8.;            // the Jacobian store the local distorted frame\n // L = inverse(J)*L;                                  // undistort by applying the inverse transform\n    O.g += Circle(L,.4);                               // draw circle in undistorted space\n    \n    O.b = ( .5+.5*determinant(J) ) *.6;                // det(J) shows compression in distortion\n  //O.b = length(vec4(J))/3.;\n\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 264, 264, 1383]], "test": "error"}
{"id": "WlByzc", "name": "Line Integral Sinusoid 3D", "author": "spalmer", "description": "extending back to 3D but visualizing every ray as a trace through fog as density; equivalent to blackle's original toy but with my math.  I'm still not happy with how it gets scaled and visualized, but it's working well enough I'll show it.", "tags": ["fog", "analytic", "integral", "calculus", "lineintegral"], "likes": 6, "viewed": 107, "published": "Public", "date": "1595009041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I simply stole blackle's work from https://shadertoy.com/view/3lByRK\n// and changed to use my method instead.  Most of credit to blackle.\n\n// see 1D toy at https://shadertoy.com/view/3lScz3 where the math was derived\n// see 2D toy at https://shadertoy.com/view/WtScRc\n\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// and so has Sean L. Palmer.\n\nconst float pi = acos(-1.);\n\n#if 1\n// my way\n/**/\n// the sinusoidal function we're working with, F(x) := sin(x)^2; in Maxima notation.\nfloat F(float x)\n{\n    float s = sin(x);\n\treturn s*s; // s^2\n}\n// in 3D we don't show or evaluate the F function directly\nfloat F(vec3 p)\n{\n    //return F(p.y) * F(p.z);\n    return F(p.x) * F(p.y) * F(p.z);\n    //return F(p.x) + F(p.y) + F(p.z);\n    //return F(p.x) + F(p.y);\n    //return F(p.x);\n\t//return dot(vec3(F(p.x),F(p.y),F(p.z)), vec3(1,0,1));\n    //return F(p.x) * F(p.y) * F(p.z); // ?\n}\n// ok maybe we do\n/**/\n/*\n(%i0) F(p) := sin(p)^2;\n(%o0)\tF(p):=sin(p)^2\n(%i1) integrate(F(p_x), p_x, a_x, b_x)\n\t+ integrate(F(p_y), p_y, a_y, b_y)\n\t+ integrate(F(p_z), p_z, a_z, b_z);\n(%o1)\t-(sin(2*b_z)-2*b_z)/4-(sin(2*b_y)-2*b_y)/4-(sin(2*b_x)-2*b_x)/4\n\t\t+(sin(2*a_z)-2*a_z)/4+(sin(2*a_y)-2*a_y)/4+(sin(2*a_x)-2*a_x)/4\n(%i2) trigsimp(%o1);\n(%o2)\t-(sin(2*b_z)-2*b_z+sin(2*b_y)-2*b_y+sin(2*b_x)-2*b_x\n\t\t -sin(2*a_z)+2*a_z-sin(2*a_y)+2*a_y-sin(2*a_x)+2*a_x)/4\n*/\n// Maxima does integrate(F(x), x, a, b); producing (+2*b-2*a-sin(2*b)+sin(2*a))/4\n// compute line integral of F(x) with x ranging between a and b\nfloat A(float a, float b)\n{\n    return abs(.5*(b - a) + .25*(sin(2.*a) - sin(2.*b)));\n}\n/*\n// no idea why I split it out this way originally;\n// I almost want to rewrite all of this anyway now.\nfloat B(float a, float b)\n{\n    return .0125 * abs(b - a); // constant fog on this axis\n}\n*/\nfloat A(vec3 a, vec3 b, vec3 dir)\n{\n    return dot(abs(dir), vec3(A(a.x, b.x), A(a.y, b.y), A(a.z, b.z))) // bingo!\n        //A(a.x, b.x)// just one plane is interesting\n        //dot(abs(dir), vec3(F(a), A(a.y, b.y), A(a.z, b.z))) //A(a.y, b.y) * A(a.z, b.z) // \"beams\"?\n        //(A(a.x, b.x) * A(a.y, b.y) * A(a.z, b.z)) / 127. // product shows up much more strongly\n        //(A(a.x, b.x) + A(a.y, b.y) + A(a.z, b.z)) / 3.\n    \t//(A(a.x, b.x) + A(a.y, b.y) + B(a.z, b.z)) / 3. // seems we must include some constant fog on the remaining axes or it doesn't seem right\n    \t//(A(a.x, b.x) + A(a.y, b.y)) / 2.\n    \t//(A(a.x, b.x) + B(a.y, b.y) + B(a.z, b.z)) / 3.\n    \t//A(a.x, b.x) // Can see mine easier when using just 2 axes or even just one\n        ;     // HACK\n}\n// if you give the individual planes/puffs any sort of density, \n// it quickly obscures view entirely, which wasn't really desired.\n\nfloat lineintegral(vec3 a, vec3 b) \n{\n    // find a scale where I can perceive it\n    const float s = 4.8; //1.; //2.; //.5; //200.; //1./200.; //\n    a *= s; b *= s; //\n    vec3 dir = (b - a);\n    if (dot(dir, dir) > 0.) dir = normalize(dir);\n    return A(a, b, dir) / s;\n}\n\n// I don't think it's quite right though,\n// because each axis is considered too independently.\n// I believe I probably must integrate the full vector equation\n// but I won't know until I see it.\n// yeah, I mean, it does work, but it does also\n// seem to combine in a way that isn't quite realistic.\n// It seems I can see one axis, and maybe even two, but\n// when I combine all three, I can't perceive the noise anymore.\n// I added wind so I can notice flow, which helps, \n// and I can definitely see it when there's just one planar axis\n// of fog flowing, but when I combine all 3, very hard to see, again.  :(\n// I tried some exponent-bending hacks, nothing works well so far.\n// I get the feeling I'm missing something crucial here\n// regarding self-obscurance of the fog.\n// idk how I'd incorporate that into the integral,\n// if it would even be possible.\n// anyway this was only intended to mimic\n// the flow of noise through otherwise solid fog, anyway!!!\n// So, if I can wrangle the values to a usable range\n// and distribution, I can utilize it to modulate\n// some other shape of fog, which is still very useful.\n// proper scattering can be factored by angle easily,\n// at least for single-scattering model.\n// for fog-shadows, would likely need to march through somehow.\n// I can't see how this technique would handle god-rays,\n// unless the fog-sheets themselves were arranged into beams\n// directed along a certain axis, which is easy for parallel beams\n// with fairly uniform distribution, but not so easy for\n// beams emanating from a point or ball or something.\n// Oh well I think it's still great for certain purposes!\n\n#else\n\n// blackle's way\n// shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec3 b) \n{\n    b += vec3(equal(b, vec3(0))) * .01;\n    return a/b;\n}\n\nvec3 antiderivatives(float x, vec3 origin, vec3 dir) \n{\n    // antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3( 1, 1, 0, -1, 0, 1,  0,-1,-1);\n    mat3 B = mat3( 1, 1, 0,  1, 0, 1,  0, 1, 1);\n    vec3 Q = origin + dir * x;\n    vec3 integral = div(sin(A*Q),(A*dir)) \n                  - div(sin(B*Q),(B*dir))\n         + div((2.*Q-sin(2.*Q)),(4.*dir));\n    return integral;\n}\n\nfloat lineintegral(vec3 a, vec3 b) \n{\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    vec3 r = antiderivatives(len,a,dir) - antiderivatives(0.,a,dir);\n    return dot(r, vec3(1));\n}\n\n#endif\n\n// blackle implemented Rodrigues' rotation formula\nvec3 erot(vec3 p, vec3 ax, float ro) \n{\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n// blackle bit munging\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\n\nfloat hash(float a, float b) \n{\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) \n{\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\n// niter must be 50, or it won't be scaled correctly FIXME - am working on it\nfloat lifogmultiscale(vec3 a, vec3 b, int niter)\n{\n    float fog = 0.\n    , prescale = 6. //1. //9. //1./9. //9. //\n \t, scale = 1.\n    , scalefactor = 1.06;\n    a *= prescale; b *= prescale; // massive HACK\n    vec3 oa = a, ob = b; // keep so each layer can be independent\n    // sum up multiple different versions of the fog\n    for (int i = 0; i < niter; ++i) {\n        // I tried some other stuff here, \n        // but blackle's works better so far.\n        // See Pyramid Field where I was working on it also.\n        // https://shadertoy.com/view/3ld3Dl\n        // N.B. tan is blackle's distribution-uniformizing trick,\n        // helps fixup the cubic distribution hash3 gives,\n        // back into something more spherically-distributed.\n        // random rotation\n        vec3 ax = normalize(tan(hash3(float(i), 14353.))); // axis\n        float ro = hash(float(i), 66123.)*10.; // angle, yet another hash\n        // TODO can't we just get a random length vector\n        // and use its direction and length?  Would be cheaper than another hash,\n        // and since we normalize anyway...\n        \n        // rotate both points into this layer's basis\n        // if not chained, each loop iteration can be\n        // done more independently and the compiler has\n        // more flexibility, less flow dependency issues.\n        // Just rotate each layer from the original coordinates!\n        a = erot(oa,ax,ro);\n        b = erot(ob,ax,ro);\n        // TODO I'm not 100% sure how it's scaling the fbm layers\n        // but in general it contributes less for finer scales.\n        fog += lineintegral(a*scale,b*scale) / sqrt(scale);\n       \tscale *= scalefactor;\n    }\n    fog /= prescale; // HACK HACK HACK\n    fog /= prescale;\n    fog /= float(niter);\n    fog /= float(niter);\n    //fog /= pow(scalefactor, float(niter)); // HACK try to fix it? TODO\n\t//fog /= 2500.; // mega HACK only works for niter == 50 apparently\n\treturn fog;\n}\n// if you wanted fog beams all parallel but with different scales,\n// would require a different method of randomly rotating each scale layer.\n// this seems only good for radially symmetric tiled fog.\n// but you could do a 2d field and skew the 3rd axis\n// to project the shafts into the scene how you like.\n\nfloat lifoguniscale(vec3 a, vec3 b)\n{\n    return lineintegral(a,b);\n}\n\nfloat scene(vec3 p) \n{\n    // tile space mirrored, the transcendental-heavy way isn't as slow as it seems\n    p = asin(sin(p+0.));\n\t// field of spheres\n    return length(p)-1.;\n}\n\nfloat march(inout vec3 p, vec3 cam, float tol, float maxd, int niter, out bool hit)\n{\n    //vec3 p = init;\n    hit = false;\n    float t = 0.;\n    for (int i = 0; i < niter && !hit; ++i) {\n        float dist = scene(p);\n        hit = dist*dist < tol*tol;\n        p += dist * cam;\n        t += dist;\n        if (t > maxd) break; //t = distance(p,init)\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 o, vec2 q)\n{\n    vec2 R = iResolution.xy\n    , uv = (q-.5*R)/R.y\n    , mr = (iMouse.xy-.5*R)/R.y * vec2(2,-1) * pi;\n    if (iMouse.xy == vec2(0)) mr = vec2(0, .2);\n    // I changed blackle's camera to a coordinate system \n    // I'm more familiar with, having +Y up, w/ mouselook\n    float ct = iTime/5., st = iTime/15., wt = iTime/3.;\n    vec3 cam = normalize(vec3(uv,1))\n\t, init = vec3(.5,.5,.5)*pi;\n    init += .25*pi * vec3(-cos(ct), 0, sin(ct)); \n    //init.x += iTime/15.; // sin,cos spin? TODO\n     cam = erot(cam, vec3(1,0,0), .0 + mr.y);\n     cam = erot(cam, vec3(0,1,0), st + mr.x);\n\t// draw a field of black spheres in thick noisy white fog\n    vec3 p = init;\n    bool hit;\n    float maxd = 28.;\n    float t = march(p, cam, 1e-4, maxd, 256, hit);\n    vec3 wind = mod(wt, 1024.) * vec3(1,0,0) * 8. // wind can only discard so much precision at expense of an occasional pop\n    , a = init + wind\n    , b = p + wind;  // init + cam * t\n    float fog = lifoguniscale(a,b);\n    // I managed to botch the tuning on it so you can't see it rn anyway :(\n    // hopefully I'll get something worth looking at soon\n    //if (uv.x > 0.) //p.x > R.x/2.) \n    //    fog = lifogmultiscale(a*.02,b*.02,8) * 1024.; //lifoguniscale(a,b); //50); //lifoguniscaleB(a,b); //\n    // blackle just obtained the density\n    // and was using that directly as intensity, after scaling\n    // but I want proper fogging; doesn't seem to make much difference :(\n    // at this point I have so many HACK's in so many parts of the process\n    // that I don't feel I have any control over the results.\n    \n    // meh, I have no control over the contrast of the puffs,\n    // and about fed up messing w it for the day.\n    fog *= .08; // master density HACK\n    float g = 1.-exp2(-fog); // Beer's law\n    vec3 c = vec3(g);\n    c = sqrt(c); // cheap gamma output\n    // dither for 8 bits/ch using blue noise texture in iChannel0\n    c += .5/256. * (texelFetch(iChannel0, ivec2(q) % ivec2(iChannelResolution[0].xy), 0).x * 2. - 1.);\n    o = vec4(c, 1);\n}\n\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByzc.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[5543, 5594, 5633, 5633, 5699], [5779, 5779, 5810, 5810, 5886], [5888, 5888, 5919, 5919, 6031], [6033, 6111, 6161, 6161, 8050], [8359, 8359, 8396, 8396, 8428], [8430, 8430, 8452, 8535, 8608], [8610, 8610, 8695, 8716, 8981], [8983, 8983, 9019, 9019, 11035]], "test": "error"}
{"id": "WlByzW", "name": "Evolution of nebulae-like volume", "author": "Leria", "description": "Stable with additive noise\nI tried to make it looks like a nebulae without any light effects of course\n--> the movements are only for the beauty, not realistic\n", "tags": ["noise", "time", "evolution", "nebulae"], "likes": 13, "viewed": 374, "published": "Public API", "date": "1593780965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.2\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//enable-disable distorsion (0/1)\n#define DISTORSION_ON\t\t0\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t1\n\n\n//Stretch or not the colored volume\n\t#define STRETCH\t\t\t1\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* clamp( noise(p)/.178 +.5 ,0.,1.) )\n#define Psnoise(p) (2.* clamp( snoise(p)/.178 +.5 ,0.,1.) )\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1., pow( 1.4, -3. ) );\n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    \n    #if STRETCH\n   \tp *= stretching;\n    s = 2./pow(stretching,vec3(.333));\n    #endif\n    \n    f = noise(p+iTime/10.); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching;\n    s = 2./pow(stretching,vec3(.333));\n    #endif\n\n    f = Pnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  2.*Pnoise( p ); p = p*s;\n    f *=  4.*Pnoise( p ); p = p*s;\n    f *=  8.*Pnoise( p ); p = p*s;\n    f *= 16.*Pnoise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 m_vec = m.pos - p;\n    float d = dot(m_vec,m_vec);\n    vec3 res = normalize(m_vec) * (DISTORSION*m.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    //RATE\n    float acc_rate = 0.8; // To control the acceleration rate\n\n    \n    int s = 0;\n    for(s; s < 140; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(d > 0.)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {            \n            #if COLOR     \n            float r_p = RADIUS/length(center);\n            float acceleration_p = sin(clamp(-r_p*r_p+4.,0., 4.));\n            \n            \n            float n = 0.;\n            if(r_p < 2.)\n            \tn = abs( fbm( p/8.+( acc_rate*acceleration_p) ) );\n             else\n                 n = abs( fbm( p/8. ) );          \n            \n            float mask = smoothstep(0., \n                                   \t1.*RADIUS,\n                                    (RADIUS-length(center))- 128.*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size\n            //4*f(p.) is a property that defines the quantity of color which is absorbed\n            //f(p.) is here to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 6.* f(p.x) * dens, \n                      \tk * 3.*  \t\t dens,\n              \t      \tk * 3.* f(p.z) * dens);    \n           \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.0, .*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        #if DISTORSION_ON\n        space_time_bending(r, p, k); \n        #endif\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\tc = exp(-t_acc);\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    cam.pos = C;\n\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n    \n    fragColor = vec4(color, 1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 889, 911, 911, 1084], [1754, 1754, 1811, 1811, 1980], [1982, 2005, 2027, 2280, 3197], [3199, 3199, 3225, 3225, 4050], [4161, 4161, 4186, 4199, 4561], [4563, 4563, 4588, 4601, 4934], [4936, 4936, 4955, 4955, 5048], [5050, 5050, 5111, 5111, 5305], [5306, 5325, 5401, 5401, 5448], [5450, 5450, 5482, 5482, 5502], [5504, 5504, 5538, 5538, 5560], [5662, 5662, 5686, 5686, 5846], [5848, 5848, 5872, 5872, 5957], [5959, 5988, 6016, 6016, 6186], [6188, 6210, 6256, 6256, 6879], [6929, 6929, 6970, 6970, 7006], [7008, 7008, 7094, 7094, 7129], [7131, 7131, 7174, 7174, 7214], [7216, 7216, 7240, 7240, 7288], [7290, 7290, 7330, 7330, 7634], [7636, 7636, 7660, 7660, 7723], [7725, 7725, 7772, 7772, 7824], [7826, 7826, 7909, 7909, 8048], [8051, 8051, 8104, 8104, 8461], [11412, 11412, 11469, 11469, 12087]], "test": "valid"}
{"id": "WlByzy", "name": "Neonwave style", "author": "mrange", "description": "License CC0: Neonwave style road, sun and city\nThe result of a bit of experimenting with neonwave style colors.", "tags": ["2d", "neonwave"], "likes": 18, "viewed": 490, "published": "Public API", "date": "1594640245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Neonwave style road, sun and city\n//  The result of a bit of experimenting with neonwave style colors.\n    \n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat planey(vec2 p, float w) {\n  return abs(p.x) - w;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n\n  return d;\n}\n\nfloat city(vec2 p) {\n  float sd = circle(p, 0.5);\n  float cd = 1E6;\n\n  const float count = 5.0;\n  const float width = 0.1;\n\n  for (float i = 0.0; i < count; ++i) {\n    vec2 pp = p;\n    pp.x += i*width/count;\n    float nn = mod1(pp.x, width);\n    float rr = hash(nn+sqrt(3.0)*i);\n    float dd = box(pp-vec2(0.0, -0.5), vec2(0.02, 0.35*(1.0-smoothstep(0.0, 5.0, abs(nn)))*rr+0.1));\n    cd = min(cd, dd);\n  }\n  \n  return max(sd,cd);\n}\nvec3 sunEffect(vec2 p) {\n  float aa = 4.0 / RESOLUTION.y;\n\n  vec3 col = vec3(0.1);\n  vec3 skyCol1 = hsv2rgb(vec3(283.0/360.0, 0.83, 0.16));\n  vec3 skyCol2 = hsv2rgb(vec3(297.0/360.0, 0.79, 0.43));\n  col = mix(skyCol1, skyCol2, pow(clamp(0.5*(1.0+p.y+0.1*sin(4.0*p.x+TIME*0.5)), 0.0, 1.0), 4.0));\n  \n  p.y -= 0.375;\n  float ds = sun(p);\n  float dc = city(p);\n\n  float dd = circle(p, 0.5);\n \n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp(0.5 - 1.0*p.y, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  vec3 cityCol = sunCol*sunCol;\n  \n  col += glareCol*(exp(-30.0*ds))*step(0.0, ds);\n  \n\n  float t1 = smoothstep(0.0, 0.075, -dd);\n  float t2 = smoothstep(0.0, 0.3, -dd);\n  col = mix(col, sunCol, smoothstep(-aa, 0.0, -ds));   \n  col = mix(col, glareCol, smoothstep(-aa, 0.0, -dc)*t1);   \n  col += vec3(0.0, 0.25, 0.0)*(exp(-90.0*dc))*step(0.0, dc)*t2;\n\n//  col += 0.3*psin(d*400);\n\n  return col;\n}\n\nfloat ground(vec2 p) {\n  p.y += TIME*80.0;\n  p *= 0.075;\n  vec2 gp = p;\n  gp = fract(gp) - vec2(0.5);\n  float d0 = abs(gp.x);\n  float d1 = abs(gp.y);\n  float d2 = circle(gp, 0.05);\n\n  const float rw = 2.5;\n  const float sw = 0.0125;\n\n  vec2 rp = p;\n  mod1(rp.y, 12.0);\n  float d3 = abs(rp.x) - rw;\n  float d4 = abs(d3) - sw*2.0;\n  float d5 = box(rp, vec2(sw*2.0, 2.0));\n  vec2 sp = p;\n  mod1(sp.y, 4.0);\n  sp.x = abs(sp.x);\n  sp -= vec2(rw - 0.125, 0.0);\n  float d6 = box(sp, vec2(sw, 1.0));\n\n  float d = d0;\n  d = pmin(d, d1, 0.1);\n  d = max(d, -d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d = min(d, d6);\n  \n  return d;\n}\n\nvec3 groundEffect(vec2 p) {\n  vec3 ro = vec3(0.0, 20.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.025, 1.0));\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float distg = (-9.0 - ro.y)/rd.y;\n\n  const vec3 shineCol = 0.75*vec3(0.5, 0.75, 1.0);\n  const vec3 gridCol = vec3(1.0);\n\n  vec3 col = vec3(0.0);\n  if (distg > 0.0) {\n    vec3 pg = ro + rd*distg;\n    float aa = length(dFdx(pg))*0.0002*RESOLUTION.x;\n    \n    float dg = ground(pg.xz);\n    \n    col = mix(col, gridCol, smoothstep(-aa, 0.0, -(dg+0.0175)));   \n    col += shineCol*(exp(-10.0*clamp(dg, 0.0, 1.0)));\n    col = clamp(col, 0.0, 1.0);\n    \n//    col += 0.3*psin(dg*100);\n    col *= pow(1.0-smoothstep(ro.y*3.0, 220.0+ro.y*2.0, distg), 2.0);\n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col = clamp(col,0.0,1.0);\n//  col=pow(col,vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec3 col = vec3(0.0);\n\n  vec2 off = vec2(0.0, 0.0);\n  \n  col += sunEffect(p+off);\n  col += groundEffect(p+off);\n\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x / RESOLUTION.y;\n \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByzy.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[245, 245, 267, 267, 436], [438, 438, 463, 463, 511], [513, 513, 537, 537, 607], [609, 609, 630, 630, 659], [661, 661, 700, 700, 825], [827, 827, 858, 858, 884], [886, 886, 913, 913, 989], [991, 991, 1022, 1022, 1047], [1049, 1049, 1080, 1080, 1105], [1107, 1107, 1146, 1146, 1235], [1237, 1237, 1276, 1276, 1305], [1307, 1307, 1326, 1326, 1559], [1561, 1561, 1581, 1581, 1992], [1993, 1993, 2017, 2017, 2906], [2908, 2908, 2930, 2930, 3530], [3532, 3532, 3559, 3559, 4353], [4355, 4355, 4392, 4392, 4614], [4616, 4616, 4645, 4645, 4805], [4807, 4807, 4859, 4859, 5023]], "test": "error"}
{"id": "wlfBRN", "name": "Capsule Practice", "author": "reatured", "description": "Capsule and shades", "tags": ["learning"], "likes": 0, "viewed": 96, "published": "Public", "date": "1596135182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n\n\n\n\nfloat cd(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ab, ap)/dot(ab, ab);\n    \n    t = clamp(t, 0.,1.);\n    \n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0., 1., 6., 4.);\n    float planeDist = p.y;\n    vec3 topP = vec3(2., 3., 5.);\n    topP.x += sin(iTime);\n    topP.y += cos(iTime);\n    float cd = cd(p,\n                  vec3(-2., 1., 3.),\n                  topP,\n                  1.);\n    \n    return min(cd, planeDist);\n    \n}\nfloat RayMarch(vec3 ro, vec3 rd){\n\tfloat dO = 0.; \t//distance\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n     \tvec3 p = ro + rd*dO;//step destination vector\n        float dS = GetDist(p);//dist to destination\n        dO += dS; \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n \tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(GetDist(p-e.xyy),\n                      GetDist(p-e.yxy),\n                      GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lightPos){\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p); //obj normal\n    \n    float dif = clamp(dot(n, l),0.,1.);//shadow\n    float d = RayMarch(p + n*SURF_DIST * 2.,l);\n    if(d<length(lightPos - p))\t dif *= .2;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv- 0.5) *2.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.y += sin(iTime*1.5+sin(uv.x*12.0))*0.05;\n    vec3 col = vec3(0.1);\n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1. - uv.x*sin(iTime)));\n    \n    float d = RayMarch(ro, rd);\n    \n        vec3 p = ro + rd * d;\n    float dif  = GetLight(p, vec3(0., 7., 3.));//the position on obj\n    dif  += GetLight(p, vec3(3., 2., 1.));//the position on obj\n    \n    \n    d /= 6.;\n    col += vec3(0.2 + uv.x*0.2,0.5 + uv.x *-0.6,0.7)*dif;\n    \n    // Time varying pixel color\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 114, 114, 277], [279, 279, 301, 301, 597], [598, 598, 631, 631, 895], [897, 897, 920, 920, 1130], [1132, 1132, 1170, 1226, 1466], [1468, 1468, 1525, 1575, 2233]], "test": "valid"}
{"id": "wlffRN", "name": "spiralyRects", "author": "pohy", "description": "spiralyRects", "tags": ["spiralyrects"], "likes": 2, "viewed": 119, "published": "Public API", "date": "1596143315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat Circle(vec2 uv, vec2 p, float r) {\n\tfloat d = distance(uv, p);\n    d = smoothstep(r, r * .99, d);\n    return d;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}\n\nfloat Rect(vec2 uv, vec2 p, vec2 wh, float rot) {\n    vec2 sizeH = wh * .5;\n    vec2 uvRot = rotate(uv - p, rot);\n    float d = distance(uvRot, vec2(clamp(uvRot.x, -sizeH.x, sizeH.x), clamp(uvRot.y, -sizeH.y, sizeH.y)));\n    d = smoothstep(.001, .0, d);\n    return d;\n}\n\nfloat vecAngle(vec2 a, vec2 b) {\n\tfloat cosA = dot(a, b) / length(a) * length(b);\n    return acos(cosA);\n}\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\n\nfloat posCos(float x) {\n    return cos(x) * .5 + .5;\n}\n\nfloat remap(float val, vec2 from, vec2 to) {\n    return val / from.x * to.x;\n}\n\nfloat triangle(float x, float p) {\n    return 4. / p * (x - p / 2. * floor(2. * x / p + .5)) * pow(-1., floor(2. * x / p + .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    float t = 10. + iTime * .2;\n\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //uv *= .1 + posSin(t) * 3.;\n    uv *= 1.7;\n    \n    \n    //col += Rect(uv, vec2(1), .25, PI * sin(t) * .5 + PI * mouse.x);\n    \n    float start = 150. * posCos(300. + sin(t) + posCos(t));\n    //float start = 0.;\n    float it = 5. + 300. * posSin(cos(t) + posSin(t));//posSin(t) * 1000.;\n    for (float i = start; i < it; i++) {\n        float iN = i / it;\n    \tfloat r =  .005;\n        float rotR = i * .002;\n        float spread = i * .1;\n        vec2 p = vec2(sin(spread) * rotR, cos(spread) * rotR);\n        //float d = Circle(uv, p, r);\n        float a = vecAngle(vec2(.0001, .00001), p) + sin(t + i * .1);\n        vec2 wh = vec2(.1 * iN, distance(vec2(0), p) * .1 + iN * .3);\n        float d = Rect(uv, p, wh, a);\n        d *= iN * .2;\n        //d *= texture(iChannel0, p).rgb;\n        //col += texture(iChannel0, rotate(uv - p * wh, a) * 4.).rgb * (iN * .3) * d;\n        col += d * vec3(.9 * iN, .2 * iN, .9);\n        ///*\n        if (i > it - 1.) {\n        \tcol *= .3 + fract(it) * iN;\n        }\n\t\t//*/\n        //col.r +=  vecAngle(vec2(.0001, .00001), p);\n        //col = sampleNoise.rgb;\n        //col.rg += samplePos;\n    }\n\t    \n    //col.rg += uv;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 60, 60, 139], [141, 141, 171, 171, 267], [269, 269, 318, 318, 538], [540, 540, 572, 572, 646], [648, 648, 671, 671, 702], [704, 704, 727, 727, 758], [760, 760, 804, 804, 838], [840, 840, 874, 874, 970], [972, 972, 1029, 1079, 2563]], "test": "valid"}
{"id": "wlfyWs", "name": "Golden Fractal ", "author": "Pairtial", "description": "Based on @evvvvil's work ", "tags": ["fracta", "gold", "pairtial"], "likes": 0, "viewed": 163, "published": "Public API", "date": "1593926413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Originally created by https://www.twitch.tv/evvvvil_ https://www.shadertoy.com/user/evvvvil\n\n\nvec2 z,v,e=vec2(.000035,-.000035);float t,tt,b,g,g2,bb; vec3 np,bp,pp,po,no,al,ld;//global vars. The city of Norwich, pronounced \"shit-hole\", will be the butt of today's jokes. \nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function // Norwich is the capital of middle class England and home to 142000 boring cyclists.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function // People from Norwich actually live in London, they can be found near Bethnal Green, pricing out the locals with their East-Anglian petro Dollars.\nvec2 fb( vec3 p, float m)\n{ \n  p.y+=bb*.05; //Make those pesky blue lines dash at the top of the fractal. Racing like art students offended by the lack of houmous served on Norwich university campuses.\n  vec2 h,t=vec2(bo(p,vec3(35,31,33)),3); //Blue box base, East Anglia's finest shape since Allan Partridge's striped ties.\n  t.x=max(t.x,-(length(p)-1.5)); //Dig fucking hole in box base, because sanctions against the city of Norwich for breeding hipsters should be debated in parliament.\n  t.x=max(abs(t.x)-.6,(p.y-6.4));  //Onion trick + cut that shit with horizontal plane . \n  h=vec2(bo(p,vec3(9,1,2.9)),6);  //Another fucking box this time white. Nothing exciting, neither here nor in Norwich. \n  h.x=max(h.x,-(length(p)-2.5)); //Dig another fucking hole, this time in the white box. \n  h.x=max(abs(h.x)-.4,(p.y-5.4)); //Onion trick + cut that shit with horizontal plane.\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(bo(p+vec3(0,0.4,0),vec3(5.4,0.4,3.4)),m); //Blue or orange box, material ID passwed in fb function call\n  h.x=max(h.x,-(length(p)-2.5)); //Bored of all this digging hole bullshit but had to be this way with the onion trick fucking with my drilling rig\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(length(p)-2.,m); //Finally, stick a ball in the hole (that's what she said)\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  t.x*=0.7; return t; //Tweak distance field to avoid artifact and return the whole shit\n}\nvec2 mp( vec3 p )\n{ \n  pp=bp=p; //Setup bullshit new postions pp and bp based on p,  \n  bp.yz=p.yz*=r2(sin(pp.x*.3-tt*.5)*.4); //add twist along z axis (due to line below bullshit x axis will become z axis. I know, dumb as fuck, but not as dumb as a vegetarian sausage)\n  p.yz*=r2(1.57);//This is some real bullshit, whoever thought it was a good fucking idea to rotate the whole fucking thing rather than flip variables in fb, is a fucking bell-end... Ah, yes, that would be me.\n  b=sin(pp.x*.7+tt); //Setup animation variable used all over the shop, you gotta punch the math in if you wanna wiggle\n  bb=cos(pp.x*.2+tt);//Setup animation variable used all over the shop, the opposite of above, sort of\n  p.x=mod(p.x-tt*2.,10.)-5.; //Modulo along z axis (x is now z, yeah I know, still dumb as fuck, but not as dumb as giving 2.5k fines to the homeless. Yeah I'm looking at you, Oxford, you cruel bastard.\n  vec4 np=vec4(p*.4,.4); //make new position np a vec4 for fractal so we can track the scale changes in the .w scalar and reuse that shit later to spank the distance field into shape to avoid artifact \n  for(int i=0;i<4;i++){ //\"Less is more\" when it comes to iterations, same could be said about prison time.\n    np.xyz=abs(np.xyz)-vec3(1,1.2,0); //Kaleidoscopic mandelbullshit\n    np.xyz = 2.*clamp(np.xyz, -vec3(0), vec3(2,0.,4.3+bb)) - np.xyz; //Adding the box in \"mandelbox\", thgankx to alkama for the help there\n    np=np*(1.3)/clamp(dot(np.xyz,np.xyz),0.1,.92); //each iter with scale and clamp the mess into beauty. Bit like rhinoplasty, but without the black eyes\n  }  \n  vec2 h,t=fb(abs(np.xyz)-vec3(2,0,0),5.);//Fuck it we still gonna abs symetry kaleidoscope that shit one more time for more details\n  t.x/=np.w; //Yeah that's where the trick is to render fractal without artifact by tweaking domain using the .w scaling scalar \n  t.x=max(t.x,bo(p,vec3(5,5,10))); //Contain the fractal within a box, cuts the sides a bit\n  np*=0.5; np.yz*=r2(.785); np.yz+=2.5; //reuse np fractal positions to create another bigger orange fractal on the side\n  h=fb(abs(np.xyz)-vec3(0,4.5,0),7.); //np on line above was scaled, rotated and shifted a bit, once again another abs symetry to increase amount of geom\n  h.x=max(h.x,-bo(p,vec3(25,5,5))); //remove inside bits of bigger orange fractal\n  h.x/=np.w*1.5; //Again trik to render fractal without artifact reusing .w scaling scalar\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(bo(np.xyz,vec3(3.0,b*10.,0.0)),3); //Mega glowy light sweeper is here broski, time to take your pants off and indulge.\n  h.x/=np.w*1.5; //Since we're using fractal position np again but this itme inside box, still we have to do the scaling scalar trick again to improve rendering\n  g2+=0.1/(0.1*h.x*h.x*(1000.-b*998.)); //Balkhan's super sick glow trick, with my added sweep along z axis hot sauce. Things are getting too fucking spicy for the pepper!\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(0.6*bp.y+sin(p.y*5.)*0.03,6); //Make a terrain out of a frilled horizontal plane, resue bp position to get the twist as well\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(length(cos(bp.xyz*.6+vec3(tt,tt,0)))+0.003,6); //Make it fucking rain sparkly little fucking particles. Because everything looks better when sprinkled with glitter, even Norwich city centre.\n  g+=0.1/(0.1*h.x*h.x*9000.); //Make the particle glow and pack the glow with that 4000\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(7.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<728;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>140.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>540.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  vec3 ro=mix(vec3(1),vec3(-0.5,1,-1),ceil(sin(tt*.5)))*vec3(10,2.8+0.75*smoothstep(-1.5,1.5,1.5*cos(tt+0.2)),cos(tt*0.3)*3.1),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.4,-.3)); //ld=light direction\n  co=fo=vec3(8.3,3.7,1.32)-length(uv)*.1-rd.y*.2; //background is blueish with vignette and subtle vertical gradient based on ray direction y axis. It's dark like the heart of people from Norwich.\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying it with that mediocre looking waitress\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(0.1,18.2,5.4),vec3(0.1,0.4,.7),.5+0.5*sin(bp.y*7.)); //al=albedo=base color, by default it's a mix between blue/turquoise and darker blue. mix is done by reusing bp in a sin, weird I know but not as weird as Norwich's suburban dogging scene\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=mix(vec3(1,.5,0),vec3(.9,.3,.1),.5+.5*sin(bp.y*7.)); //Material ID 7 gives us greadient orange -> red colour, again mixing between colours by reusing bp in a sin\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.); //Sp=specular, stolen from Shane, below you will find: mix(vec3(.8),vec3(1),abs(rd))*al is a sick trick by crundle to tweak colour depending on ray direction\n    co=mix(sp+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.2)+.2)*(dif+s(2.)),fo,min(fr,.2)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0003*t*t*t)); //Fog soften things, but it won't stop failed art students from becoming dictators.\n  }\n  fragColor = vec4(pow(co+g*.2+g2*mix(vec3(1.,.5,0),vec3(.9,.3,.1),.5+.5*sin(bp.y*3.)),vec3(0.65)),1);// Naive gamma correction and glow applied at the end\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 274, 298, 298, 339], [340, 451, 468, 468, 511], [512, 678, 705, 705, 2185], [2186, 2186, 2205, 2205, 5725], [5726, 5726, 5808, 5808, 6574], [6664, 6664, 6793, 6793, 9789]], "test": "valid"}
{"id": "wljcDD", "name": "starzzzz", "author": "notchris", "description": "space", "tags": ["space"], "likes": 2, "viewed": 53, "published": "Public", "date": "1594443081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a messy, but common, random function\nfloat rand(in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // corners of a tile at st\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n    \n    // average the random value\n    float avg = (a + b + c + d) / 4.0;    \n    return smoothstep(0., 1., avg);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy;\n    vec3 spaceColor = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(spaceColor);\n    \n    //first layer of stars\n    float speed = iResolution.x / 10.0;\n    vec2 direction = vec2(1.0, 0.0);\n    vec2 layer1Offset = st + direction * speed * iTime;\n    float strength = step(0.98, noise(layer1Offset));\n    vec3 starColor = vec3(1.0, 1.0, 0.9) * strength;\n    color += starColor;\n\n    //second layer of stars\n    speed = iResolution.x / 30.0;\n    float scale = 1.25;\n    vec2 layer2Offset = (vec2(st.x, st.y) + direction * speed * iTime)/scale;\n    strength = step(0.96,noise(layer2Offset));\n    starColor = vec3(1.0, 0.8, 0.9) * strength;\n    color += starColor;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 64, 64, 138], [140, 140, 165, 165, 506], [508, 508, 565, 565, 1315]], "test": "valid"}
{"id": "WljcDt", "name": "XOR Doughnut LOL", "author": "970037201", "description": "The kaleidoscopic Doughnut from a non euclidean universe. My first official Shadertoy project.", "tags": ["euclidean"], "likes": 6, "viewed": 79, "published": "Public", "date": "1595782518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 donut(float inner_diam, float outer_diam, float blur, vec2 uv){\n    //create smoothstep off of length from origin, creating smooth circle\n\tvec3 val = vec3(smoothstep(outer_diam, outer_diam - blur, length(uv)));\n    //multiply circle by inverse of another, smaller circle\n    vec3 donut = val * smoothstep(inner_diam - blur, inner_diam, length(uv));\n    //get an integer location of uv in range 256.\n    ivec2 xoruv = abs(ivec2(floor(uv*256.)));\n    //multiply donut color by xor pattern\n    donut *= vec3((xoruv.x ^ xoruv.y)%256)/256.;\n\treturn donut;\n}\n//generate pseudo random 3 parta vector from 2 part vector\nvec3 hash23(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 203.597));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 uv = (fragCoord * 2. - iResolution.xy ) / iResolution.y;\n    float t = iTime * .25;\n    uv.x += sin(t)*.75;\n    t *= .5+cos(t)*0.01;\n    float curvature = cos(uv.y) * cos(uv.x);//curvature of the universe, positive or negative?\n    vec2 nuv = uv * mix(1./curvature, curvature, cos(t*2.));//say yay to derivative of tan!\n    nuv *= mat2(sin(t),-cos(t),cos(t),sin(t));\n    nuv *= 5.;\n    nuv += t * 5.;\n    vec2 boxes = fract(nuv*2.)*2. - 1.;\n    \n    //for each spot render donut\n    vec3 col = donut(.45,1.,.2, boxes);\n    col *= hash23(floor(nuv));\n    //multiply by big donut\n    col *= donut(0.35,1.,.05,uv);\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 142, 557], [558, 617, 638, 638, 813], [814, 814, 871, 871, 1547]], "test": "valid"}
{"id": "WljcR3", "name": "Infinite Ocean (By Criyson)", "author": "Criyson", "description": "Continuously updating", "tags": ["water"], "likes": 23, "viewed": 359, "published": "Public", "date": "1594972880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float k_screenshotTime = 13.0;\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 3;\nconst int k_superSampleCount = 10;\nconst int k_fmbWaterSteps = 4;\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\nfloat g_fTime;\nconst vec3 g_vSunDir = vec3( -100.0, 70., 25. );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n#define MOD2 vec2(4.438975,3.972973)\n\n// 哈希算法, 提供随机噪声的高度\nfloat Hash( float p ) {\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec2 Hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Perlin噪声 + 线性过度处理\nfloat SmoothNoise(in vec2 o) {\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\tfloat n = p.x + p.y*57.0;\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    return res;\n}\n\n// FBM算法, 对perlin噪声进行迭代\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i < k_fmbSteps; i++) {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n// 对SmoothNoise求导\nvec3 SmoothNoise_DXY(in vec2 o) {\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\tfloat n = p.x + p.y*57.0;\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv; \n    return vec3(dx, dy, res);\n}\n\n// 对FBM求导\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbWaterSteps; i++) {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n// 地形高度采样, 利用fbm迭代算出地形\nfloat GetTerrainHeight( const vec3 vPos ) {    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm * 0.05;\n    fTerrainHeight -= 0.3 + (0.5 + 0.5 * sin( vPos.z * 0.001 + 3.0)) * 0.4;\n    return fTerrainHeight;\n}\n\n// 距离场函数\nfloat GetSceneDistance( const vec3 vPos ) {\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos ) {\n    return -GetTerrainHeight( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos ) {\n    return vec2( 1.0, 0.);\n}\n\nvec2 GetGradient( const vec2 vPos ) {\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag ) {    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 ;\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75, fGradientAscent);\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float time ) {\n    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    return result;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput ){\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\tfloat fDist = dot(vOffset, vOffset);\n\tconst float kStrength = 0.8;\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x ) {\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nstruct Intersection {\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, float near, float far, out Intersection intersection ) {\n    float stepScale = 1.0;\n    intersection.m_dist = near;\n    intersection.m_objId = OBJ_ID_SKY;\n    float sceneDist = 0.0;\n    // k_raymarchSteps 作为步进次数上限, 在次数限制内查找物体\n    for( int iter = 0; iter < k_raymarchSteps; iter++ ) {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n        sceneDist = GetSceneDistance( vPos );\n        intersection.m_dist += sceneDist * stepScale;\n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( sceneDist <= 0.01 ) {\n            break;\n        }\n        if ( intersection.m_dist > far ) {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = far;\n            break;\n        }\n    }\n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos) {\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\n// 追踪水面场景算法\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, float near, float far, out Intersection intersection ) {\n \tintersection.m_dist = far;\n    // 求出相机在y轴分量上, 与是方向距离的倍数\n    // 所得倍数与RayDir的乘积, 结合相机位置, 可求出水面的具体坐标\n    float t = -vRayOrigin.y / vRayDir.y;\n    if ( t > 0.0 )  {\n        intersection.m_dist = t;\n    }\n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\nfloat triNoise(in vec3 p) {\n    float z = 1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ ) {\n        p += tri3(bp*2.);\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n} \n\nstruct Surface {\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n\nvoid GetSurfaceInfo( Intersection intersection, out Surface surface ) {\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal + (vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );\n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k) {\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular ) {\n    vec3 vSunDir = GetSunDir();\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    float diffuseIntensity = fNdotL;\n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\tfloat alpha = 1.0 - surf.m_gloss;\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular ) {\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss ) {\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist ) {\n    float fOpticalDepth = dist * 6.0;\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir ) {    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss ) {\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir,const in float near, const in float far, out Intersection intersection ){\n    RaymarchScene( vRayOrigin, vRayDir, near, far, intersection );        \n    if ( intersection.m_objId == OBJ_ID_SKY ){\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float near, const in float far) {\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, near, far, intersection );\n}\n\nvec3 GetScene( const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float near, const in float far) {\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    Intersection waterInt;\n    TraceWater( vRayOrigin, vRayDir, near, far, waterInt );\n    vec3 vReflectRayOrigin;\n    vec3 vResult;\n    vec3 vTransmitLight;\n    Surface specSurface;\n    vec3 vSpecularLight = vec3(0.0);\n    vec2 vFlowRate = GetBaseFlow( waterInt.m_pos.xz ) * 0.3;\n    vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, g_fTime / 5.0 );\n    float fFogDistance = waterInt.m_dist;\n    vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n    vReflectRayOrigin = waterInt.m_pos;\n    vec3 vRefractRayOrigin = waterInt.m_pos;\n    vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );\n    Intersection refractInt;\n    vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, near, far, refractInt ); // note : dont need sky\n\n    // add extra extinction for the light travelling to the point underwater\n    vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n    specSurface.m_pos = waterInt.m_pos;\n    specSurface.m_normal = normalize( vWaterNormal );\n    specSurface.m_albedo = vec3(1.0);\n    specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n    vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n    float fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n    specSurface.m_gloss = 0.99 * fGlossFactor;            \n    specSurface.m_specScale = 1.0;\n    vec3 vSurfaceDiffuse = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n    AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n    vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n    vTransmitLight = vRefractLight.rgb;\n    vTransmitLight += vInscatter;\n    vTransmitLight *= vExtinction; \n    vec3 vReflectRayDir = reflect( vRayDir, vWaterNormal );\n    vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir, near, far );\n    vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n    vec3 vFresnel = GetFresnel( -vRayDir, vWaterNormal, specSurface.m_specR0, specSurface.m_gloss );\n    vSpecularLight += vReflectLight;\n    vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    vec3 vFogColour = GetSkyColour(vRayDir);\n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    return vResult;\n}\n\n\nvoid initCamera(out vec3 ro, out vec3 rd,out float near, out float far) {\n    // 相机参数\n    vec3 lookAt = vec3(0.,0.,0.);\n    vec3 cameraPosition = vec3(1.5, 1.5, -1.5); \n    \n    // 相机控制\n    if( iMouse.z > 0.0 )  {\n        float fHeading = iMouse.x * 10.0 / iResolution.x;\n        float fDist = 5.0 - iMouse.y * 5.0 / iResolution.y;\n        cameraPosition.y += 1.0 + fDist * fDist * 0.05;\n        cameraPosition.x += sin( fHeading ) * fDist;\n        cameraPosition.z += cos( fHeading ) * fDist;\n    }\n    \n    // 相机三轴\n    vec3 forward = normalize(lookAt-cameraPosition);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n \tvec3 up = normalize(cross(forward,right));\n    float FOV = 0.5;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    near = 0.01;\n\tfar = 200.0;\n    vec2 screenCoords = (2.0*gl_FragCoord.xy/iResolution.xy - 1.0)*aspect;\n    ro = cameraPosition;\n    rd = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro,rd; // Rar Origin , Ray Direction \n    float near, far;\n    g_fTime = iTime;\n    initCamera(ro, rd, near, far);\n\tvec3 vResult = GetScene(ro, rd, near, far);\n\tvResult = ApplyVignetting( fragCoord.xy / iResolution.xy, vResult );\t\n\tvec3 vFinal = Tonemap(vResult * 3.0);\n    vFinal = vFinal * 1.1 - 0.1;\n\tfragColor = vec4(vFinal, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 292, 292, 325], [729, 774, 797, 797, 900], [902, 902, 925, 925, 1053], [1055, 1092, 1122, 1122, 1462], [1464, 1506, 1537, 1537, 1750], [1752, 1776, 1809, 1809, 2310], [2312, 2328, 2383, 2383, 2748], [2750, 2801, 2844, 2844, 3052], [3054, 3073, 3116, 3116, 3164], [3166, 3166, 3208, 3208, 3271], [3273, 3273, 3310, 3310, 3339], [3341, 3341, 3378, 3378, 3623], [3625, 3625, 3691, 3691, 4158], [4160, 4160, 4244, 4244, 4870], [5127, 5127, 5151, 5151, 5320], [5405, 5405, 5512, 5512, 6284], [6989, 7017, 7121, 7121, 7478], [7481, 7481, 7503, 7503, 7528], [7529, 7529, 7550, 7550, 7621], [7622, 7622, 7649, 7649, 7885], [8024, 8024, 8095, 8095, 8556], [8561, 8561, 8595, 8595, 8645], [8647, 8647, 8772, 8772, 9507], [9513, 9513, 9590, 9590, 9709], [9711, 9711, 9780, 9780, 9919], [9921, 9921, 9960, 9960, 10146], [10148, 10148, 10183, 10183, 10488], [10490, 10490, 10539, 10539, 10655], [14267, 14267, 14340, 14360, 15259], [15261, 15261, 15318, 15318, 15664]], "test": "error"}
{"id": "wljcRd", "name": "Impact crater", "author": "vegardno", "description": "Very simple impact crater model from heightmap", "tags": ["2d", "moon", "heightmap", "bumpmapping", "crater", "impact"], "likes": 6, "viewed": 101, "published": "Public", "date": "1595182505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// crater function\n\nconst float radius = .3;\nconst float bottom = .6;\n\nfloat bowl(float r)\n{\n    // y = ax² + c\n    const float c = -bottom;\n    const float a = bottom / (radius * radius);\n    \n    float y = a * r * r + c;\n    return clamp(y, -1., 0.);\n}\n\nfloat ridge(float r)\n{\n    return smoothstep(.0, .7, 1. * (.5 - clamp(r, radius, .5)));\n}\n\n// uv in [-1, 1]²\n// result in [-1, 1]\nfloat height(vec2 uv)\n{\n\t// custom interpolation to avoid discontinuities\n    int n = 43;\n    float a = float(n) * (atan(uv.y, uv.x) + radians(180.)) / radians(360.);\n    ivec2 size = textureSize(iChannel0, 0);\n    ivec2 mid = size / 2;\n    float noise = .14 * (mix(texelFetch(iChannel0, mid + ivec2(int(round(a - .5)), 0), 0).x,\n                            texelFetch(iChannel0, mid + ivec2((int(round(a + .5))) % n, 0), 0).x,\n                            smoothstep(-.3, 1.3, fract(a))) - .5) * clamp(length(uv), 0., .5);\n\n    float r = length(uv) + noise;\n    return .05 * texture(iChannel1, 1.3 * uv).r + min(\n    \tbowl(r) + ridge(r),\n        .13 + .14 * texture(iChannel2, .5 + 2. * uv).r);\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec2 uv)\n{\n    const float eps = 0.001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3( height(uv-h.xy) - height(uv+h.xy),\n                            2.0*h.x,\n                            height(uv-h.yx) - height(uv+h.yx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 1.2;\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n#if 0\n    vec3 col = vec3(.5 + .5 * height(uv));\n#else\n    float t = radians(20.) * iTime;\n    vec3 col = vec3(.2, 0, 0)\n        + vec3(1) * max(0., dot(normal(uv), normalize(vec3(cos(t), sin(t), .4))))\n        + vec3(0) * height(uv);\n#endif\n\n#if 0 // overlay slice graphs\n    col = mix(col, vec3(1., 0., 0.), smoothstep(2. * scale / iResolution.y, 0., abs(uv.y - .5 * bowl(abs(uv.x)))));\n    col = mix(col, vec3(0., 0., 1.), smoothstep(2. * scale / iResolution.y, 0., abs(uv.y - .5 * ridge(abs(uv.x)))));\n    col = mix(col, vec3(1., 1., 1.), smoothstep(2. * scale / iResolution.y, 0., abs(uv.y - .5 * height(vec2(uv.x, 0.)))));\n    col = mix(col, vec3(1., 1., 1.), smoothstep(2. * scale / iResolution.y, 0., abs(length(uv) - .5)));\n#endif\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljcRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 92, 112, 255], [257, 257, 279, 279, 346], [1086, 1151, 1173, 1173, 1426], [1428, 1428, 1485, 1485, 2362]], "test": "error"}
{"id": "WljcRG", "name": "Another xor \"automaton\"", "author": "jarble", "description": "This animation has many patterns that resemble cellular automata. This is based on [url=https://www.shadertoy.com/view/wtlcR8]another pattern[/url] that I found.", "tags": ["xor"], "likes": 14, "viewed": 445, "published": "Public API", "date": "1594683337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = (x)^(y);\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 9970 < 1000 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 90, 90, 223]], "test": "error"}
{"id": "wljcWd", "name": "Fractal Sky", "author": "NivBehar", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 6, "viewed": 98, "published": "Public", "date": "1595775773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 2000\n#define COLOR_REPEAT 0.6\n#define MANDELBROT_SHADE 2072.\n#define time iTime\n#define HEX_DIST 1.\n#define HAIR_DIST 21.\n#define PI 3.141592654\n#define _DotsSize 0.213\n#define _DotsSmoothness 0.221\n\nvec2 rot(vec2 p, vec2 pivot, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    p -= pivot;\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n    p += pivot;\n\n    return p;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n\n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n\n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat TriangleDist(vec2 p, vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return sqrt(d)*sign(s);\n}\nvec3 iterate(vec2 UV , float distance_type)\n{\n    //cool shit: https://www.shadertoy.com/view/wdBfDK\n    //UV = _MandelbrotArea.xy + (UV-0.5)*_MandelbrotArea.zw;\n    //UV = rot(UV, _MandelbrotArea.xy, _MandelbrotAngle);\n\n    vec3 col;\n\n    float dots_dist = 1e20f;\n    vec2 z = UV;\n    // shape = z for regular mandelbrot set\n    // a; 0       ; (GOLDEN-2); 0.285; 0.285; 0.45  ; -0.70176; -0.835 ; -0.8 ; -0.7269; -0.754\n    // b; 1-GOLDEN; (GOLDEN-1); 0    ; 0.01 ; 0.1428; -0.3842 ; -0.2321; 0.156; 0.1889; -0.066\n    //float[1] shapes;\n    //float2 shapes[11] = {z, float2(0, 1-GOLDEN), float2(GOLDEN-2, GOLDEN-1), float2(0.285, 0.), float2(0.285, 0.01), float2(0.45, 0.1428), float2(-0.70176, -0.3842), float2(-0.835, -0.2321),\n        //float2(-0.8, 0.156), float2(-0.7269, 0.1889), float2(-0.754, -0.066)};\n        vec2 shape = vec2(0.285, 0.01);\n    //shape = float2(_fractal_shape_a, _fractal_shape_b);\n    //if(shape.x == 0 && shape.y == 0)\n    //    shape = z;\n    vec2 prev_z;\n    vec2 z_dots;\n    vec4 z_hc;\n    float dist_from_mandelbrot = 1e20f;\n    float r = 20.;\n\n    vec2 hc2;\n    int i = 0;\n    for(i = 0; i<ITERATIONS; i++ )\n    {\n        prev_z = z;\n        if(distance_type == HEX_DIST)\n        {\n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 1. + 10.*HexDist(0.5 + 2.*sin(cos(z2)*0.5)*cos(cos(z2*3.)));\n        }\n        if(distance_type == HAIR_DIST)\n        {   \n            vec2 z2 = rot(z, vec2(0.), time*0.4);\n            r = 10. + 15.*TriangleDist(sin(cos(z2*PI+time)*0.5 + 5.)*cos(cos(z2*PI)), vec2(50.,3.2));\n            //float r2 = 5 + 15*TriangleDist(sin(cos(z2*PI+time*1)*0.5 + 5)*cos(cos(z2*PI)), float2(50,-0.6));\n            //r = lerp(r,r2, 0.4 + 0.4*sin(time));\n            //r = 5+TriangleDist(z*3, float2(_test1,_test2));\n        }\n\n        //r = HexCoords(0.5 + 0.25*sin(cos(z*2 + time)*0.1)*cos(cos(z*3) + 0.25*sin(cos(prev_z*2)) )).y*10;\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + shape;\n        //float z_hash = N22(z);\n        if(length(z) > r)\n            //if(dot(z, prev_z) > r)\n            break;\n        //return 0.0;\n\n\n        z_dots = z + rot(z,prev_z,time*0.2);\n        z_dots = vec2(HexDist(z_dots));\n        z_hc = HexCoords(z_dots);\n\n        //z_dots = pMod2(z_dots,4);\n\n        dots_dist = min( dots_dist, dot(z_dots,z_dots) );\n        //dots_dist = min( dots_dist, dot(z_hc.x,z_hc.y) );\n        dist_from_mandelbrot = min(dist_from_mandelbrot, dot(z,z));\n\n        //hc2 = min(hc2, HexCoords(prev_z).xy);\n    }\n\n    if(i >= ITERATIONS)\n        return vec3(0.);\n\n    float fraciter = log2( log(length(z)) / log(r) );\n    float j = float(i);\n    //j -= fraciter;\n\n    //float2 hc = HexCoords(dots_dist).xy;\n\n    //col = smoothstep(0,dist, sin(hc.y*15)*cos(hc.y*15));\n    //float dots_size = 1;\n    //float dots_smoothness = 0.9;\n    float dots = smoothstep(_DotsSize - _DotsSmoothness, _DotsSize, dots_dist);\n    //dots = smoothstep(0.9, 1, dots_dist);\n    dots = clamp(0.,1.,dots);\n\n    //col = smoothstep(0,dist, );\n    //float3 tex = tex2D(_MainTex, hc2);\n    //col = tex;\n    //col = dots;\n\n    vec3 beat = vec3(time*0.4);//(_smooth_bass2 + _smooth_mid2 + _smooth_treb2)*0.001 + (_bass2 + _mid2 + _treb2)*0.003;\n    // Color 1\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.75, 0.55, 0.85);\n    vec3 c1 = beat; // animate \\ offset\n    vec3 d1 = vec3(0.0, 0.1, 0.2);\n    // Color 2\n    vec3 a2 = vec3(0.5, 0.5, 0.5);\n    vec3 b2 = vec3(0.75, 0.55, 0.85);\n    vec3 c2 = vec3(1.0, 1.0, 0.5); // animate \\ offset\n    vec3 d2 = vec3(0.8, 0.9, 0.3);\n    // Color 3 - blue to gray\n    vec3 a3 = vec3(0.5, .5, 1.);\n    vec3 b3 = vec3(0.5, 0.5, 0.);\n    vec3 c3 = vec3(0., 0., 0.); // animate \\ offset\n    vec3 d3 = vec3(0., 0., 0.);\n    // Color 4 - black and white\n    vec3 a4 = vec3(1, 1, 1);\n    vec3 b4 = vec3(1.0, 1.0, 1.0);\n    vec3 c4 = vec3(1.0, 1.0, 1.0); // animate \\ offset\n    vec3 d4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 a5 = vec3(0.3, 0.27, 0.5);\n    vec3 b5 = vec3(0.9, 0.45, 0.75);\n    vec3 c5 = vec3(beat); // animate \\ offset\n    vec3 d5 = vec3(.8, 0.9, 0.25);\n    \n    // Color choise\n    //vec3 a = mix(a1, a2, 0.*time*0.02);\n    //vec3 b = mix(b1, b2, 0.*time*0.02);\n    //vec3 c = mix(c1, c2, 0.*time*0.02);\n    //vec3 d = mix(d1, d2, 0.*time*0.02);\n\n    vec3 col1 = a1 + b1 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d1 + c1));\n    vec3 col2 = a2 + b2 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d2 + time*0.2));\n    vec3 col3 = a3 + b3 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d3 + c3 ));\n    vec3 col4 = a4 + b4 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d4 + c4));\n    vec3 col5 = a5 + b5 * cos(2.*PI*(sqrt(j) * COLOR_REPEAT + d5 + c5));\n\tvec3 col6 = mix(col1, col5, abs(col1-col5));\n    col = col1;\n    \n    \n    //col = mix(col1, col4, 0.5 + 0.5*sin(float(i)));\n    //col = vec3(clamp(0.,1.,fraciter));\n    //col = mix(col, col2, fraciter);\n    //col = col2;\n    //col = vec3(dist_from_mandelbrot);\n\n    dist_from_mandelbrot = smoothstep(0., j/(MANDELBROT_SHADE), dist_from_mandelbrot);\n    //dist_from_mandelbrot = smoothstep(0, (_MandelbrotArea.z)*0.1, dist_from_mandelbrot); // shade depends on the zoom \n\n    dist_from_mandelbrot = clamp(0.,1.,dist_from_mandelbrot);\n\n    if(distance_type == HEX_DIST)\n    {\n        float leaves = smoothstep(0.,0.7,fraciter);\n        float leaves_edges = smoothstep(0.3,0.,fraciter);\n        //float leaves_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        //leaves_edges *= leaves_edges_tips;\n        col *= leaves;\n        //col += leaves_edges;\n        //col *= dist_from_mandelbrot;\n\n    }\n    if(distance_type == HAIR_DIST)\n    {\n        float hair = smoothstep(0.,0.9,fraciter);\n        float hair_edges = smoothstep(0.18,0.,fraciter);\n        float hair_edges_tips = smoothstep(-0.02,0.03,fraciter);\n        hair_edges *= hair_edges_tips; // to avoid pxieli edges of the hairs\n        col *= hair;\n        col += hair_edges;\n\n        // add dots\n        col *= (dist_from_mandelbrot);\n        //float id = j;\n        //float hash = N11(id + floor(-time*2));\n        //col += 0.1*(1-dist_from_mandelbrot) * (col3);\n        //col = col3;\n    }\n\n\n\n    //col = hash+0.1;\n\n\n    //col *= hair_edges2*dist_from_mandelbrot;\n    //col = col4;\n    //col = fraciter;\n\n    //col *= dots;\n    //col += (1-dots)*dist_from_mandelbrot*col3;\n    //col *= smoothstep(0.8,0.,fraciter);\n    //col = dots;\n    //col = fraciter;\n    //col = 1-dots;\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;// = fragCoord/iResolution.xy;\n    \n    float zoom = 0.001;\n    zoom = 3.;\n\n    #if 1\n    int AA = 2;\n    vec3 col = vec3(0.);\n    // anti-aliasing from https://www.shadertoy.com/view/Mss3R8\n\tfor( int j=0; j<AA; j++ )\n\tfor( int i=0; i<AA; i++ )\n\t{\n\t\tvec2 of = -0.5 + vec2( float(i), float(j) )/float(AA);\n\n        uv = (fragCoord+of)/iResolution.xy;\n        \n        uv*=zoom;\n        uv.x-= zoom/2.;\n        uv.y -= zoom/2.;\n        //uv += vec2(0.2013 ,0.052);\n\t   col += iterate( uv, HEX_DIST );\n\t}\n\tcol /= float(AA*AA);\n    \n    #else\n    \n    uv = fragCoord/iResolution.xy;\n    uv*=zoom;\n    uv.x-= zoom/2.;\n    uv.y -= zoom/2.;\n    uv += vec2(0.2013 ,0.052);\n\tvec3 col = iterate(uv, HEX_DIST);\n    \n    #endif\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 258, 258, 396], [397, 397, 420, 420, 522], [523, 523, 549, 549, 820], [821, 821, 858, 858, 1149], [1150, 1150, 1195, 1369, 7550], [7551, 7551, 7608, 7608, 8370]], "test": "valid"}
{"id": "WljczK", "name": "Noisy Colorful Cells", "author": "NightJolt", "description": "color and noise and color and noise and color and noise and cells", "tags": ["noise", "color", "cell"], "likes": 2, "viewed": 169, "published": "Public API", "date": "1594836666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 effect(vec2 p) {\n    float ang = iTime * 0.1;\n    mat2x2 rot = mat2x2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    \n    p *= rot;\n    \n    return p;\n}\n\nvec3 noise_map(vec2 p) {\n    vec2 cell = floor(p);\n    vec2 point = fract(p);\n    \n    float min_dist = 1.;\n    \n    for (int x= -1; x <= 1; x++) {\n        for (int y= -1; y <= 1; y++) {\n            vec2 new_cell = vec2(x, y);\n            vec2 new_point = random2(new_cell + cell);\n            \n            new_point = sin(new_point * sin(iTime * .4) * 5. + iTime) * .5 + .5;\n            \n            float dist = length(new_cell + new_point - point);\n            \n            min_dist = min(min_dist, dist);\n        }\n    }\n    \n    vec3 color = vec3(min_dist);\n    color *= color;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float screen_ratio = iResolution.x / iResolution.y;\n    //uv = fract(uv * 3.);\n    uv -= sin(iTime * .3) * .1 + .5;\n    uv.x *= screen_ratio;\n    vec3 color;\n    \n    uv *= 20.;\n    \n    uv = effect(uv);\n    \n    float offset_noise_x = noise_map(uv).x;    \n    float offset_noise_y = noise_map(uv + vec2(1., 1.)).x;\n    float offset_noise_z = noise_map(uv + vec2(2., 2.)).x;\n    \n    uv += (vec2(offset_noise_x) - .5) * .1;\n    color += vec3(offset_noise_x, offset_noise_y, offset_noise_z);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 115], [117, 117, 138, 138, 273], [275, 275, 299, 299, 882], [884, 884, 939, 939, 1517]], "test": "valid"}
{"id": "wljyDw", "name": "Julia Sets On Main Cardioid", "author": "centrinia", "description": "Julia sets with parameters on the boundary of the main cardioid of the Mandelbrot set.", "tags": ["fractal"], "likes": 0, "viewed": 39, "published": "Public", "date": "1594578784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float M_LN2 = 0.69314718055994530941723212145817656807;\nconst int M = 256;\nfloat mandelbrot(vec2 z, vec2 c) {\n\n    int i;\n    for(i=0;i<M;i++) {\n        z = vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y) + c;\n        if(dot(z,z) > 4.0) {\n            break;\n        }\n    }\n    if(i < M) {\n        float log_zn = log(dot(z,z))/4.0;\n        float nu = log(log_zn / M_LN2) / M_LN2;\n        return float(i + 1) - nu;\n    } else {\n        return float(M);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    float t = iTime/4.0;\n    \n    vec2 c = vec2(cos(t),sin(t));\n    c = vec2(1.0,0.0)-c;\n    c = vec2(c.x*c.x-c.y*c.y,2.0*c.x*c.y);\n    c = (vec2(1.0,0.0)-c)/4.0;\n        \n\tfloat m = mandelbrot(uv*4.0,c);\n    fragColor = vec4(mod(m,1.0),(sin(m)+1.0)/2.0,(sin(m*9.0)+1.0)/2.0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 115, 115, 451], [452, 452, 509, 559, 886]], "test": "valid"}
{"id": "wljyWc", "name": "Circle Pixel", "author": "Chindianese", "description": "Circle pixel", "tags": ["pixel"], "likes": 3, "viewed": 85, "published": "Public", "date": "1595601583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_CIRCLE_SIZE 0.95\n#define MIN_CIRCLE_SIZE 0.0\n#define CHANNEL iChannel2\n#define LINEAR 0\n#define DENSITY 120.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n\tfloat width = DENSITY;\n    float height = width;\n    width = iResolution.x * 0.001 * width;    \n    height = iResolution.y * 0.001 * height;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 position = fragCoord /iResolution.xy;\n    \n    position *= vec2(width, height);\n    position = ceil(position);\n    position /= vec2(width, height);\n    vec2 collPosition = position;\n    \n    vec4 cellColor = texture(CHANNEL, collPosition);\n    cellColor.w = 0.0;\n    float brightness = length(cellColor) / 1.7320508075688772;\n    \n    #if LINEAR\n    float circleSize = clamp((brightness),MIN_CIRCLE_SIZE, MAX_CIRCLE_SIZE);\n    #else\n     float circleSize = clamp(sqrt(brightness),MIN_CIRCLE_SIZE, MAX_CIRCLE_SIZE);\n    #endif\n\n    position -= uv;\n    position *= vec2(width, height);\n    position -= vec2(1,1) - position;\n    \n    vec2 circlePosition = vec2(1.0 - circleSize, 1.0-circleSize);\n    circlePosition -= position;\n    float distance = length(circlePosition);\n    \n    // uv /= vec2(width, height);\n\n\tcolor = cellColor * smoothstep(0.0f,circleSize - distance, 1.);\n\t\n    \n    fragColor = color;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 1368]], "test": "error"}
{"id": "wljyWG", "name": "RayMarching learning", "author": "Amirh", "description": "Learning to make sense of Ray Marching.\nAny feedback or suggestions appreciated!", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 36, "published": "Public", "date": "1595429618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST  100.0\n#define SURF_DIST 0.01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p - c)- r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n\n    vec3 c = a + t*ab;\n    \n    float x = length(p - c)- r;\n    float y = (abs(t - 0.5) - 0.4)*length(ab);\n    float e = length(max(vec2(x,y), 0.0));\n    float i = min(max(x,y), 0.0);\n    \n    return e + i;\n}\n\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat dCube(vec3 p, vec3 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\n\nfloat GetDist(vec3 p)\n{\n  vec4 s = vec4(0, 3, 8, 1);\n  \n  float sphereDist = length(p-s.xyz)-s.w;\n  float planeDist = p.y;\n\n  float cyld = sdCylinder(p, vec3(4, 1, 7), vec3(3, 4, 5), 0.3);  \n  float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n  float td = sdTorus(p-vec3(0, 0.5, 7), vec2(1.5, 0.5));\n  float bd = dCube(p - vec3(-3.0, 0.5, 6), vec3(0.5));\n    \n  float d = min(cd , planeDist);\n  d = min(d, sphereDist);\n  d = min(d , td);\n  d = min(d, bd);\n  d = min(d, cyld);\n    \n  return d;\n}\n\nfloat RayMarch (vec3 rayorg, vec3 raydir) {\n    float d0 = 0.;\n    \n    for (int i=0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayorg + raydir*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(d0 > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return d0;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight (vec3 p) \n{\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.0;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l);\n    if(d<length(lightPos-p)) dif *= 0.1;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 rayorg = vec3(0, 4, 0);\n    \n    vec3 raydir = normalize(vec3(uv.x, uv.y-0.4, 1));\n \n    float d = RayMarch( rayorg, raydir);\n    \n    vec3 p = rayorg + raydir * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 120, 120, 300], [302, 302, 353, 353, 651], [654, 654, 685, 685, 760], [762, 762, 791, 791, 834], [837, 837, 860, 860, 1341], [1343, 1343, 1386, 1386, 1619], [1621, 1621, 1645, 1645, 1838], [1841, 1841, 1867, 1867, 2179], [2182, 2182, 2239, 2239, 2603]], "test": "valid"}
{"id": "wljyWh", "name": "Octahedralis IV", "author": "sl2c", "description": "The \"Octahedralis\" shaders can all be described in terms of integers augmented with sqrt(-2) and this is a cohomology fractal effectively using the full symmetry group.", "tags": ["fractal", "circles", "hyperbolic"], "likes": 17, "viewed": 175, "published": "Public", "date": "1594313185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nfloat s = 0.4142135623730951; // silver ratio\n\nvoid octant1(inout vec3 z, inout float coh, inout bool fl) {\n    if (z.x < 0.0) {\n        z.x = -z.x;\n        coh=-coh;\n        fl=!fl;\n    }\n    if (z.y < 0.0) {\n        z.y = -z.y;\n        coh=-coh;\n        fl=!fl;\n    }\n    float r2 = dot(z,z);\n    if (r2 > 1.0) {\n        z /= r2;\n        coh=-coh;\n        fl=!fl;\n    }\n}\n\nvec3 color(vec3 z, float t) {\n    float coh = 0.0;\n    bool fl = false;\n    \n    float r2;\n    for(int i=0;i<40;i++) {\n        \n        octant1(z, coh, fl);\n        z -= vec3(s,s,0);\n        r2 = dot(z,z);\n        if (r2 < s * s) {\n            z *= s * s / r2;\n            fl = !fl;\n            coh = 1.0-coh;\n        }\n        z += vec3(s,s,0);\n        \n        \n        octant1(z, coh, fl);\n        \n        r2 = dot(z,z);\n        if (r2 < s*s) {\n            z *= s * s / r2;\n        }\n        z.y -= s + 1.0;\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n        }\n        z.y += s + 1.0;\n        \n        z.x -= s + 1.0;\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n        }\n        z.x += s + 1.0;\n        \n    }\n    octant1(z, coh, fl);\n    if (fl) {coh = -coh;}\n    coh -= t * 3.0;\n    coh = coh / (1.5 + abs(coh));\n    return vec3(0.5 + coh * 0.45);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    \n    float period = 4.2549485065150545;\n    float t = iTime * 0.5;\n    bool r = false;\n    \n    while (t > period * 0.5) {\n        t -= period;\n        float c = 0.766311365; float s = -0.64246936;\n        uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n        //r = !r;\n    }\n    \n    vec3 z = vec3(uv,ds); z*=3.5;\n    z *= exp(-t); ds *= exp(-t);\n    \n    z += vec3(0.25262046414724887,-1.0187347727326157,0);\n\tz /= dot(z,z);\n    z += vec3(0.22732631827540598,0.4228686518338363,0);\n\n    fragColor = vec4(color(z, t/period),1.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyWh.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[261, 261, 321, 321, 587], [589, 589, 618, 618, 1472], [1474, 1474, 1529, 1529, 2225]], "test": "valid"}
{"id": "wljyWK", "name": "RepSimpleScene", "author": "fayolle", "description": "Infinite repetition of simple CSG scene", "tags": ["repetition", "csg"], "likes": 1, "viewed": 45, "published": "Public", "date": "1595420605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\nfloat sdDiff(float f1, float f2)\n{\n  return min(f1, -f2);\n}\n\nfloat cylinderX(in vec3 p, in vec3 c, float r)\n{\n  float dy, dz;\n  dy = p.y - c.y;\n  dz = p.z - c.z;\n  return r - sqrt(dy * dy + dz * dz);\n}\n\nfloat cylinderY(in vec3 p, in vec3 c, float r)\n{\n  float dx, dz;\n  dx = p.x - c.x;\n  dz = p.z - c.z;\n  return r - sqrt(dx * dx + dz * dz);\n}\n\nfloat cylinderZ(in vec3 p, in vec3 c, float r)\n{\n  float dx, dy;\n  dx = p.x - c.x;\n  dy = p.y - c.y;\n  return r - sqrt(dx * dx + dy * dy);\n}\n\n// unit cube centered at origin\nfloat cube(in vec3 p)\n{\n  vec3 pl = p + 0.5;\n  vec3 pr = 0.5 - p;\n  return min(min(min(pl.x, pr.x), min(pl.y, pr.y)), min(pl.z, pr.z));\n}\n\nfloat sawtooth(in float f, in float period)\n{\n  float x;\n  float pi = 3.14159;\n  x = pi * (f * 0.5 / period - 0.5);\n  return 2.0 * (0.5 - asin(sin(x + pi / 2.0)) / pi) - 1.0;\n}\n\nfloat simpleScene(in vec3 p)\n{\n  float cu = cube(p);\n  float cx = cylinderX(p, vec3(0.0, 0.0, 0.0), 0.25);\n  float cy = cylinderY(p, vec3(0.0, 0.0, 0.0), 0.25);\n  float cz = cylinderZ(p, vec3(0.0, 0.0, 0.0), 0.25);\n  return sdDiff(sdDiff(sdDiff(cu, cx), cy), cz);\n}\n\nfloat repSimpleScene(in vec3 p)\n{\n  float xt, yt, zt, t = 0.25, sc;\n  xt = sawtooth(p.x, 1.0 - 0.5 * t);\n  yt = p.y; //sawtooth(p.y, 1.0-0.5*t);\n  zt = sawtooth(p.z, 1.0 - 0.5 * t);\n  vec3 pt = vec3(xt, yt, zt);\n  sc = simpleScene(pt);\n  return sc;\n}\n\n//------------------------------------------------------------------\n\nfloat map(in vec3 p)\n{\n  return -repSimpleScene(p);\n}\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n  float res = -1.0;\n\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  float t = tmin;\n  for (int i = 0; i < 70 && t < tmax; i++)\n  {\n    float h = map(ro + rd * t);\n    if (abs(h) < (0.0001 * t))\n    {\n      res = t;\n      break;\n    }\n    t += h;\n  }\n\n  return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n  return normalize(e.xyy * map(pos + e.xyy) +\n                   e.yyx * map(pos + e.yyx) +\n                   e.yxy * map(pos + e.yxy) +\n                   e.xxx * map(pos + e.xxx));\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y, 0.0) * 0.3;\n  float t = castRay(ro, rd);\n\n  if (t != -1.0)\n  {\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n\n    // material\n    col = 0.2 + 0.18 * sin(vec3(0.0, 0.5, 1.0));\n\n    // lighting\n    vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));\n    vec3 hal = normalize(lig - rd);\n    float amb = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.2, 0.2, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n    float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n                dif *\n                (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.80 * dif * vec3(1.30, 1.00, 0.70);\n    lin += 0.55 * amb * vec3(0.40, 0.60, 1.15);\n    lin += 0.85 * dom * vec3(0.40, 0.60, 1.30);\n    lin += 0.55 * bac * vec3(0.25, 0.25, 0.25);\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00);\n    col = col * lin;\n    col += 7.00 * spe * vec3(1.10, 0.90, 0.70);\n\n    col = mix(col, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));\n  }\n  else\n  {\n    col = vec3(1.0, 1.0, 1.0);\n  }\n\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize(cross(cw, cp));\n  vec3 cv = cross(cu, cw);\n  return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime * 1.5;\n\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n  vec3 ro = ta + vec3(4.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 4.5 * sin(0.1 * time + 6.0 * mo.x));\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  vec3 tot = vec3(0.0);\n#if AA > 1\n  for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++)\n    {\n      vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n      vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else\n  vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif\n\n      vec3 rd = ca * normalize(vec3(p, 2.5));\n      vec3 col = render(ro, rd);\n      col = pow(col, vec3(0.4545));\n      tot += col;\n\n#if AA > 1\n    }\n  tot /= float(AA * AA);\n#endif\n\n  fragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 48, 48, 73], [75, 75, 123, 123, 215], [217, 217, 265, 265, 357], [359, 359, 407, 407, 499], [501, 533, 556, 556, 670], [672, 672, 717, 717, 848], [850, 850, 880, 880, 1115], [1117, 1117, 1150, 1150, 1367], [1439, 1439, 1461, 1461, 1492], [1494, 1494, 1533, 1533, 1797], [1799, 1863, 1893, 1893, 2125], [2127, 2127, 2164, 2164, 3522], [3524, 3524, 3574, 3574, 3741]], "test": "valid"}
{"id": "wljyWR", "name": "Swiss cheese caves", "author": "jarble", "description": "This fractal is based on my [url=https://www.shadertoy.com/view/WtjyDz]\"alien hive.\"[/url] It looks more like a cave than a hive.", "tags": ["3d", "raymarching", "fractal"], "likes": 3, "viewed": 180, "published": "Public API", "date": "1594151414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx*i/3.0+p1/i)+p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 3;k++){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    float i = 3.0;\n    for(int k = 0; k < 3; k++){\n        //add bumps to the surface\n    \tresult -= sceneSDF1(p*i)/(i*9.0);\n        i *= 3.0;\n    }\n    return result*scale*200.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 622, 622, 722], [726, 726, 751, 751, 1017], [1019, 1019, 1042, 1042, 1257], [1259, 1259, 1287, 1287, 1405], [1408, 1829, 1920, 1920, 2244], [2259, 2513, 2578, 2578, 2710], [2712, 2801, 2830, 2830, 3140], [3142, 3634, 3774, 3774, 4384], [4386, 4756, 4841, 4841, 5256], [5258, 5585, 5634, 5669, 5800], [5802, 5802, 5859, 5859, 6931]], "test": "valid"}
{"id": "wljyz1", "name": "Sinusoids Wave 2D - v4: bump2", "author": "FabriceNeyret2", "description": "analytic version of [url]https://shadertoy.com/view/ttBczh[/url]\nbump map ( with constrant-contrast blending over 7x7 neighborhood )\n\n", "tags": ["bump", "2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 4, "viewed": 210, "published": "Public API", "date": "1593762552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// analytic version of https://shadertoy.com/view/ttBczh\n// variant of https://shadertoy.com/view/wtSczh\n// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y,  C,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    float d, o = 0., t = o, v;\n    for (int k=0; k<49; k++)\n        C = U - round((U+vec2(k%7-3,k/7-3))*.2) / .2 ,\n        V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(0.,1.-.05*dot(C,C)), d*=d*d*d,\n        v = length(V), V *= 36./v * cos(36.*v +(U-.2*C).x) ,\n        o += ( .4 + dot( V , cos(2.*iTime+vec2(0,11)) ) ) * d,\n        t += d*d;\n    t = ( .5 + .003*o/sqrt(t) )* smoothstep(1.,-1.,U.y -37.);\n    O += sqrt( t );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 239, 239, 793]], "test": "valid"}
{"id": "WllBzn", "name": "The croco", "author": "MonsieurSoleil", "description": "Why on earth did i do that ???", "tags": ["raymarchingtest"], "likes": 1, "viewed": 55, "published": "Public", "date": "1595856274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\nstruct matter\n{\n    float m;\n    int type;\n    bool reflected;\n    float shad;\n};\n    \nvec3 hash33(vec3 p)\n{\n  \tuvec3 q = uvec3(ivec3(p)) * UI3;\n    q = (q.x ^ q.y ^ q.z) * UI3;\n    return -1. + 2.0 * vec3(q) * UIF;\n}\n\nfloat worleyNoise(vec3 uv, float freq, bool tileable)\n{\n \tvec3 id = floor(uv);\n    vec3 p = fract(uv);\n    float minDist = 10000.0;\n    \n    for(float x = -1.; x <= 1.; ++x)\n    {\n     \tfor(float y = -1.; y <= 1.; ++y)\n        {\n         \tfor(float z = -1.; z <= 1.; ++z)\n            {\n             \tvec3 offset = vec3(x, y, z);\n                vec3 h = vec3(0.);\n                if(tileable)\n                    h = hash33(mod(id + offset, vec3(freq))) * 0.4 + 0.3;\n                else \n\t\t\t\t\th = hash33(id + offset) * 0.4 + 0.3;\n                h += offset;\n                vec3 d = p - h;\n                minDist = min(minDist, dot(d, d));\n\n            }\n        }\n    }\n\n\treturn 1.0 - minDist;\n}\n\nfloat worleyFbm(vec3 p, float freq, bool tileable)\n{\n    float fbm = worleyNoise(p * freq, freq, tileable) * .625 +\n\t\t\t\tworleyNoise(p * freq * 2.0, freq, tileable) * .25 +\n        \t\tworleyNoise(p * freq * 4.0, freq, tileable) * .125;\n    \n    return max(0., fbm * 1.1 - 0.1);\n}\n    \nvec3 tonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n    \nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n    \nmat2 rot(float a)\n{\n \tfloat ca = cos(a);\n    float sa = sin(a);\n    \n    return mat2(ca, sa, -sa, ca);\n}\n    \nvec2 hash( vec2 p )\n{\n    p= vec2( dot(p, vec2(127.11, 351.5)),\n       \t\tdot(p, vec2(2.65, 183.1)));\n    \n    return -1.0 + 2.0 * fract( sin(p) * 45687.2365);\n}\n\nvec2 hash22(vec2 x)\n{\n \treturn fract( sin( vec2( dot(x, vec2(12.4, 16.4)), dot(x, vec2(23.1, 28.37)))) * 12.4);   \n}\n\nvec3 random3f( vec3 p )\n{\n\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,4512.0,121546.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n    \nconst float pi = 3.14159;\n\nfloat gg = 0.0;\n\nfloat opSJ(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat opSS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5 * (d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat cyl(vec2 p, float s)\n{\n    return length(p) - s;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n \tfloat mat01, mat02, eye, museauHaut, museauBas, bouche, iris;\n    \n    vec3 p01 = p;\n    p01 = vec3(abs(p.x), p.yz);\n    vec3 p02 = p01, p03 = p01, p04 = p, p05 = p, p06 = p;\n    \n    // Tete globale\n    mat01 = sdRoundCone(p, vec3(0.0,0.0,0.0), vec3(0.0,0.5,3.25),  1.5, 0.5);\n    \n     //Coupe tête\n//\tmat01 = max(mat01, - box(p - vec3(0.0, -2.25, 0.0), vec3(15.0, 1.5, 15.0)));\n\n    //\tFormation Tete museau\n\t//mat01 = opSS(sphere(p - vec3(0.0, 1.55, 1.55), 0.45), mat01, 0.4);\n    //mat01 = opSS(sphere(p - vec3(0.0, 1.75, 1.25), 0.45), mat01, 0.3);\n    \n    \n    \n   \tmat01 = opSS(sdRoundCone(p, vec3(0.0,1.5,2.5), vec3(0.0,1.7,-1.0),  0.5, 0.5), mat01, 0.6);\n   \n    //mat01 = opSS(sphere(p - vec3(0.0, 1.85, 1.4), 1.05), mat01, 0.2);\n    \n    mat01 = opSS(cyl(p02.xz - vec2(1.5, 1.55), 0.3), mat01, 1.1);\n\tmat01 = opSS(cyl(p02.xz - vec2(1.2, 2.25), 0.3), mat01, 1.1);\n    mat01 = opSS(cyl(p02.xz - vec2(1.2, 1.05), 0.2), mat01, 0.7);\n    \n    \n    mat01 = opSS(sdRoundCone(p02, vec3(1.25,1.0,2.5), vec3(1.25,1.0,-1.0),  0.5, 0.1), mat01, 0.5);\n    \n    //mat01 = opSS(sphere(p - vec3(0.0, 1.75, 2.65), 1.0), mat01, 0.4);\n    \n    p03 -= vec3(0.3, 1.0, 3.3);\n    p03.xy *= rot(0.6);\n    //mat01 = opSJ(sdEllipsoid(p03 , vec3(0.25, 0.05, 0.2)), mat01, 0.4);\n\n    \n    // Machoire bas\n    mat01 = opSS(sdRoundCone(p, vec3(0.0,-0.0,3.5), vec3(0.0,-0.5,-0.0),  0.5, 0.7), mat01, 0.6);\n    p04.zy *= rot(0.1);\n    p04.zy *= rot(-0.4 * abs(sin(iTime * 1.75)));\n    \n    bouche = sdRoundCone(p04, vec3(0.0,0.2,3.0), vec3(0.0,-0.4,-0.0),  0.4, 0.7);\n    bouche = max(bouche, -box(p04 + vec3(0.0, -0.65, 0.0), vec3(2.0, 0.5, 5.0)));\n    \n    bouche = opSJ(sdEllipsoid(p04 - vec3(0.22, -0.0, 3.3), vec3(0.10, 0.200, 0.20)), bouche, 0.3);\n    bouche = opSJ(sdEllipsoid(p04 - vec3(-0.22, -0.0, 3.3), vec3(0.10, 0.200, 0.20)), bouche, 0.3);\n    \n    mat01 = min(mat01, bouche);\n    \n    //Tête nuque\n    mat01 = opSS(sphere(p - vec3(1.5, 0.55, -1.05), 0.6), mat01, 0.6);\n    mat01 = opSS(sphere(p - vec3(-1.5, 0.55, -1.05), 0.6), mat01, 0.6);\n    \n\tmat01 = opSS(sphere(p - vec3(0.0, 1.05, -1.50), 1.0), mat01, 0.4);\n    \n    //Coup corps\n    mat01 = opSJ(sdRoundCone(p, vec3(0.0,-2.0,0.25), vec3(0.0,-0.5, -0.5),1.2, 1.1), mat01, 0.7);\n\n    // Yeux\n    eye = sphere(p02 - vec3(0.85, 0.7, 0.455), 0.225);\n    iris = sphere(p02 - vec3(0.88, 0.72, 0.66), 0.080);\n    mat01 = opSJ(sdEllipsoid(p02 - vec3(0.28, 0.8, 3.4), vec3(0.15, 0.250, 0.25)), mat01, 0.2);\n    mat01 = opSS(cyl(p02.yz - vec2(1.35, 1.45), 0.35), mat01, 0.4);\n    \n    mat01 = max(mat01, -sdEllipsoid(p02 - vec3(0.52, 0.8, 3.55), vec3(0.2, 0.05, 0.14)));\n    \n    //mat01 = opSS(sphere(p - vec3(0.0, -0.55, -2.0), 1.45), mat01, 0.3);\n    \n    /*mat01 = opSS(sphere(p - vec3(0.0, 0.4, 1.25), 0.5), mat01, 0.5);\n\n    //Creux museau\n    //mat01 = min(sdRoundCone(p, vec3(0.0,0.65,2.25), vec3(0.0,0.9,0.5),  0.5, 0.2), mat01);\n    mat01 = opSS(sdRoundCone(p, vec3(0.0,1.1,2.25), vec3(0.0,0.9,0.5),  0.30, 0.2), mat01, 0.8);\n\n        //Creux tete\n        mat01 = opSS(sdRoundCone(p, vec3(0.0,1.7,-0.9), vec3(0.0,1.3,2.05),  1.2, 0.2), mat01, 0.8);\n        //mat01 = min(sdRoundCone(p, vec3(0.0,1.7,-0.5), vec3(0.0,1.4,2.05),  0.6, 0.2), mat01);\n\n        //CreuxCils\n        mat01 = opSS(sdRoundCone(p, vec3(1.5,0.3,-0.1), vec3(0.8,0.05,0.65), 0.25, 0.1), mat01, 0.25);\n        mat01 = opSS(sdRoundCone(p, vec3(-1.5,0.3,-0.1), vec3(-0.8,0.05,0.65), 0.25, 0.1), mat01, 0.25);\n\n        // Joues\n        mat01 = opSJ(mat01, sphere(p + vec3(0.8, 0.5, 0.0), 0.3), 0.8);\n        mat01 = opSJ(mat01, sphere(p + vec3(-0.8, 0.5, 0.0), 0.3), 0.8);\n\n\n\n        // Bouche\n        mat01 = opSS(sdRoundCone(p, vec3(0.0,-0.5,2.45), vec3(0.0,-0.5,0.6),  0.5, 0.7), mat01, 0.6);\n        //mat01 = min(sdRoundCone(p, vec3(0.0,-0.5,2.45), vec3(0.0,-0.5,0.6),  0.6, 0.7), mat01);\n\n        p05.yz *= rot(0.5 * abs(sin(iTime * 4.0)) + 0.0);\n        bouche = max(sdRoundCone(p05, vec3(0.0,-0.4,0.4), vec3(0.0,-0.3,1.5),  0.75, 0.5), -box(p05 - vec3(0.0, -0.05, 0.0), vec3(2.0, 0.3, 2.2)));\n\n        mat01 = opSJ(bouche, mat01, 0.15);\n\n            //Bouts naseaux\n            p03 = vec3(abs(p.x), p.yz);\n        p04 = p03;\n\n        p04 -= vec3(0.26, 0.295, 2.45);\n        p04.xy *= rot(-0.7);\n\n        mat01 = opSJ(sdEllipsoid(p04, vec3(0.25,0.15,0.25)), mat01, 0.28);\n\n\n\n            //Creux naseaux\n            p03 -= vec3(0.4, 0.215, 2.850);\n        p03.xy *= rot(-0.4);\n        mat01 = opSS(sdEllipsoid(p03, vec3(0.2,0.1,0.1)), mat01, 0.01);\n\n\n            // Ajustements\n            p06 = vec3(abs(p.x), p.yz);\n        float d1 = length(p06.xz - vec2(1.2, 1.85)) - 0.4;\n        mat01 = opSS(d1, mat01, 0.5);\n\n        float d2 = length(p.yz - vec2(1.3, 1.25)) - 0.3;\n        mat01 = opSS(d2, mat01, 0.9);\n\n        float d3 = length(p06.xz - vec2(1.2, 1.05)) - 0.2;\n        mat01 = opSS(d3, mat01, 0.2);\n\n        float d4 = length(p.yz - vec2(0.7, -0.85)) - 0.3;\n        mat01 = opSS(d4, mat01, 0.8);*/\n            //p03.zy *= rot(sin(iTime));\n\n            //museauHaut = sdCappedCone(p, vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), 0.15, 0.05);\n            /*museauHaut = box(p01 + vec3(0.0, -0.2, -1.5), \n        vec3(0.5 * (clamp(abs(1.0 - pow((p.y * 3.0), 2.6)) * \n        (abs(sin(1.0 - (p.z * 0.35)) * 1.0)), 0.0, 1.0 ))\n        , 0.055, \n        0.8 * (clamp(1.0 - p.y, 0.0, 1.0))));\n\n        museauBas = box(p03 + vec3(0.0, 0.1, -1.5), \n        vec3(0.5 * sin(1.0 - (p.z * 0.35))\n        , 0.055, \n        0.8));*/\n\n\n\n\n        \n\n       /*p02.xy *= rot(-0.1);\n        mat01 = min(mat01, sdEllipsoid(p02 - vec3(0.35, 0.7, 0.65), vec3(0.05, 0.1, 0.2)));*/\n\n\n        mat.m = mat01;\n\n        if(mat.m < 0.05)\n        {\n\n            float up = clamp(((p.y + 0.95) * 0.3), 0.0, 2.0);\n            if(up > 0.0)\n            {\n                vec3 v = voronoi(16.0*p);\n                mat.m -= 0.025 * (v.y-v.x) * up;\n                mat.type = 0;   \n            }\n        }\n\n        if(eye < 0.01)\n        {\n            mat.type = 1;   \n        }\n    \n        if(iris < 0.01)\n        {\n            mat.type = 2;   \n        }\n\n        mat.m = min(eye, mat.m);\n     \tmat.m = min(iris, mat.m);\n}\n\nvec3 normals(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n    \n    matter m01, m02, m03, m04;\n    \n    map(m01, p);\n    map(m02, p - uv.xyy);\n    map(m03, p - uv.yxy);\n    map(m04, p - uv.yyx);\n    \n    return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n\nvec3 subsurface( vec3 p, vec3 dir )\n{\nvec3 density = pow(vec3(0.7, 0.5, 0.4), vec3(0.4));\n  float confidence = .01;\n  vec3 visibility = vec3(1.0);\n    \n    matter m01;\n  map(m01, p);\n  float lastVal = m01.m; \n  float soft = 0.0;\n  for(int i = 1; i < 15; ++i)\n  {\n    if( visibility.x < confidence )\n    {\n      continue;\n    }\n    map(m01, p);\n    float val = m01.m;\n    \n    vec3 softened = pow(density, vec3(smoothstep(soft, -soft, val)));\n    \n    if( (val-soft) * lastVal < 0.0 )\n    {\n      float transition = -min(val-soft, lastVal)/abs(val-soft-lastVal);\n      visibility *= pow(softened, vec3(transition));\n    }\n    \n    else if( val-soft < 0.0 )\n    {\n      visibility *= softened;\n    }\n    \n    soft += 0.1;\n    lastVal = val+soft;\n    p += dir * 0.4;\n  }\n  \n  return visibility;\n}\n\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0)\n{\n  float alpha = rough*rough;\n  float asqrt = alpha*alpha;\n  vec3 h = normalize(v + l);\n  \n  float dnl = clamp(dot(n, l), 0.0, 1.0);\n  float dnv = clamp(dot(n, v), 0.0, 1.0);\n  float dnh = clamp(dot(n, h), 0.0, 1.0);\n  float dlh = clamp(dot(l, h), 0.0, 1.0);\n  \n  float f, d, vis;\n  float den = dnh*dnh*(asqrt - 1.0) + 1.0;\n  d = asqrt/(pi * den * den);\n  dlh = pow(1.0 - dlh, 5.0);\n  f = f0 + (1.0 - f0)*dlh;\n  float k = alpha/1.0;\n  vis = G1V(dnl, k)*G1V(dnv, k);\n  \n  \n  float spec = dnl * d * f *vis;\n  return spec;\n}\n\nfloat getao(vec3 p, vec3 n, float h)\n{\n  matter m01;\n  map(m01, p+n*h);\n  return clamp(m01.m / h, 0.0, 1.0);\n}\n\nfloat shadow(vec3 p, vec3 l, int stepC, float limit)\n{\n  matter m01;\n  for(int i = 0; i < stepC; ++i)\n  {\n     map(m01, p);\n    float d = m01.m;\n    \n    if(d < limit)\n    {\n      return 0.0;\n      break;\n    }\n    if(d > 20.0)\n    {\n     \treturn 1.0;   \n    }\n    \n    p += d * l;\n  }\n  \n   return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 l = vec3(0.0, 1.5, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 o = vec3(5.0 * cos(iTime * 0.3), 1.5, 5.0 * sin(iTime * 0.3)), t = vec3(0.0, 0.5, 1.2);\n    vec3 fr = normalize(t-o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p = dir * 0.5 + o;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    matter mat;\n    float dd = 0.0, shad = 0.0;\n    \n    for(int i = 0; i< 150; ++i)\n    {\n\t\tmap(mat, p);\n        \n        if(mat.m < 0.01)\n        {\n            shad = 1.0;\n            break;\n        }\n        \n        //col += gg *0.00375 * vec3(1.0);\n        \n        p += dir * mat.m * 0.75;\n        dd += mat.m* 0.75;\n        \n        /*if(dd >= 15.0)\n            break;*/\n    }\n    \n    vec3 n = normals(p);\n    float range = sqrt(dot(uv,uv));\n    //col += vec3(1.0) * clamp(dot(l, n), 0.0, 1.0) * shad;\n    float fog = clamp(dd/100.0, 0.0, 1.0);\n    //hsl(60,56%,91%)\n    vec3 Fogcolor = mix(vec3(0.5), vec3(0.2), pow(range * 0.75, 1.2));\n        \n     vec3 skycolor = mix(vec3(0.08, 0.38, 0.15), vec3(0.9, 0.85, 0.7), pow(1.0-(clamp(uv.y+0.5, 0.0, 1.0)), 0.7));\n    \n   if(shad >= 0.0)\n  {\n      \n    vec3 n = normals(p);\n    vec3 ld = normalize(l);\n    float fresnel = pow( max(0.0, 1.0 + dot(n, dir)), 3.0 );\n    \n    \n    vec3 albedo = vec3(1.0);\n    \n    vec3 lamb = vec3(max(0.0, dot(n, ld)));\n    float spec = ggx(n, dir, ld, 3.0, fresnel);\n\t\n    vec3 ss = subsurface(p, dir);\n\n    \n      \n\n    \n      \n      if(mat.type == 1 || mat.type == 2)\n      {\n          //lamb = mix(lamb, ss, 0.0);\n\t\t\t//col += (vec3(1.0) * spec + (lamb * vec3(1.0))) * 1.0;\n    \t\t//col += (vec3(1.0) * fresnel) * 1.0;\n          \t//col = vec3(1.0);\n          col = mat.type == 1 ? vec3(0.8, 0.6, 0.2) : vec3(0.0);\n          \n          \n      } else {\n          float up = clamp(((p.y + 0.85) * 1.5), 0.0, 1.0);\n\n          if(up > 0.0)\n          {\n              float r = worleyFbm(vec3(p.x, p.z, 1.0), 3.5, true);\n              float g = worleyFbm(vec3(p.x, p.z, 1.0), 0.5, true);\n              \n              skycolor = mix(skycolor, /*vec3(0.27, 0.44, 0.3)*/ vec3(0.05), g * up * 1.5);\n              skycolor = mix(skycolor, /*vec3(0.27, 0.44, 0.3)*/ vec3(0.67, 0.5, 0.1), r * up * 0.4);\n          }\n          \n          lamb = mix(lamb, ss, 0.2);\n          //float s = shadow(p + n * 0.15, l, 30, 0.075);\n          col += (vec3(1.0) * spec + (lamb * skycolor)) * 0.7;\n\n        //color += ((lamb * albedo));\n        //col += (skycolor * fresnel) * 1.0;\n          \n         float ao = 0.0;\n          for(int i = 0; i < 4; ++i)\n          {\n\t\t\t\n            ao += getao(p, n, float(i) * 0.50);\n          }\n          ao /= 4.0;\n          col *= ao;\n\t\t\n          \t\n          //col += clamp(dot(n, l), 0.0, 1.0) * vec3(1.0, 0.8, 0.6) * s;\n          //col += clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.0, 1.0) * vec3(0.5, 0.5, 1.0) * 0.5;\n          \n      }\n    \n  }\n   \tcol += fog * Fogcolor * 0.5;\n\n    col = tonemapACES(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 236, 236, 345], [347, 347, 402, 402, 1046], [1048, 1048, 1100, 1100, 1325], [1331, 1331, 1359, 1359, 1499], [1505, 1505, 1530, 1530, 1549], [1550, 1550, 1575, 1575, 1594], [1600, 1600, 1619, 1619, 1704], [1710, 1710, 1731, 1731, 1870], [1872, 1872, 1893, 1893, 1988], [1990, 1990, 2015, 2015, 2201], [2203, 2203, 2230, 2230, 2819], [2821, 2821, 2880, 2880, 2969], [2971, 2971, 3034, 3098, 3685], [3688, 3688, 3752, 3752, 4312], [4362, 4362, 4401, 4401, 4489], [4491, 4491, 4535, 4535, 4638], [4640, 4640, 4671, 4671, 4699], [4701, 4701, 4728, 4728, 4786], [4788, 4788, 4816, 4816, 4844], [4846, 4846, 4882, 4882, 10997], [10999, 10999, 11021, 11021, 11252], [11254, 11254, 11284, 11284, 11318], [11321, 11321, 11358, 11358, 12114], [12117, 12117, 12175, 12175, 12696], [12698, 12698, 12736, 12736, 12808], [12810, 12810, 12864, 12864, 13115], [13117, 13117, 13174, 13174, 16410]], "test": "valid"}
{"id": "wllfzN", "name": "very basic pattern in 3d", "author": "sirleto", "description": "camera can be moved to see the spherical pattern in 3d", "tags": ["basics"], "likes": 1, "viewed": 48, "published": "Public", "date": "1596229622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec3 cam = normalize(vec3(pow(iTime*0.1,2.0),uv));\n\n    float bg = length(sin(cam*2.5)*0.4+0.6)/sqrt(3.);\n  \tfragColor.xyz = vec3(pow(bg,3.));\n    fragColor.x *= sin(cam.x*700.);\n    fragColor.y *= cos(cam.y*700.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 340]], "test": "valid"}
{"id": "wlScRd", "name": "3D perlin noise", "author": "HalbFettKaese", "description": "Image takes a slice of 3D perlin noise. Location of slice depends on time.\n\nExcuse the messy random noise function, I might fix that later.", "tags": ["noise", "perlin"], "likes": 2, "viewed": 74, "published": "Public", "date": "1595079410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n\nint rand2(vec2 pixel, int seed) {\n\treturn int(4769.*fract(cos(floor(pixel.y-5234.)*755.)*245.* sin(floor(pixel.x-534.)*531.)*643.));\n}\n\nint rand3(vec3 uv, int seed) {\n\treturn int(4769.*fract(cos(floor(uv.y-5234.)*755.)*245.* sin(floor(uv.x-534.)*531.)*643.)*sin(floor(uv.z-53345.)*765.)*139.);\n}\n\nvec2 randVec2(vec2 pixel, int seed) {\n    int a = rand2(pixel, seed)*5237;\n    int p1 = (a & 1) * 2 - 1;\n    int p2 = (a & 2) - 1;\n    return vec2(p1, p2);\n}\n\nfloat fade(float t) {\n\treturn t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat lerp(float a, float b, float t) {\n\treturn a + fade(t) * (b - a);\n}\n\nfloat sinmix(float b1, float b2, float t) {\n    if (t <= 0.) return b1;\n    else if (t >= 1.) return b2;\n       \n    float s = sin(t*PI/2.);\n    return b1 * (1. - s) + b2 * s;\n    \n}\n\n\n\nfloat perlin2D(vec2 pixel, int seed) {\n    vec2 fp = fract(pixel);\n    float c1 = dot(fp, randVec2(floor(pixel), seed));\n    float c2 = dot(fp - vec2(1, 0), randVec2(floor(pixel) + vec2(1, 0), seed));\n    float c3 = dot(fp - vec2(0, 1), randVec2(floor(pixel) + vec2(0, 1), seed));\n    float c4 = dot(fp - vec2(1, 1), randVec2(floor(pixel) + vec2(1, 1), seed));\n    return (1. + \n            lerp(\n                lerp(c1, c2, fp.x), \n                lerp(c3, c4, fp.x), \n                fp.y)\n           )/2.;\n}\n\nfloat layeredPerlin2D(vec2 pixel, int layerNumber, float fade, float frequencyShift, int seed) {\n    float weight = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    int layer_seed = seed;\n    float final_range = 0.;\n    for (int i = 0; i < layerNumber; i++) {\n        result += perlin2D(pixel/frequency, layer_seed) * fade;\n        final_range += fade;\n        weight *= fade;\n        frequency *= frequencyShift;\n    \tlayer_seed = rand2(pixel, layer_seed);\n    }\n    return result/final_range;\n}\n\nvec3 randVec3(vec3 uv, int seed) {\n\tint a = rand3(uv, seed)*5237;\n    int p1 = (a & 1) * 2 - 1;\n    int p2 = (a & 2) - 1;\n    int p3 = (a & 4) / 2 - 1;\n    return vec3(p1, p2, p3);\n}\n\nfloat perlin3D(vec3 uv, int seed) {\n\tvec3 fuv = fract(uv);\n    float c1 = dot(fuv - vec3(0, 0, 0), randVec3(floor(uv) + vec3(0, 0, 0), seed));\n    float c2 = dot(fuv - vec3(0, 0, 1), randVec3(floor(uv) + vec3(0, 0, 1), seed));\n    float c3 = dot(fuv - vec3(0, 1, 0), randVec3(floor(uv) + vec3(0, 1, 0), seed));\n    float c4 = dot(fuv - vec3(0, 1, 1), randVec3(floor(uv) + vec3(0, 1, 1), seed));\n    float c5 = dot(fuv - vec3(1, 0, 0), randVec3(floor(uv) + vec3(1, 0, 0), seed));\n    float c6 = dot(fuv - vec3(1, 0, 1), randVec3(floor(uv) + vec3(1, 0, 1), seed));\n    float c7 = dot(fuv - vec3(1, 1, 0), randVec3(floor(uv) + vec3(1, 1, 0), seed));\n    float c8 = dot(fuv - vec3(1, 1, 1), randVec3(floor(uv) + vec3(1, 1, 1), seed));\n    return (1. + \n            lerp(\n        \t\tlerp(\n            \t\tlerp(c1, c2, fuv.z), \n                    lerp(c3, c4, fuv.z), \n                    fuv.y), \n                lerp(\n                    lerp(c5, c6, fuv.z), \n                    lerp(c7, c8, fuv.z), \n                    fuv.y), \n                fuv.x)\n           )/2.;\n}\n\nfloat layeredPerlin3D(vec3 uv, int layerNumber, float fade, float frequencyShift, int seed) {\n    float weight = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    int layer_seed = seed;\n    float final_range = 0.;\n    for (int i = 0; i < layerNumber; i++) {\n        result += perlin3D(uv/frequency, layer_seed) * fade;\n        final_range += fade;\n        weight *= fade;\n        frequency *= frequencyShift;\n    \tlayer_seed = rand3(uv, layer_seed);\n    }\n    return result/final_range;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    uv += (.0 - iMouse.xy);\n    uv = uv/iResolution.yy;\n    \n    uv *= 8.;\n    \n    vec2 polar = vec2(2.*atan(uv.x, uv.y), length(uv));\n    \n    \n    \n    //uv *= 20.;\n    \n    //float perlin = layeredPerlin3D(vec3(uv, iTime), 8, 2., 2., 4);\n    \n    vec3 col = vec3(0);\n    \n    float r = .25;\n        \n    vec2 samplePoint = polar.y * r * vec2(sin(polar.x), cos(polar.x));\n    \n    samplePoint *= layeredPerlin3D(vec3(5.*samplePoint+30., iTime), 8, 2., 2., 4);    \n    samplePoint = polar.y * r * vec2(sin(polar.x), cos(polar.x)) \n        * layeredPerlin3D(vec3(5.*samplePoint+30., iTime), 8, 2., 2., 4);\n    \n    polar.y *= layeredPerlin3D(vec3(10.*samplePoint+60., iTime), 20, 2., 2., 4);\n        \n    col += smoothstep(.25, .01, abs(mod(polar.y-iTime/4., .5) - r));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 63, 63, 164], [166, 166, 196, 196, 325], [327, 327, 364, 364, 484], [486, 486, 507, 507, 557], [559, 559, 598, 598, 631], [633, 633, 676, 676, 815], [819, 819, 857, 857, 1330], [1332, 1332, 1428, 1428, 1836], [1838, 1838, 1872, 1872, 2020], [2022, 2022, 2057, 2057, 3088], [3090, 3090, 3183, 3183, 3585], [3587, 3587, 3644, 3694, 4523]], "test": "valid"}
{"id": "WlScRW", "name": "Tuto: managing atan discontinuit", "author": "FabriceNeyret2", "description": "Left: atan() discontinuity spoils the hardware derivatives  ( white arc ) used for antialiasing circles (or anything else).\nRight: managing it.\nClick to directly display fwidth(U) or Jacobian", "tags": ["antialiasing", "derivative", "fwidth", "tuto", "discontinuity", "jacobian"], "likes": 7, "viewed": 355, "published": "Public API", "date": "1593779781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- Managing discontinuity when computing hardware derivatives ( -> Jacobian, fwidth )\n// See also: computing Jacobian to cancel distortions https://www.shadertoy.com/view/WlByRW\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I, z, \n         U = (u - .5*R) / R.y,                           // normalized coordinates\n         D = vec2(6,-1);\n\n    U*=2.; U-=.5; U/=dot(U,U); U+=.5;                    // distortion\n    float a = atan(U.y, U.x)/6.283;   \n    U = log(length(U)) +  a * D - .3*iTime;              // spiraling\n                       // a cause a discontinuity. unseen in spiral because param fits.\n    vec2 dFx = dFdx(U), dFy = dFdy(U); // but derivatives (fwidth,dFdx,dFdy) will get a +1 or -1 jump\n    if (u.x/R.x<.5)                                      // --- left: the naive way\n        z = fwidth(U);\n    else {                                               // --- right: eliminating the jump trough discontinuity\n        float dax = dFdx(a), day = dFdy(a),\n               dx = abs(dax) > .5 ? sign(dax) : 0.,      // detect the jump\n               dy = abs(day) > .5 ? sign(day) : 0.;      // ( jump is +- 1 since atan/2PI, 0.5 threshold is large )\n        dFx -= D*dx, dFy -= D*dy,                        // eliminates in derivatives\n        z = abs(dFx)+abs(dFy);                           // recomputes fwidth manually\n/* shorter:\n    dax = dFdx(a), day = dFdy(a);\n    dFX = dFdx(U) - ( abs(dax) > .5 ? D*sign(dax) : R-R ),\n    dFY = dFdy(U) - ( abs(day) > .5 ? D*sign(day) : R-R );  \n    -> Jacobian, det, width, length...\n*/     \n    }\n                                                         // --- display\n    U.x+=.5; I = round(U); U = fract(U);                 // show distorted checker  \n    O = vec4(.5*U,0,0); \n    \n    if (iMouse.z <= 0.)                                  // draw antialiased circles\n        O += smoothstep(3.*length(z),0., abs(length(U*2.-1.) - .5)-.01 ); \n    else {                                               // draw derivatives\n#if 1                                                    //   fwidth   \n        O += vec4(z,0,0);                                  \n     // O += length(z);              \n#else                                                    //   Jacobian   \n        mat2 M = inverse(transpose(mat2(dFx, dFy)))/R.y; // Jacobian to go back to screen\n        O  = vec4( .5+ M);\n     // O += max( 0., -30.*determinant(M)*R.y );\n#endif\n    }\n    if (abs(u.x-R.x/2.)<2.) O.b ++;                      // separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 220, 220, 2504]], "test": "valid"}
{"id": "wlScWD", "name": "方块显隐2", "author": "miracleYang", "description": "方块显隐2", "tags": ["2d"], "likes": 2, "viewed": 186, "published": "Public API", "date": "1594359404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.1415926;\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\nfloat aa = 0.;\nfloat radio=0.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x*=iResolution.x/iResolution.y;\n    //uv.x+=.011;\n    radio=iResolution.x/iResolution.y;\n    \n    \n    //uv= (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //vec2 screen = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float backgroundColor =1.0;\n    \n    vec3 col = vec3(0);\n    uv *= 5.;\n    \n    vec2 c = fract(uv);\n    \n    vec2 id = floor(uv)+.5;\n    float n=Hash21(id);\n    \n    float width=.1;\n    \n    float t = iTime;\n    aa = abs(sin(t));    \n    vec2 edge =sin(c*PI);\n    //edge.x-=clamp(aa*2.-n,width,1.);\n    edge.x-=width;\n    edge.y-=width*radio;\n    \n    float x= step(.01,edge.x);\n    float y= step(.01,edge.y);\n    if(x== 0.&& y==0.)\n    {\n        col=vec3(0);\n    }\n    else if(x== 1. && y==1.)\n    {\n        col=vec3(1);\n    }\n    if(n<1.)\n    {\n        n-=aa;\n        n=clamp(n,0.,1.);\n    }\n    col=n*col;\n    \n    //col.z=1.;\n    //col+=step(.01,edge.x);\n    //col*=step(.01,edge.y);\n    //col.y=edge.y;\n    col=mix(vec3(0.),col,backgroundColor);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 132], [133, 133, 150, 150, 270], [302, 302, 359, 409, 1476]], "test": "valid"}
{"id": "WlScWh", "name": "EarthBound Coffee Break", "author": "MakiXx", "description": "https://www.youtube.com/watch?v=QTsHiAzWweU", "tags": ["earthbound"], "likes": 2, "viewed": 152, "published": "Public", "date": "1595530948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\t#define K 0.142857142857 // 1/7\n\t#define Ko 0.428571428571 // 1/2-K/2\n\t#define K2 0.020408163265306 // 1/(7*7)\n\t#define Kz 0.166666666667 // 1/6\n\t#define Kzo 0.416666666667 // 1/2-1/6*2\n\t#define jitter 0.8 // smaller jitter gives less errors in F2\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n\tvec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 p1 = permute(p + Pi.z); // z+0\n\tvec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n\tvec4 ox1 = fract(p1*K) - Ko;\n\tvec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\n\tvec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract(p2*K) - Ko;\n\tvec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\n\tvec4 oz2 = floor(p2*K2)*Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter*ox1;\n\tvec4 dy1 = Pfy + jitter*oy1;\n\tvec4 dz1 = Pf.z + jitter*oz1;\n\tvec4 dx2 = Pfx + jitter*ox2;\n\tvec4 dy2 = Pfy + jitter*oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\td1 = min(d1, d2);\n\td1.xy = min(d1.xy, d1.wz);\n\td1.x = min(d1.x, d1.y);\n\treturn sqrt(d1.xx);\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min(d1,d2); // F1 is now in d\n\td2 = max(d1,d2); // Make sure we keep all candidates for F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n\td.y = min(d.y, d.z); // nor in d.z\n\td.y = min(d.y, d.w); // nor in d.w\n\td.y = min(d.y, d2.x); // F2 is now in d.y\n\treturn sqrt(d.xy); // F1 and F2\n#endif\n}\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// Copyright (c) 2020 Maki. All rights reserved.\n\n// precision mediump float;\n\nvec2 wobbly(vec2 uv, float speed, float repetition, float amount, float offset) {\n    return vec2(\n        uv.x,\n        uv.y + sin(uv.y * repetition + (iTime+offset) * speed) / amount\n    );\n}\n\nfloat bubbles(vec2 uv, float offset, float direction) {\n\tfloat zoom = 6.0;\n\n    uv*=zoom;\n\n    uv = wobbly(uv, 0.8, 0.17*zoom, 0.2*zoom, offset);\n    uv.x -= iTime * 0.3 * direction;\n    uv.y -= iTime * 0.8;\n\n\tvec2 F = cellular2x2x2(\n\t\tvec3(\n\t\t\tuv,\n\t\t\t(iTime + offset) * 0.2\n\t\t)\n\t);\n\n\tfloat maxSs = 0.33;\n\tfloat minSs = maxSs - 0.0001;\n\n\tfloat _size = 0.0;\n\tfloat ringVisibleWidth = 0.02;\n\tfloat ringInvisibleWidth = 0.045;\n\n\tfloat final = 1.0 - smoothstep(minSs, maxSs, F.x);\n\n\t_size += ringVisibleWidth;\n\tfinal -= 1.0 - smoothstep(minSs-_size, maxSs-_size, F.x);\n\t\n\tfor (int i=0; i<3; i++) {\n\t\t_size += ringInvisibleWidth;\n\t\tfinal += 1.0 - smoothstep(minSs-_size, maxSs-_size, F.x);\n\n\t\t_size += ringVisibleWidth;\n\t\tfinal -= 1.0 - smoothstep(minSs-_size, maxSs-_size, F.x);\n\t}\n\n\treturn clamp(final, 0.0, 1.0);\n}\n\nvec2 pixelateUV(vec2 uv, float amount) {\n\treturn floor(uv * amount) / amount;\n}\n\n#define colorBg vec3(1.0, 47.0, 113.0) / 255.0\n#define colorBlue vec3(8.0, 48.0, 170.0)/255.0\n#define colorGreen vec3(2.0, 87.0, 53.0)/255.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = pixelateUV(uv, 200.0);\n\n    float blueBubbles = bubbles(uv, 11512.11, 1.0);\n\tfloat blueOpacity = smoothstep(0.2, 0.6, noise((iTime + 11512.11) * 1.0));\n\tfloat blueCombined = clamp(blueBubbles * blueOpacity, 0.0, 1.0);\n\t\n    float greenBubbles = bubbles(uv, 82351.93, -1.0);\n\tfloat greenOpacity = smoothstep(0.2, 0.6, noise((iTime + 82351.93) * 1.0));\n\tfloat greenCombined = clamp(greenBubbles * greenOpacity, 0.0, 1.0);\n\t\n\tvec3 color = mix(\n\t\tmix(\n\t\t\tcolorBg, // a\n\t\t\tcolorBlue, // b\n\t\t\tblueCombined // alpha\n\t\t), // a\n\t\tcolorGreen, // b\n\t\tgreenCombined // alpha\n\t);\n\n\tfragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScWh.jpg", "access": "shaders20k", "license": "mit", "functions": [[217, 264, 286, 286, 331], [332, 332, 354, 354, 399], [401, 665, 693, 693, 2501], [2573, 2573, 2593, 2593, 2631], [2633, 2633, 2654, 2654, 2744], [2825, 2825, 2906, 2906, 3018], [3020, 3020, 3075, 3075, 3832], [3834, 3834, 3874, 3874, 3913], [4057, 4057, 4114, 4114, 4767]], "test": "valid"}
{"id": "wlScWy", "name": "Bugs in the Shrubs", "author": "dr2", "description": "Flight of the humongous dragonfly (mouseable)", "tags": ["tree", "forest", "flight", "dragonfly"], "likes": 10, "viewed": 244, "published": "Public API", "date": "1595246109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Bugs in the Shrubs\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat PrEllips2Df (vec3 p, vec2 r);\nfloat Minv3 (vec3 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 bugMat;\nvec3 bugPos, sunDir, qHit, trOff;\nvec2 gId;\nfloat tCur, tCyc, dstFar, hgSize, trSzFac, trTwist, trTrunk, trLeaf, bgSzFac, bgAngW[2], bgFreqW;\nint idObj;\nbool trCore;\nconst float trLay = 4.;\nconst int idWing = 11, idEye = 12, idBod = 13, idTail = 14, idMth = 15, idAnt = 16;\nconst float pi = 3.1415927, sqrt3 = 1.732051, phi = 1.618034;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPos (float t)\n{\n  return vec3 (10. * cos (0.1 * t) + 0.1 * t, 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (-0.1 * 10. * sin (0.1 * t) + 0.1, 0., 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (-0.1 * 0.01 * 10. * cos (0.1 * t), 0., 0);\n}\n\nfloat PathDst (vec2 p)\n{\n  float s;\n  s = abs (p.x - TrackPos (p.y).x) - 1.5;\n  return s * step (0., s) * step (0.5, Fbm2 (0.5 * p));\n}\n\nvoid SetTrConf ()\n{\n  vec2 hc;\n  if (PathDst (HexToPix (gId * hgSize)) == 0.) trSzFac = 0.;\n  else {\n    hc = Hashv2v2 (16.1 * gId + 0.3);\n    trSzFac = hgSize * 0.5 * sqrt3 * (0.8 - 0.4 * hc.x);\n    trTwist = phi * (1. + smoothstep (0.3, 0.7, hc.y));\n    hc = Hashv2v2 (17.1 * gId + 0.3);\n    trLeaf = 9. + floor (3. * hc.x);\n    trTrunk = 0.3 + 0.3 * hc.y;\n    hc = Hashv2v2 (18.1 * gId + 0.3);\n    trCore = (hc.x > 0.2);\n    trOff.xz = max (0., hgSize * 0.5 * sqrt3 - 1.1 * trSzFac) *\n       sin (2. * pi * hc.y + vec2 (0.5 * pi, 0.));\n    trOff.y = 0.;\n  }\n}\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, h, w, s, rMax, rMin;\n  dMin = dstFar;\n  if (trSzFac > 0.) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= trOff;\n    dMin /= trSzFac;\n    p /= trSzFac;\n    p.y -= 1.3 + 2. * trTrunk;\n    rMax = 1.;\n    rMin = 0.5;\n    if (trCore) {\n      q = p;\n      d = PrEllips2Df (q.xzy, vec2 (rMin, 1.3));\n      DMINQ (1 + int (trLay));\n    }\n    for (float k = float (VAR_ZERO); k < trLay; k ++) {\n      s = k / trLay;\n      r = mix (rMax, rMin, s);\n      h = 0.9 * s + 0.3;\n      q = p;\n      q.xz = Rot2D (q.xz, trTwist * s);\n      q.xz = Rot2D (q.xz, 2. * pi * floor (trLeaf * atan (q.z, - q.x) / (2. * pi) + 0.5) / trLeaf);\n      w = 0.5 * (1. - 0.3 * s) * r;\n      d = SmoothMax (abs (PrEllips2Df (q.xzy, vec2 (r, 1.3))) - 0.05 * (1. - 0.2 * q.y),\n         min (length (vec2 (q.y + w - h, abs (q.z) - w)) - w, q.y + w - h), 0.04 * (1. - 0.5 * s));\n      DMINQ (1 + int (k));\n    }\n    p.y -= - (1.3 + 2. * trTrunk);\n    q = p;\n    q.y -= trTrunk;\n    d = PrCylDf (q.xzy, 0.25 * (1. + 0.05 * sin (2. * pi * q.y / trTrunk)), trTrunk);\n    DMINQ (2 + int (trLay));\n    dMin *= 0.8 * trSzFac;\n  }\n  return dMin;\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjCDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjCDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjCSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    if (trSzFac > 0.) {\n      h = ObjCDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n      d += clamp (h, 0.1, 0.3);\n    } else d += 0.2 / max (0.1, length (rd.xz));\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b;\n  float dMin, d, bLen, wSpan, wr, tr, u;\n  bLen = 1.8;\n  wSpan = 3.;\n  p = bugMat * (p - bugPos);\n  dMin = dstFar / bgSzFac;\n  p /= bgSzFac;\n  p.z -= 0.2 * bLen;\n  b = vec2 (14., 3.) * max (0., abs (p.x) - 0.12 * bLen) / wSpan;\n  q = p;\n  q.yz -= bgAngW[0] * b;\n  d = PrEllCylDf (q.xzy, vec2 (0.96 * wSpan, 0.35), 0.01);\n  DMINQ (idWing);\n  q = p;\n  q.yz -= bgAngW[1] * b;\n  q.z -= 0.42 * bLen;\n  d = PrEllCylDf (q.xzy, vec2 (wSpan, 0.35), 0.01);\n  DMINQ (idWing);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.18, 0.07, bLen);\n  d = PrSphDf (q, 0.15);\n  DMINQ (idEye);\n  q = p;\n  wr = q.z / bLen;\n  if (wr > 0.5) {\n    u = 2. * (wr - 0.5);\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp (0.67 * (wr - 0.5), -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * bLen, bLen);\n  DMINQ (idBod);\n  q.yz -= bLen * vec2 (0.1 * (wr + 1.) * (wr + 1.), -1.8);\n  d = PrCylDf (q, 0.018, 0.8 * bLen);\n  DMINQ (idTail);\n  q = p;\n  q.yz -= vec2 (-0.06, 1.03 * bLen);\n  d = PrSphDf (q, 0.06);\n  DMINQ (idMth);\n  q = p;\n  wr = q.y / bLen;\n  q.x = abs (q.x) - 0.1;\n  q.xz -= 1.5 * wr * wr;\n  q.yz -= vec2 (0.34, 0.9 * bLen);\n  d = PrCylDf (q.xzy, 0.025 - 0.25 * wr * wr, 0.2);\n  DMINQ (idAnt);\n  return 0.8 * dMin * bgSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat WingPat ()\n{\n  vec4 b;\n  vec2 bb;\n  float ds;\n  b = (8. * (vec4 (-1.2, -0.5, -0.18, -0.05) * abs (qHit.x) +\n     max (qHit.z, - qHit.z)) + vec4 (1.65, 0.725, 0.225, 0.1)) /\n     vec4 (0.1, 0.075, 0.075, 0.075);\n  bb = b.xz + step (abs (b.yw), abs (b.xz)) * (b.yw - b.xz);\n  ds = bb.x + step (abs (bb.y), abs (bb.x)) * (bb.y - bb.x);\n  ds = sqrt (max (0., 1. - ds * ds)) * sign (ds);\n  return ds;\n}\n\nvec4 BugCol (float ds)\n{\n  vec4 col4;\n  vec4 wCol = vec4 (0.9, 0.9, 0.7, 0.3);\n  vec4 bCol = vec4 (0., 0.2, 1., 0.2);\n  if (idObj == idWing) {\n    col4 = wCol * (1. + 0.2 * abs (ds));\n  } else if (idObj == idEye) {\n    col4 = (qHit.z < 0.05) ? bCol : vec4 (0.8, 0.8, 0.9, -1.);\n  } else if (idObj == idBod) {\n    col4 = bCol;\n    if (qHit.y > 0.) col4 = mix (col4, vec4 (0.9, 0.3, 0., 0.1), \n       smoothstep (-1., -0.5, qHit.z) * (1. - smoothstep (0., 0.1, abs (qHit.x))));\n    else col4 = mix (col4, wCol, smoothstep (-1., -0.5, qHit.z) *\n       (1. - smoothstep (0., 0.1, abs (qHit.x)))) *\n       (0.5 + 0.5 * smoothstep (0.01, 0.02, abs (qHit.x)));\n  } else if (idObj == idTail) {\n    col4 = bCol;\n    if (qHit.z < -1.3) col4 = vec4 (0.9, 0., 0., -1.);\n  } else if (idObj == idMth) {\n    col4 = vec4 (0.9, 0.6, 0.2, 0.1);\n  } else if (idObj == idAnt) {\n    col4 = vec4 (0.3, 0.8, 0.3, 0.1);\n  }\n  return col4;\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.1, 0.35, 0.1), vec3 (0.3, 0.35, 0.35),\n       smoothstep (-0.02, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  }\n  return col;\n}\n\nvec3 GrndCol (vec3 p, float dh, vec3 rd, vec3 roo)\n{     // aliasing reduced by smoothing - see iq's \"Filtering procedurals\"\n  vec4 c;\n  vec3 rdx, rdy, dp;\n  rdx = rd + 0.0005 * vec3 (normalize (vec3 (- roo.z, 0., roo.x)).x, 0., 0.);\n  rdy = rd + 0.0005 * vec3 (0., normalize (cross (vec3 (- roo.z, 0., roo.x), roo)).y, 0.);\n  rdx = dh * (rdx * rd.y / rdx.y - rd);\n  rdy = dh * (rdy * rd.y / rdy.y - rd);\n  c = vec4 (0.);\n  for (float k = float (VAR_ZERO); k < 5.; k ++) {\n    dp = (k == 0.) ? vec3 (0., 0., 1.) : vec3 (2. * mod (k, 2.) - 1., sign (k - 2.5), 0.25);\n    dp.xy = dp.x * rdx.xz + dp.y * rdy.xz;\n    c += dp.z * vec4 (mix (vec3 (0.25, 0.25, 0.), vec3 (0.1, 0.5, 0.2),\n       smoothstep (0.4, 0.6, Fbm2 (2. * (p.xz + dp.xy)))), 1.);\n  }\n  return c.xyz / c.w;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, roo, vn, q;\n  vec2 hc, b, cs, vf;\n  float dstObj, dstObjC, dstObjB, dstGrnd, dFac, sh, ao, ds, f;\n  int idObjC;\n  bool isSky;\n  isSky = false;\n  bgFreqW = 10.;\n  bgAngW[0] = 0.1 * (cos (bgFreqW * tCur) + 0.3);\n  bgAngW[1] = 0.12 * (cos (bgFreqW * tCur + 0.3 * pi) + 0.3);\n  dstObjC = ObjCRay (ro, rd);\n  idObjC = idObj;\n  roo = ro;\n  dstGrnd = dstFar;\n  dstObjB = ObjRay (ro, rd);\n  dstObj = min (dstObjB, dstObjC);\n  vf = vec2 (0.);\n  ao = 1.;\n  sh = 1.;\n  if (dstObj < dstFar) {\n    dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n    if (dstObjB < dstObjC) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      ds = (idObj == idWing) ? WingPat () : 0.;\n      col4 = BugCol (ds);\n      if (idObj == idWing && ds != 0.) {\n        vn = bugMat * vn;\n        vn.yz = clamp (vn.yz - 0.2 * vec2 (sqrt (1. - ds * ds), ds), -1., 1.);\n        vn = normalize (vn) * bugMat;\n      }\n    } else {\n      ro += dstObj * rd;\n      vn = ObjCNf (ro);\n      q = ro;\n      q.xz -= HexToPix (gId * hgSize);\n      hc = Hashv2v2 (27.1 * gId + 0.1);\n      b = q.xz - trOff.xz;\n      idObj = idObjC;\n      if (idObj < 1 + int (trLay)) {\n        f = float (idObj) / trLay;\n        col4 = mix (vec4 (HsvToRgb (vec3 (0.15 * hc.x, 0.8, 0.6)), 0.),\n           vec4 (HsvToRgb (vec3 (0.2 + 0.3 * hc.y, 0.8, 1.)), 0.1), f);\n        if (dot (b, vn.xz) > 0.) {\n          b = Rot2D (b, trTwist * (float (idObj - 1) / trLay));\n          cs = sin (4. * trLeaf * atan (b.y, - b.x) + vec2 (0.5 * pi, 0.)) * dFac;\n          col4 *= 0.95 - 0.05 * cs.x;\n          vn.xz = Rot2D (vn.xz, 0.1 * pi * cs.y);\n        } else col4 *= 0.3;\n        if (dFac > 0.) vf = vec2 (32., 0.8 - 0.6 * smoothstep (0.1, 0.7, f));\n      } else if (idObj == 1 + int (trLay)) {\n        col4 = vec4 (HsvToRgb (vec3 (0.2 + 0.3 * hc.y, 1., 1.)), 0.1);\n      } else  if (idObj == 2 + int (trLay)) {\n        col4 = vec4 (0.3, 0.2, 0.1, 0.) * (0.85 + 0.15 * sin (32. * atan (b.y, - b.x) +\n           0.2 * pi * sin (4. * pi * ro.y)));\n        vf = vec2 (32., 1.);\n      }\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    if (dstGrnd < dstFar) {\n      vf = vec2 (2., 3. * (1. - smoothstep (0.1, 0.15, dstGrnd / dstFar)));\n      col4 = vec4 (GrndCol (ro, dstGrnd, rd, roo), 0.05);\n      gId = PixToHex (ro.xz / hgSize);\n      SetTrConf ();\n      if (trSzFac > 0.) ao = 0.5 + 0.5 * smoothstep (0.3, 1.,\n         length (ro.xz - HexToPix (gId * hgSize) - trOff.xz) / trSzFac);\n      else col4 += 0.7 * pow (Noisefv2 (64. * ro.xz), 32.) * \n         (1. - smoothstep (0.12, 0.15, dstGrnd / dstFar));\n    } else col4 = vec4 (0.1, 0.35, 0.1, 0.);\n  } else isSky = true;\n  if (! isSky) {\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = min (ao, min (ObjCSShadow (ro, sunDir), ObjSShadow (ro, sunDir)));\n    f = dot (vn, sunDir);\n    if (col4.a >= 0.) {\n      col = col4.rgb * (ao * (0.15 + 0.15 * max (- f, 0.)) + 0.8 * sh * max (f, 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else {\n      rd = reflect (rd, vn);\n      rd.yz = Rot2D (rd.yz, 0.1);\n      col = mix (col4.rgb * (0.8 - 0.2 * dot (vn, rd)), SkyHrzCol (ro, rd), 0.6);\n    }\n    col = mix (col, SkyHrzCol (roo, rd), smoothstep (0.8, 0.95, min (dstGrnd, dstObj) / dstFar));\n  } else col = SkyHrzCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid BugPM (float t, float s)\n{\n  vec3 vd, cb, sb;\n  float flPit, flYaw, flRol, a;\n  bugPos = TrackPos (t);\n  vd = TrackVel (t);\n  a = SmoothBump (0.35, 0.65, 0.1, mod (tCur / tCyc, 1.));\n  flPit = 0.05 * pi * s;\n  flYaw = 0.5 * pi - atan (vd.z, - vd.x);\n  flRol = 60. * TrackAcc (t).x + 0.7 * (Fbm1 (2. * tCur) - 0.5);\n  if (s > 0.) {\n    flYaw += pi * a * sign (mod (tCur / tCyc, 2.) - 1.);\n    flRol *= (2. * a - 1.);\n  }\n  cb = cos (vec3 (flPit, flYaw, flRol));\n  sb = sin (vec3 (flPit, flYaw, flRol));\n  bugMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, spd, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 1.;\n  bgSzFac = 0.1;\n  tCyc = 10.;\n  az = 0.;\n  el = -0.02 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.1 * pi);\n  spd = 1.;\n  ro = TrackPos (spd * tCur);\n  ro.y = 1.2 + 0.3 * sin (2. * pi * (0.04 * tCur));\n  vd = TrackVel (spd * tCur);\n  az += atan (vd.x, vd.z);\n  s = abs (az) > 0.5 * pi ? -1. : 1.;\n  BugPM (spd * tCur + (3. - 2. * SmoothBump (0.35, 0.65, 0.1, mod (tCur / tCyc, 1.))) * s, s);\n  bugPos.y = 1.2 + 0.35 * sin (2. * pi * (0.04 * tCur + 0.05 * s)) + 0.05 * (Fbm1 (tCur) - 0.5);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.5;\n  sunDir = normalize (vec3 (0., 1., -0.7));\n  dstFar = 100.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1269, 1269, 1294, 1294, 1350], [1352, 1352, 1377, 1377, 1437], [1439, 1439, 1464, 1464, 1524], [1526, 1526, 1550, 1550, 1661], [1663, 1663, 1682, 1682, 2225], [2227, 2227, 2250, 2250, 3384], [3386, 3386, 3420, 3420, 4693], [4695, 4695, 4717, 4717, 4973], [4975, 4975, 5013, 5013, 5500], [5502, 5502, 5524, 5524, 6795], [6797, 6797, 6830, 6830, 7013], [7015, 7015, 7036, 7036, 7291], [7293, 7293, 7330, 7330, 7597], [7599, 7599, 7617, 7617, 8002], [8004, 8004, 8028, 8028, 8920], [8922, 8922, 8957, 8957, 9709], [9711, 9711, 9763, 9835, 10483], [13921, 13921, 13952, 13952, 14622], [14624, 14624, 14680, 14680, 15839], [15841, 15841, 15874, 15874, 15901], [15903, 15903, 15945, 15945, 15996], [15998, 15998, 16041, 16041, 16105], [16107, 16107, 16143, 16143, 16198], [16200, 16200, 16244, 16244, 16319], [16321, 16321, 16366, 16366, 16469], [16471, 16471, 16516, 16516, 16554], [16556, 16556, 16613, 16613, 16696], [16698, 16698, 16734, 16734, 16940], [16942, 16942, 16964, 16964, 17002], [17004, 17004, 17028, 17028, 17258], [17260, 17260, 17284, 17284, 17344], [17346, 17346, 17376, 17376, 17489], [17491, 17491, 17515, 17515, 17632], [17666, 17666, 17690, 17690, 17750], [17752, 17752, 17776, 17776, 17829], [17831, 17831, 17855, 17855, 17967], [17969, 17969, 17994, 17994, 18140], [18142, 18142, 18167, 18167, 18353], [18355, 18355, 18377, 18377, 18531], [18533, 18533, 18554, 18554, 18709], [18711, 18711, 18740, 18740, 18952], [18954, 18954, 18993, 18993, 19173]], "test": "error"}
{"id": "WlSczD", "name": "Boze Cell", "author": "kaiware007", "description": "One in all...\nAll in one...", "tags": ["raymarching"], "likes": 2, "viewed": 57, "published": "Public", "date": "1593872639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define AA 2\n    \nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nstruct surface {\n\tfloat dist;\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec3(0,1,1), \t\t vec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec3(0.),        vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec3(1,0.7,0.6), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec3(1,0,0.1),   vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec3(1,0.3,0.4), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    vec3 index = floor(pos * 10. + 0.5);\n    vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n#define SURF_CS(d) \t\t(surface(d, vec3(0.9), vec3(0,0,0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec3(0), vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec3(0,1,0), vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec3(1,0,0), vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_TUBE(d) \t(surface(d, vec3(1,0.2,0.3), vec3(0), 0.1, 0.1, 0, false, 2.2, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec3 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.2 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    //p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    //p = opBendXZ(p + vec3(0.03, 0, 0) * sc, 0.1);\n    //p = opBendXZ(p + vec3(0.015, 0, 0.1) * sc, 2.5 * sc);\n    //p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(-0.2,0.8,0));\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    //float sl = sc.x * sc.y * sc.z;\n    //float sl = 1.;\n    float minsc = min(sc.x, min(sc.y, sc.z));\n\t//vec3 sc2 = 1.0/sc;\n    //float dist = someSDF(samplePoint / vec3(s_x, s_y, s_z)) * min(s_x, min(s_y, s_z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    //result = opU(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, float hue)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    //float sl = sc.x * sc.y * sc.z;\n    //float sl = 1.;\n    float minsc = min(sc.x, min(sc.y, sc.z));\n\t//vec3 sc2 = 1.0/sc;\n    //float dist = someSDF(samplePoint / vec3(s_x, s_y, s_z)) * min(s_x, min(s_y, s_z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo = sinebow(hue);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    //result = opU(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 getPoint3D(vec3 id, vec3 offset)\n{\n    //return sin(hash33(id + offset) * iTime * 1.5 + hash33(id + offset)) * 0.2 + offset;\n    //return hash33(id + offset) * 0.3 - 0.15 + offset;\n    return hash33(id + offset) * 0.3 - 0.15 + offset + sin(hash33(id + offset) * iTime * 1.5) * 0.05;\n    //return offset;\n}\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(MAX_DIST);\n    //p = rotate(p, (p.z * 0.1), vec3(0,0,1));\n\t//p -= vec3(0.25);\n    p.xy *= rot(sin(p.z * 0.5) * 0.3);\n        \n    // rotate\n    //float r = 3.14159*sin(p.z*0.15)+iTime*0.25;\n    //mat2 R = mat2(cos(r), sin(r), -sin(r), cos(r));\n    //p.xy *= R;\n    //vec3 op = p;\n    \n    vec3 index = floor(p + 0.5);\n\tfloat h = hash13(index);\n    float t = iTime * (0.75 + h * 0.25) * M_PI2;\n    \n    vec3 q = opRep(p, vec3(1., 1., 1.));\n    //q = rotate(q, h * M_PI2, vec3(0,1,0));\n    \n    //float sc = mix(0.5, 1., abs(sin(t)*0.9)+0.1);\n    float tp = h * M_PI + t;\n    float sc = abs(sin(tp));\n\t//float scxz = sc * 0.75 + 0.25;\n    //vec3 offset = hash33(index) * 2. - 1.0;\n    //vec3 offset = vec3(0.25, 0, 0);\n    vec3 pp = getPoint3D(index, vec3(0));\n    \n    vec3 q2 = q - pp;\n    q2 = rotate(q2, t *0.1, normalize(pp+vec3(0.000001,0,0)));\n    \n    float hue = noise(abs(p) * 5.5 + t*0.2)*0.33-0.2;\n    //float sc = 1.;\n    //result = SURF_SPHERE(sdSphere(p - vec3(0,0.125,0), 0.2));\n    //result = sdBoze(p, vec3(1., 1., 0.75), sin(t*3.)*0.5 + 0.5);\n\t//result = sdBoze(q + vec3(0, abs(cos(tp))*-0.2+0.15, 0), vec3(scxz, 1.1-easeInExpo(sc)*0.9, scxz), 1.);\n    //result = sdBoze(p, vec3(1., 2., 1.), sin(t*3.)*0.5 + 0.5);\n    //result = SURF_SPHERE2(sdSphere(q2, 0.1));\n    //result = sdBoze(q2, vec3(1.) + sc * 0.1, sin(t*3.)*0.5 + 0.5);\n    //result = sdColorBoze(q2, vec3(1.) + sc * 0.1, sin(t*3.)*0.5 + 0.5, cos(p.z * 0.1 + t*0.1) * 0.5 + 0.5);\n    //result = sdColorBoze(q2, vec3(1.) + sc * 0.1, sin(t*3.)*0.5 + 0.5, cos(t*0.1) * 0.5 + 0.5);\n    result = sdColorBoze(q2, vec3(1.) + sc * 0.1, sin(t*3.)*0.5 + 0.5, hue);\n    \n    /*\n    const vec3[13] positions = vec3[13] (\n    \tvec3(0,0,1),\n\t\tvec3(1,0,1),\n\t\tvec3(1,0,0),\n\t\tvec3(0,1,0),\n\t\tvec3(0,1,1),\n\t\tvec3(1,1,1),\n\t\tvec3(1,1,0),\n\t\tvec3(1,-1,1),\n\t\tvec3(1,-1,0),\n\t\tvec3(1,-1,-1),\n\t\tvec3(1,0,-1),\n\t\tvec3(0,1,-1),\n\t\tvec3(1,1,-1)\n    );\n    \n    // grid line\n    for(int i = 0; i < 13; i++) {\n        vec3 pos = getPoint3D(index, positions[i]);\n                \n        if(length(pos - pp) > 1.0)\n            continue;\n\n        surface tube = SURF_TUBE(sdCapsule(q, pos, pp, 0.01));\n        tube.albedo = sinebow(hash13(index + positions[i]));\n\n        //result = opU(result, tube);\n        result = opSU(result, tube, 0.05);\n    }\n\t*/\n    /*\n    for(int x = -1; x <= 1; x++) {\n    \tfor(int y = -1; y <= 1; y++) {\n            for(int z = -1; z <= 1; z++) {\n                if(x==0 && y==0 && z==0)\n                    continue;\n                \n            \tvec3 pos = getPoint3D(index, vec3(x,y,z));\n                \n                if(length(pos - pp) > 1.0)\n                    continue;\n                \n                surface tube = SURF_TUBE(sdCapsule(q, pos, pp, 0.05));\n                //tube.albedo = sinebow(hash13(pos));\n                                      \n                //result = opU(result, tube);\n                result = opSU(result, tube, 0.1);\n            }\n        }\n    }\n\t*/\n    \n    vec3 col = sinebow(hue);\n    float t2 = iTime * M_PI2 * 2.;\n    for(int i = -1; i <= 1; i++) {\n        if(i==0)\n            continue;\n\n        // x\n        vec3 pos = getPoint3D(index, vec3(i,0,0));\n\t\tfloat ofs = sin((p.x - p.z) * 20. + t2) * 0.01;\n        surface tube = SURF_TUBE(sdCapsule(q, pos, pp, 0.025 + ofs));\n        tube.albedo = col;\n        result = opSU(result, tube, 0.1);\n        \n        // y\n        pos = getPoint3D(index, vec3(0,i,0));\n\t\tofs = sin((p.y - p.z) * 20. + t2) * 0.01;\n        tube = SURF_TUBE(sdCapsule(q, pos, pp, 0.025 + ofs));\n        tube.albedo = col;\n        result = opSU(result, tube, 0.1);\n        \n        // z\n        pos = getPoint3D(index, vec3(0,0,i));\n        ofs = sin(p.z * 20. + t2) * 0.01;\n        tube = SURF_TUBE(sdCapsule(q, pos, pp, 0.025 + ofs));\n        tube.albedo = col;\n        result = opSU(result, tube, 0.1);\n    }\n\n       \n    /*\n    /////\n        vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec3 pos = getPoint3D(index, vec3(x,y,z));\n            \n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n    /////\n\t*/\n    //vec3 sc = hash33(index) *0 .5+ 0.5;\n    //vec3 sc = noised(index.xy * 512. + index.y * 333. + t * 0.25) * 0.4 + 0.6;\n    //result = sdBoze(q, sc, sin(t*3.)*0.5 + 0.5);\n    \n        \n    //result = opU(boze1, boze2);\n    //result = boze2;\n    //result = opU(opU(boze1, boze2), boze3);\n    //result = sdBoze(p, 1., sin(t*3.)*0.5 + 0.5);\n    //result = opSU(sdBoze(p + vec3(cos(t)*-0.05-0.05,0.05,0), 1., cos(t * 3.8)*0.5+0.5), result, 0.01);\n\t//result = opU(result, SURF_CUBE(sdRoundBox(p - vec3(0.5,0.125,0), vec3(0.25), 0.01)));\n    \n    //result = opU(result, SURF_SPHERE2(sdSphere(p - vec3(-0.5,0.125,0), 0.2)));\n    \n    // background\n    //surface bg1 = SURF_BG1(sdPlane(p + vec3(0., 0.15, 0.), vec4(0,1,0,0)), p);\n    //surface bg1 = SURF_BG1(sdBox(p + vec3(0., 1.15, 0.), vec3(0.75,1.0,0.75)), p);\n    //result = opU(result, bg1);\n    /*\n    vec3 index = floor(p * 2. + 0.5);\n    float rnd = hash13(vec3(index.x,0,index.z));\n    vec3 rnd3 = hash33(vec3(index.x,0,index.z));\n    \n    //vec3 q = opRep(p, vec3(0.5, 5., 0.5));\n    q = TwistY(q, 2.*M_PI2);\n    q = rotate(q, t+rnd*M_PI2, vec3(0,1,0));\n    q += vec3(0.02,0,0.02);\n    float w = 0.025;\n    //vec3 col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    vec3 col = sinebow(rnd + iTime * 3.5) * saturate(noise(rnd3 + vec3(iTime * 10.5,0,0))*2.5-1.);\n    surface bg2 = surface(sdRoundBox(q, vec3(w,5.,w), 0.01), vec3(0), saturate((sin(q.y * 100.-t*2.)*10.0-5.))*col, 0.1, 0.8, 0);\n    \n    result = opU(result, opSU(bg1, bg2, 0.1));\n    */\n    \n\treturn result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    vec3 pos = origin + direction * t;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(pos).dist;\n        if (h < EPS) return 0.0;\n        /*\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < h) {\n            h = iBox.y + EPS; \n        }\n        */\n        t += h;\n        pos = origin + direction * t;\n        \n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction) {\n    float t = 0.0;\n    \n    vec3 pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = (hit.dist);\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n        \n        t += d;\n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    if(d <= EPS){\n    \treturn surface(t, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n    \treturn surface(t, vec3(0), hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n    \n    return vec3(0.05,0.0,0.01);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // test 2 Grid\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //uv += vec2(10.);\n    //uv = abs(uv);\n    /*\n    // plexus\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n  \t*/  \n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, surface mat, vec2 uv)\n{\n    vec3 col = vec3(0,1,0);\n    vec3 sky = SkyColor(ray);\n    \n    //float t = iTime * 1.0 + M_PI * 1.5;\n    //float r = 2.0;\n    //vec3 lightPos = vec3(-0.6, 0.8, 0.5);\n    vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightColor = vec3(0.98, 0.92, 0.89) * 1.5;\n\n    if (mat.dist >= MAX_DIST) {\n        col = sky;\n    } else {\n        vec3 result = vec3(0.);\n        vec3 nor = norm(p);\n\t\tvec3 sky = SkyColor(ray);\n        \n        col = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n        col = mix(col, sky, 1.0 - saturate(exp2(2.0 - mat.dist * 0.5)));\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n        /*\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(p);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    p = p - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    p = p + orientingNormal * OFFSET;\n                }\n\n\n                surface indirectHit = traceRay(p, ray);\n\n                p = p + indirectHit.dist * ray;\n                //float reflength = length(indirectPosition - p);\n                //p = indirectPosition;\n                mat = indirectHit;\n\n                result = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n\n                vec3 sky = SkyColor(ray);\n                \n                dist += mat.dist;\n                \n                // Exponential distance fog\n                result = mix(result, sky, 1.0 - saturate(exp2(50.0 - dist * dist)));\n\n                col += result * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n\n            }\n        }\n*/\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray);\n    \n    pos = p + mat.dist * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI2 * -0.2;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        //float y = sin(t * 2.5) * 0.3 + 0.5;\n        float y = 0.5;\n        //float r = 2. + sin(t * 0.5)*0.5;\n        float r = 1.5;\n        //float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90 + RAD90*0.25;\n        //float theta = t + RAD90;\n        float theta = RAD90;\n\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        //vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        vec3 ro = vec3(0.5 + cos(t * 2.)*0.025, y + sin(t * 1.)*0.025, 0.75 + t);\n        vec3 ta = vec3(0.5, y, 0. + t);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1292, 1292, 1329, 1329, 1539], [1986, 1986, 2009, 2009, 2082], [2084, 2084, 2105, 2105, 2175], [2177, 2177, 2200, 2200, 2279], [2282, 2282, 2304, 2304, 2721], [2724, 2724, 2785, 2785, 2923], [2926, 2986, 3012, 3012, 3878], [3880, 4068, 4091, 4091, 4194], [4196, 4216, 4237, 4237, 4371], [4373, 4392, 4414, 4414, 4547], [4549, 4569, 4591, 4591, 4716], [4817, 4817, 4853, 4853, 4881], [4883, 4883, 4929, 4929, 4985], [4987, 4987, 5018, 5018, 5109], [5111, 5111, 5161, 5161, 5279], [5281, 5281, 5318, 5318, 5407], [5409, 5409, 5479, 5479, 5613], [5615, 5615, 5679, 5679, 5796], [5798, 5798, 5831, 5857, 5888], [5890, 5890, 5915, 5915, 5934], [5935, 5935, 5960, 5960, 5979], [5980, 5980, 6016, 6016, 6044], [6046, 6046, 6105, 6105, 6418], [6420, 6420, 6453, 6453, 6518], [6520, 6544, 6596, 6596, 6715], [6717, 6774, 6811, 6852, 6935], [6937, 6937, 6976, 7148, 7257], [7259, 7259, 7308, 7308, 7867], [7869, 7869, 7908, 7954, 8039], [8041, 8041, 8082, 8192, 8306], [8321, 8372, 8409, 8409, 8431], [8433, 8433, 8476, 8476, 8498], [8500, 8500, 8544, 8544, 8565], [8567, 8567, 8619, 8619, 8718], [8721, 8721, 8766, 8766, 9195], [9197, 9197, 9218, 9218, 9286], [9288, 9288, 9328, 9328, 9453], [9456, 9456, 9491, 9491, 9639], [9641, 9641, 9675, 9675, 9851], [9853, 9853, 9888, 9888, 9923], [9925, 9925, 9962, 9962, 9997], [9999, 10170, 10255, 10255, 10332], [10334, 10377, 10452, 10452, 10844], [10846, 11061, 11092, 11092, 11141], [11143, 11143, 11170, 11170, 11208], [11210, 11210, 11239, 11239, 11277], [11279, 11279, 11306, 11306, 11355], [11614, 11614, 11635, 11635, 11774], [11800, 11800, 11832, 11832, 11945], [11947, 11947, 11979, 11979, 12119], [12121, 12121, 12154, 12154, 12385], [12387, 12387, 12410, 12410, 12989], [12991, 12991, 13016, 13016, 13408], [13410, 13410, 13453, 13453, 14677], [14679, 14679, 14738, 14738, 15995], [15997, 15997, 16063, 16063, 16185], [16187, 16187, 16232, 16232, 16403], [16405, 16405, 16473, 16473, 16691], [16911, 16911, 16950, 17096, 17221], [17223, 17223, 17244, 17244, 23276], [23808, 23808, 23857, 23857, 24459], [24461, 24461, 24514, 24514, 25392], [25658, 25726, 25754, 25754, 25881], [25883, 25973, 26036, 26036, 26242], [26244, 26310, 26374, 26544, 27175], [27177, 27177, 27214, 27214, 27304], [27306, 27306, 27332, 27332, 28920], [29096, 29096, 29117, 29117, 29165], [29167, 29167, 29228, 29313, 29512], [29514, 29514, 29587, 29679, 29879], [29881, 29881, 29923, 30003, 30057], [30059, 30059, 30108, 30108, 30156], [30158, 30158, 30231, 30288, 30503], [30505, 30505, 30525, 30525, 30550], [30737, 30737, 30787, 30871, 31229], [31231, 31231, 31286, 31343, 31603], [31605, 31605, 31701, 31701, 33088], [33292, 33292, 33325, 33381, 33567], [33569, 33569, 33608, 33608, 33651], [33653, 33669, 33742, 33742, 33826], [33828, 33954, 34024, 34024, 34307], [34309, 34309, 34409, 34409, 35202], [35204, 35204, 35271, 35271, 37970], [37972, 37972, 38012, 38012, 38145], [38147, 38147, 38189, 38189, 38367]], "test": "valid"}
{"id": "WlSczt", "name": "nickak SDF Tutorial", "author": "nickak", "description": "SDF Tutorial, Introduction to Signed Distance Function programming", "tags": ["a"], "likes": 1, "viewed": 164, "published": "Public", "date": "1595017322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching\nconst int max_iterations = 256;\nconst float near_distance = 0.001;\nconst float far_distance = 30.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n\n\n//signed distance sphere formula\nfloat sdSphere( vec3 p, float r){\n\treturn length(p) -r;  \n}\n\n//signed distance box formula\nfloat sdBox( vec3 p, vec3 b ) {\n    \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//distance field is the minumum of all visible objects\nfloat distanceField( vec3 p ) {\n\n    \n    //call various signed distance functions on p; the object\n\t//can be modified by operating on p, + vec3, is a translation\n    \n    float d1 = sdSphere( p+vec3(2,-2,0),  0.5 );\t//object 1\n    \n    float d = d1;\n    \n    float d2 = sdBox( p+vec3(2,2,0), vec3(0.5) );\t//object 2\n    \n    d = min(d,d2);\n    \n    float d3 = sdBox( p+vec3(-2,-2,0), vec3(0.5) );\t//object 3\n    \n    d = min(d,d3);\n\n    float d4 = sdSphere( p+vec3(-2,2,0), 0.5 );\t\t//object 4\n     \n    d = min(d,d4);\n    \n    return d;\n}\n\n//rayMarching is an attempt to locate an object at *here* where *here* = (eyePosition + dir), a RAY\n//if an object is found, return true\n//else return false\nbool rayMarching( vec3 eyePosition, vec3 dir, in float depth ) {\n    \n\tfloat t = 0.0, d = 0.0;\n    \n    for ( int i = 0; i < max_iterations; i++ ) {\n        \n        vec3 v = eyePosition + dir * t; \n        d = distanceField( v );\n        \n        if ( d < near_distance ) {\n            break;\n        }\n       \n        t += min( abs(d), 0.1 );\n        \n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    //object does not exist or was not found here\n    if ( d >= near_distance ) {\n        return false;\n    }\n\n    //object was found here\n    return true;\n}\n\n//fov = field of view\nvec3 viewspaceRayDir( float fov, vec2 screenSize, vec2 fragCoord ) {\n    \n\tvec2 xy = fragCoord - screenSize * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = screenSize.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 lookAtMatrix(vec3 eye, vec3 lookAt, vec3 up) {\n    \n\tvec3 f = normalize(lookAt - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat3(\n\t\tvec3(s),\n\t\tvec3(u),\n\t\tvec3(-f)\n\t);\n}\n\nstruct Camera {\n\tvec3 eyePosition;\n    vec3 lookAtPosition;\n    vec3 shaderRay;\n};\n\nCamera setupCamera( vec3 shaderRay ){\n    \n    Camera camera;\n    \n    float posx =  sin(iTime);\n    \n\tcamera.eyePosition = vec3( posx,5, 7);\n    \n\tcamera.lookAtPosition = vec3(0,0,0);\n    \n    camera.shaderRay  = lookAtMatrix(camera.eyePosition, camera.lookAtPosition, vec3(0,1,0) ) * shaderRay;\n\n\treturn camera;\n}\n\nvec4 march(Camera camera){\n    \n    float depth = far_distance;\n\tif ( rayMarching( camera.eyePosition, camera.shaderRay, depth ) ) {\n        return vec4(1); //white\n\t}\n\t\n\treturn vec4(0);\t//black    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //shaderRay is the ray into the scene for the current fragment pixel in the image.\n    //there are iResolution.x * y number of these and all are calculated simultaneously via gfxcard.\n\tvec3 shaderRay = viewspaceRayDir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\tCamera camera = setupCamera( shaderRay );\n\t\n    fragColor = march(camera);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 230, 263, 263, 289], [291, 321, 352, 352, 444], [446, 501, 532, 663, 1040], [1042, 1199, 1263, 1263, 1777], [1779, 1801, 1869, 1869, 2068], [2070, 2070, 2121, 2121, 2272], [2358, 2358, 2395, 2395, 2673], [2675, 2675, 2701, 2701, 2875], [2877, 2877, 2933, 3122, 3275]], "test": "valid"}
{"id": "WlSczW", "name": "shuffle color flattening v2?????", "author": "thefox231", "description": "???????????????????????????????/\nlooks cool doe", "tags": ["glitch", "colorflattening"], "likes": 7, "viewed": 252, "published": "Public API", "date": "1593782772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(texture(iChannel0, uv));\n    \n    vec3 newCol = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) {\n        float color = col[i];\n        \n    \tfloat range1 = mod(iTime + uv.y - abs(uv.x - .5) + float(i) / 3.0, 3.0) - 1.0;\n    \tfloat range2 = mod(iTime * 1.5 - uv.x + abs(uv.y - .5) + float(i) / 2.0 + 0.5, 3.0) - 1.0;\n        \n        /*\n    \tif (color > range1 && color < range2) {\n    \t\tnewCol[i] = 1.0;\n    \t}\n    \n    \tif (color < range1 && color > range2) {\n    \t\tnewCol[i] = 0.0;\n    \t}\n\t\t*/\n        \n        newCol[i] = (abs(color - range1) + abs(color - range2)) / 2.0;\n    }\n    \n    fragColor = vec4(newCol, 1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 743]], "test": "error"}
{"id": "wlsfRn", "name": "Iterations - stripes", "author": "iq", "description": "Another abstract thingy based on noise. Loosely based on [url]https://www.shadertoy.com/view/MssGW4[/url]", "tags": ["procedural", "2d", "iterations"], "likes": 61, "viewed": 3039, "published": "Public API", "date": "1596125298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Other \"Iterations\" shaders:\n//\n// \"trigonometric\"   : https://www.shadertoy.com/view/Mdl3RH\n// \"trigonometric 2\" : https://www.shadertoy.com/view/Wss3zB\n// \"circles\"         : https://www.shadertoy.com/view/MdVGWR\n// \"coral\"           : https://www.shadertoy.com/view/4sXGDN\n// \"guts\"            : https://www.shadertoy.com/view/MssGW4\n// \"inversion\"       : https://www.shadertoy.com/view/XdXGDS\n// \"inversion 2\"     : https://www.shadertoy.com/view/4t3SzN\n// \"shiny\"           : https://www.shadertoy.com/view/MslXz8\n// \"worms\"           : https://www.shadertoy.com/view/ldl3W4\n// \"stripes\"         : https://www.shadertoy.com/view/wlsfRn\n\n#define AA 2\n\nfloat hash( in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*57.0;\n    return mix(mix( hash(n+ 0.0), hash(n+ 1.0),f.x),\n               mix( hash(n+57.0), hash(n+58.0),f.x),f.y);\n}\n\nvec2 map( in vec2 p, in float time )\n{\n    for( int i=0; i<4; i++ )\n    {\n    \tfloat a = noise(p*1.5)*6.2831 + time;\n\t\tp += 0.1*vec2( cos(a), sin(a) );\n    }\n    return p;\n}\n\nfloat height( in vec2 p, in vec2 q )\n{\n    float h = dot(p-q,p-q);\n    h += 0.005*texture(iChannel0,0.75*(p+q)).x;\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.25*iTime;\n    \n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\t\t#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\t#endif\n\n        // deformation\n        vec2 q = map(p,time);\n\n        // color\n        float w = 10.0*q.x;\n        float u = floor(w);\n        float f = fract(w);\n        vec3  col = vec3(0.7,0.55,0.5) + 0.3*sin(3.0*u+vec3(0.0,1.5,2.0));\n        \n        // filtered drop-shadow\n        float sha = smoothstep(0.0,0.5,f)-smoothstep(1.0-fwidth(w),1.0,f);\n        \n        // normal\n        vec2  eps = vec2(2.0/iResolution.y,0.0);\n\t\tfloat l2c = height(q,p);\n        float l2x = height(map(p+eps.xy,time),p) - l2c;\n        float l2y = height(map(p+eps.yx,time),p) - l2c;\n        vec3  nor = normalize( vec3( l2x, eps.x, l2y ) );\n            \n        // lighting\n        col *= 0.3+0.7*sha;\n        col *= 0.8+0.2*vec3(1.0,0.9,0.3)*dot(nor,vec3(0.7,0.3,0.7));\n        col += 0.3*pow(nor.y,8.0)*sha;\n        col *= 7.5*l2c;\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[763, 763, 789, 789, 828], [829, 829, 855, 855, 1069], [1071, 1071, 1109, 1109, 1244], [1246, 1246, 1284, 1284, 1376]], "test": "error"}
{"id": "wlsfzn", "name": "Rainbow Scales", "author": "t420babe", "description": "Rainbow with a tan overlay that reminds me of scales", "tags": ["rainbow"], "likes": 4, "viewed": 142, "published": "Public API", "date": "1595886081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n\nvec3 rainbow_scales(vec2 pos) {\n\n  float speed = 0.5;\n  float zoom = 4.0;\n  pos *= zoom;\n    \n  // vec2 movement = u_mouse;\n  float mod_time = mod(iTime, 400.0);\n  vec2 movement = vec2(mod_time * 4.0, 500.0);\n\n  for (int i = 1; i < 5; i++) {\n    pos.x += 0.003 / float(i) * tan(float(i) * 3.0 * pos.y + iTime / speed) + movement.x/ 20.0;\n    //pos.y += 0.3 / float(i) * cos(float(i) * 3.0 * pos.x + iTime * speed) + movement.y / 1000.0;\n    pos.y += 0.003 / float(i) * tan(float(i) * 3.0 * pos.x + iTime / speed) + movement.y / 10.0;\n  }\n\n  float g = cos(pos.x + pos.y + 1.0) * 0.5 + 0.5;\n  float b = sin(pos.x + pos.y + 1.0) * 0.5 + 0.5;\n  float r = (tan(pos.x + pos.y) + tan(pos.x + pos.y)) * 0.5 + 0.5;\n\n  return vec3(r, g, b);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    \n    vec3 color = rainbow_scales(pos);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 78, 78, 779], [783, 783, 840, 893, 1013]], "test": "valid"}
{"id": "wlSyDc", "name": "roof tiles?", "author": "miko3k", "description": "procedurel roof tiles", "tags": ["procedural", "texture", "pattern", "sinewave", "tiles"], "likes": 3, "viewed": 50, "published": "Public", "date": "1595545643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PERIOD 0.3\n\nfloat rand2(vec2 co) { return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453); }\nvec3 rand23(vec2 x)\n{\n\tvec3 y = vec3(\n      dot(x,vec2(127.1,311.7)),\n\t\t\tdot(x,vec2(269.5,183.3)),\n\t\t\tdot(x,vec2(113.5,271.9))\n  );\n\n\treturn fract(sin(y)*43758.5453123);\n}\n\nfloat edge(float thickness, float value) {\n    return 1.0-smoothstep(0.0,thickness/2.0,value)+smoothstep(1.0-thickness/2.0,1.0,value);\n}\n\n\nvec4 oneTile(vec2 where, vec2 which) {\n    float baseColor = rand2(which);\n    float start = PERIOD-abs(sin(where.x*PI))*PERIOD;\n    \n    float blackH = edge(0.1, where.x);\n    float colorH = 1.0 - blackH;\n    float colorV = smoothstep(start+0.1, start+0.2, where.y);\n    float visiblity = smoothstep(start, start+0.1, where.y);\n    \n    vec3 color = vec3(1.0,0.2,0.2)+rand23(which)*0.2;\n    \n    return vec4(\n        color * colorH * colorV,\n        visiblity\n    );\n    \n\n    \n}\n\n\nvec4 tiledTiles(vec2 uv) {\n    float oddRow = step(1.0, mod(uv.y, 2.0));\n    uv.x += oddRow * 0.5;\n\n    vec2 where = fract(uv);\n    vec2 which = floor(uv);\n    \n    vec2 underWhere = vec2(\n        fract(where.x+0.5),\n        1.0 + where.y\n    );\n    vec2 underWhich = vec2(\n        which.x + 1.0 - step(where.x, 0.5) - oddRow,\n        which.y - 1.0\n    );\n    \n    vec4 a = oneTile(where, which); \n    vec4 b = oneTile(underWhere, underWhich); \n    \n    return vec4(a.a)*a + (1.0-a.a)*b;\n    \n}\n\nvec4 untiledTiles(vec2 uv) { \n    uv.y /= 2.0;\n    \n    vec2 where = fract(uv);\n    vec2 which = floor(uv);\n    where.y *= 2.0;\n    return oneTile(where, which);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 1.0 + sin(iTime) * 0.2;\n    uv += iTime/6.0;\n    uv *= 5.0;\n    \n    fragColor = tiledTiles(uv);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 67, 67, 132], [133, 133, 154, 154, 304], [306, 306, 348, 348, 442], [445, 445, 483, 483, 925], [928, 928, 954, 954, 1422], [1424, 1424, 1452, 1452, 1587], [1590, 1590, 1647, 1647, 1796]], "test": "valid"}
{"id": "WlSyDd", "name": "Reflected Box Innards", "author": "kstyler", "description": "The inside of a ray marched box with reflections.", "tags": ["reflection", "sdf", "box", "mirror", "crystal"], "likes": 1, "viewed": 206, "published": "Public API", "date": "1595661041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_D=100;\nconst float DELTA=0.01;\nint matID = 0;\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(vec3 p){\n    return box(p,vec3(sin(iTime)+1.5));\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,DELTA);\n    \n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n\n}\nvec3 skyColor(vec3 rd){\n    \n    vec3 outLight = vec3(0.125);\n    outLight+= addLight(vec3(0.7,0.5,0.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    \n    \n    outLight+=addLight(vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,0.,-0.01);\n    vec3 rd = normalize(vec3(uv,1));\n  \n    rd.xz*=rot(iTime/8.);\n    rd.xy*=rot(iTime/8.);\n   \n    vec3 color = vec3(0); \n    vec3 accum = vec3(0); \n    float tot = 0.;\n    for(int i = 0; i<50;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n      \n        vec3 n = normal(p);\n      \n        if(dst>0.01){\n         color = skyColor(rd);\n        }\n       \n        else{\n            \n            color += skyColor(reflect(rd,n));\n            ro=p;\n            rd = reflect(rd,n);\n            \n        }\n        \n        accum+=0.02*color;\n    }\n \n    fragColor = vec4((accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 78, 78, 127], [129, 129, 158, 158, 251], [254, 254, 272, 272, 314], [316, 316, 336, 336, 513], [515, 515, 567, 567, 736], [737, 737, 760, 760, 987], [989, 989, 1045, 1045, 1755]], "test": "valid"}
{"id": "WlSyDW", "name": "方块翻转", "author": "gggab", "description": "方块翻转。", "tags": [], "likes": 6, "viewed": 72, "published": "Public", "date": "1594304449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.1415926;\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\nvec2 N22(vec2 p){\n\tvec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\nfloat aa = 0.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    uv.x+=.011;\n    \n    //uv= (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec2 screen = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float backgroundColor =smoothstep(-.01,.01, cos(screen.x*PI)+.035);\n    \n    vec3 col = vec3(0);\n    uv *= 5.;\n    \n   \tvec2 c = fract(uv);\n    \n    vec2 id = floor(uv)+.5;\n    float n=Hash21(id);\n    \n    float width=.1;\n    \n    float t = iTime;\n    aa = abs(sin(t));    \n    vec2 edge =sin(c*PI);\n    edge.x-=clamp(aa*2.-n,width,1.);\n    edge.y-=width;\n    \n    col+=step(.01,edge.x);\n    col*=step(.01,edge.y);\n    col=mix(vec3(0.),col,backgroundColor);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSyDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 132], [133, 133, 150, 150, 267], [283, 283, 340, 390, 1111]], "test": "valid"}
{"id": "wlSyzh", "name": "Abstract Background", "author": "lewdoo", "description": "Just playing with shapes, not really trying for optimisation", "tags": ["art"], "likes": 5, "viewed": 101, "published": "Public", "date": "1595363850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P vec3(1., 0.75, 0.95)\n#define B vec3(.7, 0.95, 0.95)\n#define O vec3(1., 0.6, 0.4)\n#define R vec3(1., 0.4, 0.2)\n#define Y vec3(1., 1., .5)\n\nfloat backBubbleSize = .5;\nfloat backBubbleCount = 5.;\n\nfloat circ(float s, vec2 uv){\n\tfloat c = clamp(floor(1. - distance(uv, vec2(0.5, 0.5)) + 0.1 * s), 0., 1.);\n\treturn c;\n}\n\nfloat ribbon(float s, vec2 uv, float offset){\n    s = 1. - s;\n    uv.y += (sin(uv.x * 3. + iTime * 2. + offset) * 0.2 \n            + sin(iTime) * 0.2 + sin(-iTime + uv.x) * 0.1)\n        * 0.5 * (uv.x + 0.25);\n    \n    float g = abs(sin(uv.x * 0.5 + iTime + offset)) * 0.05 * uv.x;\n    \n \tfloat r = smoothstep(s, s + .005, 1. - abs(uv.y - .5) + g);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(ratio, 1.) * (fragCoord.xy / iResolution.xy);\n    \n    \n    vec3 bg = vec3(1., 0.99, 0.95);\n    bg = bg * (1. - (uv.y - 0.1)) + uv.y * P;\n    bg += (1. - uv.y - 0.5) * O;\n    \n    bg = bg * uv.y + (bg + Y) * (1. - uv.y) * 0.5;\n    \n    vec3 col = bg;\n    \n    //ribbons\n    float r1 = ribbon(0.04, uv, 1.);\n    \n    float r2 = ribbon(0.02, uv + vec2(0., 0.05), 2.);\n    \n    float r3 = ribbon(0.02, uv + vec2(0., -0.04), 9.78342);\n    //--------------\n    \n    //circles\n    float circlesA = 0.;\n    for(float i = 6.; i < 10.; i++){\n        float offset = 1. + abs(sin(i * 1.3));\n    \tcirclesA += circ(0.5 + abs(sin(i) * 0.6), \n                         uv + vec2(sin(iTime * offset + i) * 1.2 + 2. - 0.2 * i, \n                                       cos(iTime * offset + i)) * 0.4 + 0.525);\n    }\n    circlesA = clamp(0., 1., circlesA); \n    \n    float circlesB = 0.;\n    for(float i = 6.; i < 15.; i++){\n        float offset = 1. + abs(sin(i * 1.5));\n    \tcirclesB += circ(0.5 + abs(sin(i) * 0.6), \n                         uv + vec2(sin(iTime * offset + i) * 1.4 + 2. - 0.2 * i, \n                                       cos(iTime * offset + i)) * 0.4 + 0.525);\n    }\n    circlesB = clamp(0., 1., circlesB); \n    //--------------------------\n    \n    \n    //back bubbles----------\\/\n    vec2 st = uv * backBubbleCount;\n    \n    float offset = (floor(st.x) * 0.1);\n    offset = abs(sin((offset + 1.634) * 5.24928 + sin(offset * 5.141 + 0.6346) + sqrt(offset * 2.436268) + offset));\n    \n    st.y -= fract(iTime * 0.35 + offset) * 8. - .5;\n    \n    st.x = fract(st.x);\n    st.x += sin(uv.y * 4. + offset) * (1. / backBubbleCount);\n    float bb = circ(backBubbleSize + offset * 0.75, st); \n    \n    //----------------------/\\\n    \n    \n    //applying the effects\n    col = bg;\n    \n    col = col * (1. - r1) + r1 * B;\n    col = vec3(1. - circlesB) * col + circlesB * O * Y;\n    col = col * (1. - r2) + r2 * R;\n    col = bb * (P + vec3(1.)) * 0.5 + (1. - bb) * col;\n    col = vec3(1. - circlesA) * col + circlesA * P * Y;\n    col = col * (1. - r3) + r3 * Y;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 233, 233, 324], [326, 326, 371, 371, 689], [691, 691, 748, 748, 2933]], "test": "valid"}
{"id": "wltSz8", "name": "Raindow Starfield Tutorial", "author": "deliaev", "description": "made while following this tutorial: https://www.youtube.com/watch?v=rvDo9LvfoVE", "tags": ["tutorial", "stars"], "likes": 3, "viewed": 72, "published": "Public", "date": "1595439648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 20.\n\nmat2 Rot(float a) {\n \tfloat s = sin(a), c = cos(a);\n    return mat2( c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare) {\n \tfloat d = length(uv);\n    float m = .04/d; //smoothstep(.2, 0.5, d);\n    \n    float rays = max(0., 1. - abs(uv.x*uv.y*0.));\n    m += rays*flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0., 1. - abs(uv.x*uv.y*1000.));\n    m += rays*.3*flare;\n    \n    m*=smoothstep(1., .2, d);\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n \tp = fract(p*vec2(1223.34, 16312.21));  \n    p += dot(p, p+45.85);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n \tvec3 col = vec3(0);\n    \n    vec2 gv = fract(uv) -.5;\n    vec2 id = floor(uv);\n    \n    for (int y=-1;y<=1;y++) {\n        for (int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n            float n = Hash21(id+offs);\n            float size = fract(n*345.29);\n    \t\tfloat star = Star(gv-offs-vec2(n,fract(n*34.))+.5, smoothstep(.6,.9,size));\n            \n            vec3 color = sin(vec3(.2,.3,.9)*fract(n*678.3)*19.37)*.5;\n            \n           \tstar *= sin(iTime*.03*n*7.);\n            col += star*size*color;\n        }\n    }\n    \n    // col.rg = gv;\n    \n    // if (gv.x > .48 || gv.y>.48) col.r=1.;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*.1;\n    vec3 col = vec3(0);\n    vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    uv *= (sin(iTime)+1.0)*.4 + .1;\n    // uv += M*4.;\n    uv *= Rot(t*.8);\n        \n    \n    for (float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20., .5, depth);\n        float fade = depth*smoothstep(1.,.9,depth);\n    \tcol += StarLayer(uv*scale+i*453.2-M)*fade;\n    }\n    col *= -1.;\n    col += vec3(1.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 108], [110, 110, 144, 144, 439], [441, 441, 463, 463, 560], [562, 562, 587, 587, 1236], [1238, 1238, 1295, 1295, 1850]], "test": "valid"}
{"id": "wlVXRV", "name": "Goatrance trip !", "author": "z0rg", "description": "A shader made on new song from Agneton !", "tags": ["psy", "psytrance", "goatrance", "agneton", "nithzogoa"], "likes": 5, "viewed": 177, "published": "Public API", "date": "1595444128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\nvec2 repeat(vec2 p, vec2 sp)\n{\n  return mod(p,sp)-sp/2.;\n}\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\n float sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nfloat _union(float a, float b)\n{\n  return min(a,b);\n}\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\n\nvec3 rdrPsy(vec2 uv)\n{\n  vec3 cols[4];\n\n  cols[0] = vec3(196.,1.,44.)/255.;\n  cols[1] = .0*vec3(1.,44.,196.)/255.;\n  cols[2] = vec3(1.,196.,153.)/255.;\n  cols[3] = vec3(196.,153.,1.)/255.;\n  float fidx= mod(-iTime+length(uv)*4.+.2*-abs(sin(50.*atan(uv.y,uv.x)/PI))\n    +abs(0.1*sin(iTime*5.+sin(uv.x*5.)*179.7*atan(uv.y,uv.x)/PI))\n      ,4.);\n  int curIdx=int(fidx);\n  vec3 bubbles = vec3(uv,.5)*(1.-sat(50.*_cir(repeat(uv*(sin(iTime*.5)*.2+.5)*r2d(.5*sin(uv.y*2.+iTime*.5)),vec2(.1)),.02)));\n  return bubbles+vec3(.3)+mix(cols[curIdx], cols[int(mod(float(curIdx)+1.,4.))], fract(fidx));\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  vec2 uvc = vec2(abs(uv.x),uv.y*sign(uv.x));\n  vec2 uvcir =uvc- vec2(.0);\n  float acir = atan(uvcir.y,uvcir.x)/PI;\n  vec2 pcir = vec2(sin(iTime),cos(iTime*.7))*.5;\n  float cir = (1.-sat(_cir(uv+pcir,.5)*200.))*float(acir<.7*sin(10.*-iTime+length(uvcir)*20.));;\n\n\n  return vec3(abs(uv),.5)*cir*2.;\n}\n\nvec3 rdrDot(vec2 uv, float szmin, float szmax)\n{\n  vec2 ouv = uv;\n  uv = vec2(int(uv.x/szmax),int(uv.y/szmax))*szmax;\n  vec3 col = rdrScn(uv);\n\n  return col*(1.-sat((length(ouv-uv-vec2(.5*szmax*sign(uv.x),.5*szmax*sign(uv.y)))-mix(szmin,(szmax-.1*szmax)*.5,col.x))*200.*(col.x+.1)));\n}\n\nfloat sdCross(vec2 p, float sz)\n{\n  vec2 sz2 = vec2(sz,sz/3.);\n  float a = sdf_rect(p,sz2);\n  float b = sdf_rect(p,sz2.yx);\n\n  return _union(a,b);\n}\n\nvec3 rdrCross(vec2 uv)\n{\n  vec3 acc;\n\n  for (int i = 0;i<16;++i)\n  {\n    float fi = float(i);\n    float px = sin(fi)*.5;\n    vec2 pos= vec2(px,sin(px*2.+iTime)+mod((fi-4.)*5.,.53));\n    vec2 p = (uv-vec2(pos))*r2d(sin(iTime*.5+float(i)));\n\n    float sd = sat(sdCross(p,.1*fi*.3)*200.);\n    float sdHalo = sat(sdCross(p,.1*(fi*.2))*5.);\n    float sd2 = sat(sdCross(p,.08*(fi*.3))*200.);\n\n    acc*= sd;\n    acc+= vec3(1.)*(sd2*(1.-sd))+(1.-sdHalo)*sd*vec3(uv.xyx*.5+.5);\n  }\n  return acc;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 opsy = rdrPsy(uv*r2d(-iTime));\n  uv = abs(uv);\n  uv = uv*r2d(20.*atan(uv.y,uv.x)/PI);\n  uv= uv+(vec2(.1)*r2d(-iTime));\n  float sel = float(mod(iTime,.4)<.2);\n  vec3 col = rdrDot((uv+vec2(.3))*r2d(iTime),.02,mix(.05,.01,sel));\n  vec3 c2 = rdrCross(uv);\n\n  return mix(col,c2,c2.x)+rdrPsy(uv).yxz-opsy.zyx*.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\nuv*=2.+(sin(iTime)*.5+.5);\n  vec3 col = rdr(uv);\n    //uv.x += .5;\n    float rad = length(uv)-.1;\n    float an = abs(atan(uv.y, uv.x)/PI);\n    vec3 col2 = col*float(rad < texelFetch(iChannel0, ivec2(int((an)*512.), 0), 0).x)*.5;\n    vec3 outcol = sat(1.-lenny(uv*.5))*col.zxy*.5+col2.zxy;\n//    outcol = pow(outcol, vec3(1./2.2));\n    \n    float fadeIn = clamp(iTime,0.,3.)/3.;\n  fragColor = vec4(outcol*fadeIn, 1.0);\n}", "image_inputs": [{"id": "4lB3R3", "previewfilepath": "https://soundcloud.com/agneton/agneton-fire-in-the-sky", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/agneton/agneton-fire-in-the-sky", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXRV.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[426, 426, 444, 444, 505], [507, 507, 528, 528, 558], [559, 559, 579, 579, 606], [607, 607, 625, 625, 671], [672, 672, 702, 702, 730], [731, 731, 762, 762, 788], [791, 791, 825, 825, 873], [875, 875, 907, 907, 928], [929, 929, 959, 959, 981], [984, 984, 1006, 1006, 1573], [1575, 1575, 1597, 1597, 1897], [1899, 1899, 1947, 1947, 2184], [2186, 2186, 2219, 2219, 2334], [2336, 2336, 2360, 2360, 2824], [2826, 2826, 2845, 2845, 3161], [3164, 3164, 3221, 3221, 3732]], "test": "error"}
{"id": "wlXBRn", "name": " x^y - x mod y", "author": "mathieu_h", "description": "This pleasing pattern is the result of some visual experimentation with a mathematical problem.\nWe were trying to prove that (x^5-x) mod n = 0 is true for all integers and wanted to see how this generalizes to x^n -x. (n=>y on the screen).", "tags": ["math", "visual", "modular"], "likes": 2, "viewed": 45, "published": "Public", "date": "1595809885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mirror 0\n#define phi 1.61803398875\n#define AA = 0.1\n\nfloat mid (float x){return abs(mod(x-.5,1.0)-.5)*2.0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    vec2 res = iResolution.xy;\n    uv = ( 2.*uv - res ) / res.y; \n\n    // View\n    float zoom = exp(phi + pow(fract(iTime/(8.*phi)),pow(phi,4.0)) * 16.);\n    vec2 offset = vec2(\tpow(phi, 2.0), phi);\n    \n    // Transform 2D\n    uv *= zoom;    \n    uv += offset;\n    \n    // Draw Function\n    float x = uv.x;\n    float y = uv.y;\n    if(mirror == 1)\n    {\n      \ty = sign(x)*y;\n    \tx = abs(x);\n    }\n    \n    \n    float value = mod(pow(x,y) - x,y);   \n    \n    // Filtering\n    if(value < 0.0) \n    {\n    \tvalue = abs(value);   \n    }\n    else if(value > 0.0) \n    {\n       \tvalue = abs(value);\n    }\n    \n    value = pow(value,0.02);    \n    value = smoothstep(0.1, 1.125, value);\n    \n    // Composition\n    vec3 bg = vec3(.17);\n    vec3 col = vec3(value);\n    col = col;\n    col = max(col, bg);    \n\n    // Output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 81, 81, 115], [117, 117, 174, 174, 1048]], "test": "valid"}
{"id": "WlXBzH", "name": "Sineapple Under The Sea", "author": "Flopine", "description": "IF IT RUNS SLOW, COMMENT THE LINE 19 (AddSeaweed) \nThis shader was made for a chiptune album cover: https://youtu.be/TSarY-ZmXUY ", "tags": ["raymarching", "cartoon", "modeling", "animation", "npr", "spongebob"], "likes": 16, "viewed": 200, "published": "Public", "date": "1595940489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n/////////////////////////////////////////////////////////////////////////\n// THIS SHADER WAS MADE FOR A CHIPTUNE ALBUM: Sineapple under the Sea  //\n// https://youtu.be/TSarY-ZmXUY                                        //\n// IF IT RUNS SLOW, COMMENT THE LINE 19 (AddSeaweed)                   //\n/////////////////////////////////////////////////////////////////////////\n\n\n// TOOLBOX //\n#define AddSeaweed\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define ITER 100.\n\n#define BPM (110.0/60.)\n#define time(speed,off) fract(iTime*speed+off)\n#define bouncy(speed,off) sqrt(abs(sin(time(speed,off)*PI))) \n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nstruct bloc\n{\n    float d;\n    vec3 color;\n};\n\nbloc min_struct (bloc a, bloc b)\n{\n    if (a.d<b.d) return a;\n    else return b;\n}\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n/////////////\n\n\n// 2D PROCEDURAL TEXTURE //\nfloat losdist(vec2 uv)\n{\n    uv = abs(uv);\n    return dot(uv,vec2(1.));\n}\n\nfloat grid(vec2 uv)\n{\n    vec2 ga = fract(uv)-.5;\n    vec2 gb = fract(uv-.5)-.5;\n    vec2 guv = (dot(ga,ga)<dot(gb,gb))? ga:gb;\n\n    return clamp(.8-losdist(guv),0.,1.);\n}\n//////////////////////////\n\n\n// 3D BASIC SHAPES //\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat tore (vec3 p, vec2 d)\n{\n    vec2 q = vec2(length(p.xz)-d.x,p.y);\n    return length(q)-d.y;\n}\n\nfloat ellipse( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n/////////////////////\n\n\n// SIGN MODELING //\nfloat part (vec3 p)\n{  \n    float r = 0.2+sin(p.y*(PI/2.)*0.3) * sin(p.y*(PI/2.)*0.3);\n    return cyl(p.xzy, r, 1.);\n}\n\nbloc bb_sign(vec3 p)\n{\n    p *= 2.5;\n    p += vec3(13.,-2.,38.);\n    p.xz *= rot(-PI/2.);\n    p.xy *= rot(PI/10.);\n    vec3 pp = p;\n    p.y += 3.5;\n    float dpole = 1e10;\n    for (int i=0; i<5;i++)\n    {\n        dpole = min(dpole, part(p));\n        p.y -=2.;\n    }\n    bloc pole = bloc (dpole/2.5, vec3(0.3,0.25,0.)); \n\n    p = pp;\n    p.yz += vec2(-1.5, .5);\n    float dlifebelt = tore(p.xzy,vec2(1.6,0.55));\n    bloc lifebelt = bloc(dlifebelt/2.5,vec3(0.8,0.5,0.1));\n    return min_struct(pole, lifebelt);\n}\n/////////////////////\n\n\n// SEAWEED MODELING //\nfloat swdist (vec3 p, float anim)\n{\n    p.x += sin(p.y+anim)*0.2;\n    p *= 0.7;\n    float dseaw = cyl(p.xzy, 0.05-p.y*0.05, 2.);\n    dseaw = min(dseaw,box(p,vec3(0.02,2.,0.15-sin(p.y*4.)*0.1-p.y*0.1))-0.02);\n    return dseaw/0.7;\n}\n\nbloc seaweed (vec3 p)\n{\n    p.y -= 0.7;\n    float per = 1.;\n    p.x = abs(p.x) - 9.5;\n    p.z -= 20.;\n    float id = floor((p.z-20.)/per);\n    float dseaw = 1e10;\n\n    for (float i=0.; i<=40.; i+=per)\n    {\n        dseaw = min(dseaw,swdist(p, time(0.2,id)*TAU));\n        p.z += per;\n    }\n\n    p.y += 2.5;\n    vec3 cseaw = vec3(0.5,0.5+p.y*0.5,0.2)*0.7;\n\n    return bloc(dseaw, cseaw);\n}\n//////////////////////\n\n\n// GROUND MODELING //\nbloc ground (vec3 p)\n{\n    float gsize = 20.;\n    vec3 pp = p;\n    p.y += sin(p.x*(PI/4.)) * sin(p.x*(PI/4.))*0.7;\n    p.y += cos(p.z*(PI/2.)) * sin(p.z*(PI))*0.1;\n    float dsand = max(-box(p,vec3(2.,1.,gsize*1.5)),box(p,vec3(10.,0.5,gsize)));\n    vec3 csand = mix(vec3(0.75,0.8,0.65),vec3(0.6,0.5,0.4),pow(texture(iChannel0,p.xz*0.2).r,7.));\n    bloc sand = bloc(dsand,clamp(csand,0.,1.));\n\n    p = pp;\n    p.y += 0.4;\n    float droad = box(p,vec3(2.,0.3,gsize));\n    vec3 croad = vec3(0.05);\n    bloc road = bloc(droad, croad);\n    return min_struct(sand,road);\n}\n////////////////////\n\n\n// ANCHOR MODELING //\nbloc anchor (vec3 p)\n{\n    p *= 0.5;\n    p += vec3(3.,-0.5,0.5);\n    p.xy *= rot(-0.15);\n    vec3 pp = p;\n    float danch = cyl(pp.xzy, 0.15, 2.);\n\n    pp.y -= 0.9;\n    float c1 = cyl(pp,0.1, 1.);\n    pp.z = abs(pp.z)-1.3;\n    pp.xy *= rot(PI/2.);\n    float t1 = tore(pp, vec2(0.3,0.08));\n    danch = smin(danch,smin(t1,c1,0.1),0.1);\n\n    pp = p;\n    pp.y -= 2.3;\n    pp.xy *= rot(PI/2.);\n    danch = smin(danch, tore(pp, vec2(0.3,0.08)),0.15);\n\n    pp = p;\n    pp.xy *= rot(PI/2.);\n    float a = atan(-pp.z,-pp.x)*length(pp);\n    danch = smin(danch, max(p.y,tore(pp, vec2(2.,0.2-(abs(a))*0.05))),0.1);\n\n    return bloc(danch/0.5, vec3(0.2));\n}\n//////////////////////\n\n\n// CORALS MODELING //\nbloc coral (vec3 p)\n{\n    p *= 1.5;\n    vec3 pp = p;\n    p.x += cos(p.y*2.)*.2;\n    p.z = abs(p.z)-.4;\n    p.z += sin((p.y-0.5)*2.)*0.3;\n    p.yz *= rot(PI/6.);\n\n    float r = 0.2-exp(-sin(p.y*2.))*0.15+.3;\n    float dcor = max((pp.y+pp.z*.4)-.5,abs(cyl(p.xzy,r,1.4))-.05);\n    return bloc(dcor/1.5, vec3(1.,0.3,0.));\n}\n\nbloc corals (vec3 p)\n{\n    vec3 pp = p;\n\n    p += vec3(4.,1.,14.);\n    bloc cs = coral(p);\n\n    p = pp;\n    p += vec3(-8.,1.05,8.);\n    p.xz *= rot(PI/5.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(-3.,1.5, 0.);\n    p.xz *= rot(-PI/5.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(4.5,1.05,-3.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(-7.,1.3, -10.);\n    p.xz *= rot(PI/10.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(-3.,1.3, -17.);\n    p.xz *= rot(-PI/4.);\n    cs = min_struct(cs,coral(p));\n\n    return cs;\n}\n//////////////////////\n\n\n// PATRICK'S HOUSE MODELING //\nbloc patgir (vec3 p)\n{\n    p.y -= 2.3;\n    p.xy *= rot(PI/2.);\n    float dg = cyl(p.yzx, 0.05, 0.3);\n    p.x -= 0.3;\n    dg = min(dg,cyl(p, 0.05,0.5));\n\n    p.z -= 0.5;\n    p.y = abs(p.y)-0.1;\n    p.yz *= rot(PI/5.);\n    dg = min(dg,cyl(p, 0.05,0.2));\n\n    return bloc(dg,vec3(0.8,0.7,0.1));\n}\n\nbloc pathouse (vec3 p)\n{\n    p *= 0.8;\n    p += vec3(-4.3, 1.7, -3.5);\n    float dhouse = max(-p.y,length(p)-2.);\n\n    return min_struct(bloc(dhouse/0.8,vec3(0.18,0.15,0.1)),patgir(p));\n}\n///////////////////////////////\n\n\nbloc hwindow (vec3 p)\n{\n    float dhw = max(cyl(p, 0.5, 0.1),-cyl(p+vec3(0.,0.,0.1),0.4,0.1));\n    return bloc(dhw,vec3(0.,0.08,.5-length(p)*0.8));\n}\n\n\n// SPONGEBOB'S HOUSE MODELING //\nbloc bobhouse (vec3 p)\n{\n    p += vec3(-4.5,0.1,12.);\n    p.xz *= rot(-PI/2.);\n    vec3 pp = p;\n\n    vec2 puv = vec2(atan(p.z,p.x)*1.5,p.y);\n    bloc dbhouse = bloc(max(-p.y-1.3,ellipse(p,vec3(2., 3.,2.)+grid(puv)*0.3)),vec3(0.9,0.4,0.));\n\n    p += vec3(1.2,-1.,1.7);\n    p.yz *= rot(PI/9.);\n    p.xz *= rot(-PI/5.);\n    dbhouse = min_struct(dbhouse,hwindow(p));\n\n    p = pp;\n    p += vec3(-1.2,-0.2,1.9);\n    p.xz *= rot(PI/5.);\n    dbhouse = min_struct(dbhouse,hwindow(p)); \n\n    p = pp;\n    p.y -= 3.5;\n    p.z -= 0.5;\n    p.z -= sin(p.y)*0.5;\n    mo(p.xz,vec2(0.5+sin(p.y)*0.3));\n    p.x -= 0.4;\n    p.z += 0.5;\n    dbhouse = min_struct(dbhouse, bloc(cyl(p.xzy, 0.3-p.y*0.15, 2.),vec3(0.,1.,0.2)));\n    p.z -= 0.5;\n    dbhouse = min_struct(dbhouse, bloc(cyl(p.xzy, 0.3-p.y*0.15, 2.),vec3(0.3,1.,0.2)));\n\n    return dbhouse;\n}\n/////////////////////////////\n\n\n// SQUIDWARD'S HOUSE MODELING //\nbloc carhouse (vec3 p)\n{\n    p += vec3(-5.,-1.5,4.);\n    p.xz *= rot(PI/10.);\n    vec3 pp = p;\n    float dcarh = cyl(p.xzy, 1.6-p.y*0.05, 3.8);\n\n    p.z = abs(p.z)-2.;\n    dcarh = min(dcarh,box(p,vec3(0.2,1.3,0.5))-0.05);\n\n    p = pp;\n    p.xy += vec2(1.5,-0.2);\n    dcarh = min(dcarh, box(p,vec3(0.3,1.6,0.5-p.y*0.1))-0.05);\n\n    p = pp;\n    p.xy += vec2(1.65,-2.2);\n    dcarh = min(dcarh,box(p,vec3(0.2,0.3,1.5))-0.06);\n\n    bloc face = bloc(dcarh,vec3(0.,0.,0.1));\n    p = pp;\n    p.xy += vec2(1.45,-1.1);\n    p.z = abs(p.z)-0.95;\n    p.xz *= rot(-PI/2.);\n\n    return min_struct(face, hwindow(p));\n}\n////////////////////////////////\n\n\n// ALL SET COMBINED //\nbloc sets (vec3 p)\n{\n    p.z -= 20.;\n    p.z += iTime*1.5;\n    p.z = mod(p.z-20.,40.)-20.;\n    vec3 pp = p;\n\n    bloc cor = corals(p);\n    bloc bbs = bb_sign(p);\n    bloc sw = seaweed(p);\n    bloc anch = anchor(p);\n    bloc patho = pathouse(p);\n    bloc bobho = bloc(bobhouse(p*0.8).d/0.8,bobhouse(p*0.8).color);\n    bloc carho = carhouse(p);\n\n    p.y += 2.;\n    bloc gr = ground(p);\n\n    bloc bset = min_struct(carho,\n                           min_struct(\n                               min_struct(patho,\n                                          bobho),\n                               min_struct(anch,\n                                          min_struct(bbs,\n                                                     gr)\n                                         )\n                           )\n                          );\n\t#ifdef AddSeaweed\n    \tbset = min_struct(bset, sw);\n    #endif\n    bset = min_struct(bset, cor);\n\n    return bset;\n}\n/////////////////////////////\n\n\n// CHARACTER MODELING //\nfloat sx = 0.5, sz = 0.4;\nbloc spongebob (vec3 p)\n{\n    p.x += 1.;\n    bloc feets = bloc(box(p-vec3(0.,bouncy(BPM,0.15),0.),vec3(sx,0.1,sz)),vec3(0.05));\n    bloc pants = bloc(box(p-vec3(0.,0.35+bouncy(BPM,0.1),0.),vec3(sx,0.2,sz)),vec3(0.3,0.25,0.2));\n    bloc shirt = bloc(box(p-vec3(0.,0.75+bouncy(BPM,0.05),0.),vec3(sx,0.15,sz)),vec3(0.9));\n    bloc head = bloc(box(p-vec3(0.,1.55+bouncy(BPM,0.0),0.),vec3(sx,0.6,sz)),vec3(0.7,0.6,0.1));\n    return min_struct(head,min_struct(shirt,min_struct(feets, pants)));\n}\n\nbloc patrick (vec3 p)\n{\n    p.x -= 1.;\n    bloc lowbody = bloc(box(p-vec3(0.,bouncy(BPM,0.10),0.),vec3(sx,0.15,sz)),vec3(0.7,0.2,0.6));\n    bloc pants = bloc(box(p-vec3(0.,0.4+bouncy(BPM,0.05),0.),vec3(sx,0.25,sz)),vec3(0.3,0.8,0.5));\n    bloc upbody = bloc(box(p-vec3(0.,1.4+bouncy(BPM,0.),0.),vec3(sx,0.65,sz)),vec3(0.7,0.2,0.6));\n    return min_struct(upbody,min_struct(lowbody,pants));\n}\n////////////////////////////\n\n\n// ALL SCENE COMBINED //\nbloc SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    p.x += 0.8;\n    vec3 pp = p;\n    bloc se = sets(p);\n\n    p = pp;\n    p.y += 1.7;\n    return min_struct(se,min_struct(patrick(p),spongebob(p)));\n}\n///////////////////////////////\n\n\nvec3 norm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\n\n// MAIN // \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\t\n\n    uv += texNoise(uv*0.2-time(0.05,0.)).r*0.05;\n\n    vec3 ro = vec3(uv*4.5,-100.),\n        rd = normalize(vec3(0.,0.,1.)),\n        p = ro,\n        l = normalize(vec3(-2.,5.,-5.)),\n        col = vec3(0.0,(p.y+p.x*0.5)-5.5, 0.9)*0.7;\n\n    bloc shape;\n    bool hit = false;\n\n\n    for (float i=0.;i<ITER;i++)\n    {\n        shape = SDF(p);\n        if (shape.d<0.01)\n        {\n            hit = true;\n            break;\n        }\n        p += shape.d*rd*0.8;\n    }\n\n    if (hit)\n    {\n        vec3 n = norm(p);\n        col = mix(vec3(0.2,0.6,0.7),shape.color,dot(n,l)*0.5+0.5);\n    }\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1016, 1016, 1050, 1050, 1098], [1100, 1100, 1140, 1140, 1229], [1231, 1231, 1262, 1262, 1309], [1311, 1438, 1462, 1462, 1700], [1717, 1745, 1769, 1769, 1818], [1820, 1820, 1841, 1841, 1991], [2021, 2043, 2071, 2071, 2156], [2158, 2158, 2196, 2196, 2235], [2237, 2237, 2266, 2266, 2335], [2337, 2337, 2370, 2370, 2459], [2484, 2504, 2525, 2525, 2622], [2624, 2624, 2646, 2646, 3134], [3159, 3182, 3217, 3217, 3413], [3415, 3415, 3438, 3438, 3802], [3828, 3850, 3872, 3872, 4416], [4440, 4462, 4484, 4484, 5106], [5132, 5154, 5175, 5175, 5473], [5475, 5475, 5497, 5497, 6062], [6088, 6119, 6141, 6141, 6412], [6414, 6414, 6438, 6438, 6601], [6636, 6636, 6659, 6659, 6785], [6788, 6821, 6845, 6845, 7650], [7683, 7716, 7740, 7740, 8318], [8354, 8377, 8397, 8397, 9315], [9399, 9399, 9424, 9424, 9888], [9890, 9890, 9913, 9913, 10281], [10313, 10338, 10357, 10357, 10568], [10603, 10603, 10623, 10623, 10744], [10747, 10759, 10816, 10816, 11495]], "test": "error"}
{"id": "wlXfRH", "name": "Ode to: Piet Mondrian - Tableau", "author": "ChocolatePinecone", "description": "An ode to the work Tableau by Piet Mondrian", "tags": ["mondrian", "pietmondrian", "tableau"], "likes": 3, "viewed": 198, "published": "Public API", "date": "1595969273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 drawRectangle(vec4 bounds, float edgeWidth, vec2 st) {\n    vec2 stWidth = edgeWidth / iResolution.xy;\n    vec2 relPos = st.xy - bounds.xy;\n    vec3 color = vec3(1.0);\n    \n    // Check to determine if point is inside rect edge or inner part\n    vec2 ch1 = step(bounds.xy, st.xy) - step(bounds.xy + bounds.zw, st.xy); // 1.0 if rect\n    vec2 ch2 = step(bounds.xy + stWidth, st.xy) - step(bounds.xy + bounds.zw - stWidth, st.xy); // 1.0 if inside inner rect\n    float edge = ch1.x * ch1.y - ch2.x * ch2.y; // 1.0 if inside edge\n    \n    // Give edge black color\n    color -= edge;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    float fade = (sin(iTime * 2.0) + 1.0) * 0.5;\n    \n    vec3 red = vec3(0.662, 0.129, 0.137);\n    vec3 yellow = vec3(0.996, 0.792, 0.227);\n    vec3 blue = vec3(0.0, 0.368, 0.608);\n\n    // Draw lines\n    color = drawRectangle(vec4(0.05,0.65,0.2,0.4), 10.0, st);\n    color *= drawRectangle(vec4(-0.1,0.65,1.2,0.2), 10.0, st);\n    color *= drawRectangle(vec4(-0.1,-0.1,0.35,1.2), 10.0, st);\n    color *= drawRectangle(vec4(0.7,-0.1,0.25,1.2), 10.0, st);\n    color *= drawRectangle(vec4(0.237,-0.1,0.8,0.2), 10.0, st);\n\n    // Draw colors\n    if(st.x < 0.25 && st.y > 0.65) {\n    \tcolor *= red * fade;\n    }\n    if(st.x > 0.95 && st.y > 0.65) {\n    \tcolor *= yellow * fade;\n    }\n    if(st.x > 0.7 && st.y < 0.1) {\n    \tcolor *= blue * fade;\n    }\n    \n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 105, 105, 654], [657, 657, 714, 714, 1578]], "test": "valid"}
{"id": "WlXfz4", "name": "Sphere with shade", "author": "reatured", "description": "Sphere with shadow", "tags": ["learning"], "likes": 2, "viewed": 460, "published": "Public", "date": "1596079696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\nfloat GetDist(vec3 p){\n \tvec4 s = vec4(sin(iTime * 3.),abs(sin(iTime * 5.)) +1. ,cos(iTime * 3. )+ 8.,1.);//sphere location and radius\n    float sphereDIst = length(p-s.xyz) - s.w;//dist to sphere\n    float planeDist = p.y;\n    float d = min(sphereDIst, planeDist);\n    return d;\n    \n}\nfloat RayMarch(vec3 ro, vec3 rd){\n\tfloat dO = 0.; \t//distance\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n     \tvec3 p = ro + rd*dO;//step destination vector\n        float dS = GetDist(p);//dist to destination\n        dO += dS; \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n \tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(GetDist(p-e.xyy),\n                      GetDist(p-e.yxy),\n                      GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n\tvec3 lightPos = vec3(0., 5., 6.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p); //obj normal\n    \n    float dif = clamp(dot(n, l),0.,1.);//shadow\n    float d = RayMarch(p + n*SURF_DIST * 2.,l);\n    if(d<length(lightPos - p))\t dif *= .2;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv-0.5) *2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.1);\n    \n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 3.));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    float dif  = GetLight(p);//the position on obj\n    \n    \n    \n    d /= 6.;\n    col += vec3(0.2 + uv.x*0.2,0.5 + uv.x *-0.6,0.7)*dif;\n    \n\n    //col = GetNormal(p);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 353], [354, 354, 387, 387, 651], [653, 653, 676, 676, 886], [888, 888, 911, 911, 1240], [1242, 1242, 1299, 1349, 1881]], "test": "valid"}
{"id": "wlXfzH", "name": "Camera Movement Test", "author": "Zi7ar21", "description": "Testing camera rotation", "tags": ["3d", "ray", "ray", "raymarch", "mandelbulb", "sphere", "marcher", "epic", "yeet"], "likes": 4, "viewed": 221, "published": "Public API", "date": "1595974454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"My Very First Working Fractal\" by Zi7ar21. https://shadertoy.com/view/ttBcWR\n// 2020-07-28 21:58:56\n\n// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking!\n#define MAX_MARCHES 32\n#define MAX_DISTANCE 32.0\n#define COLLISION_DISTANCE 0.01\n#define Bailout 16.0\n#define Iterations 6\n\n// Mandelbulb Distance Estimator\n// Adapted from:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat sphere(vec3 pos) {\n\tfloat Power = float((sin(iTime * 2.5) * 0.5) + 8.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat distorigin=0.0;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*distorigin;\n        float distsurface = sphere(raypos);\n        distorigin += distsurface;\n        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n    }\n    \n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march) {\n\t// Light Positions\n    vec3 lightpositiona = vec3(0, 8, 0);\n\tvec3 lightpositionb = vec3(0, 0, 0);\n    vec3 lightpositionc = vec3(0, -8, 0);\n\t// Animate Lights\n    lightpositiona.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n    lightpositionb.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n    lightpositionc.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(0.0, 0.0, -4.5);\n    camerapos = vec3(camerapos.x+((-iMouse.x+iResolution.x/2.0)/iResolution.x), camerapos.y+((-iMouse.y+iResolution.y/2.0)/iResolution.x), -4.5);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Compute and Shade\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    vec3 diffuse = shade(march);\n\t\n\t// Finish the Image and Apply Tone Map\n    col = vec3(acesFilm(diffuse));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 1105, 1129, 1129, 1711], [1713, 1738, 1783, 1783, 2092], [2094, 2108, 2134, 2134, 2353], [2355, 2370, 2394, 2414, 3865], [3867, 3886, 3915, 3915, 4100], [4102, 4122, 4179, 4202, 5071]], "test": "valid"}
{"id": "WsBBRD", "name": "Cuboids", "author": "jbsiraudin", "description": "Some squishy isometric cuboids - pure 2D drawing.", "tags": ["2d", "isometric"], "likes": 13, "viewed": 143, "published": "Public", "date": "1594379085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pixelWidth 2.0/iResolution.y\n#define N 4\n#define A 0.59\n#define red vec3(1.0, 0.0, 0.0)\n#define white vec3(1.0)\n\nvec3 light = vec3(0.05, 1.0, 0.85);\n\n// sdPoly adapted from https://www.shadertoy.com/view/WdSGRd \nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = -1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        \n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return smoothstep(-pixelWidth, pixelWidth, s*sqrt(d));\n}\n\nvoid drawCuboid(inout vec4 c, vec2 p, vec3 color, float width, float height, float depth)\n{   \n    height = max(pixelWidth, height);\n    vec2 v0 = vec2(0, height);\n    vec2 v1 = v0 + vec2(depth, A*depth);\n    vec2 v2 = v1 - vec2(0, height);\n    vec2 v3 = v0 - vec2(0, height);\n    \n    vec2 v4 = v0 - vec2(width, -A*width);\n    vec2 v5 = v4 - vec2(0, height);\n    \n    vec2 v6 = v4 + vec2(depth, A*depth);\n    \n    vec2[] polyRight = vec2[](v0,v1,v2,v3);\n    vec2[] polyLeft = vec2[](v0,v4,v5,v3);\n    vec2[] polyTop = vec2[](v0,v4,v6,v1);\n    \n    float right = sdPoly(polyRight, p);\n    float left = sdPoly(polyLeft, p);\n    float top = sdPoly(polyTop, p);\n    \n    float a = clamp(top + right + left, 0.0, 1.0);\n    \n    //Crayon-like border\n    //vec3 result = step(0.9, top) * vec3(1.0) + step(0.9, right) * vec3(0.85) + step(0.9, left) * vec3(0.05);\n\n    vec4 result = vec4(light.y*color, top);\n    result = mix(result, vec4(light.z*color, right), right);\n    result = mix(result, vec4(light.x*color, left), left);\n    \n    c = mix(c, result, pow(a, 4.0));\n}\n\nfloat st(float a, vec2 uv)\n{\n    return sin(a*iTime+a*uv.y*uv.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 U = (2.0*fragCoord-iResolution.xy)/(iResolution.y);\n    vec2 p = fract(U) - vec2(.5, 0.4);\n    \n    float s = 0.2*.6;\n    \n    vec4 col = vec4(0);\n    \n    //Lighting change\n    light.x = 0.5 + 0.35*pow(sin(iTime), 3.);\n    light.z = 0.5 + 0.35*pow(sin(iTime + 3.), 3.);\n    \n    // Draw red cuboid\n    drawCuboid(col, p, red, s*(1.0+0.5*st(3.5, U)), s*(1.0+st(5., U)), s*(1.0+0.25*st(2., U)));\n    // Draw blue-ish one\n    U *= 1.1;\n    drawCuboid(col, p-vec2(0.1,-0.2), vec3(0.6, 0.8, 1.0), s*(1.0+0.5*st(3.5, U)), s*(1.0+st(5., U)), s*(1.0+0.25*st(2., U)));    \n\n    \n\tfragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1883, 1883, 1911, 1911, 1950], [1952, 1952, 2007, 2007, 2610]], "test": "error"}
{"id": "wssBDn", "name": "rainbow coral gyroid thingie", "author": "sasha_sortai", "description": "there's still a couple of glitches but I like it anyway", "tags": ["raymarching", "sdf", "gyroid"], "likes": 22, "viewed": 211, "published": "Public", "date": "1595947312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 march(vec3, vec3, vec2);\nvec3 march(vec3, vec3, vec2, float);\n\nfloat DE(vec3);\n\nvec3 color(vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/min(iResolution.x, iResolution.y);\n    vec2 p = uv*2.;\n    // Time varying pixel color\n    vec3 col = vec3(p,0);\n    \n    vec3 cam = vec3(1);\n    vec3 tar = normalize(vec3(1,1,1.2))+vec3(cos(iTime/10.),sin(iTime/10.),0) ;\n    \n    vec3 hit = march(cam, tar, p);\n    col = vec3(mod(DE(hit),.1)*10.);\n    col = color(hit);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\nfloat squiggly(vec3 pos)\n{\n    pos.x += iTime*.2;\n    pos *= 5.;\n    float res = 1.-abs(cos(pos.x)*sin(pos.y) + cos(pos.y)*sin(pos.z) + cos(pos.z)*sin(pos.x));\n    pos *= -2.;\n    res += .5*(1.-abs(cos(pos.x)*sin(pos.y) + cos(pos.y)*sin(pos.z) + cos(pos.z)*sin(pos.x)));\n    pos *= -1.3;\n    res += .25*(1.-abs(cos(pos.x)*sin(pos.y) + cos(pos.y)*sin(pos.z) + cos(pos.z)*sin(pos.x)));\n    pos *= -3.;\n    res += .4*(1.-abs(cos(pos.x)*sin(pos.y) + cos(pos.y)*sin(pos.z) + cos(pos.z)*sin(pos.x)));\n    return res;\n}\n\nfloat DE(vec3 p)\n{\n    float tmp = (cos(p.x)*sin(p.y) + cos(p.y)*sin(p.z) + cos(p.z)*sin(p.x))*.5;\n    float def = squiggly(p)*.025;\n    return tmp-exp(-tmp*tmp)*def;\n}\n\nvec3 march(vec3 cam, vec3 tar, vec2 p)\n{\n    return march(cam, tar, p, 1.);\n}\n\nvec3 march(vec3 cam, vec3 tar, vec2 p, float f)\n{\n    mat3 camcoord;\n    camcoord[2] = normalize(tar-cam);\n    camcoord[0] = cross(camcoord[2],vec3(0,0,1));\n    camcoord[1] = cross(camcoord[0], camcoord[2]);\n    vec3 dir = camcoord*vec3(p,f);\n    \n    float l = 0.;\n    float d;\n    for (int i = 0; i < 100; i++)\n    {\n        d = DE(cam+dir*l)*.9;\n        if (abs(d)<.0000001 || d>50.) break;\n        l+=d;\n    }\n    return cam+dir*l;\n}\n\nvec3 color(vec3 pos)\n{\n    if (length(pos)>50.) return vec3(0);\n    vec3 de = vec3(.0001,0,0);\n    vec3 norm = normalize(vec3(\n        DE(pos+de.xyz)-DE(pos-de.xyz),\n        DE(pos+de.zxy)-DE(pos-de.zxy),\n        DE(pos+de.yzx)-DE(pos-de.yzx)));\n    float rot = -iTime;\n    norm.xy *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n    return mix(vec3(.1),.5*(norm+1.),squiggly(pos));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 213, 616], [620, 620, 646, 646, 1132], [1134, 1134, 1152, 1152, 1302], [1304, 1304, 1344, 1344, 1381], [1383, 1383, 1432, 1432, 1820], [1822, 1822, 1844, 1844, 2208]], "test": "error"}
{"id": "WsyXzW", "name": "Mountain Fly-by", "author": "wessles", "description": "Simple ray-marched terrain.", "tags": ["mountain"], "likes": 0, "viewed": 358, "published": "Public", "date": "1595479333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CAM_ROTATE\n\n#define ITER 50\n#define BASE_FOV 1.0\n\nstruct HitResult {\n\tfloat dist;\n    vec3 col;\n};\n    \nfloat rand(vec2 co) {\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = rand(i);\n    float b = rand(i+vec2(1.,0.));\n    float c = rand(i+vec2(0.,1.));\n    float d = rand(i+vec2(1.,1.));\n    \n    vec2 u = f*f*(3.-2.*f);\n     \n    float n = mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;\n    n = abs(n);\n    n = 1.-n;\n    n*=pow(n,2.);\n    return n;\n}\n\n#define OCT 6\n#define SCL 2.1;\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float freq = 0.;\n    \n    for(int i = 0; i < OCT; i++) {\n        value += amplitude * (1.-pow(1.-noise(st),5.));\n        st *= SCL;\n        amplitude *= 0.45;\n    }\n    \n    return value;\n}\n\n\n#define scale 1.\nfloat dist(vec3 p) {\n    float d = p.y+fbm(p.xz);\n    d = min(d, p.y+0.6);\n    return d;\n}\n    \nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = dist(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.1, 0.0);\n    return normalize(vec3( dist(pos + eps_zero.xyy), dist(pos + eps_zero.yxy), dist(pos + eps_zero.yyx) ) - c);\n}\n\nHitResult march(vec3 o, vec3 r) {\n    HitResult result;\n    \n    result.col = vec3(1.,1.,1.);\n    result.dist = 0.;\n    \n    vec3 p = o;\n    \n    for(int i = 0; i < ITER; i++) {\n        float d = dist(p)*.7;\n        p += r*d;\n        result.dist += d;\n    }\n    vec3 normal = calcNormal(p);\n    float light = max(0., dot(normal, normalize(vec3(1.,10., 1.))));\n    result.col = mix(vec3(.9, 0.86, 0.87), vec3(0.1,0.5,0.1), (-p.y)*2.);\n    if(p.y < -0.58) result.col = vec3(0.,0.,1.);\n    result.col *= light;\n    \n    return result;\n}\n\n// hue2rgb function I ripped off.\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    float yrot = .43;\n    vec3 origin = vec3(0,yrot,0.);\n    \n    float r = iMouse.x/100. + iTime * .2;\n    mat2 rot = mat2(cos(r),-sin(r),sin(r),cos(r));\n    yrot /=2.;\n    ray.yz *= mat2(cos(yrot),-sin(yrot),sin(yrot),cos(yrot));\n    origin.xz *= rot;\n    ray.xz *= rot;\n    \n    origin += vec3(1000., 0, sin(iTime / 5.0) * 50.0);\n    \n    \n    if(ray.y >0.) {\n        fragColor = vec4(1.);\n    } else {\n        HitResult hit = march(origin, ray);\n        float t = hit.dist;\n\n\n        vec3 col = mix(hit.col, vec3(1.), t/20.);\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 133, 133, 202], [204, 204, 226, 226, 571], [605, 605, 625, 625, 868], [888, 888, 908, 908, 978], [984, 984, 1011, 1032, 1262], [1264, 1264, 1297, 1297, 1797], [1892, 1892, 1916, 1916, 2025], [2027, 2027, 2084, 2134, 2886]], "test": "valid"}
{"id": "wt2cDK", "name": "002 - Ray Tracer", "author": "Mr_Admirals", "description": "Experimenting with raytracing.", "tags": ["raytracing"], "likes": 1, "viewed": 62, "published": "Public", "date": "1595453638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray\n{\n\tvec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n \tvec3 color;\n    vec3 dir;\n};\n    \nstruct Material\n{\n  \tvec3 color;\n    float diffuse;\n    float specular;\n};\n    \nstruct Sphere\n{\n  \tvec3 pos;\n    float r;\n    Material mat;\n};\n    \nstruct Plane \n{\n    vec3 normal;\n    Material mat;\n};\n    \nstruct Hit\n{\n\tvec3 point;\n    vec3 normal;\n    Material mat;\n};\n    \nLight light;\nLight ambientLight;\nPlane plane;\nvec3 camera;\nconst int numSpheres = 2;\nSphere spheres[numSpheres];\n\nconst float exposure = 0.5;\nconst float gamma = 1.0;\n\nconst int iterations = 4;\nconst float Epsilon = 1e-3;\nconst float\tambientConstant = 0.08;\nconst float smoothness = 0.5;\n\n// Computes scene object values\nvoid SetUpScene()\n{\n    light = Light(vec3(1.0), normalize(vec3(1.0, -0.75, 1.0)));\n    ambientLight = Light(vec3(1.0, 1.0, 1.0), normalize(vec3(1.0)));\n    plane = Plane(vec3(0.0, 1.0, 0.0), Material(vec3(0.8), 1.0, 0.0));\n    camera = vec3(0.0, 1.0, -10.0);\n    spheres[0] = Sphere(vec3(-4.0, 3.0 + sin(iTime), 0), 2.0, Material(vec3(1.0, 0.5, 0.2), 1.0, 1.0));\n    spheres[1] = Sphere(vec3( 4.0 + cos(iTime), 3.0, 0), 2.5, Material(vec3(0.5, 0.2, 1.0), 1.0, 1.0));\n}\n    \n// Tests for intersection between ray and sphere\nbool IntersectionTest(out Hit hit, Ray ray, Sphere sphere)\n{\n    // Check for a Negative Square Root\n    vec3 oc = sphere.pos - ray.origin;\n    float l = dot(ray.dir, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.r, 2.0);\n    if (det < 0.0) return false;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return false;\n    hit = Hit(ray.origin + len*ray.dir, (ray.origin + len*ray.dir - sphere.pos) / sphere.r, sphere.mat);\n    return true;\n}\n\n// Test for intersection between ray and plane\nbool IntersectionTest(out Hit hit, Ray ray, Plane plane) \n{\n    float len = -dot(ray.origin, plane.normal) / dot(ray.dir, plane.normal);\n    if (len < 0.0) return false;\n    hit = Hit(ray.origin + len * ray.dir, plane.normal, plane.mat);\n    \n    return true;\n}\n\n// Trace a ray throughout the scene, testing for intersections with all objects\nbool Trace(out Hit hit, Ray ray)\n{   \n    Hit intersection;\n    \n    for(int i = 0; i < numSpheres; i++)\n    {\n     \tif(IntersectionTest(intersection, ray, spheres[i]))\n        {\n            hit = intersection;\n    \t\treturn true;\n        }\n    }\n    \n    if(IntersectionTest(intersection, ray, plane))\n    {\n        hit = intersection;\n     \treturn true;   \n    }\n    \n    return false;\n}\n\n// Computes the color value from a ray and its bounces\nvec3 GetColor(Ray ray)\n{\n    vec3 color;\n    \n    vec3 ambient = ambientConstant * ambientLight.color;\n    \n    vec3 energyFalloff = vec3(1.0);\n    \n    for(int i = 0; i < iterations; i++)\n    {\n        Hit hit;\n    \tif(Trace(hit, ray))\n    \t{\n            // Schlick's Approximation\n            float refractionIndex = 3.0;\n         \tfloat f0 = pow(refractionIndex - 1.0, 2.0) / pow(refractionIndex + 1.0, 2.0);\n            float ndotv = clamp(dot(hit.normal, -ray.dir), 0.0, 1.0);\n            float fresnel = f0 + (1.0 - f0) * pow(1.0 - ndotv, 5.0);\n            energyFalloff *= fresnel;\n            \n            // Check for obstacles between surface and light\n            Hit shadowHit;\n            if(!Trace(shadowHit, Ray(hit.point + -light.dir * Epsilon, -light.dir)))\n            {\n                // Blinn-Phong\n                float shade = clamp(dot(hit.normal, -light.dir), 0.0, 1.0);\n                vec3 diffuse = hit.mat.color * light.color * hit.mat.diffuse * shade * energyFalloff;\n                \n                vec3 halfDir = normalize(-light.dir + -ray.dir);\n                vec3 specular = light.color * hit.mat.specular * pow(clamp(dot(halfDir, hit.normal), 0.0, 1.0), smoothness * 100.0);               \n                \n                color += diffuse + specular;\n            }\n            \n            // Calculate reflectance ray\n            ray = Ray(hit.point + hit.normal * Epsilon, reflect(ray.dir, hit.normal));\n    \t}\n        else\n        {\n           color += ambient;\n           break;\n        }\n    }\n    \n    return color;\n}\n\n\n// Fragment program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    SetUpScene();\n    \n    Ray ray = Ray(camera, normalize(vec3(uv, 1.0)));\n    vec3 col = GetColor(ray);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 693, 712, 712, 1162], [1168, 1217, 1277, 1317, 1763], [1765, 1812, 1871, 1871, 2073], [2075, 2155, 2189, 2189, 2543], [2545, 2600, 2624, 2624, 4162], [4165, 4185, 4242, 4242, 4458]], "test": "valid"}
{"id": "Wt2cR1", "name": "Electronic Gems - Gem", "author": "frhun", "description": "the gem from the intro of electronic gems", "tags": ["gem"], "likes": 6, "viewed": 234, "published": "Public API", "date": "1593818883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\nconst float pifi = pi / 5.0;\nconst float pifih = pifi / 2.0;\nconst float r = 0.4;\nconst float ri = 0.3;\nconst float ri2 = 0.36;\nconst float h = 0.6;\nconst float hu = 0.5;\nconst float huh = 0.55;\n\nstruct line {\n    vec3 a;\n    vec3 b;\n};\n\nfloat segment(vec2 u, line l){\n    vec2 a = l.a.xy;\n    vec2 b = l.b.xy;\n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nvoid addCol(inout vec3 col, float dist){\n    col += vec3(clamp(\n    \t1.0 - (( dist - 0.002) / 0.003)\n        , 0.0\n        , 1.0\n    ));\n}\n\nbool drawLine(line l){\n    return l.b.z > -0.1 && l.a.z > -0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    uv *= 2.0;\n    uv /= 1.5;\n\n    vec3 col = vec3(0.);\n    \n    float ao = -iTime / 4.0;\n    vec3 base = vec3(0.0, - h / 2.0, 0.0);\n    \n    for(float i = 0.0; i < 10.0; i = i + 1.0){\n        vec3 mainEdge = vec3(\n            sin(pifi * i + ao) * r,\n            hu,\n            cos(pifi * i + ao) * r\n        );\n        vec3 upperMidpoint = vec3(\n            sin(pifi * i + pifih + ao) * r,\n            hu,\n            cos(pifi * i + pifih + ao) * r\n        );\n        vec3 prevUpperMidpoint = vec3(\n            sin(pifi * i - pifih + ao) * r,\n            hu,\n            cos(pifi * i - pifih + ao) * r\n        );\n        vec3 upperMainEdgeEnd = vec3(\n            sin(pifi * i + ao) * ri2,\n            huh,\n            cos(pifi * i + ao) * ri2\n        );\n        vec3 topMidpoint = vec3(\n            sin(pifi * i + pifih + ao) * ri,\n            h,\n            cos(pifi * i + pifih + ao) * ri\n        );\n        vec3 prevTopMidpoint = vec3(\n            sin(pifi * i - pifih + ao) * ri,\n            h,\n            cos(pifi * i - pifih + ao) * ri\n        );\n        \n        line lineToDraw = line(\n        \tbase,\n            base + mainEdge\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge * 0.33,\n            base + upperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge * 0.33,\n            base + prevUpperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge,\n            base + upperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge,\n            base + prevUpperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge,\n            base + upperMainEdgeEnd\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + upperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + prevUpperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + topMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + prevTopMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + topMidpoint,\n            base + prevTopMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n    }\n    \n    col = clamp(col, 0.0, 1.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 294, 294, 424], [426, 426, 466, 466, 564], [566, 566, 588, 588, 631], [633, 633, 690, 690, 4003]], "test": "valid"}
{"id": "Wt2cW3", "name": "stb - Semitransparent Voxels", "author": "stb", "description": "Semitransparent voxels!", "tags": ["3d", "transparency", "voxels", "out", "adc", "bailout", "bail"], "likes": 7, "viewed": 67, "published": "Public", "date": "1595547803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tSemitransparent Voxels\n\t2020 stb (2015 BeyondTheStatic)\n\n\tThe renderer will stop tracing if RGBA.a < ADC. Set ADC to 0.0 to disable it. This\n\timplementation is imperfect, but still effective.\n\t\n\tThe mouse controls the camera. Play with the three consts!\n\n\tChanges:\n\t\t- fixed fog blending\n\t\t- updated volumetric fog (add this between lines 82-83):\n            else {\n                float f = clamp(map(LV-.5+7.*lPos)*1., 0., 1.);\n                vec3 vCol = f * vec3(.7, .8, 1.) * clamp(map(LV-.5+2.7*lPos)/3.+.5, 0., 1.); \n                float alph = .025;\n                RGBA.rgb += RGBA.a * alph * vCol;\n                RGBA.a *= 1.00001 - alph;\n            }\n*/\nconst float ADC\t\t= .1;\t// 0.0-1.0\nconst float alpha\t= .1;\t// 0.0-1.0\nconst float maxDist\t= 80.;\t// 0.0-?.?\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nfloat map(in vec3 p) {\n    float f;\n    p.x += 10.*(.5-float(mod(p.z-0., 40.)<20.)) - 5.;\n    p.xz = mod(p.xz, 20.)-10.;\n    f = length(p)-8.;\n    f = min(f, p.y+7.);\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res\t= iResolution.xy;\n    vec2 uv\t\t= (fragCoord-.5*res) / res.y;\n\t\n    vec3 camPos\t= vec3(.0, .0, -15.);\n    vec3 rayDir\t= normalize(vec3(uv, .5));\n    \n    vec2 nav = vec2(.8*cos(.1*iTime), -.337*iTime);\n    camPos.yz = rotate(camPos.yz, nav.x);\n    camPos.xz = rotate(camPos.xz, nav.y);\n    rayDir.yz = rotate(rayDir.yz, nav.x);\n    rayDir.xz = rotate(rayDir.xz, nav.y);\n    \n    vec3 adj, xV, yV, zV, V_;\n    vec3 po\t= sign(rayDir);\n    vec3 V\t= camPos, LV;\n    float dist;\n    \n    // light pos, background\n    vec3 lPos\t= normalize(vec3(.5, 1., .25));\n    vec3 bg\t\t= vec3(.3, .5, 1.) + pow(length(rayDir+lPos)/2.5, 2.);\n    \n    vec4 RGBA\t= vec4(vec3(0.), 1.);\n    \n    for(int i=0; i<150; i++) {\n        dist = length(V-camPos);\n        \n        LV = V;\n        \n        adj = mix(floor(V+po), ceil(V+po), .5-.5*po) - V;\n        \n        xV = adj.x * vec3(1., rayDir.yz/rayDir.x);\n        yV = adj.y * vec3(rayDir.xz/rayDir.y, 1.);\n        zV = adj.z * vec3(rayDir.xy/rayDir.z, 1.);\n\n        V_ = vec3(length(xV)<length(yV) ? xV : yV.xzy);\n    \tV_ = vec3(length(V_)<length(zV) ? V_ : zV);\n        \n        V += V_;\n        if(dist>maxDist || RGBA.a<ADC) break;\n        if(map(floor((V+LV)/2.))<0.){\n            vec3 vCol = vec3(.1, 1., .1) * clamp(map(LV-.5+2.7*lPos)/3.+.5, 0., 1.);\n            RGBA.rgb += RGBA.a * alpha * mix(vCol, bg, dist/maxDist);\n            RGBA.a *= 1.00001 - alpha;\n        }\n    }\n    \n    RGBA.rgb += bg * RGBA.a;\n    \n    fragColor = vec4(RGBA.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[851, 851, 873, 873, 1033], [1035, 1035, 1090, 1090, 2589]], "test": "valid"}
{"id": "wt2cWh", "name": "Shaders are coming back in style", "author": "koo1ant", "description": "Someone said my last shader reminded him of Twin Peaks, so I fixed it :)", "tags": ["3d", "checkerboard", "ball"], "likes": 2, "viewed": 181, "published": "Public API", "date": "1594270306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n#define resolution iResolution\n\n// Original shader: https://www.shadertoy.com/view/3tByzw\n\nprecision highp float;\n\nmat4 rotX(in float angle) {\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), - sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotY(in float angle) {\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1.0, 0, 0,\n        - sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return\n    (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nfloat sat(float v){\n    return clamp(v, 0.,1.);\n}\n\nvoid ball(inout float buf, vec2 uv, float phase, float radius, float bh) {\n    float bounce = abs(sin(t * 3.0 + phase)) * bh;\n    float bd = 1.00 + pow(abs(sin(t * 3.0 + 3.14 / 2.0 - 0.1 + phase)), 50.00) * 0.17;\n    float ballRadius = radius;\n    float shadowSize = abs(sin(t * 3.0 + phase)) * 1.00 + 1.00;\n    float a = atan(uv.y - bounce + 0.02, uv.x + -0.37);\n\n    // Shadow\n    float shadow = 1.0 - smoothstep(-0.5, 0.8, length(vec2(uv.x * (shadowSize*2.), uv.y * 1.75 * (shadowSize*2.)) - vec2(0.00, - 0.36)) - ballRadius + 0.0);\n    buf -= smoothstep(0.0, 0.8, shadow) * 0.65; // Soften the shadow a little bit\n\t\n    // Cut a hole in the buffer\n    buf *= step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius);\n\n    // Add specular\n    float mask = sat(1.0 - step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius));\n    float impulse = sin(t*6.+1.20); // Spin a little faster when it hits the ground\n    float spin = sin(a * 18.0 - ((t * 10.0) + impulse)) * 0.03;\n    float specular = smoothstep(\n        0.30 - spin,\n        -0.02,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) *  mask +\n        // Fake reflection\n        smoothstep(\n            0.30 + sin(a * 18.0 + t*10.) * 0.03,\n            +0.52,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) * mask;;\n\n    buf += specular;\n}\n\nvoid ground(inout float p, vec2 uv, float offset) {\n    vec2 guv = uv;\n    guv.x = abs(fract(guv.x*1.50)*2.-1.);\n\n    guv.y = fract(guv.y*2.70)*1.50 + offset + -1.00;\n    // Sine checkers\n    //p += step(sin(uv.y * 10.00) * sin(t), sin(uv.x * 10.0));\n    p -=  1.-step(0.00,guv.x+guv.y) -1.0 +step(0.77, guv.x + guv.y);\n}\n\nvoid light(inout float p, vec2 pv){\n    vec2 lightPos = vec2(pv.x, pv.y - 2.);\n    p *= 1.-smoothstep(0.0, 3.5, length(lightPos - vec2(sin(t), 0.0)));\n}\n\nvoid projection(inout vec2 pv){\n\t vec4 m =\n        vec4(pv.x, pv.y, 0.00, 0.00) *\n        rotY(sin(t * 1.0) * 0.1) *\n        rotX(0.60) *\n        1.2 + 0.2;\n    \n    pv /= abs(0.8 - m.z);\n}\n\nvec4 image()\n{\n    vec2 pv = setupSpace(gl_FragCoord.xy, resolution.xy); // Perspective UV\n    vec2 uv = setupSpace(gl_FragCoord.xy, resolution.xy); // Screen-space UV\n    float camPos = -t*0.8; // Camera speed\n    float p; // Image\n    \n   \tprojection(pv);\n    \n    pv.y += camPos;\n   \n    // Scene\n    float w = 1.50;\n    ground(p, pv, 0.00);\n    ground(p, pv, -w);\n    ground(p, pv, +w);\n    light(p, vec2(pv.x, pv.y - camPos));\n    ball(p, vec2(uv.x + 0.180 + sin(t*0.9+0.4)*0.1 , uv.y + -0.40), 1.00 , 0.18, 0.2);\n    \n    vec3 color = vec3(p);\n    color.r += -abs(uv.y)*0.1;\n    \n    return vec4(color, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = image();\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 158, 158, 292], [294, 294, 321, 321, 457], [459, 459, 500, 500, 577], [579, 579, 598, 598, 628], [630, 630, 704, 704, 2060], [2062, 2062, 2113, 2113, 2383], [2385, 2385, 2420, 2420, 2537], [2539, 2539, 2570, 2570, 2728], [2730, 2730, 2744, 2744, 3346], [3347, 3347, 3404, 3404, 3431]], "test": "valid"}
{"id": "wt2cWK", "name": "Zegend of Lelda: Windfaker Water", "author": "pprovins", "description": "By generating a voronoi pattern and detecting edges of cells it is possible to layer two voronoi fields and use a displacement map to create a water effect similar to something seen in a popular video game. ", "tags": ["voronoi", "water", "zelda", "toon", "windwaker", "voronoiegde"], "likes": 6, "viewed": 335, "published": "Public", "date": "1595423852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 pseudoRand(vec2 p) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nvec3 vorobord( in vec2 x ) {\n    vec2 idx = floor(x);\n    vec2 pad = fract(x);\n\n\tvec2 selfcell, closecell;\n\n    float mindist = 4.0;\n    for( float x = -1.0; x <= 1.0; ++x) {\n        for(float y = -1.0; y <= 1.0; ++y) {\n            vec2 offset = vec2(x, y);\n            vec2 self = pseudoRand( idx + offset );\n            self = 0.5 + 0.5*sin( iTime * self * .5 );\n            vec2 neighbor = offset + self - pad;\n            float dist = length(neighbor);\n\n            if (dist < mindist) {\n                mindist = dist;\n                closecell = neighbor;\n                selfcell = offset;\n            }\n        }\n    }\n\n    mindist = 4.0;\n    for(float x = -2.0; x <= 2.0; ++x) {\n        for(float y = -2.0; y <= 2.0; ++y) {\n            vec2 offsetcell = selfcell + vec2(x, y);\n            vec2 self = pseudoRand(idx + offsetcell);\n            self = 0.5 + 0.5*sin(iTime * self  * 0.5);\n            vec2 neighbor = offsetcell + self - pad;\n\n            if(length(closecell - neighbor) > 0.00001){\n                mindist = sin(min(mindist, dot(0.5 * (closecell + neighbor), normalize(neighbor - closecell))));\n            }\n        }\n    }\n\n    return vec3(mindist, closecell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Animate the texture for a water ripple\n    vec3 displ = vec3(texture(iChannel0, (uv * 0.25) + (sin(iTime * .15) * 0.25) + 0.25).xyz);\n    // Create a voronoi pattern\n    vec3 layerone = vorobord(5.0 * mix(uv, displ.rg, 0.12));\n    vec3 layertwo = vorobord(3.0 * mix((uv + .5), displ.rg, 0.1));\n    // Color the border and body\n    vec3 locol = mix(vec3(0.7,0.7,0.9), vec3(0.0, 0.0, 1.0), smoothstep(0.09, 0.1, layerone.x * 2.2));\n    vec3 ltcol = mix(vec3(.8,.8,1.0), vec3(1.0, 1.0, 1.0), smoothstep(0.04, 0.05, layertwo.x * 3.2));\n    // Mix uppper water with lower water\n    vec3 vorolayers = mix(locol, ltcol, 0.3);\n\n    fragColor = vec4(vorolayers, 1.0);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 115], [117, 190, 218, 218, 1377], [1379, 1379, 1436, 1436, 2151]], "test": "error"}
{"id": "Wt2cWm", "name": "Moebius Lizard - filled", "author": "FabriceNeyret2", "description": "filled version of \"Moebius Lizard\", Escher-like tiling on Moebius spiral, by iapafoto. [url]https://shadertoy.com/view/wtjyz1[/url]\nMouse control.", "tags": ["2d", "mobius", "escher", "lizard", "moebus"], "likes": 12, "viewed": 305, "published": "Public API", "date": "1594562888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === variant of \"Moebius Lizard\" by iapafoto. https://shadertoy.com/view/wtjyz1\n// see study here :  https://shadertoy.com/view/WtBcRD\n// Here: filled shapes\n\n// --- L() get the distance d of p=U-a to segment(a-a,b-a) \n// AND get whether pixel in/out shape by counting the number of intersection with [U,U+(0,inf)]\n//     for close contours, n is odd inside and even outside.\n// l get the label of the closest line\nvec2 q; float s,c,v,d=1e3; int k,n=0;\n#define L(p,l) v = length( q = p-b*( c = clamp( s = dot(p,b)/dot(b,b),0.,1.))); \\\n               if (v<d) d=v, k=l;                                               \\\n               c = clamp ( s = (p).y/b.y, 0.,1.);                               \\\n               if ( c == s && s * b.x > (p).x ) n++\n            \n// --- T encodes shape, turned 4x by Pi/2, + copied trough tiles.\n// note that a Lizard is contoured by 3 of these.        Vsame Yv                         Vsame xV\nint[] T = int[](6,0,9,2,12,5,6,10,0,20,  6,26,  12,20,11,17,14,17,17,18,15,22,11,26,16,26,22,18,22,27,25,28,28,30,30,26\n          // left hand  - left of head (10)head right of head                   -                right foot\n    ,     // completed contour. Used only with FILL=2\n    26,24,28,21,29,18,38,18,30,12,30,7,34,11,38,13,39,10,39,7,36,8,  30,2,    24,8,14,2,9,-4,6,-1,4,2, 6,0 );\n          //       ^same y^                        ^same x^           <- possible issues\n\nvoid drawTile(vec2 m, int i, int r) {\n    vec2 a = vec2(T[i  ],T[i+1]),\n         b = vec2(T[i+2],T[i+3]) - a;\n    L(m-a, 4*r);\n}\n    \nvoid mainImage(out vec4 O, vec2 u ) {\n    \n    vec2 R = iResolution.xy, D = vec2(6,2),\n         m = 2.*iMouse.xy/R,\n         U = (u - .5*R) / R.y ,z = U + vec2(1,0), \n         g = vec2(30,26), I;   \n    float w = 3.*48./R.y;\n#if 0                                    // tile plane\n    U *= 1.3; I = floor(U+.5); U *= 48.;\n#else \t                                 // tile Moebius spiral\n    U *= mat2(z,-z.y,z) / dot(U,U);\n    U += .5;\n    float a = atan(U.y, U.x)/6.283;\n\tU =  m + log(length(U)) *vec2(.5,-1) + iTime/20.\n           + a*D;\n // w = 48.* determinant(mat2(dFdx(U),dFdy(U)));  // Jacobian to eval distortions, see https://www.shadertoy.com/view/WlByRW\n    vec2 dFx = dFdx(U), dFy = dFdy(U); // eliminate atan discont, see  https://www.shadertoy.com/view/WlScRW\n    float dax = dFdx(a), day = dFdy(a),\n           dx = abs(dax) > .5 ? sign(dax) : 0.,      // detect the jump\n           dy = abs(day) > .5 ? sign(day) : 0.;      // ( jump is +- 1 since atan/2PI, 0.5 threshold is large )\n    dFx -= D*dx, dFy -= D*dy,                        // eliminates in derivatives\n    w = determinant(mat2(dFx,dFy));                  // corrected Jacobian det\n    w = 48.* 2.*sqrt(abs(w));            // pixel width, for antialiasing\n    U = 48.*fract( U ) - g;              // tiles\n#endif\n    \n    int nn=-1; float  e = 1e3;\n    for (int r=0; r < 4; r++)\n    {   \n        m = mod(U+g+8.,48.)-8.;\n        U = vec2(-U.y,U.x); \n        for (int i=0; i <  T.length()-2 ; i+=2) {\n            drawTile(m,i,r);\n        }\n      e = min(e, min(length(m-vec2(7.8,20)),length(m-vec2(4.5,20)))-.8);  // eyes\n\n        if (n%2>0) nn=r, n=0; // for checkered filling color\n    }\n    if(nn>=0) n=nn; \n    // --- returned values: d = distance to contour, n = fill parity, I = tileId\n\n    e = smoothstep(w,0.,abs(e));\n    d = smoothstep(w,0.,abs(d));\n  //O = .5 + vec4( n%2 > 0 ? 1. -d - e : e );   // just surfaces\n    O = .5 + vec4( n%2 > 0 ? 1. - e : e ) - d;  // + border\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1413, 1413, 1450, 1450, 1541], [1547, 1547, 1584, 1584, 3504]], "test": "error"}
{"id": "wt2cWR", "name": "flamey circle tail thing", "author": "sh1boot", "description": "not finished", "tags": ["circle", "mask", "dissipation"], "likes": 1, "viewed": 200, "published": "Public API", "date": "1594157618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(in float x) {\n    x = log2(abs(x) + 0.000001);\n    x = fract(sin(x) * 21.56789 + cos(x) * 11.98765);\n    return fract(x + 2.0);\n}\n\nfloat random(in float x, in float y) {\n    return random(sin(x * 7.1010101) + cos(y * 9.3131313) + 2.1);\n}\n\nvec2 bubble(int slice, int i) {\n    float fs = fract(float(slice) * 0.1);\n    float f = float(i) + 123.45 * fs;\n    return vec2(\n        random(1.5 * f, 3.1415926 * f) * 2.0,\n        random(2.5 * f, 1.6180340 * f) * 0.1 + fs);\n}\n\nfloat tail(float y, float t) {\n    return (sin(t - y) + sin((t - y) * 3.1)) * 0.2 + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n#if 1\n    uv.y = (uv.y - .5) * iResolution.y / iResolution.x + .5;\n#else\n    uv.x = (uv.x - .5) * iResolution.x / iResolution.y + .5;\n#endif\n    #if 0\n    float radius = 0.04;\n#else\n    float radius = 0.005 + uv.y * 0.15;\n#endif\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float t = fract(iTime * 0.3);\n    float y = fract(uv.y - t);\n    for (int j = -1; j < 2; ++j) {\n        int row = int(y * 10.0) + j;\n        for (int i = 0; i < 45; i++) {\n            vec2 bub = bubble(row, i);\n            bub.y = fract(bub.y + t);\n            float x = tail(bub.y, iTime * 0.3);\n            if (distance(x, bub.x) < 0.075) bub.x += 0.15;\n\n            col *= smoothstep(radius, radius*1.01, distance(uv, bub));\n        }\n    }\n    float p = tail(uv.y, iTime * 0.3);\n    col *= 1.0 - smoothstep(0.1,0.11, distance(p, uv.x));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 142], [144, 144, 182, 182, 250], [252, 252, 283, 283, 480], [482, 482, 512, 512, 572], [574, 574, 629, 629, 1571]], "test": "valid"}
{"id": "Wt2czR", "name": "y=cos(x)*sin(z)", "author": "changjiu", "description": "the 3D graph of the function:y=cos(x)*sin(z)", "tags": ["math", "graph", "function"], "likes": 3, "viewed": 186, "published": "Public API", "date": "1593592389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.0001;\n\nvec3 rayDir;\n \nvec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nvec3 cameraDir = vec3(0.0, 0.0, -1.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\nvec3 applyMatrix4(vec3 v3, mat4 m4){\n\t\tfloat x = v3.x, y = v3.y, z = v3.z;\n\t\tfloat e[16];\n    \te[0] = m4[0][0];\n        e[1] = m4[0][1];\n        e[2] = m4[0][2];\n        e[3] = m4[0][3];\n    \n    \te[4] = m4[1][0];\n        e[5] = m4[1][1];\n        e[6] = m4[1][2];\n        e[7] = m4[1][3];\n    \n        e[8] = m4[2][0];\n        e[9] = m4[2][1];\n        e[10] = m4[2][2];\n        e[11] = m4[2][3];\n    \n    \te[12] = m4[3][0];\n        e[13] = m4[3][1];\n        e[14] = m4[3][2];\n        e[15] = m4[3][3];\n\n\t\tfloat w = 1. / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tv3.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tv3.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tv3.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn v3;\n}\n\nmat4 arrayToM4(float e[16]){\n    mat4 m4;\n    \n    m4[0][0]=e[0] ;\nm4[0][1]=e[1] ;\nm4[0][2]=e[2] ;\nm4[0][3]=e[3] ;\nm4[1][0]=e[4] ;\nm4[1][1]=e[5] ;\nm4[1][2]=e[6] ;\nm4[1][3]=e[7] ;\nm4[2][0]=e[8] ;\nm4[2][1]=e[9] ;\n m4[2][2]=e[10];\n m4[2][3]=e[11];\n m4[3][0]=e[12];\n m4[3][1]=e[13];\n m4[3][2]=e[14];\n m4[3][3]=e[15];\n    \n\treturn m4;\n}\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(0.5*iTime)*10.0;\n    cameraPosition.y = (sin(iTime)+1.0)*2.0;\n    cameraPosition.z = cos(0.5*iTime)*10.0;\n    \n    if(iMouse.z>0.){\n        float theta = -iMouse.x/iResolution.x*3.14159*2.0;\n        float y = 20.-iMouse.y/iResolution.y*20.0;\n        cameraPosition.x = sin(theta)*10.0;\n        cameraPosition.y = y;\n        cameraPosition.z = cos(theta)*10.0;\n    }\n    \n  \n    \n\treturn cameraPosition;\n}\n\nvec3 unproject(vec3 pointScreen){\n    \n    cameraPosition = getCameraPosition();\n\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 vpMatrix = projectMatrix * viewMatrix;\n    \n    mat4 VPmatrixInverse = inverse(vpMatrix);\n    \n\tvec3 pointV3 = applyMatrix4(pointScreen, VPmatrixInverse);\n\n    return pointV3;\n}\n\nvec3 getPointV3ByFragCoord(vec2 coord){\n    \n    vec3 pointScreen = vec3(coord.x, coord.y, 0.5);\n\tvec3 pointV3 = unproject(pointScreen);\n\n    return pointV3;\n}\n\nvec3 getRayDirByCoord(vec2 coord){\n\tvec3 pointV3 = getPointV3ByFragCoord(coord);\n    vec3 ray = pointV3 - cameraPosition;\n    return normalize(ray);\n}\n\n\nfloat funcSDF(vec3 p) {\n    \n    return p.y-cos(p.x)*sin(p.z);\n}\n\nfloat sceneSDF(vec3 p) {\n    //To prevent artefact, *0.8\n    float minDis2 = funcSDF(p)*0.8;\n    return minDis2;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n            \nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0,5.0,3.0);\n    vec3 light1Intensity = vec3(1., 1., 1.);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 cood = vec2(( fragCoord.x / iResolution.x ) * 2. - 1., ( fragCoord.y / iResolution.y ) * 2. - 1.);\n    rayDir = getRayDirByCoord(cood);\n    \n    float dist = shortestDistanceToSurface(cameraPosition, rayDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.1, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = cameraPosition + dist * rayDir;\n    \n    vec3 K_a = vec3(0.1, 0.1, 0.1);\n    vec3 K_d = vec3(0.3, 0.3, 0.3);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 1.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, cameraPosition);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2czR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 342, 342, 1127], [1129, 1129, 1183, 1183, 1423], [1425, 1425, 1558, 1558, 2835], [2837, 2837, 2873, 2873, 3622], [3624, 3624, 3652, 3652, 3955], [3957, 3957, 3982, 3982, 4436], [4438, 4438, 4471, 4471, 4935], [4937, 4937, 4976, 4976, 5096], [5098, 5098, 5132, 5132, 5248], [5251, 5251, 5274, 5274, 5315], [5317, 5317, 5341, 5373, 5431], [5433, 5433, 5524, 5524, 5830], [5832, 5832, 5861, 5861, 6171], [6173, 6173, 6313, 6313, 6742], [6756, 6756, 6841, 6841, 7212], [7214, 7214, 7271, 7271, 7935]], "test": "error"}
{"id": "Wt2czz", "name": "Cross of Light 2", "author": "GabrieleGiuseppini", "description": "This shader simulates the flash of light that typically accompanies spaceships exploding in space. It is centered with the mouse. This shader is cheaper than my other \"Cross of Light\" shader.", "tags": ["explosionflash"], "likes": 1, "viewed": 50, "published": "Public", "date": "1593608509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vertexProgress = mod(iTime, 1.0); // 0.0 -> 1.0\n    // Map vertexProgress to -0.48 -> 1.48\n    float progress = -0.48 + vertexProgress/(2. * .48);\n\n    // Calculate fragment's coordinates in the NDC space\n    vec2 centeredFragCoord = fragCoord.xy - iResolution.xy / 2.0;\n    vec2 ndc = vec2(\n        centeredFragCoord.x / iResolution.x,\n        centeredFragCoord.y / iResolution.y) * 2.0;\n\n    vec2 centerPosition = iMouse.xy - iResolution.xy / 2.0;\n    vec2 centerNdc = vec2(\n        centerPosition.x / iResolution.x,\n        centerPosition.y / iResolution.y) * 2.0;\n    \n    // Center\n    ndc = vec2(ndc.x - centerNdc.x, centerNdc.y - ndc.y);\n\n    // ------------------    \n    \n    vec2 rotNdc = ndc;\n    \n    progress = pow(1. - abs(progress), 9.0);\n    \n    float alpha = 1.0 - smoothstep(0.0, progress, sqrt(abs(rotNdc.x * rotNdc.y)));\n\n    fragColor = vec4(alpha, alpha, alpha, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2czz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 960]], "test": "valid"}
{"id": "wt2yDR", "name": "interpolation from 0 to 1", "author": "eclypse", "description": "interpolation from 0 to 1", "tags": ["interpolation"], "likes": 0, "viewed": 58, "published": "Public", "date": "1594156113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float value1 = (uv.x + uv.y);\n    float value2 = 1.0 - (uv.x + uv.y) * 0.5; // from bottom left 1 to top right 0\n    \n    float progress = fract(iTime * 0.25) ;\n    float ramp = 0.5;\n    \n    progress = 1.0 - (progress + progress * ramp); // from 1 to -1\n    \n   \tfloat sx = smoothstep( progress, progress + ramp, value2);\n    // Output to screen\n    fragColor = vec4(vec3(sx), 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 547]], "test": "valid"}
{"id": "wt2yDt", "name": "Waves v.5", "author": "pli", "description": "Nicer waves, and much better framerate.", "tags": ["learning"], "likes": 1, "viewed": 93, "published": "Public API", "date": "1595773147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define EYE_COLOR vec3(0., 0.0, 0.0)\n\n#define BOAT_INITIAL_X 0.1\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nfloat heightAt(float xd, float z) {\n    return -0.1 + 0.01 * cos(13.*xd + 2.*z);\n}\n\nfloat boatHeight(vec3 pos, float delta) {\n    return -0.1 - 0.01 * cos(6. * pos.x + delta * 2. * 3.14159) + 0.1;\n}\n\nfloat sphereSize(float x, float z) {\n    return 0.1 + 0.02 * cos(4.*x - z);\n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\tfloat initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\tvec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .5;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1.,5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.205, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n\n    col = colorVariation * (0.75 + dot(normal, light));\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.3);\n\tcol = mix(col, vec3(1.), (shineVariation -  0.5 * colorVariation) * spec);\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 566, 566, 615], [618, 618, 661, 661, 769], [772, 772, 825, 825, 865], [868, 868, 903, 903, 950], [952, 952, 993, 993, 1066], [1068, 1068, 1104, 1104, 1145], [1148, 1148, 1180, 1180, 1205], [1207, 1207, 1241, 1241, 1268], [1270, 1270, 1303, 1303, 1490], [1493, 1493, 1521, 1521, 1566], [1569, 1569, 1646, 1701, 4840], [4842, 4842, 4865, 4865, 5203], [5206, 5206, 5227, 5227, 6611], [6613, 6613, 6670, 6670, 6798]], "test": "valid"}
{"id": "wt2yDV", "name": "v3Text2.glsl", "author": "jorge2017a1", "description": "v3Text2.glsl", "tags": ["v3text2glsl"], "likes": 7, "viewed": 58, "published": "Public", "date": "1595445309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat letter(vec2 coord)\n{\n    float size = iResolution.x / 25.0;\n\n    float gt = iTime * 0.3; // global\n    float ct = floor(gt); // coarse\n    float rt = fract(gt); // repeated\n\n    vec2 gp = floor(coord / size * 7.0); // global\n    vec2 cp = floor(coord / size); // coarse\n    vec2 rp = floor(fract(coord / size) * 7.0); // repeated\n    vec2 odd = fract(rp * 0.5) * 2.0;\n\n    float th = (1.0 - pow(rand(cp + ct * 0.82), 3.0)) * 0.7;\n    float amp = smoothstep(th, th + 0.03, rt);\n    amp *= smoothstep(0.0, 0.05, 1.0 - rt);\n\n    float c = max(odd.x, odd.y); // 2x2 grid\n    c *= step(0.5, rand(gp + 0.1 * ct)); // random removal\n    c += min(odd.x, odd.y); // border and center points\n\n    c *= rp.x * (6.0 - rp.x); // cropping\n    c *= rp.y * (6.0 - rp.y);\n\n    return clamp(c, 0.0, 1.0) * amp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy;\n    float c; // MSAA with 2x2 RGSS sampling pattern\n    c  = letter(coord + vec2(-3.0 / 8.0, -1.0 / 8.0));\n    c += letter(coord + vec2( 1.0 / 8.0, -3.0 / 8.0));\n    c += letter(coord + vec2( 3.0 / 8.0,  1.0 / 8.0));\n    c += letter(coord + vec2(-1.0 / 8.0,  3.0 / 8.0));\n    fragColor = vec4(c / 4.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [93, 93, 119, 119, 893], [895, 895, 952, 952, 1288]], "test": "valid"}
{"id": "wt2yRR", "name": "Radial Uv Shader", "author": "loni852", "description": "Radial Uv Shader Map", "tags": ["uv", "uv", "radial", "uvmap", "radialuv"], "likes": 0, "viewed": 114, "published": "Public", "date": "1593612673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec2 uv)\n{\n\treturn texture(iChannel1,uv).r;\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0425*noise( p );\n    return f/0.9375;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float maxLength = distance( 0.5, 0.0);\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    \n    float r = distance(uv,vec2(0.0,0.0))/maxLength;\n    \n    float angle = atan(uv.x, uv.y) / 3.1416;\n    \n    \n    \n    \n    vec2 newuv = vec2(r,angle);\n    \n    //Untouched Radial UV\n    vec2 rounduv = vec2(r,angle);\n    rounduv *= 0.5;\n    rounduv += 0.5;\n    //Offset to match 0 to 1\n    rounduv.x -= 0.3;\n    \n    \n    //MOVE AROUND AND DISTORTION\n    newuv.x -= iTime*0.1;\n    vec2 zoominguv = vec2(r,angle);\n    zoominguv.x += iTime*0.1;\n    newuv.y += (iTime*0.05) + (fbm4(zoominguv)*0.05);\n    vec4 textures = texture(iChannel0,newuv);\n    \n    \n    //Point Showcasing UV Mapping (UVY MAPS TO RADIAL AND UVX TO DISTANCE FROM CENTER)\n    vec2 point = vec2(0.3,(sin(iTime)*0.5)+0.5);\n    textures.r += smoothstep(distance(point,rounduv)-0.01,distance(point,rounduv),0.01);\n    \n    \n    vec3 col = textures.rgb;\n    \n    col = vec3(r,angle,0.0);\n    \n\n    // Output to screen\n    fragColor =  vec4(0.1) + textures;\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 57], [59, 59, 81, 81, 271], [274, 274, 331, 381, 1438]], "test": "error"}
{"id": "Wt2yWh", "name": "Trig pattern", "author": "Oggbog", "description": "Experimenting with atan and others from the trig family", "tags": ["trig"], "likes": 1, "viewed": 199, "published": "Public API", "date": "1594234569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime/2.;\n    uv = uv * mat2(cos(t),-sin(t),sin(t),cos(t));\n    uv = fract(uv * .5*sin(-iTime)*4.)-.5;\n    float a = atan(uv.y,uv.x);\n    a = mod((a+3.141)/6.282,.1)*10.;\n    a -= step(.4+sin((uv.y+uv.x)*88.)*.2,length(uv));\n    uv = fract(uv * .5*cos(iTime-1.)*8.)-.5;\n    float b = mod((a+3.141)/6.282,.1)*10.;\n    b -= step(.4+sin((uv.y+uv.x)*88.)*.2,length(uv));\n    vec3 col = vec3(a*2.,0.,5.);\n    col = mix(col,vec3(0.,b*2.,.3),.5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 613]], "test": "valid"}
{"id": "Wt2yzd", "name": "apollonian----v1--6", "author": "jorge2017a1", "description": "apollonian----v1--6", "tags": ["apollonianv16"], "likes": 5, "viewed": 88, "published": "Public", "date": "1595120826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013---y modificado por jorge2017a1\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\n\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t\n        \n        \n        p = -1.0 + 2.0*fract(0.5*p+0.5);\n        \n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n        \n        \n\t\t//float k = s/r2;\n        float k = 1.75/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n        \n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.0 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yzd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[380, 380, 410, 410, 765], [767, 767, 815, 815, 1068], [1070, 1070, 1126, 1126, 1377], [1379, 1379, 1433, 1447, 2432], [3496, 3496, 3590, 3590, 3817]], "test": "valid"}
{"id": "Wt2yzG", "name": "Best Friend Cube", "author": "blackle", "description": "some new shitty way to fake reflections in this extremely specific circumstance", "tags": ["bep"], "likes": 24, "viewed": 373, "published": "Public API", "date": "1594695385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat GaborNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<5.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        //random rotation in 3d. the +.1 is to fix the rare case that g == vec3(0)\n        //https://suricrasia.online/demoscene/functions/#rndrot\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat box(vec2 p, vec2 d, float es) {\n    vec2 q = abs(p)-d;\n    vec2 qq = max(q,0.);\n    return mix(super(qq),length(qq),es) +min(0.,max(q.x,q.y));\n}\n\nvec3 distorted_p;\nfloat plate;\nfloat bx;\nfloat bump;\nfloat scene(vec3 p) {\n    float plateangle = atan(p.x,p.y);\n    \n    //different noise for each dimension\n    vec3 distort = vec3(0);\n    distort.x += GaborNoise(p/2., iTime*3., 1.15)*.3;\n    distort.y += GaborNoise(p/2.+10., iTime*3., 1.15)*.3;\n    distort.z += GaborNoise(p/2.+20., iTime*3., 1.15)*.3;\n\n    float es = smoothstep(0.,.3,GaborNoise(p*2., 0., 1.15));\n    plate = box(vec2(p.z+1.6,length(p.xy)), vec2(0.1,2.5+sin(plateangle*23.)*.004 -abs(es)*.001 ), es*.8+.2 )-.07;\n    plate = min(plate, box(vec2(p.z+6.6,length(p.xy)),vec2(5.,.8-abs(es)*.001),0. ));\n\n    p += distort;\n\n    distorted_p = p;\n    vec3 ap = abs(p);\n    bump = min(ap.x,min(ap.y,ap.z));\n    bump = smoothstep(0.,.1,bump);\n    bx = box(p,vec3(1))-.3-bump*.05;\n    return min(bx,plate);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat bayer(vec2 fragCoord) {\n    return texelFetch(iChannel0, ivec2(fragCoord) % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-10.,0,-0.5);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 250 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam*.8;\n        if (distance(p,init)>50.) break;\n    }\n    bool pl = dist == plate;\n    float lbx = bx;\n    float lb = bump;\n    vec3 local_coords = distorted_p;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.05,.05,scene(p+vec3(.05)/sqrt(3.)));\n    float rao = smoothstep(-.2,.1,scene(p+r*.1)) * smoothstep(-.4,.1,scene(p+n*.1));\n    float tex = GaborNoise(local_coords*3., 0., 1.5)+.5;\n    float diff = mix(length(asin(sin(n*2.)*.9)*0.5+0.5)/sqrt(3.),ss,.2)+.1;\n    float spec1 = length(asin(sin(r*4.)*.9)*0.5+0.5)/sqrt(3.);\n    float spec2 = length(asin(sin(r*3.)*.9)*0.5+0.5)/sqrt(3.);\n    float specpow = mix(2.,5.,tex);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n\n    vec3 col1 = vec3(0.7,0.3,0.4)*diff + pow(spec2,specpow)*frens*.5;\n    vec3 col2 = vec3(0.7)*(ss*.8+.2) + pow(spec1*1.1,40.)*frens + spec1*frens*.3;\n\n    float bgdot = length(asin(sin(cam*3.5)*.8)*0.4+0.6)/sqrt(3.);\n    vec3 bg = vec3(.2,.2,.3) * bgdot*bgdot + pow(bgdot, 10.)*2.;\n    \n    float tex2 = smoothstep(0.1,.8,GaborNoise(p*4., 0., 1.2));\n    vec3 bounce = p+r*lbx*(2.-tex2);\n    float rao2 = smoothstep(-lbx,lbx,scene(bounce));\n    vec3 bouncecol = mix(vec3(.7,.3,0.4), vec3(.8), smoothstep(-.8,.8,bounce.x*bounce.y*bounce.z));\n    vec3 pedistal = vec3(.1)*spec1 + pow(spec1, 10.-tex2*2.);\n    if (n.z>.99) pedistal = mix(bouncecol*frens*.4, pedistal, rao2);\n    \n    vec3 col = mix(col1,col2,smoothstep(-.05,.05,local_coords.x*local_coords.y*local_coords.z));\n    col *= lb*.3+.7;\n    if (pl) col = pedistal;\n    fragColor.xyz = hit ? rao*col : bg;\n    fragColor *= 1.- dot(uv,uv)*.6;\n    fragColor = sqrt(smoothstep(-.01, 1.1, fragColor));\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yzG.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 340, 385, 1045], [1047, 1047, 1068, 1068, 1100], [1102, 1102, 1123, 1123, 1155], [1157, 1157, 1184, 1184, 1268], [1270, 1270, 1307, 1307, 1420], [1475, 1475, 1496, 1496, 2241], [2243, 2243, 2262, 2262, 2378], [2380, 2380, 2409, 2409, 2472], [2474, 2474, 2531, 2531, 4877]], "test": "error"}
{"id": "wtBcDc", "name": "Waves v.1", "author": "pli", "description": "First shader test, very basic 2d stuff.", "tags": ["learning"], "likes": 1, "viewed": 90, "published": "Public API", "date": "1595601654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADOW 0.03\n\n\nfloat covered(vec2 uv, float speed, float height, float vOffset) {\n    float distance = height * cos(speed * iTime + uv.y * 2.0 + uv.x * 300.0 * height)\n        \t+ 0.3 * height * cos(speed * iTime + uv.x * 100.0 * height)\n        \t+ vOffset - uv.y;\n    \n    float covered;\n    if (distance < 0.0) {\n        covered = 1.0;\n    } else if (distance < SHADOW) {\n        covered = 1.0 - distance / SHADOW;\n    } else {\n        covered = 0.0;\n    }\n    return covered;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 result;\n    float c = covered(uv, 1.5, 0.02, 0.2);\n    if (c > 0.0) {\n        result = vec4(0.0, 0.18, 0.2 ,1.0) * sqrt(c);\n    } else {\n        c = covered(uv, 2.5, 0.04, 0.0);\n        if (c > 0.0) {\n        \tresult = vec4(0.14, 0.37, 0.4 ,1.0) * sqrt(c);\n        } else {\n            c = covered(uv, 4.0, 0.05, -0.25);\n            if (c > 0.0) {\n                result = vec4(0.25, 0.47, 0.51 ,1.0) * sqrt(c);\n            } else {\n                result = vec4(0.41, 0.58, 0.61 ,1.0);\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 88, 88, 486], [488, 488, 545, 595, 1266]], "test": "valid"}
{"id": "wtBcDm", "name": "perlin noodleys expanded", "author": "surgery_waves", "description": "alsdf", "tags": ["idklol"], "likes": 0, "viewed": 83, "published": "Public", "date": "1594521893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float twopi = radians(360.);\n\nfloat random (in vec2 st, vec2 coeff, float scaler) {\n    return fract(sin(dot(st.xy, coeff) * scaler));\n    }\n                 \nfloat noise (in vec2 st, vec2 coeff, float scaler) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i, coeff, scaler);\n    float b = random(i + vec2(1.0, 0.0), coeff, scaler);\n    float c = random(i + vec2(0.0, 1.0), coeff, scaler);\n    float d = random(i + vec2(1.0, 1.0), coeff, scaler);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n                 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvhalf = uv.xy / 2. * 0.5;\n    \n    float centerDist = distance(uv.xy, uvhalf);\n    \n    float bill = cos(fract(0.142 * iTime)*twopi);\n    float gaffigan = sin(fract(iTime * 0.0014) * twopi + centerDist);\n            \n    float pos = noise(uv.xy + 0.3 * 0.4 + 1.3 * sin(dot(1.-uv.yx, vec2(centerDist)) * centerDist + fract(iTime * 0.075161) * radians(360.)), \n                      vec2(431.51,3330.311),\n                      23.21 + centerDist);\n  \n    // Time varying pixel color\n    vec3 col = iTime * pos / centerDist * vec3(uv.xy + pos*0.3 + 5., sin(centerDist * 4. * radians(360.)) + bill * 0.2) + vec3(0.10,0.3,0);\n\n    // Output to screen\n    fragColor = vec4(1. / col * vec3(0.33 * gaffigan * bill + 0.251,\n                                0.144 + centerDist * bill,\n                                pow(gaffigan, 0.5) / centerDist),\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 83, 83, 140], [159, 159, 211, 211, 788], [809, 809, 866, 916, 1841]], "test": "valid"}
{"id": "wtBcDV", "name": "001 - Hello World", "author": "Mr_Admirals", "description": "First shader using RayMarching", "tags": ["firstshader"], "likes": 0, "viewed": 57, "published": "Public", "date": "1595429700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p)\n{\n    // Define Sphere\n    // XYZ = Position\n    // W = Radius\n    vec4 sphere = vec4(0, 1 , 6, 1);\n    \n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    \n    // Plane is at Y = 0\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + rd * dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        \tGetDist(p - e.xyy),\n        \tGetDist(p - e.yxy),\n        \tGetDist(p - e.yyx)\n        );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n\tvec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime) * 2.0);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float d = RayMarch(p + n * SURF_DIST * 2.0, l);\n    float distToLight = distance(p, lightPos);\n    \n    if(d < distToLight) return 0.0;\n    \n    return clamp(dot(n, l), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float diffuse = GetLight(p);\n    \n   \td /= 6.0;\n    vec3 col = vec3(diffuse);\n    \n    fragColor =  vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 92, 153, 378], [380, 380, 414, 414, 634], [636, 636, 660, 660, 870], [872, 872, 896, 896, 1239], [1241, 1241, 1298, 1348, 1679]], "test": "valid"}
{"id": "WtBcRd", "name": "1/2 oct. steps", "author": "yonatan", "description": "idk, another iteration on https://www.shadertoy.com/view/3tSczK\n\nmouse x sets speed.", "tags": ["fractal"], "likes": 5, "viewed": 269, "published": "Public API", "date": "1595032354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R2 1.41421356237\n#define r (iResolution.xy)\n#define t (iTime*(1.-iMouse.x/r.x))\n#define M(q)q*=mat2(sin(t*.1-t/s+vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n\tfloat s,g,e,i;\n    for(i=g=0.;i++<20.;){\n        e=s=2.;\n        vec4 p=vec4(g*(FC.xy*e-r)/r.y,g-1.7,1);\n        for(int i;i++<24;s*=R2)\n            M(p.xy),\n            M(p.yz),\n            p=abs(p)*R2-R2+1.;\n        g+=e=length(p)/s;\n        o+=(1e-5-p/s*.05)/e;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 182, 182, 471]], "test": "valid"}
{"id": "WtBcRG", "name": "Quadrupole Contour Plot", "author": "Mr_Mayhem", "description": "An animated contour plot with sharper lines than earlier posts. Use mouse or tap touchscreen.", "tags": ["distancefields", "contours", "noloop", "fields", "topo", "quadrupole"], "likes": 3, "viewed": 82, "published": "Public", "date": "1594604303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Mr_Mayhem July 2020\n// An animated contour plot with sharper lines than earlier posts. \n// Use mouse or tap touchscreen.\n\n// Heavily modified from https://www.shadertoy.com/view/lltBWM by 8x\n// Thanks to FabriceNeyret2 for many improvements.\n\n#define addPole(u,v)  sum +=  h / (1. + length(fragCoord - R*vec2(u, v)));\n#define addZero(u,v)  sum += -h / (1. + length(fragCoord - R*vec2(u, v)));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  R = iResolution.xy;\n    float h = 1000.; // try increasing this, heh.\n    float sum = 0.0;\n    \n    // create some poles and zeros\n    // (positive and negative values of 'sum' with respect to xy location)\n    // (like peaks and valleys in terrain)\n    // 4 zeros in a square make a Quadrupole\n    addZero(0.3, 0.3); \n    addZero(0.3, 0.7);    \n    addZero(0.7, 0.3);\n    addZero(0.7, 0.7);        \n            \n    sum *=  0.5; // reduce the value by half\n    \n    // pole at mouse, but we skipped 'sum *=  0.5;' part above\n    // meaning it's twice as 'strong' as the previous 4.\n    addPole(iMouse.x/R.x, iMouse.y/R.y);\n    \n    // animate\n    sum *= sin(iTime/2.); \n    \n    // Thanks to FabriceNeyret for helping me sort this out\n    // with better smoothstep.\n    float br = fract(sum);\n    if(mod(sum, 2.) > 1.) br = 1. -br; // can we replace if statement?\n    br = sign(sum) * smoothstep(1.5, .0, br / fwidth(sum) );\n    fragColor =  vec4(-br, br, 0, 1) ; // replaces if br > 0. statement\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 457, 457, 1463]], "test": "valid"}
{"id": "wtBcWd", "name": "Waves v.4", "author": "pli", "description": "Same boat, now in 3d. Only realized how slow it was when I tried it on my old computer :)\nV.5 is much faster: https://www.shadertoy.com/view/wt2yDt", "tags": ["learning"], "likes": 0, "viewed": 96, "published": "Public API", "date": "1595702882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define EYE_COLOR vec3(0., 0.0, 0.0)\n\n#define BOAT_INITIAL_X 0.1\n#define BOAT_INITIAL_Z 0.3\n\n\n#define X_WAVES 10.\n#define Z_WAVES 10.\n#define X_WAVE_SPACE 0.15\n#define Z_WAVE_SPACE 0.1\n\n#define WAVE_SMOOTH 0.13\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\t\treturn sqrt( (p.x-center.x) * (p.x-center.x) + (p.y-center.y) * (p.y-center.y) + (p.z-center.z) * (p.z-center.z)) - radius;   \n}\n\nfloat distPoints(vec2 p1, vec2 p2) {\n\treturn sqrt( (p1.x-p2.x) * (p1.x-p2.x) + (p1.y-p2.y) * (p1.y-p2.y));   \n}\n\n\nfloat heightAt(float xd, float z) {\n    return -0.1 + 0.01 * cos(13.*xd + 2.*z);\n}\n\nfloat boatHeight(vec3 pos, float delta) {\n    return -0.1 - 0.01 * cos(6. * pos.x + delta * 2. * 3.14159) + 0.1;\n}\n\nfloat sphereSize(float x, float z) {\n    return 0.1 + 0.02 * cos(4.*x - z);\n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n\tvec3 coords;\n    coords.x = -X_WAVE_SPACE * X_WAVES / 2. + grid.x * X_WAVE_SPACE;\n    coords.y = grid.y;\n    coords.z = grid.z * Z_WAVE_SPACE;\n    return coords;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n\tvec3 grid;\n    grid.x = (coords.x + X_WAVE_SPACE * X_WAVES / 2.) / X_WAVE_SPACE;\n    grid.y = coords.y;\n    grid.z = coords.z / Z_WAVE_SPACE;\n    return grid;\n}\n\nfloat waveSizeAt(vec3 coords) {\n    return 0.10 + 0.03 * cos(coords.x + 2. * sin(0.5*coords.z) + 4.*iTime);   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.04 + waveSizeAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    float dist = 1.;\n    for (float x = 0. ; x < X_WAVES ; x+=1.) {\n        for (float z = 0. ; z < Z_WAVES ; z+=1.) {\n\n            vec3 coords = coordsFromGrid(vec3(x, 0., z));            \n            \n            float size = waveSizeAt(vec3(x, 0., z));\n\t\t\tfloat distSphere = distSphere(pos, coords, size);\n   \t\t \tdist = smoothmin(dist, distSphere, WAVE_SMOOTH); // 0.08\n        }\n    }\n    \n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\n    float initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\n\n    // boat\n    vec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .5;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    vec3 ink = vec3(0.15, 0.2, 0.3);\n    \n    //camera\n    vec3 eye = vec3(0., 1.,6.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.12) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.23, 0.25);\n    if (distPoints(moonPosition, uv) < 0.2) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totDist = 0.;\n    float maxDist = 7.;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n\n    col = colorVariation * (0.75 + dot(normal, light));\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.3);\n\tcol = mix(col, vec3(1.), (shineVariation -  0.5 * colorVariation) * spec);\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[586, 586, 604, 604, 653], [656, 656, 699, 699, 807], [810, 810, 863, 863, 994], [996, 996, 1032, 1032, 1107], [1110, 1110, 1145, 1145, 1192], [1194, 1194, 1235, 1235, 1308], [1310, 1310, 1346, 1346, 1387], [1390, 1390, 1422, 1422, 1587], [1589, 1589, 1623, 1623, 1785], [1787, 1787, 1818, 1818, 1899], [1902, 1902, 1930, 1930, 1973], [1976, 1976, 2053, 2108, 5376], [5378, 5378, 5401, 5401, 5739], [5742, 5742, 5763, 5763, 7184], [7186, 7186, 7243, 7243, 7371]], "test": "valid"}
{"id": "wtBcWK", "name": "v3Hex.glsl", "author": "jorge2017a1", "description": "v3Hex.glsl", "tags": ["v3hexglsl"], "likes": 4, "viewed": 65, "published": "Public", "date": "1595449921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy - iResolution.xy * 0.5;\n\n    float phi = atan(coord.y, coord.x + 1e-6);\n    phi = phi / PI * 0.5 + 0.5;\n    float seg = floor(phi * 6.0);\n\n    float theta = (seg + 0.5) / 6.0 * PI * 2.0;\n    vec2 dir = vec2(cos(theta), sin(theta));\n    float l = dot(dir, coord);\n\n    float phase = iTime * 0.8;\n    float w1 = sin(floor(phase    ) + seg) * 40.0 + 60.0;\n    float w2 = sin(floor(phase + 1.0) + seg) * 40.0 + 60.0;\n    float w = mix(w1, w2, smoothstep(0.75, 1.0, fract(phase)));\n\n    float prog = l / w + iTime * 2.0;\n    float thresh = fract(73.8493748 * abs(sin(floor(prog) * 4.67458347)));\n    float c = clamp((fract(prog) - thresh) * w * 0.3, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 808]], "test": "valid"}
{"id": "wtBcWt", "name": "NoiseHashTest", "author": "Mario8664", "description": "Test the hash function of noise.", "tags": ["2d", "noise"], "likes": 1, "viewed": 49, "published": "Public", "date": "1595678122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float x)\n{\n    x = 123.0 * fract(x * 67.0 + 0.1276795);\n    return fract(x*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float factor = 0.002;\n    float scrollSpeed = 0.08;\n    float yOffset = 0.5;\n    float yScale = 0.5;\n    float xScale = 1.0;\n    float xPrecision = 500.0;\n    float fps = 60.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float inputTime = floor(iTime * fps) / fps * scrollSpeed;\n    // Time varying pixel color\n    float noise = hash( floor((uv.x * xScale + inputTime) * xPrecision) / xPrecision);\n    vec3 col = (abs(uv.y - yOffset * yScale - noise * yScale) <= factor) \n        && uv.x >= 0.0 ? vec3(noise, 0.2, 0.2) : vec3(0.8,1.0,uv.y);\n    \n    col = (abs(uv.y - yOffset * yScale + 0.2 * yScale) <= 0.005) && uv.x >= 0.0 ? vec3(noise, noise, noise) : col; \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [93, 93, 150, 150, 939]], "test": "valid"}
{"id": "wtByDK", "name": "v3TriLattice8.glsl", "author": "jorge2017a1", "description": "///source code of ShaderSketches", "tags": ["v3trilattice8glsl"], "likes": 3, "viewed": 77, "published": "Public", "date": "1595382786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float offs = step(fract(1.0 - uv.y), fract(sx));\n    return vec2(floor(sx) * 2.0 + offs, floor(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res = iResolution.y / (5.0 + sin(iTime * 0.5));\n\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / res;\n\n    vec3 p = vec3(dot(uv, vec2(1.0, 0.5)), dot(uv, vec2(-1.0, 0.5)), uv.y);\n    vec3 p1 = fract(+p);\n    vec3 p2 = fract(-p);\n\n    // distance from borders\n    float d1 = min(min(p1.x, p1.y), p1.z);\n    float d2 = min(min(p2.x, p2.y), p2.z);\n    float d = min(d1, d2);\n\n    // border line\n    float c = clamp((d - 0.04) * res, 0.0, 1.0);\n\n    // gradient inside triangles\n    float r = rand(uv2tri(uv));\n    c *= abs(0.5 - fract(d + r + iTime * 0.8)) * 2.0;\n\n    // color variation\n    float cb = sin(iTime * 4.8 + r * 32.984) * 0.5 + 0.5;\n    vec3 rgb = mix(vec3(0.75, 0.0, 0.0), vec3(1, 0.5, 0.5), cb);\n\n    fragColor = vec4(rgb * c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 92], [94, 94, 116, 116, 271], [273, 273, 330, 330, 1093]], "test": "valid"}
{"id": "wtByDw", "name": "Industrial machinery", "author": "jarble", "description": "This fractal appears to be a large industrial complex.\nClick and drag the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 3, "viewed": 199, "published": "Public API", "date": "1594496801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 3.0\n#define iterations 4\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1,float i){\n    p += sin(p.yzx+iTime*i*9.0)/(i*27.0); //animation\n    return size-length(sin(p/vec3(length(p/20.0)))*size1)/1.8;\n}\n\nfloat vines(vec3 p,float size1){\n\treturn vines(p,size1,1.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float i = multiplier;\n\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p*i)/i;\n        result = min(result,vines(p,size1,i)/(i));\n        i *= multiplier;\n    }\n    return (result)*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p *= sin(p);\n    float v = vines(p,1.0);\n    return sin(vec3(v*6.0,v*4.0,v*3.0))/5.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.0+.001*(1.0+depth);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    vec3 eye = vec3(50.0,1.6,iTime/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[631, 631, 671, 671, 790], [792, 792, 824, 824, 854], [856, 856, 880, 880, 1183], [1185, 1185, 1213, 1232, 1316], [1318, 1739, 1830, 1830, 2206], [2221, 2475, 2540, 2540, 2672], [2674, 2763, 2792, 2792, 3107], [3109, 3601, 3741, 3741, 4351], [4353, 4723, 4808, 4808, 5155], [5157, 5484, 5533, 5568, 5699], [5701, 5701, 5758, 5758, 6835]], "test": "valid"}
{"id": "wtByWK", "name": "v0Dots3.glsl", "author": "jorge2017a1", "description": "v0Dots3.glsl", "tags": ["v0dots3glsl"], "likes": 5, "viewed": 73, "published": "Public", "date": "1595449881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat swirl(vec2 coord)\n{\n    float l = length(coord) / iResolution.x;\n    float phi = atan(coord.y, coord.x + 1e-6);\n    return sin(l * 21.0 + phi * 5.0 - iTime * 4.0) * 0.5 + 0.5;\n}\n\nfloat halftone(vec2 coord, float size, vec2 offs)\n{\n    vec2 uv = coord / size;\n    vec2 ip = floor(uv) + offs; // column, row\n    vec2 odd = vec2(0.5 * mod(ip.y, 2.0), 0.0); // odd line offset\n    vec2 cp = floor(uv - odd + offs) + odd; // dot center\n    float d = length(uv - cp - 0.5) * size; // distance\n    float r = swirl(cp * size) * size * 0.6; // dot radius\n    return max(0.0, d - r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy - iResolution.xy * 0.5;\n    float size = iResolution.x / (30.0 + sin(iTime * 0.5) * 20.0);\n    float k = size / 4.0;\n\n    float d =   halftone(coord, size, vec2(-0.5, -1));\n    d = smin(d, halftone(coord, size, vec2( 0.5, -1)), k);\n    d = smin(d, halftone(coord, size, vec2(-1.0,  0)), k);\n    d = smin(d, halftone(coord, size, vec2( 0.0,  0)), k);\n    d = smin(d, halftone(coord, size, vec2( 1.0,  0)), k);\n    d = smin(d, halftone(coord, size, vec2(-0.5,  1)), k);\n    d = smin(d, halftone(coord, size, vec2( 0.5,  1)), k);\n\n    fragColor = vec4(d, d, d, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 41, 41, 144], [146, 146, 171, 171, 329], [331, 331, 382, 382, 727], [729, 729, 786, 786, 1380]], "test": "valid"}
{"id": "WtByWt", "name": "Rotating normal small objects", "author": "akanarika", "description": "Small objects showing normal color", "tags": ["raymarching", "normal"], "likes": 1, "viewed": 64, "published": "Public", "date": "1595651080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 getBall(vec3 p) {\n    vec3 c = vec3(5, 0, 0);\n    return vec2(length(p - c) - 1., 1.);\n}\n\nvec2 getBox(vec3 p) {\n    vec3 size = vec3(1, 1, 2);\n    vec3 c = vec3(-5, 0, 0);\n    return vec2(length(max(abs(p - c) - size, 0.)), 2.);\n}\n\nvec2 getTorus(vec3 p) {\n\tvec3 c = vec3(0, 0, 5);\n    float r1 = 1.5;\n    float r2 = 1.;\n    vec3 pxz = vec3(p.x, 0, p.z);\n    vec3 pxzc = c - pxz;\n    float lpxzc = length(pxzc);\n    vec3 q = pxz + pxzc * (lpxzc - r1) / lpxzc;\n    return vec2(length(q - p) - r2, 3.);\n}\n\nvec2 getCapsule(vec3 p) {\n\tvec3 a = vec3(1, 2, -2);\n    vec3 b = vec3(-1, 0, -5);\n    float r = 1.;\n    vec3 ba = a - b;\n    vec3 pa = a - p;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return vec2(length(pa - t * ba) - r, 4.);\n}\n\nvec2 getPlane(vec3 p) {\n    return vec2(p.y + 1., 5.);\n}\n\nvec2 getDist(vec3 p) {\n    float d = 1000000.;\n    float id = -1.;\n    vec2 res = getBall(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getBox(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getTorus(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getCapsule(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getPlane(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    return vec2(d, id);\n}\n\nvec3 getNorm(vec3 p) {\n\tfloat eps = 0.001;\n    return normalize(vec3(getDist(vec3(p.x + eps, p.y, p.z)).x - getDist(vec3(p.x - eps, p.y, p.z)).x,\n                          getDist(vec3(p.x, p.y + eps, p.z)).x - getDist(vec3(p.x, p.y - eps, p.z)).x,\n                          getDist(vec3(p.x, p.y, p.z + eps)).x - getDist(vec3(p.x, p.y, p.z - eps)).x));\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n\tfloat t = 0.;\n    float id = -1.;\n    for (int i = 0; i < 100; i++) {\n    \tvec3 p = ro + t * rd;\n        float h = getDist(p).x;\n        id = getDist(p).y;\n        t += h;\n        if (t > 300. || h < 0.001) break; \n    }\n    if (t > 300.) {\n        t = -1.;\n        id = -1.;\n    }\n    return vec2(t, id);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nmat3 v(vec3 ri, vec3 up, vec3 forw) {\n    return transpose(mat3(ri, up, forw));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0, 10, 30);\n    vec3 target = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv.x , uv.y + .1, -1));\n    \n    if (iMouse.z > 0.) ro.xz *= rot(iMouse.x * 10. / iResolution.x);\n    else ro.xz *= rot(iTime * .5);\n    \n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 forw = normalize(ro - target);\n    vec3 ri = normalize(cross(up, forw));\n    rd *= v(ri, up, forw);\n\n    vec2 rm = rayMarch(ro, rd);\n    vec3 p = ro + rm.x * rd;\n    \n    vec3 col = rm.x > 0. ? vec3(getNorm(p)) : vec3(.4, .7, .8);\n    if (rm.y > 4.5) {\n    \tcol = vec3(.8, .8, .3);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 94], [96, 96, 117, 117, 236], [238, 238, 261, 261, 507], [509, 509, 534, 534, 754], [756, 756, 779, 779, 812], [814, 814, 836, 836, 1355], [1357, 1357, 1379, 1379, 1712], [1714, 1714, 1753, 1753, 2062], [2064, 2064, 2083, 2083, 2135], [2137, 2137, 2174, 2174, 2218], [2220, 2220, 2277, 2277, 2970]], "test": "valid"}
{"id": "wtByz1", "name": "golden ratio sphere", "author": "madware", "description": "spherical variant of a shader https://www.shadertoy.com/view/ttSyz1", "tags": ["goldenratio"], "likes": 8, "viewed": 162, "published": "Public", "date": "1593704315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SAMPLES 256.0\n#define USE_GOLDEN_RATIO\n\nfloat circle(in vec2 uv, in vec2 p, in float rad)\n{\n    vec2 puv = uv - p;\n    float rsquare = rad*rad;\n    return smoothstep(rsquare + 0.000005, rsquare - 0.000005, dot(puv, puv));\n}\n\nmat3 rotateAroundY(float a)\n{\n    float cs = cos(a);\n    float sn = sin(a);\n    return\n        mat3( cs, 0.0, -sn,\n              sn, 0.0,  cs,\n             0.0, 1.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = radians(180.0);\n    float aspect = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= aspect;\n\n    vec3 col = vec3(.5, .5, .5);\n    \n    mat3 rot = rotateAroundY(iTime / 3.0);\n    \n    for(float i = 0.0; i < NUM_SAMPLES; i += 1.0) {\n        float phi = acos(1.0 - 2.0 * (i + 0.5) / NUM_SAMPLES);\n        #ifdef USE_GOLDEN_RATIO\n            float theta = pi * (1.0 + sqrt(5.0)) * i;\n        #else\n            float theta = pi / 0.931 * i; // some interesting random ratio\n        #endif\n        float sphi = sin(phi);\n        vec3 p = vec3(\n            sphi * cos(theta), \n            sphi * sin(theta),\n            cos(phi)\n        );\n        p = rot * p;\n        p *= aspect / 2.0;\n        vec3 clr = vec3(1.0, 1.0, 1.0) * (1.0 - (p.z + 0.5) * 0.5);\n        p += vec3(0.5, 0.5 * aspect, 0.5);\n        float plot = circle(uv, p.xy, 0.0025);\n        col = mix(col, clr, plot * 0.75);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 103, 103, 235], [237, 237, 266, 266, 410], [412, 412, 469, 469, 1443]], "test": "valid"}
{"id": "wtByzV", "name": "Diamond, Circle, Square Normals", "author": "jt", "description": "Like [url]https://www.shadertoy.com/view/wtSyzV[/url] but with explicitly computed normal vectors.", "tags": ["normals", "circle", "square", "diamond", "norm", "pnorm"], "likes": 2, "viewed": 81, "published": "Public", "date": "1594821785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2020 by jt\n// A unit-circle of norm 1/q with normal vectors.\n// Interpolating q from 1 to 0 results in a smooth transition from diamond (q=1) via circle (q=0.5) to square (q=0).\n// Instead of taking the limit for q=0 to avoid division by zero for visualization purpose some small q is sufficient.\n\n// (If square flickers reduce epsilon)\n#define EPS 1e-7\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    vec2 R = iResolution.xy;\n    I = (2. * I - R) / R.y;\n\n    //float q = .5 + .5 * cos(iTime); // exact but division-by-zero occurs \n    float q = .5 + (.5 - EPS) * cos(iTime); // inexact but avoids division-by-zero\n    //o = vec4(dot(pow(abs(I), vec2(1./q)), vec2(1)) < pow(1., 1./q));\n    float p = 1./q;\n    float m = max(abs(I.x), abs(I.y));\n    //float d = pow(dot(pow(abs(I), vec2(p)), vec2(1)), q); // numerically unstable for large exponents\n    float d = m * pow(dot(pow(abs(I / m), vec2(p)), vec2(1)), q); // numerically stable for large exponents (maximal component normalized to 1)\n    //o = vec4(d < 1.); // easy but shows aliasing artifacts\n    o = vec4(smoothstep(1., .99, d)); // antialiased\n    //vec2 n = normalize(p * I * pow(abs(I), vec2(p - 2.))); // numerically unstable for large exponents\n    vec2 n = normalize(p * I * pow(abs(I / m), vec2(p - 2.))); // numerically stable for large exponents (maximal component normalized to 1)\n    o.xy *= 0.5 + 0.5 * n;\n    o.z = 0.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 399, 399, 1397]], "test": "valid"}
{"id": "WtfBR4", "name": "eindacor_flowers", "author": "Eindacor_DS", "description": "it's flowers, you dolt!", "tags": ["flowers"], "likes": 2, "viewed": 22, "published": "Public", "date": "1596068812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA .002f\n#define PI 3.141592653f\n#define TWOPI 6.28318530718f\n#define skyColor vec3(.5f, .75f, 1.f)\n#define earthColor vec3(0.4f, .4f, 0.2f)\n#define sunColor vec3(1.f, 1.f, 0.f)\n#define stemColor vec3(0.f, 0.7f, 0.f)\n#define flowerColor vec3(1.f, 0.f, 0.f)\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat circleSmoothStep(vec2 center, float radius, float thickness, vec2 p, float antiAlias) {\n    float distFromCenter = distance(center, p);\n    float halfThickness = thickness / 2.f;\n    if (distFromCenter < radius) {\n        return smoothstep(radius - halfThickness - antiAlias, radius - halfThickness + antiAlias, distFromCenter);\n    } else {\n        return 1.f - smoothstep(radius + halfThickness - antiAlias, radius + halfThickness + antiAlias, distFromCenter);\n    }\n}\n\n/*\n\treturns smoothstep value for line segment\n\texample usage:\n\t\toutColor = mix(outColor, lineColor, lineSegmentSmoothStep(start, end, uv, thickness, AA, true));\n*/\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nvec2 rotatePointAroundOtherPoint(vec2 center, vec2 p, float angleInRadians) {\n    mat2x2 rotationMatrix = mat2x2(\n    \tcos(angleInRadians), -sin(angleInRadians),\n        sin(angleInRadians), cos(angleInRadians)\n    );\n    \n    return (rotationMatrix * (p - center)) + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n      \n    float earthElevationOnScreen = 0.5f;\n    float earthRadius = .25f;\n    vec2 earthCenter = vec2(0.5f * aspectRatio, earthElevationOnScreen - earthRadius);\n    earthCenter.y = .5f;\n    float actualDist = distance(earthCenter, uv);\n    \n    float dayLength = 8.f;\n    float sunTimeScale = iTime * .8f;\n    float sunPositionValue = mod(sunTimeScale, dayLength) / dayLength;\n    float sunHeight = .25f;\n    vec2 sunAzimuthPos = vec2(earthCenter.x, earthCenter.y + earthRadius + sunHeight);\n    \n    vec2 sunPosition = rotatePointAroundOtherPoint(earthCenter, sunAzimuthPos, TWOPI * sunPositionValue);\n     \n    vec3 outColor = skyColor;\n    \n    float earthValue = smoothstep(actualDist - AA, actualDist + AA, earthRadius);\n    outColor = mix(outColor, earthColor, earthValue);\n       \n    float flowerAttractionCoeff = .3f;\n    float flowerStemThickness = .005f;\n    float flowerHeight = .025f;\n    vec2 flowerStart = vec2(earthCenter.x, earthCenter.y + earthRadius);\n    int flowerCount = 50 ;\n    float flowerGrowthFactor = .3f;\n    float flowerRadius = .012f;\n    \n    for (int i=0; i<flowerCount; i++) {\n        float rotation = float(i) / float(flowerCount) * TWOPI;\n        vec2 localFlowerStart = rotatePointAroundOtherPoint(earthCenter, flowerStart, rotation);   \n        vec2 flowerTangentVec = normalize(localFlowerStart - earthCenter);\n        vec2 flowerToSunVec = normalize(sunPosition - localFlowerStart);\n        \n        float normalizedTanDotSun = (dot(flowerTangentVec, flowerToSunVec) + 1.f) / 2.f;\n        \n        float bendFactor = 1.f - smoothstep(0.5, 1.f, normalizedTanDotSun);\n        if (bendFactor < .0000f) {\n         \t// treat like a straight line   \n        } else if (i==0) {\n            float circleRadius = mix(flowerHeight / PI, 1000.f, bendFactor);\n            outColor = mix(outColor, vec3(1), circleSmoothStep(earthCenter, circleRadius, .002f, uv, AA));\n        }\n        \n        vec2 mixedVec = normalize(mix(flowerToSunVec, flowerTangentVec, pow(1.f - normalizedTanDotSun, flowerAttractionCoeff)));\n        vec2 flowerEnd = mixedVec * (flowerHeight + (pow(normalizedTanDotSun, 2.f) * flowerHeight * flowerGrowthFactor)) + localFlowerStart;\n        outColor = mix(outColor, stemColor, lineSegmentSmoothStep(localFlowerStart, flowerEnd, uv, flowerStemThickness, AA, true));\n        float flowerDist = distance(uv, flowerEnd);\n        outColor = mix(flowerColor, outColor, smoothstep(flowerRadius - AA, flowerRadius + AA, flowerDist));\n    }\n    \n       \n    float sunRadius = .05f;\n    float sunDistance = distance(sunPosition, uv);\n    float sunValue = smoothstep(sunDistance - AA, sunDistance + AA, sunRadius);\n    outColor = mix(outColor, sunColor, sunValue);\n    \n    fragColor = vec4(outColor, 1.f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 346, 346, 435], [437, 437, 530, 530, 913], [915, 1079, 1192, 1192, 1826], [1828, 1828, 1905, 1905, 2105], [2107, 2107, 2164, 2214, 5087]], "test": "valid"}
{"id": "WtfBRr", "name": "Hyper Menger Tunnel", "author": "kstyler", "description": "Flying through a changing Menger sponge.", "tags": ["tunnel", "raymarch", "menger", "sponge"], "likes": 6, "viewed": 287, "published": "Public API", "date": "1595794368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cros(vec3 p){\n    return min(box(p.xyy,vec3(1,1,9999)),min(box(p.xxz,vec3(1,9999,1)),box(p.yyz,vec3(9999,1,1))));\n}\n\nfloat sponge(vec3 p, float size){\n    float res = box(p,vec3(size));\n    float c = 2.*size;\n    float crSiz =3.; \n    \n    \n    for(int i = 0; i < 4; i++){\n    \tvec3 q = mod(p+0.5*c,c)-0.5*c;\n        q.z*=sin(iTime/2.)+1.5;\n        float subt = cros(q*(crSiz/size))/(crSiz/size);  \n        res=max(-subt,res);\n        c/=3.;\n        crSiz*=3.;\n    }\n    return res;\n}\nfloat map(vec3 p){\n    float c = 5.4;\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sponge(q,4.);\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,0.01);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n}\n\nvec3 skyColor(vec3 rd){\n    vec3 outLight = vec3(0.125);\n    outLight+=addLight(10.*vec3(0.7,0.2,0.3)*sin(iTime/4.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    outLight+=addLight(10.*vec3(0.1,0.3,0.7)*sin(iTime/4.),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,0.,-11.);\n    ro.z+=iTime*8.;\n    vec3 rd = normalize(vec3(uv,1));\n    rd.z*=sin(iTime/6.);\n    rd.xy*=rot(iTime/8.);\n    vec3 color = vec3(0);\n    vec3 accum = vec3(0);\n    float tot = 0.;\n    for(int i = 0; i<80;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n        vec3 n = normal(p);\n        if(dst>0.01){\n        \tcolor = skyColor(rd)/2.;\n        }\n        else{    \n        \tcolor  = vec3(tot/1000.);    \n        }\n        accum+=color*0.04;\n    }\n    fragColor = vec4(1.-(accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 98, 98, 191], [193, 193, 212, 212, 314], [316, 316, 349, 349, 683], [684, 684, 702, 702, 783], [785, 785, 805, 805, 976], [978, 978, 1030, 1030, 1198], [1200, 1200, 1223, 1223, 1471], [1473, 1473, 1529, 1529, 2142]], "test": "valid"}
{"id": "WtfBzN", "name": "2D plotting", "author": "nikat", "description": "Demonstrates different approaches to plotting.\n\nPurple — compare |f(x)-y| to epsilon.\nBlue —  same, but correct epsilon by derivative value.\nRed —  sampling without epsilon-comparison.\n\nInspired by https://www.shadertoy.com/view/4scSz4\n", "tags": ["2d", "function", "plot"], "likes": 4, "viewed": 83, "published": "Public", "date": "1596095572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Created by Nikita Miropolskiy, nikat/2020\n\n\tinspired by this shader https://www.shadertoy.com/view/4scSz4\n\n */\n\nvec3 colBackground1 = vec3( 0.92, 0.96, 0.9);\nvec3 colBackground2 = vec3( 0.87, 0.93, 0.83);\nvec3 colAxes        = vec3( 0.1,  0.1,  0.1);\nvec3 colNaive       = vec3( 0.5,  0.0,  0.5);\nvec3 colDerivative  = vec3( 0.1,  0.0,  0.7);\nvec3 colSampling    = vec3( 0.7,  0.0,  0.0);\n\n// This is a function that we want to plot.\nfloat f(float x) {\n    //return sin(x);\n    return sin(10.0*sin(iTime*0.33) + 3.0*x*sin(x));\n}\n\n// This is the algebraic derivative of f function\n// for example go to www.wolframalpha.com and search \"sin(c + 3.0*x*sin(x))'\"\n//float df(float x) {\n//    return 3.0*(sin(x) + x*cos(x))*cos(10.0*sin(iTime*0.33) + 3.0*x*sin(x));\n//}\n\nvec2 frag2point(in vec2 frag) {\n    return 4.0*(frag - 0.5*iResolution.xy)/iResolution.yy;\n}\n\nfloat samples2stroke(float ratio) {\n    return 1.0 - smoothstep(0.0, 0.5, ratio)*smoothstep(1.0, 0.5, ratio);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // draw grid\n\tvec2 p = frag2point(fragCoord);\n    vec3 col = mix(colBackground1, colBackground2, mod(floor(p.x)+floor(p.y), 2.0));\n    \n    // naive comparison\n    float epsilon = 0.01;\n    float plotNaive = smoothstep(0.0, 2.0*epsilon, abs(p.y - f(p.x)));\n    \n    // algebraic derivative calculation\n    // float dy = df(p.x);\n    \n    // numeric derivative calculation\n    float dy = (f(p.x+epsilon*0.5)-f(p.x-epsilon*0.5))/epsilon;\n    \n    // comparsion with derivative correction\n    float plotDerivative = smoothstep(0.0, 2.0*epsilon*sqrt(1.0+dy*dy), abs(p.y - f(p.x)));\n    \n    // sampling\n    float pixSample = 0.5;\n    float pixWidth = 1.0;\n    float plot = 0.0, axes = 0.0;\n    float total = 0.0;\n    for (float sx = fragCoord.x-pixWidth; sx <= fragCoord.x+pixWidth; sx += pixSample) {\n        for (float sy = fragCoord.y-pixWidth; sy <= fragCoord.y+pixWidth; sy += pixSample) {\n            total++;\n            vec2 s = frag2point(vec2(sx, sy));\n            if ( f(s.x) > s.y ) plot++;\n            if ( s.x*s.y > 0.0 ) axes++;            \n        }\n    }\n    float plotAxes = samples2stroke(axes/total);\n    float plotSampling = samples2stroke(plot/total);\n    \n    // draw axes\n    col = mix(colAxes, col, plotAxes);\n    \n    // draw plot depending on fragCoord.x\n    if (fragCoord.x < 0.33*iResolution.x) {\n        // naive approach\n    \tcol = mix(colNaive, col, plotNaive);\n    } else if (fragCoord.x < 0.67*iResolution.x)  {\n        // derivative calculation\n\t   \tcol = mix(colDerivative, col, plotDerivative);\n    } else {\n    \t// sampling\n\t\tcol = mix(colSampling, col, plotSampling);\n    }\n    \n    // vignetting\t\n\tcol *= 1.0 - 0.1*length(p);\n    \n    // output\n    fragColor = vec4(col, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 437, 455, 476, 531], [767, 767, 798, 798, 859], [861, 861, 896, 896, 972], [974, 974, 1031, 1048, 2752]], "test": "valid"}
{"id": "WtffR8", "name": "Moon Fishing", "author": "makkotech", "description": "by rakurai5", "tags": ["glsl"], "likes": 3, "viewed": 77, "published": "Public", "date": "1595916411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define TAU 6.28318530718\n#define Octaves 4\n#define PI2 6.28318530718\n\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat opUnion(float d1, float d2) { return min(d1, d2); }\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\nfloat opSubtraction(float d1, float d2) { return max(d1, -d2); }\nfloat opOnion(float d, float thikness) { return abs(d) - thikness; }\n\nfloat noise(vec2 pixuv, float t, vec2 p){\n    vec2 p2 = mod(pixuv*TAU, TAU)-250.0;\n\tvec2 s = vec2(p2);\n\tfloat c = 1.0;\n\tfloat inten = 0.005;\n    \n    for (int n = 0; n < Octaves; n++) \n\t    {\n\t\t    float ti = t * (1.0 - (3.0 / float(n+1)));\n\t\t    s = p + vec2(cos(ti - s.x) + sin(ti + s.y), sin(ti - s.y) + cos(ti + s.x));\n\t\t    c += 1.0/length(vec2(p2.x / (sin(s.x+t)/inten),p2.y / (cos(s.y+t)/inten)));\n\t    }\n\t    c /= float(Octaves);\n\t    c = 1.17-pow(c, 1.4);\n    return c;\n}\n\nfloat moon(vec2 st){\n    float s = smoothstep(1.21, 1.2, length(st-vec2(0.15, .15)));\n    s *= smoothstep(.80, .81, length(st-vec2(.40, 0.75)));\n    return s;\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRect(vec2 p, vec2 r)\n{\n    vec2 d = abs(p) - r;\n    return length(max(d, 0.0))\n        + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdHook(vec2 p, float s)\n{\n    float base = opUnion(sdCircle(p, s * 0.7), sdRect(p - vec2(0, -1.5) * s, vec2(0.3, 1.0) * s));\n    float hookCircle = opOnion(sdCircle(p - vec2(0, -3.3) * s, s), 0.25 * s);\n    float mask = sdRect(p - vec2(-1.2, -3) * s, vec2(1, 1.1) * s);\n    float hook = opSubtraction(hookCircle, mask);\n    return opUnion(base, hook);\n}\n\nfloat sdline(vec2 p)\n{\n    float line = sdRect(p - vec2(0.13, 0.1), vec2(0.002, 0.55));\n    \n    return line;\n}\n\nfloat rand(int seed, float ray) {\n\treturn mod(sin(float(seed)*363.5346+ray*674.2454)*6743.4365, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    uv.x += 0.0035 * cos(uv.y * 100.0 + iTime * PI2);\n    uv.x += 0.0015 * cos(uv.y * 250.0 + iTime * PI2);\n    \n    vec2 uvn = gl_FragCoord.xy/iResolution.y;\n    \n    vec2 uv2 = -1.0 + 2.0*gl_FragCoord.xy / iResolution.xy;\n\tuv2.x *=  iResolution.x / iResolution.y;\n    \n    vec2 p = gl_FragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tp*= 10.0;\n    vec2 pixuv = vec2((gl_FragCoord.xy / iResolution.xy-0.5).x * 1.0, (gl_FragCoord.xy / iResolution.xy-0.5).y * 1.0);\n    \n    float n = noise(pixuv, iTime * 0.25, p);\n    vec3 back = vec3(n) * vec3(0.0,0.3,1.0);\n    back = pow(back,vec3(1.0,0.8,0.85));\n    back *= 2.0;\n\n    // bubbles by inigo quilez https://www.shadertoy.com/view/4dl3zn\n    vec3 bcol = vec3(0.0);\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n\t\tfloat rad = 0.025 + 0.025*siz+sin(iTime/6.+pha*500.0+siz)/30.0;\n\t\tvec2  pos = vec2( pox+sin(iTime/10.+pha+siz), -1.0-rad + (2.0+2.0*rad)\n\t\t\t\t\t\t *mod(pha+0.1*(iTime/5.0)*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv2 - pos );\n\t\tvec3  col = mix( vec3(0.15,0.15,0.25*sin(iTime/6.0)), \n\t\t\t\t\t\tvec3(0.25,0.4,0.85*sin(iTime/9.0)), \n\t\t\t\t\t\t0.5+0.5*sin(float(i)*1.2+1.9));\n        \n\t\tfloat f = length(uv2-pos)/rad;\n\t\tf = sqrt(clamp(1.0+(sin((iTime/7.0)+pha*500.0+siz)*0.5)-f*f,0.0,1.0));\n\t\tbcol += col.zyx *(1.0-smoothstep( rad*0.85, rad, dis )) * f;\n\t}\n\n    vec3 col = vec3(0.0, .35 + uv.y * .55, .95 + uv.y * .25);\n    \n    vec3 moon = vec3(moon(uv+vec2(0.1,0.6)));\n    moon *= back;\n    \n    col += moon;\n    col += bcol;\n    \n    vec2 lPos = vec2(1.2,0.6);\n    \n    if (sdline(uvn - lPos) < 0.0)\n    {\n        col = vec3(1.0);\n    }\n    \n    if (sdHook(uvn - lPos - vec2(0.13, -0.45), 0.01) < 0.0)\n    {\n        col = vec3(0.1);\n    }\n    \n    vec2 position = ( gl_FragCoord.xy / iResolution.xy ) - vec2(0.1, 1.5);\n\tposition.y *= iResolution.y/iResolution.x;\n\tfloat ang = atan(position.y, position.x);\n\tfloat dist = length(position);\n\tvec3 Light = vec3(0.15, 0.5, 0.8) * (pow(dist, -1.0) * 0.2) + dist * vec3(0.02, 0.1, 0.35);\n\tfor (float ray = 0.0; ray < 100.0; ray += 1.0) {\n\t\tfloat rayang = rand(5234, ray)*10.0+iTime*0.15*(rand(2500, ray)-rand(4000, ray));\n\t\trayang = mod(rayang, PI*2.0) + PI * 0.5;\n\t\tif (rayang < ang - PI) {rayang += PI*2.0;}\n\t\tif (rayang > ang + PI) {rayang -= PI*2.0;}\n\t\tfloat brite = .20 - abs(ang - rayang);\n\t\tbrite -= dist * 0.05;\n\t\tif (brite > 0.0) {\n\t\t\tLight += vec3(0.0, 0.25+0.4*rand(4567, ray), 0.25+0.4*rand(5000, ray)) * brite;\n\t\t}\n\t}\n    \n    col *= Light;\n    \n    col *= uvn.y * 1.5;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 183, 183, 205], [206, 206, 248, 248, 270], [271, 271, 312, 312, 335], [336, 336, 376, 376, 404], [406, 406, 447, 447, 886], [888, 888, 908, 908, 1048], [1050, 1050, 1083, 1083, 1111], [1113, 1113, 1143, 1143, 1236], [1238, 1238, 1269, 1269, 1597], [1599, 1599, 1621, 1621, 1710], [1712, 1712, 1745, 1745, 1815], [1817, 1817, 1872, 1872, 4689]], "test": "valid"}
{"id": "WtfyWj", "name": "Ocean Treasure", "author": "dean_the_coder", "description": "Lots of firsts for me: Underwater, refraction (bubbles), 'god rays', and modelling of a (simple!) stingray.\n\nThanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!", "tags": ["3d", "raymarching", "sea", "water", "godrays", "caustics"], "likes": 14, "viewed": 510, "published": "Public API", "date": "1593609443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Ocean Treasure'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n#define time (iTime + 37.0)\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRod(vec3 p, float h, float r) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSurface(vec2 p) {\n    float sh = texture(iChannel0, (p + vec2(0.0, 1.0) * (time + 1.0)) * 0.05).r;\n    sh -= texture(iChannel0, (p + vec2(0.7, 0.2) * time) * 0.05).r;\n    return clamp(0.05 + sh * 0.2, 0.0, 1.0);\n}\n\nfloat sdChest(vec3 p) {\n    if (length(p) > 4.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    float w = 1.0;\n    float l = 1.5;\n    float h = 0.6;\n    \n    vec3 pp = p + vec3(0.0, h, 0.0);\n    vec3 bs = vec3(w, h, l);\n    float box = sdBox(pp , bs);\n    float boxInner = sdBox(pp - vec3(0.0, 0.9, 0.0), bs);\n    box = max(box, -boxInner);\n\n    p.xy *= rot(0.2);\n    p.y -= 0.2;\n    float lid = max(max(-p.y, length(p.xy) - w), abs(p.z) - l);\n    \n    float d = min(lid, box) - texture(iChannel0, (p.xz + p.y) * 0.11).r * 0.1;\n    d -= abs(abs(p.z) - l * 0.5) < 0.15 ? 0.07 : 0.0;\n    \n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    float bh = textureLod(iChannel0, p.xz * rot(1.1) * 0.01, 2.5).r * 6.5;\n\t     bh += textureLod(iChannel0, (p.xz + vec2(12.3, 23.4)) * rot(0.5) * 0.02, 0.0).r * 1.2;\n    bh /= 2.5;\n    return p.y + 6.0 - bh;\n}\n\nfloat sdBubble(vec3 p, float t) {\n    float progress = pow(min(fract(t * 0.1) * 4.5, 1.0), 2.0);\n    float maxDepth = 4.2;\n    float depth = maxDepth * (1.0 - progress * progress);\n    float r = mix(0.01, 0.08, progress);\n    \n    float d = 1.2 - smoothstep(0.0, 1.0, min(progress * 5.0, 1.0)) * 0.3;\n    \n    return length(p + vec3(d, depth, -1.0 + 0.2 * progress * sin(progress * 10.0))) - r;\n}\n\nfloat sdPlant(vec3 p, float h) {\n    float r = 0.02 * -(p.y + 2.5) - 0.005 * pow(sin(p.y * 30.0), 2.0);\n    p.z += sin(time + h) * pow(0.2 * (p.y + 5.6), 3.0);\n    return sdRod(p + vec3(0.0, 5.7, 0.0), 3.0 * h, r);\n}\n\nfloat sdPlants(vec3 p) {\n    vec3 dd = vec3(0.2, 0.0, -0.5);\n    \n    // Make multiple copies, each one displaced and rotated.\n    float d = 1e10;\n    for (int i = 0; i < 4; i++) {\n        d = min(d, min(sdPlant(p, 1.2), min(sdPlant(p + dd.xyx, 0.5), sdPlant(p + dd, 0.8))));\n        p.x -= 1.0;\n        p.z -= 1.0;\n        p.xz *= rot(0.6);\n    }\n    \n    return d;\n}\n\nfloat sdManta(vec3 p) {\n    // Translate the origin to the center of the manta.\n    p.xz *= rot(3.141);\n    p.y += 3.5;\n    p.z += 22.0;\n    \n    float t = mod(iTime, 20.0);\n    p.x -= 30.0;\n    p.xz *= rot(-t * 0.07);\n    p.x += 30.0;\n\n    if (length(p) > 3.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    // Flap!\n    p.y -= sin(-time * 1.5) * 0.2;\n    p.y -= (abs(p.x) + 0.1) * sin(abs(p.x) + time * 1.5) * 0.4;\n    \n    // Wings.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 4.0);\n    float d = sdBox(pp, vec3(1.0, 0.015, 1.0));\n    d = smin(d, length(p.xz * vec2(0.5, 1.0)) - 1.18, -0.05); // Nose\n    \n    // Eyes\n    pp = p;\n    if (p.y > 0.0) {\n    \tpp.x = abs(pp.x) - 0.1;\n    \tpp.z -= 0.6;\n    \td = smin(d, length(pp) - 0.1, 0.05);\n    }\n    \n    // Tail.\n    p.z += 1.25;\n    d = smin(d, sdBox(p, vec3(0.005, 0.005, 2.0)), 0.3);\n    \n    return (d - 0.02) * 0.7;\n}\n\nfloat godLight(vec3 p, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 sp = p + lightDir * -p.y;\n\n    float f = 1.0 - clamp(sdSurface(sp.xz) * 10.0, 0.0, 1.0);\n    f *= 1.0 - length(lightDir.xz);\n    return smoothstep(0.2, 1.0, f * 0.7);\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    pp.xz *= rot(-.5);\n    \n    float surface = -p.y - sdSurface(p.xz);\n    float t = time * 0.6;\n    surface += (0.5 + 0.5 * (sin(p.z * 0.2 + t) + sin((p.z + p.x) * 0.1 + t * 2.0))) * 0.4;\n    \n    return min2(vec2(surface, 1.5),\n           min2(vec2(sdChest(pp + vec3(2.0, 4.4, 0.0)), 2.5),\n           min2(vec2(sdFloor(p), 3.5),\n           min2(vec2(sdPlants(p - vec3(6.0, 0.0, 7.0)), 5.5),\n           min2(vec2(sdManta(p), 6.5),\n           min2(vec2(sdBubble(pp, time - 0.3), 4.5),\n                vec2(sdBubble(pp, time), 4.5)))))));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0025;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcOcc(vec3 p, vec3 n) {\n    const float dist = 0.5;\n    return smoothstep(0.0, 1.0, 1.0 - (dist - map(p + n * dist).x));\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nfloat marchGodRay(vec3 ro, vec3 rd, vec3 light, float hitDist) {\n    // March through the scene, accumulating god rays.\n    vec3 p = ro;\n    vec3 st = rd * hitDist / 96.0;\n    float god = 0.0;\n    for (int i = 0; i < 96; i++) {\n        float distFromGodLight = 1.0 - godLight(p, light);\n        god += godLight(p, light);\n        p += st;\n    }\n    \n    god /= 96.0;\n\n    return smoothstep(0.0, 1.0, min(god, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera.\n    vec3 ro = vec3(-0.4, -2.0, -4.0);\n    ro.xz *= rot(0.03 * sin(time * 0.3));\n    ro.y += sin(time * 0.2) * 0.3;\n    vec3 rd = getRayDir(ro, vec3(0.0, -3.0, 0.0), uv);\n\n    // Raymarching loop.\n    int hit = 0; // ID of the object we hit.\n    float d = 0.01; // Ray distance travelled.\n    float maxd = 50.0; // Max ray distance.\n    vec3 p;\n    float outside = 1.0; // Tracks inside/outside of bubble (for refraction)\n    for (float steps = 0.0; steps < 100.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            if (h.y == 4.5) {\n                // Bubble refraction.\n                rd = refract(rd, calcNormal(p) * sign(outside), 1.0);\n                outside *= -1.0;\n                continue;\n            }\n            \n            hit = int(h.y);\n            break;\n        }\n        \n        if (d > maxd)\n            break;\n\n        d += h.x;\n    }\n\n    vec3 deepColor = vec3(0.02, 0.08, 0.2) * 0.1;\n    vec3 lightPos = vec3(1.0, 4.0, 3.0);\n    vec3 col = deepColor;\n    if (hit > 0) {\n        \n        vec3 n = calcNormal(p);\n        vec3 mat = vec3(0.15, 0.25, 0.6);\n        if (hit == 1) {\n            // Sea\n            n.y = -n.y;\n        } else {\n        \tif (hit == 2)\n                mat = mix(mat, vec3(0.2, 0.15, 0.125), 0.5); // Chest\n            else if (hit == 3)\n                mat += vec3(0.1, 0.1, 0.0); // Sand\n        \telse if (hit == 5)\n                mat += vec3(0.0, 0.2, 0.0); // Plant\n        \telse if (hit == 6)\n                mat += vec3(0.5); // Manta\n\n            mat *= 0.4 + 0.6 * godLight(p, lightPos);\n            mat *= calcOcc(p, n); // Ambient occlusion.\n                \n            // Shadows.\n            vec3 lightDir = normalize(lightPos - p);\n\t\t\tfloat sha1 = max(0.0, map(p + lightDir * 0.25).x / 0.25);\n            float sha2 = max(0.0, map(p + lightDir).x);\n            mat *= clamp((sha1 + sha2) * 0.5, 0.0, 1.0);\n        }\n        \n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        \n        float amb = 0.1;\n        float diff = max(0.0, dot(lightToPoint, n));\n\n        col = (amb + diff) * mat;\n    }\n    \n    // Fog.\n    float fog = clamp(pow(d / maxd * 2.0, 1.5), 0.0, 1.0);\n    col = mix(col, deepColor, fog);\n    \n    // God rays.\n    col = mix(col, vec3(0.15, 0.25, 0.3) * 12.0, marchGodRay(ro, rd, lightPos, d));\n    \n    // Output to screen\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 188, 188, 291], [293, 293, 312, 312, 388], [390, 390, 437, 437, 642], [644, 644, 671, 671, 703], [705, 705, 734, 734, 825], [827, 827, 866, 866, 925], [927, 927, 952, 952, 1148], [1150, 1150, 1173, 1173, 1771], [1773, 1773, 1796, 1796, 2008], [2010, 2010, 2043, 2043, 2406], [2408, 2408, 2440, 2440, 2624], [2626, 2626, 2650, 2650, 2994], [2996, 2996, 3019, 3075, 3889], [3891, 3891, 3930, 3930, 4153], [4155, 4155, 4173, 4173, 4731], [4733, 4733, 4761, 4761, 4952], [4954, 4954, 4985, 4985, 5084], [5174, 5174, 5215, 5215, 5356], [5358, 5358, 5422, 5477, 5775], [5777, 5777, 5834, 5834, 8483]], "test": "error"}
{"id": "wtfyzf", "name": "Isles", "author": "yonatan", "description": "Noiseless, 1/2 octave stepped fbm worked out better than I expected.\n\nOriginally written for https://pagedout.institute/", "tags": ["raymarching", "terrain", "fbm"], "likes": 11, "viewed": 204, "published": "Public", "date": "1593609568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// feel free to reuse\n\nmat2 rot2d(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));} // Angle => 2D rotation matrix\n\nfloat terrain_height(vec2 position) { // https://www.iquilezles.org/www/articles/fbm/fbm.htm\n  float height=0., amplitude=.8, n;\n  for(int i = 0; i < 20; i++) { // Sum up 20 layers\n    n = sin(position.x) * cos(position.y); n = n * n * n; // Simple base pattern, no noise\n    height += n * amplitude; // Accumulate value at current amplitude\n    position *= rot2d(float(i*i)); // Rotate (phase-shift?) by a hash of the current iteration\n    position *= 1.4; // Scale (increase frequency by ~1/2 an octave)\n    amplitude *= .66; // Reduce amplitude\n  }\n  return height;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime*.1;\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x,iResolution.y);\n  vec3 p, water_tint = vec3(1), ray_origin = vec3(-cos(time*.5)*4.,1.,time), // Camera position\n       ray_direction = normalize(vec3(uv.x, uv.y - .7 + cos(time) * .5, 1.7));\n  ray_direction.xy *= rot2d(sin(time*.5)*.5); // Camera orientation and field of view\n  float distance = 0., ray_length = 0.;\n  for(int i = 0; i < 75; i++) { // Raymarching loop\n    p = ray_origin + ray_direction * ray_length; // Get current ray position\n    if(distance<.1 && p.y<0.) { // If we're close to the surface check p.y for a water hit\n      ray_origin.y = -ray_origin.y; ray_direction.y = -ray_direction.y; // Reflect ray\n      water_tint = vec3(.78, .85, .8); // Make water greener and darker\n    } else { // Not underwater - march\n      distance = p.y-terrain_height(p.xz); // Real distance is hard to calculate so use p's\n                                   // height above the terrain, and since that's obviously\n      ray_length += distance * .6; // wrong - only march .6 of the way and hope for the best.\n    }\n    if(ray_length > 20.) break; // We are far away (in the sky)\n  }\n  vec2 h = vec2(.0001, 0); // From https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n  vec3 surface_normal = normalize(vec3(terrain_height(p.xz-h.xy) - terrain_height(p.xz+h.xy),\n                               2.*h.x, terrain_height(p.xz-h.yx) - terrain_height(p.xz+h.yx)));\n  vec3 terrain_color = vec3(.9, .7, .6) * (surface_normal.z * .5 + .5); // Terrain, backlit\n  vec3 sky_color = mix(vec3(1.2,1.,.9),vec3(.4,.5,.6),abs(ray_direction.y)); // Sunny horizon\n  if(ray_length > 20.) { // Reuse terrain_height() FBM to paint some clouds\n    vec2 cloud_uv = ray_direction.xz / ray_direction.y + time;\n    sky_color *= 1. - min(0., terrain_height(cloud_uv) * ray_direction.y);\n  }\n  vec3 color = mix(terrain_color, sky_color, min(1., ray_length / 20.)); // Mountains-sky fade\n  color *= water_tint; // Water color\n  fragColor = vec4(pow(color, vec3(.4545)), 1); // Gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 87], [120, 120, 157, 212, 690], [692, 692, 749, 749, 2823]], "test": "valid"}
{"id": "WtjcRR", "name": "Heightmap Circle Tests", "author": "Mischawake", "description": "testing out combining circles as heightmaps", "tags": ["normals"], "likes": 0, "viewed": 30, "published": "Public", "date": "1593660538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec2 pos1 = vec2(0.5,0.5+ sin(iTime/1.773)*0.1);\n    float r1 = 0.35;\n    \n    vec2 pos2 = vec2(0.75 + sin(iTime/1.892)*0.3,0.6);\n    float r2 = 0.20;\n    \n    vec2 pos3 = vec2(0.9,0.35);\n    float r3 = 0.25;\n    \n    float d1 = distance(pos1,uv);\n    float d2 = distance(pos2,uv);\n    float d3 = distance(pos3,uv);\n    \n\tfloat inf = 0.0;\n    float flip = 2.0;\n    \n    inf += pow( max( (r1 - d1)/r1,0.), flip );\n    inf += pow( max( (r2 - d2)/r2,0.), flip );\n    inf += pow( max( (r3 - d3)/r3,0.), flip );\n    \n    inf = pow( inf, 1.0 / flip );  \n    vec3 col = vec3(1,1,1) * inf;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 791]], "test": "valid"}
{"id": "wtjcRW", "name": "Fractured", "author": "Oggbog", "description": "kaleidoscopic type thing with added swoosh", "tags": ["trig"], "likes": 0, "viewed": 170, "published": "Public API", "date": "1593880837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n    uv += vec2(tan(mod(uv.x,uv.y)+iTime)/4.,sin(mod(uv.y,uv.x)+iTime)/2.);\n    \n    uv = fract(uv * 2.5)-.5;\n    float a = iTime*2.;\n    uv *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    \n    \n    float w = abs(sin(iTime*.5)/4.)+.2;\n    float s = step(uv.x,-w)-step(uv.x,w);\n    s *= step(uv.y,-w)-step(uv.y,w);\n    \n    vec3 col = vec3(s,s/4.,s/2.);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjcRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 515]], "test": "valid"}
{"id": "WtjcW1", "name": "Iridescent opals", "author": "jarble", "description": "As the camera angle changes, the colors also appear to change.", "tags": ["3d", "raymarching", "iridescent", "opal"], "likes": 4, "viewed": 272, "published": "Public API", "date": "1594250870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float scale = EPSILON*1000.0;\n\nvec3 animate(vec3 p){\n    vec3 p1 = p;\n    //p1 /= 1.1;\n    float d = 200.0;\n    return p+(sin(p1.zxy/d)+cos(p1.zxy/d))*d;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p /= scale*2.0;\n\n\n    float to_return = 4.5 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    for(int i = 1; i < 3; i++){\n    \t//p += sin(iTime);\n        p += animate(p*2.0-to_return)/3.0;\n        p /= 2.0;\n        to_return -= .5;\n        to_return = min(to_return,4.5 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0));\n        //to_return -= 1.5;\n    }\n    \n    return (to_return-.4) * scale/1.0;\n}\n\nvec3 surface_color(in vec3 uv)\n{\n   uv *= 10.0;\n   return sin(vec3(sceneSDF(uv/2.0),sceneSDF(uv/3.0),sceneSDF(uv/5.0))/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    vec3 eye = scale*vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*10.0; \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p)*.4+surface_color(p+viewDir*50.0)*.6;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjcW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 310, 310, 413], [415, 655, 679, 679, 1124], [1126, 1126, 1158, 1158, 1252], [1254, 1675, 1766, 1766, 2084], [2099, 2353, 2418, 2418, 2550], [2552, 2641, 2670, 2670, 2980], [2982, 3474, 3614, 3614, 4204], [4206, 4576, 4661, 4661, 5020], [5022, 5349, 5398, 5433, 5564], [5566, 5566, 5623, 5623, 6671]], "test": "valid"}
{"id": "wtjcWG", "name": "white dwarf", "author": "foil", "description": "Caution: it is highly unoptimized. \nBasically, it is just a combination of https://www.shadertoy.com/view/Md3XRB and https://www.shadertoy.com/view/ttlGDf with a slight tweaking.", "tags": ["warping", "sphere", "circle", "antialiasing"], "likes": 0, "viewed": 31, "published": "Public", "date": "1595286472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA\n\nfloat pulseCircle(in vec2 p, in float r)\n{\n    float l = length(p) - r;\n    return smoothstep(2.3,3.6,1.6*sin(4.5/l + 2.*iTime) + 0.2/l);\n}\n\nfloat circle(in vec2 p, in float r) {\n\tfloat l = r - length(p);\n    return l;\n}\n\nfloat hash(vec2 co){\n    return sin( 2355.44 * fract(sin(dot(co.xy ,vec2(12.9898,78.233)))  * 43758.5453));\n}\n\nvec3 warping(in vec2 pos) {\n\tfloat strength = 0.2;\n    float t = iTime/200.0;\n    \n    vec3 col = vec3(0);\n    \n    #ifdef AA\n    for(float i = -1.0; i <= 1.0; i++) {\n        for(float j = -1.0; j <= 1.0; j++) {\n\n            pos = pos+vec2(i*0.8,j*0.8)/3.0;\n            \n            #endif\n\n    \t\tfor(float k = 1.0; k < 6.0; k+=1.0){ \n    \t\t\tpos.x += strength * sin(2.0*t+k*1.5 * pos.y)+t*0.5;\n        \t\tpos.y += strength * cos(3.0*t+k*1. * pos.x)+t*0.3;\n\t\t\t}\n\n    \t\t//Time varying pixel colour\n    \t\tcol += 0.25 + 0.5*cos(t*0.5+pos.xyx*3.).xxx;\n    \t\t#ifdef AA\n        }\n    }\n\n    col /= 2.;   \n    #endif\n    \n\t//col = pow(col, vec3(0.4545));\n    col = clamp(col, vec3(0.0), vec3(1.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;    \n\n    vec3 bg = vec3(0.0);\n    vec3 noiseColor = vec3(clamp(hash(uv*iTime*0.2), 0.0, 1.0));\n    vec3 white = vec3(1.0);\n    vec3 warpingColor = warping(uv*1.0);\n\n    bg = mix(bg, white, pulseCircle(uv - vec2(0.9, 0.5), 0.3));\n    bg = mix(bg, warpingColor, smoothstep(0.0, 0.05, circle(uv - vec2(0.9, 0.5), 0.35)));\n\n    fragColor = vec4(bg, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjcWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 54, 54, 151], [153, 153, 190, 190, 232], [234, 234, 254, 254, 343], [1059, 1059, 1116, 1116, 1515]], "test": "valid"}
{"id": "WtjcWW", "name": "Basic ray tracer", "author": "banni", "description": "ray tracing", "tags": ["raytracing"], "likes": 0, "viewed": 76, "published": "Public", "date": "1594400414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float isp(in vec3 ro,\n                          in vec3 rd,\n                          in vec3 sp,\n                          in float radius){\n    vec3 a = sp - ro;\n    if(dot(a,rd) < 0.){return -1.;}\n    rd = normalize(rd);\n    float scProj = dot(a,rd);\n    vec3 proj = ro + rd * scProj;\n    float dist = length(proj-sp);\n    if(dist <= radius){\n        return scProj - sqrt(radius * radius - dist * dist);\n    }\n    return -1.;\n}\n\nfloat bouncy(float value){\n    //magic params\n    float t = 3.1;\n    float f = 6.;\n    //magic motion function\n\treturn (abs((sin(t - value * f) + 1.) * 4. - 2.))/6.;\n}\n\nfloat f1(float value){\n\treturn pow(value,0.5);\n}\n\nfloat f2(float value){\n\treturn pow(0.65 - value,2.) * 4. + 0.5;\n}\n\nfloat f3(float value){\n\treturn min(f1(value),f2(value));\n}\nfloat n21(vec2 c){\n\treturn fract(sin(c.x * 100. + c.y * 6598.) * 5398.);\n}\nfloat sn(vec2 uv){\n\tvec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0));\n    float tl = n21(id + vec2(0,1));\n    float tr = n21(id + vec2(1,1));\n  \tfloat bfn = mix(bl,br,smoothstep(0.,1.,lv.x));\n    float tfn = mix(tl,tr,smoothstep(0.,1.,lv.x));\n    return mix(bfn,tfn,smoothstep(0.,1.,lv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //1 * a + b = 0.25\n    //0 * a + b = -0.25\n    //a = 0.5, b = -0.25\n    float a = 0.5f;\n    float b = -0.25;\n    float x = fragCoord.x/iResolution.x;\n    float y = fragCoord.y/iResolution.y;\n    float aspectRatio = iResolution.x/iResolution.y;\n    x = x * a + b;\n    y = y * a + b;\n    x *= aspectRatio;\n    float nearPlane = 1.0f;\n    float farPlane = 10000.;\n    vec3 cameraPosition = vec3(0.0f,0.0,0.0);\n    vec3 ro = cameraPosition;\n    vec3 rd = normalize(vec3(x,y,nearPlane));\n    \n    vec3 lightPos = vec3(200,0,1.);\n    vec3 spheres[5];\n    for(int i = 0; i<spheres.length(); i++){\n    \tspheres[i] = vec3(0,0,10 + i * 20);\n    }\n    \n    float t = farPlane;\n    int index = 0;\n    for(int i = 0; i<spheres.length(); i++){\n        vec3 xOffset = vec3(15.,0,0);\n        vec3 yOffset = vec3(0,10.,0);\n        spheres[i] += xOffset * cos(iTime);\n        spheres[i] += yOffset * bouncy(iTime * 0.4) * 0.5;\n        float newt = isp(ro,rd,spheres[i],1.);\n        if(newt >= nearPlane && newt < t){\n        \tt = newt;\n            index = i;\n        }\n    }\n    if(t >= nearPlane && t < farPlane){\n        vec3 color = vec3(.6f,0.2f,1. - float(index) / 50.);\n        vec3 lightColor = vec3(1.0f,0.5f,0.1f);\n        //point of intersection\n        vec3 pi = ro + rd * t;\n        vec3 normal = normalize(pi - spheres[index]);\n        vec3 lightDir = normalize(lightPos - pi);\n        float diff = max(0.,dot(lightDir,normal));\n        vec3 difCol = lightColor * color * diff;\n        vec3 ambient = lightColor * color * 0.05f;\n        vec3 viewDir = normalize(ro - pi);\n        float spec = max(0.,dot(lightDir,reflect(-viewDir,normal)));\n        spec = pow(spec,32.);\n        vec3 specColor = lightColor * spec;\n        vec3 finalColor = difCol + ambient + specColor;\n        //Gamma correction\n        finalColor = pow(finalColor,vec3(0.4545));\n    \tfragColor = vec4(finalColor,1.0f);\n    }\n    else{\n        //sky\n        vec2 uv = fragCoord/iResolution.xy;\n        uv+= iTime *0.0001;\n        float amp = 1.;\n        float td = 0.;\n        float fn = sn(uv * 4.) * amp;\n        td += amp;\n        amp /= 2.;\n        fn += sn(uv * 8.) * amp;\n        td += amp;\n        amp /= 2.;\n        fn += sn(uv * 16.) * amp;\n        td += amp;\n        amp /= 2.;\n        fn += sn(uv * 32.) * amp;\n        td += amp;\n        amp /= 2.;\n        fn += sn(uv * 64.) * amp;\n        td += amp;\n        amp /= 2.;\n        fn += sn(uv * 128.) * amp;\n        td += amp;\n        amp /= 2.;\n        fn /= td;\n        vec3 blue = vec3(0,0,1);\n        vec3 white = vec3(1);\n        vec3 fincol = (1. - fn) * white + fn * blue;\n        //Gamma correction\n        fincol = pow(fincol,vec3(0.4545));\n        fragColor = vec4(fincol,1.0f);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjcWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 141, 141, 430], [432, 432, 458, 477, 599], [601, 601, 623, 623, 649], [651, 651, 673, 673, 716], [718, 718, 740, 740, 776], [777, 777, 795, 795, 851], [852, 852, 870, 870, 1201], [1203, 1203, 1260, 1332, 3987]], "test": "valid"}
{"id": "Wtjczw", "name": "Pixelated rainbow clouds + Pink!", "author": "Yambam", "description": "Fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK", "tags": ["hash"], "likes": 4, "viewed": 239, "published": "Public API", "date": "1593990716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK\n// 2020-07-05 23:08:47\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord*.3/pow(1.2,mag)));\n}\n\nvec3 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.,mag),0)*3.*iTime,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color1 = vec3(0,0,0);\n    float maximum = 5.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0);\n    }\n    fragColor = vec4(color1/maximum,0.0);\n    fragColor.r = mix(fragColor.r, 1., max(0., 3.3 - 3.*fragColor.b - 4.*fragColor.g));\n    fragColor.b += .2*fragColor.r;\n    fragColor.g -= .1*fragColor.b;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtjczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 169, 190, 190, 326], [329, 329, 368, 368, 420], [422, 422, 465, 465, 528], [530, 530, 587, 587, 942]], "test": "valid"}
{"id": "wtjyRD", "name": "Worley's noise", "author": "HypePaul", "description": "Worley's noise inside a cube with the camera passing through it.", "tags": ["noise"], "likes": 3, "viewed": 51, "published": "Public", "date": "1593888157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 25\n\nfloat hash1(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat closestDistance(vec3 pos, vec3[N] points) {\n    // number larger than max distance\n    float min = 10.;\n    for (int i = 0; i < N; i++) {\n    \tfloat d = (points[i].x - pos.x) *\n            \t  (points[i].x - pos.x) +\n            \t  (points[i].y - pos.y) *\n            \t  (points[i].y - pos.y) +\n            \t  (points[i].z - pos.z) *\n            \t  (points[i].z - pos.z);\n        if (min > d)\n            min = d;\n    }\n    return sqrt(min);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    vec3[N] points;\n    for (int i = 0; i < N; i++)\n        points[i] = vec3(\n            hash1(float(i) * floor(iTime / 2.)) * ratio,\n            hash1(float(i) * floor(iTime / 2.) / 2.),\n            hash1(float(i) * floor(iTime / 2.) / 3.) + .5);\n    fragColor = vec4(1. - 2. * vec3(closestDistance(vec3(uv, mod(iTime, 2.)), points)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 36, 36, 77]], "test": "valid"}
{"id": "wtjyRW", "name": "box nearest intersection", "author": "FabriceNeyret2", "description": "Computes closest positive ray-box intersection, if exist.\nComment line 23 for just that. Default = BBox mode: d = 0 inside.\nClick + drag mouse to chose a ray start + dir.\n", "tags": ["raytracing", "intersection", "mm", "bbox"], "likes": 9, "viewed": 250, "published": "Public API", "date": "1593877944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float r0 = .3, r1 = .5 /* , r2 */;\nconst vec2  P = vec2(1.1,.3),                        // bounding box at P, axis X0,X1\n      A = cos( -.5 + vec2(0,1.57) ),                 // ex: defined by angle -> frame <A,Aortho> \n     X0 = r0*A, X1 = r1*vec2(-A.y,A.x) /* , X2 */;   // axis X0,X1\n\n#define S(d) smoothstep( 1.5/R.y, 0., d )     // --- draw antialiased\nfloat line(vec2 p, vec2 a,vec2 b) {           // --- segment with disc ends: seamless distance to segment\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\n#define spot(P)  S( length( P - U ) -.01 )            // draw dot\n\n// --- v2. maybe a bit cheaper\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) */ ), I; // box radii \n    mat2  F = mat2( X0/dot(X0,X0), X1/dot(X1,X1) /* , X2/dot(X2,X2) */ );   // orthogonal normalized box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to normalized coordinates in box frame\n    I = abs(C-.5); if ( /*max(I.z,*/ max(I.x,I.y) <=.5 ) return 0.; // if inside the Bbox. Comment for box intersection\n    // C+lD = 0|1 -> l = ( 0|1 - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction */                        \\\n    l =  D[i] > 0. ?  C[i] < 0. ? -C[i]   : C[i] < 1. ? 1.-C[i] : -1.          \\\n                   :  C[i] > 1. ? 1.-C[i] : C[i] > 0. ? -C[i]   :  1.;         \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */      \\\n    I = (C+l*D)*L;                                                             \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^     */                 \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] */                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n /* test(2); */\n    return d==1e5 ? -1. : d;\n}\n\n/* // --- first version ( costlier ? )\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) * / ), I; // box radii \n    mat2  F = mat2( X0/L.x, X1/L.y /* , X2/L.z * / ); // orthogonal unitary box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to box frame\n    // C+lD = 0|L -> l = ( 0|L - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction * /                        \\\n    l =  D[i] > 0. ?  C[i] < 0.   ? -C[i]     : C[i] < L[i] ? L[i]-C[i] : -1.  \\\n                   :  C[i] > L[i] ? L[i]-C[i] : C[i] > 0.   ? -C[i]     :  1.; \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box * /      \\\n    I = C+l*D;                                                                 \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^    * /                  \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] * /                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n /* test(2); * /\n    return d==1e5 ? -1. : d;\n}\n*/\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y,\n         M1 = iMouse.xy/R.y,\n         M0 = iMouse.zw/R.y, C = M0,\n          D = normalize(M1-M0);\n    if (M1==vec2(0)) M1 = vec2(.4);\n    if (M0.x<=0.) C = M1, D = cos(iTime+vec2(0,11)), M1=M0+.2*D;     \n    O-=O;\n    O += S( min ( min ( line(U,P,P+X0),  line(U,P+X0,P+X0+X1) ), // draw box\n                  min ( line(U,P+X1,P),  line(U,P+X0+X1,P+X1) ) \n          )     );\n\n    if (D == vec2(0)) return;   \n    O.r += spot(C);\n    O.r += S( line(U, C, C+D ) );              // draw cam\n    \n    float d = intersect( C, D );               // shortest distance or -1.\n    if (d<0.) return;\n    \n    O.g += spot( C + d*D );                    // draw hit point ( if exist )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 398, 468, 639], [3978, 3978, 4016, 4016, 4742]], "test": "error"}
{"id": "WtjyWh", "name": "Basic optical illusion", "author": "Nrx", "description": "Simple optical illusion.", "tags": ["illusion"], "likes": 6, "viewed": 280, "published": "Public API", "date": "1594233103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage (out vec4 a, vec2 b) {\n\tvec2 c = iResolution.xy, d = (b + b - c) / c.y * 6.,\t/* Normalization of the fragment coordinates\t*/\n\t\te = d + 5. * cos (vec2 (0., 1.57) + iTime);\t\t\t/* Position of the little black circle\t\t\t*/\n\tc = floor (d) * .5;\t\t\t\t\t\t\t\t\t\t/* The plan is seen as a grid of squares\t\t*/\n\ta = vec4 (0., .5 + .5 * fract (c.x + c.y), .5, 1.);\t\t/* Squares' colors (light/dark green)\t\t\t*/\n\tc = round (d) / .1;\t\t\t\t\t\t\t\t\t\t/* Get the ID of the green squares' corners\t\t*/\n\ta = mix (a, vec4 (1., vec2 (cos (c.x + c.y) > 0.), 1.),\t/* Crosses' colors are cosines of these IDs\t\t*/\n\t\tsmoothstep (.4, .41, dot (d = fract (d) - .5, d)))\t/* Add crosses in the green squares' corners\t*/\n\t\t* smoothstep (0., .1, dot (e, e));\t\t\t\t\t/* Little black circle\t\t\t\t\t\t\t*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 762]], "test": "error"}
{"id": "WtjyWt", "name": "M_Sponge", "author": "kstyler", "description": "Practicing fractal geometry.", "tags": ["fractal", "raymarch", "menger", "sponge"], "likes": 3, "viewed": 211, "published": "Public API", "date": "1595718461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cros(vec3 p){\n    return min(box(p.xyy,vec3(1,1,9999)),min(box(p.xxz,vec3(1,9999,1)),box(p.yyz,vec3(9999,1,1))));\n}\n\nfloat sponge(vec3 p, float size){\n    float res = box(p,vec3(size));\n    float c = 2.*size;\n    float crSiz =3.; \n    for(int i = 0; i < 4; i++){\n      vec3 q = mod(p+0.5*c,c)-0.5*c;\n      float subt = cros(q*(crSiz/size))/(crSiz/size);  \n      res=max(-subt,res);\n      c/=3.;\n      crSiz*=3.;\n    }\n    return res;\n}\nfloat map(vec3 p){\n    return sponge(p,1.7);\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,0.01);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n}\n\nvec3 skyColor(vec3 rd){\n    vec3 outLight = vec3(0.125);\n    outLight+=addLight(10.*vec3(0.7,0.2,0.3),normalize(-vec3(0.2,0.05,0.2)),rd);\n    outLight+=addLight(10.*vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,0.,-11.);\n    vec3 rd = normalize(vec3(uv,1));\n    rd.xy*=rot(iTime/8.);\n    ro.xz*=rot(iTime/8.);\n    rd.xz*=rot(iTime/8.);   \n    vec3 color = vec3(0);\n    vec3 accum = vec3(0);\n    float tot = 0.;\n    for(int i = 0; i<80;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n        vec3 n = normal(p);\n        if(dst>0.01){\n        \tcolor = skyColor(rd)/2.;\n        }\n        else{    \n        \tcolor  = vec3(tot/1000.);    \n        }\n        accum+=color*0.04;\n    }\n    fragColor = vec4(1.-(accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 98, 98, 191], [193, 193, 212, 212, 314], [316, 316, 349, 349, 634], [635, 635, 653, 653, 681], [683, 683, 703, 703, 874], [876, 876, 928, 928, 1096], [1098, 1098, 1121, 1121, 1341], [1343, 1343, 1399, 1399, 2022]], "test": "valid"}
{"id": "WtjyzR", "name": "Path to the colorful infinity", "author": "benoitM", "description": "Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)", "tags": ["2d", "fractal", "colors", "space", "abstract", "recursive", "generative", "pseudo3d", "inversion", "layers", "symmetries", "travel", "spacefolding"], "likes": 60, "viewed": 1122, "published": "Public API", "date": "1593582640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Benoit Marini - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Try it fullscreen ;)\n// Try NUM_LAYERS 80. if your GPU can\n\n#define NUM_LAYERS 16.\n#define ITER 23\n\nvec4 tex(vec3 p)\n{\n    float t = iTime+78.;\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);   \n    float t= iTime* .3;\n    \n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\n    {\n        float d = fract(i+t); // depth\n        float s = mix(5.,.5,d); // scale\n        float f = d * smoothstep(1.,.9,d); //fade\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\n    }\n    \n    col/=NUM_LAYERS;\n    col*=vec3(2,1.,2.);\n   \tcol=pow(col,vec3(.5 ));  \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[226, 226, 244, 244, 464], [466, 466, 523, 523, 979]], "test": "valid"}
{"id": "WtKXRV", "name": "2D Metaballs 2 Colours", "author": "lewdoo", "description": "Metaballs with 2 colours", "tags": ["metaballs", "color"], "likes": 0, "viewed": 85, "published": "Public", "date": "1595364089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ballsize 6.2\n#define stickyness .35\nconst float ballcount = 8.;\nconst float drawDist = 3.;\nconst float origin = 2.;\n\nconst vec3 trunk1 = vec3(.3, .9, .3);\nconst vec3 trunk2 = vec3(.1, .2, .9);\n\nfloat rand(vec2 uv){\n\tfloat r= sin(dot(vec2(uv.x * 28.2763, uv.x * 634.324), uv) * 340.7328 * (sin(uv.x * uv.y * 1000.8924) + 0.933));\n\treturn r;\n}\n\n\nvec3 positions(float i){\n    vec3 p = vec3(sin(rand(vec2(i, i * 4027.))), sin(rand(vec2(i * 8136., i * 47.))), 2.) * 0.2;\n        p.x += (sin(rand(vec2(i * 0.2, i * 40.) + 0.2) * iTime) * \n                  rand(vec2(i + 0.3, i * 978.))) * 0.5;\n        \n        p.y += ((cos((rand(vec2(i + 0.1, i * 40.)) + 0.5) * iTime) * \n                  rand(vec2(i * 8923., i * 978.))) + 0.2) * 0.2;\n    \n    \t/*p.z += ((cos((rand(vec2(i + 0.6, i * 2.3453)) + 0.9) * iTime) * \n                  rand(vec2(i * 6324.4267, i * 2854.523))) + 0.2);*/\n\treturn p;\n}\n\nfloat rayMarching(in vec3 origin, in vec3 ray, out vec3 m){\n\tfloat mDist = 1.;\n    m = origin;\n    return 1.;\n    \n    \n}\n\nvec3 metaField(vec2 uv){\n    vec3 fieldi = vec3(0.);\n    \n\t//this bit is the meta field---------------------------\\/\n    for(float i = 0.; i < ballcount; i++){\n        \n        vec3 pos = positions(i);\n        \n        float depth = drawDist - (origin - pos.z);\n        \n    \tfloat d = 1. - distance(uv, pos.xy) * ballsize * depth;\n       \td += rand(vec2(i, 0.2)) * 0.1;\n        \n        \n       \tfloat ball = smoothstep(0., 1., d);\n        if(i < ballcount / 2.){\n        \tfieldi.r += ball;\n        }\n        else{\n    \t\tfieldi.g += ball;\n        }\n    }\n\n    fieldi.b = (sign(fieldi.r + fieldi.g - stickyness) * 0.5 + 0.5);\n    return fieldi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = metaField(uv);\n    \n    //applying the two colors\n    col.r /= (col.r + col.g);\n    col.g /= (col.r + col.g);\n    \n    col = vec3(col.r * trunk1 + (col.g) * trunk2) * col.b;\n    //------------------/\\\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 222, 222, 349], [352, 352, 376, 376, 899], [901, 901, 960, 960, 1022], [1024, 1024, 1048, 1048, 1670], [1672, 1672, 1729, 1779, 2161]], "test": "valid"}
{"id": "WtlBR4", "name": "dodeca (wip)", "author": "CoolerZ", "description": "Trying to construct the distance function to a dodecahedron.", "tags": ["raymarching", "dodecahedron"], "likes": 1, "viewed": 60, "published": "Public", "date": "1596163838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON .01\n#define MAX_ITERS 100\n\nconst float PI = radians(180.);\nconst float PI2 = 2.*PI;\n\nvec2 rot2d(vec2 p, float angle)\n{\n    mat2 r = mat2(\n        cos(angle), sin(angle), // first column\n        -sin(angle), cos(angle) // second column\n    );\n    return r*p;\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    vec3 o = dot(p, axis)*axis;\n    vec3 x = normalize(p-o);\n    vec3 y = normalize(cross(-axis, x));\n    float r = length(p-o);\n    return o + r*cos(angle)*x + r*sin(angle)*y;\n}\n\nfloat line_d(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba);\n}\n\nfloat line_d(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba);\n}\n\nfloat thick_line_d(vec2 p, vec2 a, vec2 b, float r)\n{\n    vec2 pa = p - a, ba = b - a;\n    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - i*ba)-r;\n}\n\nfloat point_d(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat ngon_d(vec2 p, int n, float r)\n{\n    float delta = PI2/float(n);\n    float d = 10000.0;\n    float sig = -1.;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec2 v1 = vec2(r*cos(a1), r*sin(a1));\n        vec2 v2 = vec2(r*cos(a2), r*sin(a2));\n        d = min(d, line_d(p, v1, v2));\n\n        if(cross(vec3(v1-p,0.),vec3(v2-v1,0.)).z < 0.)sig = 1.;\n    }\n    return sig*d;\n}\n\nfloat ngon_d(vec3 pos, int n, float r)\n{\n    vec2 p = pos.xy;\n    float delta = PI2/float(n);\n    float sig = -1.;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec2 v1 = vec2(r*cos(a1), r*sin(a1));\n        vec2 v2 = vec2(r*cos(a2), r*sin(a2));\n        if(cross(vec3(v1-p,0.),vec3(v2-v1,0.)).z < 0.)\n        {\n            sig = 1.;\n            break;\n        }\n    }\n    if(sig<0.)return abs(pos.z);\n    float d = 10000.0;\n    for(int i = 0; i < n; i++)\n    {\n        float a1 = float(i)*delta, a2 = float(i+1)*delta;\n        vec3 v1 = vec3(r*cos(a1), r*sin(a1), 0.);\n        vec3 v2 = vec3(r*cos(a2), r*sin(a2), 0.);\n        d = min(d, line_d(pos, v1, v2));\n    }\n    return d;\n}\n\nfloat vertex_d(vec3 p, vec3 pos)\n{\n    const float vertex_size = .1;\n    return length(p-pos)-vertex_size;\n}\n\nfloat dodeca_old(vec3 p, float radius)\n{\n    // https://en.wikipedia.org/wiki/Pentagon\n    // https://en.wikipedia.org/wiki/Regular_dodecahedron\n    const float C1 = 4./(sqrt(3.)*(1.+sqrt(5.)));\n    const float C2 = .5*sqrt(2.5+1.1*sqrt(5.));\n    const float C3 = sqrt(2./(5.-sqrt(5.)));\n    const float C4 = .5*sqrt(5.+2.*sqrt(5.));\n    const float dihedral_angle = radians(116.57);\n    float edge_len = radius*C1;\n    float ri = edge_len*C2; // radius of the inscribed sphere.\n    float d = 10000.0;\n    vec3 bot_center = ri*vec3(0,-1,0);\n    float pent_rad = edge_len*C3;\n    float delta_angle = PI2/5.;\n    const float line_thickness = .05;\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        float a2 = float(i+1)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    float pent_height = edge_len*C4;\n    float small_height = pent_height*sin(dihedral_angle);\n    float dodeca_height = 2.*ri;\n    float smaller_height = dodeca_height - small_height;\n    float low_height = (ri-smaller_height);\n    vec3 low_center = low_height*vec3(0,-1,0);\n    float low_rad = radius*cos(asin(low_height/radius));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n\n    // top half\n    //const float offset_angle = 0.;\n    const float offset_angle = PI2/10.;\n    //float offset_angle = mix(0., PI2/10.,.5+.5*sin(iTime));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        float a2 = offset_angle+float(i+1)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n\n        // join both halves with edges\n        float a3 = float(i)*delta_angle;\n        vec3 v3 = low_center + low_rad*cos(a3)*vec3(1,0,0) + low_rad*sin(a3)*vec3(0,0,1);\n        d = min(d, line_d(p, v2, v3)-line_thickness);\n        float a4 = offset_angle+float(i-1)*delta_angle;\n        vec3 v4 = -low_center + low_rad*cos(a4)*vec3(1,0,0) + low_rad*sin(a4)*vec3(0,0,1);\n        d = min(d, line_d(p, v3, v4)-line_thickness);\n    }\n\n\n    return d;\n}\n\nfloat plane_d(vec3 p, vec3 norm)\n{\n    return dot(p, norm);\n}\n\nfloat dodeca(vec3 p, float radius)\n{\n    vec3[] verts = vec3[](\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.),\n        vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec3(0.)\n    );\n    // https://en.wikipedia.org/wiki/Pentagon\n    // https://en.wikipedia.org/wiki/Regular_dodecahedron\n    const float C1 = 4./(sqrt(3.)*(1.+sqrt(5.)));\n    const float C2 = .5*sqrt(2.5+1.1*sqrt(5.));\n    const float C3 = sqrt(2./(5.-sqrt(5.)));\n    const float C4 = .5*sqrt(5.+2.*sqrt(5.));\n    const float dihedral_angle = radians(116.57);\n    float edge_len = radius*C1;\n    float ri = edge_len*C2; // radius of the inscribed sphere.\n    float d = 10000.0;\n    vec3 bot_center = ri*vec3(0,-1,0);\n    float pent_rad = edge_len*C3;\n    float delta_angle = PI2/5.;\n    const float line_thickness = .05;\n    int index = 0;\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        float a2 = float(i+1)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    float pent_height = edge_len*C4;\n    float small_height = pent_height*sin(dihedral_angle);\n    float dodeca_height = 2.*ri;\n    float smaller_height = dodeca_height - small_height;\n    float low_height = (ri-smaller_height);\n    vec3 low_center = low_height*vec3(0,-1,0);\n    float low_rad = radius*cos(asin(low_height/radius));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = float(i)*delta_angle;\n        vec3 vert_pos = low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = float(i)*delta_angle;\n        vec3 v1 = bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n\n    // top half\n    //const float offset_angle = 0.;\n    const float offset_angle = PI2/10.;\n    //float offset_angle = mix(0., PI2/10.,.5+.5*sin(iTime));\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -bot_center + pent_rad*cos(angle)*vec3(1,0,0) + pent_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        float a2 = offset_angle+float(i+1)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -bot_center + pent_rad*cos(a2)*vec3(1,0,0) + pent_rad*sin(a2)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n    }\n    for(int i = 0; i < 5; i++)\n    {\n        // vertices\n        float angle = offset_angle+float(i)*delta_angle;\n        vec3 vert_pos = -low_center + low_rad*cos(angle)*vec3(1,0,0) + low_rad*sin(angle)*vec3(0,0,1);\n        verts[index++] = vert_pos;\n        d = min(d, vertex_d(p, vert_pos));\n\n        // edges\n        float a1 = offset_angle+float(i)*delta_angle;\n        vec3 v1 = -bot_center + pent_rad*cos(a1)*vec3(1,0,0) + pent_rad*sin(a1)*vec3(0,0,1);\n        vec3 v2 = -low_center + low_rad*cos(a1)*vec3(1,0,0) + low_rad*sin(a1)*vec3(0,0,1);\n        d = min(d, line_d(p, v1, v2)-line_thickness);\n\n        // join both halves with edges\n        float a3 = float(i)*delta_angle;\n        vec3 v3 = low_center + low_rad*cos(a3)*vec3(1,0,0) + low_rad*sin(a3)*vec3(0,0,1);\n        d = min(d, line_d(p, v2, v3)-line_thickness);\n        float a4 = offset_angle+float(i-1)*delta_angle;\n        vec3 v4 = -low_center + low_rad*cos(a4)*vec3(1,0,0) + low_rad*sin(a4)*vec3(0,0,1);\n        d = min(d, line_d(p, v3, v4)-line_thickness);\n    }\n\n    vec3 mid1 = .2*(verts[0]+verts[1]+verts[2]+verts[3]+verts[4]);\n    vec3 mid2 = .2*(verts[10]+verts[11]+verts[12]+verts[13]+verts[14]);\n\n    vec3 mid3 = .2*(verts[0]+verts[1]+verts[5]+verts[15]+verts[6]);\n    vec3 mid4 = .2*(verts[1]+verts[2]+verts[6]+verts[16]+verts[7]);\n    vec3 mid5 = .2*(verts[2]+verts[3]+verts[7]+verts[17]+verts[8]);\n    vec3 mid6 = .2*(verts[3]+verts[4]+verts[8]+verts[18]+verts[9]);\n    vec3 mid7 = .2*(verts[4]+verts[0]+verts[9]+verts[19]+verts[5]);\n\n    vec3 mid8  = .2*(verts[10]+verts[11]+verts[15]+verts[6]+verts[16]);\n    vec3 mid9  = .2*(verts[11]+verts[12]+verts[16]+verts[7]+verts[17]);\n    vec3 mid10 = .2*(verts[12]+verts[13]+verts[17]+verts[8]+verts[18]);\n    vec3 mid11 = .2*(verts[13]+verts[14]+verts[18]+verts[9]+verts[19]);\n    vec3 mid12 = .2*(verts[14]+verts[10]+verts[19]+verts[5]+verts[15]);\n\n    d = min(d, vertex_d(p, mid1));\n    d = min(d, vertex_d(p, mid2));\n    d = min(d, vertex_d(p, mid3));\n    d = min(d, vertex_d(p, mid4));\n    d = min(d, vertex_d(p, mid5));\n    d = min(d, vertex_d(p, mid6));\n    d = min(d, vertex_d(p, mid7));\n    d = min(d, vertex_d(p, mid8));\n    d = min(d, vertex_d(p, mid9));\n    d = min(d, vertex_d(p, mid10));\n    d = min(d, vertex_d(p, mid11));\n    d = min(d, vertex_d(p, mid12));\n\n    //d = min(d, plane_d(p, normalize(mid1))); // doesn't quite work, needs to be clamped to interior of the pentagon.\n    vec3 axis1 = normalize(mid1 - mid2);\n    vec3 axis2 = normalize(mid3 - mid10);\n    vec3 axis3 = normalize(mid4 - mid11);\n    vec3 axis4 = normalize(mid5 - mid12);\n    vec3 axis5 = normalize(mid6 - mid8);\n    vec3 axis6 = normalize(mid7 - mid9);\n\n    float d1 = 0.0;\n    d1 = max(d1, abs(dot(p, axis1)));\n    d1 = max(d1, abs(dot(p, axis2)));\n    d1 = max(d1, abs(dot(p, axis3)));\n    d1 = max(d1, abs(dot(p, axis4)));\n    d1 = max(d1, abs(dot(p, axis5)));\n    d1 = max(d1, abs(dot(p, axis6)));\n    d1 -= radius*.8;\n    d = min(d, d1);\n    return d;\n}\n\n\n\nfloat scene_d(vec3 p)\n{\n    //float d = length(p)-1.;\n    //float d = ngon_d(rot2d(p.xy-vec2(0,-1), radians(90.+10.*iTime)), 5, .5);\n    //vec3 axis = vec3(0,0,1);\n    //float d = ngon_d(rot3d(p, axis, radians(90.+10.*iTime)), 5, .5);\n    //float d = ngon_d(rot3d(p-vec3(1,-1,1), axis, radians(90.+10.*iTime)), 5, .5);\n    vec3 pp = rot3d(p,vec3(0,1,0), iTime);\n    float d = dodeca(pp, 1.);\n    d = min(d, p.y+4.); // ground plane\n    //d = min(d, length(p.yz)-0.05); // x axis\n    d = min(d, length(p.xz)-0.05); // y axis\n    //d = min(d, length(p.xy)-0.05); // z axis\n    return d;\n}\n\nvec3 get_normals(vec3 p)\n{\n    float x1 = scene_d(p-vec3(EPSILON,0,0));\n    float x2 = scene_d(p+vec3(EPSILON,0,0));\n    float y1 = scene_d(p-vec3(0,EPSILON,0));\n    float y2 = scene_d(p+vec3(0,EPSILON,0));\n    float z1 = scene_d(p-vec3(0,0,EPSILON));\n    float z2 = scene_d(p+vec3(0,0,EPSILON));\n\n    return normalize(vec3(x2-x1,y2-y1,z2-z1)/(2.*EPSILON));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 cam_pos = vec3(1,2,4);\n    vec3 lookat = vec3(0.);\n    vec3 cam_dir = normalize(lookat-cam_pos);\n    vec3 world_up = vec3(0,1,0);\n    vec3 cam_right = normalize(cross(cam_dir, world_up));\n    vec3 cam_up = normalize(cross(cam_right, cam_dir));\n    float focal_dist = 2.;\n    vec3 ro = cam_pos + cam_dir*focal_dist + cam_right*uv.x + cam_up*uv.y;\n    vec3 rd = normalize(ro - cam_pos);\n    float ray_dist = 0.;\n    vec3 col = vec3(0.);\n    bool hit = false;\n    for(int i = 0; i < MAX_ITERS; i++)\n    {\n        float d = scene_d(ro+rd*ray_dist);\n        if(d<EPSILON)\n        {\n            hit = true;\n            break;\n        }\n        ray_dist += d;\n    }\n    if(hit)\n    {\n        vec3 hit_pos = ro+rd*ray_dist;\n\t\tcol = get_normals(hit_pos);\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 134, 134, 275], [277, 277, 321, 321, 500], [502, 502, 540, 540, 659], [661, 661, 699, 699, 818], [820, 820, 873, 873, 994], [996, 996, 1028, 1028, 1054], [1056, 1056, 1094, 1094, 1487], [1489, 1489, 1529, 1529, 2226], [2228, 2228, 2262, 2262, 2336], [2338, 2338, 2378, 2482, 6268], [6270, 6270, 6304, 6304, 6331], [12594, 12594, 12617, 12912, 13180], [13182, 13182, 13208, 13208, 13541], [13543, 13543, 13598, 13598, 14501]], "test": "error"}
{"id": "wtlBzr", "name": "Julia for n-Mandelbrot", "author": "amhall", "description": "Interactive Julia set of any integer Mandelbrot set or other complex polynomial. Try your own polynomials!", "tags": ["2d", "fractal", "julia", "mandelbrot", "polynomial"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1595929878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Anthony Hall, July 2020\n\nconst float pi = radians(180.0);\nconst int SUPERSAMPLE = 2; // Decrease to speed things up, increase to reduce aliasing\nconst float increment = 1.0 / float(SUPERSAMPLE);\nconst float offset = increment / 2.0 - 0.5;\n\n// Exponent of generalized Mandelbrot set\n// It is an integer for this shader because \nconst int EXPONENT = 5;\n\n// Radius of the circle traversed when the mouse button is released\nconst float radius = 0.0045;\n// Period (seconds) to make a full circle when the mouse button is released\nconst float period = 4.0;\n\n// Pro tip - slowly click your mouse across the left side of the screen\n// to get back to auto-circling C\n\n\n// By default, the graph is such that the minimum screen dimension\n// corresponds to [-1.0, 1.0]\n// If you change the exponent/polynomial you may have to change this to see it all\nconst float SCALE = 1.25;\n\n\n// Increasing this will increase the detail of some spirals\nconst int maxJuliaIters = 150;\n\n// The mandelbrot/polynomial doesn't really need many iterations to show detail\nconst int maxPolyIters = 50;\n\n// Decreasing this value will increase the brightness of intermediary values\n// If you increase the max iterations, you should decrease this\n// otherwise both sets may be very dim\nconst float brightnessExponent = 0.5;\n\n\n// Multiplies two complex numbers, c1 * c2\nvec2 complexMultiply(vec2 c1, vec2 c2);\n\n// Divides two complex numbers, c1 / c2\nvec2 complexDivide(vec2 c1, vec2 c2);\n\n// Divides a float by a complex number, f / c\nvec2 complexDivide(float f, vec2 c);\n\n\n// *** This is the polynomial function we iterate over for both sets ***\n// Input - initial z and C, max iteration count to use\n// Returns number of iterations\n// Pretty much any polynomial will yield a neat result\n// Try out your own polynomials using the complex functions above!\nint f(vec2 z0, vec2 C, int maxIters)\n{\n    vec2 z = z0;\n    int iters;\n    for (iters = 0; iters < maxIters; iters++)\n    {\n        // The actual polynomial\n        // Remove/add '*/' before each code segment to comment/uncomment\n        \n        // z^EXPONENT + C:\n        /* */\n        vec2 temp = z;\n        for (int i = 1; i < EXPONENT; i++)\n    \t\tz = complexMultiply(z, temp);\n        \n        z += C; /**/\n        \n        // Here are some of my other favorites\n        \n        // z^4 - z^3 + C:\n        /* \n\t\tz = complexMultiply(complexMultiply(complexMultiply(z, z), z), z)\n            - complexMultiply(complexMultiply(z, z), z)\n            + C; /**/\n        \n        // Inverse Mandelbrot set. Mighty circular!\n        // I highly recommend raising the max iterations for this one\n        // When C is near the borders of the main circular horn triangle,\n        // some of the convergence is not very apparent at only 100 iterations\n        /* \n        z = complexDivide(1.0, complexMultiply(z, z) + C); /**/\n        \n        // Break condition\n        if (dot(z, z) > 4.0)\n            break;\n    }\n    return iters;\n}\n\n// Get rainbow color of screen the same way a default shadertoy does\nvec3 getRainbowColor(vec2 point) {\n    point *= 4.0;\n    float time = iTime / 1.5;\n    return 0.5 + 0.5*cos(time + point.xyx + vec3(0,2,4));\n}\n\n// Converts a point in screen space to a point in complex space\nvec2 screenToSampleCoord(vec2 screenCoord, float minDimension) {\n\treturn SCALE * (2.0 * screenCoord - iResolution.xy) / minDimension;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    // Supersample\n    for (int j = 0; j < SUPERSAMPLE; j++) {\n        for (int i = 0; i < SUPERSAMPLE; i++) {\n         \tvec2 screenCoord = fragCoord + offset + increment * vec2(float(i), float(j));\n            \n            // Transform screen coord so minimum dimension is on interval \n            vec2 coord = screenToSampleCoord(screenCoord, minDimension);\n            \n            // Get C for Julia\n            // Rotate around in a circle until it gets clicked\n            // (or the mouse is way to the left)\n            // When the mouse is released, rotate in a circle\n            vec2 C;\n            if (iMouse.x < 1.0)\n            \tC =  0.8 * vec2(cos(iTime/4.0), sin(iTime/4.0));\n            else {\n\n                C = screenToSampleCoord(iMouse.xy, minDimension);\n                \n\t\t\t\tif (iMouse.z < 0.0) {\n                    float time = iTime * 2.0 * pi / period;\n                    C += radius * vec2(cos(time), sin(time));\n                }\n            }\n            \n            // Calculate colors for the polynomial set and the Julia set\n            float polyIters = float(f(vec2(0.0), coord, maxPolyIters));\n            float juliaIters = float(f(coord, C, maxJuliaIters));\n            \n            // Color points in the set to be black - can also be done for Julia set\n            polyIters = mod(polyIters, float(maxPolyIters));\n            // juliaIters = mod(juliaIters, float(maxIters));\n            \n            float polyIntensity = polyIters / float(maxPolyIters);\n            float juliaIntensity = juliaIters / float(maxJuliaIters);\n            \n            // Brighten them a bit\n            polyIntensity = pow(polyIntensity, (brightnessExponent + 1.0) / 2.0);\n            juliaIntensity = pow(juliaIntensity, brightnessExponent);\n            \n            vec3 polyColor = polyIntensity * getRainbowColor(uv);\n            vec3 juliaColor = juliaIntensity * (1.0 - getRainbowColor (uv));\n            \n            vec3 result = polyColor + juliaColor;\n            \n            // Invert if near C\n            if (length(coord - C) <= 0.012)\n                result = 1.0 - result;\n            \n            color += result;\n        }\n    }\n    // Average the samples\n    color /= float(SUPERSAMPLE * SUPERSAMPLE);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n// *** Complex operation implementations ***\n\n// c1 * c2\nvec2 complexMultiply(vec2 c1, vec2 c2) {\n    return vec2(\n    \tc1.x*c2.x - c1.y*c2.y,\n    \tc1.x*c2.y + c1.y*c2.x);\n}\n\n// c1 / c2\nvec2 complexDivide(vec2 c1, vec2 c2) {\n    // c1/(a + bi) = c1*(a - bi)/(a^2 + b^2)\n    vec2 numerator = complexMultiply(c1, vec2(c2.x, -c2.y));\n    float denominator = c2.x*c2.x + c2.y*c2.y;\n    \n    return numerator / denominator;\n}\n\n// f / c\nvec2 complexDivide(float f, vec2 c) {\n \t// f/(a + bi) = f*(a - bi)/(a^2 + b^2)\n    vec2 numerator = f * vec2(c.x, -c.y);\n    float denominator = c.x*c.x + c.y*c.y;\n    \n    return numerator / denominator;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1552, 1834, 1872, 1872, 2964], [2966, 3035, 3069, 3069, 3177], [3179, 3243, 3307, 3307, 3382], [3384, 3384, 3441, 3441, 5890], [5938, 5949, 5989, 5989, 6065], [6067, 6078, 6116, 6161, 6312], [6314, 6323, 6360, 6401, 6529]], "test": "error"}
{"id": "wtlfR4", "name": "HSB Colour Twist - TBOS 6.0", "author": "stungeye", "description": "More colour hypnotism. The HSB spectrum plotted Polar and twisted through time.", "tags": ["sin", "color", "rgb", "colour", "colour", "trig", "twist", "hsb"], "likes": 1, "viewed": 253, "published": "Public API", "date": "1596200410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.1415926535897\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    \n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Polar plot of the HSB Colour Space.\n// https://thebookofshaders.com/06/\nvoid mainImage(out vec4 fragColor,  // Output (r, g, b, a) pixel color \n               in vec2 fragCoord) { // Input (x, y) image coordinate\n    \n    vec2 st = fragCoord.xy/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n   \n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float radius = length(toCenter)*2.0;\n    float angle = atan(toCenter.y,toCenter.x);\n    \n    // I only added the twist. :)\n    float twist = 10. * (sin(iTime / PI));\n    angle +=  twist * radius; // Rotate according to radius.\n    \n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 131, 157, 157, 340], [342, 417, 524, 557, 1154]], "test": "valid"}
{"id": "WtsBR4", "name": "OpenSimplex2 Fractal Warp V3", "author": "Auburn", "description": "Modified https://www.shadertoy.com/view/wlcXzB", "tags": ["noise"], "likes": 7, "viewed": 359, "published": "Public API", "date": "1596160692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////// K.jpg's Smooth Re-oriented 8-Point BCC Noise (OpenSimplex 2, Smooth Version) //////////////////\n///////////////////////// Modified to output a 2D vector instead of a standard 1D value. /////////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec2 bccNoisePart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    vec4 hashesRaw = permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0));\n    hashes = mod(hashesRaw, 48.0);\n    vec4 outDirHashes = mod(floor(hashesRaw / 48.0), 6.0);\n    vec4 outDirAngles = outDirHashes / 6.0 * 3.14159 * 2.0; // You could easily create more than 6 output base directions, with a wider-ranged hash\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    vec4 extrapolationsP = extrapolations * sin(outDirAngles);\n    vec4 extrapolationsQ = extrapolations * cos(outDirAngles);\n    \n    // Return it all as a vec4\n    return vec2(dot(aaaa, extrapolationsP), dot(aaaa, extrapolationsQ));\n   \n}\n\n// Classic \"Simplex\" noise lattice orientation.\nvec2 bccNoise_XYZ(vec3 X) {\n    \n    // Orthonormal rotation, not a skew transform.\n    X = dot(X, vec3(2.0/3.0)) - X;\n    return bccNoisePart(X) + bccNoisePart(X + 144.5);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec2 bccNoise_PlaneFirst(vec3 X) {\n    \n    // Orthonormal rotation, not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    return bccNoisePart(X) + bccNoisePart(X + 144.5);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n// Borrowed from https://www.shadertoy.com/view/Wt3XzS by FabriceNeyret2\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    vec2 uv = fragCoord;\n    uv *= 0.004;\n    \n    // Input point\n    vec3 X = vec3(uv, mod(iTime, 10000.0) * 0.09);\n    \n    // Evaluate noise\n    vec2 noiseResult = vec2(0);\n    float amp = 1.;\n    float z = 0.;\n    \n    for(int i = 0; i < 11; i++)\n    {\n    \tnoiseResult += bccNoise_PlaneFirst(X + vec3(noiseResult * (0.8 / sqrt(amp)), z)) * amp;\n        X *= 1.57;\n        amp *= 0.65;\n        z += 17.;\n    }\n    \n    float phi = atan(noiseResult.y, noiseResult.x);\n    vec3 col = hsv2rgb(vec3(phi/(2.*3.14159), 1., min(1.,length(noiseResult)*0.9)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 278, 300, 300, 337], [339, 401, 424, 472, 1443], [1445, 1490, 1517, 1517, 3202], [3204, 3252, 3279, 3335, 3426], [3428, 3579, 3613, 3669, 3990], [4074, 4147, 4169, 4169, 4338], [4340, 4340, 4395, 4466, 5081]], "test": "valid"}
{"id": "WtScDt", "name": "Bandlimited Synthesis 1", "author": "iq", "description": "A simple way to prevent aliasing of cosine functions (the color palette in this case) by removing frequencies as oscillations become smaller than a pixel. You can think of it as an LOD system. Move the mouse to compare naive versus band-limited cos(x)", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 145, "viewed": 24489, "published": "Public API", "date": "1595832751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/www/articles/palettes/palettes.htm)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.6,0.5,0.4);\n    col += 0.14*mcos(6.2832*t*  1.0+vec3(0.0,0.5,0.6));\n    col += 0.13*mcos(6.2832*t*  3.1+vec3(0.5,0.6,1.0));\n    col += 0.12*mcos(6.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.11*mcos(6.2832*t*  9.1+vec3(0.1,0.5,1.2));\n    col += 0.10*mcos(6.2832*t* 17.1+vec3(0.0,0.3,0.9));\n    col += 0.09*mcos(6.2832*t* 31.1+vec3(0.1,0.5,1.3));\n    col += 0.08*mcos(6.2832*t* 65.1+vec3(0.1,0.5,1.3));\n    col += 0.07*mcos(6.2832*t*131.1+vec3(0.3,0.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = 2.0*q/dot(q,q);\n\n    // animation\n    p.xy += 0.05*iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-th));\n    \n    // palette\n    if( q.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScDt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1932, 1953, 1977, 1977, 2140], [2205, 2205, 2225, 2225, 2253], [2255, 2364, 2393, 2393, 2893], [2895, 2895, 2951, 2970, 3564]], "test": "valid"}
{"id": "WtScDz", "name": "Pixelated rainbow clouds + Blue!", "author": "Yambam", "description": "My 2nd fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK", "tags": ["hash"], "likes": 2, "viewed": 199, "published": "Public API", "date": "1594073937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Pixelated rainbow clouds + Pink!\" by Yambam. https://shadertoy.com/view/Wtjczw\n// 2020-07-06 22:16:34\n\n// Fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK\n// 2020-07-05 23:08:47\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord*.3/pow(1.2,mag)));\n}\n\nvec3 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.,mag),0)*3.*iTime,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color1 = vec3(0,0,0);\n    float maximum = 5.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0);\n    }\n    fragColor = vec4(color1/maximum,0.0);\n    fragColor.r = mix(fragColor.r, 1., max(0., 3.3 - 3.*fragColor.b - 4.*fragColor.g));\n    fragColor.b += .2*fragColor.r;\n    fragColor.g -= .1*fragColor.b;\n    fragColor.r *= .6;\n    fragColor.g *= .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 284, 305, 305, 441], [444, 444, 483, 483, 535], [537, 537, 580, 580, 643], [645, 645, 702, 702, 1103]], "test": "valid"}
{"id": "WtScRD", "name": "endless particle room", "author": "Eugene_One", "description": "fork of https://shaderfrog.com/app/view/1815", "tags": ["shaderfrog"], "likes": 4, "viewed": 88, "published": "Public", "date": "1593787024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define G 32 // MORE => LESS\n\nfloat trace(vec3 o, vec3 r){\n    float d = 0.;\n    for (int i = 0; i < G; i++){\n        vec3 p = o + r * d;\n        d += length(mod(p, 2.) - 1.) - .2 + sin(dot(floor(p/2.), vec3(9)))*.1;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    vec2 uv = ((fragCoord/iResolution.y) * 2. - 1.);\n    fragColor = vec4(vec3(cos(t) * .5 + .5,\n                    .5 * sin(t) + .5,\n                    sin(t / 3.1243)) * \n                    10. /\n                        (1. + pow(\n                            trace(vec3(t, cos(t), sin(t)),\n                            normalize(vec3(uv, 1.7)) *\n                            mat3(\n                                cos(t / 5.),0.,-sin(t / 5.),\n                                0.,1.,0.,\n                                sin(t / 5.),0.,cos(t / 5.))), 2.) * .05\n                                ), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 58, 58, 238], [240, 240, 297, 297, 919]], "test": "valid"}
{"id": "wtScRt", "name": "julia's set", "author": "CyanMARgh", "description": "here is some sdf's and julia set on screen for example.", "tags": ["raymarching", "julia", "noob"], "likes": 4, "viewed": 103, "published": "Public", "date": "1595071897", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPos = vec3(0., .6, -5.5);\nfloat softShadow = 10.;\nfloat depthmax = 40.; \nconst float eps = 1e-4;\nvec3 backcol = vec3(1.,1.,1.)*1.;\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n//SDF operations\n//colored\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n//uncolored\nfloat un(float d1, float d2){\n    return d1<d2?d1:d2;\n}\nfloat dif(float d1, float d2){\n    d2*=-1.;\n    return d1>d2?d1:d2;\n}\nfloat smix( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//additioanal operations\nvec4 qxq( in vec4 a, in vec4 b){\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, \n        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );\n\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//SDF\nfloat sphere(vec3 pos){\n    return length(pos);\n}\nfloat plane(vec3 n, vec3 pos){\n    return dot(pos, n);\n}\nfloat capsule(vec3 a, vec3 b, float r1, float r2, vec3 p){\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n\t\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                           return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat box(vec3 b, vec3 p){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat disk(vec3 p0, vec3 n, float r,vec3 p){\n    p-=p0;\n    float d = length(p);\n    float h = abs(dot(p,n));    \n    float R = sqrt(d*d-h*h)-r;\n    return (R>0.)?sqrt(h*h+R*R):h;\n}\nfloat loop(vec3 p0, vec3 n, float r,vec3 p){\n\tp-=p0;\n    float d = length(p);\n    float h = abs(dot(p,n));    \n    float R = sqrt(d*d-h*h)-r;\n    return sqrt(h*h+R*R);\n}\nfloat cylinder(vec3 a, vec3 b, float r, vec3 p){\n    p-=a;b-=a;\n    float k = dot(b,p)/dot(b,b);\n    float d1 = length(b*k-p)-r;\n    if(k>0.&&k<1.){\n        return d1;\n    }else{\n        float d2 = (abs(k-.5)-.5)*length(b);\n        if(d1>0.){            \n            return sqrt(d1*d1+d2*d2); \n        }else{\n            return d2;\n        }\n    }\n}\nfloat cut(vec3 p, float r){\n    p*=r;\n  \tfloat da = box(vec3(inf,1.0,1.0),p);\n\tfloat db = box(vec3(1.0,inf,1.0),p);\n\tfloat dc = box(vec3(1.0,1.0,inf),p);\n\treturn min(da,min(db,dc))/r;\n}\nfloat sponge(vec3 p, int L){\n\tfloat d = box(vec3(1.,1.,1.),p);\n    float s=1.;\n    float r=4.;\n    do{\n        d = max(-cut(p,r/(r-2.))/s,d);\n        p = mod((p+1.)*r,2.)-1.;   \n        s*=4.;L--;\n    }while(L>0&&length(p)<2.5);\n    return d;\n}\nfloat julia(int L, vec3 p){\n\tfloat t = iTime / 3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( p, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<L;i++){\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0){\n\t\t\tbreak;\n        }\n\t}\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n//color functions\nvec3 checkerboard(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return vec3(1.)*((d.x+d.y+d.z)%2==0?1.:.8);\n}\n//scene SDF\nvec4 map(vec3 p){\n    //\"room\"\n    vec4 d0 = vec4(.9,.9,1.,plane(vec3(0.,1.,0.),p)+1.5);\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(0.,0.,-1.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(1.,0.,0.),p)+10.02));\n    d0 = cun(d0,vec4(.9,.9,1.,box(vec3(1.,1.,1.),p-vec3(0.,-2.,0.))));\n    d0.xyz *= checkerboard(p);\n\n    p+=vec3(.0,.1,.0);\n    \n    //julia set\n    vec4 jul = vec4(1.,.6,.6,julia(8,p*.5-vec3(.0,.5,.0)));\n    d0 = cun(d0,jul);\n    \n    return d0;\n}\n//normal vector by point\nvec3 norm(vec3 pos){\n    const vec2 e = vec2(eps,0.);\n    float d = map(pos).w;\n    return normalize(vec3(\n        map(pos + e.xyy).w-d,\n        map(pos + e.yxy).w-d,\n        map(pos + e.yyx).w-d\n    ));\n}\n\n//color and length of ray\nvec4 rayCast(vec3 eye, vec3 dir){\n    vec3 pos; float depth=0.,dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n        depth += dist;\n        if (dist < eps){\n            break;\n        }else if(depth>depthmax){\n            depth = depthmax+eps;\n            break;\n        }\n    }\n    rc.w=depth;\n    return rc;\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += clamp(h,0.02,2.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\n\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    //direction calculation\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float angle = (1.2+cos(iTime*.4))*.6;\n    eye.xz*=ro(angle);\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.xz*=ro(angle);\n\n    //raymarching\n    vec4 rc = rayCast(eye, dir);\n    float depth = rc.w;\n\n    vec3 pos = eye+dir*depth;\n    vec3 n = norm(pos);\n    pos+=eps*n;\n    \n    vec3 col = rc.xyz;\n    vec3 lighting = vec3(.25);\n\n    if (depth < depthmax){\n\n        // adding 3 point lights and one directional light\n        lighting += getLight(pos, vec3(6., 8., 0.), n, vec3(1.,.9,.9), 15.,false);\n        lighting += getLight(pos, vec3(6., 8., -10.), n, vec3(1.,1.,1.), 50.,false);\n        lighting += getLight(pos, vec3(-10., 10., -2.), n, vec3(1.,1.,1.), 30.,false);\n        lighting += getLight(pos, vec3(2., 13., -10.), n, vec3(1.,.9,.9), 120.,true);\n        \n        //lighting -= getOcc(pos, n);\n\t\tcol *= lighting;\n    }else{\n        col=backcol;\n    }\n    \n    //compositing color, lighting and fog\n    fragColor = vec4(1.5*log(1.+ col)*exp(-0.003*depth), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtScRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 209, 236, 236, 266], [267, 267, 295, 295, 340], [341, 341, 381, 381, 484], [485, 497, 526, 526, 552], [553, 553, 583, 583, 622], [623, 623, 666, 666, 765], [767, 792, 824, 824, 1067], [1068, 1068, 1087, 1087, 1147], [1149, 1155, 1178, 1178, 1204], [1205, 1205, 1235, 1235, 1261], [1262, 1262, 1320, 1320, 1850], [1851, 1851, 1877, 1877, 1964], [1965, 1965, 2009, 2009, 2146], [2147, 2147, 2191, 2191, 2316], [2317, 2317, 2365, 2365, 2666], [2667, 2667, 2694, 2694, 2852], [2853, 2853, 2881, 2881, 3097], [3098, 3098, 3125, 3125, 3506], [3507, 3525, 3551, 3551, 3632], [3633, 3645, 3662, 3675, 4111], [4112, 4137, 4157, 4157, 4342], [4344, 4370, 4403, 4403, 4801], [4802, 4833, 4902, 4902, 5309], [5310, 5340, 5371, 5371, 5768], [5770, 5784, 5838, 5867, 6999]], "test": "valid"}
{"id": "WtScWV", "name": "Aerodynamics Boze", "author": "kaiware007", "description": "Fake wind tunnel test. ", "tags": ["raymarching"], "likes": 9, "viewed": 76, "published": "Public", "date": "1595429604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define AA 1\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 50\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 20.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(-0.6, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89);\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(MAX_DIST);\n    \n    vec3 b = p;\n    b = rotate(b, M_PI, vec3(0,1,0));\n    float scb = saturate(sin(b.z *200. + iTime*50.)) * 0.025;\n    \n    result = opU(result, sdBoze(b + vec3(0, 0, 0), vec3(1.+scb, 1.+scb, 1), 3.+sin(iTime*100.)*0.5));\n    \n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\n#define fog_density(x) (1.0 - saturate(exp2(20.0 - (x) * 1.5)))\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    \n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    \n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n        \n        float metalness = mat.metalness;\n        float dist = mat.dist;\n#ifdef ENABLE_REFLECTION\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI2 * -0.1;\n        //float t = iTime * -1.0;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        //float y = sin(t * 2.) * 0.25 + 0.5;\n        float y = 0.5;\n        //float r = 2.0 + sin(t * 0.5);\n        float r = 2.;\n        float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90 + RAD90*0.25;\n        //float theta = t + RAD90;\n        //float theta = RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.125, 0);\n        //vec3 ta = vec3(0. + t, -0.5, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1621, 1621, 1658, 1723, 1941], [2417, 2417, 2440, 2440, 2513], [2515, 2515, 2536, 2536, 2606], [2608, 2608, 2631, 2631, 2710], [2713, 2713, 2735, 2735, 3152], [3263, 3263, 3284, 3284, 3425], [3427, 3427, 3457, 3457, 3587], [3589, 3589, 3650, 3650, 3788], [3791, 3851, 3877, 3877, 4743], [4745, 4933, 4956, 4956, 5059], [5061, 5081, 5102, 5102, 5236], [5238, 5257, 5279, 5279, 5412], [5414, 5434, 5456, 5456, 5581], [5682, 5682, 5718, 5718, 5746], [5748, 5748, 5794, 5794, 5850], [5852, 5852, 5883, 5883, 5974], [5976, 5976, 6026, 6026, 6144], [6146, 6146, 6207, 6207, 6338], [6340, 6340, 6377, 6377, 6466], [6468, 6468, 6538, 6538, 6672], [6674, 6674, 6738, 6738, 6855], [6857, 6857, 6890, 6916, 6947], [6949, 6949, 6974, 6974, 6993], [6994, 6994, 7019, 7019, 7038], [7039, 7039, 7075, 7075, 7103], [7105, 7105, 7164, 7164, 7477], [7479, 7479, 7512, 7512, 7577], [7579, 7603, 7655, 7655, 7774], [7776, 7886, 7918, 7918, 8012], [8014, 8014, 8048, 8048, 8199], [8201, 8201, 8235, 8235, 8383], [8385, 8385, 8419, 8419, 8554], [8556, 8556, 8584, 8584, 8669], [8670, 8728, 8799, 8799, 9127], [9129, 9214, 9258, 9258, 9482], [9484, 9541, 9578, 9619, 9702], [9704, 9704, 9743, 9915, 10024], [10026, 10026, 10075, 10075, 10634], [10636, 10636, 10675, 10721, 10806], [10808, 10808, 10849, 10959, 11073], [11088, 11139, 11176, 11176, 11198], [11200, 11200, 11243, 11243, 11265], [11267, 11267, 11311, 11311, 11332], [11334, 11334, 11386, 11386, 11485], [11488, 11488, 11533, 11533, 11962], [11964, 11964, 11985, 11985, 12049], [12051, 12051, 12091, 12091, 12216], [12219, 12219, 12254, 12254, 12402], [12404, 12404, 12438, 12438, 12614], [12616, 12616, 12651, 12651, 12686], [12688, 12688, 12725, 12725, 12760], [12762, 12933, 13018, 13018, 13095], [13097, 13140, 13215, 13215, 13634], [13636, 14214, 14298, 14298, 14641], [14643, 14649, 14701, 14701, 14857], [14859, 14859, 14919, 14919, 14960], [14962, 15177, 15208, 15208, 15257], [15259, 15259, 15286, 15286, 15324], [15326, 15326, 15355, 15355, 15393], [15395, 15395, 15422, 15422, 15471], [15703, 15703, 15724, 15724, 15863], [15889, 15889, 15921, 15921, 16034], [16036, 16036, 16068, 16068, 16208], [16210, 16210, 16243, 16243, 16475], [16477, 16477, 16500, 16500, 17079], [17081, 17081, 17106, 17106, 17267], [17269, 17269, 17312, 17312, 18334], [18336, 18336, 18402, 18402, 18524], [18526, 18526, 18571, 18571, 18742], [18744, 18744, 18812, 18812, 19030], [19250, 19250, 19271, 19271, 19565], [20085, 20085, 20134, 20134, 20432], [20699, 20767, 20795, 20795, 20922], [20924, 21014, 21077, 21077, 21283], [21285, 21351, 21415, 21585, 22216], [22218, 22218, 22255, 22255, 22345], [22347, 22347, 22373, 22373, 24225], [24401, 24401, 24422, 24422, 24470], [24472, 24472, 24533, 24618, 24817], [24819, 24819, 24892, 24984, 25184], [25186, 25186, 25228, 25308, 25362], [25364, 25364, 25413, 25413, 25461], [25463, 25463, 25536, 25593, 25808], [25810, 25810, 25830, 25830, 25855], [26042, 26042, 26092, 26176, 26534], [26536, 26536, 26591, 26648, 26908], [26910, 26910, 27006, 27006, 28401], [28605, 28605, 28638, 28694, 28880], [28882, 28882, 28921, 28921, 28964], [28966, 28982, 29055, 29055, 29139], [29141, 29267, 29337, 29337, 29620], [29622, 29622, 29722, 29722, 30515], [30517, 30517, 30542, 30542, 31011], [31078, 31078, 31104, 31104, 31468], [31470, 31470, 31519, 31519, 32984], [32986, 32986, 33065, 33065, 35383], [35385, 35385, 35425, 35425, 37566], [37568, 37568, 37610, 37610, 37788]], "test": "valid"}
{"id": "WtScWz", "name": "Ero Cells", "author": "yacodes", "description": "Voronoi inspired cells", "tags": ["cellsvoronoi"], "likes": 2, "viewed": 168, "published": "Public API", "date": "1594066529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int POINTS_COUNT = 32;\n\nfloat random (float i) {\n  return fract(sin(i)* 43758.5453123);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  return mix(random(i), random(i + 1.0), smoothstep(0.,1.,f));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st.x *= iResolution.x / iResolution.y;\n  st.x -= 0.35;\n  vec3 color = vec3(.0);\n  vec2 point[POINTS_COUNT];\n  for (int i = 0; i < POINTS_COUNT; i++) {\n    point[i] = vec2(noise(float(i) + sin(iTime)), noise(float(i) + 1. + iTime));\n  }\n\n  float m_dist = 1.;\n  for (int i = 0; i < POINTS_COUNT; i++) {\n    float dist = distance(st, point[i] + sin(iTime * (noise(float(i)) + 2.5)) / 4.);\n    m_dist = min(m_dist, dist);\n  }\n\n  color += vec3(\n\t\tsmoothstep(0.1, 0.3, m_dist),\n\t\tsmoothstep(-0.1, -0.3, (1. - m_dist)),\n\t\tm_dist\n  );\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 54, 54, 95], [97, 97, 119, 119, 228], [230, 230, 285, 285, 892]], "test": "valid"}
{"id": "WtSczG", "name": "Raymarcher - Test 1", "author": "SpinningCube", "description": "This is my first ray marcher on Shadertoy.", "tags": ["raymarching"], "likes": 4, "viewed": 251, "published": "Public API", "date": "1594611578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Filmic Transform curve by milesWaugh\n\nconst int maxSteps = 256;\nconst float epsilon = 0.0001;\nconst float focalLength = 1.;\nconst float renderDist = 5000.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfShininess;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = vec3(0.1, 0.1, 0.1);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance( ray, pos ) - radius;\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float shininess ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfShininess = shininess;\n        }\n    }\n}\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n    addSDF( Sphere( ray, vec3(10, 0, 100), 15.), vec3(.8, 0., 0.), 1.5, 512. );\n    addSDF( Sphere( ray, vec3(-20, 0, 120), 15.), vec3(0., 0., 1.), 1.5, 512. );\n    //addSDF( Sphere( ray, vec3(5.*cos(iTime), 5.*sin(iTime), 120), 15.), vec3(0., 0., 1.), 1., 256. );\n    addSDF( Ground( ray, -15.), vec3(.4, .4, .4), 1., 256. );\n    return SDE;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    //const float eps = 10. * epsilon; // replace by an appropriate value\n    //const vec2 h = vec2(eps,0);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n        \n        scene( ray, renderDist );\n        \n        rayLength += SDE;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < epsilon ) {\n            return vec4(1., ray);\n        }\n    }\n    return vec4(1., ray);\n}\n\nvoid phongLighting(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * 1.), lightDist, false).x == 0. ) {\n        \n        diffuse += max(intensity * dot(surfNormal, lightDir), 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n    \tspecular += max(intensity * surfSpecular * pow(dot(surfNormal, halfway), surfShininess), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    phongLighting( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-50, 50, -10), 1., surfNormal );\n}\n\nvec3 filmicTransform(vec3 color) {\n    return vec3(1. - (1./(5. * pow(color.x, 2.) + 1.)),\n                1. - (1./(5. * pow(color.y, 2.) + 1.)),\n                1. - (1./(5. * pow(color.z, 2.) + 1.)));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    vec3 finalCol = filmicTransform((diffuse * surfCol) + (ambient * surfCol) + specular);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera = vec3(0., 5.*sin(iTime), 0.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSczG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[446, 446, 489, 489, 532], [544, 544, 594, 594, 638], [640, 640, 675, 675, 699], [701, 701, 770, 770, 949], [951, 951, 994, 994, 1366], [1368, 1368, 1395, 1395, 1874], [1876, 1876, 1957, 1957, 2398], [2400, 2400, 2509, 2509, 2832], [2834, 2834, 2925, 2925, 3066], [3068, 3068, 3126, 3126, 3195], [3197, 3197, 3231, 3231, 3402], [3404, 3404, 3459, 3459, 3667], [3669, 3669, 3726, 3726, 4274]], "test": "valid"}
{"id": "wtSczh", "name": "Sinusoids Wave 2D - variant3", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/3lScRR[/url]\nWith constant-contrast blending.\n\n", "tags": ["trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 3, "viewed": 194, "published": "Public API", "date": "1593690115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y, d, C,T=R-R,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    for (int k=0; k<49; k++)\n        C = U - round((U+vec2(k%7-3,k/7-3))*.2) / .2 ,\n        V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(V-V,1.-.05*dot(C,C)), d*=d*d*d,\n        O += sin( 36.*length(V) -2.*iTime +(U-.2*C).x ) * d.x ,\n        T += d*d;\n    O = ( .5 + .1*O/sqrt(T.x) )* smoothstep(1.,-1.,U.y -37.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 134, 134, 586]], "test": "valid"}
{"id": "wtSczy", "name": "Voronoooooooooise", "author": "TheGreatMurloc", "description": "fdsf noise", "tags": ["nnoise"], "likes": 1, "viewed": 55, "published": "Public", "date": "1595065489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p) {\n\treturn fract(sin(p.x*123.+p.y*3456.)*3524.);\n}\n\nvec2 N22(vec2 p) {\n\treturn vec2(N21(p), N21(p+324.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - vec2(.5,.5)) * vec2(1.,9./16.);\n    \n    float noise = 0.;\n    // Tiling\n    float tileMult = 20.;\n    vec2 tiledUV = fract(uv * tileMult) - vec2(.5);\n    vec2 id = floor(uv * tileMult) - vec2(.5);\n    \n    // Points\n    float t = (iTime+sin(iTime*.1))*10.;\n    vec2 pos = sin(N22(id)*t)*.5;\n    noise = 1.-step(.05,length(tiledUV-pos));\n    \n    // Distance\n    float dist = 999.;\n    for (float x = -1.; x <= 1.; x++)\n    {\n        for (float y = -1.; y <= 1.; y++)\n        {\n            vec2 off = vec2(x,y);\n            vec2 p = sin(N22(id+off)*t)*.5+off;\n            float d = length(tiledUV - p);\n            dist = min(d,dist);\n        }\n    }\n    \n    //Coloriiiing\n    noise = dist+.05;\n    noise -= (1.-noise)*abs(dot(uv,vec2(-cos(iTime+68.5646),sin(iTime)*2.)));\n    vec3 col = vec3(noise);\n    col.gr += uv+sin(iTime)*.3;\n    col += (1.-noise)*vec3(.4,.1,.5)-sin(iTime)*.3;\n    col -= .5;\n    col *= sin(iTime*.5);\n    col += .5;\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSczy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 67], [69, 69, 87, 87, 124], [126, 126, 183, 183, 1233]], "test": "valid"}
{"id": "Wtsfzn", "name": "Glowy shapes :)", "author": "makio135", "description": "Based on resources from iq, mercury hg_SDF and evvvil 🙏🙏🙏", "tags": ["raymarching", "glow"], "likes": 9, "viewed": 179, "published": "Public", "date": "1595859040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_resolution iResolution\n#define u_time iTime*.2\n\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 3\n\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n    if(3.0 * p.x < m) q = p.xyz;\n    else if(3.0 * p.y < m) q = p.yzx;\n        else if(3.0 * p.z < m) q = p.zxy;\n            else return m * 0.57735027;\n\n            float k = clamp(0.5 * (q.z - q.y + s), 0.0, s); \n        return length(vec3(q.x, q.y - s + k, q.z - k)); \n}\nfloat sdTorus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// subtract d1 from d2\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\n// from https://www.alanzucconi.com/2016/07/01/signed-distance-functions/#part4\nfloat opBlend(float sdf1, float sdf2, float amount) {\n    return amount * sdf1 + (1. - amount) * sdf2;\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nvec3 GDFVectors[19];\nvoid initGDFVectors() {\n    GDFVectors[0] = normalize(vec3(1, 0, 0));\n    GDFVectors[1] = normalize(vec3(0, 1, 0));\n    GDFVectors[2] = normalize(vec3(0, 0, 1));\n\n    GDFVectors[3] = normalize(vec3(1, 1, 1 ));\n    GDFVectors[4] = normalize(vec3(-1, 1, 1));\n    GDFVectors[5] = normalize(vec3(1, -1, 1));\n    GDFVectors[6] = normalize(vec3(1, 1, -1));\n\n    GDFVectors[7] = normalize(vec3(0., 1., PHI+1.));\n    GDFVectors[8] = normalize(vec3(0., -1., PHI+1.));\n    GDFVectors[9] = normalize(vec3(PHI+1., 0., 1.));\n    GDFVectors[10] = normalize(vec3(-PHI-1., 0., 1.));\n    GDFVectors[11] = normalize(vec3(1., PHI+1., 0.));\n    GDFVectors[12] = normalize(vec3(-1., PHI+1., 0.));\n\n    GDFVectors[13] = normalize(vec3(0., PHI, 1.));\n    GDFVectors[14] = normalize(vec3(0., -PHI, 1.));\n    GDFVectors[15] = normalize(vec3(1., 0., PHI));\n    GDFVectors[16] = normalize(vec3(-1., 0., PHI));\n    GDFVectors[17] = normalize(vec3(PHI, 1., 0.));\n    GDFVectors[18] = normalize(vec3(-PHI, 1., 0.));\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    float d = 0.;\n    for (int i = 13; i <= 18; ++i) d = max(d, abs(dot(p, GDFVectors[i])));\n    return d - r;\n}\n\nfloat glow = 0.;\nvec2 sceneSDF(vec3 p) {\n    p *= rotate3D((u_time + .3) * TAU, vec3(-1., 1.5, .2));\n\n    initGDFVectors();\n\n    float t = mod(u_time * 3., 3.);\n    float a = sdOctahedron(p, 1.5);\n    float b = sdTorus(p * rotate3D(PI/4., vec3(1, 1, 0)), vec2(1.1, .4));\n    float c = fDodecahedron(p * rotate3D(PI/2., vec3(1, 0 , 0)), 1.);\n    float d = opBlend(\n        opBlend(\n            opBlend(\n                a, \n                b, \n                linearstep(2., 2.3, t)\n            ), \n            c, \n            linearstep(1., 1.3, t)\n        ), \n        a, \n        linearstep(0., .3, t)\n    );\n\n    float d2 = 999.;\n    for(float i = -1.; i <= 1.; i+= .1) {\n        d2 = opUnion(d2, sdBox(p + vec3(0., (i - fract(t) * .2) * 3., 0.), vec3(2., .01, 2.)));\n    }\n\n    float d3 = d + .02;\n\n    d2 = opSubtraction(d - .1, opIntersection(d, d2));\n    glow += (0.005 / (0.004 + d2 * d2 * 50.)) * 1.5; \n\n    return vec2(d2, 1.);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    #if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n    #endif\n\n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = sceneSDF(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    // epsilon = a small number\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy).x + \n        e.yyx * sceneSDF(pos + e.yyx).x + \n        e.yxy * sceneSDF(pos + e.yxy).x + \n        e.xxx * sceneSDF(pos + e.xxx).x\n    );\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = sceneSDF(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n    return calcNormal(pos);\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette(float t){ \n    return vec3(0.50,0.50,0.50) + vec3(0.50,0.50,0.50) * cos(2. * 3.141592653589793 * (vec3(1.00,1.00,1.00) * t + vec3(0.00,0.33,0.67)));\n}\n\nvec3 render(in vec3 ro, in vec3 rd) { \n    // cast ray to nearest object\n    vec2 res = castRay(ro, rd);\n    float distance = res.x; // distance\n    float materialID = res.y; // material ID\n\n    vec3 col = vec3(0.6 - length((gl_FragCoord.xy - u_resolution.xy / 2.) / u_resolution.x));;\n        if(materialID > 0.0) {\n            vec3 pos = ro + distance * rd;\n            col = computeColor(ro, rd, pos, distance, materialID);\n        }\n    // col += glow * vec3(0.9, 0.9, 0.1);\n    col += glow * palette(u_time);\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Ray Origin)\\t\n    vec3 ro = vec3(0., 0., 3.6);\n    vec3 ta = vec3(0.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 color = vec3(0.0);\n\n    #if AA>1\n    for(int m = 0; m < AA; m++)\n        for(int n = 0; n < AA; n++) {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n            #else\n            vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n            #endif\n\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n            // render\\t\n            vec3 col = render(ro, rd);\n\n            color += col;\n            #if AA>1\n        }\n    color /= float(AA*AA);\n    #endif\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtsfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 268, 268, 605], [606, 606, 636, 636, 710], [712, 712, 741, 741, 898], [900, 939, 977, 977, 1386], [1388, 1388, 1423, 1423, 1449], [1451, 1474, 1515, 1515, 1542], [1544, 1544, 1586, 1586, 1612], [1614, 1694, 1747, 1747, 1798], [1800, 1800, 1851, 1851, 1910], [1933, 1933, 1956, 1956, 2920], [2922, 2922, 2960, 2960, 3073], [3092, 3092, 3115, 3115, 4012], [4014, 4014, 4064, 4064, 4250], [4252, 4252, 4290, 4290, 4904], [4906, 4906, 4978, 4978, 5250], [5252, 5252, 5282, 5314, 5563], [5565, 5565, 5605, 5605, 5911], [5914, 5914, 5979, 5979, 6009], [6011, 6072, 6094, 6094, 6235], [6237, 6237, 6274, 6309, 6791]], "test": "valid"}
{"id": "WtSyDh", "name": "The Birth of a Star", "author": "romeosoft", "description": "The Birth of a Star.", "tags": ["star", "accretiondisc"], "likes": 1, "viewed": 103, "published": "Public", "date": "1596003838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\nconst float pi = 3.1415926;\nfloat time;\nconst vec3 \n    c1 = vec3(0.4, 0.3, 0.42),\n\tc2 = vec3(1.7, 0.95,0.);\nconst float R = 0.3;\nconst float R1 = R * 1.25;\n\n//--------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------\nvec3 getCor(float r, vec3 p, vec3 camray)\n{\n   float d = (r - R);\n\t\t\n \t//float w = 0.01/(d*d*d + 0.001);\n    \n   // float v = w * r * dot(cross(p / r, vec3(0.,-1.,0.)), camray);\n   // \n   //ROT(p.xz, (1.1 + (d * 0.1)*w) * (iTime + 15.0));\n    \n   // vec3 cor = mix(c1,c2, 0.75 * map(vec3(p.x, p.y*0.01, p.z)) * 1.5);\n    \n    return mix(c2, c1, (r*r) / 5.5) * mix(1.,0.,r/4.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 1.25;\n    float eyea = -(iMouse.x / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.1)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.25 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    float dt = 0.02;\n    vec3 cor = vec3(0.0);\n    \n    for(int i = 0; i < 400; i ++)\n    {\n\t\tfloat r = length(p);\n        float rr = length(p.xz);\n        if(rr < abs(p.y) * 0.02)\n        {\n            cor = vec3(0., 0.95,1.);\n            break;\n        }\n        else \n        if(r > R)\n        { \n            float d = (r - R);\n            float w = 0.01/(d*d*d + 0.001);\n            vec2 pp = p.xz;\n            ROT(pp, (1.1 + (d * 0.1)*w) * (iTime + 15.0));\n            \n            float deta = map(vec3(pp.x,p.y,pp.y)*1.25);\n            float dt = 0.005 + deta * 0.02;\n            p += (v) * dt;\n            float h = 0.01 + deta * 0.005*(r);    \n            if(abs(p.y) < h && r < 5.)\n            {\n                cor += getCor(r, vec3(pp.x,p.y,pp.y), front) * mix(0.25, 0.01,r / 2.);\n\n                if(max(cor.r,cor.g) >= 0.9)\n                    break;\n            }\n        }\n        else\n        {\n            cor = vec3(1.0, 1.0, 0.2);\n            break;\n        }\n    }\n    \n    fragColor = vec4(cor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 864, 892, 892, 1441], [1442, 1442, 1471, 1471, 1719], [1721, 1721, 1748, 1748, 1999], [2001, 2001, 2021, 2021, 2167], [2168, 2215, 2258, 2258, 2594], [2596, 2596, 2653, 2653, 4256]], "test": "valid"}
{"id": "wtSyDK", "name": "v0TriLattice2.glsl", "author": "jorge2017a1", "description": "v0TriLattice2.glsl", "tags": ["v0trilattice2glsl"], "likes": 7, "viewed": 77, "published": "Public", "date": "1595449903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 hue2rgb(float h)\n{\n    h = fract(h) * 6.0 - 2.0;\n    return clamp(vec3(abs(h - 1.0) - 1.0, 2.0 - abs(h), 2.0 - abs(h - 2.0)), 0.0, 1.0);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float sxf = fract(sx);\n    float offs = step(fract(1.0 - uv.y), sxf);\n    return vec2(floor(sx) * 2.0 + sxf + offs, uv.y);\n}\n\nvec3 tri(vec2 uv)\n{\n    vec2 p = floor(uv2tri(uv));\n    float h = rand(p + 0.1) * 0.2 + iTime * 0.2;\n    float s = sin((rand(p + 0.2) * 3.3 + 1.2) * iTime) * 0.5 + 0.5;\n    return hue2rgb(h) * s + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n\n    float t1 = iTime / 2.0;\n    float t2 = t1 + 0.5;\n\n    vec3 c1 = tri(uv * (8.0 - 4.0 * fract(t1)) + floor(t1) * 4.0);\n    vec3 c2 = tri(uv * (8.0 - 4.0 * fract(t2)) + floor(t2) * 4.0 + 2.0);\n\n    fragColor = vec4(mix(c1, c2, abs(1.0 - 2.0 * fract(t1))), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 92], [94, 94, 117, 117, 237], [239, 239, 261, 261, 436], [438, 438, 457, 457, 641], [643, 643, 700, 700, 1035]], "test": "valid"}
{"id": "WtSyDW", "name": "Simple hexagonal truchet pattern", "author": "mrange", "description": "License CC0: Simple hexagonal truchet pattern\nNothing fancy, wanted a simple shader that illustrated simple hexagonal truchet patterns\n", "tags": ["truchet"], "likes": 6, "viewed": 288, "published": "Public API", "date": "1594302729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Simple hexagonal truchet pattern\n//  Nothing fancy, wanted a simple shader that illustrated simple hexagonal truchet patterns\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot120   = MROT(TAU/3.0);\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst vec2 n1       = normalize(sz.yx);\nconst vec2 n2       = n1*vec2(-1.0, 1.0);\nconst float radius  = 0.5/sqrt(3.0);\nconst vec2 off1     = 2.0*radius*n1;\nconst vec2 off2     = rot120*off1;\nconst vec2 off3     = rot120*off2;\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz*1.0, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(length(p1) < length(p2)));\n  vec2 n = p3 - p;\n  p = p3;\n\n  return round(n*2.0)*0.5;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat cell0(vec2 p) {\n  float d0 = abs(p.y);\n  float d1 = abs(dot(n1, p));\n  float d2 = abs(dot(n2, p));\n  float d3 = circle(p, radius);\n \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  d = min(d, d3);\n   \n  return d;\n}\n\nfloat cell1(vec2 p) {\n  p = abs(p);\n  float d0 = circle(p-off1, radius); \n  return d0;\n}\n\nfloat cell2(vec2 p) {\n  float d0 = circle(p-off1, radius);\n  float d1 = circle(p-off2, radius);\n  float d2 = circle(p-off3, radius);\n   \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n \n  return d;\n}\n\nfloat df(vec2 p, float scale, float width, inout vec2 nn) {\n   p /= scale;   \n   nn = hextile(p);\n   nn = round(nn);\n   float r1 = hash(nn);\n   float r2 = fract(23.0*r1);\n   rot(p, floor(r2*6.0)* TAU/6.0);\n   float d = 1E6;\n   if (r1 < 0.5) {\n     d = cell2(p);\n   } else if (r1 < 0.8) {\n     d = cell1(p);\n   } else {\n     d = cell0(p);\n   }\n   d *= scale;\n    \n   float d1 = abs(d) - width;\n   float d2 = abs(d) - width*2.0;\n   d2 = abs(d2) - width*0.5;\n   \n   return min(d1, d2);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n    \n  float aa = 4.0 / iResolution.y;\n  float tm = iTime*0.1;\n    \n  p += vec2(cos(tm), sin(tm*sqrt(0.5)));\n\n  vec2 nn = vec2(0.0);\n  float d = df(p, 0.25, 0.01, nn);\n\n  vec3 col = vec3(0.0);\n  \n  col += vec3(0.5 + 0.5*sin(nn*10.0), 1.0)*smoothstep(0.0, aa, -d);\n//  col += vec3(0.5, 0.3, 0.9)*pcos(500*d);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSyDW.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[189, 189, 213, 213, 283], [285, 285, 306, 306, 335], [730, 730, 758, 857, 1039], [1041, 1041, 1074, 1074, 1159], [1161, 1161, 1192, 1192, 1218], [1220, 1220, 1241, 1241, 1465], [1467, 1467, 1488, 1488, 1555], [1557, 1557, 1578, 1578, 1780], [1782, 1782, 1841, 1841, 2267], [2269, 2269, 2324, 2324, 2769]], "test": "error"}
{"id": "wtSyRc", "name": "Photon Transmission", "author": "Xor", "description": "Quick shader for fun.", "tags": ["light", "space", "stars"], "likes": 12, "viewed": 197, "published": "Public", "date": "1594936284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash(vec2 p)\n{\n \treturn fract(sin(mod(p.xy*2.94-p.yx*2.77,99.+p.x))*691.5);\n}\n\nvoid mainImage(out vec4 Color, in vec2 Coord)\n{\n    vec2 u = Coord/iResolution.xy+hash(Coord)*.02;\n    float s = hash(floor(u * mat2(9,-3,7,-4))).x;\n    float l = length(Coord-iResolution.xy*.4)/iResolution.y;\n    vec3 b = .5+.5*cos(l*vec3(40.-l*l,40.5,41.)-iTime+s*4.)/(.2+l*3.);\n    vec3 g = mix(hash(floor(Coord/2.)).xxx,vec3(.7,.9,1),pow(s,5.)*.2);\n\n    Color = vec4(pow(g,.5+b*b*80.)/(.5+l),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 82], [84, 84, 131, 131, 486]], "test": "valid"}
{"id": "wtSyRd", "name": "Ray-Box Intersection", "author": "pprovins", "description": "An axis-aligned bounding box (AABB) is intersected by a ray, the surface normal is then calculated from the intersection and used to reflect a background. Background is taken from Sphere shader created by kig.", "tags": ["reflection", "ray", "intersection", "box"], "likes": 2, "viewed": 241, "published": "Public", "date": "1595076324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 box(vec3 ray_origin, vec3 ray_dir, vec3 minpos, vec3 maxpos) {\n  vec3 inverse_dir = 1.0 / ray_dir;\n  vec3 tbot = inverse_dir * (minpos - ray_origin);\n  vec3 ttop = inverse_dir * (maxpos - ray_origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 traverse = max(tmin.xx, tmin.yz);\n  float traverselow = max(traverse.x, traverse.y);\n  traverse = min(tmax.xx, tmax.yz);\n  float traversehi = min(traverse.x, traverse.y);\n  return vec3(float(traversehi > max(traverselow, 0.0)), traversehi, traverselow);\n}\n\nvec3 background(float t, vec3 rd) {\n  vec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n  float sun = max(0.0, dot(rd, light));\n  float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n  float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n  return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) +\n         pow(ground, 0.5) * vec3(0.7, 0.6, 0.5) +\n         pow(sky, 1.0) * vec3(0.3, 0.5, 0.8);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) *\n            vec2(iResolution.x / iResolution.y, 1.0);\n  vec3 ray_origin = vec3(0.0, 0.0, -3.0);\n  vec3 ray_direction = normalize(vec3(uv, 1.0));\n  vec3 boxllc = vec3(1.2);\n  vec3 boxurc = vec3(3.0);\n  vec3 boxctr = (boxllc + boxurc) / 2.0;\n  vec3 box = box(ray_origin, ray_direction, boxllc, boxurc);\n  float is_box_hit = box.x;\n  float box_t_max = box.y;\n  float box_t_min = box.z;\n  vec3 box_hit = boxctr - (ray_origin + (box_t_min * ray_direction));\n  vec3 box_intersect_normal = box_hit / max(max(abs(box_hit.x), abs(box_hit.y)), abs(box_hit.z));\n  box_intersect_normal = clamp(box_intersect_normal, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0));\n  box_intersect_normal = normalize(floor(box_intersect_normal * 1.0000001));\n  vec3 box_reflect = reflect(ray_direction, box_intersect_normal);\n  vec3 bg_col = background(iTime, ray_direction);\n  vec3 col = background(iTime, box_reflect) * vec3(0.9, 0.8, 1.0);\n  fragColor = vec4(mix(bg_col, col, is_box_hit), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 67, 67, 530], [532, 532, 567, 567, 943], [945, 945, 1000, 1000, 2020]], "test": "valid"}
{"id": "wtSyRK", "name": "Raymarcher - Test 2: Repetition", "author": "SpinningCube", "description": "An infinite grid of multicolored spheres.", "tags": ["raymarching"], "likes": 3, "viewed": 250, "published": "Public API", "date": "1594787652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Filmic Transform curve by milesWaugh\n\nconst int maxSteps = 256;\nconst float epsilon = 0.01;\nconst float focalLength = 1.;\nconst float renderDist = 8000.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfShininess;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = .9*vec3(.5, .6, .7);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance(mod(ray, 150.), pos ) - radius;\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float shininess ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfShininess = shininess;\n        }\n    }\n}\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addSDF( Sphere( ray, vec3(100, 100, 100), 15.), colx, 1.5, 512. );\n    \n    return SDE;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n        \n        scene( ray, renderDist );\n        \n        rayLength += SDE;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < epsilon ) {\n            return vec4(1., ray);\n        }\n    }\n    return vec4(1., ray);\n}\n\nvoid phongLighting(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if (true)/*( shootRay(lightDir, ray + (surfNormal * 1.), lightDist, false).x == 0. )*/ {\n        \n        diffuse += max(intensity * dot(surfNormal, lightDir), 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n    \tspecular += max(intensity * surfSpecular * pow(dot(surfNormal, halfway), surfShininess), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    phongLighting( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    phongLighting( ray, rayDir, normalize(vec3(-1,1,-2)), surfNormal, 1., 0. );\n}\n\nvec3 filmicTransform(vec3 color) {\n    //return color;\n    return vec3(1. - (1./(5. * pow(color.x, 2.) + 1.)),\n                1. - (1./(5. * pow(color.y, 2.) + 1.)),\n                1. - (1./(5. * pow(color.z, 2.) + 1.)));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    //fog = fog*fog;\n    //fog = fog*fog;\n    vec3 finalCol = (diffuse * surfCol) + (ambient * surfCol) + specular;\n    finalCol = mix(finalCol, ambient, fog);\n    \n    return filmicTransform(finalCol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera = vec3(60.*iTime, 30.*iTime, 200.*iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = filmicTransform(ambient);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[444, 444, 487, 487, 530], [542, 542, 592, 592, 646], [648, 648, 683, 683, 707], [709, 709, 778, 778, 957], [959, 959, 1002, 1002, 1238], [1240, 1240, 1267, 1267, 1638], [1640, 1640, 1721, 1721, 2162], [2164, 2164, 2273, 2273, 2606], [2608, 2608, 2699, 2699, 2840], [2842, 2842, 2900, 2900, 2982], [2984, 2984, 3018, 3038, 3209], [3211, 3211, 3266, 3266, 3626], [3628, 3628, 3685, 3685, 4261]], "test": "valid"}
{"id": "wtSyWc", "name": "Trapezoid SDF flickering fix", "author": "bloxard", "description": "I've been looking into the 2D Trapezoid and I noticed a very small one pixel line in the center of the trapezoid primitive that were flickering.\nLeft: Original version taken from https://www.shadertoy.com/view/MlycD3\nRight: New flicker free version.\n", "tags": ["2d", "sdf", "distance", "trapezoid"], "likes": 4, "viewed": 154, "published": "Public", "date": "1595525639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// By Per Bloksgaard/2020\n\n// Original Trapezoid from https://www.shadertoy.com/view/MlycD3\nfloat sdTrapezoid( in vec2 p, in vec2 a, in vec2 b, in float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// Slightly improved version of a Trapezoid primitive without flicking.\nfloat sdTrapezoidFixed(in vec2 p, in vec2 a, in vec2 b, in float ra, float rb)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float baba = dot(ba, ba);\n    float x = abs(dot(vec2(-pa.y, pa.x), ba)) / sqrt(baba);\n    float paba = dot(pa, ba) / baba;\n    float rba = rb - ra;\n    float cax = max(0., x - ((paba < 0.5) ? ra : rb));\n    float cay = abs(paba - 0.5) - 0.5;\n    float f = clamp((rba*(x - ra) + paba * baba) / (rba * rba + baba), 0., 1.);\n    float cbx = x - ra - f * rba;\n    float cby = paba - f;\n    return sign(max(cbx,cay)) * sqrt(min(cax*cax + cay * cay*baba, cbx*cbx + cby * cby*baba));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.*fragCoord.xy)/iResolution.y*0.5;\n    float ra = 0.13-0.1*abs(sin(iTime*1.37+0.0));\n    float rb = 0.13-0.1*abs(sin(iTime*1.41+1.1));\n    vec2 pa = vec2(-0.3 + 0.05*sin(iTime*1.3), -0.2 + -0.15*cos(iTime*0.4));\n    vec2 pb = vec2(0.3 - 0.05*sin(iTime*-0.3), 0.2 + 0.15*cos(iTime*0.37));\n    float a = iTime * 0.7;\n    mat2 m = mat2(cos(a),sin(a),-sin(a),cos(a));\n    pa *= m;\n    pb *= m;\n\tfloat mX = (iMouse.z>0.) ? ((iMouse.x/iResolution.x*2.-1.)*iResolution.x/iResolution.y)*0.5 : 0.;\n    float d = 1e6;\n    if (p.x < mX)\n    {\n        d = sdTrapezoid(p, pa, pb, ra, rb);\n    }\n    else\n    {\n        d = sdTrapezoidFixed(p, pa, pb, ra, rb);\n    }\n    vec3 col = mix(vec3(0.,0.,1.), vec3(1.,1.,0.),sign(d));\n    col *= 1. - exp(-4.0*abs(d));\n    col *= 0.8 + 0.2*cos(140.*d);\n    col = mix(col, vec3(1.), 1. - smoothstep(0., 0.015, abs(d)));\n    col = mix(col, vec3(1.), 1. - smoothstep(0., 0.005, abs(d)));\n    col = mix(col, vec3(1.), 1.0 - smoothstep(0., 0.005, abs(p.x - mX)));\n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyWc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1070, 1135, 1212, 1212, 1758], [1760, 1832, 1912, 1912, 2437], [2439, 2439, 2496, 2496, 3545]], "test": "valid"}
{"id": "wtSyzh", "name": "Logarithmic Moebius Transform 12", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/tt2yRz[/url]\n\n(un)comment line  29 for const/adaptive disc size", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 11, "viewed": 229, "published": "Public API", "date": "1593687435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/tt2yRz\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I, D,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n\t     z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n#if 1\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n    U += .5;\n    float a = atan(U.y, U.x)/6.283;\n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U))*vec2(.5, -.5) + iTime/8.\n        + a * vec2(6, 1); // n    \n#else\n    U.x +=.022; U *= vec2(1.5,1);                             // test in the plane\n    if(u.x/R.y>sqrt(3.)/2.) return;\n#endif\n  //D  = vec2(10,14.82)/1.43;// /(.5+iMouse.x/R.x);\n    D  = vec2(21./3., 2./sqrt(3.)*9.);                        // thanks Shane !\n    mat2 M = mat2(1,0,.5,sqrt(3.)/2.);\n    U = U*D * M;                                              // triangular mesh\n    float dx=0.,dy=0.,dax=dFdx(a),day=dFdy(a);                // manage jump trough poles arc\n    if (abs(dax) > .5) dx=-sign(dax);\n    if (abs(day) > .5) dy=-sign(day);\n    D = vec2(6,1)*D * M;\n    vec2 dFdx = dFdx(U)+D*dx, dFdy = dFdy(U)+D*dy;\n  //z = fwidth(U);\n    z = abs(dFdx)+abs(dFdy);\n    M = inverse(transpose(mat2(dFdx, dFdy)))*30./R.y;         // Jacobian to go back to screen\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y>0.), v,                           // parallelogram = 2 triangles\n          i = mod( I.x + I.y , 3.), id; \n    I += i==0.? vec2(0) : i==1. ? vec2(1) : vec2(s,1.-s);  id = I.x +7.81*I.y;\n    vec4 V = vec4( 1.-2.*abs(U.x-U.y) , abs(U*2.-1.) , 0 );\n    v = V[i<2. ? 2-int(i+s)%2 : 0 ];\n    U = i==0. ? U : i==1. ? 1.-U : s==0.?vec2(U.x,U.y-1.):vec2(1.-U.x,-U.y);\n    U *= M;                                                  // undistort disc constante size\n    U *= 1.9 / length(vec4(M));                              // adaptive size\n // U *= inverse(mat2(1,0,.5,sqrt(3.)/2.));\n // O  = smoothstep(.7,-.7,(length(U)-.8)/( abs(z.x-z.y)>1.?.1:z.y*2.))\n    O  = smoothstep(.7,-.7,(length(U)-.8)/(z.y*2.))\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n    if (fract(iTime/6.)<.4) O += smoothstep(-.7,.7, (v-.95)/(z.y*4.));  // draw AA tiles\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 2239]], "test": "error"}
{"id": "WtSyzK", "name": "Quick noise improvisation", "author": "jaszunio15", "description": "Use mouse to adjust domain warp strength.\n\nQuick improvisation with simple fractal noise. Just fbm with domain warp :)\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)", "tags": ["noise", "improvisation", "domainwarp"], "likes": 4, "viewed": 90, "published": "Public", "date": "1594759602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\nfloat hash12(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(21.57851, 20.47856))) * 1347.8967423);\n}\n\nfloat noise12(vec2 x)\n{\n \tvec2 rootUV = floor(x);\n    vec2 frac = fract(x);\n    \n    float n00 = hash12(rootUV + vec2(0.0, 0.0));\n    float n01 = hash12(rootUV + vec2(0.0, 1.0));\n    float n10 = hash12(rootUV + vec2(1.0, 0.0));\n    float n11 = hash12(rootUV + vec2(1.0, 1.0));\n    \n    float n0 = mix(n00, n01, frac.y);\n    float n1 = mix(n10, n11, frac.y);\n    \n    return mix(n0, n1, frac.x);\n}\n\nfloat fractalNoise12(vec2 x, float maxScale, float sizeMod)\n{\n \tfloat noise = 0.0;\n    \n    for (float i = 1.0; i < maxScale; i *= sizeMod)\n    {\n     \tnoise += noise12((x + iTime / i * 0.2) * i) / i;\n        float warpStrength = noise12((x + 14.32762 - iTime * 0.1) * i) / i;\n        x += noise / i * (1.0 - iMouse.x / iResolution.x) * warpStrength * 2.0;\n    }\n    \n    return noise * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv += 0.01 * iTime;\n    \n    vec2 rootUV = floor(uv * 10.0);\n    \n    float noise = fractalNoise12(uv * 8.0, 64.0, 1.8);\n    float mask = 1.0 - smoothstep(0.2, 0.00, noise - (sin(iTime * 0.13) * 0.3 + 0.5));\n    \n    fragColor = vec4(mask);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSyzK.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[62, 62, 84, 84, 156], [158, 158, 181, 181, 554], [556, 556, 617, 617, 949], [951, 951, 1008, 1008, 1294]], "test": "valid"}
{"id": "wtSyzV", "name": "Diamond, Circle, Square", "author": "jt", "description": "A unit-circle of norm 1/q\nInterpolating q from 1 to 0 results in a smooth transition from diamond (q=1) via circle (q=0.5) to square (q=0).\nInstead of taking the limit for q=0 to avoid division by zero for visualization purpose some small q is sufficient\n", "tags": ["circle", "square", "diamond", "norm"], "likes": 2, "viewed": 64, "published": "Public", "date": "1594819357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2020 by jt\n// A unit-circle of norm 1/q\n// Interpolating q from 1 to 0 results in a smooth transition from diamond (q=1) via circle (q=0.5) to square (q=0).\n// Instead of taking the limit for q=0 to avoid division by zero for visualization purpose some small q is sufficient.\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    vec2 R = iResolution.xy;\n    I = (2. * I - R) / R.y;\n\n    //float q = .5 + .5 * cos(iTime); // exact but division-by-zero occurs \n    float q = .5 + .49 * cos(iTime); // inexact but avoids division-by-zero\n    //o = vec4(dot(pow(abs(I), vec2(1./q)), vec2(1)) < pow(1., 1./q));\n    o = vec4(dot(pow(abs(I), vec2(1./q)), vec2(1)) < 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 321, 321, 662]], "test": "error"}
{"id": "Wtt3RN", "name": "SearchingForShapes", "author": "kvick", "description": "Used this as a way to search for a nice background graphic for a painting I did here: https://www.artstation.com/artwork/nQ5d6O", "tags": ["color"], "likes": 0, "viewed": 35, "published": "Public", "date": "1593964062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tvec2 st = uv;\n    \n    st.x += sin(st.y * 10.0) * 0.5 + 0.5;\n    \n    st.x -= 0.5;\n    st.x /= (((1.0 - uv.y) - 0.5) * 2.0) * 5.0;\n    \n    \n    vec2 vz = st;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 pink = vec3(0.7, 0.2, 0.3) * 1.3;\n    vec3 blu = vec3(0.23, 0.29, 0.31) * 1.0;\n    \n    const float samples = 5.0;\n    st.x = st.x * samples;\n    float index = floor(st.x);\n    st.x = mod(st.x, 1.0);\n    \n    st.x -= 0.5;\n    st.x *= 2.5;\n    st.x += sin(st.y * 5.0 + (index * 2.0 + iTime)) * 0.5 + 0.5;\n    \n    col = mix(pink, blu, st.x);\n    \n    vz.x = floor(mod(vz.x * 100.0, 2.0));\n    col *= vec3(vz.x);\n\t\n    vec3 gradient = pink * pow((1.0 - abs(uv.y * 2.0 - 1.0)), 2.0);\n    col = max(col, gradient);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtt3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 930]], "test": "valid"}
{"id": "wtXfRH", "name": "Bandlimited Synthesis 2", "author": "iq", "description": "A way to prevent aliasing of cosine functions (the color palette in this case) by analytically integrating them. Move the mouse to compare naive versus filtered cos(x). More info [url]https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm[/url]", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 77, "viewed": 2349, "published": "Public API", "date": "1595968982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nbool mode;\n\nvec3 fcos( vec3 x )\n{\n    if( mode) return cos(x);                // naive\n\n    vec3 w = fwidth(x);\n    #if 0\n    return cos(x) * sin(0.5*w)/(0.5*w);     // filtered-exact\n\t#else\n    return cos(x) * smoothstep(6.28,0.0,w); // filtered-approx\n\t#endif  \n}\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.09*fcos(6.28318*t*  9.1+vec3(0.2,0.8,1.4));\n    col += 0.08*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.07*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.06*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.06*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.09*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvec2 deform( in vec2 p )\n{\n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    p.x += iTime*0.1;\n    \n    // deform 2\n    p += 0.2*cos( 1.5*p.yx + 0.03*1.0*iTime + vec2(0.1,1.1) );\n    p += 0.2*cos( 2.4*p.yx + 0.03*1.6*iTime + vec2(4.5,2.6) );\n    p += 0.2*cos( 3.3*p.yx + 0.03*1.2*iTime + vec2(3.2,3.4) );\n    p += 0.2*cos( 4.2*p.yx + 0.03*1.7*iTime + vec2(1.8,5.2) );\n    p += 0.2*cos( 9.1*p.yx + 0.03*1.1*iTime + vec2(6.3,3.9) );\n    \n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 w = p;\n    \n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (w.x-th<0.0);\n\n    // deformation\n    p = deform( p );\n\n    // base color pattern\n    vec3 col = getColor( 0.5*length(p) );\n    \n    // lighting\n    col *= 1.4 - 0.14/length(w);\n\n    // separation\n    col *= smoothstep(0.005,0.010,abs(w.x-th));\n    \n    // palette\n    if( w.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n \n    // output\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfRH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1875, 1875, 1896, 1896, 2128], [2130, 2130, 2159, 2159, 2724], [2726, 2726, 2752, 2768, 3186], [3188, 3188, 3244, 3263, 3845]], "test": "valid"}
{"id": "WtXfz4", "name": "Tweaked band limited synthesis", "author": "Mipmap", "description": "Tweak of Band Limited Synthesis 2 https://www.shadertoy.com/view/wtXfRH by Inigo Quilez", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 6, "viewed": 276, "published": "Public API", "date": "1596078529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweak of Band Limited Synthesis 2 https://www.shadertoy.com/view/wtXfRH by Inigo Quilez\n\n// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    #if 0\n    return cos(x) * sin(0.5*w)/(0.5*w);     // filtered-exact\n\t#else\n    return cos(x) * smoothstep(8.28,0.0,w); // filtered-approx\n\t#endif  \n}\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 w = p;\n    \n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    vec2 q = p;\n    p.x += iTime*0.1;\n    \n    // deform 2\n    p += 0.2*sin( 1.5*p.yx + 0.03*1.0*iTime + vec2(0.1,1.1) );\n\tp += 0.2*cos( 2.4*p.yx + 0.03*1.6*iTime + vec2(4.5,2.6) );\n\tp += 0.2*sin( 3.3*p.yx + 0.03*1.2*iTime + vec2(3.2,3.4) );\n\tp += 0.2*cos( 4.2*p.yx + 0.03*1.7*iTime + vec2(1.8,5.2) );\n\tp += 0.2*sin( 9.1*p.yx + 0.03*1.1*iTime + vec2(6.3,3.9) );\n\n    // base color pattern\n    vec3 col = getColor( 0.4*length(p) );\n    \n    // lighting\n    col *= 1.4 - 0.07*length(q);\n \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfz4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1956, 1956, 1977, 1977, 2155], [2157, 2157, 2186, 2186, 2694], [2696, 2696, 2752, 2771, 3426]], "test": "valid"}
{"id": "Wty3D3", "name": "Sinewaves", "author": "Omega", "description": "Sinewaves", "tags": ["waves", "sine"], "likes": 1, "viewed": 82, "published": "Public", "date": "1593706523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float image(vec2 uv, float offset)\n{\n    float time = iTime * 4.;\n    float y = sin(uv.x * 40. + time) + sin(uv.x * 20. + time);\n    y *= pow(1. - abs(uv.x), 3.) * 0.7;\n    return abs(uv.y * 8. - y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tfloat c = image(uv + vec2(0.,0.),0.) + abs(uv.x * 1.5);\n\n    fragColor = vec4(0.,1.-c,1.-c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 201], [203, 203, 259, 259, 452]], "test": "valid"}
{"id": "Xs3cDM", "name": "Learning Fractal Ray Tracing", "author": "deliaev", "description": "Learning Fractal Ray Tracing", "tags": ["raytracing", "fractal"], "likes": 2, "viewed": 41, "published": "Public", "date": "1595439584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(9999.0,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,9999.0,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,9999.0));\n  return min(da,min(db,dc));\n}\nvec3 map( in vec3 p )\n{\n   float d = sdBox(p,vec3(1.0));\n   vec3 res = vec3( d, 1.0, 0.0);\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0 );\n       }\n   }\n\n   return res;\n}\nvec3 intersect( in vec3 ro, in vec3 rd ) //RAY TRACING ALGO\n{\n    for(float t=0.0; t<10.0; )\n    {\n        vec3 h = map(ro + rd*t); //vec3 dist = sceneSDF(eye + depth * viewRayDirection);\n        if( h.x<0.001 ) \t\t\t//if dist.x < EPSILON\n            return vec3(t,h.yz);\t//return depth\n        t += h.x;\t\t\t\t//viewRay += \"safe distance\"\n    }\n    return vec3(-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // CAMERA\n    //ray origin\n    vec3 ro = 2.1*vec3(2.5*sin(0.25*ctime),1.0+1.0*cos(ctime*.13),2.5*cos(0.25*ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    //ray direction\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    vec3 col = intersect( ro, rd );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3cDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [119, 119, 147, 147, 322], [323, 323, 346, 346, 828], [829, 829, 890, 890, 1194], [1196, 1196, 1253, 1253, 1780]], "test": "valid"}
