{"id": "4dfXDn", "name": "2d signed distance functions", "author": "Maarten", "description": "test stuff for signed distance fields, just a playground\nupdate: added early out in shadow, made min step larger (1 instead of 0.5), made step equal to distance instead of half distance\nthis allows fewer steps without light bleeding", "tags": ["2d", "shadow", "distance", "occlusion", "penumbra", "ambient", "soft", "signed"], "likes": 378, "viewed": 17259, "published": "Public", "date": "1439840550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\n\tHi all,\n\n\tThis is just my playground for a bunch of 2D stuff:\n\n\tSome distance functions and blend functions\n\tCone marched 2D Soft shadows\n\tUse the mouse to control the 3rd light\n\n*/\n\n\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\n\nfloat sceneDist(vec2 p)\n{\n\tfloat c = circleDist(\t\ttranslate(p, vec2(100, 250)), 40.0);\n\tfloat b1 =  boxDist(\t\ttranslate(p, vec2(200, 250)), vec2(40, 40), \t0.0);\n\tfloat b2 =  boxDist(\t\ttranslate(p, vec2(300, 250)), vec2(40, 40), \t10.0);\n\tfloat l = lineDist(\t\t\tp, \t\t\t vec2(370, 220),  vec2(430, 280),\t10.0);\n\tfloat t1 = triangleDist(\ttranslate(p, vec2(500, 210)), 80.0, \t\t\t80.0);\n\tfloat t2 = triangleDist(\trotateCW(translate(p, vec2(600, 250)), iTime), 40.0);\n\t\n\tfloat m = \tmerge(c, b1);\n\tm = \t\tmerge(m, b2);\n\tm = \t\tmerge(m, l);\n\tm = \t\tmerge(m, t1);\n\tm = \t\tmerge(m, t2);\n\t\n\tfloat b3 = boxDist(\t\ttranslate(p, vec2(100, sin(iTime * 3.0 + 1.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c2 = circleDist(\ttranslate(p, vec2(100, 100)),\t30.0);\n\tfloat s = substract(b3, c2);\n\t\n\tfloat b4 = boxDist(\t\ttranslate(p, vec2(200, sin(iTime * 3.0 + 2.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c3 = circleDist(\ttranslate(p, vec2(200, 100)), \t30.0);\n\tfloat i = intersect(b4, c3);\n\t\n\tfloat b5 = boxDist(\t\ttranslate(p, vec2(300, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c4 = circleDist(\ttranslate(p, vec2(300, 100)), \t30.0);\n\tfloat a = merge(b5, c4);\n\t\n\tfloat b6 = boxDist(\t\ttranslate(p, vec2(400, 100)),\tvec2(40, 15), \t0.0);\n\tfloat c5 = circleDist(\ttranslate(p, vec2(400, 100)), \t30.0);\n\tfloat sm = smoothMerge(b6, c5, 10.0);\n\t\n\tfloat sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);\n    \n    float b7 = boxDist(\t\ttranslate(p, vec2(600, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), \n\t\t\t\t\t   \t\tvec2(40, 15), \t0.0);\n\tfloat c6 = circleDist(\ttranslate(p, vec2(600, 100)), \t30.0);\n\tfloat e = mergeExclude(b7, c6);\n    \n\tm = merge(m, s);\n\tm = merge(m, i);\n\tm = merge(m, a);\n\tm = merge(m, sm);\n\tm = merge(m, sc);\n    m = merge(m, e);\n\t\n\treturn m;\n}\n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\nfloat shadow(vec2 p, vec2 pos, float radius)\n{\n\tvec2 dir = normalize(pos - p);\n\tfloat dl = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * dl;\n\t\n\t// distance traveled\n\tfloat dt = 0.01;\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\t\t\t\t\n\t\t// distance to scene at current position\n\t\tfloat sd = sceneDist(p + dir * dt);\n\n        // early out when this ray is guaranteed to be full shadow\n        if (sd < -radius) \n            return 0.0;\n        \n\t\t// width of cone-overlap at light\n\t\t// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage\n\t\t// should be '(sd / dt) * dl', but '*dl' outside of loop\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(1.0, abs(sd));\n\t\tif (dt > dl) break;\n\t}\n\n\t// multiply by dl to get the real projected overlap (moved out of loop)\n\t// add one radius, before between -radius and + radius\n\t// normalize to 1 ( / 2*radius)\n\tlf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\treturn lf;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, pos, radius);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (shad * fall + source) * color;\n}\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p);\n\t\n\tvec2 light1Pos = iMouse.xy;\n\tvec4 light1Col = vec4(0.75, 1.0, 0.5, 1.0);\n\tsetLuminance(light1Col, 0.4);\n\t\n\tvec2 light2Pos = vec2(iResolution.x * (sin(iTime + 3.1415) + 1.2) / 2.4, 175.0);\n\tvec4 light2Col = vec4(1.0, 0.75, 0.5, 1.0);\n\tsetLuminance(light2Col, 0.5);\n\t\n\tvec2 light3Pos = vec2(iResolution.x * (sin(iTime) + 1.2) / 2.4, 340.0);\n\tvec4 light3Col = vec4(0.5, 0.75, 1.0, 1.0);\n\tsetLuminance(light3Col, 0.6);\n\t\n\t// gradient\n\tvec4 col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(c - p)/iResolution.x);\n\t// grid\n\tcol *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n\t// ambient occlusion\n\tcol *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\tcol += drawLight(p, light1Pos, light1Col, dist, 150.0, 6.0);\n\tcol += drawLight(p, light2Pos, light2Col, dist, 200.0, 8.0);\n\tcol += drawLight(p, light3Pos, light3Col, dist, 300.0, 12.0);\n\t// shape fill\n\tcol = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t// shape outline\n\tcol = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 1.5));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfXDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 310, 358, 358, 459], [462, 462, 495, 495, 518], [521, 521, 561, 561, 604], [607, 607, 644, 644, 668], [671, 671, 708, 708, 731], [734, 829, 862, 862, 929], [932, 932, 964, 964, 1030], [1033, 1033, 1065, 1065, 1082], [1085, 1180, 1212, 1212, 1319], [1322, 1322, 1362, 1362, 1392], [1395, 1395, 1437, 1437, 1519], [1522, 1522, 1577, 1577, 1686], [1689, 1689, 1759, 1759, 1871], [1874, 1874, 1922, 1922, 2038], [2041, 2041, 2100, 2100, 2288], [2291, 2365, 2393, 2393, 2427], [2430, 2430, 2478, 2494, 2607], [2610, 2610, 2658, 2674, 2787], [2790, 2840, 2865, 2865, 4646], [4649, 4649, 4685, 4685, 4895], [4898, 4969, 5015, 5015, 6021], [6025, 6025, 6110, 6132, 6424], [6427, 6427, 6454, 6454, 6514], [6517, 6517, 6563, 6563, 6602], [6605, 6605, 6666, 6666, 6834], [6837, 6893, 6950, 6950, 8179]], "test": "untested"}
{"id": "4lfSWl", "name": "Animated-Static", "author": "smilingrob", "description": "A noise function that shows some mildly interesting animations in the lower left.  But otherwise appears like TV static.\ne isn't necessary, it could also be 2.001 or many other numbers.", "tags": ["noise"], "likes": 10, "viewed": 2208, "published": "Public API", "date": "1440375195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float e = 2.7182818284590452353602874713527;\n\nvec4 noise(vec2 texCoord)\n{\n    float G = e + (iTime * 0.1);\n    vec2 r = (G * sin(G * texCoord.xy));\n    return vec4(fract(r.x * r.y * (1.0 + texCoord.x)));\n}\n\n\nvoid mainImage(out vec4 o, vec2 texCoord)\n{\n    o = noise(texCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 79, 79, 211], [214, 214, 257, 257, 284]], "test": "untested"}
{"id": "4lfSzf", "name": "strange tendrils", "author": "netgrind", "description": "spooky", "tags": ["raytrace", "grey", "spooky", "tendrils"], "likes": 5, "viewed": 1429, "published": "Public API", "date": "1438384265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//By Cale Bradbury, 2015\n\n//how many itterations of the fractal\n#define LOOPS 10.0\n\n#define BOX\n//uncomment the line below to make shit magical\n//#define COLOR\n\n//fuck yeah, mirror that shit\n#define MIRROR\n\n// Base ray trace code via https://www.shadertoy.com/view/Xds3zN by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat qbox( vec3 p, float s ){\n  return length(max(abs(p)-vec3(s,s,s),0.0));\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y,uv.x)+spin;\n\tfloat d = length(uv)*1.4;\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nfloat f(vec3 pos, float size, float cur){\n    return smin(cur,sphere(pos,size), .15);\n}\n#define pi 3.14158\n\nvec2 map( in vec3 pos )\n{\n    pos =(opRep(pos,vec3(3.,3.,3.)));\n   pos.xy = kale(pos.xy,pi/6.,pi*1.4+cos(iTime)*.1,0.);\n    pos.xz = kale(pos.xz,pi/6.,pi*1.4+sin(iTime)*.1,0.);\n    \n    float size = .5;\n    float r = f(pos,size,1.);  \n    \n    for(float i = 0.; i<LOOPS;i++){\n        pos+=vec3(size*(sin(iTime)*.5+1.5),0.,0.);\n        size*=(cos(iTime*2.)*.3+.5);\n        r = f(pos,size,r);\n    }\n    return vec2(r,1.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<30; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, float c )\n{ \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 col = vec3(c);\n    if( m>-.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.5, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.5, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.5,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.5, 1.0 ),16.0);\n        \n       dif *= softshadow( pos, lig, 0.01, .5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif;\n\t\tbrdf += 1.20*spe*dif;\n        brdf += 0.30*amb*occ;\n        brdf += 0.40*dom*occ;\n        brdf += 0.30*bac*occ;\n        brdf += 0.40*fre*occ;\n\t\t//brdf += 0.02;\n\t\tcol = brdf;\n        col*=(1.0-res.x*.11);\n        \n    \t//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    #ifdef MIRROR\n    p.x = -abs(p.x);\n    #endif\n\t\t \n\tfloat time = 15.0 + iTime*.5;\n\tfloat camDist = 5.;\n\t// camera\t\n\tvec3 ro = vec3(cos(time)*camDist,0.,sin(time)*camDist);\n    //vec3( -0.5+camDist*cos(0.1*time), 5.0, 0.5 + camDist*sin(0.1*time) );\n\tvec3 ta = vec3( -0.001, -0., -0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, time );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    float bg =  q.y*.2+.1;\n    // render\t\n    vec3 col = render( ro, rd,bg );\n    col = vec3(mix(col.r,bg,1.0-col.r));\n\n    col *= 1.-length((q*2.-1.))*.3;\n    #ifdef COLOR\n    col = sin(col*vec3(10.,6.,15.)*(sin(time*.35)*.5+2.)+time)*.5+.5;\n    #endif\n    \n\tcol = pow( col, vec3(1.2545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 386, 419, 419, 445], [447, 447, 477, 477, 510], [512, 512, 542, 542, 571], [573, 573, 614, 614, 707], [709, 709, 741, 741, 765], [767, 767, 797, 797, 845], [847, 847, 875, 875, 971], [973, 973, 1030, 1030, 1195], [1197, 1197, 1238, 1238, 1284], [1305, 1305, 1330, 1330, 1727], [1729, 1729, 1769, 1769, 2355], [2357, 2357, 2431, 2431, 2691], [2693, 2693, 2725, 2725, 2946], [2948, 2948, 2990, 2990, 3289], [3291, 3291, 3339, 3339, 4570], [4572, 4572, 4624, 4624, 4801], [4803, 4803, 4860, 4860, 5726]], "test": "untested"}
{"id": "4lfXWj", "name": "P_Malin's delorean modeling", "author": "yasuo", "description": "Mr. P_Malin's delorean modeling is so simple and It's good to start to learn modeling by code.\nBelow is original one, so Amazing and great work.\nhttps://www.shadertoy.com/view/MlsSzf\n", "tags": ["studymodelingbyraymarching"], "likes": 5, "viewed": 235, "published": "Public", "date": "1439576301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\nfloat pi = 3.14159265359;\n\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 mapFloor ( vec3 pos )\n{\n    vec4 ret = vec4(0.1,0.1,0.1,1.0);\n    ret.w = pos.y;\n    return ret;\n}\n\n/* Mr. P_Malin's delorean modeling https://www.shadertoy.com/view/MlsSzf */\nfloat PlaneDist( const in vec3 vPos, const in vec4 vPlane )\n{\n    return dot(vPlane.xyz, vPos) - vPlane.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat CarBodyMin( float a, float b )\n{\n    return smin(a, b, 0.03);\n}\n\nfloat CarBodyMax( float a, float b )\n{\n    return -CarBodyMin(-a, -b);\n}\n\nfloat CarBodyDisance(vec3 _vPos )\n{\n    vec3 vCarPos = _vPos;\n\n    vec3 vBodyPos = vCarPos;\n    vBodyPos.x = abs(vBodyPos.x);\n\n    float distBonnet0 = PlaneDist(vBodyPos, vec4( -0.005687, 0.994044, 0.108829, 0.891393 ) );\n    float distRoof0 = PlaneDist(vBodyPos, vec4( 0.004004, 0.999946, 0.009596, 1.124596 ) );\n    float distFrontWindow0 = PlaneDist(vBodyPos, vec4( -0.002180, 0.918728, 0.394886, 1.033900 ) );\n    float distDoorWindow0 = PlaneDist(vBodyPos, vec4( 0.765404, 0.643545, -0.002593, 1.145616 ) );\n    float distSmallWindow0 = PlaneDist(vBodyPos, vec4( 0.760709, 0.645945, -0.063856, 1.201365 ) );\n    float distDoorUpper0 = PlaneDist(vBodyPos, vec4( 0.945737, 0.324923, -0.002605, 1.045727 ) );\n    float distDoorLower0 = PlaneDist(vBodyPos, vec4( 0.985543, -0.169304, 0.006400, 0.805219 ) );\n    float distFront0 = PlaneDist(vBodyPos, vec4( 0.001169, 0.393724, 0.919228, 2.167077 ) );\n    float distBase0 = PlaneDist(vBodyPos, vec4( -0.002855, -0.999987, 0.004094, -0.132802 ) );\n    float distRearWindow0 = PlaneDist(vBodyPos, vec4( 0.001012, 0.976084, -0.217392, 1.302470 ) );\n    float distRear0 = PlaneDist(vBodyPos, vec4( -0.000983, 0.100691, -0.994917, 2.116753 ) );\n    float distFrontBase0 = PlaneDist(vBodyPos, vec4( 0.000408, -0.940669, 0.339326, 0.348749 ) );\n    float distRearBase0 = PlaneDist(vBodyPos, vec4( 0.120237, -0.941372, -0.315218, 0.256832 ) );\n    float distTopRearPanel0 = PlaneDist(vBodyPos, vec4( 0.909642, 0.405237, -0.091298, 1.161221 ) );\n    float distBottomRearPanel0 = PlaneDist(vBodyPos, vec4( 0.974792, -0.205007, -0.088053, 0.849642 ) );\n\n    float topCurveX = abs(vBodyPos.x);\n    topCurveX = topCurveX * topCurveX;\n    distBonnet0 += topCurveX * 0.05;\n    distRoof0 += topCurveX * 0.1;\n    distFrontWindow0 += topCurveX * 0.01;\n    distRearWindow0 += topCurveX * 0.01;\n\n    float topCurveZ = abs(vBodyPos.z);\n    topCurveZ = topCurveZ * topCurveZ;\n    distRoof0 += topCurveZ * 0.05;\n\n    float result = -100000.0;\n\n    result = CarBodyMax( result, distRoof0 );\n    result = CarBodyMax( result, distDoorWindow0 );\n    result = CarBodyMax( result, distSmallWindow0 );\n    result = CarBodyMax( result, distDoorUpper0 );\n    result = CarBodyMax( result, distDoorLower0 );\n    result = CarBodyMax( result, distFront0 );\n    result = CarBodyMax( result, distBase0 );\n    result = CarBodyMax( result, distRearWindow0 );\n    result = CarBodyMax( result, distRear0 );\n    result = CarBodyMax( result, distFrontBase0 );\n    result = CarBodyMax( result, distRearBase0 );\n    result = CarBodyMax( result, distTopRearPanel0 );\n    result = CarBodyMax( result, distBottomRearPanel0 );\n\n    float distBonnetWindow = CarBodyMin(distBonnet0, distFrontWindow0);    \n    result = CarBodyMax( result, distBonnetWindow );\n\n    return result;\n}\n/* Mr. P_Malin's delorean modeling https://www.shadertoy.com/view/MlsSzf */\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n    vec4 val1 = mapFloor( q.xyz );\n\n    vec4 newCarPos = vec4(q.xyz + vec3( 0, -1, 0 ),1)*matRotateY(180.0*pi/180.0);\n    vec4 val2 = vec4(0.5,0.5,0.5,CarBodyDisance(newCarPos.xyz ));\n\n    vec4 val4 = combine ( val1, val2 );\n    return val4;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    position -= .5;\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x / iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 2.5, 44.0);\n    mat4 m = matRotateY(time);\n\n    vec4 result;\n    for (int i =0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    if ( pos.z> 100. )\n    {\n        // bg\n        col = vec3(0);\n    }\n    else\n    {\n        // shade\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n\n        col += vec3(result.xyz) ;\n    }\n\n    fragColor = vec4( col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 108, 108, 271], [273, 273, 301, 301, 465], [467, 467, 495, 495, 644], [646, 646, 683, 683, 742], [744, 744, 772, 772, 847], [849, 925, 986, 986, 1033], [1035, 1035, 1076, 1076, 1169], [1171, 1171, 1209, 1209, 1240], [1242, 1242, 1280, 1280, 1314], [1316, 1316, 1351, 1351, 4094], [4095, 4172, 4201, 4201, 4491], [4493, 4493, 4520, 4520, 4614], [4616, 4616, 4673, 4673, 5867]], "test": "untested"}
{"id": "4lfXWS", "name": "[SIG15] portal", "author": "the23", "description": "portal. such a great game. even in 2D.\n\nI wish I had the time to add the proper companion cube...", "tags": ["portal", "sig15", "shaderofgame"], "likes": 15, "viewed": 442, "published": "Public", "date": "1439208874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AltFakeAO 1\n\nconst vec2 g = vec2(0.0, -0.981);\nconst float sqrt2 = 1.414213562;\n\nconst float speed = 2.542;\nconst vec2 bot = vec2(-1.5,-1);\nconst vec2 top = vec2(1.5,1);\n\nconst float logoRad1 = 0.4;\nconst float logoRad2 = 0.9;\nconst vec3 logoColor = vec3(0.0);//vec3(0.09803, 0.607843, 0.988235);\n\nconst float slitWidth = 0.05;\nconst float slitShift = 0.185;\nconst float slitLength = 0.4;\n\nconst float portalStretchFactor = 5.0;\nconst float portalRadIn = 0.35;\nconst float portalRadOut = 0.4;\nconst float portalBlendHalf = 0.2;\n\nconst vec2 portalPosExit1  = vec2(-1.3,  0.5);\nconst vec2 portalPosEnter1 = vec2(-0.3, -0.7);\nconst vec2 portalPosExit2  = vec2( 0.3, -0.7);\nconst vec2 portalPosEnter2 = vec2( 1.3,  0.5);\n\nconst vec3 portalColorEnter = vec3(1.0, 0.5, 0.0);\nconst vec3 portalColorExit = vec3(0.0, 0.7, 1.0);\n\nconst vec3 stickManColor = vec3(1.3);\nconst float stickManInvSize = 4.0;\nconst vec3 dropShadowColor = vec3(0.3);\nconst vec2 dropShadowOffset = vec2(0.01, -0.01);\n\nconst vec3 wallColor = vec3(0.8);\nconst vec3 fakeAOColor = vec3(0.7);\n\nfloat slits(vec2 pos)\n{\n    float aaf = length(fwidth(pos));\n    float tmp1 = smoothstep(slitWidth - aaf, slitWidth, length(pos.y - slitLength) + (1.0 - float(pos.x < slitShift)));\n    float tmp2 = smoothstep(slitWidth - aaf, slitWidth, length(pos.x - slitLength) + (1.0 - float(pos.y > -slitShift)));\n    float tmp3 = smoothstep(slitWidth * sqrt2 - aaf, slitWidth * sqrt2, length((pos.x - pos.y) - slitLength * sqrt2) + (1.0 - float(pos.x > slitShift)));\n    float tmp4 = smoothstep(slitWidth * sqrt2 - aaf, slitWidth * sqrt2, length((pos.x + pos.y) - slitLength * sqrt2) + (1.0 - float(pos.y > slitShift)));\n\n    return tmp4 * tmp3 * tmp2 * tmp1;\n}\n\nvec3 drawCirc(vec3 col, vec2 coord, vec2 pos, float rad, vec3 oldColor)\n{\n    float dst = distance(coord, pos);\n    return mix(oldColor, col, 1.0 - smoothstep(rad - fwidth(dst), rad, dst));\n}\n\nvec3 drawDisc(vec3 col, vec2 coord, vec2 pos, float radIn, float radOut, vec3 oldColor)\n{\n    float dst = distance(coord, pos);\n    float aaf = fwidth(dst);\n    return mix(oldColor, col, (smoothstep(radIn - aaf, radIn, dst) * (1.0 - smoothstep(radOut - aaf, radOut, dst))));\n}\n\nvec3 drawLine(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness, vec3 oldColor)\n{\n    float d = dot(coord - p1, p2 - p1) / length(p2 - p1);\n    d /= length(p2 - p1);\n    d = clamp(step(0.0, d) * d, 0.0, 1.0);\n    d = distance(p1 + d * (p2 - p1), coord);\n    \n    float dst = smoothstep(thickness - length(fwidth(coord)), thickness, d);\n\n    return mix(col, oldColor, dst);\n}\n\nvec3 drawLineFade(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness, vec3 oldColor)\n{\n    // this didn't work for some reason on my my Macbook, but on my iMac...\n    if (AltFakeAO == 0)\n    {\n    float d = dot(coord - p1, p2 - p1) / length(p2 - p1);\n    d /= length(p2 - p1);\n    d = clamp(step(0.0, d) * d, 0.0, 1.0);\n    d = distance(p1 + d * (p2 - p1), coord);\n    \n    return mix(col, oldColor, clamp(0.0, 1.0, d / thickness));\n    }\n    else\n    {\n    float aaf = length(fwidth(coord));\n    vec3 blendedCol = mix(col, oldColor, 0.66);\n    float blendedLen = aaf * 3.0;\n    vec3 color = drawLine(blendedCol, coord, p1, p2, blendedLen, oldColor);\n\n    blendedCol = mix(col, oldColor, 0.33);\n    blendedLen = aaf * 2.0;\n    color = drawLine(blendedCol, coord, p1, p2, blendedLen, color);\n\n    blendedCol = col;//mix(col, oldColor, 0.0);\n    blendedLen = aaf;// * 1.0;\n    color = drawLine(blendedCol, coord, p1, p2, blendedLen, color);\n\n    return color;\n    }\n}\n\nfloat cross2D(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec3 drawQuad(vec3 col, vec2 coord, vec2 p1, vec2 p2, vec2 p3, vec2 p4, float thickness, vec3 oldColor)\n{\n    float sideA = sign(cross2D(coord - p1, p2 - p1));\n    float sideB = sign(cross2D(coord - p2, p3 - p2));\n    float sideC = sign(cross2D(coord - p3, p4 - p3));\n    float sideD = sign(cross2D(coord - p4, p1 - p4));\n    float dst = abs(sideA - sideB) + abs(sideB - sideC) + abs(sideC - sideD) + abs(sideD - sideA);\n    dst = clamp(dst, 0.0, 1.0);\n\n    vec3 res = mix(col, oldColor, dst);\n    res = drawLine(col, coord, p1, p2, thickness, res);\n    res = drawLine(col, coord, p2, p3, thickness, res);\n    res = drawLine(col, coord, p3, p4, thickness, res);\n    res = drawLine(col, coord, p4, p1, thickness, res);\n    return res;\n}\n\nvec3 drawHeart(vec2 coord, vec2 pos, float invScale, vec2 stretch, vec3 oldColor)\n{\n  // credits go to @iq - https://www.shadertoy.com/view/XsfGRn\n  vec2 coordinate = stretch * (coord - pos) * invScale;\n  float a = atan(coordinate.x,coordinate.y)/3.141593;\n  float r = length(coordinate);\n  float h = abs(a);\n  float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n  vec3 hcol = vec3(1.0,0.5*r,0.3);\n\n  float heartMask = smoothstep(0.0, fwidth(d-r), d-r);\n\n  return mix(oldColor, hcol, heartMask);\n}\n\nvec3 apertureLogo(vec2 coord, vec2 pos, float invScale, vec3 oldColor)\n{\n    float rad = distance(coord, pos) * invScale;\n    float insideRing = step(logoRad1, rad) * (1.0 - smoothstep(logoRad2-fwidth(rad), logoRad2, rad));\n    float logo = slits((coord - pos) * invScale) * slits((-coord + pos) * invScale) * insideRing;\n    return mix(oldColor, logoColor, logo);\n}\n\nvec3 stickman(vec2 coord, vec2 pos, vec3 col, float invScale, bool upsideDown, vec3 oldColor)\n{\n    float rad = 0.06;\n\n    vec2 armL = vec2(0.3, 0.44);\n    vec2 armL2 = vec2(0.6, 0.55);\n    vec2 armL3 = vec2(0.7, 0.3);\n\n    vec2 armR = vec2(0.02, 0.32);\n    vec2 armR2 = vec2(-0.15, 0.1);\n    vec2 armR3 = vec2(-0.4, -0.0);\n\n    vec2 legL = vec2(0.5, -0.05);\n    vec2 legL2 = vec2(0.65, -0.4);\n    vec2 legL3 = vec2(0.8, -0.1);\n\n    vec2 legR = vec2(0.22, -0.18);\n    vec2 legR2 = vec2(0.1, -0.5);\n    vec2 legR3 = vec2(0.23, -0.75);\n\n    vec2 scaleCoord = (coord - pos) * invScale;\n    scaleCoord.x *= -1.0;\n\n    if (upsideDown)\n    {\n        scaleCoord.y *= -1.0;      \n    }\n\n    vec3 res = oldColor;\n    res = drawCirc(col, scaleCoord, vec2(0.0, 0.7), 0.18, res);\n\n    //arm left\n    res = drawLine(col, scaleCoord, armL, armL2, rad, res);\n    res = drawLine(col, scaleCoord, armL2, armL3, rad, res);\n    //arm right\n    res = drawLine(col, scaleCoord, armR, armR2, rad, res);\n    res = drawLine(col, scaleCoord, armR2, armR3, rad, res);\n    //leg left\n    res = drawLine(col, scaleCoord, legL, legL2, rad, res);\n    res = drawLine(col, scaleCoord, legL2, legL3, rad, res);\n    //leg right\n    res = drawLine(col, scaleCoord, legR, legR2, rad, res);\n    res = drawLine(col, scaleCoord, legR2, legR3, rad, res);\n\n    //torso\n    res = drawQuad(col, scaleCoord, armL, armR, legR, legL, rad, res);\n\n    //cut-off @ portals - dirty!\n    if ((coord.x < portalPosExit1.x) || (coord.x > portalPosEnter2.x)\n      || (coord.y < portalPosExit2.y) || (coord.y < portalPosEnter1.y))\n    {\n        res = oldColor;\n    } \n    return res;\n}\n\nvec3 portal(bool jumpIn, vec2 coord, vec2 pos, bool alongX, vec3 oldColor)\n{\n    vec2 stretch = alongX ? vec2(1.0, portalStretchFactor) : vec2(portalStretchFactor, 1.0);\n    stretch *= 1.4;\n\n    vec3 col = jumpIn ? portalColorEnter : portalColorExit;\n    return drawDisc(col, (coord - pos) * stretch, vec2(0.0), portalRadIn, portalRadOut, oldColor);\n}\n\nvec3 blendPortals(vec3 portal1, vec3 portal2, float time1, float time2, float time)\n{\n    float blender = smoothstep(time1 - portalBlendHalf, time1 + portalBlendHalf, time) \n                  - smoothstep(time2 - portalBlendHalf, time2 + portalBlendHalf, time);\n    return mix(portal1, portal2, blender);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float durationTotal = 2.92;\n    float durationHalf = 1.55;\n    float tick = iTime * speed;\n    float time = mod(tick, durationTotal);\n    bool evenTurn = mod(floor(tick / durationTotal), 2.0) > 0.0;\n    vec3 color = vec3(0.0);\n\n    vec2 area = top - bot;\n    float ratioScreen = iResolution.x/ iResolution.y;\n    float ratioArea = area.x / area.y;\n    vec2 padding = vec2(ratioScreen / ratioArea, ratioArea /ratioScreen);\n    padding = max(vec2(0.0), area * padding - area);\n    vec2 coord = uv * (area + padding) + bot - (padding * 0.5);\n\n    //background\n    //color = vec3(1.0 - smoothstep(0.6, 1.3, abs(coord.y))) * 0.4 * (smoothstep(2.0, 1.4, abs(coord.x))) + 0.1;\n    color = drawQuad(wallColor, coord, vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(0.5, -0.5), vec2(-0.5), 0.01, color);\n\n    color = drawQuad(wallColor, coord, vec2(-1.5, 1.0), vec2(-1.5, 0.0), vec2(-1.1, 0.2), vec2(-1.1, 0.8), 0.01, color);\n\n    color = drawQuad(wallColor, coord, vec2(-1.1, 0.2), vec2(-1.1, 0.8), vec2(-0.5, 0.8), vec2(-0.5, 0.2), 0.01, color);\n    color = drawQuad(wallColor, coord, vec2(-0.5, 0.8), vec2(-0.5, -0.5), vec2(0.5, -0.5), vec2(0.5, 0.8), 0.01, color);\n    color = drawQuad(wallColor, coord, vec2(1.1, 0.2), vec2(1.1, 0.8), vec2(0.5, 0.8), vec2(0.5, 0.2), 0.01, color);\n\n    color = drawQuad(wallColor, coord, vec2(1.5, 1.0), vec2(1.5, 0.0), vec2(1.1, 0.2), vec2(1.1, 0.8), 0.01, color);\n\n    color = drawLineFade(fakeAOColor, coord, vec2(0.5, -0.5), vec2(-0.5), 0.02, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(-1.1, 0.2), vec2(-1.1, 0.8), 0.02, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(1.1, 0.2), vec2(1.1, 0.8), 0.02, color);\n\n    //combanion cube\n    vec3 cubeColor = vec3(0.85);\n    color = drawLineFade(fakeAOColor, coord, vec2(-0.15, -0.55), vec2(-0.15, -0.35), 0.03, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(0.15, -0.55), vec2(0.15, -0.35), 0.03, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(0.15, -0.35), vec2(0.0, -0.3), 0.03, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(-0.15, -0.35), vec2(0.0, -0.3), 0.03, color);\n\n    color = drawQuad(cubeColor, coord, vec2(0.0, -0.6), vec2(0.0, -0.4), vec2(-0.15, -0.35), vec2(-0.15, -0.55), 0.01, color);\n    color = drawQuad(cubeColor, coord, vec2(0.0, -0.6), vec2(0.0, -0.4), vec2(0.15, -0.35), vec2(0.15, -0.55), 0.01, color);\n    color = drawQuad(cubeColor, coord, vec2(0.0, -0.4), vec2(-0.15, -0.35), vec2(0.0, -0.3), vec2(0.15, -0.35), 0.01, color);\n    \n    color = drawLineFade(fakeAOColor, coord, vec2(0.0, -0.6), vec2(-0.15, -0.55), 0.02, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(0.0, -0.6), vec2(0.15, -0.55), 0.02, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(0.0, -0.6), vec2(0.0, -0.4), 0.02, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(0.0, -0.4), vec2(-0.15, -0.35), 0.02, color);\n    color = drawLineFade(fakeAOColor, coord, vec2(0.0, -0.4), vec2(0.15, -0.35), 0.02, color);\n\n    color = drawHeart(coord, vec2(0.0, -0.33), 20.0, vec2(1.0, 1.5), color);\n    color = drawHeart(coord + vec2(0.0, coord.x * 0.25), vec2(-0.09, -0.47), 20.0, vec2(1.7, 1.0), color);\n    color = drawHeart(coord - vec2(0.0, coord.x * 0.25), vec2(0.09, -0.47), 20.0, vec2(1.7, 1.0), color);\n\n    //logo\n    color = apertureLogo(coord, vec2(0.0, 0.5), 3.5,  color);\n\n    //portals\n    vec3 portalExit1 = portal(false, coord, portalPosExit1, false, color);\n    vec3 portalExit2 = portal(false, coord, portalPosExit2, true, color);\n    color = blendPortals(portalExit1, portalExit2, 0.9, 2.3, time);\n\n    vec3 portalEnter1 = portal(true, coord, portalPosEnter1, true, color);\n    vec3 portalEnter2 = portal(true, coord, portalPosEnter2, false, color);\n    color = blendPortals(portalEnter2, portalEnter1, 0.3, 1.7, time);\n\n    vec2 start = vec2(-1.3, 0.5);\n    vec2 dir = vec2(0.70, 0.0);\n    bool upsideDown = evenTurn;\n\n    bool mirror1UpsideDown = !upsideDown;\n    bool mirror2UpsideDown = upsideDown;\n\n    vec2 pos = dir * time + 0.5 * g * time * time;\n\n    vec2 mirror1Pos = start + pos;\n    mirror1Pos.y = portalPosExit2.y - (mirror1Pos.y - portalPosExit2.y);\n    mirror1Pos.x += portalPosExit2.x - portalPosEnter1.x;\n\n    vec2 mirror2Pos = start + pos + portalPosEnter2 - portalPosExit1;\n\n    if (time > durationHalf)\n    {\n        time = time - durationHalf;\n        dir = vec2(0.74, 1.55);\n        start = portalPosExit2;\n        pos = dir * time + 0.5 * g * time * time;\n        upsideDown = !upsideDown;\n        mirror1Pos = start + pos - vec2(portalPosEnter2.x - portalPosExit1.x, 0.0);\n        mirror1UpsideDown = upsideDown;\n\n        mirror2UpsideDown = !upsideDown;\n\n        mirror2Pos = start + pos;\n        mirror2Pos.y = portalPosExit2.y - (mirror1Pos.y - portalPosExit2.y);\n        mirror2Pos.x -= portalPosExit2.x - portalPosEnter1.x;\n    }\n\n    // the main guy incl a little drop shadow :-)\n    color = stickman(coord, start + pos + dropShadowOffset, dropShadowColor, stickManInvSize, upsideDown, color);\n    color = stickman(coord, start + pos, stickManColor, stickManInvSize, upsideDown, color);\n    //mirror1 : show exit @ next portal\n    color = stickman(coord, mirror1Pos + dropShadowOffset, dropShadowColor, stickManInvSize, mirror1UpsideDown, color);\n    color = stickman(coord, mirror1Pos, stickManColor, stickManInvSize, mirror1UpsideDown, color);\n    //mirror2 : show enter @ previous portal\n    color = stickman(coord, mirror2Pos + dropShadowOffset, dropShadowColor, stickManInvSize, mirror2UpsideDown, color);\n    color = stickman(coord, mirror2Pos, stickManColor, stickManInvSize, mirror2UpsideDown, color);\n\n    fragColor.rgb = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 1062, 1085, 1085, 1712], [1714, 1714, 1787, 1787, 1905], [1907, 1907, 1996, 1996, 2183], [2185, 2185, 2272, 2272, 2565], [2567, 2567, 2658, 2734, 3537], [3539, 3539, 3570, 3570, 3606], [3608, 3608, 3713, 3713, 4343], [4345, 4345, 4428, 4491, 4846], [4848, 4848, 4920, 4920, 5214], [5216, 5216, 5311, 5311, 6845], [6847, 6847, 6923, 6923, 7198], [7200, 7200, 7285, 7285, 7506], [7508, 7508, 7565, 7565, 13246]], "test": "untested"}
{"id": "4ljXRR", "name": "Futuristic grid", "author": "Alexey", "description": "1/abs(tan)) experiment", "tags": ["2d", "grid", "animation"], "likes": 7, "viewed": 213, "published": "Public", "date": "1441039153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat hash (float v) {\n  return smoothstep(0.1, 0.9, abs(sin(v))) * 20.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\t\t\n    p.x *= iResolution.x / iResolution.y;\t\n    \t\n    vec3 col = vec3(0.2, 0.3, 0.4);\n    vec3 c = vec3(0.0);\t\n    c += col / (abs(tan(hash(p.x) + cos(iTime + p.y) + iMouse.y * 10.0))); \n    c += col / (abs(tan(hash(p.y) + cos(iTime + p.x) + iMouse.x * 10.0)));\n    c /= 5.0;\t\n\t\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 121], [123, 123, 180, 180, 565]], "test": "untested"}
{"id": "4llSRX", "name": "mandelbrot set123123", "author": "jnalanko", "description": "mandelbrot set", "tags": ["fractal"], "likes": 0, "viewed": 98, "published": "Public", "date": "1438541480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 complex_multiply(vec2 a, vec2 b){\n\treturn vec2(a.x*b.x - a.y * b.y, a.x * b.y + a.y * b.x);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    //uv *= vec2(1.0*sin(iTime)+1.2);\n    uv *= vec2(exp(-mod(iTime,24.0) * 0.3));\n    //uv *= vec2(3.0);\n    uv -= vec2(1.4,0);\n    //uv += vec2(cos(0.9*iTime)+0.4,sin(iTime)+0.4);\n    vec2 z = vec2(0,0);\n    for(int i = 0; i < 500; i++){\n   \t\tz = complex_multiply(z,z) + uv;\n        if(length(z) > 2.0) break;\n    }\n    if(length(z) > 2.0)\n        fragColor = vec4(0.5,0.5,0.5,1.0);\n    else\n        fragColor = vec4(0,0,0,0);\n    \n    //uv = abs(complex_multiply(uv,vec2(sin(iTime*2.0),cos(iTime*2.0))));\n\t//fragColor = vec4(uv*vec2(0.5),0.0,1.0);\n}\n\n// *sin(iTime)", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 101], [103, 103, 160, 160, 780]], "test": "untested"}
{"id": "4llSWj", "name": "Basic Main Sequence Star", "author": "martin", "description": "A star", "tags": ["star"], "likes": 7, "viewed": 221, "published": "Public", "date": "1439759023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on:\n// - https://www.shadertoy.com/view/4dXGR4\n// - https://www.shadertoy.com/view/lsf3RH\n\n//Tweakables\nconst float SIZE = 3.25;\nconst float CORONA_SCALE = 0.25;\nconst int CORONA_SAMPLES = 12;\nconst float CORONA_SAMPLE_STEP = 1.5;\nconst float ANIMTION_SPEED = 1.5;\n\nconst vec3 BASE_COLOR = vec3(1, 0.45, 0.15);\n\nconst float MIN_SPOT = 0.0;\nconst float MAX_SPOT = 1.0;\nconst float SPOT_INTENSITY = 0.55;\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1.0, 100.0, 1000.0);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res)) * s;\n\tvec3 uv1 = floor(mod(uv + vec3(1.0), res)) * s;\n\t\n\tvec3 f = fract(uv);\n    f = f * f * (3.0 - 2.0 * f);\n\n\tvec4 v = vec4(uv0.x + uv0.y + uv0.z, uv1.x + uv0.y + uv0.z,\n\t\t      \t  uv0.x + uv1.y + uv0.z, uv1.x + uv1.y + uv0.z);\n\n\tvec4 r = fract(sin(v * 0.1) * 1000.0);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z) * 0.1) * 1000.0);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z) * 2.0 - 1.0;\n}\n\nfloat body(in vec2 uv)\n{\n\tfloat brightness\t= 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\n\tfloat time\t\t= iTime * ANIMTION_SPEED * 0.1;\n\tfloat aspect\t= iResolution.x / iResolution.y;\n\tvec2 p \t\t\t= (-0.5 + uv);\n\t\n\tfloat dist\t\t= length(p);\n\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp *= (2.0 - brightness);\n  \tfloat r = dot(sp, sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n    return length(starSphere);\n}\n\nfloat corona(in vec2 p)\n{\n    //Calculate the color intensity of this pixel (based on distance from center)\n\tfloat color = (1.0 / CORONA_SCALE) * (SIZE - (length(6.0 * p)));\n\t\n    //Calculate polar coordinate\n\tvec3 coord = vec3(atan(p.x, p.y) / 6.2832, length(p) * 0.5, 0);\n    \n    //Offset coordinate by time for animation\n    coord += vec3(0.0, -iTime * (ANIMTION_SPEED / 150.0), iTime * (ANIMTION_SPEED / 750.0));\n\t\n    //Sum up samples\n\tfor(int i = 1; i <= CORONA_SAMPLES; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord, power * float(CORONA_SAMPLES) * CORONA_SAMPLE_STEP);\n\t}\n    \n    return max(color * CORONA_SCALE, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    //Correct for screen size and aspect ratio\n\tvec2 p = -0.5 + fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n    //Calculate the color intensity of this pixel (based on distance from center)\n\tfloat color = corona(p);\n    vec3 coronaColor = vec3(\n        clamp(color * BASE_COLOR.r, 0.0, 1.0),\n        clamp(pow(max(color, 0.0), 2.0) * BASE_COLOR.g, 0.0, 1.0),\n        clamp(pow(max(color, 0.0), 3.0) * BASE_COLOR.b, 0.0, 1.0)\n    );\n    \n    //Calculate spots on the star body\n    float spots = mix((1.0 - SPOT_INTENSITY), 1.0, clamp(1.0 - body(p + 0.5), 0.0, 1.0));\n    vec3 spotColor = vec3(\n        clamp(spots * 1.0 / (1.0 - BASE_COLOR.r), 0.0, 1.0),\n        clamp(spots * 1.0 / (1.0 - BASE_COLOR.g), 0.0, 1.0),\n        clamp(spots * 1.0 / (1.0 - BASE_COLOR.b), 0.0, 1.0)\n\t);\n    \n    fragColor = vec4(\n        coronaColor * spotColor,\n        1.0\n    );\n}\n\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 413, 447, 447, 1029], [1031, 1031, 1055, 1055, 1890], [1892, 1892, 1917, 1999, 2560], [2562, 2562, 2620, 2667, 3506]], "test": "untested"}
{"id": "4llXDX", "name": "Spinning Doodle", "author": "haxiomic", "description": "response to reddit thread https://www.reddit.com/r/programming/comments/3hpnhv/that_mesmerizing_thing_in_18_lines_of_pure/", "tags": ["2d", "sine", "roation"], "likes": 15, "viewed": 344, "published": "Public", "date": "1440198538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define time iTime\n\nfloat arc(in float R, in float angle, in float start, in float end, in float motionBlur){\n    float e = 0.0025;\n    float ea = 0.0015 * (1. + motionBlur);\n\n    float f = smoothstep(start-e, start+e, R) * (1.-smoothstep(end-e, end+e, R));\n    f *= smoothstep(0.25-ea, 0.25+ea, angle);\n    f *= 1. - smoothstep(0.75-ea, 0.75+ea, angle);\n    return 1. - f;\n}\n\nvoid rot(inout vec2 r, in float theta){\n    mat2 rot = mat2(\n        cos(theta), -sin(theta), \n        sin(theta), cos(theta)\n    );\n    r *= rot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(1.0), 1.);\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec2 r = uv - vec2(.5);\n    r.x *= iResolution.x/iResolution.y;\n    rot(r, -PI*.5);\n   \n    const float width = 0.02;\n    const float gap = 0.003;\n    const float count = 20.0;\n    const float motionBlurStrength = 0.005;\n    const float chromaticAbberationX = 0.01;\n    \n    float speed = 0.25;\n    float v = sin(time*speed + PI)*0.8;\n    float v2 = cos(time*speed + PI*1.0)*.5 + .5;\n    float theta = time*speed + v;\n\t\n    for(int c = 0; c < 3; c++){\n        \n    \tvec2 r2 = r;\n        r2.y += float(c - 1) * chromaticAbberationX * length(r);\n        \n        for(float i = 0.0; i < count; i++){\n            float j = i * (width+gap);\n            rot(r2, theta + float(c-1)*i*0.00035*v2);\n            float angle = (atan(r2.y, r2.x) + PI)/(2.*PI);\n           \tfloat R = length(r2);\n            R += sin(angle*30.0) * 0.01;\n            float f = arc(R, angle, 0.0 + j, width + j, i*i*i*motionBlurStrength*v2);\n            fragColor[c] *= f;\n        }\n        \n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 134, 134, 400], [402, 402, 441, 441, 550], [552, 552, 609, 609, 1669]], "test": "untested"}
{"id": "4llXW2", "name": "three planes", "author": "tly", "description": "another escher shader, \"three intersecting planes\".", "tags": ["raymarching", "escher", "planes"], "likes": 31, "viewed": 1357, "published": "Public", "date": "1439826050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14156;\n\nstruct Ray{\n\tvec3 p,v;\n};\n\nfloat hash2 (vec2 p) {\n\treturn fract(sin(p.x*15.0 + p.y*35.7)*49379.37);\t\n}\n\nfloat noise2(vec2 p){\n\tvec2 iP = floor(p);\n\tvec2 fP = fract(p);\n\t\n\treturn mix(\n\t\tmix(hash2(iP + vec2(0,0)),hash2(iP + vec2(0,1)),fP.y),\n\t\tmix(hash2(iP + vec2(1,0)),hash2(iP + vec2(1,1)),fP.y),\n\t\tfP.x\n\t);\n}\n\nvec3 rotateY(in vec3 v, in float a) {\n\treturn vec3(cos(a)*v.x + sin(a)*v.z, v.y,-sin(a)*v.x + cos(a)*v.z);\n}\n\nvec3 rotateX(in vec3 v, in float a) {\n\treturn vec3(v.x,cos(a)*v.y + sin(a)*v.z,-sin(a)*v.y + cos(a)*v.z);\n}\n\nfloat box(vec3 p,vec3 boxPos,vec3 boxSize){\n    vec3 d = abs(p-boxPos)-boxSize;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat boxplane(vec3 p){\n    vec3 p0 = p;\n\tp0.xz = fract(p0.xz);\n    vec3 p1 = p;\n    p1.xz = fract(p1.xz - 0.5);\n    return max(\n    \tmin(\n        \tbox(p0,vec3(0.5,0,0.5), vec3(0.25,0.02,0.25)),\n        \tbox(p1,vec3(0.5,0,0.5), vec3(0.25,0.02,0.25))\n    \t),\n        box(p,vec3(0,0,48.76),vec3(1.24,1,50))\n    );\n}\n\nfloat scene(vec3 p){\n    float plane1 = boxplane(p);\n    \n    vec3 x = normalize(vec3(-1,sqrt(2.0),1));\n    vec3 y = normalize(vec3(-1,0,-1));\n    vec3 z = normalize(vec3(-1,-sqrt(2.0),1));\n    \n    float plane2 = boxplane(mat3(x,y,z) * p);\n    float plane3 = boxplane(mat3(-x,y,z) * p);\n    \n\treturn min(plane1,min(plane2,plane3));\n}\n\n//thanks inigo ;)\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy) - scene(pos-eps.xyy),\n\t    scene(pos+eps.yxy) - scene(pos-eps.yxy),\n\t    scene(pos+eps.yyx) - scene(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) - 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 p = 1.71 * vec3(0,1.07,-1.5);\n    vec3 ray = normalize(vec3(uv.xy,0.9));\n    \n    vec2 rotation = vec2(sin(0.75 * iTime),sin(iTime));\n    rotation = 0.2 * sign(rotation) * pow(abs(rotation),vec2(7.0));\n    \n    p = rotateY(rotateX(p,rotation.x), rotation.y);\n    ray = rotateX(ray,-0.5);\n    ray = rotateY(rotateX(ray,rotation.x), rotation.y);\n\n    const int MAX_STEPS = 100;\n\t\n    vec3 normal = vec3(0,0,0);\n    for(int i= 0; i < MAX_STEPS; i++){\n    \tfloat d = scene(p);\n   \n        if(d < 0.0001){\n            normal = calcNormal(p);\n            break;\n        }\n        p+= d * ray;\n    }\n    \n    vec3 sunRay = normalize(vec3(1,1,-0.7));\n    \n\tfragColor = vec4(\n        mix(\n            mix(0.3,1.0,max(0.0,dot(normal,sunRay))) * vec3(0.1,0.6,0.9) ,\n        \tvec3(0.6,0.1,0.1),\n            smoothstep(10.0,25.0,length(p))\n        ) + 0.15 *(noise2(fragCoord.xy) - 0.5)\n        ,1);\n    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llXW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 76, 76, 129], [131, 131, 152, 152, 336], [338, 338, 375, 375, 446], [448, 448, 485, 485, 555], [557, 557, 600, 600, 672], [674, 674, 697, 697, 987], [989, 989, 1009, 1009, 1323], [1325, 1343, 1375, 1375, 1595], [1597, 1597, 1653, 1653, 2645]], "test": "untested"}
{"id": "4lsSzX", "name": "Distance Field Text", "author": "Flyguy", "description": "Distance field based text with an 80's scifi like style. This is based on some shaders I posted on GLSL Sandbox a few days ago.", "tags": ["retro", "text", "logo", "distance", "shadertoy", "scifi"], "likes": 59, "viewed": 6445, "published": "Public API", "date": "1438651295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define SHOW_DISTANCE\n\n#define BACK_COL_TOP vec3(1,0,1)\n#define BACK_COL_BOTTOM vec3(0,0,1)\n\n#define TEXT_COL1_TOP vec3(0.05, 0.05, 0.40)\n#define TEXT_COL1_BOTTOM vec3(0.60, 0.90, 1.00)\n#define TEXT_COL2_TOP vec3(0.10, 0.10, 0.00)\n#define TEXT_COL2_BOTTOM vec3(1.90, 1.30, 1.00)\n\n//--- Primiives ---\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\n//p0 = bottom left, clockwise winding\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.y));\n}\n//-----------------\n\n//--- Letters ---\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n\nvoid H(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.000,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n}\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 0.825), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfRect(vec2(0.250, 0.825), uv - vec2(-0.000,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.1875,-0.1875)) * -1.0));\n}\n\nvoid D(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.25), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfSemiArc(0.5, 0.125, (uv.xy * vec2(-1,1) - vec2(0.375,-0.00))));\n}\n\nvoid E(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));    \n    df = min(df, dfQuad(vec2(-0.375,-0.625), vec2(-0.375,-0.375), vec2(0.250, -0.375), vec2( 0.125,-0.625), uv));\t\n    df = min(df, dfQuad(vec2(-0.375,0.375), vec2(-0.375,0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\t   \n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfSemiArc(0.25, 0.125, (uv.xy * vec2(-1,1) - vec2(0.125,0.25))));    \n    df = min(df, dfRect(vec2(0.25, 0.250), uv - vec2(-0.375,0.375)));\n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.250,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.1,-0.125), vec2(0.250,-0.625), vec2(-0.025,-0.625), uv));\t\n\n}\n\nvoid T(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.250, 1.0), uv - vec2(-0.3125,-0.625))); \n\tdf = min(df, dfQuad(vec2(-0.625, 0.375), vec2(-0.625,0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\t\n}\n\nvoid O(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.375), uv - vec2( 0.000,-0.1875)));  \n    df = min(df, dfRect(vec2(0.25, 0.375), uv - vec2(-0.625,-0.1875)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.1875,-0.1875)) * -1.0));\n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(-0.1875,-0.1875)) ));\n}\n\nvoid Y(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2( 0.000,0.375)));  \n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2(-0.625,0.375)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.375,-0.1875)) ));\n    df = min(df, dfRect(vec2(0.250, 0.75), uv - vec2(-0.3125,-0.625))); \n}\n\n//---------------\n\n//--- Gradient Stuff ---\n//returns 0-1 when xn is between x0-x1\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) / (x1 - x0);\n}\n\nvec3 retrograd(float x0, float x1, float m, vec2 uv)\n{\n\tfloat mid = x0+(x1 - x0) * m;\n\n\tvec3 grad1 = mix(TEXT_COL1_BOTTOM, TEXT_COL1_TOP, linstep(mid, x1, uv.y));\n    vec3 grad2 = mix(TEXT_COL2_BOTTOM, TEXT_COL2_TOP, linstep(x0, mid, uv.y));\n\n\treturn mix(grad2, grad1, smoothstep(mid, mid + 0.04, uv.y));\n}\n//----------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy/iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y );\n\t\n\tuv = (uv - aspect/2.0)*8.0;\n\t\n    //Text distance field\n\tfloat dist = 1e6;\n\t\n\tvec2 chSpace = vec2(1.125,1.500);\n\t\n\tvec2 chuv = uv;\n\tchuv.x += (chSpace.x * 9.0) / 2.0 - 0.75;\n\t\t\n\tS(dist, chuv); chuv.x -= chSpace.x;\n\tH(dist, chuv); chuv.x -= chSpace.x;\n\tA(dist, chuv); chuv.x -= chSpace.x;\n\tD(dist, chuv); chuv.x -= chSpace.x;\n    E(dist, chuv); chuv.x -= chSpace.x;\n    R(dist, chuv); chuv.x -= chSpace.x;\n\tT(dist, chuv); chuv.x -= chSpace.x;\n    O(dist, chuv); chuv.x -= chSpace.x;\n    Y(dist, chuv); chuv.x -= chSpace.x;\n    \n    dist /= 2.0;\n    \n    //Colors and mixing mask\n\tfloat mask = smoothstep(4.0 / iResolution.y, 0.00, dist);\n    \n\tvec3 textcol = retrograd(-0.75, 0.50, 0.40 + pow(abs(dist), 0.25) * 0.08, uv);\n\t\n\tvec3 backcol = mix(BACK_COL_BOTTOM, BACK_COL_TOP, (uv.y/4.0)+0.5) * smoothstep(0.02, 0.025, dist);\n\t\n    //Grid Stuff\n\tvec2 gdef = vec2(uv.x / abs(uv.y), 1.0 / (uv.y));\n\tgdef.y = clamp(gdef.y,-1e2, 1e2);\n\t\n\tvec2 gpos = vec2(0.0,-iTime);\n\t\n\tgdef += gpos;\n\t\n\tvec2 grep = mod(gdef*vec2(1.0,2.0), vec2(1.0));\n\t\n\tfloat grid = max(abs(grep.x - 0.5),abs(grep.y - 0.5));\n\t\n\tfloat gs = length(gdef-gpos)*0.01;\n\t\n\tbackcol *= mix(smoothstep(0.46-gs,0.48+gs,grid), 1.0, step(0.0,uv.y))*0.75+0.25;\n\t\n    //Mixing text with background\n\tvec3 color = mix(backcol,textcol,mask);\n\t\n    #ifdef SHOW_DISTANCE\n    color = vec3(sin(dist*48.0));\n    #endif\n    \n\tfragColor = vec4( vec3( color ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsSzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 302, 350, 350, 404], [406, 444, 503, 503, 792], [794, 794, 828, 828, 894], [916, 934, 967, 967, 1396], [1398, 1398, 1431, 1431, 1684], [1686, 1686, 1719, 1719, 2055], [2057, 2057, 2090, 2090, 2243], [2245, 2245, 2278, 2278, 2695], [2697, 2697, 2730, 2730, 3184], [3186, 3186, 3219, 3219, 3402], [3404, 3404, 3437, 3437, 3748], [3750, 3750, 3783, 3783, 4076], [4097, 4161, 4206, 4206, 4239], [4241, 4241, 4295, 4295, 4547], [4548, 4574, 4631, 4631, 6131]], "test": "untested"}
{"id": "4lsXWj", "name": "spores", "author": "mprice", "description": "doodle", "tags": ["flat"], "likes": 45, "viewed": 7833, "published": "Public", "date": "1439779419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265;\n\nbool HIT_HOLE = false;\nbool HIT_BARREL = false;\n\nvec3 rotateX(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    1., 0., 0.,\n    0., cos(ang), -sin(ang),\n    0., sin(ang), cos(ang));\n  return rmat * p;\n}\nvec3 rotateY(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), 0., sin(ang),\n    0., 1., 0.,\n    -sin(ang), 0., cos(ang));\n  return rmat * p;\n}\nvec3 rotateZ(vec3 p, float ang) {\n  mat3 rmat = mat3(\n    cos(ang), -sin(ang), 0.,\n    sin(ang), cos(ang), 0.,\n    0., 0., 1.);\n  return rmat * p;\n}\n\nfloat sphere(vec3 pos, float r) {\n  return length(pos) - r;   \n}\n\nfloat barrel(vec3 pos) {\n  float d = sphere(pos, 0.5);\n  pos.y += 0.5;\n  float holed = -sphere(pos, .25);\n  d = max(d, holed);\n  HIT_HOLE = (holed == d) ? true : HIT_HOLE;\n  return d;\n}\n\nfloat placedBarrel(vec3 pos, float rx, float ry) {\n  pos = rotateY(pos, ry);\n  pos = rotateX(pos, rx);\n  pos.y += 2.0;\n  return barrel(pos);\n}\n\nfloat distfunc(vec3 pos) {\n  pos += vec3(iTime);\n  vec3 c = vec3(10.);\n  pos = mod(pos,c)-0.5*c;\n    \n  pos = rotateX(pos, iTime);\n\n  HIT_HOLE = false;\n  HIT_BARREL = false;\n  \n  // Any of you smart people have a domain transformation way to\n  // do a rotational tiling effect instead of this? :)\n  float sphered = sphere(pos, 2.0);\n  float d = sphered;\n  d = min(d, placedBarrel(pos, 0., 0.));\n  d = min(d, placedBarrel(pos, 0.8, 0.));\n  d = min(d, placedBarrel(pos, 1.6, 0.));\n  d = min(d, placedBarrel(pos, 2.4, 0.));\n  d = min(d, placedBarrel(pos, 3.2, 0.));\n  d = min(d, placedBarrel(pos, 4.0, 0.));\n  d = min(d, placedBarrel(pos, 4.8, 0.));\n  d = min(d, placedBarrel(pos, 5.6, 0.));\n  d = min(d, placedBarrel(pos, 0.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 2.4, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.0, PI / 2.0));\n  d = min(d, placedBarrel(pos, 4.8, PI / 2.0));\n  d = min(d, placedBarrel(pos, 5.6, PI / 2.0));\n  d = min(d, placedBarrel(pos, 1.2, PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 3.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 5.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 1.2, 7.0 * PI / 4.0));\n  d = min(d, placedBarrel(pos, 2.0, 7.0 * PI / 4.0));\n  HIT_BARREL = d != sphered;\n\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m_x = (iMouse.x / iResolution.x) - 0.5;\n    float m_y = (iMouse.y / iResolution.y) - 0.5;\n    vec3 cameraOrigin = vec3(5.0 * sin(m_x * PI * 2.), m_y * 15.0, 5.0 * cos(m_x * PI * 2.));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (dist < EPSILON || totalDist > MAX_DIST) { break; }\n        dist = distfunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n\n    if (dist < EPSILON) {\n      vec2 eps = vec2(0.0, EPSILON);\n      vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n      vec3 lightdir = normalize(vec3(1., -1., 0.));\n      float diffuse = max(0.2, dot(lightdir, normal));\n      vec2 tc = vec2(pos.x, pos.z);\n      vec3 texcol = texture(iChannel0, tc).rgb;\n\n      vec3 lightcol = vec3(1.);\n      vec3 darkcol = vec3(.4, .8, .9);\n      float sma = 0.4;\n      float smb = 0.6;\n        \n      if (HIT_HOLE) { \n          lightcol = vec3(1., 1., 0.8);\n      } else if (HIT_BARREL) {\n        lightcol.r = 0.95;   \n      } else {\n          sma = 0.2;\n          smb = 0.3;\n      }\n      float facingRatio = smoothstep(sma, smb, \n                                     abs(dot(normal, rayDir)));\n\n      vec3 illumcol = mix(lightcol, darkcol, 1. - facingRatio);\n      fragColor = vec4(illumcol, 1.0);        \n    } else {\n      float strp = smoothstep(.8, .9, mod(screenPos.y * 10. + iTime, 1.));\n      fragColor = vec4(mix(vec3(1., 1., 1.), vec3(.4, .8, .9), strp), 1.);\n    }\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 196, 196, 311], [312, 312, 345, 345, 460], [461, 461, 494, 494, 609], [611, 611, 644, 644, 675], [677, 677, 701, 701, 862], [864, 864, 914, 914, 1006], [1008, 1008, 1034, 1034, 2448], [2450, 2450, 2507, 2507, 4660]], "test": "untested"}
{"id": "4lSXzR", "name": "Flower at night", "author": "yibojiang", "description": "experiment math painting :)", "tags": ["flower", "pattern"], "likes": 45, "viewed": 2495, "published": "Public API", "date": "1440955127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//yibojiang, 2015-8-30\n#define pi 3.1415926\n#define flyCount 40\n\nfloat pingPong(float v) {\n\n  const float amplitude = 1.;\n  const float t = pi * 2.0;\n  float k = 4.0*amplitude / t;\n  float r = mod( v  , t);\n  float d = floor(v / (0.5 * t) );\n  return mix(k * r - amplitude ,  amplitude * 3. - k * r , mod(d, 2.0));\n\n}\n\nfloat getRad(vec2 q) {\n  return atan(q.y, q.x);\n}\n\nvec2 hash(vec2 p)\n{\n  p = vec2( dot(p, vec2(127.1, 311.7)),\n            dot(p, vec2(269.5, 183.3)) );\n  return -1. + 2.*fract(sin(p) * 53758.5453123);\n}\n\nvec2 noise(vec2 tc) {\n  return hash(tc);\n}\n\nfloat firefly(vec2 p, float size) {\n  return smoothstep(0.0, size, length(p) );\n\n}\n\nconst float pow = 1.0;\nconst float flySpeed = 0.1;\nconst float duration = 1.0;\n\nvec3 drawFlower(vec3 col, vec2 p, vec2 flowerP, float t, float count, float ratio)\n{\n  \n  vec2 q = p - flowerP - vec2( pow * 0.008 * cos(3.0*iTime) , pow * 0.008 * sin(3.0*iTime) ) ;\n  vec2 rootP = p - flowerP - vec2( pow * 0.02 * cos(3.0*iTime) * p.y , -0.48 + pow * 0.008 * sin(3.0*iTime) );\n  q.y *= ratio;\n  //draw stem\n  float width = 0.01;\n  float h = 0.5;\n  float w = 0.0005;\n\n  col = mix(vec3(0.5, 0.7, 0.4), col, \n            1.0 - (1.0 - smoothstep(h, h + width, abs(rootP.y)))\n            * (1.0 - smoothstep(w, w + width, abs(rootP.x - 0.1 * sin(4.0 * rootP.y + pi * 0.35)))));\n\n  //draw flower\n  vec3 flowerCol = mix(vec3(0.7, 0.7, 0.2), vec3(0.7, 0.9, 0.7), smoothstep(0.0, 1.0, length(q) * 10.0));\n\n  float r = 0.1 + 0.05 * ( pingPong( getRad( q ) * count  + 2.*q.x * (t - duration)  )  );\n\n  col = mix(flowerCol, col, smoothstep(r, r + 0.02,  length(q)));\n\n  //draw buds\n  float r1 = 0.04;\n  vec3 budCol = mix (vec3(.3, .4, 0.), vec3(.9, .8, 0.), length(q) * 10.0);\n  col = mix(budCol, col, smoothstep(r1, r1 + 0.01,  length(q)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  float t = duration * (1. + sin(3.0 * iTime ) );\n\n  vec2 p = fragCoord.xy / iResolution.xy;\n\n  float ratio = iResolution.y / iResolution.x;\n\n  vec2 uv = p;\n  uv.y *= ratio;\n\n  //vec2 flowerP = ;\n  \n  //sky\n  vec3 col = mix( vec3(0.1, 0.6, 0.5), vec3(0.2, 0.1, 0.2), sqrt(p.y) * .6 );\n  col = mix(drawFlower(col, p, vec2(0.618, 0.518), t, 7.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\n  col = mix(drawFlower(col, p, vec2(0.418, 0.418), t*4.0, 6.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\n  col = mix(drawFlower(col, p, vec2(0.818, 0.318), t*2.0, 8., ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\n\n  for (int ii = 0; ii < flyCount; ii++) {\n    float i = float(ii);\n    float seed = i / float(flyCount);\n    float t1 = 1.0*(1. + sin(noise(vec2(seed) ).x * iTime));\n    vec2 fireflyP = uv - vec2(noise(vec2(seed) ).x + noise(vec2(seed) ).y * t1 * flySpeed, noise(vec2(seed) ).y + noise(vec2(seed) ).y * t1 * flySpeed);\n    float fly = firefly( fireflyP, 0.002 + 0.008 * seed );\n    vec3 flyCol = mix(vec3(0.1, 0.9, 0.1) * t1, vec3(0.0), fly );\n    col += flyCol;\n  }\n  fragColor = vec4(col, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 90, 90, 317], [319, 319, 341, 341, 368], [370, 370, 389, 389, 522], [524, 524, 545, 545, 566], [568, 568, 603, 603, 650], [732, 732, 816, 816, 1794], [1796, 1796, 1853, 1853, 2986]], "test": "untested"}
{"id": "4lsXzs", "name": "[SIG15] I see the light", "author": "casty", "description": "Use the mouse. Camera has autofocus. \nHalos are single-sampled, I use a distribution function of the multisampled 't' to test drawing order.", "tags": ["raytracing"], "likes": 29, "viewed": 717, "published": "Public", "date": "1439046609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Eduardo Castineyra - casty/2015\n// Creative Commons Attribution 4.0 International License\n\nconst float PI=3.14159265358979323846;\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\nvec3  hash3( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0))+vec3(0.0,1.0,2.0))); }\nconst float TOOFAR = 99999.0;\n\nvec2 mouse;\n\nfloat time;\n\n#define NSAMPLES 15\n\n// See http://iquilezles.org/www/articles/palettes/palettes.htm for more information\nvec3 pal( in float t){\n    \n    vec3 a, b ,c ,d; \n    \n    a = vec3(0.5,0.5,0.5); b = vec3(0.5,0.5,0.5); c = vec3(0.2,0.2,0.2); d = vec3(0.9,0.23,0.57);\n    return (a + b*cos( 6.28318*(c*t+d) ) + vec3(10.0) / 30.0); // desaturate\n\t}\n\n/// sRGB\nvec4 sTex2D(sampler2D s, vec2 coord){\n    vec4 color = texture(s, coord);\n    return pow(color, vec4(2.0));\n\t}\n\nfloat rayPlane(vec3 ro, vec3 rd, float y){\n    float t = (y-ro.y)/rd.y;\n  \treturn t;\n  \t}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n ){\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n\t}\n\nvec3 sun(vec2 uv){\n    vec2 uv1 = vec2(atan(uv.y,uv.x) / (2.0 * PI), length(uv));\n    uv1.x += step(uv.x, 0.0);\n    uv = uv1 + vec2(0.07, 0.0);\n    uv.x += sin(uv.y*30.0)/100.0;\n    uv1.x -= sin(uv.y*30.0 - 4.0)/100.0;\n    float col = 0.0;\n    col += step(fract(uv.x * 7.0), uv.y) + step(fract((7.0 - uv.x) * 7.0),uv.y);\n    col *= step(fract(uv1.x * 7.0), uv.y * 1.2) + step(fract((7.0 - uv1.x) * 7.0),uv.y * 1.2);\n    col += step(0.75 , 1.0 - uv.y);\n    col = clamp(col, 0.0, 1.0);\n    col -= step(0.78 , 1.0 - uv.y);\n    col = clamp(col, 0.0, 1.0);\n    return vec3(col);\n\t}\n\nvec3 rayHalo(vec3 ro, vec3 rd, vec3 o, float r){\n    o -= ro;\n    float t = dot(o, rd);\n//    float d = dot(rd * t - o, rd * t - o);\n    float d = length(rd * t - o);\n   \treturn vec3(t,d,d);\n\t}\n\nfloat LAMPR = 0.2;\nfloat LAMPBOTTOM = 1.1;\nfloat Ycoef = 0.15;    \n\n\nvec4 rayLamp(vec3 ro, vec3 d, vec3 ce, out float side, out vec3 n){\n    \n    vec4 res = vec4(TOOFAR);    \n    \n    vec3 bound = rayHalo(ro, d, ce, 0.0);\n    if (bound.y > LAMPR/Ycoef / 2.0)\n        return res;\n\t\n    vec3 o = ce - ro;\n\tfloat bottom = o.y - LAMPBOTTOM * LAMPR;\n    float top = o.y + LAMPBOTTOM * LAMPR;\n    side = 1.0;\n    n = vec3(0.0, 1.0, 0.0);\n    if (top < 0.0){\n        float t = rayPlane(vec3(0.0), d, top);\n        if (t > 0.0){\n            vec3 p = t * d - o;\n            if (dot(p, p) + (Ycoef -1.0) * p.y * p.y < LAMPR * LAMPR)\n\t            return vec4(p, t);\n        \t}\n    \t}\n    \n\tfloat c = dot(o,o) - LAMPR * LAMPR + (o.y *o.y * (Ycoef - 1.0));\n\tfloat b = -2.0 * (dot(d,o) +  d.y * o.y * (Ycoef - 1.0)); \n    float a = 1.0 + (Ycoef - 1.0) * d.y * d.y;\n\tfloat discriminant = b*b-4.0 * a * c;\n    if (discriminant > 0.0){\n        \n        float s = sqrt(discriminant);\n        float t = (-b -s)/ ( 2.0 * a); \n        side  = 1.0;\n        if (((t * d).y) > top){\n            return res;\n        \t}\n        if (((t * d).y) < bottom){\n            t = (-b + s)/ ( 2.0 * a);\n            side = -1.0;\n        \t}\n        if (((t * d).y) < bottom){\n            return res;\n        \t}\n        \n\n        vec3 p = ((t * d) - o);\n       \tvec3 n = normalize(p - o) * side;\n        vec2 uv = p.xy;        \n\t\treturn t > 0.0 ?  vec4(p, t) :res;\n    \t}\n    return res;\n\t}\n\n\n/// Magic numbers Here\nvoid Lantern(vec2 pos, out vec3 col, out vec3 ce, out float fire){\n   \tvec3 r = hash3(pos);\n    vec3 r2 = hash3(r.zy);\n    ce.y = 1.0 + sin((time * 0.02 + r2.x + r2.y * 10.0)) * (6.0 + r.z * 3.0) + 2.0;\n    ce =  vec3(pos.x + 0.5, ce.y, pos.y + 0.5);\n    ce.x += sin(time * (1.07 + r2.y / 2.0) + r2.z) * 0.1 ;\n    if (abs(pos.x) + abs(pos.y) < 2.0) /// FIXME Closest halos don't get well with the traverse\n        ce.y = TOOFAR;\n    fire = sin(time * (11.0 + r2.x)  + r2.z * 10.0) * 0.25 + 0.75 + cos(time * 23.0) * 0.25;\n    col = pal(r2.z);\n\t}\n\nvec4 rayCellPos(vec3 o, vec3 d, vec2 pos){\n    vec3 ce;\n    vec3 col;\n    float side;\n    float fire;\n    vec3 n;\n    Lantern(pos, col, ce, fire);\n    vec4 sph = rayLamp(o, d, ce, side, n);\n    if (sph.a >= TOOFAR)\n        return vec4(vec3(0.0), sph.a);\n    vec3 p = (o + sph.a*d - ce);\n    vec3 tex = (texcube( iChannel0, p, n).rgb + 1.0) / 5.0;\n    float star = (1.0 - sun(p.zy * 3.5 - vec2(0.0)).r) / (2.5 - side);\n    tex.r += star;\n    tex += (1.0 - tex.r) * fire * vec3(60.0, 60.0, 30.0) / (9.0 + side * 4.0);\n    tex *= clamp(0.2 - p.y / (LAMPR/Ycoef), 0.01, 1.0);\n    col *= tex;\n    return vec4(col, sph.a);\n\t}\n\nvec4 castRay( in vec3 ro, in vec3 rd){\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( 0.0, 0.0, 0.0, TOOFAR);\n\t\n    vec2 mm;\n    mm = step( dis.xy, dis.yx ); \n    dis += mm*ris;\n    pos += mm*rs;\n\n    // traverse regular grid (in 2D)\n\tfor( int i=0; i<18; i++ ) \n\t{\t\t\n        \n        vec4 cell = rayCellPos(ro, rd, pos);\n        if (cell.a != TOOFAR){\n            return cell;\n        \t}\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\treturn res;\n}\n\nvec4 rayHaloPos(vec3 o, vec3 d, vec2 pos){\n    vec3 ce;\n    vec3 col;\n    float fire;\n    Lantern(pos, col, ce, fire);\n   \tce.y -= LAMPBOTTOM * LAMPR;\n    \n    float ra = 1.5;\n    vec3 hal = rayHalo(o, d, ce, ra);\n    col *= 1.0 - pow(hal.y / ra, 0.1);\n    col = clamp(col * 0.3, vec3(0.0), vec3(0.1));\n    return  vec4(col.rgb * smoothstep(-40.0, 20.0, dot(ce, vec3(0.0, 1.0, 0.0))), hal.x);\n\t}\n\nvec4 rayFirePos(vec3 o, vec3 d, vec2 pos){\n    vec3 ce;\n    vec3 col;\n    float fire;\n    Lantern(pos, col, ce, fire);\n    \n   \tce.y -= LAMPBOTTOM * LAMPR;\n    \n    col = vec3(8.0, 8.0, 4.0) * fire;\n    \n    float ra = 0.2;\n    vec3 hal = rayHalo(o, d, ce, ra);\n    col *= 1.0 - pow(hal.y / ra, 0.05);\n    col = clamp(col, vec3(0.0), vec3(max(0.0, 1.0 - hal.x / 25.0)));\n    return vec4(col.rgb * smoothstep(-0.1, 0.2, dot(ce, vec3(0.0, 1.0, 0.0))), hal.x);\n\t}\n\nvec4 castRayHalos( in vec3 ro, in vec3 rd, vec2 tdf){\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n    vec2 side = sign(rd.xz).yx * vec2(-1.0, 1.0); /// 3 parallel lines traverse the grid\n\t\n    vec2 mm;\n\tfloat mint = 0.0;\n\tvec4 hal;    \n\tvec4 res = vec4( 0.0, 0.0, 0.0, TOOFAR);\n    \n    // traverse regular grid (in 2D)\n\tfor( int i=0; i<40; i++ ) \n\t{\t\t\n        float att = (40.0 - float(i))/40.0;\n        hal = rayHaloPos(ro, rd, pos);\n        res.rgb += hal.rgb * att;\n        hal = rayFirePos(ro, rd, pos);\n        /// What is the probability that the halo is behind something?\n        res.rgb += (1.0 - smoothstep(tdf.x - tdf.y, tdf.x + tdf.y, hal.a)) * hal.rgb * att;\n        hal = rayHaloPos(ro, rd, pos + side);\n        res.rgb += (1.0 - smoothstep(tdf.x - tdf.y, tdf.x + tdf.y, hal.a)) * hal.rgb * att;\n        hal = rayHaloPos(ro, rd, pos - side);\n        res.rgb += (1.0 - smoothstep(tdf.x - tdf.y, tdf.x + tdf.y, hal.a)) * hal.rgb * att;\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\treturn vec4(res.rgb, tdf.x + tdf.y);\n}\n\nvec2 hashmod = vec2(0.0);\nvoid dof(vec2 uv, inout vec3 co, inout vec3 rd, vec2 focus){\n    rd *= focus.x;\n    vec3 hash = hash3(uv + hashmod) / focus.y;\n    co += hash - 0.5 / focus.y;\n    rd = normalize(rd - hash + 0.5 / focus.y);\n    hashmod += hash.xz;\n\t}\n\nvec3 cam(vec2 uv, vec3 co, vec3 d){\n    d = normalize(d);\n    vec3 u = normalize(cross(d,vec3(0.0,1.0,0.0)));\n    vec3 v = normalize(cross(u,d));\n    vec2 p = uv - 0.5;\n\tvec3 rd = normalize(d + p.x*u + p.y*v);    \n    return rd;\n\t}\n\nvec4 rayTrace2(vec3 o, vec3 d){\n    vec4 cas = castRay(o, d);\n    float t = cas.a;\n    if (t < TOOFAR){\n        return vec4(cas);\n    \t}\n    vec3 sky = (1.0 - abs(d.y)) * vec3(0.01, 0.04, 0.1);\n    return vec4(sky, TOOFAR);\n\t}\n\nvec4 rayHalos(vec3 o, vec3 d, vec2 tdf){\n    vec4 cas = castRayHalos(o, d, tdf);\n    return cas;\n\t}\n\nvec4 center(vec2 uv){\n    return vec4(step(-0.001, -length(uv - 0.5)));\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy) * vec2(1.0, 0.56) + vec2(0.0, 0.22);\n    mouse = iMouse.xy / iResolution.xy;\n    time = iTime;\n    \n    \n    vec3 co = vec3(0.5, 0.0, 0.5);\n    \n   \tvec2 a = vec2(mouse.xy/vec2(1.0, 4.0) + vec2(0.0, -0.1) + vec2(0.0, 0.15) *(1.0 -step (0.01, mouse.y))) * 2.0 * PI;\n    vec3 dir = vec3(cos(a.x) * cos(a.y), sin(a.y), sin(a.x) * cos(a.y));\n\t    \n    vec3 rd = cam(uv, co, dir);\n\tvec2 focus = vec2(rayTrace2(co, dir).a, 20.0);\n\tvec4 c = vec4(0.0);\n    \n    vec4 color = vec4(0.0);\n    vec2 tdf = vec2(0.0); /// t distribution\n    \n    for (int i = 0 ; i < NSAMPLES; i++){\n        rd = cam(uv + hash2(float(i)) / iResolution.xy, co, dir);\n        vec3 cod = co;\n        vec3 rdd = rd;\n    \tif (focus.x <= 0.0) focus.x = 1000.0;\n    \tdof(uv, cod, rdd, focus);\n        vec4 c = rayTrace2(cod, rdd);\n\t\tcolor.xyz += c.xyz;\n        c.a = clamp(c.a, 0.0, 100.0);\n        tdf.x += c.a;  \t\t\t\t\t\t\t\t/// average\n        tdf.y += abs(c.a - tdf.x / float(i + 1));\t/// sd\n        \n        color.a = max(color.a, c.a);\n    \t}\n    \n    tdf.x /= float(NSAMPLES);\n    \n    rd = cam(uv, co, dir); \n    c = rayHalos(co, rd, tdf);\n    \n    color /= float(NSAMPLES) + center(uv);\n    color.xyz += c.xyz;\n    color = pow(color, vec4(0.5));\n    fragColor = vec4(color.xyz, 1.0) + center(uv);\n\n    \n\t}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "ldl3zn", "previewfilepath": "https://soundcloud.com/jeliaedu/i-see-the-light-ost-disneys", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/jeliaedu/i-see-the-light-ost-disneys", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsXzs.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[0, 144, 168, 168, 227], [228, 228, 252, 252, 302], [303, 303, 327, 327, 404], [483, 568, 590, 590, 800], [802, 811, 848, 848, 921], [923, 923, 965, 965, 1012], [1014, 1014, 1066, 1066, 1211], [1213, 1213, 1231, 1231, 1789], [1791, 1791, 1839, 1839, 1984], [2055, 2055, 2122, 2122, 3437], [3440, 3463, 3529, 3529, 4008], [4010, 4010, 4052, 4052, 4629], [4631, 4631, 4669, 4669, 5247], [5249, 5249, 5291, 5291, 5644], [5646, 5646, 5688, 5688, 6106], [6108, 6108, 6161, 6161, 7292], [7320, 7320, 7380, 7380, 7552], [7554, 7554, 7589, 7589, 7785], [7787, 7787, 7818, 7818, 8013], [8015, 8015, 8055, 8055, 8114], [8116, 8116, 8137, 8137, 8190], [8192, 8192, 8248, 8248, 9568]], "test": "untested"}
{"id": "4lXXD2", "name": "Bokeh Lights", "author": "inferno", "description": "Branch of this shader [url]https://www.shadertoy.com/view/4lXXDB[/url] by [b]BigWIngs[/b] with some reduction to just get some nice bokeh lights. Use the mouse to look around", "tags": ["3d", "raymarching", "light", "dof", "bokeh"], "likes": 22, "viewed": 834, "published": "Public", "date": "1439841310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Martijn Steinrucken - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// \n// based on https://www.shadertoy.com/view/4lXXDB by BigWIngs\nconst vec3 worldUp = vec3(0.,1.,0.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nconst float NUM_LIGHTS = 150.;\t\t\t// number of twinkly lights falling down\nconst float _FocalDistance = 0.0035;\t// focal distance of the camera\nconst float _DOF = 1.;\t\t\t\t// depth of field. How quickly lights go out of focus\nconst float _ZOOM = 0.6;\t\t// camera zoom, smaller values means wider FOV\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n// Helper functions - Borrowed from other peoples shaders =================================\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nvec2 hash2(float n) {\n\tvec2 n2 = vec2(n, -n+2.1323);\n    return fract(sin(n2)*1751.5453);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.;\n    x /= w;\n    return 1. - x*x*(3.-2.*x);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat PeriodicPulse(float x, float p) {\n    // pulses from 0 to 1 with a period of 2 pi\n    // increasing p makes the pulse sharper\n\treturn pow((cos(x+sin(x))+1.)/2., p);\n}\n\n\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(1., dot(p-r.o, r.d))*r.d;\n}\n\n// ================================================================\n\n// simple value noise\nfloat hash3( float n ) \n{ \n\treturn fract(sin(n)*753.5453123); \n}\n\nfloat vnoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash3(n+  0.0), hash3(n+  1.0),f.x),\n                   mix( hash3(n+157.0), hash3(n+158.0),f.x),f.y),\n               mix(mix( hash3(n+113.0), hash3(n+114.0),f.x),\n                   mix( hash3(n+270.0), hash3(n+271.0),f.x),f.y),f.z);\n}\n\nfloat Bokeh(ray r, vec3 p) \n{\n    float dist = length( p-ClosestPoint(r, p) );\n    \n    float distFromCam = length(p-e.o);\n    float focus = cubicPulse(_FocalDistance, _DOF, distFromCam);\n    \n    vec3 inFocus = vec3(0.2, -0.1, 1.);\t// outer radius = 0.05, inner radius=0 brightness =1\n    vec3 outFocus = vec3(0.25, 0.2, .05);\t// out of focus is larger, has sharper edge, is less bright\n    \n    vec3 thisFocus = mix(outFocus, inFocus, focus);\n    \n    return smoothstep(thisFocus.x, thisFocus.y, dist)*thisFocus.z;\n}\n\nvec3 Lights(ray r, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    float height = 4.;\n   \tfloat halfHeight = height/2.;\n   \n    for(float i=0.; i<NUM_LIGHTS; i++) {\n    \tfloat c = i/NUM_LIGHTS;\n        c *= twopi;\n        \n        vec2 xy = hash2(i)*10.-5.;\n        \n        float y = fract(c)*height-halfHeight;\n        \n        vec3 pos = vec3(xy.x, y, xy.y);\n        pos += vec3(vnoise(i * pos * iTime * 0.0006), vnoise(i * pos * iTime * 0.0002), 0.0);\n        \n        float glitter = 1. +clamp((sin(c+t*3.)-0.9)*50., 0., 100.);\n       \n        col += Bokeh(r, pos)*glitter *mix( vec3(02.5,2.2,01.9), vec3(0.7, 1.6,3.0), 0.5+0.5*sin(float(i)*1.2+1.9));\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec3 mouse = -vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tfloat t = iTime;\n    \n    float speed = 0.004;\n    \n    float st = sin(t*speed);\n    float ct = cos(t*speed);\n    \n    cam.p = vec3(st, st, ct)*vec3(4., 3.5, 4.);\n    cam.p = normalize(cam.p);// NOTE this won't work if the lookat isn't at the origin\n    \n    cam.p = rotate_x(cam.p,mouse.y*2.+5.2); cam.p = rotate_y(cam.p,mouse.x*3.);\n\n    \n    cam.lookAt = vec3(0., 0., 0.);\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(worldUp, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = _ZOOM;\n    \n    vec3 screenCenter = cam.p+cam.forward*cam.zoom;\n    vec3 screenPoint = screenCenter+cam.left*uv.x+cam.up*uv.y;\n    \n    e.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    e.d = normalize(screenPoint-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n   \n    vec3 col = vec3(0.);\n    \n\tcol += Lights(e, t*0.2);\t\t\t\t\t\t\t// lights falling down\n  \tcol += 0.05;\n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXXD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[933, 1026, 1049, 1049, 1087], [1089, 1089, 1110, 1110, 1180], [1182, 1182, 1229, 1229, 1319], [1321, 1321, 1357, 1357, 1474], [1476, 1476, 1512, 1512, 1630], [1632, 1632, 1671, 1763, 1804], [1808, 1808, 1842, 1895, 1944], [2015, 2037, 2062, 2062, 2101], [2103, 2103, 2130, 2130, 2507], [2509, 2509, 2538, 2538, 3027], [3029, 3029, 3058, 3058, 3708], [3711, 3711, 3768, 3768, 4920]], "test": "untested"}
{"id": "4lXXDB", "name": "Bokeh World", "author": "BigWIngs", "description": "My first attempt at creating an environment inside of a shader. Could definitely be optimized but I already spent way too much time on this. :)\nI welcome suggestions on how to make it better.\n\n", "tags": ["raytracing", "bokeh", "ocean", "underwater", "fish", "sparkles"], "likes": 29, "viewed": 1873, "published": "Public", "date": "1439527702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Martijn Steinrucken - msteinrucken@gmail.com - 2015\n// License Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)\n// \nconst vec3 worldUp = vec3(0.,1.,0.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nconst float NUM_SURFACE_BOKEH = 150.;\t// number of twinkly lights on the surface\nconst float NUM_LIGHTS = 100.;\t\t\t// number of twinkly lights falling down\nconst float _FocalDistance = 3.;\t// focal distance of the camera\nconst float _DOF = 2.;\t\t\t\t// depth of field. How quickly lights go out of focus\nconst float _ZOOM = 0.4;\t\t// camera zoom, smaller values means wider FOV\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n// Helper functions =================================\n\n//  Borrowed from other peoples shaders =============\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nvec2 hash2(float n) {\n\tvec2 n2 = vec2(n, -n+2.1323);\n    return fract(sin(n2)*1751.5453);\n}\n\n// http://iquilezles.org/www/articles/functions/functions.htm\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.;\n    x /= w;\n    return 1. - x*x*(3.-2.*x);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n// ================ End Borrowed Functions =================================\n\nfloat PeriodicPulse(float x, float p) {\n    // pulses from 0 to 1 with a period of 2 pi\n    // increasing p makes the pulse sharper\n\treturn pow((cos(x+sin(x))+1.)/2., p);\n}\n\nfloat SlantedCosine(float x) {\n    // its a cosine.. but skewed so that it rises slowly and drops quickly\n    // if anyone has a better function for this i'd love to hear about it\n\tx -= 3.55;\t// shift the phase so its in line with a cosine\n    return cos(x-cos(x)*0.5);\n}\n\nvec3 IntersectPlane(ray r, vec4 plane) {\n    // returns the intersection point between a ray and a plane\n\tvec3 n = plane.xyz;\n    vec3 p0 = plane.xyz*plane.w;\n    float t = dot(p0-r.o, n)/dot(r.d, n);\n    return r.o+max(0.,t)*r.d;\t\t\t\t// not quite sure what to return if there is no intersection\n    \t\t\t\t\t\t\t\t\t\t// right now it just returns the ray origin\n}\n\nfloat BandStep(float ss, float se, float es, float ee, float t) {\n    return smoothstep(ss, se, t)*smoothstep(ee, es, t);\n}\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\n// ================================================================\n\n\n\nvec3 Light(ray r, vec3 p) {\n\t// renders a pointlight at position p\n    float dist = length( ClosestPoint(r, p)-p );\n    \n    float lightIntensity = smoothstep(0.1, 0.08, dist);\n    \n    return lightIntensity*vec3(1.);\n}\n\nfloat Bokeh(ray r, vec3 p) {\n\tfloat dist = length( p-ClosestPoint(r, p) );\n    \n    float distFromCam = length(p-e.o);\n    float focus = cubicPulse(_FocalDistance, _DOF, distFromCam);\n    \n    vec3 inFocus = vec3(0.05, -0.1, 1.);\t// outer radius = 0.05, inner radius=0 brightness =1\n    vec3 outFocus = vec3(0.25, 0.2, .05);\t// out of focus is larger, has sharper edge, is less bright\n    \n    vec3 thisFocus = mix(outFocus, inFocus, focus);\n    \n    return smoothstep(thisFocus.x, thisFocus.y, dist)*thisFocus.z;\n}\n\n\n\n\n\nfloat SineWave(vec2 pos, float phase, float frequency, float amplitude, float offset, float thickness, float glow) {\n\t\t// returns a sine wave band\n    \t// takes a position from -pi,-pi to pi, pi\n\t\t\t\t\n    float dist = abs(pos.y-(sin(pos.x*frequency+phase)*amplitude-offset));  // distance to a sine wave\n    return smoothstep(thickness+glow, thickness, dist);\n}\n\nvec3 Floor(ray r) {\n\tvec3 i = IntersectPlane(r, vec4(0.,1.,0.,0.));//Light(e, lightPos);\n    vec3 col=vec3(0.);\n    \n    return col;\n}\n\nvec3 SurfaceBokeh(ray r, float t) {\n    vec3 col = vec3(0.);\n    \n    float bokehArea = 30.;\n    float halfBokehArea = bokehArea/2.;\n    float bokehSize = 0.3*0.3;\t\t\t// use square so we can use squared distance to avoid using length()\n    float bokehBrightness = 0.1;\n    vec3 bokehColor = vec3(1., 1., 0.5);\n    \n    t *= 1.;\n    float T = iTime*3.;\n    float fT = floor(T);\n    \n    for(float i=0.; i<NUM_SURFACE_BOKEH; i++) {\n        float c = i/NUM_SURFACE_BOKEH;\n        float thisT = T+c;\n        \n        vec2 n = hash2(floor(thisT)+c)*bokehArea-halfBokehArea;\n        vec3 p = vec3(n.x, 10., n.y);\n        \n        //vec3 bokeh = vec3( smoothstep(bokehSize, bokehSize*0.8, length(p-ClosestPoint(e, p))) );\n        vec3 d = p-ClosestPoint(e, p);\n        vec3 bokeh = vec3( smoothstep(bokehSize, bokehSize*0.8, dot(d, d)) );\n        \n        \n        float alpha = cubicPulse(0.5, 0.5, fract(thisT));\n        col += vec3( bokeh*alpha);\n    }\n    col *= bokehBrightness;\n    \n    col *= bokehColor;\n    \n    return col;\n}\n\nvec3 Surface(ray r, vec2 coords, float t) {\n    float st = sin(t);\n    float ct = cos(t);\n    mat2 rot = mat2(ct, st, st, -ct);\n    \n    vec3 col = vec3(0.);\n    \n    t *= -20.;\n\tvec2 I = IntersectPlane(r, vec4(0., 1., 0., 10.)).xz*0.2;\n   \n    \n    vec2 W1 = vec2(12., -45)*rot;\n    vec2 W2 = vec2(-210., 360.)*rot;\n    vec2 W3 = vec2(870., -360.);\n    vec2 W4 = vec2(130., 60.);\n    vec2 W5 = vec2(1., -870.);\n    vec2 W6 = vec2(0., 0.);\n    \n    float LW1 = length(I-W1);\n    float LW2 = length(I-W2);\n    float LW3 = length(I-W3);\n    float LW4 = length(I-W4);\n    float LW5 = length(I-W5);\n    float LW6 = length(I-W6);\n    \n    float wave1 = sin(LW1*8.7+t);\n    float wave2 = sin(LW2*12.2+t);\n    float wave3 = sin(LW3*16.+t);\n    float wave4 = sin(LW4*8.+t);\n    float wave5 = sin(LW5*16.+t);\n    float wave6 = sin(LW6*32.+t);\n    \n    float waves = wave1*wave2*wave3*wave4*wave5*wave6;\n    waves /= 4.;\n    waves += 0.25;\n\n    col += vec3(waves);\n    col *= vec3( smoothstep(5., 0., LW6) );\t\t// LW6 was centered at 0, 0 so we can use it to fade the waves\n    \n    \n    col += SurfaceBokeh(r, t);\t\t\t\t\t// add surface wave sparkles\n   \t\n    float camToLight = clamp(dot(worldUp, cam.forward), 0., 1.);\n    camToLight = pow(camToLight, 12.);\n    float rayToLight = clamp(dot(worldUp, e.d), 0., 1.);\n  \t\n    float starShape =  1.+clamp(sin(coords.x*coords.x*100.)-cos(coords.y), 0.,1.);\n    col += vec3(camToLight*rayToLight)*starShape;\n    \n    return col;\n}\n\nvec3 Backdrop(ray r, vec2 coords, float t) {\n    vec3 col= vec3(0.1, 0.5, 1.);\n    \n\tfloat band1 = SineWave(coords, t, 1., 1., 0., 0., 1.);\n\tfloat band2 = SineWave(coords, t*0.7686+1.1342132, 3., .5, 0., 0., 1.);\n    \n    col += (band1*band2)*vec3(0.1, 0.1, 1.);\n    float wave = SineWave(coords, 0., 4., .1, 0., 0.01, 0.01);\n    \n   \n    if(r.d.y>0.) col += Surface(r, coords, t);\n    \n    return col;\n}\n\n\n\n\nvec3 Lights(ray r, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    float height = 4.;\n   \tfloat halfHeight = height/2.;\n   \n    for(float i=0.; i<NUM_LIGHTS; i++) {\n    \tfloat c = i/NUM_LIGHTS;\n        c *= twopi;\n        \n        vec2 xy = hash2(i)*10.-5.;\n        \n        float y = fract(c-t)*height-halfHeight;\n        \n        vec3 pos = vec3(xy.x, y, xy.y);\n        \n        float glitter = 1. +clamp((sin(c+t*30.)-0.9)*50., 0., 100.);\n       \n        float verticalFade = BandStep(halfHeight, halfHeight*0.8, -halfHeight*0.8, -halfHeight, y);\n        col += Bokeh(r, pos)*verticalFade*glitter;\n    }\n    return col;\n}\n\n\n\nvec4 FishLayer(ray r, vec2 coords, float depth, float pathThickness, float t, float shouldLight) {\n\t\n    vec4 col = vec4(1.);\n    \n    vec2 I = IntersectPlane(r, vec4(0.,1.,0.,depth)).xz;\n    \n    float pathCenter = 4.5;\n    \n    float squareDist = dot(I, I);\n    float dist = length(I);\n    float x = coords.x*10.;\n    \n    dist += sin(coords.x*20.)*0.1;\n   \t\n    float circle = BandStep(pathCenter-pathThickness, pathCenter, pathCenter, pathCenter+pathThickness, dist);\n    \n    col.rgb *= 1.- ((dist-pathCenter)/pathThickness)*shouldLight;\t\t// add the light gradient to fake light from above\n    \n    x -= t+depth;\n    \n    float creature = SlantedCosine(x)*0.5+0.5;\n    creature *= clamp(sin(x/2.)*100., 0., 1.);\t// knock out every other creature\n    pathCenter -= 0.2;\n    float eyes = PeriodicPulse(x+1.5, 16.)*BandStep(pathCenter-0.4, pathCenter, pathCenter, pathCenter+0.4, dist);\n    \n    col.rgb -= vec3( eyes*eyes )*0.5;\n    \n    col.a = smoothstep(0., .5, circle*creature);\n    col.rgb *= clamp(col.a*10.,0.,1.);\t\t\t// premultiply alpha\n    \n    return col;\n}\n\nvec4 Fish(ray r, vec2 coords, float t) {\n    vec4 topLayer = FishLayer(r, coords, 2., 0.7, t*2., 1.)*vec4(0.4,0.4,0.4,0.3);\n    vec4 bottomLayer = FishLayer(r, coords, -3., 1., t, 0.)*vec4(0.,0.,0.,.3);\n    \n    vec4 layers = mix(topLayer, bottomLayer, bottomLayer.a);\n    \n    return layers;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec3 mouse = -vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tfloat t = iTime;\n    \n    float speed = 0.3;\n    \n    float st = sin(t*speed);\n    float ct = cos(t*speed);\n    \n    cam.p = vec3(st, st, ct)*vec3(4., 3.5, 4.);\n    cam.p = normalize(cam.p);// NOTE this won't work if the lookat isn't at the origin\n    \n   // cam.p = vec3(1., 2., 1.);\n    cam.p = rotate_x(cam.p,mouse.y*2.); cam.p = rotate_y(cam.p,mouse.x*3.);\n    \n    \n    cam.lookAt = vec3(0., 0., 0.);\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(worldUp, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = _ZOOM;\n    \n    vec3 screenCenter = cam.p+cam.forward*cam.zoom;\n    vec3 screenPoint = screenCenter+cam.left*uv.x+cam.up*uv.y;\n    \n    e.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    e.d = normalize(screenPoint-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n    \n    float x = atan(e.d.x, e.d.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(e.d.y);  \t\t// from -1/2pi to 1/2pi\n\tvec2 sphereCoords = vec2(x, y);\t\t\t\t\t\n    \n   \n    vec3 col = vec3(0.);\n    \t\n    col += Backdrop(e, sphereCoords, t*0.1);\t\t\t// blueish water + surface \n    \n    vec4 fish = Fish(e, sphereCoords, t);\t\t\t\t// fishies! or... some poor excuse for them ;)\n    col = mix(col, fish.rgb, fish.a);\n    \n\tcol += Lights(e, t*0.1);\t\t\t\t\t\t\t// lights falling down\n   \n    float depthGradient = (dot(e.d, worldUp)+1.)+0.3;\t// STuff gets darker the deeper you go\n    col *= vec3(depthGradient);\n    \n    \n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXXDB.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[1026, 1080, 1103, 1103, 1141], [1143, 1143, 1164, 1164, 1234], [1236, 1298, 1345, 1345, 1435], [1437, 1437, 1473, 1473, 1590], [1592, 1592, 1628, 1628, 1746], [1748, 1826, 1865, 1957, 1998], [2000, 2000, 2030, 2179, 2271], [2273, 2273, 2313, 2377, 2627], [2629, 2629, 2694, 2694, 2752], [2754, 2754, 2788, 2841, 2890], [2892, 2963, 2990, 3029, 3182], [3184, 3184, 3212, 3212, 3699], [3705, 3705, 3821, 3899, 4065], [4067, 4067, 4086, 4086, 4201], [4203, 4203, 4238, 4238, 5229], [5231, 5231, 5274, 5274, 6693], [6695, 6695, 6739, 6739, 7099], [7104, 7104, 7133, 7133, 7727], [7731, 7731, 7829, 7829, 8801], [8803, 8803, 8843, 8843, 9097], [9099, 9099, 9156, 9156, 10837]], "test": "untested"}
{"id": "4lXXWl", "name": "mandelbrot-steve", "author": "steverock", "description": "Just playing around with the mandelbrot set.", "tags": ["fractal"], "likes": 2, "viewed": 115, "published": "Public", "date": "1440375472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ZITERS 64\n\nfloat evalmag(vec2 c)\n{\n    float re = 0.0;\n    float im = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    \n    for (int i = 0; i < ZITERS; i++ ) {\n\t\ta = re;\n        b = im;\n        re = a*a-b*b + c.x;\n        im = a*b+b*a + c.y;\n    }\n    \n    float mag = re*re + im*im;\n    return mag;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    float t = iTime;\n    float scale = 2.0 / min(res.x, res.y) / pow(t,3.0);\n    vec2 pixelcenter = res * 0.5;\n    vec2 cCenter = vec2(-0.745, 0.15);\n    vec2 c0 = (fragCoord - res*0.5) * scale + cCenter;\n    \n    fragColor = vec4(0.0);\n    float denom = 0.0;\n    for(float dx = 0.0; dx <= 1.0; dx += 0.33 ) {\n        for(float dy = 0.0; dy <= 1.0; dy += 0.33 ) {\n            vec2 c = c0 + vec2(dx, dy);\n   \t\t\tfloat mag = evalmag(c0);\n\t\t    fragColor += mix( vec4(0.0), vec4(1.0), mag*0.5) / 9.0;\n        }\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 42, 42, 307], [309, 309, 366, 366, 916]], "test": "untested"}
{"id": "4tBSRz", "name": "RedBlueLines", "author": "Alexey", "description": "my first shader", "tags": ["2s"], "likes": 14, "viewed": 220, "published": "Public", "date": "1440853375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\t\t\n    p.x *= iResolution.x / iResolution.y;\t\n\t\n    float v = p.x + cos(iTime + p.y);\n    \t\n    vec3 col = vec3(0.1 * max(0.0, p.y), 0.1 * max(0.0, p.x), 0.2 * max(0.0, p.x)) / abs(v * 2.0);\t\n  \n\t\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 358]], "test": "untested"}
{"id": "4tBSzR", "name": "Spheres_fbm", "author": "felipevsfbr", "description": "Trying to learn ray tracing :)", "tags": ["raytracingspheres"], "likes": 3, "viewed": 181, "published": "Public", "date": "1440825984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pixProj(p) sqrt(dot(dFdx(p),dFdx(p)) + dot(dFdy(p),dFdy(p)))\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Material\n{\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n\tfloat shin;\n};\n\nstruct Esfera\n{\n\tvec3 center;\n\tfloat r;\n\tint id;\n\tMaterial m;\n};\n\nstruct Plane\n{\n\tvec3 p0;\n\tvec3 n;\n\tint id;\n\tMaterial m;\n};\n\nstruct Light\n{\n\tvec3 position;\n\tvec3 diffuse;\n\tvec3 specular;\n\tfloat cntAt, linAt, quaAt;\n};\n\nstruct HitInfo\n{\n\tvec3 hitPos;\n\tvec3 hitNrm;\n\tfloat dist;\n\tint obj;\n\tMaterial m;\n};\n\nMaterial mb = Material(\n\tvec3(0.0), \n\tvec3(0.0), \n\tvec3(0.0), \n\t0.);\n\nMaterial mee = Material(\n\tvec3(0.2), vec3(0.9,0.3, 0.1),\n\tvec3(0.9), 120.);\n\nMaterial me = Material(\n\tvec3(0.2, 0.2, 0.2),\n\tvec3(0.3, 0.8,0.3),\n\tvec3(0.9, 0.9, 0.9),\n\t120.);\n\nMaterial mp = Material(\n\tvec3(0.5, 1., 1),\n\tvec3(1, 1,1),\n\tvec3(0.0),\n\t0.);\n\nEsfera es[2];\n\nPlane P = Plane(\n\tvec3(0.0, -3.0,0.0),\n\tvec3(0.0, 1.0, 0.0),\n\t1, Material(\n\tvec3(0.5, 1., 1),\n\tvec3(1, 1,1),\n\tvec3(0.0),\n\t0.));\n\nLight L = Light(\n\tvec3(30.0, 90.0, 50.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\t0.,1.,0.03);\nRay getRays(Ray R, HitInfo hit, out Ray refracted, out bool internalRefl);\nbool ray_esfera(Ray R, Esfera E, out HitInfo hit);\nbool ray_plane(Ray R, Plane P, out HitInfo hit);\nvec3 local(HitInfo hit, Light L, Material m);\nbool intersect(Ray R, out HitInfo Info);\nbool shadow(HitInfo Info, Light L);\nfloat fbm(vec3 p);\nvec3 trace(Ray R);\n\n\nvec3 trace(Ray R)\n{\n    vec3 resolution = iResolution;\n\tvec3 col = vec3(0.);\n\tHitInfo info = HitInfo(vec3(0.0), vec3(0.0), 1000.0, -1, mb);\n\tHitInfo refl2, refr;\n\tRay temp = R, refracted;\n\tbool c;\n\tif(intersect(temp, info))\n\t\t\tcol = local(info, L, info.m);\n\tif(info.obj != -1)\n\t{\n\t\tcol += -0.5 + smoothstep(.3, .6, fbm(info.hitPos));\t\n\t\tRay refl = getRays(temp, info, refracted, c);\n\t\tif(intersect(refl, info))\n\t\t\tcol += 0.1*local(info, L, info.m);\n\t\ttemp = refl;\n\t}\n\telse\n\t{\n\t\tvec2 p = gl_FragCoord.xy/resolution.xy;\n\t\tcol = vec3(0.0, 0.0, .4);\n\t\tcol += fbm(vec3(gl_FragCoord.xy/resolution.xy, 1.0))\n\t\t\t     + 0.4*fbm(vec3(gl_FragCoord.yx/resolution.xy, 0.0));\n\t\tfloat dist = 0.1*distance(p, vec2(0.0));\n\t\tcol *= exp(-dist*sin(iTime));\n\t}\t\n\treturn col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 resolution = iResolution;\n\tvec2 uv = gl_FragCoord.xy/resolution.xy;\n\tuv = 2.0*uv - 1.0;\n\tuv.x *= resolution.x/resolution.y;\n\tvec2 m = iMouse.xy/resolution.xy;\n    m = 2.0*m - 1.0;\n    m.x *= resolution.x/resolution.y;\n\tes[0] = Esfera(\n\tvec3(3.0, -1.0, 0.0),\n\t2.0, 0, mee);\n\n\tes[1] = Esfera(\n\tvec3(-3.0, -1.0, -5.0),\n\t2.0, 0, me);\n\t\n\tvec3 at = vec3(0.0);\n\tvec3 eye = vec3(6.*2.*sin(0.5*iTime), 5, 10);\n\tvec3 look = normalize(at - eye);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 ww = cross(look, up);\n\tvec3 vv = cross(ww, look);\n\tvec3 dx = tan(radians(30.0))*ww;\n\tvec3 dy = tan(radians(30.0))*vv;\n    eye.xy *= abs(m.xy);\n\tRay R = Ray(eye, normalize(look + dx*uv.x + dy*uv.y));\n\tvec3 col = trace(R);\n\tfragColor = vec4(col, 1.0);\n\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0, s = .5, t= 0.;\n\n    f += s*noise( p ); t+=s; p = m*p*2.02; s*= .5; if(pixProj(p)> 1.) return f/t;\n    f += s*noise( p ); t+=s; p = m*p*2.03; s*= .5; if(pixProj(p)> 1.) return f/t;\n    f += s*noise( p ); t+=s; p = m*p*2.01; s*= .5; if(pixProj(p)> 1.) return f/t;\n    f += s*noise( p ); t+= s;\n\n    return f/t;\n}\n\nbool shadow(HitInfo Info, Light L)\n{\n\tvec3 lightv = normalize(L.position - Info.hitPos); \n\tRay sh = Ray(Info.hitPos, lightv);\n\tHitInfo hit = HitInfo(vec3(0.0), vec3(0.0), 1000.0, -1, mb);\n\tif(intersect(sh, hit))\n\t{\n\t\tfloat distToLight = distance(Info.hitPos, L.position);\n\t\tfloat distToObj = distance(Info.hitPos, hit.hitPos);\n\t\tif(distToLight > distToObj)\n\t\t\treturn true;\t\n\t}\n\treturn false;\n}\n\nRay getRays(Ray R, HitInfo hit, out Ray refracted, out bool internalRefl)\n{\n\tRay reflected;\n\tvec3 dir = reflect(R.direction, hit.hitNrm);\n\treflected = Ray(hit.hitPos, normalize(dir));\n\tvec3 nl = hit.hitNrm;\n\tfloat nls = dot(hit.hitNrm, R.direction);\n\tif(nls > 0.0) nl *= -1.;\n\tfloat nc = 1.0, nt = 1.5;\n\tfloat eta = nt/nc;\n\tbool into = dot(nl, hit.hitNrm) > 0.;\n\tfloat ddn = dot(R.direction, nl);\n\tif(into)\n\t\teta = nc/nt;\n\tfloat c2 = 1.0 - eta*eta*(1.0 - ddn*ddn);\n\tif(c2 < 0.0)\n\t{\n\t\tinternalRefl = true;\n\t\trefracted = Ray(vec3(0.0), vec3(0.0));\n\t}\n\telse\n\t{\n\t\tinternalRefl = false;\n\t\trefracted = Ray(hit.hitPos, normalize(refract(R.direction, hit.hitNrm, eta)));\n\t}\n\treturn reflected;\n}\n\nbool intersect(Ray R, out HitInfo Info)\n{\n\tHitInfo hit = HitInfo(vec3(0.0), vec3(0.0), 10000.0, -1, mb);\n\tHitInfo hitz;\n\tfor(int i = 0; i < 2; i++)\n\t\tif(ray_esfera(R ,es[i], hitz))\n            if(hitz.dist < hit.dist)\n\t\t\t\thit = hitz;\n\tif(ray_plane(R, P, hitz))\n\t\tif(hitz.dist < hit.dist)\n\t\t\thit = hitz;\n\tInfo = hit;\n\tif(hit.obj != -1)\n\t\treturn true;\n\treturn false;\n}\n\nvec3 getTexture(HitInfo hitInfo)\n{\n\tfloat size = 2.0;\n\tvec3 p = hitInfo.hitPos/size;\n    p = vec3(sin(3.14*hitInfo.hitPos/size));\n    float s = pixProj(p);\n    return vec3(0.3)*smoothstep(-s,s,p.x*p.y*p.z);\n}\n\nvec3 local(HitInfo hit, Light L, Material m)\n{\n\tvec3 col = vec3(0.0);\n\tvec3 lightv = L.position - hit.hitPos;\n\tfloat dist = length(lightv);\n\tlightv = normalize(lightv);\n\tfloat attenuation = 900.0/(L.cntAt + L.linAt*dist + L.quaAt*dist*dist);\n\tvec3 amb = attenuation*m.diffuse*m.ambient;\n\tvec3 dif = attenuation*m.diffuse*L.diffuse*dot(lightv, hit.hitNrm);\t\n\tfloat s = dot(lightv, hit.hitNrm);\n\tvec3 spec = vec3(0.0);\n\tif(s > 0.0)\n\t\tspec = pow(max(0.0, s), m.shin)*m.specular*L.specular;\n\tcol = amb + dif + spec;\n\tif(shadow(hit, L))\n\t\tcol = vec3(0.);\n\tif(hit.obj == 1)\n\t\tcol *= getTexture(hit);\n\treturn col;\n}\n\nbool ray_esfera(Ray R, Esfera E, out HitInfo hit)\n{\n\tvec3 or = R.origin - E.center;\n\tvec3 dir = R.direction;\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0*dot(or, dir);\n\tfloat c = dot(or, or) - E.r*E.r;\n\tfloat delt = b*b - 4.*a*c;\n\tif(delt > 0.0)\n\t{\n\t\tfloat t0 = -b -sqrt(delt);\n\t\tfloat t1 = -b +sqrt(delt);\n\t\tfloat t = min(max(0.0, t0), max(0.0, t1));\n\t\tt /= 2.0*a;\n\t\tif(t > 0.001)\n\t\t{\n\t\t\thit.hitPos = R.origin + t*R.direction;\n\t\t\thit.hitNrm = normalize(hit.hitPos - E.center);\n\t\t\thit.obj = E.id;\n\t\t\thit.dist = t;\n\t\t\thit.m = E.m;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool ray_plane(Ray R, Plane P, out HitInfo hit)\n{\n\tfloat t = dot(P.p0 - R.origin, P.n)/dot(R.direction, P.n);\n\tif(t > 0.001 && t < 70.0)\n\t{\n\t\thit.hitPos = R.origin + t*R.direction;\n\t\thit.hitNrm = P.n;\n\t\thit.dist = t;\n\t\thit.obj = P.id;\n\t\thit.m = P.m;\n\t\treturn true;\n\t}\n\treturn false;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1407, 1407, 1426, 1426, 2163], [2166, 2166, 2223, 2223, 2958], [3069, 3069, 3092, 3092, 3131], [3133, 3133, 3159, 3159, 3562], [3564, 3564, 3585, 3585, 3915], [3917, 3917, 3953, 3953, 4310], [4312, 4312, 4387, 4387, 4998], [5000, 5000, 5041, 5041, 5366], [5368, 5368, 5402, 5402, 5576], [5578, 5578, 5624, 5624, 6186], [6188, 6188, 6239, 6239, 6753], [6755, 6755, 6804, 6804, 7039]], "test": "untested"}
{"id": "4tfXRl", "name": "Contour", "author": "antonOTI", "description": "my implementation of contour, I intend to use it for a small game of my own", "tags": ["2d", "noob", "edge"], "likes": 8, "viewed": 1670, "published": "Public API", "date": "1438773564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 FakeStencil(vec2 pos)\n{\n    float shape = 1. - smoothstep(.13,.16,distance(pos,vec2(0.5)));\n    float t = iTime;\n   \tshape = max(shape,1. - smoothstep(.05,.09,distance(pos,vec2(cos(t)*1.1,sin(t)*.8) * .15 + vec2(.5))));\n   \tshape = max(shape, 1. - smoothstep(.025,.04,distance(pos,iMouse.xy/iResolution.xy * vec2(1.,.5) + vec2(0.,.25))));\n\treturn vec4(1.) * shape;\n}\n\n#define P .001\nvec4 outlineColor = vec4(.9,.15,0.04,1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = (uv.y - 0.5) * iResolution.y / iResolution.x + 0.5;\n    \n    float stencil = FakeStencil(uv + vec2(-1.,0.) * P).x;\n    stencil += FakeStencil(uv + vec2(1.,0.) * P).x;\n    stencil += FakeStencil(uv + vec2(0.,-1.) * P).x;\n    stencil += FakeStencil(uv + vec2(0.,1.) * P).x;\n    \n    stencil += FakeStencil(uv + vec2(-.7,-.7) * P).x;\n    stencil += FakeStencil(uv + vec2(.7,.7) * P).x;\n    stencil += FakeStencil(uv + vec2(.7,-.7) * P).x;\n    stencil += FakeStencil(uv + vec2(-.7,.7) * P).x;\n    \n    // Contour\n    float a = smoothstep(3.5,4.5,stencil)*(1. - smoothstep(7.9,8.,stencil));\n    \n    // Stripes\n    a += step(8.,stencil) * .2 * step(.7,sin((uv.x * 240. + uv.y *60.)+ iTime * 7.)*.4+.6);\n    \n    vec4 col = outlineColor * a;\n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 371], [430, 430, 487, 487, 1301]], "test": "untested"}
{"id": "4tlSD2", "name": "Red Cube Hell", "author": "metabog", "description": "Dude wtf. ", "tags": ["raymarching"], "likes": 1, "viewed": 142, "published": "Public", "date": "1439837166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraOrigin = vec3(cos(iTime*0.02)*50.0,cos(iTime*0.05)*50.0,sin(iTime*0.02)*50.0); //vec3(2.0, 7.0, 2.0);\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\nvec3 cameraDir = normalize(cameraTarget - cameraOrigin);\nvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\nvec3 cameraUp = cross(cameraDir, cameraRight);\n\nvec3 lightPosition = vec3(cos(iTime*1.0)*50.0,50.0,sin(iTime*0.3)*50.0);\n\nconst int MAX_ITER = 100; // 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\nconst float MAX_DIST = 100.0; // Make sure you change this if you have objects farther than 20 units away from the camera\nconst float EPSILON = 0.02; // At this distance we are close enough to the object that we have essentially hit it\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n//A hollowed out sphere\nfloat insideOutSphere(vec3 pos, float radius)\n{\n    return radius-length(pos);\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat distfunc(vec3 pos)\n{\n    \n    pos.x = mod(pos.x,10.0) - 5.0;\n    pos.y = mod(pos.y,10.0) - 5.0;\n    pos.z = mod(pos.z,10.0) - 5.0;\n    \n    float value =0.0;\n    \n    value = box(pos,vec3(0.5,0.5,0.5));\n    value = min(value, insideOutSphere(vec3(0.0,0.0,0.0),100.0));\n    return value;\n}\n\nvec4 evaluate(vec2 uv)\n{\n     float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n    \n    \n    \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * (uv.y) + cameraDir);\n    \n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    \n    bool hasHitOnce = false;\n    \n    int hitTimes = 1;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n\t{\n        \n        if(totalDist>MAX_DIST)\n            break;\n        \n        \n    \t\t// Either we've hit the object or hit nothing at all, either way we should break out of the loop\n   \t\t if ((dist < EPSILON) )\n   \t\t {\n        \tvec2 eps = vec2(0.0, EPSILON);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   \t\t\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n   \t\t\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n    \n             \n            //let's fuck with the normals a bit\n             normal.x += texture(iChannel0, vec2(pos.x,pos.z)*0.1).x*0.1;\n             normal.y += texture(iChannel0, vec2(pos.y,pos.z)*0.1).x*0.1;\n             normal.z += texture(iChannel0, vec2(pos.z,pos.x)*0.1).x*0.1;\n\n             vec3 lightVec = normalize(pos - lightPosition);\n             \n   \t\t\tfloat diffuse = max(0.0, dot(-lightVec, normal));\n    \t\tfloat specular = pow(diffuse, 64.0);\n        \tfloat value = diffuse*0.6;\n             vec4 hitcolor = hsv2rgb(vec3(totalDist/100.0,1.0,1.0)).xyzz*value + specular*0.002;\n    \t\n             color = hitcolor/float(hitTimes);\n       \t \thasHitOnce = true;\n             \n            rayDir = 2.0 * dot(rayDir,normal)*normal - rayDir;\n            pos += rayDir*5.0;\n             totalDist = 0.0;\n\t\t\t dist = EPSILON;\n             \n             hitTimes++;\n             if(hitTimes==3)\n                 break;\n   \t\t }\n        \n   \n        \n        \n    \tdist = distfunc(pos); // Evalulate the distance at the current point\n    \ttotalDist += dist;\n    \tpos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n\t}\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv*=0.1; //FOV\n    uv.x*= iResolution.x /iResolution.y;\n\n    \n   vec4 col = evaluate(uv);\n\n       //  uncomment for smoother rendering if your pc can take it.. mine can't\n    /*\n   vec4 col = (evaluate(uv) + evaluate(uv + vec2(0.0001,0.0))\n       + evaluate(uv + vec2(-0.0001,0.0))\n       + evaluate(uv + vec2(0.0,0.0001))\n       + evaluate(uv + vec2(0.0,-0.0001))\n       + evaluate(uv + vec2(0.0001,-0.0001))\n       + evaluate(uv + vec2(-0.0001,0.0001))\n       + evaluate(uv + vec2(0.0001,-0.0001)))/8.0;\n    */\n    \n\t\tfragColor = col;\n\n\t\n\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[463, 792, 814, 814, 1145], [1147, 1147, 1169, 1169, 1338], [1341, 1341, 1379, 1379, 1414], [1416, 1440, 1487, 1487, 1520], [1522, 1522, 1554, 1554, 1602], [1604, 1604, 1630, 1630, 1898], [1900, 1900, 1924, 1924, 3901], [3903, 3903, 3960, 3960, 4577]], "test": "untested"}
{"id": "4tlSWl", "name": "Steel Lattice", "author": "Shane", "description": "The lattice structure in this example is really simple to construct, and represents just one of infinitely many combinations.", "tags": ["fire", "blackbody", "steel", "lattice"], "likes": 152, "viewed": 19912, "published": "Public API", "date": "1440598001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Steel Lattice\n    -------------\n    \n    Shadertoy user FabriceNeyret2's \"Crowded Pillars 3\" inspired me to dig up some old\n    \"lattice with holes\" code. Here's the link to his particular example: \n    https://www.shadertoy.com/view/4lfSDn\n    \n    The lattice structure in this example is really simple to construct, and represents \n    just one of infinitely many combinations. I was going for that oldschool, 3D-tube \n\tscreensaver look and had originally hoped to set the thing ablaze.\n\n\tUnfortunately, I couldn't achieve even mild realism whilst maintaining a decent \n\tframerate, so have copped out and settled for a very subtle reflective firey afterglow. \n\tI haven't given up on the original idea, though.\n    \n\tThere's a whole bunch of notes in there. Probably too many, but hopefully, someone\n\twill find some of it useful. I spent far too long reading up on blackbody radiation, \n\tthen barely used it. Typical. :)\n\n\tIf anyone spots any errors, feel free to let me know.\n\n*/\n\n#define FIRE_REFLECTION // Comment this out, to get rid of the reflective afterglow.\n\n#define sEPS 0.005 // Minimum surface distance threshold.\n#define FAR 20. // Maximum ray distance threshold.\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n\n// 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    //n = abs(n)/1.732051;\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n// I just wanted a simple function to produce some firey blackbody colors with a simple explanation \n// to go with it, but computer nerds who write academic papers never make it easy. :) Anyway, to save \n// someone else the trouble, here's some quick, but messy, notes.\n//\n// The paper located here was pretty helpful. Mind numbingly boring, but helpful:\n// http://www.spectralcalc.com/blackbody/CalculatingBlackbodyRadianceV2.pdf\n// So was this:\n// http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/blackbody/spectrum-of-blackbodies/\n//\n// If wasting time reading though countless webpages full of physics and mathematics that never get to \n// the point isn't your thing, then this Shadertoy example should be far more accommodating:\n// User - Bejit: https://www.shadertoy.com/view/MslSDl\nvec3 blackbodyPalette(float t){\n\n    // t = tLow + (tHigh - tLow)*t;\n    t *= 4000.; // Temperature range. Hardcoded from 0K to 4000K, in this case. \n    \n    // Planckian locus or black body locus approximated in CIE color space... Color theory is not my thing,\n    // but I think below is a conversion of the physical temperture (t) above (which has no meaning to a \n    // computer) to chromacity coordinates. \n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    // Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\n    \n    // Converting XYZ color space to RGB. Note: Below are the transpose of the matrices you'll find all over the \n    // web, because I'm placing XYZ after the conversion matrix, and not before it. If you're getting the wrong\n    // colors, that's probably the reason. I found that out the hard way. :) \n    // http://www.cs.rit.edu/~ncs/color/t_spectr.html\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\n                    \n    // Alternative conversion matrix: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    // mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);\n\n    // Apply StefanBoltzmann's law to the RGB color, and we're done. \n    // \n    // Appendix A: Algorithms for Computing In-band Radiance.\n    // http://www.spectralcalc.com/blackbody/CalculatingBlackbodyRadianceV2.pdf\n    // Planck*Light/Boltzman = 0.01438767312;\n    // Planck*Light*Light*2. = 1.1910428e-16;\n    //\n    // Whoever went through the trouble to use the real algorithm to come up with the estimate of 0.0004, \"Thank you!\" :)\n    // The last term relates to the power radiating through the surface... or something to that effect.\n    // Some RGB values fall a little below zero, so I've had to rectify that.\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n ){\n    \n    // Placing raised box-like bumps all over the structure.\n    p = abs(mod(p, 0.0625)-0.03125);\n    float x = min(p.x,min(p.y,p.z))/0.03125;\n    // More even alternative, but not the look I was after.\n    //float x = (0.03125-max(p.x,max(p.y,p.z)))/0.03125*1.25;\n    \n    // More intricate detail.\n    //x = sin(x*1.57+sin(x*1.57)*1.57)*0.5 + 0.5; \n\n    // Very, very lame, but cheap, smooth noise for a bit of roughness. The frequency is \n    // high and the amplitude is very low, so the details won't be discernible enough to \n    // necessitate a real noise algorithm.\n    p = sin(p*380.+sin(p.yzx*192.+64.));\n    float surfaceNoise = (p.x*p.y*p.z);\n\n    return clamp(x + surfaceNoise*0.05, 0., 1.);//x*32. + //To accentuate x*2./0.03125, etc\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = 0.001;\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = vec3( bumpSurf3D(vec3(p.x-eps, p.y, p.z), nor)-ref,\n                      bumpSurf3D(vec3(p.x, p.y-eps, p.z), nor)-ref,\n                      bumpSurf3D(vec3(p.x, p.y, p.z-eps), nor)-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n\n// Shadertoy user FabriceNeyret2's \"Crowded Pillars 3\" inspired me to dig up some old\n// \"lattice with holes\" code. Here's the link: https://www.shadertoy.com/view/4lfSDn\n//\n// The technique used here is pretty common: Produce two, or more, repeat field objects, \n// lattices - or whatever you'd like - at different repeat frequencies, then combine them \n// with either a standard operation (min(x1, x2), max(x1, -x2), etc) or something less \n// standard, like the one I've used below (sqrt(x1*x1+x2*x2)-.05). The possibilities are\n// endless. Menger cubes, and the like, are constructed using a similar method.\n//\n// For anyone who wants to experiment, use one line from each of the three sections.\n// There are 24 different combinations all up, and I've probably chosen the least\n// interesting one. :)\nfloat map(vec3 p){\n \n    // SECTION 1\n    //\n    // Repeat field entity one, which is just some tubes repeated in all directions every \n    // two units, then combined with a smooth minimum function. Otherwise known as a lattice.\n    p = mod(p, 2.)-1.;\n    float x1 = sminP(length(p.xy),sminP(length(p.yz),length(p.xz), 0.25), 0.25)-0.5; // EQN 1\n    //float x1 = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-0.5; // EQN 2\n    //p = abs(p); float x1 = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.5; // EQN 3\n\n    // SECTION 2\n    //\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p, 0.5)-0.25);\n    float x2 = min(p.x,min(p.y,p.z)); // EQN 1\n    //float x2 = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.125; //-0.175, etc. // EQN 2\n    \n    // SECTION 3\n    //\n    // Combining the two entities above.\n    return sqrt(x1*x1+x2*x2)-.05; // EQN 1\n    //return max(x1, x2)-.05; // EQN 2\n    \n}\n\n// Standard ray marching function: I included some basic optimization notes. I know\n// most of it is probably obvious to many, but I thought some might find it useful.\nfloat raymarch(vec3 ro, vec3 rd) {\n\t\n\t// Surface distance and total ray distance.\n\tfloat d, t = 0.0;\n    \n    // More iterations means a chance to gain more accuracy, but should be the lowest\n    // possible number that will render as many scene details as possible.\n    for (int i = 0; i < 128; i++){\n        // Surface distance.\n        d = map(ro + rd *t);\n        \n        // If the distance is less than the surface distance threshold (sEPS), or \n        // further than the maximum ray distance threshold (FAR), exit.\n        //\n        // An early exit can mean the difference between, say, 20 map calls and the \n        // maximum iteration count (128, in this case). In general, you want the \n        // largest sEPS and smallest FAR value that will facilitate an accurate scene. \n        // Tweaking these two figures is an artform. sEPS values ranging from 0.001 \n        // to 0.05 tend to work. However, smaller numbers can kill framerate, in some \n        // cases. I tend to favor 0.005 and 0.01. For the FAR value, it depends on \n        // the scene.\n        if (d<sEPS || t>FAR) break;  \n        \n        // Add a portion of the surface distance (d) to the total ray distance (t).\n        //\n        // Sometimes, the ray can overshoot, so decreasing the jump distance \"d\" can \n        // help give more accuracy. Of course, the downside is more iterations,\n        // which in turn, reduces framerate. Tweaking these numbers is also an artform.\n        // Anywhere between 0.5 (if accuracy is really necessary) and 1.0 works for\n        // me. 0.75 is a good compromise.\n        t += d*0.75;\n    }\n    \n    return t;\n}\n\n// Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n// The iterations should be higher for proper accuracy, but in this case, the shadows are a subtle background feature.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; // 24 or 32 would be better.\n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        \n        // I'm always torn between local shadowing (clamp(h, 0.0005, 0.2), etc) and accounting for shaowing from\n        // distant objects all the way to the light source. If in doubt, local shadowing is probably best, but\n        // here, I'm trying to do the latter.\n        dist += clamp(h, 0.0005, stepDist*2.); // The best of both worlds... I think. \n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow slightly. It's a preference thing. Really dark\n    // shadows look too brutal to me.\n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n// Standard normal function.\nvec3 getNormal(in vec3 p) {\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\n// Curvature function, which Shadertoy user Nimitz wrote. I've hard-coded this one to\n// get just the range I want. Not very scientific at all.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values. Almost common sense... almost. :) If anyone \n// could provide links to some useful articles on the function, I'd be greatful.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    vec2 e = vec2(-1., 1.)*0.05; //0.05->7. - 0.04->11. - 0.03->20.->0.1->2.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 7. * (t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.y;\n    \n    // No camera setup. Just lazily heading straight to the unit direction vector.\n    vec3 rd = normalize(vec3(uv, 0.5));\n    //vec3 rd = normalize(vec3(uv, sqrt(1.-dot(uv, uv))*0.5)); // Mild fish lens, if you'd prefer.\n    \n    // Rotating the unit direction vector about the XY and XZ places for a bit of a look around.\n    rd.xy *= rot(iTime*0.5);\n    rd.xz *= rot(iTime*0.25); // Extra variance.\n    \n    // Ray origin. Set off linearly in the Z-direction. A bit of a lattice cliche, but effective.\n    vec3 ro = vec3(0.0, 0.0, iTime*1.0);\n    //vec3 ro = vec3(0.5 + iTime*0.7, 0.0, iTime*0.7); // Another lattice traversal cliche.\n    \n    // Light position. Rotated a bit, then placed a little above the viewing position.\n    vec3 lp = vec3(0.0, 0.125, -0.125);\n    lp.xy *= rot(iTime*0.5);\n    lp.xz *= rot(iTime*0.25);\n    lp += ro + vec3(0.0, 1.0, 0.0);\n    \n    // Initiate the scene color to black.\n    vec3 sceneCol = vec3(0.);\n    \n    // Distance to the surface in the scene.\n    float dist = raymarch(ro, rd);\n    \n    // If the surface has been hit, light it up.\n    if (dist < FAR){\n\n        // Surface point.\n        vec3 sp = ro + rd*dist;\n        \n        // Surface normal.\n        vec3 sn = getNormal(sp);\n        \n    \t\n\t    // Standard function-based bump map - as opposed to texture bump mapping. It's possible to \n\t    // taper the bumpiness (last term) with distance, using something like: 0.0125/(1.+dist*0.125).\n\t    sn = doBumpMap(sp, sn, 0.01);\n    \t\n    \t\n\t    // Light direction vector.\n\t    vec3 ld = lp-sp;\n\n        // Object color at the surface point.\n\t    vec3 objCol = tex3D( iChannel0, sp, sn );\n\t    // Using the bump function to shade the surface a bit more to enhance the bump mapping a little.\n\t    // Not mandatory, but I prefer it sometimes.\n\t    objCol *= bumpSurf3D(sp, sn)*0.5 + 0.5;\n    \t\n\n\t    float lDist = max(length(ld), 0.001); // Distance from the light to the surface point.\n\t    ld /= lDist; // Normalizing the light-to-surface, aka light-direction, vector.\n\t    float atten = min( 1.0 /( lDist*0.5 + lDist*lDist*0.1 ), 1.0 ); // Light falloff, or attenuation.\n    \t\n\t    float ambient = .25; //The object's ambient property. You can also have a global and light ambient property.\n\t    float diffuse = max( 0.0, dot(sn, ld) ); //The object's diffuse value.\n\t    float specular = max( 0.0, dot( reflect(-ld, sn), -rd) ); // Specular component.\n\t    specular = pow(specular, 8.0); // Ramping up the specular value to the specular power for a bit of shininess.\n\t    \n\t    // Soft shadows. I really cheaped out on the iterations, so the shadows are not accurate. Thankfully, \n\t    // they're not a dominant feature, and everything's moving enough so that it's not really noticeable.\n\t    float shadow = softShadow(sp, ld, sEPS*2., lDist, 32.);\n\t    // Ambient occlusion.\n        float ao = calculateAO(sp, sn)*0.5 + 0.5;\n    \t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n\n        #ifdef FIRE_REFLECTION\n        // The firey reflection: Not very sophisticated. Use the relected vector to index into a\n        // moving noisey texture, etc, to obtain a reflective shade value (refShade). Combine it\n        // with the surface curvature (crv - higher curvature, more reflective heat... probably), \n        // then feed the result into a blackbody palette function to obtain the reflective color. \n        // It's mostly made up, with a tiny bit of science thrown in, so is not meant to be taken \n        // seriously.\n        \n        // Surface reflection vector.\n        vec3 sf = reflect(rd, sn);\n        \n        // Curvature. This function belongs to Shadertoy user Nimitz.\n\t    float crv = clamp(curve(sp), 0., 1.);\n        \n        float refShade = getGrey(tex3D( iChannel1, sp/4. + iTime/64., sf ));\n        refShade = refShade*0.4 + max(dot(sf, vec3(0.166)), .0);\n        vec3 refCol = blackbodyPalette(refShade*(crv*0.5+0.5));\n        #endif\n\n    \t// Combining the terms from above in a pretty standard way to produce the final color.\n\t    sceneCol = objCol*(vec3(1., 0.97, 0.92)*diffuse + ambient)  + vec3(1.,0.9,0.92)*specular*0.75;\n\t    #ifdef FIRE_REFLECTION\n\t    // Add the subtle relected firey afterglow.\n\t    sceneCol += refCol; //*(diffuse + ambient + specular*0.75);\n\t    #endif\n\t    \n\t    // Shading the color.\n\t    sceneCol *= atten*ao*shadow;\n\t\n\t}\n\n  \t// Done! No gamma correction - I wouldn't recommend it. :)\n\tfragColor = vec4(clamp(sceneCol, 0., 1.), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1187, 1202, 1224, 1224, 1268], [1271, 1411, 1460, 1460, 1570], [1573, 1603, 1622, 1622, 1688], [1691, 1845, 1895, 1925, 2122], [2125, 2926, 2957, 2994, 5225], [5227, 5291, 5332, 5398, 6089], [6091, 6141, 6198, 6198, 6643], [6645, 7450, 7468, 7679, 8440], [8442, 8610, 8644, 8691, 10247], [10249, 10277, 10311, 10311, 10553], [10555, 10674, 10742, 10742, 12968], [12970, 12999, 13026, 13026, 13254], [13256, 13813, 13836, 13836, 14079], [14081, 14081, 14138, 14166, 18779]], "test": "untested"}
{"id": "4tlSzl", "name": "Combustible Voronoi", "author": "Shane", "description": "The effect itself is nothing new or exciting, just some moving 3D Voronoi layering. However, the fire palette might prove useful to some.", "tags": ["voronoi", "fire"], "likes": 206, "viewed": 13342, "published": "Public API", "date": "1439902848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    Combustible Voronoi Layers\n\t--------------------------\n\n    The effect itself is nothing new or exciting, just some moving 3D Voronoi layering. \n    However, the fire palette might prove useful to some.\n\n*/\n\n\n// This is my favorite fire palette. It's trimmed down for shader usage, and is based on an \n// article I read at Hugo Elias's site years ago. I'm sure most old people, like me, have \n// visited his site at one time or another:\n//\n// http://freespace.virgin.net/hugo.elias/models/m_ffire.htm\n//\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5)) * (exp(1.43876719683e5/(T*L)) - 1.);\n    return 1. - exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n/*\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    // Hardcode red, green and blue wavelengths (in hundreds of nanometers).\n    vec3 L = (exp(vec3(19442.7999572, 25692.271372, 32699.2544734)/T) - 1.);\n    // Exposure level. Set to \"50\" For \"70,\" change the \".5\" to a \".7,\" etc.\n    return 1. - exp(-vec3(22532.6051122, 90788.296915, 303184.239775)*2.*.5/L); \n}\n*/\n\n// Hash function. This particular one probably doesn't disperse things quite as nicely as some \n// of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// 3D Voronoi: Obviously, this is just a rehash of IQ's original.\n//\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\t\n\t// Maximum value: I think outliers could get as high as \"3,\" the squared diagonal length \n\t// of the unit cube, with the mid point being \"0.75.\" Is that right? Either way, for this \n\t// example, the maximum is set to one, which would cover a good part of the range, whilst \n\t// dispensing with the need to clamp the final result.\n\tfloat d = 1.; \n     \n    // I've unrolled one of the loops. GPU architecture is a mystery to me, but I'm aware \n    // they're not fond of nesting, branching, etc. My laptop GPU seems to hate everything, \n    // including multiple loops. If it were a person, we wouldn't hang out. \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat noiseLayers(in vec3 p) {\n\n    // Normally, you'd just add a time vector to \"p,\" and be done with \n    // it. However, in this instance, time is added seperately so that \n    // its frequency can be changed at a different rate. \"p.z\" is thrown \n    // in there just to distort things a little more.\n    vec3 t = vec3(0., 0., p.z + iTime*1.5);\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t) * amp; // Add the layer to the total.\n        p *= 2.; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= .5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n\t\n\t// Shifting the central position around, just a little, to simulate a \n\t// moving camera, albeit a pretty lame one.\n\tuv += vec2(sin(iTime*.5)*.25, cos(iTime*.5)*.125);\n\t\n    // Constructing the unit ray. \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\n    // Rotating the ray about the XY plane, to simulate a rolling camera.\n\tfloat cs = cos(iTime*.25), si = sin(iTime*.25);\n    // Apparently \"r *= rM\" can break in some older browsers.\n\trd.xy = rd.xy*mat2(cs, -si, si, cs); \n\t\n\t// Passing a unit ray multiple into the Voronoi layer function, which \n\t// is nothing more than an fBm setup with some time dialation.\n\tfloat c = noiseLayers(rd*2.);\n\t\n\t// Optional: Adding a bit of random noise for a subtle dust effect. \n\tc = max(c + dot(hash33(rd)*2. - 1., vec3(.015)), 0.);\n\n    // Coloring:\n    \n    // Nebula.\n    c *= sqrt(c)*1.5; // Contrast.\n    vec3 col = firePalette(c); // Palettization.\n    //col = mix(col, col.zyx*.1+ c*.9, clamp((1.+rd.x+rd.y)*0.45, 0., 1.)); // Color dispersion.\n    col = mix(col, col.zyx*.15 + c*.85, min(pow(dot(rd.xy, rd.xy)*1.2, 1.5), 1.)); // Color dispersion.\n    col = pow(col, vec3(1.25)); // Tweaking the contrast a little.\n    \n    // The fire palette on its own. Perhaps a little too much fire color.\n    //c = pow(c*1.33, 1.25);\n    //vec3 col =  firePalette(c);\n   \n    // Black and white, just to keep the art students happy. :)\n\t//c *= c*1.5;\n\t//vec3 col = vec3(c);\n\t\n\t// Rough gamma correction, and done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 512, 538, 538, 862], [1278, 1439, 1459, 1459, 1568], [1570, 1639, 1661, 1661, 2766], [2768, 2966, 2996, 3269, 3807], [3809, 3809, 3866, 3893, 5470]], "test": "untested"}
{"id": "4tlSzs", "name": "cmyk waves", "author": "nexor", "description": "It really needs some optimizations, feel free to comment your suggestions to increase the speed of the for loop!", "tags": ["noise", "fbm", "cmyk"], "likes": 8, "viewed": 399, "published": "Public API", "date": "1439024659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time;\nvec2 resolution;\n\nvoid init()\n{\n time = iTime;\n resolution = iResolution.xy;   \n}\n\nconst float pi = 3.14156;\nconst float pi2 = pi*2.0;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.8, -0.6, 0.6, 0.8 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.x *= resolution.x/resolution.y;\n\t return p;\n}\n\nvec2 rot(vec2 p, float deg)\n{\n\tfloat c = cos(deg);\n\tfloat s = sin(deg);\n\tmat2 m = mat2(c,s,\n\t\t   \t\t\t\t\t\t\t\ts,-c);\n\treturn m*p;\n}\n\nfloat circle(vec2 p, float r)\n{\n\t return smoothstep(r,r*.99,length(p));\n}\n\nvec4 cmyk(vec2 p, float a, float r)\n{\n  vec2 b = rot(p,a);\n  vec2 q = mod(b,r)-r*.5;\n  return vec4(q,floor(p/r));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    init();\n\tvec2 p = tr(fragCoord.xy);\n\tvec4 col = vec4(1.0);\n\n    float t = time*.125;\n    float g = .0175;\n\n\tp+=vec2(1.0); //strange artifact at (0,0)\n    \n    /*\n    cmyk will be created by subtracting rgb from white, so \n    Red->Cyan\n    Green->Magenta\n    Blue->Yellow\n    white->blacK\n    */\n    vec4 rv = vec4(15.,75,0.,45.); //rotation values for each channel\n     \n    \n    p*=4.;\n    p+=t;\n\n    float r = 0.1;\n    float a=0.0;\n    for(int i=0;i<4;++i)\n    {\n    \t a = rv[i];\n    \t p=rot(p,a);\n    \t vec4 ht = cmyk(p,a,r);\n    \t float rad = fbm(fbm(.25*p-t)*.25*ht.zw+t*5.)*r*.5;\n    \t float val = circle(ht.xy,rad);\n    \t col[i] = 1.-val;\n    }\n    col.rgb -= 1.-col.a; //use black color (still looks fine without it)\n\tcol = sqrt(col);\n\n    fragColor = vec4( col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 43, 43, 93], [148, 148, 171, 171, 213], [215, 215, 241, 241, 460], [508, 508, 529, 529, 728], [730, 730, 747, 747, 837], [839, 839, 868, 868, 965], [967, 967, 998, 998, 1040], [1042, 1042, 1079, 1079, 1157], [1159, 1159, 1214, 1214, 1993]], "test": "untested"}
{"id": "4tlXWs", "name": "Room scanning effect", "author": "rosme", "description": "Trying to reproduce the room scanning effect as seen in hololens demonstration. See https://www.youtube.com/watch?v=aYdB2xBNFek&t=60", "tags": ["raymarching", "hololens"], "likes": 39, "viewed": 1710, "published": "Public", "date": "1440667436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on shaders:\n// Template - 3D \t\t\thttps://www.shadertoy.com/view/ldfSWs\n// Xor - Triangle Grid, \thttps://www.shadertoy.com/view/4tSGWz\n\n#define pi 3.14159265358979\n#define size 0.5\n#define reciproce_sqrt3 0.57735026918962576450914878050196\n#define lineThickness 0.01\n\nfloat planeDistance = 0.2;\nfloat offset;\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    //float an = 0.0*iTime + se.x;\n\t//camPos = vec3(0.0, 2.0, 5.0);\n    camPos = vec3(3.5*sin(mouse.x*10.0), 1.0, 5.0*cos(mouse.x*10.0));\n    \n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.1);\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    \n    return  min(udRoundBox(p -vec3(1.05,-0.5, 0.4), vec3(0.05, 0.4, 0.5), 0.1),\n\t\t\tmin(udRoundBox(p -vec3(-1.05,-0.5, 0.4), vec3(0.05, 0.4, 0.5), 0.1),                \n        \tmin(udRoundBox(p, vec3(0.8, 0.3, 0.1), 0.1),\n        \tmin(udRoundBox(p -vec3(0.0,-0.5, 0.6), vec3(0.8, 0.1, 0.3), 0.1), \n            min(sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0)), sdPlane(p, vec4(0.0, 0.0, 1.0, 2.0)))))));\n}\n\nfloat r(float n)\n{\n \treturn fract(abs(sin(n*55.753)*367.34));   \n}\n\nfloat r(vec2 n)\n{\n    return r(dot(n,vec2(2.46,-1.21)));\n}\n\nvec3 smallTrianglesColor(vec3 pos)\n{\n    float a = (radians(60.0));\n    float zoom = 0.5;\n\tvec2 c = (pos.xy + vec2(0.0, pos.z)) * vec2(sin(a),1.0);//scaled coordinates\n    c = ((c+vec2(c.y,0.0)*cos(a))/zoom) + vec2(floor((c.x-c.y*cos(a))/zoom*4.0)/4.0,0.0);//Add rotations\n    float type = (r(floor(c*4.0))*0.2+r(floor(c*2.0))*0.3+r(floor(c))*0.5);//Randomize type\n    type += 0.2 * sin(iTime*5.0*type);\n    \n    float l = min(min((1.0 - (2.0 * abs(fract((c.x-c.y)*4.0) - 0.5))),\n        \t      (1.0 - (2.0 * abs(fract(c.y * 4.0) - 0.5)))),\n                  (1.0 - (2.0 * abs(fract(c.x * 4.0) - 0.5))));\n    l = smoothstep(0.06, 0.04, l);\n\t\n\treturn mix(type, l, 0.5) * vec3(0.2,0.5,1);\n} \n\nvec3 largeTrianglesColor(vec3 pos)\n{\n    float a = (radians(60.0));\n    float zoom = 2.0;\n\tvec2 c = (pos.xy + vec2(0.0, pos.z)) * vec2(sin(a),1.0);//scaled coordinates\n    c = ((c+vec2(c.y,0.0)*cos(a))/zoom) + vec2(floor((c.x-c.y*cos(a))/zoom*4.0)/4.0,0.0);//Add rotations\n    \n    float l = min(min((1.0 - (2.0 * abs(fract((c.x-c.y)*4.0) - 0.5))),\n        \t      (1.0 - (2.0 * abs(fract(c.y * 4.0) - 0.5)))),\n                  (1.0 - (2.0 * abs(fract(c.x * 4.0) - 0.5))));\n    l = smoothstep(0.03, 0.02, l);\n\t\n\treturn mix(0.01, l, 0.5) * vec3(0.2,0.5,1);\n}\n   \nvec3 gridColor(vec3 pos)\n{\n    float plane5 = abs(sdPlane(pos, vec4(1.0, 0.0, 0.0, 0)));\n    float plane6 = abs(sdPlane(pos, vec4(0.0, 1.0, 0.0, 0)));\n    float plane7 = abs(sdPlane(pos, vec4(0.0, 0.0, 1.0, 0)));\n\n    float   nearest = abs(mod(plane5, planeDistance) - 0.5 * planeDistance);\n    nearest = min(nearest, abs(mod(plane6, planeDistance) - 0.5 * planeDistance));\n    nearest = min(nearest, abs(mod(plane7, planeDistance) - 0.5 * planeDistance));\n\n    return mix(vec3(0.3, 0.3, 0.5), vec3(0.2), smoothstep(0.0, lineThickness, nearest));\n}\n\n \n//---------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n\tfloat d = length(pos.xz - vec2(0.0, 2.0) + 0.5*cos(2.0*pos.xz + vec2(3.0, 1.0) * iTime)) +  pos.y + 0.2 * cos(pos.y - iTime);\n    float border = 12.0 * mod(iTime * 0.2, 1.0);\n \n    //vec3 c = gridColor(pos);\n    vec3 c1 = largeTrianglesColor(pos);\n    vec3 c = smallTrianglesColor(pos);\n    c *= smoothstep(border - 1.0, border - 2.5, d);\n    c += c1;\n    c = mix(c, vec3(0.01), smoothstep(border - 4.0, border - 10.0, d));\n    c = mix(c, vec3(0.01), smoothstep(border - 1.0, border, d));\n    c = mix(c, vec3(0.01), smoothstep(9.0, 12.0, border));\n    \n    return c;\n} \n//------------------------------------------------------------------------\n// Lighting \n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //planeDistance = sin(iTime);\n    offset = 2.0 * sqrt(2.0) / sqrt(24.0);\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.5) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 649, 730, 798, 907], [910, 1141, 1168, 1168, 1203], [1206, 1206, 1239, 1265, 1296], [1299, 1299, 1344, 1344, 1384], [1386, 1668, 1693, 1693, 2095], [2097, 2097, 2115, 2115, 2163], [2165, 2165, 2182, 2182, 2223], [2225, 2225, 2261, 2261, 2913], [2916, 2916, 2952, 2952, 3473], [3478, 3478, 3504, 3504, 4026], [4030, 4374, 4419, 4419, 4989], [4991, 5203, 5287, 5287, 5863], [5865, 5865, 5915, 5915, 6332], [6334, 6334, 6366, 6366, 6778], [6780, 6780, 6828, 6828, 7254], [7256, 7256, 7320, 7320, 7498], [7500, 7500, 7557, 7591, 8833]], "test": "untested"}
{"id": "4tlXzX", "name": "Chocolate Coating", "author": "kynd", "description": "-", "tags": ["raymarching", "shadow", "metaball"], "likes": 2, "viewed": 215, "published": "Public", "date": "1438565017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define t iTime\n#define res iResolution.xy\n\nvec3 cpos = vec3(0.0, 5.0, 5.0);\nvec3 cside = vec3(1.0, 0.0, 0.0);\nvec3 light = normalize(vec3(0.6, 0.6, 1.0));\n\nfloat smoothen(float d1, float d2) {\n    float k = 1.5;\n    return -log(exp(-k * d1) + exp(-k * d2)) / k;\n}\n\nfloat dist(vec3 p){\n    float d = 100.0, r = 4.0;\n    for (int i = 0; i < 5; i ++) {\n        float m = 1.5 + float(i) * 0.4;\n        d = smoothen(d, length(p - vec3(cos(t * m) * r, sin(t * m) * r, 0.0)) - 1.0);\n    }\n    d = smoothen(d, dot(p, vec3(0.0, 1.0, 0.0)) + 4.0);\n    return d;\n}\n\n\nvec3 norm(vec3 p){\n\tvec2 d = vec2(0.001, 0.0);\n    float di = dist(p);\n\treturn normalize(vec3(di - dist(p - d.xyy), di - dist(p - d.yxy), di - dist(p - d.yyx)));\n}\n\nfloat shadow(vec3 o, vec3 d){\n    o += norm(o) * 0.001;\n\tfloat len = 0.0, lev = 1.0;\n\tfor(float t = 0.0; t < 32.0; t++){\n\t\tfloat di = dist(o + d * len);\n\t\tif (di < 0.001){ return 0.5;}\n\t\tlev = min(lev, di  * 8.0 / min(len, 1.0));\n\t\tlen += di;\n\t}\n\treturn max(0.5, lev) ;\n}\n\nvec3 phong(vec3 p, vec3 ray) {\n    vec3 n = norm(p);\n    return vec3(0.35,0.2,0.1) * clamp(dot(light, n), 0.0, 1.0)\n\t\t+ pow(clamp(dot(normalize(light - ray), n), 0.0, 1.0), 128.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\nvec3 cdir = normalize(-cpos);\nvec3 cup  = cross(cside, cdir);\n\tvec2 p = (fragCoord.xy * 2.0 - res) / min(res.x, res.y);\n\tvec3 ray = normalize(cside * p.x + cup * p.y + cdir * 2.0);\n\n\tfloat len = 0.0, di;\n\tvec3 rhead = cpos;\n\tfor(int i = 0; i < 64; i++){\n\t\tdi = dist(rhead);\n        if (abs(di) < 0.001) {\n            break;\n        }\n\t\tlen += di;\n\t\trhead = cpos + len * ray;\n\t}\n\n\tvec3 color;\n\tif(abs(di) < 0.001){\n        color = phong(rhead, ray) * shadow(rhead, light);\n\t} \n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 222, 222, 293], [295, 295, 314, 314, 583], [586, 586, 604, 604, 749], [751, 751, 780, 780, 1022], [1024, 1024, 1054, 1054, 1206], [1208, 1208, 1263, 1263, 1772]], "test": "untested"}
{"id": "4tsSDj", "name": "rgb spirals", "author": "JamesHagerman", "description": "Not sure what this will look like on the car due to all the polar coordinate shifting going on... but it'd be worth trying!", "tags": ["sensatron"], "likes": 1, "viewed": 109, "published": "Public", "date": "1439879527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    float PI = 3.14159;\n    float numArms = 2.0;\n    float spiralAngle = PI/3.0;\n    \n    float cX = uv.x - 0.5;\n    float cY = uv.y - 0.5;\n    \n    float newX = sqrt(cX*cX + cY*cY);\n    float newY = atan(cX, cY);\n    \n    float color = 0.0;\n    color += uv.x+cos(5.0*iTime);\n\tcolor += cos(2.0*numArms*(newX*sin(spiralAngle) + newY*cos(spiralAngle)) + iTime);\n    \n    vec3 hsvd = hsv2rgb_smooth(vec3(color, 1.0, 1.0));\n    \n\tfragColor = vec4(hsvd ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 210], [213, 213, 270, 270, 779]], "test": "untested"}
{"id": "4tXSDB", "name": "City of Mod", "author": "squid", "description": "Insane. Also, this is a scary city to drive in. Bloom is for if you have a really good graphics card. Inspired by: https://www.youtube.com/watch?v=-d2-PtK4F6Y", "tags": ["3d", "raymarch", "mod", "bloom", "city"], "likes": 13, "viewed": 561, "published": "Public", "date": "1439336568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//City of Mod by squid\n\n//I get 6.2fps in windowed mode with bloom on & 120steps + cars + background (ffx windows10 no angle, on R9 290X)\n//\t\t1.4fps same setup but with cars+background\n//#define BLOOM\n// for BLOOM_RAD, lower numbers work, but because of the lower radius, the bloom is less obvious\n#define BLOOM_RAD 8 \n\n//camera zoom for autorotate/mouse mode\n#define ZOOM 90.\n\n//time+mouse rotates camera\n// turn off but path off as well => mouse movment\n//#define CAMERA_AUTOROTATE\n\n//camera goes on a ride\n#define CAMERA_PATH\n\n#ifdef BLOOM\n//steps for bloom on\n#define STEPS 120\n#else\n//steps for bloom off\n#define STEPS 500\n#endif\n\n//turn on/off the cars\n#define CARS\n//turn on/off background+moon\n#define COOL_BACKGROUND\n\n#define GRADIENT_DELTA 0.5\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iTime\n#define size iResolution\n\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n#ifdef COOL_BACKGROUND\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#endif\n\nvec2 opU(vec2 d1, vec2 d2) { return (d1.x<d2.x)?d1:d2; }\nvec3 opU( vec3 d1, vec3 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#ifdef CARS\nvec3 cars(in vec3 p) {\n    float h1 = hash11(floor((p.x-6.8)/13.));\n    p.z += iTime*5. + h1*120.;\n    vec4 hh = hash41(floor(p.z/3.));\n    if(hh.x > .07) return vec3(9e9, 0., 0.);\n    p.x -= 6.7+sin(hh.y*6.)*.1;\n    p.x = mod(p.x, 13.) - (13.*.5);\n    p.z = mod(p.z, 3.) - 1.5;\n    p.y -= .15;\n    float m = 10.;\n    if(p.z > 0.23) m += 0.1;\n    else if(p.z < -0.23) m += 0.2;\n    vec3 r = vec3(\n        sdBox(p, vec3(0.08, 0.02, 0.2)), m, hh.z);\n    return r;\n}\n#endif\n\nvec3 building(in vec3 p, in vec2 id) {\n    vec3 hh = hash32(id);\n    if(hh.z > 0.5) return vec3(9e9,0.,0.);\n    vec4 hh2 = hash41(hh.z);\n    float height = ceil(4.+pow(hh.x,1.5)*(8.+pow(hh.x,30.)*5.));\n    vec2 ext = vec2(2.+pow(hh2.x,3.)*2.,2.+pow(hh2.y,3.)*2.);\n    vec3 o = vec3(sin(hh.y*5.)*2.,height,cos(hh.y*5.)*2.);\n\tfloat d = sdBox(p-o, vec3(ext.x,height,ext.y));\n    vec2 r = vec2(d, p.y>height*2. ? 7.5 : 7.);\n    if(hh2.z > .7) {\n        height+=1.;\n    \tr = opU(r, \n                vec2(sdBox(p-o-vec3(0.,height,0.), vec3(ext.x*.5, .5, ext.y*.5)),\n                    7.6));\n    }\n    if(height > 14.) {\n        r = opU(r, vec2(\n            sdSphere((p-o-vec3(ext.x*.2,height+2.,ext.y*.2))*4.5, 1.)\n            , 8. + sin(iTime*5.+hh2.z*8.) ));\n    }\n    return vec3(r,0.);\n}\n\nvec3 moon( in vec3 pos) {\n\tfloat d = length(pos-vec3(.2, .2, 1.)*(400. + iTime))-20.;\n    return vec3(d, 12., 0.);\n}\n\nvec3 map( in vec3 pos )\n{\n    const vec2 REP = vec2(13.);\n    vec2 rq = mod(pos.xz, REP)-0.5*REP;\n    vec2 id = floor(pos.xz/REP);\n    \n    float pmid = 0.;\n    if(abs(rq.x+REP.x*.5)-1. < .01 || abs(rq.y+REP.y*.5)-1. < .01) {\n    \tpmid = 9.;\n        if((abs((rq.x+REP.x*.5) - .5)*2.+ceil(sin(rq.y*6.))*.04 < .04) ||\n           (abs((rq.y+REP.y*.5) - .5)*2.+ceil(sin(rq.x*6.))*.04 < .04)) {\n        \tpmid += .1;\n        }\n    }\n   \tvec3 res = vec3(pos.y, pmid, 0.);\n\n    res = opU(res, building(vec3(rq.x, pos.y, rq.y), id));\n    \n    #ifdef CARS\n    res = opU(res, cars(pos));\n    res = opU(res, cars((pos-vec3(.6,0.,0.))*vec3(1.,1.,-1.) ));\n    res = opU(res, cars(pos.zyx));\n    res = opU(res, cars((pos.zyx-vec3(.6,0.,.0))*vec3(1.,1.,-1.) ));\n    #endif\n#ifdef COOL_BACKGROUND\n    res = opU(res, moon(pos));\n#endif   \n    return res;\n}\n\n\nfloat DE(vec3 p0)\n{\n    return map(p0).x;\n}\n\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n        DE(p+eps.xyy) - DE(p-eps.xyy),\n        DE(p+eps.yxy) - DE(p-eps.yxy),\n        DE(p+eps.yyx) - DE(p-eps.yyx)));\n}\n\n\nfloat saturate(float v) { return clamp(v, 0.0,       1.0);       }\nvec2  saturate(vec2  v) { return clamp(v, vec2(0.0), vec2(1.0)); }\nvec3  saturate(vec3  v) { return clamp(v, vec3(0.0), vec3(1.0)); }\nvec4  saturate(vec4  v) { return clamp(v, vec4(0.0), vec4(1.0)); }\n\nvec3 ColorTemperatureToRGB(float temperatureInKelvins)\n{\n\tvec3 retColor;\n\t\n    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;\n    \n    if (temperatureInKelvins <= 66.0)\n    {\n        retColor.r = 1.0;\n        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);\n    }\n    else\n    {\n    \tfloat t = temperatureInKelvins - 60.0;\n        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n    }\n    \n    if (temperatureInKelvins >= 66.0)\n        retColor.b = 1.0;\n    else if(temperatureInKelvins <= 19.0)\n        retColor.b = 0.0;\n    else\n        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);\n\n    return retColor*vec3(1.04,1.,1.);\n}\nvec3 mat_col(vec2 m, vec3 p) {\n    float id = m.x;\n    if(id == 0.) return vec3(0.01);\n    else if(id == 7.) {\n    \tvec3 ci = hash32(ceil(p.zy+p.xy));\n        return ci.x > 0.1 ? vec3(0.01*ci.y) : \n        \tColorTemperatureToRGB(2800.+ci.y*10000.) +\n                (ci.x < 0.01 ? vec3(0., .2, 0.) : vec3(0.));\n    } \n    else if(id == 7.6) return vec3(0.06, 0.5, 0.2)*0.01;\n    else if(id >= 8. && id < 9.) {\n        float t = max(0.,id-8.);\n        return vec3(1., .04, 0.)*2.*t;\n    } else if(id >= 9. && id < 10.) {\n        if(id == 9.1) return vec3(1., 1., 0.)*1.5;\n    \telse return vec3(.1);\n    }\n    else if(id >= 10. && id < 11.) {\n        if(id == 10.1) return vec3(1., 0.08, 0.);\n        else if(id == 10.2) return vec3(1., 1., .6);\n        \n    \treturn mix(vec3(0.01, 0.0, 0.), vec3(0., 0., 0.01), m.y);\n    } \n    #ifdef COOL_BACKGROUND\n    else if(id == 12.) {\n        float fn = pow(noise(p*0.2), .3);\n    \treturn vec3(1., 1., 0.8)*fn;\n    }\n    #endif\n    return vec3(0.);\n}\n\nvec3 compute_color(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro+rd*t;\n    //vec3 nor = normal(p);\n    //vec3 ref = reflect(rd, nor);\n    \n    vec2 m = map(p).yz;\n    #ifdef COOL_BACKGROUND\n    if(m.x == 12.) {\n        vec3 n = normal(p);\n    \treturn mat_col(m,p) * pow(dot(n, vec3(0., 0., -1.)),2.);\n    }\n    #endif\n    return mat_col(m,p);\n\n\t/*vec3 f = vec3(0.);\n    //for(int i = 0; i < 1; ++i) {\n    vec3 l = normalize(vec3(0.5, .7, .3));\n   \n    \n    //float shd = calcSoftshadow(p, l, 10.);\n    float dif = clamp( dot( nor, l ), 0.0, 1.0 );\n   \tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    \n    vec3 v = vec3(0.);\n    v += .6*vec3(dif);//*shd;\n    v += .2*fre*vec3(.8, .7, .6);\n \tf += mat_col(m,p)*v;\n    //}\n    return f;*/\n}\n\n#ifdef COOL_BACKGROUND\nvec3 background(vec2 px, vec3 ro, vec3 rd) {\n    return vec3(0.05, 0., 0.2)*pow(.5-rd.y*.5, 4.);\n}\n#endif\n\nvec4 pixel(vec2 pxx)\n{\n    float pxl=4.0/size.y;//find the pixel size\n\n\t\n\t//position camera\n    vec2 m = iMouse.xy / size.xy;\n    m = length(m) < 0.05 ? vec2(100., 0.2) : m;\n    m.y += 0.2;\n    #ifndef CAMERA_PATH\n    float tim=\n        #ifdef CAMERA_AUTOROTATE\n        time*\n        #endif\n        0.08+(m.x)*5.;\n\tvec3 ro=vec3(cos(tim),0.5+(m.y)*2.-1.,sin(tim))*ZOOM;\n\tvec3 rd=normalize(vec3((2.0*pxx-size.xy)/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n    #else\n    float tim = time*0.08+(iMouse.x/size.x)*80.+100.;\n    vec3 ro=vec3(sin(tim)*2., 40.+sin(tim*.5)*30., tim*20.);\n    vec3 mp = map(ro);\n    if(mp.x < 0.01) {\n    \tro *= 1.4;\n    }\n   \tvec3 rd=normalize(vec3((2.0*pxx-size.xy)/size.y,2.0));\n\trd=lookat(ro+vec3(cos(tim*.1)*9000., -3000., 0.),vec3(0.0,1.,0.0))*rd;\n    #endif\n    //return vec4(background(pxx,ro,rd),1.);\n\t//ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t//march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(pxx),d,od=1.0;\n    bool hit = false;\n\tfor(int i=0;i<STEPS;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            hit = true;\n            break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;//d;\n\t\tif(t>1000.0)break;\n\t}\n    if(hit) {\n        vec3 c = compute_color(ro, rd, t);\n        return vec4(c, 1.);\n    } else {\n    \t#ifdef COOL_BACKGROUND\n        return vec4(background(pxx, ro, rd), 1.);\n        #endif\n        return vec4(0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 pxcolor = pixel(fragCoord.xy);\n    \n    #ifdef BLOOM\n    vec4 blurrd = pxcolor;\n    const float rd = 1.;\n    for(int i = 0; i < BLOOM_RAD; ++i) {\n    float rdd = rd*float(i);\n    blurrd += pixel(fragCoord.xy+vec2(0.,rdd));\n    blurrd += pixel(fragCoord.xy+vec2(0.,-rdd));\n    blurrd += pixel(fragCoord.xy+vec2(rdd,0.));\n    blurrd += pixel(fragCoord.xy+vec2(-rdd,0.));\n    blurrd += pixel(fragCoord.xy+vec2(rdd,rdd));\n    blurrd += pixel(fragCoord.xy+vec2(-rdd,-rdd));\n    blurrd += pixel(fragCoord.xy+vec2(rdd,-rdd));\n    blurrd += pixel(fragCoord.xy+vec2(-rdd,rdd));\n    }\n    blurrd /= (1.+8.*8.);\n    \n    const float I = 1.5;\n    const float T = 0.08;\n    vec4 hlt = clamp(blurrd-T,0.0,1.0)*1.0/(1.0-T);\n        \n    pxcolor = 1.0-(1.0-pxcolor)*(1.0-hlt*(I));\n    #endif\n    vec2 xy = (fragCoord.xy/size.xy);\n\tfloat v = .2 + 0.4*pow(50.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.7);\n    fragColor=pow(pxcolor*v+hash12(fragCoord.xy+iTime)*.005, vec4(1./2.2));\n\t\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[673, 1001, 1024, 1024, 1123], [1124, 1124, 1146, 1146, 1232], [1233, 1233, 1255, 1255, 1389], [1391, 1391, 1413, 1413, 1553], [1555, 1555, 1577, 1577, 1673], [1675, 1675, 1696, 1696, 1832], [1833, 1833, 1854, 1854, 1961], [1962, 1962, 1983, 1983, 2128], [2616, 2616, 2644, 2644, 2672], [2673, 2673, 2703, 2703, 2736], [2737, 2737, 2772, 2772, 2798], [2799, 2799, 2830, 2830, 2917], [3403, 3403, 3441, 3441, 4190], [4192, 4192, 4217, 4217, 4308], [4310, 4310, 4335, 4335, 5148], [5151, 5151, 5170, 5170, 5194], [5196, 5196, 5222, 5222, 5368], [5370, 5370, 5394, 5394, 5451], [5453, 5453, 5482, 5482, 5567], [5569, 5569, 5590, 5590, 5769], [5772, 5772, 5797, 5797, 5838], [5839, 5839, 5864, 5864, 5905], [5906, 5906, 5931, 5931, 5972], [5973, 5973, 5998, 5998, 6039], [6041, 6041, 6097, 6097, 6901], [6902, 6902, 6932, 6932, 7892], [7894, 7894, 7941, 7941, 8646]], "test": "untested"}
{"id": "4tXSDl", "name": "Metaeaux - Metaballs", "author": "metaeaux", "description": "Creating metaballs with a polynomial smoothmin function", "tags": ["raymarching", "distancefields", "smoothmin"], "likes": 5, "viewed": 1530, "published": "Public API", "date": "1440383322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 ambientColor = vec4(127./255.,199./255.,175./255., 1.0);\nconst vec4 skyColor = 0.8 * vec4(63./255.,184./255.,175./255., 1.0);\nconst float PI = 3.14159;\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec3 rotate(vec3 p, float theta)\n{\n    theta *= 2. * 3.14159;\n    mat3 ry = mat3(cos(theta), 0., sin(theta),\n                0., 1., 0.,\n                -sin(theta), 0., cos(theta));\n    return ry * p;\n}\n\nfloat smoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sploosh(vec3 p, float sizeFac, float distFac) {\n    float d = sphere(p, .4);\n    const int n = 4;\n\n    float size = 0.2 + 0.1 * abs(cos(iTime));\n    vec3 q1 = p;\n    vec3 q2 = p;\n    vec3 q3 = p;\n    vec3 q4 = p;\n    \n    for (int i = 1; i < n; i++){\n        float distX = 0.3 + 0.3 * sin(iTime * 0.7429);\n    \tfloat distY = 0.2 - 0.2 * cos(iTime * 1.242);\n\n        q1 += vec3(distX, distY, 0.);\n        q2 += vec3(-distX, distY, 0.);\n        q3 += vec3(sin(iTime * 0.342) * distX, sin(iTime)-distY, 0.);\n        q4 += vec3(cos(iTime) * distX, -distY, 0.);\n        size = 0.2 + 0.3 * abs(cos(float(n) * size));\n    \tfloat d1 = sphere(q1, size);\n        size = 0.2 + 0.3 * abs(cos(float(n) * 0.14159 * size));\n    \tfloat d2 = sphere(q2, size);\n        size = 0.2 + 0.3 * abs(sin(float(n) * 0.014159 * size));\n    \tfloat d3 = sphere(q3, size);\n    \tfloat d4 = sphere(q4, size);\n    \tfloat blendDistance = 0.4;\n    \n    \td = smoothMin(d, smoothMin(d1, d2, blendDistance), blendDistance);\n        d = smoothMin(d, smoothMin(d3, d4, blendDistance), blendDistance);\n    }\n    \n    return d;\n}\n\nfloat distanceField(vec3 p) {\n    return sploosh(p, 0.01, .02);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\n// phong shading\nvec4 phong(vec3 p, vec3 normal, vec3 lightPos, vec4 lightColor)\n{\n\tfloat lightIntensity = 0.0;\n\tvec3 lightDirection = normalize(lightPos - p);\n    \n    // lambert shading\n\tlightIntensity = max(0., dot(normal, lightDirection));\n    \n    // lambert shading\n    vec4 colour = lightColor * lightIntensity;\n    \n    // specular highlights\n    colour += pow(lightIntensity, 16.0) * (1.0 - lightIntensity*0.5);\n        \n    // ambient colour\n    colour += ambientColor * (1.0 - lightIntensity);\n    \n    \n\treturn colour;\n}\n\nvec2 squareFrame(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = squareFrame(iResolution.xy); \n    vec3 camUp = normalize(vec3(0., 1., 0.));\n    vec3 camForward = normalize(vec3(0., 0., 1.));\n    vec3 camRight = cross(camForward, camUp);\n    float focalLength = 2.;\n    vec3 ro = -vec3(0., 0., 4.);\n\tvec3 rd = normalize(camForward * focalLength + camRight * uv.x + camUp * uv.y);\n    vec4 color = skyColor;\n\n    float t = 0.0;\n    const int maxSteps = 32;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = distanceField(p);\n        if(d < 1e-2)\n        {\n            vec3 normal = getNormal(p);\n            color = phong(p, normal, normalize(vec3(1.0, 1.0, -2.0)), vec4(218./255.,216./255.,167./255., 1.0));            \n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 200, 200, 233], [235, 235, 269, 269, 303], [305, 305, 336, 336, 381], [383, 383, 417, 417, 586], [588, 588, 634, 634, 727], [729, 729, 782, 782, 1821], [1823, 1823, 1852, 1852, 1888], [1890, 1890, 1914, 1914, 2175], [2177, 2194, 2259, 2259, 2709], [2711, 2711, 2746, 2746, 2877], [2879, 2879, 2934, 2934, 3723]], "test": "untested"}
{"id": "4tXSWs", "name": "Warp Experiment 4", "author": "aiekick", "description": "use the mouse for move the warp", "tags": ["experiment", "warp", "5"], "likes": 19, "viewed": 1654, "published": "Public API", "date": "1440423521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// uv, offset, force, range\nvec2 warp(vec2 uv, vec2 m, float f, float z) \n{\n\tvec2 mo = 5.*(2.*m-iResolution.xy)/min(iResolution.x,iResolution.y), mouv = mo-uv;;\n\treturn uv - f*exp(-dot( mouv, mouv)/abs(z)) * mouv;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\t// base uv\n\tvec2 uv = 5.*(2.*g-iResolution.xy)/min(iResolution.x,iResolution.y);\n\t\n    // mouse pos (init : screen center)\n    vec2 m = iResolution.xy/2.;\n    if (iMouse.z>0.) m = iMouse.xy;\n    \n\t// main warp\n    float ft = sin(iTime*.2)*5.;\n    uv = warp(uv, m, ft, 16.);\n\n\t// repeat\n\tvec2 rp = vec2(1);\n\tuv = mod(uv, rp) -rp/2.;\n\t\n\t// Color\n    vec3 c = vec3(0.8,0.2,0.2);\n    \n    // vertical lines\n    float vlines = smoothstep(.16, .25, dot(uv.x, uv.x)); // meta axis x\n    \n    // horizontal line\n    float hlines = smoothstep(.16, .25, dot(uv.y, uv.y)); // meta axis y\n\t\n    c *= vlines + hlines;\n    \n\tf = c.xyzx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXSWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[138, 166, 213, 213, 353], [355, 355, 396, 408, 1022]], "test": "untested"}
{"id": "4tXXzs", "name": "Pulsar glitch", "author": "tabularasa1992", "description": "A nice glitchy pulsing effect.", "tags": ["glitch", "dark"], "likes": 7, "viewed": 554, "published": "Public", "date": "1438812326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bpm = 4.935;\n    \n\tvec2 uv = vec2( fragCoord.xy - 0.*iResolution.xy );\n    uv = 30. * uv.xy/iResolution.y;\n    uv.x -= 12. * ((sin(abs(sin(iTime/1.) * 5.) * uv.y * 50.) + 15.) / 15.);\n    \n    vec2 pos = vec2(15.)-uv;\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    \n    float f = 2.;\n    vec3 ring1 = vec3(1.-smoothstep(f,f+0.1,r) - (1.-smoothstep(f-0.1,f,r)));\n    f = 6.-ceil(abs(pow(cos(a),2.)*2.)*2.);\n    vec3 ring2 = vec3(1.-smoothstep(f,f+0.2,r) - (1.-smoothstep(f-0.2,f,r)));\n    f = 6.+ceil(abs(pow(cos(a),2.)*2.)*2.);\n    vec3 ring3 = vec3(1.-smoothstep(f,f+.3,r) - (1.-smoothstep(f-.3,f,r)));\n    f = 7.+ceil(abs(pow(cos(a),2.)*2.)*2.) + abs(tan(a));\n    vec3 ring4 = vec3(1.-smoothstep(f,f+.4,r) - (1.-smoothstep(f-.4,f,r)));\n    f = 8.+ceil(abs(pow(cos(a),2.)*2.)*2.) + abs(tan(a)) + abs(tan(a+3.1459/2.));\n    vec3 ring5 = vec3(1.-smoothstep(f,f+.5,r) - (1.-smoothstep(f-.5,f,r)));\n    f = 8.-ceil(abs(cos(a)*2.)*2.)+min(ceil(abs(tan(a)*0.3)),6.);\n    vec3 ring6 = vec3(1.-smoothstep(f,f+.6,r) - (1.-smoothstep(f-.6,f,r)));\n    f = 10.+ceil(abs(pow(cos(a),2.)*2.)*2.)+abs(tan(a))+abs(tan(a+3.1459/2.))+abs(tan(a*8.));\n    vec3 ring7 = vec3(1.-smoothstep(f,f+3.25,r) - (1.-smoothstep(f-3.25,f,r)));\n    \n    vec3 color = ring1 + ring2 + ring3 + ring4 + ring5 + ring6 + ring7;\n    color *= vec3(abs(sin(iTime * bpm + r/(20.))) * 2., abs(cos(iTime/2. + r)), abs(log(sin(iTime + r))));\n    color = pow(color, vec3(abs(sin(iTime * bpm))) * 5.);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1578]], "test": "untested"}
{"id": "lllSRl", "name": "raymarching + phong", "author": "jnalanko", "description": "asdfasdfa", "tags": ["asdf"], "likes": 1, "viewed": 174, "published": "Public", "date": "1439052674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdf(vec3 p){\n    p.y -= sin(iTime+sin(p.x));\n\treturn sqrt(p.z*p.z + p.y*p.y) - 1.0;   \n}\n\nvec3 get_normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.01,0,0);\n\treturn normalize(vec3(\n\t\tsdf(pos + eps.xyy) - sdf(pos - eps.xyy),\n\t\tsdf(pos + eps.yxy) - sdf(pos - eps.yxy),\n\t\tsdf(pos + eps.yyx) - sdf(pos - eps.yyx)\n\t));\n}\n\n// Clamped dot\nfloat cdot(vec3 a, vec3 b){\n    return max(0.0,dot(a,b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Fix coordinate system\n    float aspect_ratio = 16.0/9.0;\n\tvec2 pixel_pos = fragCoord.xy / iResolution.xy; // [0,1]\n    pixel_pos -= vec2(0.5,0.5); // [-1/2, 1/2]\n    pixel_pos *= vec2(2,2); // [-1,1]\n    pixel_pos.x *= aspect_ratio;\n    \n    // Raymarch\n    vec3 ray = vec3(pixel_pos.x, pixel_pos.y,-1);\n    vec3 v_0 = vec3(0,0,5); // Camera position\n    vec3 pos = v_0;\n    for(int step = 0; step < 30; step++){\n  \t\tpos += ray * sdf(pos)*0.98;\n    }\n    \n    // Phong: k_s * cos(alpha)^q * intensity / r^2\n    float sun_intensity = 70.0;\n    //vec3 sun = vec3(30.0 * sin(iTime),20,30.0*cos(iTime));\n    vec3 sun = vec3(0,0,50);\n    float k_s = 20.0;\n    float q = 2.0;    \n    \n    if(sdf(pos) > 0.1) // No hit\n        fragColor = vec4(0.1,0.1,0.3,1);\n    else{\n        vec3 surface = pos;\n        vec3 normal = get_normal(surface);\n        vec3 l = surface - sun; // Sun to surface\n        float intensity_at_surface = sun_intensity / dot(l,l); // Inverse square decay\n        \n    \tvec3 l_prime = l + 2.0*dot(l,normal)*normal;\n        vec3 to_camera = v_0 - surface;\n        float cos_angle = cdot(-l_prime, to_camera)/(length(l_prime) * length(to_camera));\n        float specular = k_s * pow(cos_angle,q) * intensity_at_surface;\n        float diffuse = 0.2 * cdot(normal, -l) * intensity_at_surface;\n        float ambient = 0.05;\n        vec3 light = vec3(clamp(diffuse + specular + ambient,0.0,1.0));\n        fragColor = vec4(light.x*0.2, light.y, light.z,1);\n    }\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 94], [96, 96, 123, 123, 310], [312, 327, 354, 354, 386], [388, 388, 445, 479, 1931]], "test": "untested"}
{"id": "lllSRr", "name": "shea shell", "author": "tabularasa1992", "description": "wonky wat?", "tags": ["abstract", "trippy", "polar"], "likes": 8, "viewed": 203, "published": "Public", "date": "1438812365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2( fragCoord.xy - 0.*iResolution.xy );\n    uv = uv.xy/iResolution.y;\n    uv.x -= .5;\n    \n    vec2 pos = vec2(0.5)-uv;\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    float a2 = a;\n    float r2 = r;\n\n    float f = abs(fract(cos(a * iTime * 2.)) + sin(iTime) * mod(a * 2., r) + log(r));\n    float trans = step(30., iTime) * ((iTime - 30.)/10.);\n    f += sin(iTime) * mix(reflect(a2, r2), reflect (a, f), trans);\n    vec3 ring1 = vec3(1.-smoothstep(f,f+0.5,r) - (1.-smoothstep(f-0.5,f,r)));\n    f*=50.;\n    vec3 ring2 = vec3(1.-smoothstep(f,f+1.,r) - (1.-smoothstep(f-1.,f,r)));\n    vec3 color = ring1 + ring2;\n    color *= vec3(abs(sin(iTime * 2. + r)), abs(cos(iTime/2. + r)), abs(sin(iTime + r)));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 826]], "test": "untested"}
{"id": "lllSWj", "name": "playing with some colors", "author": "JamesHagerman", "description": "woop. colors", "tags": ["sensatron"], "likes": 1, "viewed": 95, "published": "Public", "date": "1439879506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float time = sin(iTime*uv.x);\n    \n    vec3 hsvColor = hsv2rgb_smooth(vec3(time, 1.0, 1.0));\n    \n    fragColor = vec4(hsvColor, 1.0);\n        \n        \n        \n        \n   \t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    // fragColor is the MOST IMPORTANT thing in a shader\n    // vec4 = 4 dimensional vector\n    // red, green, blue, alpha\n    // values between 0.0 and 1.0\n    //fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    \n    //sin(iTime); // -1.0 1.0\n    \n    //vec2 twovals = vec2(0.0, 0.0);\n    //vec3 rgbOut = vec3(abs(sin(2.0*iTime)), 0.0, abs(sin(5.0*iTime)));\n    //fragColor = vec4(twovals, 1.0, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 67, 67, 243], [246, 246, 303, 303, 1035]], "test": "untested"}
{"id": "lllSWS", "name": "SIGGRAPH 2015 Attempt to Keep Up", "author": "nglevin", "description": "Following along with the instructor as best I could", "tags": ["siggraph2015"], "likes": 5, "viewed": 239, "published": "Public", "date": "1439420477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cosNoise( in vec2 pos )\n{\n    return 0.5 * (sin(pos.x) + sin(pos.y));\n}\n\n// defines a right triangle that is a rotation matrix\nconst mat2 m2 = mat2( 0.8, -0.6, \n                      0.6,  0.8 );\n\nfloat map( in vec3 pos )\n{\n    vec2 q = pos.xz * 0.5;\n    \n    float h = 0.0;\n    \n    float s = 0.5;\n    for ( int i = 0; i < 12; i++ )\n    {\n        h += s*cosNoise(q);\n        s *= 0.5;\n        \n        // rotate each one of those sin wave patterns\n        q = m2 * q * 1.7;\n    }\n    \n    h *= 3.0;\n    \n    return pos.y - h;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 nor;\n    \n    vec2 e = vec2( 0.01, 0.0 );\n    \n    nor.x = map( pos + e.xyy ) - map( pos - e.xyy );\n    nor.y = map( pos + e.yxy ) - map( pos - e.yxy );\n    nor.z = map( pos + e.yyx ) - map( pos - e.yyx );\n    \n    return normalize(nor);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    \n    float t = 0.1;\n    for (int i = 0; i < 64; i++)\n    {\n        vec3 pos = ro + t * rd;\n        float h = map( pos );\n        res = min( res, 10.0 * max(h,0.0) / t );\n        \n        if (res < 0.0001 ) break;\n        \n        t += h;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates \n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    // (bounded to -1 to 1 vertically)\n    vec2 q = -1.0 + 2.0 * p;\n    \n    // (bounded to )\n    q.x *= 1.777;\n    \n    \n    // ray origin\n    vec3 ro = vec3( 0.0, 1.65, -iTime );\n    \n   \t// ray direction\n    vec3 rd = normalize( vec3( q, -1.0) ); // shorthand for q.x, q.y with defined z coord\n    \n    \n    // now we have a ray\n    \n    //\n    // have we hit any objects? are we inside the object already?\n    //\n    // proceed after finding that out for each ray. Call that process \"marching\"\n    //\n    \n    vec3 col = vec3 (0.7, 0.8, 1.0);\n    col *= 1.0 - 0.5 * rd.y;\n    \n    float tmax = 40.0;\n    float t = 0.0;\n    // trying this marching process AT MOST 256 times, \n    //   because of WebGL constraints, GLSL ES2 constraints\n    for ( int i = 0; i < 256; i++ ) {\n        \n        vec3 pos = ro + rd * t;\n          \n        // find if we've hit an object (intersection of rays)\n        float h = map( pos );\n        \n        // want to return pos or neg value depending on if we've hit an \n        //   object (h < 0.0) or (h < 0.001)\n        //   OR we've gone beyond the range that we care about (t > tmax)\n        \n        if ( h < 0.001 || t > tmax ) {\n            break;\n        }\n        \n        t += h * 0.5; // small scalar (0.5) removes artifacts in shadows\n        \n        // advance to next step when we determine that we've hit an object\n        \n    }\n    \n    \n    vec3 light = normalize( vec3( 1.0, 0.5, -0.5) );\n    \n    \n    if (t < tmax) \n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        //col = (nor * nor * nor);\n        \n        \n        float dif = clamp( dot( nor, light ), 0.0, 1.0 );\n        \n        float sha = calcShadow( pos + nor*0.1, light );\n\n        \n        vec3 lig  = vec3(2.0, 1.5, 1.0) * dif * 1.5 * sha;\n        \t lig += vec3(0.1, 0.2, 0.3) * nor.y * 2.0; // use nor.y instead of a constant for some attenuation, keep lighting looking good\n        \n        \n        \n        vec3 mate = vec3(0.3, 0.3, 0.3) * 0.5;\n        mate = mix(mate, vec3(0.2, 0.15, 0.1), \n                   smoothstep(0.7, 0.9, nor.y));\n        \n        \n        col = lig * mate;\n        \n        float fog = exp( -0.002 * t * t );\n        col *= fog;\n        col += (1.0 - fog) * vec3(0.5, 0.6, 0.7);\n        \n    } \n    \n    col = sqrt(col);\n    \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 77], [79, 203, 229, 229, 534], [537, 537, 569, 569, 818], [820, 820, 863, 863, 1155], [1157, 1157, 1214, 1240, 3633]], "test": "untested"}
{"id": "lllXzs", "name": "omgarf", "author": "johnnyscript", "description": "its somgarf", "tags": ["garf"], "likes": 1, "viewed": 96, "published": "Public", "date": "1439176320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float angle(vec2 coord, vec2 center){\n\tfloat dx = coord.x - center.x;\n    float dy = coord.y - center.x;\n    return atan(dx/dy);\n}\n\nfloat diric (float n, float x);\nvec3 hsl2rgb (float h, float s, float l);\n\nvec3 hsl(in float h, float s, float l) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float w = iResolution.x - (15.0 * cos(iTime * 2.0));\n    float h = iResolution.y + (5.0 * cos(iTime * 3.0));\n\n    float x = fragCoord.x  ;\n    float y = fragCoord.y  ;\n    float t = iTime * 2.0;\n    \n    vec2 c = vec2( w / 2.0, h / 2.0);\n    float a = angle(fragCoord, c);\n    float vv = sin(t* y * x + log(x)) + sin(t - 0.5 * 72.0 / 60.0);\n    vec3 uv2 = hsl(vv, 1.0, .5);\n\tfragColor = vec4(uv2, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 130], [207, 207, 247, 247, 377], [379, 379, 436, 436, 895]], "test": "untested"}
{"id": "llSSRR", "name": "Vegas On Acid", "author": "SonOfLilit", "description": "A simple but pretty pattern I arrived at while teaching a friend math with shaders.\n\n\"Close your eyes and imagine, feel the magic\nVegas on acid, seen through Yves St. Laurent glasses\"", "tags": ["2dpattern"], "likes": 3, "viewed": 173, "published": "Public", "date": "1440890436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float screenSizeY = iResolution.y;\n\tvec2 uv = fragCoord.xy / screenSizeY;\n    uv -= 0.5 * vec2(1.0);\n    uv *= 1.0 + 0.2 * sin(t * 0.31);\n    uv += vec2(sin(t), t);\n    uv = mod(uv + 0.25, 0.5) - 0.25;\n    float r = uv.x * uv.x + uv.y * uv.y;\n    float gray = mod(100.0 * pow(r, 2.0), 1.0) > 0.5 * sin(t) + 0.5 ? 1.0 : 0.0;\n    fragColor = vec4(gray, gray, gray, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 453]], "test": "untested"}
{"id": "llsXD2", "name": "Seascape Documented", "author": "bteitler", "description": " \"Seascape\" by Alexander Alekseev with added documentation by me (prefixed with \"bteitler\").  Meant to help myself learn and help others understand what's going on.  Original here:\nhttps://www.shadertoy.com/view/Ms2SD1", "tags": ["procedural", "noise", "waves", "sea", "water", "learning", "subsurface"], "likes": 93, "viewed": 5568, "published": "Public", "date": "1439990666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A documented version of \"Seascape\" for learning purposes.  Original shader page here:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME;\n\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        \n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     float EPSILON_NRM\t= 0.1 / iResolution.x;\n    float SEA_TIME = iTime * SEA_SPEED;\n\n\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 0.3 + iMouse.x*0.01; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n\n    // bteitler: Calculated a vector that smoothly changes over time in a sinusoidal (wave) pattern.  \n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);\n    \n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5, at x 0 (zero), and flies over the ocean in the z axis over time.\n    vec3 ori = vec3(0.0,3.5,time*5.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    // dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n\n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n        \n    // post\n    \n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsXD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[683, 757, 783, 783, 1129], [1131, 1597, 1619, 1619, 1702], [1704, 1965, 1991, 1991, 3625], [3627, 3709, 3747, 3747, 3789], [3791, 3859, 3905, 3905, 4009], [4011, 4101, 4127, 4127, 4265], [4267, 4790, 4831, 5233, 8385], [8387, 8556, 8575, 8575, 10857], [10859, 11029, 11057, 11057, 13347], [13349, 13591, 13654, 13790, 14672], [14674, 15014, 15049, 15392, 16432], [16434, 16497, 16553, 16553, 19867], [19869, 19877, 19934, 19934, 23999]], "test": "untested"}
{"id": "llsXDf", "name": "Hexagonal wallpapers", "author": "nmz", "description": "attempt at a generalization of the hexagonal lattice tilings, using the hexagon centers function from mattz.", "tags": ["tiling", "wallpaper", "wallpapergroup"], "likes": 34, "viewed": 375, "published": "Public", "date": "1440360331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Hexagonal wallpapers by nmz (twitter: @stormoid)\n\n/*\n\tFor more info: https://en.wikipedia.org/wiki/Wallpaper_group\n\n\tp6: 0.5s\n\tp6mm: 8s\n\tp3: 12s\n\tp3m1: 21s\n\tp31m: 31s (not 100% sure about that one, can anyone confirm?)\n\n\tYou should see new patterns up to ~80seconds\n*/\n\n#define tau 6.2831853\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n//From mattz (https://www.shadertoy.com/view/4d2GzV)\n//-------------------------------------------------------------\nvec2 pick3(vec2 a, vec2 b, vec2 c, float u) \n{\n\tfloat v = fract(u * 0.3333333333333);\n\treturn mix(mix(a, b, step(0.3, v)), c, step(0.6, v));\n}\n\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\nvec2 closestHexCenters(vec2 p){\n    p = cart2tri*p;\n\tvec2 ip = floor(p), fp = fract(p);\n\tvec2 nn = pick3(vec2(0), vec2(1), vec2(1.0, 0.0), ip.x + ip.y);\n    return tri2cart*(mix(nn, nn.yx, step(fp.x, fp.y)) + ip);\n}\n\n//-------------------------------------------------------------\n\nfloat tri(in vec2 p){ return max(abs(p.x)*1.73205+p.y, -p.y*2.);}\n\nfloat smoothfloor(in float x, in float k)\n{\n    float xk = x+k*0.5;\n    return floor(xk)+smoothstep(0.,k,fract(xk));\n}\n\n//The main texture function, could be different shapes\nvec4 tex(in vec2 p, in float a, in float typ)\n{\n    float t = mod(time,23.5);\n    p *= mm2(a + smoothfloor(t*0.4,0.25)*0.5 + smoothfloor(t*0.2,0.25)*.83);\n    float rz = tri(p*mix(1.,1.4,smoothstep(0.1,-0.1,sin(time*0.4))));\n    float rz2 = rz;\n    rz = smoothstep(0.7,.8,rz);\n    vec3 tri = (1.-rz)*abs(sin(vec3(1.,2.,3.)+typ*.8))*smoothstep(0.7,0.6,rz2);\n    tri *= texture(iChannel0, p).r*0.6+0.5;\n    return vec4(tri, 1.-rz);\n}\n\nvec3 tiles(in vec2 p)\n{\n    vec3 col = pow(texture(iChannel0, p).rgb,vec3(0.37));\n    vec2 ofst = vec2(0.5,.866);\n    \n    vec4 rez = tex(p,-0.5236, 0.5)*smoothstep(0.2,.3,sin(time*0.3+3.));\n    col = mix(col,rez.rgb,rez.a);\n    \n    float a = atan(p.x, -p.y)*3./tau;\n    float id = floor(a+.8);\n    vec2 bp = p;\n    p *= mm2(id*tau/3.);\n    \n    rez = tex(p+ofst,2.094+id*4.1889+ 1.05, 2.);\n    col = mix(col,rez.rgb,rez.a);\n    \n    id = floor(a+.3);\n    p = bp;\n    p *= mm2(id*tau/3. + 1.0472);\n    rez =  tex(-p-ofst,.0+2.094+id*4.1889, 3.);\n    col = mix(col,rez.rgb,rez.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\t\t\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    p*= 8.;\n    p *= mm2(smoothstep(-0.1,.1,sin(time*0.25+0.1))*1.5708);\n    p.x += time*0.4;\n    \n    vec2 h = closestHexCenters(p);\n    vec3 col = tiles(p-h);\n\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n    \n    fragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 313, 334, 334, 386], [388, 505, 551, 551, 647], [825, 825, 856, 856, 1040], [1042, 1107, 1128, 1128, 1172], [1174, 1174, 1217, 1217, 1292], [1294, 1349, 1396, 1396, 1780], [1782, 1782, 1805, 1805, 2385], [2387, 2387, 2445, 2445, 2815]], "test": "untested"}
{"id": "llsXzl", "name": "Truchet Tiles", "author": "anastadunbar", "description": "Was very easy to make. Not so smooth when zooming in.", "tags": ["procedural", "2d", "circles", "simple", "round", "random", "generative", "smooth", "tiles"], "likes": 7, "viewed": 312, "published": "Public", "date": "1439099183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Change these:\n\n#define mode 1\n//1 = round, 2 = triangle\n\n//The round tiles\n#define sharp 35. \n#define thick 0.06\n\n//The right triangle tiles\n#define sharp2 30.\n\n#define uv_size 20.\n#define random_seed 1.\n\n//------------------------------------------------------------------------------------------------------------------\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat manhattan(vec2 uv) {\n    return abs(uv.x)+abs(uv.y);\n}\n//The tiles---------------------------------------------------------------------------------------------------------\n//The round tiles\nfloat tile_1(vec2 uv){\n    float x = clamp((1.-length(uv-vec2(1.,0.))-(0.5-thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,1.))-(0.5-thick))*sharp,0.,1.);\n    x -= clamp((1.-length(uv-vec2(1.,0.))-(0.5+thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,1.))-(0.5+thick))*sharp,0.,1.);\n    return x;\n}\nfloat tile_2(vec2 uv){\n    float x = clamp((1.-length(uv-vec2(1.,1.))-(0.5-thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,0.))-(0.5-thick))*sharp,0.,1.);\n    x -= clamp((1.-length(uv-vec2(1.,1.))-(0.5+thick))*sharp,0.,1.)+clamp((1.-length(uv-vec2(0.,0.))-(0.5+thick))*sharp,0.,1.);\n    return x;\n}\n//The right triangle tiles\nfloat tile_3(vec2 uv) {\n    float a = manhattan(uv)*0.5;\n    a = ((a-0.5)*sharp2)+0.5;\n    return clamp(a,0.,1.);\n}\nfloat tile_4(vec2 uv) {\n    float a = manhattan(vec2(1.-uv.x,uv.y))*0.5;\n    a = ((a-0.5)*sharp2)+0.5;\n    return clamp(a,0.,1.);\n}\n//------------------------------------------------------------------------------------------------------------------\nfloat draw_tiles(vec2 uv,float seed) {\n    if (floor(rand(floor(uv)+(seed/0.12))+0.5) == 0.) {\n        return tile_1(fract(uv));\n    } else {\n        return tile_2(fract(uv));\n    }\n}\nfloat draw_tiles2(vec2 uv,float seed) {\n    float random_tile = floor(rand(floor(uv)+(seed/0.12))*4.);\n    if (random_tile == 0.) {\n        return tile_3(fract(uv));\n    }\n    if (random_tile == 1.) {\n        return tile_4(fract(uv));\n    }\n    if (random_tile == 2.) {\n        return 1.-tile_3(fract(uv));\n    }\n    if (random_tile == 3.) {\n        return 1.-tile_4(fract(uv));\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = vec2(((uv.x-0.5)*(iResolution.x / iResolution.y))+0.5,uv.y);\n    \n    vec2 warped_uv = ((suv-0.5)*(uv_size+(sin(time+uv.x)*2.)))+0.5;\n    \n    //Change colors right here!\n    vec3 COLOR_B = vec3(0.5,0.1,0.0);\n\tvec3 COLOR_F = vec3(1.,0.8,0.1);\n    //-------------------------\n    float draw = draw_tiles(warped_uv,random_seed);\n    if (mode == 2) {\n    draw = draw_tiles2(warped_uv,random_seed);\n    }\n\tfragColor = vec4(mix(COLOR_B,COLOR_F,draw),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsXzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 324, 344, 344, 416], [417, 417, 443, 443, 477], [478, 613, 635, 635, 912], [913, 913, 935, 935, 1212], [1213, 1240, 1263, 1263, 1355], [1356, 1356, 1379, 1379, 1487], [1488, 1605, 1643, 1643, 1788], [1789, 1789, 1828, 1828, 2190], [2192, 2192, 2249, 2249, 2783]], "test": "untested"}
{"id": "llXSD7", "name": "Adaptive Sampling Diagram", "author": "huwb", "description": "Diagram used in our talk \"A Novel Sampling Algorithm for Fast and Stable Real-Time Volume Rendering\" at SIGGRAPH. Course page: http://advances.realtimerendering.com/s2015/index.html", "tags": ["1d", "sampling", "adaptive"], "likes": 29, "viewed": 1088, "published": "Public", "date": "1439530443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2015 Huw Bowles & Daniel Zimmermann\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Example to illustrate volume sampling research undertaken right here on\n// shadertoy and published at siggraph 2015:\n//\n// Talk: \"A Novel Sampling Algorithm for Fast and Stable Real-Time Volume Rendering\"\n// Ppt: http://advances.realtimerendering.com/s2015/siggraph15_volsampling.pptx\n// Course page: http://advances.realtimerendering.com/s2015/index.html\n//\n\n\n// for graph\n#define RANGEY 6.0\n#define RANGEX (RANGEY*iResolution.x/iResolution.y)\n#define THICK  0.05\n\n// simple macros to pull mouse position in [0,1]\n#define MOUSEX\tiMouse.x/iResolution.x\n#define MOUSEY\tiMouse.y/iResolution.y\n\n#define CAMX (RANGEX*(MOUSEX-.5)*2.5)\n\n#define SAMPLE_COUNT 32\n#define PARAMETRIC_STEPS 32\n\n#define EPS 0.001\n\n//#define VIS_SAMPLE_LEVELS\n\nfloat pdf_max( float xstart, float xend )\n{\n    xstart = max( xstart, 0. );\n    return 5./(1.+xstart*1.5);\n}\n\n// the density line plot\nbool fn1( float x, out float y, out vec4 col )\n{\n\tcol = vec4(1.,0.,0.,1.);\n\ty = pdf_max( x, x );\n\treturn true;\n}\n\n// visualise two tree levels\nfloat inten = .4;\nfloat visy0 = .5;\nbool fn2( float x, out float y, out vec4 col )\n{\n    return false;\n    //y = pow( 2., 1.+floor(log2(MOUSEY*RANGEY)) );\n    y = MOUSEY*RANGEY;\n\tcol = vec4(inten);\n\treturn true;\n}\n\n\nvec4 drawSample( vec2 px, vec2 pt, vec4 col )\n{\n    float pw = .2;\n    float r = length(pt-px);\n    \n    float border = smoothstep( pw*.65, pw*.7, r );\n    col.rgb = mix(col.rgb, vec3(99.,37.,35.)/255., border);\n    \n    float alpha = smoothstep( pw, pw*.85, r );\n    //alpha *= border;\n    alpha *= col.a;\n    return vec4( col.rgb, alpha );\n}\n\nfloat dens_max( float x, float dx )\n{\n    return pdf_max(x,x+dx);\n}\n\nfloat mov_mod( float x, float y)\n{\n    return mod( x - iTime/4., y );\n}\n\nbool onBoundary( float x, float dx )\n{\n    // the +0.25 solves numerical issues without changing the result\n\treturn mov_mod( x + dx*0.25, dx ) < dx*0.5;\n}\n\n// this parametric function places a white dot at each sample\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\tcol = vec4(192.,80.,77.,255.)/255.;\n\tmint = 0.;\n\tmaxt = 1.;\n\tint thisPt = int(floor(t*float(SAMPLE_COUNT)));\n    \n    // new variables from adaptive sampling\n    \n    // setup sampling\n\tx = 0.;\n    float dx = exp2(floor(log2(1./dens_max(x,0.))));\n    x -= mov_mod(x,2.*dx);\n    float wt = 1.;\n    bool even = true;\n    \n\tfor( int i = 0; i < SAMPLE_COUNT; i++ )\n\t{\n\t\tif( i == thisPt && x >= 0.)\n\t\t{\n\t\t\tbreak;\n\t\t}\n        \n        // sample at x, give weight wt\n        if( even )\n        {\n\t\t\tfloat densx = dens_max( x, dx * 2.0 );\n\t\t\tif( densx > 1.0 / dx )\n            {\n                // higher sampling rate\n                dx /= 2.0;\n                densx = dens_max( x, dx * 2.0 );\n                \n                // need enough of these to get to desired density, if not can get\n                // pops\n                if( densx > 1.0 / dx ) { dx /= 2.0; densx = dens_max( x, dx * 2.0 ); }\n                if( densx > 1.0 / dx ) { dx /= 2.0; densx = dens_max( x, dx * 2.0 ); }\n                if( densx > 1.0 / dx ) { dx /= 2.0; densx = dens_max( x, dx * 2.0 ); }\n            }\n            else\n            {\n                float nextDx, nextDens; bool nextEven;\n                \n                nextDx = 2.*dx;\n                nextDens = dens_max( x, nextDx*2. );\n                nextEven = onBoundary( x, nextDx*2. );\n                if( nextDens < 0.5 / dx && nextEven )\n                {\n                    // lower sampling rate\n\t\t\t\t\tdx = nextDx;\n\t\t\t\t\t// commit to this density\n\t\t\t\t\tdensx = nextDens;\n                }\n                \n                // can repeat the above block to step down sampling rates faster\n            }\n            \n\t\t\t//wt = saturate( 2.0 * (densx / (1.0 / dx) - 0.5) );\n\t\t\twt = clamp( 1.0*(2.0 * densx * dx - 1.0), 0., 1. );\n        }\n        \n        x += dx;\n\t    even = !even;\n\t}\n    \n    wt = even ? (2.-wt) : wt;\n    \n    col.a *= clamp(wt,0.,1.);\n    \n    y = pdf_max(x,x);// even ? pdf_max(x,x) : max( pdf_max(x,x), 1./(2.*dx));\n    \n\treturn true;\n}\n\n\nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // uv minx maxx miny maxy thickness\n\tfragColor = graph( uv, 0., RANGEX, 0., RANGEY, THICK );\n\n\treturn;\n}\n\n\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\nfloat boundary(float coord, float spacing)\n{\n    float r = abs(mov_mod(coord+spacing/2.,spacing)-spacing/2.);\n    return smoothstep(7.5/iResolution.y,0.,r);\n    //return  < 10./iResolution.x ? 1. : 0.;\n}\n\nvec3 graph_bg(vec2 thisPt)\n{\n    float lowcoord = exp2(floor(log2(1./thisPt.y)));\n    float i = 1.-boundary(thisPt.x,lowcoord);\n    i = mix( 0.2,1.,i);\n    return vec3(i);\n}\n\n// p is in [0,1]. \nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width )\n{\n\tvec4 result = vec4(1.);\n\t\n\tfloat thisx = xmin + (xmax-xmin)*p.x;\n\tfloat thisy = ymin + (ymax-ymin)*p.y;\n\t\n    result.rgb = graph_bg(vec2(thisx,thisy));\n    \n\t// compute gradient between this pixel and next (seems reasonable)\n\tfloat eps = dFdx(thisx);\n\n\tfloat alpha;\n\t\n\t//vec4 axisCol = vec4(vec3(.3),1.);\n\t\n\t// axes\n\t// x\n\t//alpha = abs( thisy - 0. ); alpha = smoothstep( width, width/4., alpha );\n\t//result = (1.-alpha)*result + alpha*axisCol;\n\t// y\n\t//alpha = abs( thisx - 0. ); alpha = smoothstep( width, width/4., alpha );\n\t//result = (1.-alpha)*result + alpha*axisCol;\n\t\n\t// uses iq's awesome distance to implicit http://www.iquilezles.org/www/articles/distance/distance.htm\n\tfloat f;\n\tvec4 fcol;\n\tif( fn1( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn1( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn2( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn2( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\t// parametric curves. todo - join the dots!\n\tfloat x, mint, maxt;\n\tif( pfn1( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn1( t, x, f, fcol, mint, maxt );\n\t\t\tvec4 samp = drawSample( vec2(thisx,thisy), vec2(x,f), fcol );\n\t\t\tresult = (1.-samp.a)*result + samp.a*samp;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t\n\t//result += vec4(drawNumber(xmin, vec2(0.,0.)+vec2(1.)/iResolution.xy, p ));\n\t//result += vec4(drawNumber(xmax, vec2(1.,0.)+vec2(-26.,1.)/iResolution.xy, p ));\n\t//result += vec4(drawNumber(ymax, vec2(0.,1.)+vec2(1.,-7.)/iResolution.xy, p ));\n\t//result += vec4(drawNumber(ymin, vec2(0.,0.)+vec2(1.,10.)/iResolution.xy, p ));\n\t\n\treturn result;\n}\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\nvec3 errorColour( float err, float maxerror )\n{\n\terr = 1. - err / maxerror;\n\terr *= 2. / 3.;\n\treturn hsv2rgb( vec3(err, 1., 1.) );\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXSD7.jpg", "access": "shaders20k", "license": "mit", "functions": [[1810, 1839, 1882, 1882, 1947], [1949, 1974, 2022, 2022, 2086], [2088, 2153, 2201, 2201, 2330], [2333, 2333, 2380, 2380, 2676], [2678, 2678, 2715, 2715, 2745], [2747, 2747, 2781, 2781, 2818], [2820, 2820, 2858, 2927, 2974], [2976, 3038, 3132, 3132, 5134], [5221, 5221, 5278, 5278, 5433], [5497, 5497, 5541, 5541, 5700], [5702, 5702, 5730, 5730, 5875], [5877, 5896, 5979, 5979, 7966], [7968, 8022, 8084, 8108, 8441], [8442, 8459, 8510, 8510, 8557], [8558, 8572, 8623, 8623, 8672], [8673, 8690, 8749, 8749, 9379], [9381, 9459, 9519, 9519, 10522], [10569, 10569, 10616, 10616, 10701], [10703, 10762, 10784, 10784, 11115], [11117, 11117, 11139, 11139, 11308]], "test": "untested"}
{"id": "llXSW2", "name": "OMGclouds", "author": "OMGparticles", "description": "My first contribution to ShaderToy after following the tutorial at SIGGRAPH 2015. Most of this shader code is taken directly from iq's \"Clouds\" (shadertoy.com/view/XslGRr). I just added some turbulence/movement in the clouds, and a day/night cycle.", "tags": ["procedural", "3d", "raymarching", "volumetric", "iq", "lod", "iteration", "vr"], "likes": 68, "viewed": 5338, "published": "Public API", "date": "1439770041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// Turbulence and Day/Night cycle added by Michael Olson - OMGparticles/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Volumetric clouds. It performs level of detail (LOD) for faster rendering and antialiasing\n\nfloat fTurbulence = 0.35;\nfloat fSunSpeed = 0.35;\n\nvec3 vNightColor   = vec3(.15, 0.3, 0.6);\nvec3 vHorizonColor = vec3(0.6, 0.3, 0.4);\nvec3 vDayColor     = vec3(0.7,0.8,1);\n\nvec3 vSunColor     = vec3(1.0,0.8,0.6);\nvec3 vSunRimColor  = vec3(1.0,0.66,0.33);\n\nvec3 v3sunDir;\nvoid updateSun() {\n    float fSpeed = fSunSpeed * iTime;\n    v3sunDir = normalize( vec3(cos(fSpeed),sin(fSpeed),0.0) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 );\n\treturn (-1.0+2.0*mix( rg.g, rg.r, f.z ));\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02 + iTime * fTurbulence * 1.0;\n    f += 0.25000*noise( q ); q = q*2.03 + iTime * fTurbulence * 2.0;\n    f += 0.12500*noise( q ); q = q*2.01 + iTime * fTurbulence * 4.0;\n    f += 0.06250*noise( q ); q = q*2.02 + iTime * fTurbulence * 8.0;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02 + iTime * fTurbulence * 1.0;\n    f += 0.25000*noise( q ); q = q*2.03 + iTime * fTurbulence * 2.0;\n    f += 0.12500*noise( q ); q = q*2.01 + iTime * fTurbulence * 4.0;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02 + iTime * fTurbulence * 1.0;\n    f += 0.25000*noise( q ); q = q*2.03 + iTime * fTurbulence * 2.0;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02 + iTime * fTurbulence * 1.0;\n    f += 0.25000*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.9,0.95,1.0) + 0.5*vec3(0.7, 0.5, 0.3)*dif * smoothstep(-0.3, 0.3, v3sunDir.y);\n    vec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    col.xyz *= lin;\n    //col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*v3sunDir))/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.01*float(i),0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(20,map5);\n    MARCH(30,map4);\n    MARCH(40,map3);\n    MARCH(50,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n\tfloat sun = clamp( dot(v3sunDir,rd), 0.0, 1.0 );\n    \n    float fSunHeight = v3sunDir.y;\n    \n    // below this height will be full night color\n    float fNightHeight = -0.8;\n    // above this height will be full day color\n    float fDayHeight   = 0.3;\n    \n    float fHorizonLength = fDayHeight - fNightHeight;\n    float fInverseHL = 1.0 / fHorizonLength;\n    float fHalfHorizonLength = fHorizonLength / 2.0;\n    float fInverseHHL = 1.0 / fHalfHorizonLength;\n    float fMidPoint = fNightHeight + fHalfHorizonLength;\n    \n    float fNightContrib = clamp((fSunHeight - fMidPoint) * (-fInverseHHL), 0.0, 1.0);\n    float fHorizonContrib = -clamp(abs((fSunHeight - fMidPoint) * (-fInverseHHL)), 0.0, 1.0) + 1.0;\n    float fDayContrib = clamp((fSunHeight - fMidPoint) * ( fInverseHHL), 0.0, 1.0);\n    \n    // sky color\n    vec3 vSkyColor = vec3(0.0);\n    vSkyColor += mix(vec3(0.0),   vNightColor, fNightContrib);   // Night\n    vSkyColor += mix(vec3(0.0), vHorizonColor, fHorizonContrib); // Horizon\n    vSkyColor += mix(vec3(0.0),     vDayColor, fDayContrib);     // Day\n    \n\tvec3 col = vSkyColor;\n    \n    // atmosphere brighter near horizon\n    col -= clamp(rd.y, 0.0, 0.5);\n    \n    // draw sun\n\tcol += 0.4 * vSunRimColor * pow( sun,    4.0 );\n\tcol += 1.0 * vSunColor    * pow( sun, 2000.0 );\n    \n    // stars\n    float fStarSpeed = -fSunSpeed * 0.5;\n    \n    float fStarContrib = clamp((fSunHeight - fDayHeight) * (-fInverseHL), 0.0, 1.0);\n    \n    vec3 vStarDir = rd * mat3( vec3(cos(fStarSpeed), -sin(fStarSpeed), 0.0),\n                               vec3(sin(fStarSpeed),  cos(fStarSpeed), 0.0),\n                               vec3(0.0,             0.0,            1.0));\n                              \n    col += pow((texture(iChannel0, vStarDir.xy).r + texture(iChannel0, vStarDir.zy).r) * 0.5, 42.0) * fStarContrib * 40.0;\n\n    // raymarch clouds\n    vec4 res = raymarch( ro, rd, col );\n    \n    // partially tint clouds to match sky color\n    res *= vec4(pow(vSkyColor, vec3(0.25)), 1.0);\n        \n    col = col*(1.0-res.w) + res.xyz;\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    updateSun();\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(6.28*m.x + 1.5), 0.4 * m.y, cos(6.28*m.x + 1.5)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXSW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[202, 569, 587, 587, 690], [692, 692, 718, 718, 937], [939, 939, 964, 964, 1373], [1375, 1375, 1400, 1400, 1740], [1741, 1741, 1766, 1766, 2037], [2038, 2038, 2063, 2063, 2265], [2267, 2267, 2353, 2369, 2737], [3066, 3066, 3122, 3122, 3281], [3283, 3283, 3335, 3335, 3512], [3514, 3514, 3553, 3553, 5631], [5633, 5633, 5690, 5690, 6097], [6099, 6099, 6193, 6193, 6245]], "test": "untested"}
{"id": "llXSz2", "name": "RGB to HSV test", "author": "JamesHagerman", "description": "testing an HSV shader on the lights", "tags": ["sensatron"], "likes": 3, "viewed": 260, "published": "Public", "date": "1439879534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Converting from HSV to RGB leads to C1 discontinuities, for the RGB components\n// are driven by picewise linear segments. Using a cubic smoother (smoothstep) makes \n// the color transitions in RGB C1 continuous when linearly interpolating the hue H.\n\n// C2 continuity can be achieved as well by replacing smoothstep with a quintic\n// polynomial. Of course all these cubic, quintic and trigonometric variations break \n// the standard (http://en.wikipedia.org/wiki/HSL_and_HSV), but they look better.\n\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// compare\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 hsl = vec3( uv.x+iTime*0.1+uv.y* (iMouse.x/iResolution.x), 1.0, 1.0-uv.y );\n\n\tvec3 rgb_o = hsv2rgb( hsl );\n\tvec3 rgb_s = hsv2rgb_smooth( hsl );\n\t\n\tvec3 rgb = mix( rgb_o, rgb_s, smoothstep( -0.2, 0.2, 0.0) ); //sin(2.0*iTime)\n\tfragColor = vec4( rgb, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXSz2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[630, 665, 692, 692, 819], [821, 854, 888, 888, 1066], [1068, 1079, 1136, 1136, 1444]], "test": "untested"}
{"id": "llXXWj", "name": "Colourful Tiles", "author": "Rosie", "description": "Experimenting with colourful tiles and converting between rgb and hsv", "tags": ["tiles"], "likes": 1, "viewed": 136, "published": "Public", "date": "1439728291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(1, 0, 0);\n\tvec3 color2 = vec3(1, 1, 1);\n\tvec3 pixel;\n    \n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0 + 2.0*p;\n    q.x *= 1.777; \n    \n    vec2 modu = floor(mod(fragCoord.xy, vec2(50.0, 50.0)));\n    if(modu.x < 25.0 && modu.y >= 25.0){\n    \tvec3 hsv = rgb2hsv(color1);\n    \thsv.x = (0.6*p.y+cos(iTime*0.2));\n        hsv.y = 0.6;\n    \tpixel = hsv2rgb(hsv);\n    }else if(modu.y < 25.0 && modu.x >=25.0 ){\n        vec3 hsv = rgb2hsv(color1);\n    \thsv.x = (0.6*p.x+sin(iTime*0.2));\n        hsv.y = 0.6;\n   \t \tpixel = hsv2rgb(hsv);\n    }else{\n        vec3 hsv = rgb2hsv(color2);\n        hsv.z = clamp(sin(iTime*0.2),0.0,0.5);\n    \tpixel = hsv2rgb(hsv);\n    }\n    \n    \n    \n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 353], [355, 355, 377, 377, 546], [548, 548, 605, 605, 1342]], "test": "untested"}
{"id": "llXXWl", "name": "balls bounce", "author": "rcread", "description": "inspired by https://www.shadertoy.com/view/MllSDX", "tags": ["3d", "raytracing"], "likes": 5, "viewed": 341, "published": "Public", "date": "1440482448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sum( vec2 a ) { return a.x + a.y; }\nfloat min2( vec2 a ) { return min( a.x, a.y ); }\nfloat hash11( float a ) { return fract( sin( a ) * 13131. ); }\t//\tdeliberately 'bad' hash\n\nvec3 checker( vec3 ro, vec3 rd ) {\n\tfloat t, c; vec2 p, ps;\n\tt\t\t\t=\t-ro.y / rd.y;\t\t\t\t\t\t\t\t//\tdistance to floor\n\tif ( t <= 0. ) return vec3( 0 );\n\tp\t\t\t=\tro.xz + t * rd.xz;\t\t\t\t\t\t\t//\t2d floor position\n\tc\t\t\t=\tmod( sum( floor( p ) ), 2. );\t\t\t\t//\tfloor color\n\tps\t\t\t=\tfwidth( p );\t\t\t\t\t\t\t\t//\tpixel gradient\n\tp\t\t\t=\tfract( p );\n\tp\t\t\t=\tmin( p, 1. - p ) / ps;\t\t\t\t\t\t//\tAA alpha\n\tc\t\t\t=\tmix( .5, c, clamp( min2( p ), 0., 1. ) * max( 0., .9 * ( .9 - length( ps ) ) ) ) / max( 1., .06 * t );\n\treturn vec3( c );\n}\n\nvoid gen( vec3 ro, vec3 rd, float i, float n, out vec3 p, out vec3 c ) {\n\tfloat a, s, r, t, h;\n\ta\t\t\t=\tatan( rd.z, rd.x );\t\t\t\t\t\t\t//\tray angle\n\ts\t\t\t=\t( .5 + floor( a * n ) ) / n;\t\t\t\t//\tray sector\n\tr\t\t\t=\thash11( s );\t\t\t\t\t\t\t\t//\tray sector-specific random number\n\tr\t\t\t=\tfract( r * 3. );\n\tt\t\t\t=\tsqrt( n ) * ( 2. + 1e1 * sqrt( r ) );\t\t//\tdistance to ball\n\tr\t\t\t=\tfract( r * 3. );\n\th\t\t\t=\t( 2. + 8. * r ) * sqrt( smoothstep( 0., 1., abs( 1. - 2. * fract( i + r ) ) ) );\t//\tball height\n\tp\t\t\t=\tvec3( t * cos( s ), h, t * sin( s ) );\t\t//\tball position\n\tc\t\t\t=\tfract( r * vec3( 3, 9, 27 ) );\t\t\t\t//\tball color\n\tc\t\t\t/=\tmax( 1e-5, max( c.x, max( c.y, c.z ) ) );\n}\n\nvec3 sphere( vec3 ro, vec3 rd, vec3 p, float r, vec3 c, vec4 l, out float a ) {\n\tfloat d, t; vec3 i;\n\tt\t\t\t=\tdot( p - ro, rd );\t\t\t\t\t\t\t//\tdistance to nearest point on ray to sphere_center\n\ti\t\t\t=\tro + t * rd;\t\t\t\t\t\t\t\t//\tnearest point on ray to sphere_center\n\td\t\t\t=\tlength( p - i );\t\t\t\t\t\t\t//\tperpendicular distance ray nearest point to sphere_center\n\ta\t\t\t=\t1. - clamp( ( d - r ) / ( t / iResolution.y ), 0., 1. );\t//\tAA alpha\n\tt\t\t\t-=\t( d < r ) ? sqrt( r * r - d * d ) : 0.;\t\t//\tdistance to near side sphere intersect point\n\ti\t\t\t=\tro + t * rd;\t\t\t\t\t\t\t\t//\tnear side sphere intersect point\n\treturn c * l.w * max( 0., dot( normalize( i - p ), normalize( l.xyz - i ) ) );\n}\n\n\nvoid mainImage( out vec4 o, vec2 i ) {\n\tfloat a, t; vec2 uv; vec3 p, ro, rd, c, c2, up, cam, right;\n    \n\tt\t\t\t=\tiTime / 2.;\n\tro\t\t\t=\tvec3( 0, 4. * ( 1.01 + sin( t / 4. ) ), 0 );\n\ti\t\t\t=\tfloor( i ) / iResolution.y - .5;\n\tuv\t\t\t=\tvec2( t / 2e1, 0 );\n    up\t\t\t=\tvec3( 0, 1, 0 );\n\tcam\t\t\t=\tnormalize( vec3( sin( uv.x ), 2. * asin( uv.y ), cos( uv.x ) ) );\n\tright\t\t=\tnormalize( cross( cam, up ) );\n\trd\t\t\t=\tnormalize( cam + i.x * right + i.y * up );\n\n\tc\t\t\t=\tchecker( ro, rd );\n\n\t\t\t\t\tgen( ro, rd, t, 1e4, p, c2 );\n\tc\t\t\t=\tmix( c, sphere( ro, rd, p, .1, c2, vec4( 0, 1e2, 1e2, 1.5 ), a ), a );\n\t\t\t\t\tgen( ro, rd, t, 5e2, p, c2 );\n\tc\t\t\t=\tmix( c, sphere( ro, rd, p, .1, c2, vec4( 0, 1e2, 1e2, 1.5 ), a ), a );\n\t\t\t\t\tgen( ro, rd, t, 4e1, p, c2 );\n\tc\t\t\t=\tmix( c, sphere( ro, rd, p, .1, c2, vec4( 0, 1e2, 1e2, 1.5 ), a ), a );\n\t\t\t\t\tgen( ro, rd, t, 1e1, p, c2 );\n\tc\t\t\t=\tmix( c, sphere( ro, rd, p, .1, c2, vec4( 0, 1e2, 1e2, 1.5 ), a ), a );\n\n    o.rgb\t\t=\tc;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXXWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 127, 148, 148, 168], [169, 169, 191, 191, 217], [218, 218, 243, 243, 280], [281, 309, 343, 343, 802], [804, 804, 876, 876, 1449], [1451, 1451, 1530, 1530, 2113], [2116, 2116, 2154, 2154, 3054]], "test": "untested"}
{"id": "ltBXRz", "name": "Mimicking Waves", "author": "twernmilt", "description": "This is my attempt to mimic some of the techniques used in https://www.shadertoy.com/view/4dsGzH", "tags": ["2d"], "likes": 1, "viewed": 141, "published": "Public", "date": "1440990427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float isInBand(vec2 uv, float frequency, float amplitude) {\n    float waveValue = amplitude * sin(uv.x + iTime + frequency);\n    float lineWidth = 0.05;\n    return step(1.0 - lineWidth, 1.0 - abs((uv.y * 4.0 - 2.0) - waveValue));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv              = fragCoord.xy / iResolution.xy;\n    vec3  backgroundColor = vec3(1.0, 1.0, 0.85);\n    vec3  blockColor      = vec3(0.2, 0.2, 0.15);\n    vec3  bandColor       = vec3(1.0, 0.1, 0.1);\n    float isXBlock        = step(1.0 / 80.0, mod(uv.x, 1.0 / 40.0));\n    float isYBlock        = step(1.0 / 140.0, mod(uv.y, 1.0 / 40.0));\n    float isBlock         = isXBlock * isYBlock;\n    float isBand          = 0.0;\n    \n    for(float i = 0.0; i < 8.0; i++)\n      isBand += isInBand(uv, 2.0, i / 6.0);\n    \n    vec3 finalBackground = mix(backgroundColor, blockColor, isBlock); \n    vec3 finalColor      = mix(finalBackground, bandColor, isBand);\n    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 231], [233, 233, 290, 290, 991]], "test": "untested"}
{"id": "ltfSD2", "name": "Basic Shadow", "author": "Phong", "description": "Basic shadow example.", "tags": ["shadow"], "likes": 4, "viewed": 271, "published": "Public", "date": "1439744098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Direction(vec2 tex, vec2 res, vec2 fov)\n{\n\treturn normalize(vec3((2.0 * vec2(tex.x, tex.y) - 1.0) * fov, 1));\n}\n\nvec2 Add(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 Sub(vec2 d1, vec2 d2)\n{\n    return (-d2.x > d1.x) ? d2 : d1;\n}\n\nfloat Plane(vec3 p, vec4 n )\n{\n  return dot(p,normalize(n.xyz)) + n.w;\n}\n\nfloat Sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0)) - r;\n}\n\nmat4 RotX(float th)\n{\n\treturn mat4(1.0,0.0,0.0,0.0,0.0,cos(th),-sin(th),0.0, 0.0, sin(th), cos(th), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotY(float th)\n{\n\treturn mat4(cos(th), 0.0, sin(th), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(th), 0.0, cos(th), 0.0, 0.0, 0.0, 0.0, 0.0);\n}\n\nvec3 RotatingLight(float s)\n{\n\tvec3 p = vec3(14, 0, 0);\n    p = (RotY(s * iTime) * vec4(p,1)).xyz;\n\tp += vec3(0,8,0);\n\treturn p; \n}\n\nvec2 Scene(vec3 p)\n{\n    vec2 pl = vec2(Plane(p, vec4(0,1,0,15)), 0.0);\n    vec2 pl0 = vec2(Plane(p, vec4(0,0,-1,15)), 0.0);\n    vec2 pl1 = vec2(Plane(p, vec4(1,0,0,15)), 0.0);\n\tvec2 sph = vec2(Sphere(p-RotatingLight(1.0), 0.25), 0.5);\n\tvec2 sph2 = vec2(Sphere(p-RotatingLight(2.0), 0.25), 0.5);\n    vec2 obj = vec2(RoundBox(p - vec3(0,5.0 + (7.0 * sin(4.0 * iTime)),0), vec3(3,0.5,3), 0.5), 0.0);\n\treturn Add(Add(Add(Add(Add(pl, pl0), pl1), sph), sph2), obj);\n}\n\nvec2 March(vec3 o, vec3 d)\n{\n\tfloat t = 1.0; // Near plane.\n\tfloat f = 100.0;\n\tfloat m = -1.0;\n\n\tfor (int i=0; i < 256; ++i)\n\t{\n\t\tvec2 v = Scene(o + d * t);\n\n\t\tif (v.x <= .0002)\n\t\t\tbreak;\n\n\t\tt += v.x;\n\t\tm = v.y;\n\t}\n\tif (t>f)\n\t\tm = -1.0;\n\treturn vec2(t, m); \n}\n\nvec3 CalculateNormal(vec3 pos)\n{\n\tvec3 e = vec3(0.001,0,0);\n\tvec3 n = vec3(\n\t\tScene(pos+e.xyy).x - Scene(pos-e.xyy).x,\n\t\tScene(pos+e.yxy).x - Scene(pos-e.yxy).x,\n\t\tScene(pos+e.yyx).x - Scene(pos-e.yyx).x);\n\treturn normalize(n);\n}\n\nvec4 Phong(vec3 p, vec3 lp, vec3 v, vec4 diff)\n{\n\tvec3 l = normalize(lp - p);\n\tvec3 n = CalculateNormal(p);\n\tfloat ndl = clamp(dot(n,l), 0.0, 1.0);\n\tvec4 d = mix(vec4(0.0,0.0,0.0,0.0), diff, ndl);\n\tvec3 r = reflect(v, n);\n\tfloat rdl = pow(clamp(dot(r, l), 0.0, 1.0), 6.0);\n\n\tvec4 s = mix(vec4(0.0,0.0,0.0,0.0), vec4(1.0,1.0,1.0,1.0), rdl);\n\n\treturn d + s;\n}\n\nvec4 Shadow(vec3 p, vec3 lp, vec3 v)\n{\n    vec3 l = normalize(lp - p);\n    \n    vec2 res = March(p, l);\n    \n    if (res.y == 0.5)\n        return vec4(1,1,1,1);\n    \n\treturn vec4(0,0,0,0); \n}\n\nvec4 RenderScene(vec3 ro, vec3 rd)\n{\n\tvec2 res = March(ro, rd);\n\tvec4 c = vec4(0,0,0,1);\n\n\t// PHONG\n\tif (res.y == 0.0)\n\t{\n\t\tvec3 pos = ro + rd * res.x;\n\t\tvec3 lp = RotatingLight(1.0);\t\t\n\t\tvec3 lp2 = RotatingLight(2.0);\t\t\n\t\tvec3 lp3 = RotatingLight(3.0);\t\t\n\t\tvec3 lp4 = RotatingLight(4.0);\t\t\n\t\t\n\t\tc = Phong(pos, lp, rd, vec4(0.0,0.0,1.0,1.0));\n\t\tc += Phong(pos, lp2, rd, vec4(1.0,0.0,0.0,1.0));\n\n        vec4 sh = vec4(0,0,0,0);\n        \n        sh += Shadow(pos, lp, rd);\n        sh += Shadow(pos, lp2, rd);\n        sh /= 2.0;\n        c *= sh;\n\t}\n\telse if (res.y == 0.5 )\n\t{\n\t\tc = vec4(1,1,1,1);\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(40,40,-40);\n    float aspect = iResolution.y / iResolution.x;\n    float hFOV = 3.1415/4.0;\n    \n\tvec3 rd = Direction(uv, iResolution.xy, vec2(hFOV, aspect * hFOV));\n\trd = (RotX(-3.1415/6.0) * vec4(rd,1)).xyz;\n\trd = (RotY(3.1415/4.0) * vec4(rd,1)).xyz;\n\t\n\tfragColor = RenderScene(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 116], [118, 118, 146, 146, 181], [183, 183, 211, 211, 250], [252, 252, 282, 282, 324], [326, 326, 357, 357, 382], [384, 384, 425, 425, 467], [469, 469, 490, 490, 596], [598, 598, 619, 619, 732], [734, 734, 763, 763, 865], [867, 867, 887, 887, 1329], [1331, 1331, 1359, 1359, 1590], [1592, 1592, 1624, 1624, 1821], [1823, 1823, 1871, 1871, 2180], [2182, 2182, 2220, 2220, 2373], [2375, 2375, 2411, 2411, 2986], [2988, 2988, 3045, 3045, 3396]], "test": "untested"}
{"id": "ltfSWj", "name": "It's a ball", "author": "Trippler", "description": "Seriously, only a ball", "tags": ["nothing"], "likes": 1, "viewed": 96, "published": "Public", "date": "1439667559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0,0,0,0);\n    float fx = fragCoord.x-100.0;\n    float fy = fragCoord.y-125.0+sin(iTime*2.0)*90.0;\n    if(fx*fx+fy*fy < 1000.0)\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 296]], "test": "untested"}
{"id": "ltfSWS", "name": "learning shiz", "author": "ericrius1", "description": "for learning", "tags": ["learning"], "likes": 3, "viewed": 150, "published": "Public", "date": "1439311072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n                  vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n  \n   \n\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    \n  float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n      vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n      m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n    float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n      map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n      map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n      map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n  float m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n    col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    \n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n\n      col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n  return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n     \n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n  vec3 ta = vec3( -0.5, -0.4, 0.5 );\n  \n  // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n  vec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render \n    vec3 col = render( ro, rd );\n\n  col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfSWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 378, 403, 403, 419], [421, 421, 456, 456, 482], [486, 486, 516, 516, 550], [553, 627, 652, 652, 812], [814, 814, 854, 854, 1182], [1185, 1185, 1259, 1259, 1523], [1525, 1525, 1557, 1557, 1784], [1786, 1786, 1828, 1828, 2128], [2133, 2133, 2172, 2172, 3779], [3781, 3781, 3833, 3833, 4014], [4016, 4016, 4073, 4073, 4679]], "test": "untested"}
{"id": "ltfXzj", "name": "[SIG15] sigmoids n sines", "author": "victor_shepardson", "description": "improvised some psychedelic nonsense... getting 2001 and enter the void vibes", "tags": ["procedural", "2d", "psychedelic"], "likes": 115, "viewed": 14003, "published": "Public", "date": "1438915075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nfloat sigmoid(float x){\n \treturn x/(1.+abs(x));   \n}\n\nfloat iter(vec2 p, vec4 a, vec4 wt, vec4 ws, float t, float m, float stereo){\n    float wp = .2;\n    vec4 phase = vec4(mod(t, wp), mod(t+wp*.25, wp), mod(t+wp*.5, wp), mod(t+wp*.75, wp))/wp;\n    float zoom = 1./(1.+.5*(p.x*p.x+p.y*p.y));\n    vec4 scale = zoom*pow(vec4(2.), -4.*phase);\n    vec4 ms = .5-.5*cos(2.*pi*phase);\n    vec4 pan = stereo/scale*(1.-phase)*(1.-phase);\n    vec4 v = ms*sin( wt*(t+m) + (m+ws*scale)*((p.x+pan) * cos((t+m)*a) + p.y * sin((t+m)*a)));\n    return sigmoid(v.x+v.y+v.z+v.w+m);\n}\n\nvec3 scene(float gt, vec2 uv, vec4 a0, vec4 wt0, vec4 ws0, float blur){\n    //time modulation\n    float tm = mod(.0411*gt, 1.);\n    tm = sin(2.*pi*tm*tm);\n    float t = (.04*gt + .05*tm);\n    \n    float stereo = 1.*(sigmoid(2.*(sin(1.325*t*cos(.5*t))+sin(-.7*t*sin(.77*t)))));//+sin(-17.*t)+sin(10.*t))));\n    //t = 0.;\n    //also apply spatial offset\n    uv+= .5*sin(.33*t)*vec2(cos(t), sin(t));\n    \n    //wildly iterate and divide\n    float p0 = iter(uv, a0, wt0, ws0, t, 0., stereo);\n    \n   \tfloat p1 = iter(uv, a0, wt0, ws0, t, p0, stereo);\n    \n    float p2 = sigmoid(p0/(p1+blur));\n    \n    float p3 = iter(uv, a0, wt0, ws0, t, p2, stereo);\n    \n    float p4 = sigmoid(p3/(p2+blur));\n    \n    float p5 = iter(uv, a0, wt0, ws0, t, p4, stereo);\n    \n    float p6 = sigmoid(p4/(p5+blur));\n    \n    float p7 = iter(uv, a0, wt0, ws0, t, p6, stereo);\n    \n    float p8 = sigmoid(p4/(p2+blur));\n    \n    float p9 = sigmoid(p8/(p7+blur));\n    \n    float p10 = iter(uv, a0, wt0, ws0, t, p8, stereo);\n    \n    float p11 = iter(uv, a0, wt0, ws0, t, p9, stereo);\n    \n    float p12 = sigmoid(p11/(p10+blur));\n    \n    float p13 = iter(uv, a0, wt0, ws0, t, p12, stereo);\n    \n    //colors\n    vec3 accent_color = vec3(1.,0.2,0.);//vec3(0.99,0.5,0.2);\n    /*float r = sigmoid(-1.+2.*p0+p1-max(1.*p3,0.)+p5+p7+p10+p11+p13);\n    float g = sigmoid(-1.+2.*p0-max(1.*p1,0.)-max(2.*p3,0.)-max(2.*p5,0.)+p7+p10+p11+p13);\n    float b = sigmoid(0.+1.5*p0+p1+p3+-max(2.*p5,0.)+p7+p10+p11+p13);\n    */\n    float r = sigmoid(p0+p1+p5+p7+p10+p11+p13);\n    float g = sigmoid(p0-p1+p3+p7+p10+p11);\n    float b = sigmoid(p0+p1+p3+p5+p11+p13);\n    \n    \n    vec3 c = max(vec3(0.), .4+.6*vec3(r,g,b));\n    \n    float eps = .4;\n    float canary = min(abs(p1), abs(p2));\n    canary = min(canary, abs(p5));\n    //canary = min(canary, abs(p6));\n    canary = min(canary, abs(p7));\n    canary = min(canary, abs(p10));\n    float m = max(0.,eps-canary)/eps;\n    m = sigmoid((m-.5)*700./(1.+10.*blur))*.5+.5;\n    //m = m*m*m*m*m*m*m*m*m*m;\n    vec3 m3 = m*(1.-accent_color);\n    c *= .8*(1.-m3)+.3;//mix(c, vec3(0.), m);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = min(iResolution.x, iResolution.y);\n   \tvec2 uv = (2.*fragCoord.xy - vec2(iResolution.xy)) / s;\n    \n    float blur = .5*(uv.x*uv.x+uv.y*uv.y);\n    \n    //angular, spatial and temporal frequencies\n    vec4 a0 = pi*vec4(.1, -.11, .111, -.1111); \n    vec4 wt0 = 2.*pi*vec4(.3);//.3333, .333, .33, .3);\n    vec4 ws0 = 2.5*vec4(11., 13., 11., 5.);\n\n    //aa and motion blur\n    float mb = 1.;\n    float t = 1100.+iTime;\n    vec3 c = scene(t, uv, a0, wt0, ws0, blur)\n        + scene(t-mb*.00185, uv+(1.+blur)*vec2(.66/s, 0.), a0, wt0, ws0, blur)\n        + scene(t-mb*.00370, uv+(1.+blur)*vec2(-.66/s, 0.), a0, wt0, ws0, blur)\n        + scene(t-mb*.00555, uv+(1.+blur)*vec2(0., .66/s), a0, wt0, ws0, blur)\n        + scene(t-mb*.00741, uv+(1.+blur)*vec2(0., -.66/s), a0, wt0, ws0, blur)\n        + scene(t-mb*.00926, uv+(1.+blur)*vec2(.5/s, .5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*.01111, uv+(1.+blur)*vec2(-.5/s, .5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*.01296, uv+(1.+blur)*vec2(-.5/s, -.5/s), a0, wt0, ws0, blur)\n        + scene(t-mb*.01481, uv+(1.+blur)*vec2(.5/s, -.5/s), a0, wt0, ws0, blur)\n\n        ;\n    c/=9.;\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 79], [81, 81, 158, 158, 591], [593, 593, 664, 686, 2701], [2703, 2703, 2760, 2760, 3935]], "test": "untested"}
{"id": "ltlSRl", "name": "Life of a tree", "author": "adam27", "description": "Tree and leaves rendered with distance fields.", "tags": ["3d", "raymarching", "distancefield", "tree", "leaf", "nature", "warsztat", "leaves"], "likes": 34, "viewed": 4433, "published": "Public API", "date": "1439049423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst int MAX_STEPS = 100;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct Distance\n{\n\tfloat value;\n\tvec3 color;\n};\n\nstruct Hit\n{\n\tbool is;\n\tvec3 pos;\n\tvec3 color;\n};\n    \nmat4 rotateX(float angle)\n{\n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateY(float angle)\n{\n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateZ(float angle)\n{\n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 translate(vec3 t)\n{\n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 repeat(vec3 p, vec3 s)\n{\n\treturn mod(p, s) - s/2.0;\n}\n    \n    \nfloat sphere(vec3 p, float d)\n{ \n    return length(p) - d/2.0;  \n}\n\nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s/2.0;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n\nfloat capsule(vec3 p, float h, float d)\n{\n    float x = clamp(p.y/h, 0.0, 1.0);\n    return length(p - vec3(0.0, h*x, 0.0)) - d*0.5;\n}\n    \nDistance add(Distance d1, Distance d2)\n{\n    if (d2.value > d1.value)\n        return d1;\n    else\n        return d2;\n}\n\nDistance smooth_add(Distance d1, Distance d2, float k)\n{\n    float a = d1.value;\n    float b = d2.value;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return Distance(mix(b, a, h) - k*h*(1.0-h), mix(d2.color, d1.color, pow(h, 2.0)));\n}\n\nDistance intersection(Distance d1, Distance d2)\n{\n\tif (d1.value > d2.value)\n\t\treturn d1;\n\telse\n\t\treturn d2;\n}\n    \nDistance distance(vec3 p0)\n{         \n    vec4 p = vec4(p0, 1.0);\n    mat4 m;   \n    \n        \n    vec3 color = vec3(0.7, 0.52, 0.4) * 0.7;// * (sin(p.x*30.0)*sin(p.y*2.0)*sin(p.z*30.0)*0.1+0.7);    \n    \n    Distance d = Distance(sphere(p0 + vec3(0.0, 100.0, 0.0), 200.0) + sin(p.x/2.0)*cos(p.z/2.0)/2.0, vec3(0.2, 0.8, 0.5));\n    \n    \n    d = smooth_add(d, Distance(capsule(p.xyz, 3.0, 0.6), color), 0.8);     \n    \n    p *= rotateY(sin(iTime)*2.0+sin(p.y)*2.0); \n    m = translate(vec3(0.0, 3.0, 0.0)) * rotateY(40.0) * rotateX(35.0);    \n    p.x = abs(p.x) - 0.05;\n    p.z = abs(p.z) - 0.05;    \n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 2.0, 0.4), color), 0.1); \n    \n    p *= rotateY(10.0+sin(iTime+p.x)*5.0+sin(p.x)*5.0);    \n    m = translate(vec3(0.0, 2.0, 0.0)) * rotateY(45.0) * rotateX(30.0);    \n    p.x = abs(p.x) - 0.03;\n    p.z = abs(p.z) - 0.03;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 1.5, 0.2), color), 0.1); \n    \n    p *= rotateY(15.0+sin(iTime+p.z)*8.0+cos(p.z)*8.0);  \n    m = translate(vec3(0.0, 1.5, 0.0)) * rotateY(55.0+sin(p.x)*10.0) * rotateX(35.0);    \n    p.x = abs(p.x) - 0.01;\n    p.z = abs(p.z) - 0.01;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 2.3, 0.08), color), 0.1); \n    \n    \n    float leafSize = min(sin(iTime / 3.0) * 0.06 + 0.11, 0.15);\n    vec3 leafColor = hsv2rgb(vec3(cos((iTime) / 3.0 + sin((p.x+p.y+p.z)*5.0)/3.0) * 0.14 + 0.18, 0.7, 0.8));\n    \n    vec4 r = p;\n    r.x = abs(r.x);\n    r.z = abs(r.z);\n    Distance leafs = Distance(max(sphere(repeat((r.xyz+vec3(0.0, 0.09, 0.1))/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 4.6, 0.2))), leafColor);\n    d = add(d, leafs);\n    \n    p *= rotateY(10.0+sin(iTime+r.x)*10.0+sin(r.x)*10.0);  \n    m = translate(vec3(0.0, 1.0, 0.0)) * rotateY(55.0) * rotateX(40.0);    \n    p.x = abs(p.x) - 0.01;\n    p.z = abs(p.z) - 0.01;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 1.2, 0.04), color), 0.1); \n    \n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    leafs = Distance(max(sphere(repeat((p.xyz+vec3(0.0, 0.0, 0.1))/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 2.5, 0.2))), leafColor);\n    d = add(d, leafs); \n    \n    \n    return d;\n}\n\nHit castRay(inout vec3 p, vec3 dir)\n{\t\n\tHit hit;\n\tDistance dist = distance(p);\n\tfloat eps = 0.001;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tDistance dist = distance(p);\n\t\tfloat d = dist.value;\n                \n\t\tif (d <= eps)\n\t\t{\n            hit.is = true;\n            hit.pos = p;\n            hit.color = dist.color * (1.0 - float(i) / float(MAX_STEPS));\n            return hit;\n\t\t}\n        \n\t\tp += dir*d*0.9;\n\t}\t\n\thit.is = false;\n\thit.color = vec3(0);\n\treturn hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(-iMouse.x/200.0+2.2, radians(25.0));\n    vec3 center = vec3(0.0, 4.0, 0.0);\n    float zoom = 10.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy) / iResolution.yy - vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p * 0.8;\n    p = p * zoom + center;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(-0.6, 0.8, -0.3));\n    \n    \n\tHit hit = castRay(p, dir);\n    \n\tif (hit.is)\n    {        \n        vec3 normal;\n\t\tfloat eps = 0.001;\n        normal.x = distance(p + vec3(eps,0,0)).value - distance(p - vec3(eps,0,0)).value;\n        normal.y = distance(p + vec3(0,eps,0)).value - distance(p - vec3(0,eps,0)).value;\n        normal.z = distance(p + vec3(0,0,eps)).value - distance(p - vec3(0,0,eps)).value;\n        normal = normalize(normal);\n        vec3 c = mix(hit.color, vec3(0.8), normal.y * pow(1.0 - (cos(iTime / 3.0 - 1.5) / 2.0 + 0.5), 4.0) * (sign(hit.pos.y - 1.0) / 2.0 + 0.5));\n\t\tcolor = c * (max(dot(normal, light), 0.0) * 0.8 + 0.4) * min(5.0/length(p-vec3(0.0, 5.0, 0.0)), 2.0);\n        \n    }\n\telse\n\t\tcolor = vec3(0);\n\t\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlSRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1, 108, 130, 130, 299], [405, 405, 432, 432, 609], [610, 610, 637, 637, 814], [815, 815, 842, 842, 1019], [1020, 1020, 1044, 1044, 1143], [1145, 1145, 1174, 1174, 1203], [1214, 1214, 1245, 1245, 1280], [1282, 1282, 1309, 1309, 1408], [1410, 1410, 1451, 1451, 1543], [1549, 1549, 1589, 1589, 1667], [1669, 1669, 1725, 1725, 1910], [1912, 1912, 1961, 1961, 2021], [2027, 2027, 2055, 2055, 4324], [4326, 4326, 4363, 4363, 4797], [4799, 4799, 4854, 4854, 6248]], "test": "untested"}
{"id": "ltlSWf", "name": "Flux Core", "author": "otaviogood", "description": "Long range space-based energy transmission requires a flux core to amplify and concentrate energy.\n*** Try out the high quality non-realtime renderer. Feel free to use it for your shaders if you want to render screenshots.", "tags": ["fractal", "space"], "likes": 210, "viewed": 19924, "published": "Public API", "date": "1440476793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat length8(vec2 v)\n{\n\treturn pow(pow(abs(v.x),8.0) + pow(abs(v.y), 8.0), 1.0/8.0);\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n   \tfloat a = atan(p.x, p.z);\n    float subs = 2.0;\n\ta = sin(a*subs+localTime*4.0+offset*3.234567);\n\tvec2 q = vec2(length(p.xz)-t.x-a*0.1,p.y);\n\treturn length8(q)-t.y;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlSWf.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1278, 1307, 1326, 1326, 1371], [1372, 1372, 1391, 1391, 1422], [1423, 1423, 1446, 1446, 1482], [1483, 1483, 1506, 1506, 1577], [1578, 1578, 1600, 1600, 1687], [1688, 1688, 1710, 1710, 1763], [1764, 1764, 1787, 1787, 1860], [1861, 1861, 1884, 1884, 1955], [1956, 1956, 1979, 1979, 2065], [2066, 2066, 2107, 2107, 2150], [2188, 2188, 2212, 2212, 2485], [2486, 2486, 2508, 2508, 3093], [3123, 3123, 3146, 3146, 3175], [3176, 3176, 3199, 3199, 3228], [3229, 3229, 3254, 3254, 3283], [3285, 3285, 3318, 3318, 3435], [3436, 3436, 3469, 3469, 3585], [3586, 3586, 3619, 3619, 3736], [3738, 4267, 4294, 4294, 4859], [4861, 4906, 4933, 4933, 4966], [4967, 4967, 4992, 4992, 5025], [5027, 5027, 5058, 5058, 5279], [5281, 5281, 5306, 5306, 5594], [5596, 5596, 5627, 5627, 5791], [5793, 5793, 5824, 5824, 5927], [5929, 6109, 6132, 6132, 6196], [6198, 6220, 6254, 6254, 6365], [6367, 6411, 6463, 6463, 6633], [6635, 6669, 6697, 6697, 6725], [6784, 6946, 6978, 6978, 9802], [9804, 9874, 9909, 9909, 20901], [22233, 22233, 22290, 22290, 23649]], "test": "untested"}
{"id": "ltlXWf", "name": "Pseudo Doraemon", "author": "chimanaco", "description": "Test sketch for Rendora (Repetitious Doraemon)", "tags": ["raymarching"], "likes": 4, "viewed": 178, "published": "Public", "date": "1440337424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Forked From\n// inigo quilez's Raymarching - Primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n//----------------------------------------------------------------------\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n//----------------------------------------------------------------------\n\nfloat wrap(float x) {\n  return abs(mod(x, 2.)-1.);\n}\n\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 temp = vec3(0., 0., 0.);\n    //temp = mod(p,c)-0.5*c;\n    \n    if(c != temp) {\n\t    temp = mod(p,c)-0.5*c;\n    }\n    \n\treturn temp; \n    //return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nfloat repeatX = 1.5;\nfloat repeatY = 0.0;\nfloat repeatZ = 1.5;\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    float scale = 2.0;\n\n  vec3 q = pos;\n  //q = q  * vec3(1.0, 1.0, 0.5);\n\n    q = opRep( q - vec3(0.0, 0.0, iTime), vec3(repeatX * cos(iTime) + repeatX * 1.5, 0.0, repeatZ) );      \n    q.z = abs(q.z);\n\n  /*\n  float size = 0.0;\n  float wrapSpeed = 1.;\n  q.z = mod(q.z, size);\n  q.z = abs(q.z - size/2.);\n  q.z = wrap(q.z + iTime * wrapSpeed);\n\t*/\n\n  vec2 res = opU( vec2( sdPlane(pos), 1.0 ),\n                  vec2( sdSphere( q-vec3( 0.0,0.50, 0.0), 0.5 ), 80. ) );  \n    \n    res = opU( res, vec2( sdSphere( q-vec3( -0.1,0.35 * scale, 0.4), 0.05 * scale ), 3.0 ) );\n  res = opU( res, vec2( sdSphere( q-vec3( 0.1,0.35 * scale, 0.4), 0.05 * scale ), 3.0 ) );\n  res = opU( res, vec2( sdSphere( q-vec3( -0.1 + 0.05 * cos(iTime * 10. + q.x),0.7, 0.48), 0.02 * scale ), 0. ) );\n  res = opU( res, vec2( sdSphere( q-vec3( 0.1 + 0.05 * cos(iTime * 10. + q.y),0.7, 0.48), 0.02 * scale ), 0. ) );\n  res = opU( res, vec2( sdSphere( q-vec3( 0.,0.28 * scale, 0.4), 0.06 * scale ), 290.0 ) );\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n  float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n      vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n      m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n    float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n      map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n      map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n      map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n  float m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n    col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    \n        if( m<1.5 )\n        {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n            \n            if( m == 0.) {\n                //float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n              col = vec3(0.0, 0.0, 0.);\n            }\n        }  \n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        //brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n\n      col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n  return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n     \n  float time = 15.0 + iTime * 1.;\n\n  // camera \n  vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 3.0 + 2.0 * cos(time) + 8.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n  vec3 ta = vec3( -0.5, -0.4, 0.5 );\n  \n  // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n  vec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render \n    vec3 col = render( ro, rd );\n\n  col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlXWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[553, 627, 648, 648, 679], [681, 681, 706, 706, 722], [724, 724, 759, 759, 785], [788, 862, 895, 895, 921], [923, 923, 953, 953, 987], [989, 989, 1019, 1019, 1192], [1194, 1194, 1218, 1218, 1350], [1490, 1564, 1589, 1589, 2588], [2590, 2590, 2630, 2630, 3223], [3226, 3226, 3300, 3300, 3564], [3566, 3566, 3598, 3598, 3825], [3827, 3827, 3869, 3869, 4169], [4174, 4174, 4213, 4213, 5981], [5983, 5983, 6035, 6035, 6216], [6218, 6218, 6275, 6275, 6905]], "test": "untested"}
{"id": "ltsSRs", "name": "RayTracer Trip", "author": "umarniz", "description": "Test Shader", "tags": ["raytracing", "test", "tripcolors"], "likes": 1, "viewed": 110, "published": "Public", "date": "1439122368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Create camera matrix\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Plane Equation\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize UVS to -1, 1\n\tvec2 uv = 1.0 - 2.*fragCoord.xy / iResolution.xy;\n\t// Fix aspect ratio\n    vec2 aspect = uv * (fragCoord.x / fragCoord.y);\n    \n    // Mouse coordinates\n    vec2 normalizedCoord = (iMouse.xy/iResolution.xy);\n    \n    // Create Camera Matrix\n    vec3 camO, camT;\n    camO = vec3(normalizedCoord.x,0.,normalizedCoord.y);\n    camT = vec3(0.+sin(iTime),0.2,0.5 * cos(iTime));\n    \n    mat3 cam = setCamera(camO, camT, 0.);\n    \n    // Get ray direction\n    vec3 rd = cam * normalize(vec3(aspect.xy,2.5));\n    vec3 ro = vec3(0,0,0);\n    \n    vec3 color;\n    for (float i=0.5;i<1.;i+=0.001)\n    {\n        // Get vector from plane equation\n        vec2 res = vec2(sdPlane(ro+rd*i), 1.0);\n        \n        // Get hit position and use for further calculations\n        vec3 pos = ro + res.x*rd;\n\n        // Checker Texture\n        float f = mod( floor(100.0*pos.z) + floor(100.0*pos.x), 2.0);\n        color = 0.4 + 0.1*f*vec3(1.0);\n        \n        // Trip out the colors\n        color.x = sin(color.x+cos(iTime));\n        color.y = cos(color.x+sin(iTime));\n    }\n    \n    fragColor = vec4(color.xyz, 1.0);\n    \n    \n\t//fragColor = vec4(aspect,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 25, 80, 80, 257], [259, 277, 302, 302, 317], [319, 319, 376, 406, 1568]], "test": "untested"}
{"id": "ltsSWl", "name": "emix-0012", "author": "sm", "description": "A prototype of one of the many overlay effects for demoscene production \"Emix\" (https://www.youtube.com/watch?v=F415chvZhHo)", "tags": ["tunnel", "vj"], "likes": 7, "viewed": 639, "published": "Public API", "date": "1440711344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int Npoly = 3;\nconst float TWOPI = 6.283185;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 d) {\n    float dn = dot(d, n);\n    float s = 1e8;\n    \n    if (dn != 0.0) {\n        s = dot(p - o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    return o + s * d;;\n}\n\nvec3 rayTriangle(vec3 o, vec3 ray) {\n    const float R = 2.0;\n    vec3 cand = o;\n\tfloat cdist = 1e10;\n    float phase = 0.2 * iTime;\n    \n    for (int i = 0; i < Npoly; i++) {\n        vec3 p = R * vec3(cos(TWOPI * float(i) / float(Npoly) + phase),\n                          sin(TWOPI * float(i) / float(Npoly) + phase),\n                          0.0);\n        vec3 n = normalize(-p);\n        vec3 rh = rayPlane(p, o, n, ray);\n        float dist = length(rh - o);\n        \n        if (dist < cdist) {\n            cand = rh;\n            cdist = dist;\n        }\n    }\n    return cand;\n}\n\nvec4 colorize(vec3 pos) {\n    float c = float(mod(pos.z, 0.03) < 0.015);\n    return vec4(vec3(c), 1.0);\n}\n\nvec4 trace(vec2 p) {\n    vec3 ray = normalize(vec3(p, 5.0/200.0));\n    vec3 campos = vec3(0.0, 0.0, 0.05*iTime);\n   \tvec3 hitpos = rayTriangle(campos, ray);\n    vec4 col = colorize(hitpos);\n    \n    // fog me beautiful\n    float fogfactor = exp(3.5 - 2.0 * length(hitpos - campos));\n    vec4 oc =  col * min(1.0, fogfactor);\n    return oc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 buv = fragCoord.xy / iResolution.xy - vec2(0.5);\n\tvec2 uv = buv;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor = trace(uv);\n    for (int i = 0; i < 4; i++) {\n        uv = buv + 0.25*vec2(cos(fragCoord.x+fragCoord.y + float(i)*TWOPI/4.0),\n                             sin(fragCoord.x+fragCoord.y + float(i)*TWOPI/4.0)) / iResolution.xy;\n\t    uv.x *= iResolution.x / iResolution.y;\n        fragColor += trace(uv);\n    }\n    fragColor /= 5.0;\n    fragColor += 0.1*rand(fragCoord.xy + 0.1*iTime);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 72, 72, 144], [146, 146, 193, 193, 362], [364, 364, 400, 400, 947], [949, 949, 974, 974, 1054], [1056, 1056, 1076, 1076, 1397], [1399, 1399, 1456, 1456, 1971]], "test": "untested"}
{"id": "ltsXRs", "name": "[SIG15] city demo", "author": "yasuo", "description": "well... My first competition try out. It's simple 3d stuff.", "tags": ["3d", "raymarching", "demo", "sig15"], "likes": 3, "viewed": 241, "published": "Public", "date": "1439139947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\t\t\n\n\t\t#define NEAR 0.1\n\t\t#define FAR 100.\n\t\t#define ITER 64\n\n\t\t#define PI\t3.14159265359\n\t\t#define PIH\t(PI/2.0)\n\t\t#define PI2\t(PI*2.0)\n\n\t\tfloat gt;\n\t\tfloat gtime;\n\n\t\tfloat c_0 = 31599.0;\n\t\tfloat c_1 = 9362.0;\n\t\tfloat c_2 = 29671.0;\n\t\tfloat c_3 = 29391.0;\n\t\tfloat c_4 = 23497.0;\n\t\tfloat c_5 = 31183.0;\n\t\tfloat c_6 = 31215.0;\n\t\tfloat c_7 = 29257.0;\n\t\tfloat c_8 = 31727.0;\n\t\tfloat c_9 = 31695.0;\n\n\n\t\t// from http://glslsandbox.com/e#26519.0 Thanks\n\t\tvec3 target;\n\t\tvec3 forward = vec3(0.0, -0.1, 0.0);\n\t\tvec4 quaternion(vec3 p, float a)\n\t\t{\n\t\t\treturn vec4(p*sin(a/2.0),cos(a/2.0));\n\t\t}\n\n\t\tvec3 qtransform(vec4 q, vec3 v)\n\t\t{\n\t\t\treturn v+2.0*cross(cross(v,q.xyz)-q.w*v,q.xyz);\n\t\t}\n\t\t// ========\n\n\t\tmat4 matRotateX(float rad)\n\t\t{\n\t\t\treturn mat4(1,       0,        0,0,\n\t\t\t\t\t\t0,cos(rad),-sin(rad),0,\n\t\t\t\t\t\t0,sin(rad), cos(rad),0,\n\t\t\t\t\t\t0,       0,        0,1);\n\t\t}\n\n\t\tmat4 matRotateY(float rad)\n\t\t{\n\t\t\treturn mat4( cos(rad),0,-sin(rad),0,\n\t\t\t\t\t\t 0,       1,        0,0,\n\t\t\t\t\t\t sin(rad),0, cos(rad),0,\n\t\t\t\t\t\t 0,       0,        0,1);\n\t\t}\n\n\t\tmat4 matRotateZ(float rad)\n\t\t{\n\t\t\treturn mat4(cos(rad),-sin(rad),0,0,\n\t\t\t\t\t\tsin(rad), cos(rad),0,0,\n\t\t\t\t\t\t       0,        0,1,0,\n\t\t\t\t\t\t\t   0,        0,0,1);\n\t\t}\n\n\t\t// this code from GLSL sandbox\n\t\t//returns 0/1 based on the state of the given bit in the given number\n\t\tfloat getBit(float num,float bit)\n\t\t{\n\t\t\tnum = floor(num);\n\t\t\tbit = floor(bit);\n\t\t\t\n\t\t\treturn float(mod(floor(num/pow(2.,bit)),2.) == 1.0);\n\t\t}\n\n\t\tfloat Sprite3x5(float sprite,vec2 p)\n\t\t{\n\t\t\tfloat bounds = float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))));\n\t\t\t\n\t\t\treturn getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * bounds;\n\t\t}\n\n\t\tfloat Digit(float num,vec2 p)\n\t\t{\n\t\t\tnum = mod(floor(num),10.0);\n\t\t\t\n\t\t\tif(num == 0.0) return Sprite3x5(c_0,p);\n\t\t\tif(num == 1.0) return Sprite3x5(c_1,p);\n\t\t\tif(num == 2.0) return Sprite3x5(c_2,p);\n\t\t\tif(num == 3.0) return Sprite3x5(c_3,p);\n\t\t\tif(num == 4.0) return Sprite3x5(c_4,p);\n\t\t\tif(num == 5.0) return Sprite3x5(c_5,p);\n\t\t\tif(num == 6.0) return Sprite3x5(c_6,p);\n\t\t\tif(num == 7.0) return Sprite3x5(c_7,p);\n\t\t\tif(num == 8.0) return Sprite3x5(c_8,p);\n\t\t\tif(num == 9.0) return Sprite3x5(c_9,p);\n\t\t\t\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tvec3 digitTex(vec2 position)\n\t\t{\n\t\t\tposition = position*vec2(4,3);\n\n\t\t\tposition.x = mod(position.x, 8.0)-4.0;\n\t\t\tposition.y = mod(position.y, 14.0)-7.0;\n\n\t\t\tvec2 cpos = vec2(1.0);\n\t\t\tfloat dc = Digit(fract(iTime)*10.0,floor(position-cpos));\n\t\t\tvec3 cl2 = vec3(dc)*vec3(1,1,1);\t\n\t\t\treturn cl2;\n\t\t}\n\n\t\tvec3 lineTex(vec2 uv)\n\t\t{\n\t\t\treturn vec3(tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0,tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0,tan((uv.x+uv.y+(-iTime/10.0))*10.0)*10.0);\n\t\t}\n\n\t\t// Mr. iq's distance functions \n\t\tfloat udBox( vec3 p, vec3 b )\n\t\t{\n\t\t\treturn length(max(abs(p)-b,0.0));\n\t\t}\n\n\t\tfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n\t\t{\n\t\t\tvec3 pa = p-a, ba = b-a;\n\t\t\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\t\treturn length( max(abs(pa - ba*h), 0.0));\n\t\t}\n\n\t\tvec4 mapCube( vec3 pos, vec3 cl)\n\t\t{\n\t\t\tfloat dist = udBox(  pos , vec3(3.0,6.0,3.0));\n\t\t\treturn vec4( cl, dist );\n\t\t}\n\n\t\tvec4 combine(vec4 val1, vec4 val2 )\n\t\t{\n\t\t\tif ( val1.w < val2.w ) return val1;\n\t\t\treturn val2;\n\t\t}\n\n\t\tfloat ship(vec3 p)\n\t\t{\n\t\t\tp += target;\n\t\t\tvec4 q = quaternion(forward, iTime);\n\t\t\tp = qtransform(q, p);\n\t\t\tvec4 newP = vec4(p.xyz,1.0);\n\t\t\tfloat f1 = length(newP.xyz)-2.0;\n\n\t\t\treturn f1;\n\t\t}\n\n\t\tvec3 course(float a)\n\t\t{\n\t\t\treturn vec3(\n\t\t\t\tcos(a)*35.0,\n\t\t\t\t0.0,\n\t\t\t\tsin(2.0*a)*25.0\n\t\t\t);\n\t\t}\n\t\t\n\t\tfloat cubicInOut(float t) {\n\t\t  return t < 0.5\n\t\t    ? 4.0 * t * t * t\n\t\t    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n\t\t}\n\n\t\tfloat ind = 0.0;\n\t\tvec4 map( vec3 pos, mat4 m, mat4 m2)\n\t\t{\n\t\t\tvec4 qf = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\t\t\tvec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\t\t\t\n\t\t\tqf.x = mod(qf.x, 16.0)-8.0;\n\t\t\tqf.z = mod(qf.z, 16.0)-8.0;\n\n\n\t\t\tvec3 lTex = lineTex(pos.xy);\n\n\t\t\tvec4 localCube = vec4(qf.xyz + vec3( 0, 10.0, 0 ),1.0)*m2;\n\t\t\tvec4 val1 = mapCube(localCube.xyz, vec3(0.03)+digitTex(pos.xy)*lTex );\n\t\t\tind++;\n\t\t\t\n\t\t\tint index = 0;\n\t\t\tfloat startA = (float(index))*PI2/float(10);\n\t\t\tvec3 startB = course(startA*3.0);\n\t\t\tindex++;\n\n\t\t\tfloat targetY = 1.5;\n\t\t\tfloat targetZ = 0.0;\n\t\t\tfloat s = 1.0;\n\t\t\tfloat a = (float(index))*PI2/float(10);\n\t\t\tvec3 b = course(a*s);\n\n\t\t\tvec4 val2 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),startB,b,0.1));\n\t\t\t\n\t\t\tindex++;\n\t\t\tfloat a2 = (float(index))*PI2/float(10);\n\t\t\tvec3 b2 = course(a2*s);\n\n\t\t\tvec4 val3 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b,b2,0.1));\n\t\t\t\n\t\t\tindex++;\n\t\t\tfloat a3 = (float(index))*PI2/float(10);\n\t\t\tvec3 b3 = course(a3*s);\n\n\t\t\tvec4 val4 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b2,b3,0.1));\n\t\t\t\n\t\t\tindex++;\n\t\t\tfloat a4 = (float(index))*PI2/float(10);\n\t\t\tvec3 b4 = course(a4*s);\n\n\t\t\tvec4 val5 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b3,b4,0.1));\n\t\t\t\n\t\t\tindex++;\n\t\t\tfloat a5 = (float(index))*PI2/float(10);\n\t\t\tvec3 b5 = course(a5*s);\n\n\t\t\tvec4 val6 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b4,b5,0.1));\n\t\t\t\n\t\t\tindex++;\n\t\t\tfloat a6 = (float(index))*PI2/float(10);\n\t\t\tvec3 b6 = course(a6*s);\n\n\t\t\tvec4 val7 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b5,b6,0.1));\n\n\t\t\tindex++;\n\t\t\tfloat a7 = (float(index))*PI2/float(10);\n\t\t\tvec3 b7 = course(a7*s);\n\n\t\t\tvec4 val8 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b6,b7,0.1));\n\n\t\t\tindex++;\n\t\t\tfloat a8 = (float(index))*PI2/float(10);\n\t\t\tvec3 b8 = course(a8*s);\n\n\t\t\tvec4 val9 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b7,b8,0.1));\n\n\t\t\tindex++;\n\t\t\tfloat a9 = (float(index))*PI2/float(10);\n\t\t\tvec3 b9 = course(a9*s);\n\n\t\t\tvec4 val10 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b8,b9,0.1));\n\n\t\t\tindex++;\n\t\t\tfloat a10 = (float(index))*PI2/float(10);\n\t\t\tvec3 b10 = course(a10*s);\n\n\t\t\tvec4 val11 = vec4(lTex,sdCapsule(q.xyz + vec3( 0, targetY, targetZ ),b9,b10,0.1));\n\n\n\t\t\tvec2 cpos = vec2(1.0);\n\t\t\tfloat dc = Digit(0.0,vec2(0.2,0.1));\n\t\t\tvec3 cl2 = vec3(dc)*vec3(1,1,1);\n\t\t\tvec4 val12 = vec4( vec3(0.07)+digitTex(pos.xy)*lTex, ship(q.xyz+ vec3( 0, 1.0, 0 )));\n\n\t\t\tvec4 val13 = combine ( val1, val2 );\n\t\t\tvec4 val14 = combine ( val3, val4 );\n\t\t\tvec4 val15 = combine ( val5, val6 );\n\t\t\tvec4 val16 = combine ( val7, val8 );\n\t\t\tvec4 val17 = combine ( val9, val10 );\n\t\t\tvec4 val18 = combine ( val11, val12 );\n\t\t\tvec4 val19 = combine ( val13, val14 );\n\t\t\tvec4 val20 = combine ( val15, val16 );\n\t\t\tvec4 val21 = combine ( val17, val18 );\n\t\t\tvec4 val22 = combine ( val19, val20 );\n\t\t\tvec4 val23 = combine ( val21, val22 );\n\t\t\treturn val23;\n\t\t}\n\t\t\n\t\tvec2 rot(vec2 p, float a) {\n\t\t\treturn vec2(\n\t\t\t\tcos(a) * p.x - sin(a) * p.y,\n\t\t\t\tsin(a) * p.x + cos(a) * p.y);\n\t\t}\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t\t{\n\t\t\tgt = iTime*0.5;\n\t\t\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\t\t\tposition -= .5;\n\n\t\t\t// post effect\n\t\t\tfloat effectActive = mod(iTime,18.0);\n\t\t\tif(effectActive>9.0 && effectActive<= 18.0)\n\t\t\t{\n\t\t\t\tposition.y += (sin((position.x + (iTime * 0.5)) * 6.0) * 0.1) + (sin((position.x + (iTime * 0.2)) * 22.0) * 0.01);\n\t\t\t}\n\n\t\t\tvec3 dir = vec3( position, 1.0 );\n\n         \tfloat aspect = iResolution.x / iResolution.y;\n         \tdir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n\t\t \tdir.yz = rot(dir.yz, 0.1);\n\n\t\t\tvec3 ro = course(iTime*0.6);\n\t\t\tro.z += 0.15;\n\t\t\ttarget = course((iTime*0.6)-0.3);\n\t\t\ttarget.z += 0.1;\n\t\t \tvec3 pos = vec3(0.0, 0.0, 35.0)-target;\n\n\t\t\tvec3 diff = normalize(target-ro);\n\t\t\tvec3 axis = cross(forward, diff);\n\n\t\t\t// from http://glslsandbox.com/e#26519.0 Thanks\n\t\t\tfloat angle = acos(dot(forward, diff));\n\t\t\tvec4 q = quaternion(axis, angle);\n\t\t\tdir = qtransform(q, dir);\n\t\t\tforward = qtransform(q, forward);\n\t\t\tq = quaternion(forward, atan(axis.x, axis.y)-PIH);\n\t\t\tdir = qtransform(q, dir);\n\t\t\t// ====\n\n\t\t\tmat4 m = matRotateZ(0.0);\n\n\t\t\tfloat tt = floor(gt);\n\t\t    float ff = fract(gt);\n\t\t    tt += cubicInOut(2. - exp(-ff*5.));\n\t\t    gtime = tt;\n\n\t\t\tmat4 mm = matRotateY(iTime*1.9);\n\n\t\t\tvec4 result;\n\t\t\tfor (int i =0; i < ITER; i++)\n\t\t\t{\n\t\t\t\tresult = map(pos, m, mm);\n\t\t\t\tif (result.w < NEAR || result.w > FAR) break;\n\t\t\t\tpos += result.w * dir;\n\t\t\t}\n\n\t\t\tvec3 col = map(pos, m, mm).xyz;\n\t\t\tif ( pos.z> 100. )\n\t\t\t{\n\t\t\t    col = vec3(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvec3 lightPos = vec3(20.0, 20.0, 20.0 );\n\t\t\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\t\t\tvec3 eps = vec3( .1, .01, .0 );\n\t\t\t\tvec3 n = vec3( result.w - map( pos - eps.xyy, m, mm ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yxy, m, mm ).w,\n\t\t\t\t\t       result.w - map( pos - eps.yyx, m, mm ).w );\n\t\t\t\tn = normalize(n);\n\t\t\t\t\t\t\n\t\t\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\t\t\tcol *= vec3(lambert);\n\n\t\t\t\tcol += vec3(result.xyz) ;\n\t\t\t}\n\n\t\t\tfragColor = vec4( col, 1.0);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 500, 536, 536, 581], [585, 585, 620, 620, 675], [678, 693, 723, 723, 857], [861, 861, 891, 891, 1029], [1033, 1033, 1063, 1063, 1194], [1198, 1303, 1340, 1340, 1446], [1450, 1450, 1490, 1490, 1648], [1652, 1652, 1685, 1685, 2173], [2177, 2177, 2209, 2209, 2473], [2477, 2477, 2502, 2502, 2646], [2650, 2684, 2717, 2717, 2758], [2762, 2762, 2816, 2816, 2948], [2952, 2952, 2988, 2988, 3070], [3074, 3074, 3113, 3113, 3172], [3176, 3176, 3198, 3198, 3366], [3370, 3370, 3394, 3394, 3466], [3472, 3472, 3499, 3499, 3591], [3614, 3614, 3654, 3654, 6543], [6549, 6549, 6576, 6576, 6663], [6667, 6667, 6726, 6726, 8695]], "test": "untested"}
{"id": "ltsXWj", "name": "Cloud 1", "author": "darksky505", "description": "Attempt to make a cloud shader.\n\nMouse pos moves the position of the \"sun\" giving the yellow color.", "tags": ["2d", "cloud"], "likes": 2, "viewed": 171, "published": "Public", "date": "1439911216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Cloud( vec2 uv , float depth);\nfloat CloudOrder( vec2 uv );\nfloat CloudOne( vec2 uv);\nfloat CloudTwo( vec2 uv);\nfloat CloudThree( vec2 uv);\nfloat CloudFour( vec2 uv);\nfloat CloudFive( vec2 uv);\nfloat CloudSix( vec2 uv);\nfloat CloudSeven( vec2 uv);\n\nfloat Noise( in vec2 p );\nfloat Hash( vec2 p );\n\nfloat GetSunScaler(float mouseScaler, float uv);\n\nfloat Hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat Noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( Hash( i + vec2(0.0,0.0) ), \n                     Hash( i + vec2(1.0,0.0) ), u.x),\n                mix( Hash( i + vec2(0.0,1.0) ), \n                     Hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n vec3 blue = vec3(0.2 , 0.2 ,  0.8);\n vec3 darkBlue = vec3(0.0 , 0.0 ,  0.5);\n\n vec3 white = vec3(1.0 ,1.0 ,1.0);  \n vec3 yellow = vec3(1.0 ,1.0 ,0.0);  \n vec3 grey = vec3(0.5 ,0.5 ,0.5);  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p   = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x /iResolution.y,1.0);\n    \n    float genScaler = CloudOrder(uv);\n        \n \n    float t = genScaler;\n \n    \n    float mouseScalerX = iMouse.x / iResolution.x;\n    float mouseScalerY = iMouse.y / iResolution.y;\n    \n    \n    \n    float sunScaler = (GetSunScaler(mouseScalerX , p.x)  + GetSunScaler(mouseScalerY , p.y )  ) /2.0 ;        \n  \n//vec3 colour = t *blue  +  1.0-t * white;\n    \n    \n    vec3 cloudColour = sunScaler * yellow +  1.0-sunScaler*white;\n    vec4 colour = t * vec4(darkBlue,0)   +  1.0-t *vec4(cloudColour,0);\n\n     //  vec4 colour =  vec4(cloudColour,0)   ;\n    \n    colour.xy *= 0.4;\n   //  colour.x = clamp(colour.x , 0.0  ,1.0 );\n   // colour.y = clamp(colour.y , 0.0  ,1.0 );\n     //colour.z = clamp(colour.z , 0.0  ,1.0 );\n   \n    \n    \n    \n    \n    \n    fragColor =  colour;\n}\n\n\nfloat Cloud( vec2 uv , float depth)\n{\n    float colour = 0.0;\n  //  float bounce  = 0.5 + 0.00000000005*sin(iTime * uv.x );\n    \n   \n    float mouseScalerX = iMouse.x / iResolution.x;\n    float mouseScalerY = iMouse.y / iResolution.y;\n\n    float depthScaler =  (50.0    )/ depth ;\n    \n   uv.x += iTime  * 0.005 ;\n   uv.x += 10.0 + iTime  * 0.0025 * depth ;\n     \n      \n    colour = 4.0*( depth/7.0 ) * Noise(uv * depthScaler   )   ;\n    \n   // colour = clamp(colour , 0.0  ,1.0 );\n     return colour;\n}\n \n\nfloat CloudOrder( vec2 uv)\n{\n     \n  float colour =  Cloud(uv , 1.0) ;\n  const float depth = 15.0;\n  for(float  i = 1.0; i < depth; i++)\n    {\n        colour += Cloud(uv , i) ;\n    }\n    \n    colour =  colour / depth;\n    //colour = clamp(colour , 0.0  ,1.0 );\n    return colour;\n\n}\n\n\nfloat GetSunScaler(float mouseScaler, float uv)\n{\n\tfloat sunScaler = 0.0;\n    \n    if(mouseScaler< uv)        \n    {\n       sunScaler  =  uv -mouseScaler  ; // dsitance \n     }\n    else\n    {\n        sunScaler  = mouseScaler- uv;\n    }\n    \n    return 1.0 - sunScaler;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 376, 376, 468], [470, 470, 496, 496, 790], [984, 984, 1041, 1041, 1920], [1923, 1923, 1960, 1960, 2427], [2431, 2431, 2459, 2459, 2713], [2716, 2716, 2765, 2765, 2986]], "test": "untested"}
{"id": "ltXSDB", "name": "Bezier - Signed Distance", "author": "ajs15822", "description": "Analytical signed distance to a quadratic bezier curve. Click and drag to move the center control point.", "tags": ["2d", "bezier", "distance"], "likes": 116, "viewed": 10401, "published": "Public API", "date": "1439341322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq, T21, and demofox\n// \n// I needed the -signed- distance to a quadratic bezier\n// curve but couldn't find any examples online that\n// were both fast and precise. This is my solution.\n//\n// v1 - Initial release\n// v2 - Faster and more robust sign computation\n//\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n    \n    // Render the control points\n    float d = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    if (d < 0.04) { fragColor = vec4(1.0 - smoothstep(0.025, 0.034, d)); return; }\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    \n    // Visualize the distance field using iq's orange/blue scheme\n    fragColor = vec4(1.0) - sign(d)*vec4(0.1,0.4,0.7,1.0);\n    fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[525, 588, 629, 629, 695], [697, 767, 817, 817, 1168], [1170, 1204, 1248, 1248, 1761], [1763, 1822, 1870, 1870, 2383], [2386, 2386, 2443, 2443, 3317]], "test": "untested"}
{"id": "ltXSRf", "name": "deconstructed+kirby of the stars", "author": "visy", "description": "a deconstruction of \"Kirby\" based on the Nintendo + HAL Laboratories game character", "tags": ["deconstructionvideogameskirbyglsl"], "likes": 1, "viewed": 224, "published": "Public", "date": "1438764491", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 b, in vec2 f) {\n    \n    vec2 c;\n    \n    float \n        t = iTime*1.1,\n        l = 0., s, a;\n    \n    f = f.xy / iResolution.xy;\n        \n    for (float k = 0.; k < 1024.; k++) {\n        float jore = 10.*t*abs(cos(t*0.1));\n        if (k > jore) break;\n        s = pow(fract(k / jore + t / 4.), 5.),\n\t\ta = (k / 1.2 + t);\n        c = vec2(tan(a), cos(a)) * (s * s + s*(k*0.00004)) + .5; \n        \n        if (distance(c, f) < s*cos(k)*tan(t*0.1)*1.) l = max(s+sin(k)*cos(k+t), l-cos(jore*s*0.01+t)*10.);\n        \n    }\n    \n    b = l * vec4(.63*3.,.45-0.1-cos(t+gl_FragCoord.y)*0.01,.45*3., .5);\n    \n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 625]], "test": "untested"}
{"id": "ltXXWS", "name": "snowstorm", "author": "marina", "description": "x", "tags": ["x"], "likes": 2, "viewed": 141, "published": "Public", "date": "1439276347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb(in float h, float s, float l) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n  return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = mod(iTime/4.0, 10.0);\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float x = uv.x, y = uv.y;\n  float h = 0.1 - tan(tan(t*sin(t/(x*y))/(y*t + x/sin(y))) \n      / cos(t*3.0+x*x/(x*t*y)))\n      * tan(t) + sin(x-t)/y;\n  float s = -1.0 * mod(h * t, 1.0);\n  float l = 0.7 / mod(s, 1.0) * mod(sin(h), 1.0);\n  fragColor = vec4(hsl2rgb(h, s, l), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 173], [175, 175, 230, 230, 587]], "test": "untested"}
{"id": "MlBXzz", "name": "Squirmy cube", "author": "public_int_i", "description": "a small raymarch", "tags": ["raymarch", "cube", "squirmy"], "likes": 6, "viewed": 449, "published": "Public API", "date": "1441034815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ethan Shulman 2015\n\n#define FOV_SCALE .5\n#define ITERATIONS 86\n#define EPSILON .04\n#define NORMAL_EPSILON .04\n\n#define VIEW_DISTANCE 90.\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness;\n};\n    \n    \nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n    \n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nfloat ground(in vec3 rp) {\n    return -rp.y+10.;\n}\nfloat whirlcube(in vec3 rp) {\n    vec3 rotp = rp;\n    rotp.xy = rot(rp.xy,length(rp)*.12 + iTime*.05);\n    rotp.xz = rot(rp.xz,1.-length(rotp.xy)*.06 + iTime*.2);\n    vec3 lp = mod(abs(rotp),vec3(4.))-vec3(2.);\n    float outerBounds = sdBox(rp,vec3(6.))-.6;\n    /*outerBounds = max(-(length(abs(rotp)-vec3(5.))-3.),\n                      outerBounds);\n    */\n    return max(outerBounds,\n               length(lp)-2.);\n}\nfloat whirlcube_marks(in vec3 rp) {\n    vec3 rotp = rp;\n    rotp.xy = rot(rp.xy,length(rp)*.12 + iTime*.3);\n    rotp.xz = rot(rp.xz,1.-length(rotp.xy)*.06 + iTime*.5);\n    vec3 lp = mod(abs(rotp),vec3(4.))-vec3(2.);\n    float outerBounds = sdBox(rp,vec3(6.))-.6;\n   /* outerBounds = max(-(length(abs(rotp)-vec3(5.))-3.),\n                      outerBounds);\n    */\n    return max(outerBounds,\n               length(lp)-2.)-textureProj(iChannel0,rotp).x*.35;\n}\n\nfloat df(in vec3 rp) {\n\n    return min(ground(rp),whirlcube(rp));\n}\nfloat df_hq(in vec3 rp) {\n\n    return min(ground(rp),whirlcube_marks(rp));\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\n\nmaterial mat(vec3 rp) {\n    material m;\n    \n    if (whirlcube(rp) < EPSILON) {\n        \n        vec3 rotp = rp;\n        rotp.xy = rot(rp.xy,length(rp)*.12 + iTime*.2);\n        rotp.xz = rot(rp.xz,1.-length(rotp.xy)*.06 + iTime*.5);\n        float inp = cos(cos(rotp.x) + cos(rotp.y) + cos(rotp.z) + (rp.x+rp.z) + iTime*.3);\n        inp = inp/2.+.5;\n        \n        m = material(mix(vec3(1.),vec3(.4,.2,.3),inp), //diffuse\n                     mix(vec3(.8),vec3(.8,.7,.65),inp), //specular\n                     mix(vec3(0.),vec3(0.),inp), //emissive\n                     mix(0.1,.8,inp),//metallic\n                     mix(.9,.2,inp));//roughness\n    }\n    \n    if (ground(rp) < EPSILON) {\n        m = material(vec3(1.), //diffuse\n                     vec3(1.), //specular\n                     vec3(0.), //emissive\n                     .8,//metallic\n                     0.2);//roughness\n    }\n    \n    return m;\n}\n\n//rp = ray pos\n//rd = ray dir\n//maxDist = max trace distance\n//returns -1 if nothing is hit\nfloat trace(in vec3 rp, in vec3 rd, float maxDist) {\n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        sh += max(0.,min(s,penumbraSize)-d);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh);\n}\n\nvec3 background(in vec3 rd) {\n    return mix(\n        mix(vec3(.14),vec3(.3,.16,.13),clamp(rd.y-rd.x+rd.z,0.,1.)),\n        \tvec3(.6,.34,.55), max(0.,dot(rd,normalize(vec3(1.,1.,1.)))));//rd*.5+.5;\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 td = rp-rd*EPSILON*2.0;\n    \n    //lighting\n    vec3 dlc = vec3(.2);//ambient\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    vec3 globalLightDir = normalize(vec3(1.,5.,3.));\n    vec3 globalLightColor = vec3(.9,.8,.9)*softShadowTrace(td,-globalLightDir,48.,0.4,0.1);\n    \n    dlc += max(0.,dot(-globalLightDir,norm))*globalLightColor;\n\n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tm.emissive ;\n}\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 td = rp-rd*EPSILON*2.0;\n    \n    //lighting\n    vec3 dlc = vec3(.2);//ambient\n    vec3 slc;\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    float rtd = trace(td,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = td+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    \n    \n    vec3 globalLightDir = normalize(vec3(1.,5.,3.));\n    vec3 globalLightColor = vec3(.9,.8,.9)*softShadowTrace(td,-globalLightDir,48.,0.4,0.1);\n    \n    dlc += max(0.,dot(-globalLightDir,norm))*globalLightColor;\n    slc += pow(max(0., dot(globalLightDir,reflDir)),(1.-m.roughness)*64.+4.)*globalLightColor;\n    \n    float fres = m.metallic + (1.-m.metallic)*(1.-max(0., dot(-rd,norm)));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*(.5+m.metallic*.5)*fres +\n        \tm.emissive ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n    \n    vec2 mxy = (iMouse.xy/iResolution.xy)*6.28;\n    \n    cameraLocation = vec3(mxy,5.);\n    cameraRotation = vec2(mxy.x,mxy.y/4.-1.6);//x = yaw ,   y = pitch\n\n\n    vec3 rp = vec3(0.,0.,-45.);\n    vec3 rd = normalize(vec3(uv,1.));\n    //vec3(10.,10.,10.);\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n\n    rp.yz = rot(rp.yz,cameraRotation.y);\n    rp.xz = rot(rp.xz,cameraRotation.x);\n    \n    \n    \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    fragColor = vec4(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)),1.);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 281, 314, 314, 379], [380, 380, 411, 411, 507], [518, 518, 553, 553, 638], [640, 640, 666, 666, 690], [691, 691, 720, 720, 1110], [1111, 1111, 1146, 1146, 1569], [1571, 1571, 1593, 1593, 1638], [1639, 1639, 1664, 1664, 1715], [1763, 1763, 1788, 1788, 1967], [1970, 1970, 1993, 1993, 2884], [2886, 2978, 3030, 3030, 3247], [3250, 3250, 3366, 3366, 3674], [3676, 3676, 3705, 3705, 3874], [3876, 3917, 3994, 3994, 4551], [4552, 4552, 4614, 4614, 5652], [5655, 5655, 5712, 5712, 6508]], "test": "untested"}
{"id": "MlfXWS", "name": "Raumfahrtagentur", "author": "WilstonOreo", "description": "raumfahrtagentur.org - show must go on!", "tags": ["2d", "starfield", "rocket", "hackerspaces"], "likes": 9, "viewed": 251, "published": "Public", "date": "1439310683", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// (c) 2015 WilstonOreo, raumfahrtagentur.org\nconst float soft = 0.002;\n\nconst float pi = 3.141593;\n\nvec3 cosmic_blue = vec3(0.024, 0.318, 0.545); // 06518b\nvec3 orange = vec3(0.91, 0.392, 0.196); // #e86432\nvec3 white = vec3(1.0); //#ffffff\n\nfloat circle(vec2 pos, float r)\n{\n  float _distance = length(pos);\n  float _v = (_distance ) / r;\n  return 1.0 - smoothstep(1.0 - soft / r,1.0,_v); \n}\n\nfloat line(vec2 coord, vec2 p1, vec2 p2, float thickness)\n{\n  float d = dot(coord - p1, p2 - p1) / length(p2 - p1);\n  d /= length(p2 - p1);\n  d = clamp(step(0.0, d) * d, 0.0, 1.0);\n  d = distance(p1 + d * (p2 - p1), coord);\n\n  float dst = 1.0 - smoothstep(thickness - soft, thickness + soft, d);\n\n  return dst;\n}\n\n\nfloat rectangle(vec2 pos, float w, float h)\n{\n  return 1.0 -  \n    max(smoothstep(0.5*w - soft,0.5*w + soft,abs(pos.x)), \n    smoothstep(0.5*h - soft,0.5*h + soft,abs(pos.y))); \n}\n\n\nvec2 hash2( vec2 p )\n{\nreturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(32.9898,78.233))) * 43758.5453);\n}\n\nfloat rand1(float i) {\n    return rand(vec2(i, i));\n}\n\nfloat star(int n, vec2 pos) {\n    float fn = float(n);\n    vec2 p = vec2(\n        rand1(0.12+float(n))* 3.,\n        rand1(0.5+float(n)) * 3.);\n   \tfloat pf = rand1(fn*0.63)*0.5+0.5;\n    p += vec2(0.0,-iTime*0.5)*pf;\n    p = mod(p, 3.);\n    p -= vec2(0.5);\n\n    \n    float dist = length(1.0+pos*1.5-p);\n    float i = 0.000000000000000001 * pow(dist, -10.0) * pf;\n \n    return i;\n}\n\nvec2 moon(int n, vec2 pos)\n{\n    float fn = float(n);\n    vec2 p = vec2(\n        rand1(0.12+float(n))* 3.,\n        rand1(0.5+float(n)) * 3.);\n   \tfloat pf = rand1(fn*0.63);\n    p += vec2(0.0,-iTime*0.5)*pf;\n    p = mod(p, 3.);\n    p -= vec2(0.5);\n\n    float size = 4.0*rand1(float(n)*1.5);\n    \n    float dist1 = length(1.0+pos*1.5-p + vec2(1.0,0.0));\n    float dist2 = length(vec2(1.0 - size*0.01,1.0 + size*0.01)+pos*1.5-p + vec2(1.0,0.0));\n    float i = clamp(0.00000001 * (pow(dist1, -10.0 + size)) * pf,0.1,0.15);\n    float j = clamp(0.00000001 * (pow(dist2, -10.0 + size)) * pf,0.1,0.15);\n \n    return vec2(20.0*(i - j),20.0 * (j - 0.1));\n}\n\nfloat triangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\nvec2 e0 = p1 - p0;\nvec2 e1 = p2 - p1;\nvec2 e2 = p0 - p2;\n\nvec2 v0 = p - p0;\nvec2 v1 = p - p1;\nvec2 v2 = p - p2;\n\nvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\nvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\nvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\n  float dist = -sqrt(d.x)*sign(d.y);\nreturn 1.0 - smoothstep(-soft,soft,dist);\n}\n\nvec3 cosmos(vec2 pos)\n{\n  vec2 value = vec2(0.0,0.0);\n    \n    for (int i=0; i<50; ++i) {\n        value += vec2(star(i,pos));\n    } \n\n    for (int i=50; i<53; ++i) {\n        value += moon(i,pos).xy;\n    } \n\n\n  return mix(cosmic_blue,white,clamp(value.x,0.0,1.0));\n}\n\nfloat windowBorder(vec2 pos) \n{\n  float angleOffset = 120.0 / 180.0 * pi * 2.0;\n  float theta = iTime * 0.4;\n  vec2 p0 = 0.2 * vec2(cos(theta),sin(theta));\n  vec2 p1 = 0.2 * vec2(cos(theta + angleOffset),sin(theta + angleOffset));\n  vec2 p2 = 0.2 * vec2(cos(theta + angleOffset * 2.0),sin(theta + angleOffset * 2.0));\n\n  // Window Border\n  return clamp(circle(pos,0.185) - circle(pos,0.16) \n  - line(pos,vec2(0.0,0.0),p0,0.015)\n  - line(pos,vec2(0.0,0.0),p1,0.015)\n  - line(pos,vec2(0.0,0.0),p2,0.015),  \n  0.0,1.0);   \n}\n\nvec2 polarToVec(float r, float phi)\n{\n  return r * vec2(cos(phi),sin(phi));\n}\n\nfloat star(vec2 pos) \n{\n  float dTheta = 18.0 / 180.0 * pi;\n  float r = 0.10;\n  float sum = 0.0;\n  for (float i = 0.0; i < 12.0; i += 4.0)\n  {\n    sum += triangle(pos,\n      polarToVec(r,(i + 1.0) * dTheta),\n      polarToVec(r / sqrt(8.0),(i + 15.0) * dTheta),\n      polarToVec(r,(i + 9.0) * dTheta));\n  }\n  return clamp(sum,0.0,1.0);\n}\n\n\nvec4 rocket(vec2 pos)\n{\n  vec2 windowCenter = vec2(0.0,-0.25);\n  \n  float wDist = length(pos + windowCenter);\n\n  if (wDist < 0.12 - soft) return \n    vec4(mix(cosmic_blue,white,star(pos + windowCenter)),1.0);\n\n  if (wDist < 0.12 + soft) \n    return vec4(mix(cosmic_blue,orange,smoothstep(0.12 - soft,0.12 +soft,wDist)),1.0);\n\n  float boost_wooble = 0.01 * sin(iTime*30.0);\n  float boost =  \n      circle(pos * vec2(5.0,1.0 + boost_wooble) + vec2(0.0,0.63),0.1) + \n      circle(pos * vec2(5.0,1.0 + boost_wooble) + vec2(0.4,0.6),0.1) + \n      circle(pos * vec2(5.0,1.0 + boost_wooble) + vec2(-0.4,0.6),0.1); \n\n  float d= (clamp(clamp(\n    circle(pos * vec2(3.8,1.5),0.95) - rectangle(pos + vec2(0.0,0.5),1.0,0.9) + \n    rectangle(pos - vec2(0.0,0.6),0.025,0.3) +\n    circle(pos + vec2(0.0,-0.75),0.05),0.0,1.0) +\n    triangle(pos - vec2(0.0,0.2),vec2(-0.475,-0.28),vec2(0.0,0.0),vec2(0.475,-0.28)) +\n    rectangle(pos - vec2(0.0,-0.17),0.95,0.18) + \n    rectangle(pos - vec2(0.0,-0.27),0.51,0.16) +\n    triangle(pos,vec2(-0.225,-0.45),vec2(0.0,0.0),vec2(0.225,-0.45)) + boost,\n    0.0,1.0));\n  return vec4(orange * d  +\n    white * clamp(\n      // Stripes\n      rectangle(pos - vec2(0.11,-0.15),0.055,0.055) +\n      rectangle(pos - vec2(0.0,-0.15),0.055,0.055) +\n      rectangle(pos - vec2(-0.11,-0.15),0.055,0.055) +\n      rectangle(pos - vec2(0.055,-0.205),0.055,0.055) +\n      rectangle(pos - vec2(-0.055,-0.205),0.055,0.055) + \n      windowBorder(pos + windowCenter) +\n      boost\n      ,\n    0.0,1.0),d);\n}\n\nvec3 background(vec2 pos)\n{\n  const float inner = 0.88;\n  const float stripe = 0.93;\n\n  vec4 rocketDist = rocket(pos);\n\n  float dist = length(pos);\n  if (dist < inner - soft) return mix(cosmos(pos),rocketDist.rgb,rocketDist.a);\n  if (dist < inner + soft)\n  {\n    return mix(rocketDist.rgb,white,smoothstep(inner - soft,inner +soft,dist));\n  }\n  if (dist < stripe - soft) return white;\n  if (dist < stripe + soft) {\n    return mix(white,orange,smoothstep(stripe - soft,stripe+soft,dist));\n  }\n  if (dist < 1.0 - soft) return orange;\n  if (dist < 1.0 + soft) {\n    return mix(orange,white,smoothstep(1.0 - soft,1.0+soft,dist));\n  }\n\n  return white;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/(iResolution.y) + vec2(0.0,0.0);\n  \nfragColor = vec4(background(pos), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 244, 277, 277, 394], [396, 396, 455, 455, 708], [711, 711, 756, 756, 890], [893, 893, 915, 915, 1004], [1006, 1006, 1026, 1026, 1098], [1100, 1100, 1122, 1122, 1153], [1155, 1155, 1184, 1184, 1534], [1536, 1536, 1564, 1564, 2182], [2184, 2184, 2248, 2248, 2841], [2843, 2843, 2866, 2866, 3108], [3110, 3110, 3141, 3141, 3631], [3633, 3633, 3670, 3670, 3710], [3712, 3712, 3735, 3735, 4048], [4051, 4051, 4074, 4074, 5561], [5563, 5563, 5590, 5590, 6211], [6213, 6213, 6270, 6270, 6440]], "test": "untested"}
{"id": "MllSWj", "name": "Some more play", "author": "JamesHagerman", "description": "colors spilt in middle", "tags": ["sensatron"], "likes": 1, "viewed": 91, "published": "Public", "date": "1439879555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.y = abs(uv.y-0.5);\n    \n    float crazy = log(uv.x/uv.y);\n    \n    // Using powers and tangent to sweep colors:\n    float crazy2 = pow(uv.y/uv.x, tan(iTime));\n    \n    //uv.y = atan(uv.y,uv.x);//+sin(iTime*0.5);\n    \n    vec3 outputColor = hsv2rgb_smooth(vec3(crazy, crazy2, 1.0));\n\tfragColor = vec4(outputColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 210], [212, 212, 269, 269, 644]], "test": "untested"}
{"id": "MllSWl", "name": "I have no idea what I'm doing :)", "author": "Solstice", "description": "I just enter numbers and do things that make no sense and ... things happen!", "tags": ["procedural", "noise"], "likes": 4, "viewed": 1511, "published": "Public API", "date": "1440709822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I have no idea how to colour this. :p\n// ... yes, I've tried. ^_^\n// This is my first released thing ever and it happened by accident! :)\n// Also do I have no idea what \"public+API\" means. (:\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\tvec3 ro = vec3(0.0,1.0+(iTime/15.0),-1.18); // Ray Origin.\n\tvec3 rd = normalize(vec3(q, 1.0));  // Ray Direction. 1.0 = FoV\n\tvec3 rb = rd * ( 0.1/length(vec3(q,1.0)));\n    \n\tvec3 rs;\n\tfloat s;\n\n\n\tfor(float i = 1.0; i < 200.0; i++)\n\t{\n\t\trs = ro + (i * rb);\n\t\ts = cos(snoise(vec2(rs.y,rs.z))*5.19);\n\n\t\tif (s > 0.93) break;\n\t\t\n\n\t}\n\n    vec3 m = vec3(s);\n    fragColor = vec4(m.z,m.z,m.z,1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllSWl.jpg", "access": "shaders20k", "license": "mit", "functions": [[197, 566, 587, 587, 636], [638, 638, 659, 659, 708], [710, 710, 732, 732, 769], [771, 771, 795, 795, 2301], [2304, 2304, 2361, 2361, 2850]], "test": "untested"}
{"id": "MllXDB", "name": "Cubes (plz help ?)", "author": "makc", "description": "Infinite cubes by iteratively solving for intersections (please help to solve the flicker someone)", "tags": ["help"], "likes": 3, "viewed": 242, "published": "Public", "date": "1439512901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nSo, this is infinite cubes by iteratively solving for intersections.\nThe iterations run in no particular order making it impossible to\ndiscard early, and still this runs quite a bit faster than distance\nfield raymarching (see http://makc.github.io/misc/cubes.html), where\nrays are slowed down to a crawl near the surface like it is some kind\nof black hole. The only problem with it is that annoying flickering\nthat I can't figure out. If someone of you the masters could spot the\ncause - you will make me very happy ;)\n\n*/\n\nconst float cube_half_side = 1.0, cell_side = 8.0, cube_side = cube_half_side * 2.0;\n\nvoid cubes (out vec3 color, in vec3 p, in vec3 d) {\n\n\tp = mod (p + cell_side * 0.5, cell_side);\n\n\tvec3 ad = abs(d), sd = sign(d), normal = vec3(0.0);\n\n\tvec3 offsets = (0.5 * cell_side - cube_half_side) * (sd + 1.0) + cube_half_side; // (d.x > 0.0) ? cell_side - cube_half_side : cube_half_side, etc\n\n\tvec2 test;\n\n\tfloat closest_hit_distance = 1e2 * cell_side, ray_distance, step = (cell_side + 1e-2 * cube_half_side) / max (ad.x, max (ad.y, ad.z));\n\n\tvec3 p1 = p, p2, dist;\n\n\tfloat p1_to_p_distance = 0.0;\n\n\tfor (int i = 0; i < 7; i++) {\n\n\t\t// distances to the planes of cubes sides facing the camera\n\t\tdist = (offsets - mod (p1, cell_side)) / d;\n\t\tdist += 0.5 * (1.0 - sign (dist)) * cell_side / ad; // if (dist.x < 0.0) dist.x += cell_side / abs(d.x);\n\n\t\t// x\n\t\tp2 = p1 + d * dist.x;\n\n\t\tray_distance = p1_to_p_distance + dist.x; //length(p2 - p);\n\t\tif (closest_hit_distance > ray_distance) {\n\n\t\t\t// test yz\n\t\t\ttest = mod (p2.yz + cube_half_side, cell_side);\n\t\t\tif ((test.x < cube_side) && (test.y < cube_side)) {\n\t\t\t\tclosest_hit_distance = ray_distance;\n\t\t\t\tnormal = vec3 (-sd.x, 0.0, 0.0);\n\t\t\t}\n\t\t}\n\n\t\t// y\n\t\tp2 = p1 + d * dist.y;\n\n\t\tray_distance = p1_to_p_distance + dist.y;\n\t\tif (closest_hit_distance > ray_distance) {\n\n\t\t\t// test xz\n\t\t\ttest = mod (p2.xz + cube_half_side, cell_side);\n\t\t\tif ((test.x < cube_side) && (test.y < cube_side)) {\n\t\t\t\tclosest_hit_distance = ray_distance;\n\t\t\t\tnormal = vec3 (0.0, -sd.y, 0.0);\n\t\t\t}\n\t\t}\n\n\t\t// z\n\t\tp2 = p1 + d * dist.z;\n\n\t\tray_distance = p1_to_p_distance + dist.z;\n\t\tif (closest_hit_distance > ray_distance) {\n\n\t\t\t// test xy\n\t\t\ttest = mod (p2.xy + cube_half_side, cell_side);\n\t\t\tif ((test.x < cube_side) && (test.y < cube_side)) {\n\t\t\t\tclosest_hit_distance = ray_distance;\n\t\t\t\tnormal = vec3 (0.0, 0.0, -sd.z);\n\t\t\t}\n\t\t}\n\n\t\tp1 += d * step;\n\t\tp1_to_p_distance += step;\n\t}\n\n\tcolor = normal * 0.5 * (cell_side / closest_hit_distance) + 0.5;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\tvec3 camPos = vec3 (0.0, 0.0, 3.0) + vec3 (sin (iTime / 4.0) * 7.1, cos (iTime / 4.0) * 7.1, (sin (iTime / 6.0) + cos (iTime / 2.0)) * 7.0);\n\tvec3 camDir = vec3 (0.0, 0.0, -1.0);\n\tvec3 camUp = vec3 (0.0, 1.0, 0.0) + vec3 (sin (iTime / 5.0), 0.0, 0.0);\n\tvec3 camSide = cross (camDir, camUp);\n\tfloat focus = 1.8;\n\tvec3 rayDir = normalize (camSide * pos.x + camUp * pos.y + camDir * focus);\n\tfragColor.w = 1.0;\n\tcubes (fragColor.xyz, camPos, rayDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 614, 665, 665, 2494], [2496, 2496, 2552, 2552, 3070]], "test": "untested"}
{"id": "MlsXDf", "name": "random quadtree", "author": "FabriceNeyret2", "description": "translate and move with mouse.\n#define tunes the probabilty of subdividing.", "tags": ["procedural", "mondrian", "short", "quadtree"], "likes": 42, "viewed": 2302, "published": "Public API", "date": "1440364411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define P_SUBDIV .2+.2*sin(iTime)\n//#define P_SUBDIV .2\n\nfloat rnd(vec3 v) { return fract(4e4*sin(dot(v,vec3(13.46,41.74,-73.36))+17.34)); }\n    \nvoid mainImage( out vec4 fragColor, vec2 uv )\n{\n    vec2 u, R=iResolution.xy, m=iMouse.xy;\n    if (m.x+m.y<1e-2*R.x) m = R*(.5+.5*sin(.1*iTime+vec2(0,1.6)));\n    uv.x -= 8.*(m.x-R.x/2.);\n    uv /= (1.-m.y/R.y)*4.;\n    \n\tfloat z = R.y;\n    for (int i=0; i<128; i++) {\n        u = floor(uv/z)+.5;\n        if (rnd(vec3(z*u, z)) < P_SUBDIV) break;\n        z /= 2.;\n    }\n    uv = z/2.-abs(uv-z*u);\n    fragColor = min(uv.x,uv.y)<1. ? vec4(0) :\n    \t\t\t// vec4(1); // vec4(z/R.y);\n\t\t\t\t.6+.4*cos(6.28*rnd(vec3(z*u+1.,z))+vec4(0,2.1,-2.1,0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 57, 76, 76, 140], [146, 146, 193, 193, 682]], "test": "untested"}
{"id": "MlSXRR", "name": "Gotthard Tunnel", "author": "dr2", "description": "A trip through the (soon to be old) Gotthard train tunnel.", "tags": ["raymarching", "tunnel", "landscape", "train"], "likes": 15, "viewed": 1378, "published": "Public API", "date": "1440913200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gotthard Tunnel\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;  p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat VBlockRingDf (vec3 p, float r, float w)\n{\n  vec2 q = vec2 (length (p.yx) - r, p.z);\n  q = q * q * q;\n  return pow (dot (q, q), 1./6.) - w *\n     (0.7 + 0.3 * pow (abs (sin (13. * atan (p.y, p.x))), 0.25));\n}\n\nfloat SmoothMin (float a, float b, float k)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / k, 0., 1.);\n  return mix (b, a, h) - k * h * (1. - h);\n}\n\nmat3 vuMat;\nvec3 vuPos, vuDir, sunDir;\nfloat tCur, vuSpd, grDir;\nint idObj;\nconst int nCar = 4;\nconst float carSep = 3.5;\nconst float dstFar = 250.;\n\nconst int idTun = 0, idLight = 1, idArch = 2, idRail = 3, idTie = 4,\n   idBody = 5, idBase = 6, idWheel = 7, idCable = 8, idFlash = 9, idWin = 10,\n   idFrm = 11;\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd, int refl)\n{\n  const float skyHt = 150.;\n  vec3 col;\n  vec2 p;\n  float w, f, cloudFac, s;\n  if (refl == 0 &&\n     rd.y < max (0.015 * Fbm1 (20. * rd.z + 0.5 * tCur) - 0.01, 0.002))\n     col = vec3 (0.03, 0.07, 0.03);\n  else {\n    if (rd.y > 0.) {\n      ro.x += 1.5 * tCur;\n      p = 0.02 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n      w = 0.8;\n      f = 0.;\n      for (int j = 0; j < 4; j ++) {\n\tf += w * Noisefv2 (p);\n\tw *= 0.5;\n\tp *= 2.;\n      }\n      cloudFac = clamp (5. * (f - 0.5) * rd.y + 0.1, 0., 1.);\n    } else cloudFac = 0.;\n    s = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.1, 0.6) + 0.2 * pow (1. - max (rd.y, 0.), 5.) +\n       (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n    col = mix (col, vec3 (0.75), cloudFac);\n  }\n  return col;\n}\n\nfloat WaterHt (vec3 p)\n{\n  const float wb = 1.414;\n  float ht, w;\n  p *= 0.02;\n  ht = 0.;\n  w = wb;\n  for (int j = 0; j < 6; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float h;\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  h = WaterHt (p);\n  return normalize (vec3 (h - WaterHt (p + e.xyy), e.x,\n     h - WaterHt (p + e.yyx)));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (0.3 * sin (0.3 * t) * cos (0.04 * t) + 0.9 * cos (0.017 * t),\n     0.6 + 0.3 * cos (0.15 * t) * cos (0.04 * t) * sin (0.021 * t), t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec3 v;\n  vec2 q, vyz;\n  float h, w;\n  p -= TrackPath (p.y).xy;\n  q = p * 0.06;\n  w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vyz = vec2 (0.);\n  h = 0.;\n  for (int j = 0; j < 10; j ++) {\n    v = Noisev3v2 (q);\n    vyz += v.yz;\n    h += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4 && hiRes == 0) break;\n    w *= -0.4;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  return h * smoothstep (0., 5., - grDir * p.x) + 0.1 * Noisefv2 (3. * p) - 1.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += 0.4 * h + 0.008 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float h;\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  h = GrndHt (p.xz, 1);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy, 1), e.x,\n     h - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec3 GrndCol (vec3 p, vec3 rd, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.02, 0.1, 0.02), gCol8 = vec3 (0.1, 0.08, 0.);\n  vec3 col, c;\n  vec2 q;\n  float f, d, cSpec;\n  q = p.xz;\n  cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + gCol7);\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol8, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return col * (0.2 + max (dot (n, sunDir), 0.)) +\n     cSpec * pow (max (0., dot (sunDir, reflect (rd, n))), 128.);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dTun, d, tw1, tw2;\n  dMin = dstFar;\n  p.xy -= TrackPath (p.z).xy;\n  d = length (max (abs (vec2 (abs (p.x) - 0.25, p.y + 0.51)) -\n     vec2 (0.01, 0.03), 0.));\n  if (d < dMin) { dMin = d; idObj = idRail; }\n  tw1 = 0.5 + 0.1 * sin (2.5 * p.z) * sin (31.4 * p.z);\n  tw2 = 0.8 + 0.02 * sin (6.5 * p.z) * sin (7.4 * p.z);\n  dTun = length (p.xy - vec2 (0., tw1 * clamp (p.y / tw1, -0.5, 0.5))) - tw2;\n  if (dTun < 0.1)\n     dTun = SmoothMin (- dTun, p.y + 0.6 + 0.02 * sin (4.1 * p.z), 0.05);\n  else dTun -= 0.2;\n  q = vec3 (p.x * sign (mod (p.z, 10.) - 5.1) + 0.9, p.y - 0.15,\n     mod (p.z, 5.) - 1.5);\n  d = max (dTun, - PrBoxDf (q, vec3 (0.6, 0.4, 1.)));\n  if (d < dMin) { dMin = d; idObj = idTun; }\n  d = PrBoxDf (vec3 (q.x + 0.1, q.yz), vec3 (0.1, 0.4, 1.));\n  if (d < dMin) { dMin = d; idObj = idWin; }\n  d = max (PrBoxDf (q, vec3 (0.13, 0.4, 1.)),\n     - PrBoxDf (q, vec3 (0.14, 0.38, 0.98)));\n  if (d < dMin) { dMin = d; idObj = idFrm; }\n  q = vec3 (p.x, p.y + 0.58, mod (p.z, 0.8) - 0.4);\n  d = PrBoxDf (q, vec3 (0.37, 0.02, 0.07));\n  if (d < dMin) { dMin = d; idObj = idTie; }\n  d = VBlockRingDf (vec3 (p.xy, mod (p.z, 5.) - 4.5), 0.9, 0.16);\n  if (d < dMin) { dMin = d; idObj = idArch; }\n  d = PrBoxDf (vec3 (p.x, p.y - 0.92, mod (p.z, 5.) - 2.),\n     vec3 (0.02, 0.03, 0.2));\n  if (d < dMin) { dMin = d; idObj = idLight; }\n  d = length (max (abs (vec2 (p.x, p.y - 0.92)) - vec2 (0.01), 0.));\n  if (d < dMin) { dMin = d; idObj = idCable; }\n  float ppz = p.z - vuSpd * tCur - 2.;\n  for (int nc = nCar - 1; nc >= 0; nc --) {\n    p.z = ppz - carSep * float (nc);\n    q = p;\n    q.y -= -0.12;\n    d = max (PrCylDf (q, 0.28, 0.4), - PrCylDf (q, 0.27, 0.38));\n    d = max (d, - min (PrCylDf (q, 0.23, 0.41),\n      PrBoxDf (q, vec3 (0.3, 0.1, 0.35))));\n    if (d < dMin) { dMin = d; idObj = idBody; }\n    q.y -= -0.28;\n    d = PrRoundBoxDf (q, vec3 (0.2, 0.02, 0.38), 0.01);\n    if (d < dMin) { dMin = d; idObj = idBase; }\n    q.y -= 0.57;\n    d = PrCylDf (q.xzy, 0.04, 0.03);\n    if (d < dMin) { dMin = d; idObj = idFlash; }\n    q = vec3 (abs (p.x) - 0.23, p.y + 0.41, abs (p.z + 0.2) - 0.2);\n    d = PrCylDf (q.yzx, 0.06 - sign (q.x) * 0.01, 0.02);\n    if (d < dMin) { dMin = d; idObj = idWheel; }\n  }\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  const vec3 e = vec3 (0.2, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dist)\n{\n  vec4 col4;\n  vec3 ltPos, ltDir, ltAx;\n  float ltDiff, ltSpec, amb, di, atten, t;\n  int idObjT;\n  vec3 col;\n  idObjT = idObj;\n  col4 = vec4 (0.);\n  if      (idObjT == idTun) col4 = vec4 (0.05, 0.05, 0.055, 0.5);\n  else if (idObjT == idFrm) col4 = vec4 (0.1, 0.1, 0.11, 0.6);\n  else if (idObjT == idLight) col4 = vec4 (0.);\n  else if (idObjT == idArch) col4 = vec4 (0.3, 0.2, 0.1, 0.5);\n  else if (idObjT == idRail) col4 = vec4 (0.5, 0.5, 0.55, 1.);\n  else if (idObjT == idTie) col4 = vec4 (0.15, 0.15, 0.1, 0.5);\n  else if (idObjT == idBody) col4 = vec4 (0.15, 0.25, 0.3, 0.2);\n  else if (idObjT == idBase) col4 = vec4 (0.1, 0.2, 0.2, 0.2);\n  else if (idObjT == idWheel) col4 = vec4 (0.15, 0.12, 0.05, 0.3);\n  else if (idObjT == idCable) col4 = vec4 (1., 1., 0., 1.);\n  else if (idObjT == idFlash) col4 = vec4 ((mod (2. * tCur, 1.) < 0.5) ?\n     vec3 (2., 0., 0.) : vec3 (0., 0., 2.), 0.);\n  vec3 vn = ObjNf (ro);\n  if (idObjT == idTun || idObjT == idFrm) {\n    vn = VaryNf (20. * ro, vn, 10.);\n  } else if (idObjT == idArch || idObjT == idTie) {\n    vn = VaryNf (40. * ro, vn, 2.);\n  }\n  if (idObjT == idLight) col = vec3 (1., 1., 0.9);\n  else {\n    amb = 0.05;\n    ltDiff = 0.;\n    ltSpec = 0.;\n    for (int nc = nCar; nc >= 0; nc --) {\n      t = vuSpd * tCur + carSep * float (nc);\n      ltPos = TrackPath (t);\n      ltAx = normalize (TrackPath (t + 0.1) - ltPos);\n      ltPos.y += 0.2;\n      ltDir = ro - ltPos;\n      di = 1. / max (length (ltDir), 0.01);\n      ltDir *= di;\n      atten = pow (min (di, 1.), 2.) * max (dot (ltAx, ltDir), 0.);\n      ltDiff += atten * max (dot (- ltDir, vn), 0.);\n      ltSpec += atten * pow (max (dot (reflect (- ltDir, vn), rd), 0.), 128.);\n    }\n    col = col4.rgb * (amb + (1. - amb) * ltDiff) + col4.a * ltSpec;\n  }\n  return clamp (col, 0., 1.);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  float dstHit, reflFac, dw;\n  int refl;\n  vec3 col;\n  sunDir = normalize (vec3 (0.8, 1., 1.));\n  grDir = -1.;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  reflFac = 1.;\n  refl = -1;\n  if (idObj != idWin) {\n    ro += rd * dstHit;\n    col = ObjCol (ro, rd, dstHit);\n  } else {\n    ro += rd * dstHit;\n    if (grDir * (ro.x - TrackPath (ro.z).x) > 0.) {\n      if (rd.y < 0.) {\n        dw = - ro.y / rd.y;\n        ro += dw * rd;\n        rd = reflect (rd, WaterNf (ro, dw));\n        ro += 0.01 * rd;\n\treflFac *= 0.7;\n\trefl = 1;\n      } else refl = 0;\n    } else {\n      dstHit = GrndRay (ro, rd);\n      if (dstHit < dstFar || rd.y < 0.) {\n        ro += rd * dstHit;\n        col = GrndCol (ro, rd, GrndNf (ro, dstHit));\n      } else refl = 0;\n    }\n  }\n  if (refl >= 0) col = reflFac * SkyHrzCol (ro, rd, refl);\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid VuPM (float t)\n{\n  vec3 vuF, vuB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 0.2;\n  vuPos = TrackPath (t);\n  vuF = TrackPath (t + dt);\n  vuB = TrackPath (t - dt);\n  vel = (vuF - vuB) / (2. * dt);\n  vuDir = normalize (vel);\n  vel.y = 0.;\n  acc = (vuF - 2. * vuPos + vuB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0., atan (vel.z, vel.x) - 0.5 * pi,\n     0.5 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  vuMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  tCur = iTime;\n  vec3 rd, ro;\n  vuSpd = 3.;\n  VuPM (vuSpd * tCur);\n  rd = normalize (vec3 (uv, 2.2)) * vuMat;\n  ro = vuPos;\n  ro.y += 0.1;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 270, 294, 294, 344], [346, 346, 370, 370, 417], [419, 419, 444, 444, 574], [576, 576, 601, 601, 780], [782, 782, 807, 807, 1113], [1115, 1115, 1140, 1140, 1499], [1501, 1501, 1523, 1523, 1658], [1660, 1660, 1689, 1689, 1891], [1893, 1893, 1925, 1925, 2020], [2022, 2022, 2068, 2068, 2115], [2117, 2117, 2159, 2159, 2210], [2212, 2212, 2259, 2259, 2425], [2427, 2427, 2472, 2472, 2570], [2885, 2885, 2930, 2930, 3689], [3691, 3691, 3715, 3715, 3948], [3950, 3950, 3982, 3982, 4151], [4153, 4153, 4179, 4179, 4330], [4332, 4332, 4366, 4366, 4887], [4889, 4889, 4923, 4923, 5454], [5456, 5456, 5487, 5487, 5671], [5673, 5673, 5713, 5713, 7293], [7295, 7295, 7317, 7317, 9561], [9563, 9563, 9584, 9584, 9812], [9814, 9814, 9853, 9853, 10076], [10078, 10078, 10122, 10122, 11912], [11914, 11914, 11947, 11947, 12123], [12125, 12125, 12160, 12160, 13004], [13006, 13006, 13027, 13027, 13658], [13660, 13660, 13716, 13716, 13972]], "test": "untested"}
{"id": "MlSXRz", "name": "Lighthouse", "author": "EKnapik", "description": "A lighthouse on the ocean. With the moon in the background.", "tags": ["water", "light", "ocean", "spotlight", "house", "eknapik", "lighthouse"], "likes": 2, "viewed": 473, "published": "Public", "date": "1440986036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Eric M. Knapik\n// github: eknapik\n// https://github.com/EKnapik\n\n// Illuminates the moon\n#define MoonSpotPos vec3(20.0, -10.0, -10.0)\n#define MoonSpotDir normalize(MoonSpotPos-vec3(-15.0,15.0,-20.0))\n#define MoonSpotCol vec3(1.0, 1.0, 1.0)\n// Illuminates the rest of the scene\n#define LightPos vec3(-10.0, 3.0, -16.0)\n#define LightDir normalize(LightPos-vec3(-3.0, 3.0, 0.0))\n#define LightCol vec3(1.0, 1.0, 1.0)\n\nstruct SpotLight {\n\tvec3 pos;\n    vec3 dir;\n    vec3 color;\n    float intensity;\n    float spread;\n    float penFactor;\n};\n\n// Trochoid waves that would make this nicer\nfloat wave(vec3 p, float speed, float amp, float angle, float freq) {\n\treturn amp*cos(freq*(freq*(p.x*cos(angle) + p.z*sin(angle)) - speed*iTime) - speed*iTime);\n}\n\nfloat fbm(vec2 p) {\n    float ql = length( p );\n    p.x += 0.05*sin(.81*iTime+ql*2.0);\n    p.y += 0.05*sin(1.53*iTime+ql*6.0);\n    \n    float total = 0.0;\n    float freq = 0.0152250;\n    float lacunarity = 2.51;\n    float gain = 0.15;\n    float amp = gain;\n    \n    for(int i = 0; i < 5; i++) {\n    \ttotal += texture(iChannel0, p*freq).r*amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return total;\n}\n\nfloat fbm3(vec3 p) {\n    float ql = length( p );\n    \n    float total = 0.0;\n    float freq = .02250;\n    float lacunarity = 0.151;\n    float gain = 0.15;\n    float amp = gain;\n    \n    for(int i = 0; i < 5; i++) {\n    \ttotal += texture(iChannel1, p.xy*freq).r*amp;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    \n    return total;\n}\n\n\n//-----------OBJECT OPERATIONS-----------\nvec2 shapeMin(vec2 shape1, vec2 shape2) {\n\treturn (shape1.x < shape2.x) ? shape1 : shape2;\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec4 q = m*vec4(p,1.0);\n    return q.xyz;\n}\n//----------END OBJECT OPERATIONS----------\n\n//----------DISTNACE FUNCTIONS----------\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat distSphere(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\nfloat distOcean(vec3 pos) {\n    return pos.y + fbm(pos.xz + .5*fbm(pos.xz + fbm(pos.xz))) + wave(pos, .3, .0413, .23, 2.0) + wave(pos, .15, .12, -.35, .5);\n}\n\nfloat distMoon(vec3 pos) {\n\tfloat radius = 6.0;\n    vec3 desiredPos = vec3(-15.0,15.0,-20.0);\n    return length(pos-desiredPos)-radius;\n}\n\nvec2 distLightHouse(vec2 curShape, vec3 pos) {\n    vec2 res;\n\tres = shapeMin( curShape, vec2( sdCylinder(pos, vec2(0.4, 1.5)), 4.0)); // mainTube\n    // saftey bars\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.4, 1.5, 0.0), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.0, 1.5, 0.4), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(-0.4, 1.5, 0.0), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.0, 1.5, -0.4), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.28, 1.5, -0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(-0.28, 1.5, -0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(-0.28, 1.5, 0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdCylinder(pos-vec3(0.28, 1.5, 0.28), vec2(0.03, 0.2)), 5.0));\n    res = shapeMin( res, vec2( sdTorus82(pos-vec3(0.0, 1.64, 0.0), vec2(0.4, 0.05)), 5.0));\n    res = shapeMin( res, vec2( sdTorus82(pos-vec3(0.0, 1.3, 0.0), vec2(0.4, 0.05)), 5.0));\n    // window\n    res = shapeMin( res, vec2( sdBox(pos-vec3(-0.2, 0.5, 0.0), vec3(0.2, 0.3, 0.2)), 5.0));\n    // lighthouse cap\n    res = shapeMin( res, vec2( sdCone(pos-vec3(0.0, 2.5, 0.0), vec3(0.4, 0.35, 0.5)), 5.0));\n    res = shapeMin( res, vec2( distSphere(pos-vec3(0.0, 2.5, 0.0), 0.07), 5.0));\n    return res;\n}\n//---------END DISTANCE FUNCTIONS--------\n\n\n//-----------OBJ MAP AND RAYMARCH-------------\nvec2 map(vec3 pos) {\n\tvec2 shape; // the distance to this shape and the shape id\n    \t\t\t// distance to shape is x, shape id is y\n    shape = shapeMin(vec2(distOcean(pos), 1.0), vec2(distSphere(pos, 0.5), 2.0));\n    shape = shapeMin(shape, \t\t\t\t\tvec2(distMoon(pos), 3.0));\n    shape = distLightHouse(shape, pos-vec3(3.0, 1.4, -3.0));\n    return shape;\n}\n\nvec2 rayMarch(in vec3 rayOrigin, in vec3 rayDir) {\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n    float t = tmin;\n    float precis = 0.0002;\n    float material = -1.0;\n    \n    // for more accuracy increase the amount of checks in the for loop\n    for(int i = 0; i < 60; i++) {\n        vec2 shapeObj = map(rayOrigin + t*rayDir);\n        float dist = shapeObj.x;\n        if(dist < precis || t > tmax) {\n            break;\n        }\n        t += dist;\n        material = shapeObj.y;\n    }\n    \n    if( t>tmax ) {\n    \tmaterial = -1.0; // didn't hit anything so background;\n    }\n    return vec2( t, material ); // return distance and material hit for this ray\n}\n\n\n// ----- LIGHTING --------\n// Inigo Quilez's soft shadow\nfloat softshadow(vec3 rayOrigin, vec3 rayDir, float mint, float maxt) {\n\tfloat k = 8.0; // how soft the shadow is (a constant)\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<10; i++) {\n        float h = map(rayOrigin + t*rayDir).x;\n        res = min(res, k*h/t);\n        t += h; // can clamp how much t increases by for more precision\n        if( h < 0.001 ) {\n        \tbreak;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Inigo Quilez's fast normal adjusted slightly becuase objects were shading themselves\nvec3 calcNormal(vec3 pos) {\n\tvec3 epsilon = vec3(0.023, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+epsilon.xyy).x - map(pos-epsilon.xyy).x,\n        map(pos+epsilon.yxy).x - map(pos-epsilon.yxy).x,\n        map(pos+epsilon.yyx).x - map(pos-epsilon.yyx).x);\n    return normalize(nor);\n}\n\n\nfloat getLighthouseLight(vec3 rayOrigin, vec3 rayDir) {\n    float time = 0.3*iTime;\n\tmat4 rot1 = mat4(0.0, 1.0, 0.0, 0.0,\n                      -1.0, 0.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, 0.0,\n                      0.0, 0.0, 0.0, 1.0);\n    mat4 rot2 = mat4(cos(time), 0.0, -sin(time), 0.0,\n                       0.0, 1.0, 0.0, 0.0,\n                       sin(time), 0.0, cos(time), 0.0,\n                       0.0, 0.0, 0.0, 1.0);\n    mat4 trans = rot1*rot2;\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n    float t = tmin;\n    float precis = 0.0002;\n    // for more accuracy increase the amount of checks in the for loop\n    for(int i = 0; i < 60; i++) {\n        vec3 pos = rayOrigin + t*rayDir;\n        float dist = sdCone(opTx(pos-vec3(3.0, 3.1, -3.0), trans), vec3(0.3, 0.04, 13.0));\n        if(dist < precis) {\n            break;\n        }\n        if(t > tmax) {\n            return 0.0;\n        }\n        t += dist; \n    }\n    return t;\n}\n\nvec3 applyFog(vec3  rgb, float dist, vec3 rayOri, vec3 rayDir) {\n    float b = 0.01;\n    float c = 0.2;\n    float d = 0.1;\n    float lightDist = getLighthouseLight(rayOri, rayDir);\n    float lightAmount = 1.0 - exp( -lightDist*d );\n    lightAmount = 0.6;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -dist*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.7)-0.4*vec3(0.45, 0.2, 0.0);\n    vec3  lightCol = vec3(1.0,0.9,0.7);\n    if(lightDist > 0.0 && lightDist < 8.0) {\n        return mix(mix(rgb, fogColor, fogAmount), lightCol, lightAmount);\n    }\n    return mix(rgb, fogColor, fogAmount);\n}\n\n// --- COMBINE EVERYTHING TO GET PIXEL COLOR\nvec3 calColor(vec3 rayOrigin, vec3 rayDir) {\n\tvec3 matCol; // material color\n   \t// finds the t of intersect and what is it intersected with\n    vec2 result = rayMarch(rayOrigin, rayDir);\n    float t = result.x;\n    \n    vec3 pos = rayOrigin + t*rayDir;\n    vec3 nor = calcNormal( pos );\n    vec3 reflectEye = reflect(normalize(rayDir), nor); // rayDir is the eye to position\n    vec3 posToLight; // define vector that is dependant per light\n    float ambCoeff = 0.1;\n    float shadow, attenuation, spotCos, spotCoeff = 0.0;           // how much in the light\n    float diff, spec;\n    \n    // define spotlight illuminating moon and then the moonlight\n    SpotLight moonSpot = SpotLight(MoonSpotPos, MoonSpotDir, MoonSpotCol, 1.0, 0.1, 20.0);\n    SpotLight light = SpotLight(LightPos, LightDir, LightCol, 0.9, 0.4, 20.0);\n    \n    bool background = false;\n    // set the material coefficients\n    if(result.y > 0.5 && result.y < 1.5) { //water\n        matCol = vec3(0.20,0.35,0.55);\n        float fo=pow(0.023*result.x, 1.1);\n            matCol=mix(matCol,vec3(0.91,0.88,0.98),fo);\n    } else if(result.y > 1.5 && result.y < 2.5) { // sphere in water\n        matCol = vec3(0.8);\n    } else if(result.y > 2.5 && result.y < 3.5) { // moon\n        reflectEye = reflect(normalize(-rayDir), nor);\n        matCol = vec3(5.0*fbm3(pos));\n    } else if(result.y > 3.5 && result.y < 4.5) { // main lighthouse body\n        // could do some parametric barbershop coloring here\n        matCol = vec3(0.7, 0.0, 0.0);\n    } else if(result.y > 4.5 && result.y < 5.5) { // lighthouse other parts\n    \tmatCol = vec3(0.7);\n    } else {\t\t\t\t\t\t\t\t\t  // background\n        background = true;\n    }\n    \n    // calculate light addition per spotlight\n    // Bidirectional reflectance distribution function\n    vec3 brdf = vec3(0.0);\n    // Add lighting from spot on the moon\n    posToLight = normalize(moonSpot.pos - pos);\n    spotCos = dot(posToLight, moonSpot.dir);\n    spotCoeff = smoothstep( 1.0-moonSpot.spread, 1.0, spotCos );\n    if(spotCos > 1.0-moonSpot.spread) { // within the spotlight\n    \tdiff = spotCoeff*clamp(dot(nor,posToLight), 0.0, 1.0);\n        spec = spotCoeff*pow(clamp(dot(reflectEye,posToLight), 0.0, 1.0), 20.0);\n        shadow = softshadow( pos, posToLight, 0.025, 2.5 );\n        attenuation = 1.0;\n        brdf += light.color*matCol*((diff+spec)*shadow*attenuation);\n    }\n    // Add lighting from spot away from the moon\n    posToLight = normalize(light.pos - pos);\n    spotCos = dot(posToLight, light.dir);\n    spotCoeff = smoothstep( 1.0-light.spread, 1.0, spotCos );\n    if(spotCos > 1.0-light.spread) { // within the spotlight\n    \tdiff = spotCoeff*clamp(dot(nor,posToLight), 0.0, 1.0);\n        spec = spotCoeff*pow(clamp(dot(reflectEye,posToLight), 0.0, 1.0), 20.0);\n        shadow = softshadow( pos, posToLight, 0.025, 2.5 );\n        attenuation = 1.0;\n        brdf += light.color*matCol*((diff+spec)*shadow*attenuation);\n    }\n    // Add Ambient\n    brdf += ambCoeff*vec3(0.50,0.70,1.00);\n    \n    // set the brackground\n    if(background) {\n    \tbrdf = 0.2*vec3(0.0, 0.2, 0.45);\n        result.x = 20.0;\n    }\n    // perform post processing effects\n    brdf = applyFog(brdf, result.x, rayOrigin, rayDir);\n    \n \treturn vec3(clamp(brdf, 0.0, 1.0));  \n}\n\n\n\n// CAMERA SETTING\nmat3 mkCamMat(in vec3 rayOrigin, in vec3 lookAtPoint, float roll) {\n    vec3 cw = normalize(lookAtPoint - rayOrigin);\n    vec3 cp = vec3(sin(roll), cos(roll), 0.0); //this is a temp right vec for cross determination\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera or eye (where rays start)\n    vec3 rayOrigin = vec3(0.0, 1.5, 4.0);\n    vec3 lookAtPoint = vec3(-1.0, 1.5, 0.0);\n    float focalLen = 1.0; // how far camera is from image plane\n    mat3 camMat = mkCamMat(rayOrigin, lookAtPoint, 0.0);\n\n    // ray direction into image plane\n    vec3 rayDir = camMat * normalize(vec3(p.xy, focalLen));\n    \n    //render the scene with ray marching\n    vec3 col = calColor(rayOrigin, rayDir);\n\n    fragColor = vec4(col, 1.0); \n\t//fragColor = vec4(.9); // that off white\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[549, 594, 663, 663, 757], [759, 759, 778, 778, 1181], [1183, 1183, 1203, 1203, 1528], [1531, 1573, 1614, 1614, 1665], [1666, 1666, 1691, 1691, 1728], [1730, 1730, 1755, 1755, 1820], [1821, 1821, 1850, 1850, 1898], [1944, 1985, 2016, 2016, 2103], [2105, 2105, 2141, 2141, 2240], [2242, 2242, 2280, 2280, 2449], [2451, 2451, 2486, 2486, 2553], [2555, 2555, 2592, 2592, 2620], [2622, 2622, 2649, 2649, 2779], [2781, 2781, 2807, 2807, 2918], [2920, 2920, 2966, 2966, 4337], [4382, 4429, 4449, 4449, 4780], [4782, 4782, 4832, 4832, 5448], [5451, 5508, 5579, 5579, 5948], [5950, 6038, 6065, 6065, 6326], [6329, 6329, 6384, 6384, 7292], [7294, 7294, 7358, 7358, 7908], [7910, 7955, 7999, 7999, 11216], [11220, 11238, 11305, 11305, 11565], [11568, 11568, 11625, 11625, 12256]], "test": "untested"}
{"id": "MlXSWj", "name": "Fractal flower", "author": "Pinillya", "description": "I was planning on drawing a flower - turned into a fractal shader as I kept testing new stuf. ", "tags": ["drawing2d"], "likes": 1, "viewed": 185, "published": "Public", "date": "1439666016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 createFlowerShape (in vec2 center, vec2 iteration) {\n    \n    vec3 col = vec3(0.08, 0.01, 0.01);\n    float rad = 0.003 + 0.1*cos(atan(center.x, center.y)*iteration.x);\n\n    col *= vec3(rad);\n    \n    col += smoothstep(rad,(rad*0.2)-0.1, length(center));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-1.0 + 2.0 *fragCoord.xy / iResolution.xy);\n    vec2(iResolution.x/iResolution.y, 1.0);\n    p *= 0.09;\n    \n\tvec2 center = p - vec2(-0.0,-0.0);\n    \n    vec2 iteration = vec2(10.0 + sin(iTime/10.0)*500.0);\n    \n    vec3 col = createFlowerShape(center, iteration);\n    \n    for (float i = -0.0; i < 8.0; i++) {\n        for (float j = -1.0; j < 8.0; j++) {\n            float yPos = 0.1+(i/8.0);\n            float xPos = 0.1+(j/8.0);\n            center = p - vec2(xPos,yPos);\n            vec3 tcol = createFlowerShape(center, iteration);\n\n            col += tcol;\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 281], [283, 283, 340, 340, 963]], "test": "untested"}
{"id": "MlXXDB", "name": "Minimalist", "author": "mgattis", "description": "My first try at path tracing. Casting more rays give amazing results. Had to give it a try. Special thanks to: http://blog.hvidtfeldts.net/. Here is a nice SW rendered image of the above: https://dl.dropboxusercontent.com/u/8746356/minimalist.png.", "tags": ["raymarching", "pathtracing"], "likes": 21, "viewed": 2724, "published": "Public API", "date": "1439447562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// mgattis\n\n#define MAX_DISTANCE        (8.0)\n#define MIN_DELTA           (0.004)\n#define MAX_RAYITERATIONS   (96)\n#define MAX_RAYSAMPLES      (4)\n#define MAX_RAYREFLECTIONS  (8)\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\nvec2 seed;\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir) {\n\treturn getSampleBiased(dir,0.0); // <- unbiased!\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n    // Formula 34 in GI Compendium\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 vRotateY(vec3 p, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat plane(in vec3 p, in float y) {\n    return p.y - y;\n}\n\nfloat udBox(in vec3 p, in vec3 b) {\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat getMap(in vec3 position, out int object) {\n    float rayDelta;\n    float temp;\n    \n    vec3 p = position;\n    \n    rayDelta = sphere(p - vec3(0.0, 0.2, 0.0), 1.0);\n    object = 1;\n    \n    temp = udBox(p - vec3(0.0, -1.8, 0.0), vec3(1.0, 1.0, 1.0));\n    if (temp < rayDelta) {\n        rayDelta = temp;\n        object = 1;\n    }\n    \n    temp = plane(p, -1.0);\n    if (temp < rayDelta) {\n        rayDelta = temp;\n        object = 1;\n    }\n    \n    return rayDelta;\n}\n\nvec3 getNormal(vec3 p) {\n    vec3 s = p;\n    float h = MIN_DELTA;\n    int object;\n    return normalize(vec3(\n            getMap(p + vec3(h, 0.0, 0.0), object) - getMap(p - vec3(h, 0.0, 0.0), object),\n            getMap(p + vec3(0.0, h, 0.0), object) - getMap(p - vec3(0.0, h, 0.0), object),\n            getMap(p + vec3(0.0, 0.0, h), object) - getMap(p - vec3(0.0, 0.0, h), object)));\n}\n\nfloat castRay(in vec3 origin, in vec3 direction, out int object, out int iterations) {\n    float rayDistance = 0.0;\n    float rayDelta = 0.0;\n    vec3 rayPosition;\n    \n    rayPosition = origin;\n    \n    for (int i = 0; i < MAX_RAYITERATIONS; i++) {\n        iterations += 1;\n        \n        rayDelta = getMap(rayPosition, object);\n        \n        rayDistance += rayDelta;\n        rayPosition = origin + direction * rayDistance;\n        if (rayDelta <= MIN_DELTA) {\n            return rayDistance;\n        }\n        if (rayDistance >= MAX_DISTANCE) {\n            object = 0;\n\t\t\treturn MAX_DISTANCE;\n        }\n    }\n    \n    object = 0;\n    return MAX_DISTANCE;\n}\n\nvec3 getBackground(in vec3 direction) {\n    vec3 color = vec3(0.8, 0.9, 1.0);\n    \n    vec3 bgDirection = normalize(vec3(1.0, 1.0, -1.0));\n    float bgVal = max(0.0, dot(bgDirection, direction));\n    color = mix(color, vec3(1.0, 1.0, 1.0), bgVal);\n                      \n    return color;\n}\n\nvec3 getColor(in vec3 position, in vec3 direction, in int object) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (object == 0) {\n        color = getBackground(direction);\n    }\n    else if (object == 1) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    return color;\n}\n\nvec3 castFullRay(in vec3 origin, in vec3 direction, in int subframe) {\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 directLight = vec3(0.0, 0.0, 0.0);\n    float Albedo = 0.4;\n    int iterations = 0;\n    int object = 0;\n    \n    vec3 rayOrigin = origin;\n    vec3 rayDirection = direction;\n    \n    seed = direction.xy * (float(subframe) + iTime + 1.0);\n    \n    for (int i = 0; i < MAX_RAYREFLECTIONS; i++) {\n        float rayDistance = castRay(rayOrigin, rayDirection, object, iterations);\n        if (object != 0) {            \n            vec3 rayPosition = rayOrigin + rayDirection * rayDistance;\n            vec3 rayNormal = getNormal(rayPosition);\n            vec3 newDirection = normalize(getSample(rayNormal));\n\n            color *= getColor(rayPosition, rayDirection, object) * Albedo * 2.0;\n            \n            rayOrigin = rayPosition + rayNormal * MIN_DELTA * 4.0;\n            rayDirection = newDirection;\n            \n            vec3 sunDirection = normalize(vec3(1.0, 1.0, -1.0));\n            vec3 sunSampleDirection = getConeSample(sunDirection, 0.0001);\n            float sunLight = dot(rayNormal, sunSampleDirection);\n            if (sunLight > 0.0) {\n                castRay(rayOrigin, sunSampleDirection, object, iterations);\n                if (object == 0) {\n                    directLight += color * sunLight * 1.0;\n                    //return vec3(1.0, 0.0, 0.0);\n                }\n            }\n        }\n        else {\n            return directLight + color * getBackground(rayDirection);\n        }\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = 2.0 * fragCoord.xy / iResolution.y;\n    uv -= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float myLocalTime = iTime * 0.2 + 2.0;\n    \n    vec3 origin = vRotateY(vec3(0.0, 0.0, -4.0), myLocalTime);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < MAX_RAYSAMPLES; i++) {\n        seed = uv.xy * (float(i) + 1.0);\n        vec3 direction = normalize(vec3(uv.xy + rand2n() / iResolution.y * 2.0, 2.0));\n        direction = vRotateY(direction, myLocalTime);\n    \tcolor += castFullRay(origin, direction, i);\n    }\n    \n    color = color / float(MAX_RAYSAMPLES);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 277, 292, 292, 525], [528, 528, 548, 642, 723], [725, 725, 771, 771, 1033], [1036, 1036, 1062, 1062, 1114], [1116, 1116, 1156, 1156, 1192], [1194, 1194, 1238, 1273, 1526], [1528, 1528, 1564, 1564, 1657], [1659, 1659, 1696, 1696, 1724], [1726, 1726, 1762, 1762, 1784], [1786, 1786, 1821, 1821, 1858], [1860, 1860, 1908, 1908, 2332], [2334, 2334, 2358, 2358, 2719], [2721, 2721, 2807, 2807, 3384], [3386, 3386, 3425, 3425, 3676], [3678, 3678, 3745, 3745, 3955], [3957, 3957, 4027, 4027, 5533], [5535, 5535, 5590, 5590, 6227]], "test": "untested"}
{"id": "MlXXDM", "name": "[SIG15] Winning Solitaire 2", "author": "eigenaar", "description": "A classic and forever satisfying video game moment. Controls : hold A while running to better see the cards. If you can, increase the number of cards (see \"#define OBJECT\") and add the missing patterns (see \"#define COMPILE_PATTERNS\").", "tags": ["sig15"], "likes": 3, "viewed": 1886, "published": "Public API", "date": "1439205467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//======================================================================\n// Hold A to better see a sample of the cards.\n// On my windows 8 laptop, compilation fails using Chrome\n// but works fine with Firefox. Reducing the number of cards\n// (by commenting the \"#define OBJECT\"s below) might help.\n\n// Some symbol patterns on the cards crash at compilation on some browsers,\n// so I took them out. You can try adding them back by uncommenting the\n// line \"#define COMPILE_PATTERNS\".\n\n// I left the number of cards at 1 by default so it loads faster, but\n// increase it to at least 6 to get nice results. Crank it up\n// to 20 if you can :).\n\n// A piecewise parabolic prism bounding volume is used to find a\n// good approximation of intersections, and the neighboring cards in the stack\n// are then searched for a precise intersection. All designs were\n// manually constructed with implicit functions. Cards numbers and suits\n// are selected automatically.\n\n// By Olivier Mercier\n//======================================================================\n\n\n\n// parameters, can be modified\n#define CAMERA_SPEED 0.22\n#define NB_BOUNCES 10\n#define BUMP_HEIGHT_FACTOR 0.5\n#define CARD_SPEED 1.0\n#define SEED 12834.77346652\n#define CARD_DENSITY 8.0\n#define NB_MARCH_LAYERS 3 // affects the number of cards searched for intersections.\n#define CARD_BORDER_SIZE 0.025\n#define CARD_BORDER_TINT1 0.3\n#define CARD_BORDER_TINT2 0.2\n#define SHOOT_TOWARDS_CAMERA_RANGE 0.95 // range (in radian) for the randomness of the card direction angle\n#define SHOOT_TOWARDS_CAMERA_OFFSET 4.0 // to shoot ahead of the camera\n\n//#define COMPILE_PATTERNS\n\n// e.g. if you want 5 card stacks, leave OBJECT1 to OBJECT5 uncommented, and comment OBJECT6 to OBJECT20.\n#define OBJECT1\n//#define OBJECT2\n//#define OBJECT3\n//#define OBJECT4\n//#define OBJECT5\n//#define OBJECT6\n//#define OBJECT7\n//#define OBJECT8\n//#define OBJECT9\n//#define OBJECT10\n//#define OBJECT11\n//#define OBJECT12\n//#define OBJECT13\n//#define OBJECT14\n//#define OBJECT15\n//#define OBJECT16\n//#define OBJECT17\n//#define OBJECT18\n//#define OBJECT19\n//#define OBJECT20\n\n\n// constants. DO NOT MODIFY.\n#define MATERIAL_UVW 1\n#define MATERIAL_NORMAL 2\n#define MATERIAL_CARD_SIDE_XM 3\n#define MATERIAL_CARD_SIDE_XP 4\n#define MATERIAL_CARD_SIDE_YM 5\n#define MATERIAL_CARD_SIDE_YP 6\n#define MATERIAL_CARD_FACE 7\n#define MATERIAL_CARD_BACK 8\n#define MATERIAL_FLOOR 9\n#define INFINITY 99999.0\n#define EPSILON 0.0001\n#define PI 3.14159265359\n#define CARD_HEIGHT 1.4\n#define CARD_WIDTH 1.0\n#define CARD_SPEED_ADJUSTED CARD_SPEED/(34.0/5.0)\n\nfloat multiMin3(float a1, float a2, float a3) {return min(a1,min(a2,a3));}\nfloat multiMin4(float a1, float a2, float a3,float a4) {return min(a1,min(a2,min(a3,a4)));}\nfloat multiMin5(float a1, float a2, float a3,float a4,float a5) {return min(a1,min(a2,min(a3,min(a4,a5))));}\nfloat multiMin6(float a1, float a2, float a3,float a4,float a5,float a6) {return min(a1,min(a2,min(a3,min(a4,min(a5,a6)))));}\nfloat multiMax3(float a1, float a2, float a3) {return max(a1,max(a2,a3));}\nfloat multiMax4(float a1, float a2, float a3,float a4) {return max(a1,max(a2,max(a3,a4)));}\nfloat multiMax5(float a1, float a2, float a3,float a4,float a5) {return max(a1,max(a2,max(a3,max(a4,a5))));}\nvec3 minVec3(vec3 a, vec3 b){ return vec3(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)); }\nvec3 multiMin3Vec3(vec3 a1,vec3 a2,vec3 a3){ return minVec3(a1, minVec3(a2,a3)); }\nvec3 multiMin4Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4){ return minVec3(a1, minVec3(a2,minVec3(a3,a4))); }\nvec3 multiMin5Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,a5)))); }\nvec3 multiMin6Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5,vec3 a6){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,minVec3(a5,a6))))); }\nvec3 multiMin7Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5,vec3 a6,vec3 a7){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,minVec3(a5,minVec3(a6,a7)))))); }\nvec3 multiMin9Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5,vec3 a6,vec3 a7,vec3 a8,vec3 a9){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,minVec3(a5,minVec3(a6,minVec3(a7,minVec3(a8,a9)))))))); }\n\nstruct Intersection {\n    float dist;\n    vec3 normal;\n    vec3 uvw;\n    int material;\n    int info1;\n    int info2;\n};\n    \nfloat sqr(float x) {return x*x;}\n\nvec3 camPosFun(float time) {\n    return 18.0*vec3(2.0*cos(time*CAMERA_SPEED), 0.25, sin(time*CAMERA_SPEED));\n}\n\nIntersection rectangle(vec3 ori, vec3 dir, vec3 center, vec3 normal, vec2 size) {\n    \n    Intersection res;\n    vec3 up = vec3(1.0,0.0,0.0);\n    vec3 right = cross(normal, up);\n    \n    float dist = dot(normal, center-ori) / dot(normal, dir);\n        vec3 pos = ori + dist*dir;\n        vec3 uvw = vec3(vec2(dot(pos-center, right), dot(pos-center,up)), 0.0);\n        if(abs(uvw.x) <= size.x && abs(uvw.y) <= size.y) {\n            res.dist = dist;\n            res.normal = dot(normal, dir) >= 0.0 ? normal : -normal;\n            res.uvw = uvw;\n            res.material = MATERIAL_FLOOR;\n        } else {\n            res.dist = -1.0;\n        }\n    \n    return res;\n}\n\n// piecewise parabolic funcction representing bounces.\nfloat bounce(float x, float bounceHeight, float bounceStepSize)\n{    \n    float maxHeight = bounceHeight;\n    float MHOverBounceStepSiseSqrDiv = maxHeight/(bounceStepSize*bounceStepSize/4.0);\n    float sqrtCoeff = (1.0+sqrt(BUMP_HEIGHT_FACTOR))*sqrt(maxHeight/MHOverBounceStepSiseSqrDiv);\n    float sqrtFact = sqrt(BUMP_HEIGHT_FACTOR);\n        \n    float res = 0.0;\n    float center = 0.0;\n    float height = maxHeight;\n    float fact = 1.0;\n    float temp;\n    for(int i=0; i<=NB_BOUNCES; i++) {\n        temp = -MHOverBounceStepSiseSqrDiv*sqr(x-center) + height;\n        if(temp >= 0.0) {res = temp; return res;}\n        height *= BUMP_HEIGHT_FACTOR;\n        fact *= sqrtFact;\n        center = sqrtCoeff*(1.0-fact)/(1.0-sqrtFact); \n    }\n    \n    return res;\n}\n\nfloat bounceFloor(float x, float bounceHeight, float bounceStepSize) {\n    return bounce( floor(EPSILON+x*CARD_DENSITY)/CARD_DENSITY,bounceHeight, bounceStepSize );\n}\n\n\n// returns a different value for each time cycle\nfloat cycleRandom(float time, float frequency, float phase, float seed) {\n    return sin(54.1235+SEED*seed + SEED*floor(time*frequency*CARD_SPEED_ADJUSTED - phase));\n}\n\n\n// falling card stack starting at center and extruding in the given direction\nIntersection fallingCard(float time, vec3 ori, vec3 dir, float frequency, float phase) {\n\n    vec3 center= vec3(\n                     0.0 + 8.0*cycleRandom(time, frequency, phase, 31.512*frequency),\n                     0.0,\n                     0.0 + 8.0*cycleRandom(time, frequency, phase, 51.512*frequency)\n                 );\n    float bounceHeight = 8.0 + 4.0*cycleRandom(time, frequency, phase, 3.997*frequency);\n    float bounceStepSize = 8.0 + 4.0*cycleRandom(time, frequency, phase, 15.371*frequency);\n    float camAngle = CAMERA_SPEED*(SHOOT_TOWARDS_CAMERA_OFFSET+floor(time*frequency*CARD_SPEED_ADJUSTED - phase)/(frequency*CARD_SPEED_ADJUSTED));\n    float theta = camAngle + SHOOT_TOWARDS_CAMERA_RANGE*cycleRandom(time, frequency, phase, 12.662*frequency);\n    vec3 z = vec3(cos(theta), 0.0, sin(theta));\n    vec3 y = vec3(0.0,1.0,0.0);\n    \n    float speed = CARD_SPEED*frequency*bounceStepSize;\n    float bssAdjusted = 34.0*bounceStepSize/5.0;\n    \n    float zBegin = max(mod(speed*(time-phase/speed*bssAdjusted),bssAdjusted)-12.0*bounceStepSize/5.0,0.0);\n    float zEnd = min(mod(speed*(time-phase/speed*bssAdjusted),bssAdjusted),14.0*bounceStepSize/5.0);\n   \n    int cardId = int(max(min(7.0 + 6.5*cycleRandom(time, frequency, phase, 39.612*frequency),13.0),1.0));\n    int cardSuit = int(max(min(3.0 + 2.0*cycleRandom(time, frequency, phase, 634.775*frequency),4.0),1.0));\n    \n    Intersection res;\n    res.info1 = cardId;\n    res.info2 = cardSuit;\n    \n    if(zEnd < zBegin) {res.dist = -1.0; return res;}\n    \n    \n    // transform to local axis-aligned coordinates\n    vec3 x = cross(y,z);\n    vec3 locOri = vec3( dot(ori-center,x), dot(ori-center,y), dot(ori-center,z) );\n    vec3 locDir = vec3( dot(dir,x), dot(dir,y), dot(dir,z) );\n    \n    \n    //=============================================\n    // rough intersection with bounding volume\n    float tx = INFINITY;\n    float ty = INFINITY;\n    float tz = INFINITY;\n    vec3 interX, interY, interZ;\n    \n    \n    if(abs(locDir.x) > EPSILON/10.0) {\n        tx = (sign(locOri.x)*CARD_WIDTH - locOri.x)/locDir.x;\n        interX = locOri + tx*locDir;\n        if (tx < 0.0) {tx = INFINITY;}\n        else if(!( abs(interX.y - bounce(interX.z,bounceHeight,bounceStepSize))<=CARD_HEIGHT && zBegin<=interX.z && interX.z<=zEnd)) {tx = INFINITY;}\n    }\n    \n    \n    if(abs(locDir.z) > EPSILON/10.0) {\n        tz = min( (zEnd - locOri.z)/locDir.z, (zBegin - locOri.z)/locDir.z );\n        interZ = locOri + tz*locDir;\n        if (tz < 0.0) {tz = INFINITY;}\n        if(!( abs(interZ.x)<=CARD_WIDTH && abs(interZ.y-bounce(interZ.z,bounceHeight,bounceStepSize))<=CARD_HEIGHT )) {tz = INFINITY;}\n    }\n    \n    \n    if(abs(locDir.y) > EPSILON/1000.0) {\n        float a = -bounceHeight/(bounceStepSize*bounceStepSize/4.0);\n        float c = 0.0;\n        float h = bounceHeight;\n        ty = INFINITY;\n        float tyBump;\n        \n        float bssSqrDiv4 = (bounceStepSize*bounceStepSize/4.0);\n        \n        float bounceSize = sqrt(h/bounceHeight*bssSqrDiv4);\n        \n        float tempA2 = 4.0*a*sqr(locDir.z);\n        float tempB3 = tempA2/2.0;\n        for(int i=0; i<=NB_BOUNCES; i++) {\n            if(abs(locDir.z)<=EPSILON) {\n                tyBump = min( (h + CARD_HEIGHT - locOri.y + a*(c-locOri.z)*(c-locOri.z))/locDir.y ,\n                              (h - CARD_HEIGHT - locOri.y + a*(c-locOri.z)*(c-locOri.z))/locDir.y );\n                \n            } else {\n                float tempA1 = sqr(locDir.y) + 4.0*a*locDir.y*locDir.z*(c-locOri.z);\n                float delta1 = tempA1 + tempA2*(locOri.y-(h+CARD_HEIGHT));\n                float delta2 = tempA1 + tempA2*(locOri.y-(h-CARD_HEIGHT));\n                \n                float temp1 = INFINITY;\n                float temp2 = INFINITY;\n                float tempB1 = locDir.y + 2.0*a*locDir.z*(c-locOri.z);\n                if(delta1 >= 0.0) {            \n                    float tempB2 = sqrt(delta1);\n                    float t1 = (tempB1 + tempB2)/tempB3;\n                    if(t1 < 0.0) {t1 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t1*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t1 = INFINITY;}\n                    }\n                    float t2 = (tempB1 - tempB2)/tempB3;\n                    if(t2 < 0.0) {t2 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t2*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t2 = INFINITY;}\n                    }\n                                        \n                    temp1 = min( t1, t2 );\n                }\n                if(delta2 >= 0.0) {\n                    float tempB2 = sqrt(delta2);\n                    float t1 = (tempB1 + tempB2)/tempB3;\n                    if(t1 < 0.0) {t1 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t1*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t1 = INFINITY;}\n                    }\n                    float t2 = (tempB1 - tempB2)/tempB3;\n                    if(t2 < 0.0) {t2 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t2*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t2 = INFINITY;}\n                    }\n                                        \n                    temp2 = min( t1, t2 );\n                }\n                \n                tyBump = min( temp1, temp2 );\n                \n            }\n            \n            vec3 interBump = locOri + tyBump*locDir;\n            if( abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize ) {\n                ty = min(ty, tyBump);\n            }\n            \n            h *= BUMP_HEIGHT_FACTOR;\n            c += bounceSize;\n            bounceSize = sqrt(h/bounceHeight*bssSqrDiv4);\n            c += bounceSize;\n            \n        }\n        \n        interY = locOri + ty*locDir;\n        if(!( abs(interY.x)<=CARD_WIDTH && zBegin<=interY.z && interY.z<=zEnd)) {ty = INFINITY;}\n    }\n                \n    float minT = multiMin3(tx,ty,tz);\n    if(minT > INFINITY/2.0) {res.dist = -1.0; return res;}\n    vec3 interBounding = locOri + minT*locDir;\n    \n   \n    \n    //=============================================\n    // if intersects with bounding volume, refine intersections by looking at the neighboring card slices.\n        \n    float tCard = INFINITY;\n    int material = -1;\n    \n    \n    // refine intersection in x\n    if( tx < INFINITY/2.0 ) {\n        if( abs(interX.y-bounceFloor(interX.z-0.5*(-1.0+sign(locDir.z))/CARD_DENSITY,bounceHeight,bounceStepSize))<=CARD_HEIGHT ) {\n            tCard = min(tCard, tx);\n            material = MATERIAL_CARD_SIDE_XM;\n        }\n    }\n    \n    \n    // refine intersection in z\n    if( tz < INFINITY/2.0 ) {\n        if( abs(interZ.y-bounceFloor(interZ.z,bounceHeight,bounceStepSize))<=CARD_HEIGHT ) {\n            tCard = min(tCard, tz);\n            if(locDir.z<=0.0) {material = MATERIAL_CARD_FACE;}\n            else              {material = MATERIAL_CARD_BACK;}\n        }\n    }\n    \n\n    \n    \n    // refine intersection in y by looking at neighboring cards.\n    int zFloored = int(floor(EPSILON+interBounding.z*CARD_DENSITY));\n    for(int i=-NB_MARCH_LAYERS; i<=NB_MARCH_LAYERS; i++) {\n        \n        int iSlice = zFloored + int(sign(-locDir.z))*i;\n        \n        float prevZ = (float(iSlice-int(sign(locDir.z)))/CARD_DENSITY);\n        float thisZ = (float(iSlice  )/CARD_DENSITY);\n        \n        if(thisZ < zBegin || thisZ > zEnd) {continue;}\n        float prevY, thisY;\n        \n        prevY = bounce(prevZ,bounceHeight,bounceStepSize) + CARD_HEIGHT;\n        thisY = bounce(thisZ,bounceHeight,bounceStepSize) + CARD_HEIGHT;\n         \n        float maxPrevThisY = max(prevY,thisY);\n        float minPrevThisY = min(prevY,thisY);\n        float maxPrevThisZ = max(prevZ,thisZ);\n        float minPrevThisZ = min(prevZ,thisZ);\n        \n        // top of card\n        if(abs(locDir.y) > EPSILON) {\n            ty = ( minPrevThisY - locOri.y )/locDir.y;\n            interY = locOri + ty*locDir;\n            if( ty >= 0.0 && minPrevThisZ<=interY.z && interY.z<=maxPrevThisZ && abs(interY.x)<=CARD_WIDTH ) {\n                if(ty < tCard) {\n                    tCard = ty;\n                    material = MATERIAL_CARD_SIDE_YM;\n                }\n            }\n        }\n        \n        // vertical wall\n        if(abs(locDir.z) > EPSILON) {\n            tz = ( thisZ - locOri.z )/locDir.z;\n            interZ = locOri + tz*locDir;\n            if( tz >= 0.0 && minPrevThisY<=interZ.y && interZ.y<=maxPrevThisY && abs(interZ.x)<=CARD_WIDTH ) {\n                if(tz < tCard) {\n                    tCard = tz;\n                    if(locDir.z<=0.0) {material = MATERIAL_CARD_FACE;}\n                    else              {material = MATERIAL_CARD_BACK;}\n                }\n            }\n        }\n        \n        prevY = bounce(prevZ,bounceHeight,bounceStepSize) - CARD_HEIGHT;\n        thisY = bounce(thisZ,bounceHeight,bounceStepSize) - CARD_HEIGHT;\n        maxPrevThisY = max(prevY,thisY);\n        minPrevThisY = min(prevY,thisY);\n        \n        // top of card\n        if(abs(locDir.y) > EPSILON) {\n            ty = ( maxPrevThisY - locOri.y )/locDir.y;\n            interY = locOri + ty*locDir;\n            if( ty >= 0.0 && minPrevThisZ<=interY.z && interY.z<=maxPrevThisZ && abs(interY.x)<=CARD_WIDTH ) {\n                if(ty < tCard) {\n                    tCard = ty;\n                    material = MATERIAL_CARD_SIDE_YM;\n                }\n                \n            }\n        }\n        \n        // vertical wall\n        if(abs(locDir.z) > EPSILON) {\n            tz = ( thisZ - locOri.z )/locDir.z;\n            interZ = locOri + tz*locDir;\n            if( tz >= 0.0 && minPrevThisY<=interZ.y && interZ.y<=maxPrevThisY && abs(interZ.x)<=CARD_WIDTH ) {\n                if(tz < tCard) {\n                    tCard = tz;\n                    if(locDir.z<0.0) {material = MATERIAL_CARD_FACE;}\n                    else              {material = MATERIAL_CARD_BACK;}\n                }\n            }\n        }\n    }\n    \n    if(tCard > INFINITY/2.0) {res.dist = -1.0;}\n    else{\n        vec3 interCard = locOri + tCard*locDir;\n        res.dist = tCard;\n        res.material = material;\n        \n        if(material == MATERIAL_CARD_SIDE_XM) {\n            if(locDir.x >= 0.0) {\n                res.material = MATERIAL_CARD_SIDE_XP;\n                res.normal = x;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            } else {\n                res.material = MATERIAL_CARD_SIDE_XM;\n                res.normal = -x;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            }\n        } else if(material == MATERIAL_CARD_SIDE_YM) {\n            if(locDir.y >= 0.0) {\n                res.material = MATERIAL_CARD_SIDE_YM;\n                res.normal = y;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            } else {\n                res.material = MATERIAL_CARD_SIDE_YP;\n                res.normal = -y;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            }\n        } else if(material==MATERIAL_CARD_FACE) {\n            res.normal = z;\n            res.uvw = vec3(interCard.x, interCard.y-bounceFloor(interCard.z,bounceHeight,bounceStepSize), interCard.z);\n        } else if(material == MATERIAL_CARD_BACK) {\n            res.normal = -z;\n            res.uvw = vec3(interCard.x, interCard.y-bounceFloor(interCard.z,bounceHeight,bounceStepSize), interCard.z);\n        }\n    }    \n    \n    return res;\n}\n\n// 1 to 13 is number+JQK\nvec3 cardSymbol(vec2 uv, int id, vec2 center, float size, int suitColor) {\n    vec3 color = vec3(1.0);\n    \n    float x = (uv.x - center.x)/size;\n    float y = (uv.y - center.y)/size;\n        \n    float phi = -1.0;\n    if(id==1) {\n        phi = multiMin4(1.4-2.8*x-y,1.4+2.8*x-y,2.8+2.0*y,-max(multiMin3(0.075-0.67*x-0.178571*y,0.075+0.67*x-0.178571*y,0.0892857+0.357143*y),multiMin4(-0.401786-0.535714*y,-1.15*x-0.410714*y,1.15*x-0.410714*y,2.57857+1.35714*y)));\n    } else if(id==2) {\n        float t1 = 0.937994*(1.4+y);\n        float t2 = 0.75*(1.0+x);\n        float t3 = sqr(-0.75+(t2));\n        float t4 = sqr(-1.87638+(t1));\n          phi = multiMax3(multiMin3(1.0-1.77778*(t3)-1.77778*(t4),-1.0+16.0*(t3)+16.0*(t4),-min(1.87638-(t1),-0.951057*(-0.75+(t2))-0.309017*(-1.87638+(t1)))),multiMin4(1.0-1.33333*(-0.75+(t2)),1.0+1.33333*(-0.75+(t2)),1.0-4.0*(-0.25+(t1)),1.0+4.0*(-0.25+(t1))),multiMin4(-0.5+(t1),-0.951057*(-1.19721+(t2))-0.309017*(-0.5+(t1)),1.0-0.697681*(-1.19721+(t2))*(-1.19721+(t2))-0.697681*(-0.5+(t1))*(-0.5+(t1)),-1.0+2.05716*(-1.19721+(t2))*(-1.19721+(t2))+2.05716*(-0.5+(t1))*(-0.5+(t1))));\n    } else if(id==3) {\n        float t1 = sqr(x);\n          phi = max(multiMin3(0.489796-(t1)+(-1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(9.52381+8.16327*y),-min(0.-1.4*x,1.+1.71429*y)),multiMin3(0.489796-(t1)+(1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(-9.52381+8.16327*y),-min(0.-1.4*x,1.-1.71429*y)));\n    } else if(id==4) {\n           phi = min(multiMax3(multiMin4(3.16667-4.16667*x,-1.16667+4.16667*x,-0.333333-1.66667*y,2.33333+1.66667*y),multiMin4(2.77778-2.77778*x,-0.777778+2.77778*x,-0.833333-4.16667*y,2.83333+4.16667*y),multiMin5(2.47-3.25*x,0.990349+0.990349*x,2.18512+2.25965*x-1.61404*y,1.59035-1.13596*y,1.87+2.75*y)),-multiMin3(0.49-1.75*x,0.66+1.75*x-1.25*y,0.25+1.25*y));\n    } else if(id==5) {\n        float t1 = sqr(-0.7+0.714286*(1.4+y));\n        float t2 = 2.85714*(-0.35+0.7*(1.0+x));\n        float t3 = 2.0*(-1.5+0.714286*(1.4+y));\n        float t4 = 1.42857*(-0.7+0.7*(1.0+x));\n        float t5 = 5.0*(-0.2+0.7*(1.0+x));\n        float t6 = 5.0*(-1.8+0.714286*(1.4+y));\n        float t7 = 5.0*(-1.2+0.714286*(1.4+y));\n        phi = multiMax4(multiMin3(1.0-2.04082*sqr(-0.7+0.7*(1.0+x))-2.04082*(t1),-1.0+11.1111*sqr(-0.7+0.7*(1.0+x))+11.1111*(t1),-min(-1.0*(-0.7+0.7*(1.0+x)),-0.7+0.714286*(1.4+y))),multiMin4(1.0-(t4),1.0+(t4),1.0-(t6),1.0+(t6)),multiMin4(1.0-(t2),1.0+(t2),1.0-(t7),1.0+(t7)),multiMin4(1.0-(t5),1.0+(t5),1.0-(t3),1.0+(t3)));\n    } else if(id==6) {\n        float t1 = sqr(x);\n        phi = max(min(-0.280411-(t1)+(-3.44566-2.31812*y)*y,5.97113+5.44444*(t1)+y*(18.7597+12.6209*y)),multiMin4(0.240625+0.34658*x-0.156326*y,0.165609-0.118292*y,0.0713646+0.0303719*x+0.0960231*y,-0.0346321-0.376951*x+0.178595*y));\n    } else if(id==7) {\n        phi = max(multiMin4(1.-x,1.+x,5.6-4.0*y,-3.6+4.0*y),multiMin4(1.20252-0.364399*x-0.931243*y,-0.103283+0.931243*x-0.364399*y,0.603283-0.931243*x+0.364399*y,1.4+y));\n    } else if(id==8) {\n        float t1 = sqr(x);\n        phi = max(min(0.489796-(t1)+(-1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(9.52381+8.16327*y)),min(0.489796-(t1)+(1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(-9.52381+8.16327*y)));\n    } else if(id==9) {\n        float t1 = sqr(x);\n        phi = max(min(-0.280411-(t1)+(3.44566-2.31812*y)*y,5.97113+5.44444*(t1)+y*(-18.7597+12.6209*y)),multiMin4(-0.0346321+0.376951*x-0.178595*y,0.0713646-0.0303719*x-0.0960231*y,0.165609+0.118292*y,0.240625-0.34658*x+0.156326*y));\n    } else if(id==10) {\n        phi = max(min(0.816327+(1.22449-2.04082*x)*x-0.510204*sqr(y),x*(-6.66667+11.1111*x)+2.77778*y*y),multiMin4(-3.-5.0*x,5.+5.0*x,1.-0.714286*y,1.+0.714286*y));\n    } else if(id==11) {\n        phi = multiMax3(multiMin3(-0.55-1.39286*y,0.825255+(-0.326531-1.30612*x)*x+(-0.781706-0.989822*y)*y,-0.0486111+x*(1.77778+7.11111*x)+y*(4.25595+5.38903*y)),multiMin4(3.-4.0*x,-1.+4.0*x,1.56-1.11429*y,0.44+1.11429*y),multiMin4(1.3913-1.3913*x,0.608696+1.3913*x,4.875-3.48214*y,-2.875+3.48214*y));\n    } else if(id==12) {\n        phi = max(min(0.998283+(-0.0862742-1.08456*x)*x+(0.00145184-0.511241*y)*y,-0.995231+x*(0.23965+3.01266*x)+y*(-0.00403288+1.42011*y)),multiMin4(-0.0868019-1.1716*x-1.12614*y,-0.193198+0.460248*x-0.44239*y,0.829594-0.460248*x+0.44239*y,0.723198+1.1716*x+1.12614*y));\n    } else if(id==13) {\n        phi = multiMax3(multiMin4(-2.24012-4.24012*x,4.24012+4.24012*x,1.-0.714286*y,1.+0.714286*y),multiMin4(1.06003+1.06003*x-0.928571*y,0.820061-0.585758*y,0.+0.585758*y,-0.23997-1.06003*x+0.928571*y),multiMin4(-0.23997-1.06003*x-0.928571*y,0.-0.585758*y,0.820061+0.585758*y,1.06003+1.06003*x+0.928571*y));\n    }\n    \n    if(phi>=0.0) {\n        color.r = suitColor==1?1.0:0.0;\n        color.g = 0.0;\n        color.b = 0.0;\n    }\n    \n    return color;\n}\n\n\n// 1=diamond, 2=heart, 3=spade, 4=club\nvec3 cardSuit(vec2 uv, int id, vec2 center, float size) {\n    vec3 color = vec3(1.0);\n    \n    float x = (uv.x - center.x)/size;\n    float y = (uv.y - center.y)/size;\n    \n    float phi = -1.0;\n    if(id==1) {\n        phi = multiMin4(1.4-1.4*x-y,1.4+1.4*x-y,1.4-1.4*x+y,1.4+1.4*x+y);\n    } else if(id==2) {\n           phi = multiMax3(0.202435+(-2.41421-2.91421*x)*x+(1.21619-1.24268*y)*y,0.202435+(2.41421-2.91421*x)*x+(1.21619-1.24268*y)*y,multiMin3(-0.114277-0.788252*y,1.11428-1.20711*x+0.788252*y,1.11428+1.20711*x+0.788252*y));\n    } else if(id==3) {\n        float t1 = (0.064261+0.298355*y)*y;\n        float t2 = (-0.742857-1.72449*y)*y;\n        phi = multiMax4(0.42+(2.41421-2.91421*x)*x+(t2),0.42+(-2.41421-2.91421*x)*x+(t2),multiMin3(1.3-1.20711*x-0.928571*y,1.3+1.20711*x-0.928571*y,-0.3+0.928571*y),multiMin6(1.8-1.20711*x,1.8+1.20711*x,0.3-0.928571*y,1.3+0.928571*y,0.124567+(-1.50366+0.504189*x)*x+(t1),0.124567+(1.50366+0.504189*x)*x+(t1)));\n    } else if(id==4) {\n        phi = multiMax4(-1.22851-3.48205*x*x+(5.31619-3.17049*y)*y,0.249948+(-3.23205-3.48205*x)*x+(-0.0255681-3.17049*y)*y,0.249948+(3.23205-3.48205*x)*x+(-0.0255681-3.17049*y)*y,multiMin6(1.8-x,1.8+x,0.264102-0.954213*y,1.3359+0.954213*y,0.127498+(-1.24567+0.346021*x)*x+(0.0897412+0.31506*y)*y,0.127498+(1.24567+0.346021*x)*x+(0.0897412+0.31506*y)*y));\n    }\n    \n    if(phi>=0.0) {\n        color.r = id<3?1.0:0.0;\n        color.g = 0.0;\n        color.b = 0.0;\n    }\n    \n    return color;\n}\n\n// faces for jack, queen and king.\nvec3 cardHead(vec2 uv, int id, vec2 center, float size) {\n    vec3 color = vec3(1.0);\n    \n    float x = (uv.x - center.x)/size;\n    float y = (uv.y - center.y)/size;\n    \n    if(id==11) {\n        // face\n        if( 1.0-2.04082*x*x-2.77778*y*y >= 0.0) {\n            color = vec3(1.0, 215.0/255.0, 140.0/255.0);\n        }\n        // eyes\n        if( max(1.0-816.327*(-0.2+x)*(-0.2+x)-816.327*(-0.1+y)*(-0.1+y),1.0-816.327*(0.2+x)*(0.2+x)-816.327*(-0.1+y)*(-0.1+y)) >= 0.0 ) {\n            color = vec3(0.0);\n        }\n        // hair\n        if( multiMax5(min(1.0-44.4444*sqr(0.2+x)-44.4444*sqr(0.15+-0.37+y),-1.0+25.0*sqr(0.2+x)+25.0*sqr(0.25-0.37+y)),min(1.0-44.4444*sqr(-0.2+x)-44.4444*sqr(0.15-0.25+y),-1.0+25.0*sqr(-0.2+x)+25.0*sqr(0.25-0.25+y)),min(1.0-25.0*sqr(0.2+0.29552*(-0.2+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(-0.2+x)-0.29552*(0.35+y)),-1.0+20.6612*sqr(0.25+0.29552*(-0.2+x)-0.955336*(0.35+y))+20.6612*sqr(-0.955336*(-0.2+x)-0.29552*(0.35+y))),min(1.0-25.0*sqr(0.2-0.29552*(0.2+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(0.2+x)+0.29552*(0.35+y)),-1.0+20.6612*sqr(0.25-0.29552*(0.2+x)-0.955336*(0.35+y))+20.6612*sqr(-0.955336*(0.2+x)+0.29552*(0.35+y))),multiMin4(0.2-x,0.2+x,-0.5-y,0.8+y-abs(-0.1+mod(-0.1+x,0.2)))) >= 0.0 ) {\n            color = vec3(163.0/255.0, 107.0/255.0, 2.0/255.0);\n        }\n        // crown\n        if( multiMin4(0.5-x,0.5+x,-0.4+y,0.7-y+abs(-0.1+mod(-0.1+x,0.2))) >= 0.0 ) {\n            color = vec3(1.0,234.0/255.0,0.0);\n        }\n        \n    } else if(id==12) {\n           // face\n        if( 1.0-2.04082*x*x-2.77778*y*y >= 0.0) {\n            color = vec3(1.0, 215.0/255.0, 140.0/255.0);\n        }\n        // eyes\n        if( max(1.0-816.327*(-0.2+x)*(-0.2+x)-816.327*(-0.1+y)*(-0.1+y),1.0-816.327*(0.2+x)*(0.2+x)-816.327*(-0.1+y)*(-0.1+y)) >= 0.0 ) {\n            color = vec3(0.0);\n        }\n        // hair\n        if( multiMax4(min(-1.0+1.5625*sqr(0.62161*(-0.6+x)-0.783327*(-0.35+y))+1.5625*sqr(0.9+0.783327*(-0.6+x)+0.62161*(-0.35+y)),1.0-1.77778*sqr(0.62161*(-0.6+x)-0.783327*(-0.35+y))-1.77778*sqr(0.75+0.783327*(-0.6+x)+0.62161*(-0.35+y)-0.05*(1.0+cos(10.0*PI*(0.62161*(-0.6+x)-0.783327*(-0.35+y)))))),min(-1.0+1.5625*sqr(0.9-0.783327*(0.6+x)+0.62161*(-0.35+y))+1.5625*sqr(0.62161*(0.6+x)+0.783327*(-0.35+y)),1.0-1.77778*sqr(0.62161*(0.6+x)+0.783327*(-0.35+y))-1.77778*sqr(0.75-0.783327*(0.6+x)+0.62161*(-0.35+y)-0.05*(1.0+cos(10.0*PI*(0.62161*(0.6+x)+0.783327*(-0.35+y)))))),min(1.0-16.0*sqr(0.955336*(-0.25+x)-0.29552*(-0.3+y))-16.0*sqr(0.25+0.29552*(-0.25+x)+0.955336*(-0.3+y)),-1.0+sqr(0.955336*(-0.25+x)-0.29552*(-0.3+y))+ sqr(1.05+0.29552*(-0.25+x)+0.955336*(-0.3+y))),min(1.0-16.0*sqr(0.955336*(0.25+x)+0.29552*(-0.3+y))-16.0*sqr(0.25-0.29552*(0.25+x)+0.955336*(-0.3+y)),-1.0+sqr(0.955336*(0.25+x)+0.29552*(-0.3+y))+sqr(1.05-0.29552*(0.25+x)+0.955336*(-0.3+y)))) >= 0.0 ) {\n            color = vec3(163.0/255.0, 107.0/255.0, 2.0/255.0);\n        }\n        // lips\n        if( multiMax3(min(1.0-8.16327*x*x-8.16327*sqr(-0.07-y),-1.0+2.77778*x*x+2.77778*sqr(0.23-y)),min(1.0-59.1716*sqr(0.995004*(-0.12+x)+0.0998334*(0.24+y))-59.1716*sqr(0.13-0.0998334*(-0.12+x)+0.995004*(0.24+y)),-1.0+25.0*sqr(0.995004*(-0.12+x)+0.0998334*(0.24+y))+25.0*sqr(0.24-0.0998334*(-0.12+x)+0.995004*(0.24+y))),min(1.0-59.1716*sqr(0.995004*(0.12+x)-0.0998334*(0.24+y))-59.1716*sqr(0.13+0.0998334*(0.12+x)+0.995004*(0.24+y)),-1.0+25.0*sqr(0.995004*(0.12+x)-0.0998334*(0.24+y))+25.0*sqr(0.24+0.0998334*(0.12+x)+0.995004*(0.24+y)))) >= 0.0 ) {\n            color = vec3(1.0, 61.0/255.0, 61.0/255.0);\n        }\n        // crown\n        if( multiMin4(0.5-x, 0.5+x, -0.45+y, 0.75-y+abs(-0.1+mod(-0.1+x,0.2))) >= 0.0 ) {\n            color = vec3(1.0,234.0/255.0,0.0);\n        }\n    } else if(id==13) {\n        // face\n        if( 1.0-2.04082*x*x-2.77778*y*y >= 0.0) {\n            color = vec3(1.0, 215.0/255.0, 140.0/255.0);\n        }\n        // eyes\n        if( max(1.0-816.327*(-0.2+x)*(-0.2+x)-816.327*(-0.1+y)*(-0.1+y),1.0-816.327*(0.2+x)*(0.2+x)-816.327*(-0.1+y)*(-0.1+y)) >= 0.0 ) {\n            color = vec3(0.0);\n        }\n        // hair\n        if( multiMax5(min(1.0-44.4444*sqr(0.877583*(-0.15+x)+0.479426*(-0.3+y))-44.4444*sqr(0.15-0.479426*(-0.15+x)+0.877583*(-0.3+y)),-1.0+sqr(0.877583*(-0.15+x)+0.479426*(-0.3+y))+sqr(1.1-0.479426*(-0.15+x)+0.877583*(-0.3+y))),min(1.0-44.4444*sqr(0.877583*(0.15+x)-0.479426*(-0.3+y))-44.4444*sqr(0.15+0.479426*(0.15+x)+0.877583*(-0.3+y)),-1.0+sqr(0.877583*(0.15+x)-0.479426*(-0.3+y))+sqr(1.1+0.479426*(0.15+x)+0.877583*(-0.3+y))),min(-1.0+ x*x+sqr(0.53-y),1.0-2.04082*x*x-2.04082*sqr(0.03-y-0.05*(1.0+cos(10.0*PI*x)))),min(1.0-25.0*sqr(0.2+0.29552*(-0.24+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(-0.24+x)-0.29552*(0.35+y)),-1.0+11.1111*sqr(0.4+0.29552*(-0.24+x)-0.955336*(0.35+y))+11.1111*sqr(-0.955336*(-0.24+x)-0.29552*(0.35+y))),min(1.0-25.0*sqr(0.2-0.29552*(0.24+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(0.24+x)+0.29552*(0.35+y)),-1.0+11.1111*sqr(0.4-0.29552*(0.24+x)-0.955336*(0.35+y))+11.1111*sqr(-0.955336*(0.24+x)+0.29552*(0.35+y)))) >= 0.0 ) {\n            color = vec3(166.0/255.0, 166.0/255.0, 166.0/255.0);\n        }\n        // crown\n        if( multiMin4(0.5 -x,0.5 +x,-0.4+y,0.7 -y+abs(-0.1+mod(-0.1+x,0.2))) >= 0.0 ) {\n            color = vec3(1.0,234.0/255.0,0.0);\n        }\n    }\n    \n    return color;\n}\n\n\n#ifdef COMPILE_PATTERNS\n\n// check if point is inside box, return position inside box mappd to [1.0, 1.4], return vec2(infinity) if outside.\nvec2 isInsideBox(vec2 uv, vec2 center, float size) {\n    vec2 newUV = (uv - center)/size;\n    if(abs(newUV.x) <= CARD_WIDTH && abs(newUV.y) <= CARD_HEIGHT) {return newUV;}\n    else {return vec2(INFINITY);}\n}\n\n\n// patterns in center of number cards\nvec3 cardPattern(vec2 uv, int number, int suit, int suitColor) {\n    vec3 color = vec3(1.0);\n    vec2 newUV = vec2(INFINITY);\n    \n    //return color;\n    \n    /*\n    if(number==1) {\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.0), 0.5));\n    } else if(number==2) {\n        color = min(color, cardSuit(uv, suit, vec2(0.0,-0.5), 0.25));\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.5), 0.25));\n    } else if(number==3) {\n        color = min(color, cardSuit(uv, suit, vec2(0.0,-0.7), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.0), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.7), 0.2));\n    } else if(number==4) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.25,-0.5), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(-0.25, 0.5), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.25,-0.5), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.25, 0.5), 0.2));\n    } else if(number==5) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.55), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.55), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0,0.0), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, -0.55), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.55), 0.2));\n    } else if(number==6) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.65), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.0), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.65), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, -0.65), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.0), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.65), 0.18));\n    } else if(number==7) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, -0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.0, 0.35), 0.15));\n    } else if(number==8) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, -0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.0, 0.35), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.0, -0.35), 0.15));\n    } else if(number==9) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0, 0.0), 0.12));\n    } else if(number==10) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0, -0.45), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0, 0.45), 0.12));\n    }\n    */\n    \n    if(number==1) {\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.0), 0.5));\n    } else if(number==2) {\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,-0.5), 0.25));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.5), 0.25));\n    } else if(number==3) {\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,-0.7), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.0), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.7), 0.2));\n    } else if(number==4) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.25,-0.5), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.25, 0.5), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.25,-0.5), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.25, 0.5), 0.2));\n    } else if(number==5) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.55), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.55), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0,0.0), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, -0.55), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.55), 0.2));\n    } else if(number==6) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.65), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.0), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.65), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, -0.65), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.0), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.65), 0.18));\n    } else if(number==7) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, -0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0, 0.35), 0.15));\n    } else if(number==8) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, -0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0, 0.35), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0, -0.35), 0.15));\n    } else if(number==9) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0, 0.0), 0.12));\n    } else if(number==10) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0, -0.45), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0, 0.45), 0.12));\n    }\n\n\t\n    if(newUV.x < INFINITY/2.0) {return min(vec3(1.0), cardSuit(newUV, suit, vec2(0.0,0.0), 1.0)); }\n    else {return vec3(1.0);}\n    \n    return color;\n}\n#endif\n\n\n// card front face\nvec4 cardFace(vec2 uv, int number, int suit, int borderTint) {\n    vec3 color = vec3(1);\n    float x = uv.x;\n    float y = uv.y;\n\n    color = vec3(1.0);\n    color = minVec3(color, cardSymbol(uv,number,vec2(-0.75,1.05),0.12, suit<3?1:0));\n    color = minVec3(color, cardSuit(uv,suit,vec2(-0.75,0.6),0.12));\n    color = minVec3(color, cardSymbol(-uv,number,vec2(-0.75,1.05),0.12, suit<3?1:0));\n    color = minVec3(color, cardSuit(-uv,suit,vec2(-0.75,0.6),0.12));\n\n    \n    // draw the face or the suit pattern\n    if( number==11 || number==12 || number==13 ) {\n        color = min(color, cardHead(uv,number,vec2(0.0,0.0),0.9));\n    } else {\n#ifdef COMPILE_PATTERNS\n        color = min(color, cardPattern(uv, number, suit, suit<3?1:0));\n#endif\n    }\n    \n    \n    // border\n    if(x<-CARD_WIDTH+CARD_BORDER_SIZE  || x>CARD_WIDTH-CARD_BORDER_SIZE ||\n       y<-CARD_HEIGHT+CARD_BORDER_SIZE || y>CARD_HEIGHT-CARD_BORDER_SIZE )\n    {\n        if(borderTint==1) {\n            color = vec3(CARD_BORDER_TINT1);\n        } else {\n            color = vec3(CARD_BORDER_TINT2);\n        }\n        \n    }\n    \n    return vec4(color, 1.0);\n}\n\n\n// card back face, based on the original Solitaire desing.\nvec4 cardBack(vec2 uv, int borderTint) {\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    // sky\n    vec4 color = vec4(0.0, 1.0, 1.0, 1.0);\n    // water\n    if(0.5 + 0.025*sin(PI*8.0*x) - y >= 0.0) {\n        color = vec4(0.0, 43.0/255.0, 170.0/255.0, 1.0);\n    }\n    // sand\n    if( -0.3 + 0.045*sin(PI*5.0*x - 0.6214) - y >= 0.0) {\n        color = vec4(1.0, 1.0, 111.0/255.0, 1.0);\n    }\n    // sun\n    if( 1.0 - 25.0*(-0.6 + x)*(-0.6 + x) - 25.0*(-1.0 + y)*(-1.0 + y) >= 0.0 ) {\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    // tree\n    if( multiMin4(0.6-y, 1.05+y, 0.397485+(0.724928-0.25*x)*x + (-0.277479-0.25*y)*y, -0.217087+(-0.723458+0.173611*x)*x + (0.142472+0.173611*y)*y) >= 0.0 ) {\n        color = vec4(110.0/255.0, 61.0/255.0, 56.0/255.0, 1.0);\n    }\n    // leaves\n    if( multiMax4(min(0.23242+(0.208239-8.16327*x)*x+(5.00205-8.16327*y)*y,-0.20324+x*(3.45391+6.25*x)+y*(-2.82657+6.25*y)),min(-4.32311+(-7.66587-8.16327*x)*x+(10.7262-8.16327*y)*y,1.82316+x*(6.44035+6.25*x)+y*(-5.39452+6.25*y)),min(0.0499321+(2.03551-6.25*x)*x+(4.42814-6.25*y)*y,-0.919179+x*(-0.616931+4.0*x)+y*(-0.955262+4.0*y)),min(0.0212551+(-3.72533-4.93827*x)*x+(2.33562-4.93827*y)*y,-0.910767+x*(1.07096+3.30579*x)+y*(-0.18162+3.30579*y))) >= 0.0 ) {\n        color = vec4(42.0/255.0, 222.0/255.0, 61.0/255.0, 1.0);\n    }\n    // border\n    if(x<-CARD_WIDTH+CARD_BORDER_SIZE  || x>CARD_WIDTH-CARD_BORDER_SIZE ||\n       y<-CARD_HEIGHT+CARD_BORDER_SIZE || y>CARD_HEIGHT-CARD_BORDER_SIZE )\n    {\n        if(borderTint==1) {\n            color = vec4(vec3(CARD_BORDER_TINT1), 1.0);\n        } else {\n            color = vec4(vec3(CARD_BORDER_TINT2), 1.0);\n        }\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( texture( iChannel0, vec2(65.5/256.0,0.25)).x > 0.0 ) {\n        \n        //=============================================\n        // if space is pressed : 2D mode\n        \n        vec2 uvScreen = vec2(fragCoord.xy/iResolution.xy);\n        uvScreen = 1.4*(2.0*uvScreen - vec2(1.0))*iResolution.xy/iResolution.y;\n    \n        fragColor = vec4(vec3(0.0,127.0/255.0,9.0/255.0),1.0);\n    \n        for(int i=0; i<14; i++) {\n            vec2 center = vec2( -2.1 + mod(float(i),7.0)*4.2/6.0, (i<7?0.65:-0.65) );\n            vec2 uv = (uvScreen-center)*3.0;\n        \n               if(abs(uv.x)<=CARD_WIDTH && abs(uv.y)<=CARD_HEIGHT) {\n                fragColor = vec4(vec3(1.0), 1.0);\n            }\n        }\n    \n        for(int i=0; i<13; i++) {\n            vec2 center = vec2( -2.1 + mod(float(i),7.0)*4.2/6.0, (i<7?0.65:-0.65) );\n            vec2 uv = (uvScreen-center)*3.0;\n            if(abs(uv.x)<=CARD_WIDTH && abs(uv.y)<=CARD_HEIGHT) {\n                vec3 color = cardFace(uv, i+1, int(mod(float(i),4.0))+1, 1).xyz;\n                fragColor = min(vec4(vec3(color),1.0),fragColor);\n            }\n        }\n        vec2 center = vec2( 2.1, -0.65 );\n        vec2 uv = (uvScreen-center)*3.0;\n        if(abs(uv.x)<=CARD_WIDTH && abs(uv.y)<=CARD_HEIGHT) {\n            vec3 color = cardBack(uv, 1).xyz;\n            fragColor = min(vec4(vec3(color),1.0),fragColor);\n        }\n        \n        \n        \n    } else {\n\t\t\n        //=============================================\n        // if space is not pressed : 3D mode\n    \n    \n    \tfloat time = iTime;\n    \tvec3 uvw = vec3(fragCoord.xy/iResolution.xy, 0.0);\n    \tvec2 scrPixelPos = (2.0*uvw.xy - vec2(1.0))*iResolution.xy/iResolution.x;\n\n    \tvec3 camPos = camPosFun(time);\n    \tvec3 camLookAt = vec3(0.0, 0.0, 0.0);\n    \tvec3 camLookForward = normalize(camLookAt - camPos);\n\n    \tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \tvec3 camLookRight = normalize(cross(camLookForward, worldUp));\n    \tvec3 camLookUp = normalize(cross(camLookRight, camLookForward));\n\n    \t// screen is at distance 1 from eye.\n    \tfloat worldScreenHalfWidth = 0.5;\n    \tvec3 worldPixelPos =\n        \tcamPos\n        \t+ camLookForward\n        \t+ scrPixelPos.x*worldScreenHalfWidth*camLookRight\n        \t+ scrPixelPos.y*worldScreenHalfWidth*camLookUp;\n    \tvec3 worldPixelLookDir = normalize(worldPixelPos-camPos);\n\n    \tIntersection closestInter;\n    \tclosestInter.dist = -1.0;\n\n    \t// objects. Ugly hardcoded pre-processor stuff, but it's the only way I could parameterize the number of cards and still have the shader compile.\n\n#ifdef OBJECT20\n    \tconst int nbObjects = 21;\n#else\n#ifdef OBJECT19\n    \tconst int nbObjects = 20;\n#else\n#ifdef OBJECT18\n    \tconst int nbObjects = 19;\n#else\n#ifdef OBJECT17\n    \tconst int nbObjects = 18;\n#else\n#ifdef OBJECT16\n    \tconst int nbObjects = 17;\n#else\n#ifdef OBJECT15\n    \tconst int nbObjects = 16;\n#else\n#ifdef OBJECT14\n    \tconst int nbObjects = 15;\n#else\n#ifdef OBJECT13\n    \tconst int nbObjects = 14;\n#else        \n#ifdef OBJECT12\n    \tconst int nbObjects = 13;\n#else\n#ifdef OBJECT11\n    \tconst int nbObjects = 12;\n#else\n#ifdef OBJECT10\n        const int nbObjects = 11;\n#else\n#ifdef OBJECT9\n        const int nbObjects = 10;\n#else\n#ifdef OBJECT8\n        const int nbObjects = 9;\n#else\n#ifdef OBJECT7\n        const int nbObjects = 8;\n#else\n#ifdef OBJECT6\n        const int nbObjects = 7;\n#else\n#ifdef OBJECT5\n        const int nbObjects = 6;\n#else\n#ifdef OBJECT4\n        const int nbObjects = 5;\n#else\n#ifdef OBJECT3\n        const int nbObjects = 4;\n#else\n#ifdef OBJECT2\n        const int nbObjects = 3;\n#else\n#ifdef OBJECT1\n        const int nbObjects = 2;\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif        \n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif        \n#endif\n#endif\n    \tIntersection objects[nbObjects];\n\t    \n\t    objects[ 0] = rectangle(camPos, worldPixelLookDir, vec3(0.0,-CARD_HEIGHT,0.0), vec3(0.0,1.0,0.0), vec2(50.0,50.0));\n#ifdef OBJECT1\n        objects[ 1] = fallingCard(time, camPos, worldPixelLookDir, 0.678, 0.0);\n#endif\n#ifdef OBJECT2\n\t    objects[ 2] = fallingCard(time, camPos, worldPixelLookDir, 1.053, 0.25);\n#endif\n#ifdef OBJECT3\n\t    objects[ 3] = fallingCard(time, camPos, worldPixelLookDir, 0.817, 0.5);\n#endif\n#ifdef OBJECT4\n\t    objects[ 4] = fallingCard(time, camPos, worldPixelLookDir, 0.985, 0.75);\n#endif\n#ifdef OBJECT5\n\t    objects[ 5] = fallingCard(time, camPos, worldPixelLookDir, 1.164, 0.33);\n#endif\n#ifdef OBJECT6\n\t    objects[ 6] = fallingCard(time, camPos, worldPixelLookDir, 0.773, 0.66);\n#endif\n#ifdef OBJECT7\n\t    objects[ 7] = fallingCard(time, camPos, worldPixelLookDir, 0.876, 0.15);\n#endif\n#ifdef OBJECT8\n\t    objects[ 8] = fallingCard(time, camPos, worldPixelLookDir, 1.350, 0.30);\n#endif\n#ifdef OBJECT9\n\t    objects[ 9] = fallingCard(time, camPos, worldPixelLookDir, 0.718, 0.45);\n#endif\n#ifdef OBJECT10\n\t    objects[10] = fallingCard(time, camPos, worldPixelLookDir, 0.989, 0.60);\n#endif\n#ifdef OBJECT11\n\t    objects[11] = fallingCard(time, camPos, worldPixelLookDir, 1.261, 0.75);\n#endif\n#ifdef OBJECT112\n\t    objects[12] = fallingCard(time, camPos, worldPixelLookDir, 0.877, 0.90);\n#endif\n#ifdef OBJECT113\n\t    objects[13] = fallingCard(time, camPos, worldPixelLookDir, 1.111, 0.125);\n#endif\n#ifdef OBJECT114\n\t    objects[14] = fallingCard(time, camPos, worldPixelLookDir, 0.871, 0.325);\n#endif\n#ifdef OBJECT115\n\t    objects[15] = fallingCard(time, camPos, worldPixelLookDir, 1.095, 0.625);\n#endif\n#ifdef OBJECT116\n\t    objects[16] = fallingCard(time, camPos, worldPixelLookDir, 0.941, 0.875);\n#endif\n#ifdef OBJECT117\n\t    objects[17] = fallingCard(time, camPos, worldPixelLookDir, 1.123, 0.513);\n#endif\n#ifdef OBJECT118\n\t    objects[18] = fallingCard(time, camPos, worldPixelLookDir, 0.799, 0.791);\n#endif\n#ifdef OBJECT119\n\t    objects[19] = fallingCard(time, camPos, worldPixelLookDir, 0.800, 0.437);\n#endif\n#ifdef OBJECT120\n\t    objects[20] = fallingCard(time, camPos, worldPixelLookDir, 1.110, 0.966);\n#endif        \n\t        \n\t    for(int i=0; i<nbObjects; i++) {\n\t        if(objects[i].dist > 0.0 && (closestInter.dist < 0.0 || objects[i].dist < closestInter.dist)) {\n\t          closestInter = objects[i];\n\t        }\n\t    }\n\t    \n        // if a collision occured, get color depending on material.\n\t    if(closestInter.dist > 0.0) {\n\t        if(closestInter.material == MATERIAL_UVW){\n\t            fragColor = vec4( closestInter.uvw, 1.0 );\n\t        } else if(closestInter.material == MATERIAL_FLOOR){\n\t            fragColor = vec4( 0.7*vec3(0.0,127.0/255.0,9.0/255.0), 1.0 );\n\t        } else if(closestInter.material == MATERIAL_NORMAL) {\n\t            fragColor = vec4( closestInter.normal, 1.0 );\n\t        } else if(closestInter.material == MATERIAL_CARD_BACK) {\n\t            if( mod( EPSILON + closestInter.uvw.z ,2.0/CARD_DENSITY) <= 1.0/CARD_DENSITY ) {\n\t                fragColor = cardBack( vec2(-closestInter.uvw.x, closestInter.uvw.y) , 1 );\n\t            } else {\n\t                fragColor = cardBack( vec2(-closestInter.uvw.x, closestInter.uvw.y) , 2 );\n\t            }\n\t            \n\t        } else if(closestInter.material == MATERIAL_CARD_FACE) {\n\t            if( mod( -EPSILON + closestInter.uvw.z ,2.0/CARD_DENSITY) <= 1.0/CARD_DENSITY ) {\n\t                fragColor = cardFace(closestInter.uvw.xy, closestInter.info1, closestInter.info2, 1);\n\t            } else {\n\t                fragColor = cardFace(closestInter.uvw.xy, closestInter.info1, closestInter.info2, 2);\n\t            }\n\t        } else if (closestInter.material == MATERIAL_CARD_SIDE_XM ||\n\t                   closestInter.material == MATERIAL_CARD_SIDE_XP ||\n\t                   closestInter.material == MATERIAL_CARD_SIDE_YM || \n\t                   closestInter.material == MATERIAL_CARD_SIDE_YP)\n\t        {\n\t            if( mod( closestInter.uvw.z ,2.0/CARD_DENSITY) <= 1.0/CARD_DENSITY ) {\n\t                fragColor = vec4(vec3(CARD_BORDER_TINT1), 1.0);\n\t            } else {\n\t                fragColor = vec4(vec3(CARD_BORDER_TINT2), 1.0);\n\t            }\n\t        }\n            \n\t    } else {\n\t        fragColor = vec4( vec3(0.0,127.0/255.0,9.0/255.0), 1.0);\n\t    }\n    \n    }\n    \n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2102, 2562, 2609, 2609, 2636], [2637, 2637, 2693, 2693, 2728], [2729, 2729, 2794, 2794, 2837], [2838, 2838, 2912, 2912, 2963], [2964, 2964, 3011, 3011, 3038], [3039, 3039, 3095, 3095, 3130], [3131, 3131, 3196, 3196, 3239], [3240, 3240, 3269, 3269, 3326], [3327, 3327, 3371, 3371, 3409], [3410, 3410, 3462, 3462, 3512], [3513, 3513, 3573, 3573, 3635], [3636, 3636, 3704, 3704, 3778], [3779, 3779, 3855, 3855, 3941], [3942, 3942, 4034, 4034, 4144], [4271, 4271, 4291, 4291, 4303], [4305, 4305, 4333, 4333, 4415], [4417, 4417, 4498, 4498, 5081], [5083, 5138, 5203, 5203, 5899], [5901, 5901, 5971, 5971, 6067], [6070, 6119, 6192, 6192, 6286], [6289, 6367, 6455, 6455, 18314], [18316, 18341, 18415, 18415, 23130], [23133, 23172, 23229, 23229, 24645], [24647, 24682, 24739, 24739, 29979], [38831, 38850, 38912, 38912, 39972], [39975, 40034, 40074, 40074, 41720], [41724, 41724, 41781, 41781, 49923]], "test": "untested"}
{"id": "MlXXWB", "name": "Logistic Map", "author": "metabog", "description": "Hmm...", "tags": ["chaos", "logisticmap"], "likes": 0, "viewed": 111, "published": "Public", "date": "1439336374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Solving a lorenz attractor with different params at each pixel\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distanceThresh = 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x = uv.x-0.3;\n    float r  = (uv.x)*iTime;\n\tfloat x = uv.y;\n    //iterate at this pixel for a while and solve lorenz oscillator equations\n    float mean = 0.0;\n    \n    for(int i = 0; i <22; i++)\n    {\n\t\tx = r*x*(1.0-x);\n        mean+=x;\n    }\n    mean=mean/12.0;\n    \n   float variance = 0.0;\n    x = uv.y*sin(iTime);\n     for(int i = 0; i <11; i++)\n    {\n\t\tx = r*x*(1.0-x);\n        float dif = mean -x;\n        dif = dif*dif;\n        variance+=dif;\n    }\n    variance = variance/12.0;\n    \n    \n    float dis = x;\n    \n    vec3 col;\n\n         col = hsv2rgb(vec3(dis,1.0,1.0)); \n \n        \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 88, 88, 419], [421, 421, 443, 443, 612], [644, 644, 701, 701, 1384]], "test": "untested"}
{"id": "MlXXWj", "name": "dlab", "author": "dmmn", "description": "dlab", "tags": ["dlab"], "likes": 1, "viewed": 86, "published": "Public", "date": "1439672119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat ratio;\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b ) {\n  return length(max(abs(p)-b,0.0));\n}\n\nmat4 matRotate( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t     0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 matTranslate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nfloat map(vec3 p) {\n    float dist = 100.;\n    \n    mat4 rotationMatrix = matRotate(vec3(iTime * .2, iTime * 2., iTime * .3));\n    p = (vec4(p, 0.) * matInverse(rotationMatrix)).xyz;\n    \n    dist = sdSphere(p, 1.);\n    dist = mix(dist, sdTorus(p, vec2(1., .3)), clamp(-ratio, 0., 1.));\n    dist = mix(dist, udBox(p, vec3(.5, 1., .5)), clamp(ratio, 0., 1.));\n    \n    return dist;\n}\n\nvec3 calcNormal (vec3 p) {\n\tvec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3( \tmap(p + e.xyy) - map(p - e.xyy),\n                            map(p + e.yxy) - map(p - e.yxy),\n                          \tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ratio = cos(iTime * 2.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = 2. * vec3(0., 0., -2.);\n    \n    vec3 rd = normalize(vec3(p.x, p.y, 1.));\n    //rd.xz *= ro.xz;\n    //vec3 direction = vec3(cos(iTime + PI * .5), 0.0, sin(iTime + PI * .5));\n    //rd = normalize(direction + vec3( cos(iTime) * p.x, p.y, sin(iTime) * p.x ));\n\n    vec3 col = vec3(1.);\n    \n    float tmax = 100.;\n    float h = 1.0;\n    float t = 0.0;\n    \n    for(int i = 0; i < 16; i++) {\n        if (h < 0.00001 || h > tmax) break;\n        h = map( ro + rd * t);\n        t += h;\n    }\n    \n    if (t < tmax) {\n        //col = calcNormal(ro + rd * t);\n        col = texture(iChannel0, -uv).rgb;\n        col = mix(col, texture(iChannel1, -uv).rgb, clamp(-ratio, 0., 1.));\n        col = mix(col, texture(iChannel2, -uv).rgb, clamp(ratio, 0., 1.));\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 93, 93, 117], [119, 119, 152, 152, 217], [219, 219, 250, 250, 288], [290, 290, 321, 321, 706], [708, 708, 756, 756, 872], [874, 874, 904, 904, 1154], [1156, 1156, 1175, 1175, 1538], [1540, 1540, 1566, 1566, 1781], [1783, 1783, 1838, 1838, 2789]], "test": "untested"}
{"id": "MtfXWl", "name": "PT V - R, T, S", "author": "Piperoman", "description": "Test to rotate, translate and scale in 2D", "tags": ["test", "tutorial", "nolook"], "likes": 4, "viewed": 134, "published": "Public", "date": "1440503761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n// Description: COORDINATE TRANSFORMATIONS: ROTATION, TRANSLATION, SCALATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n////////////////////////////////////////////\n// Function declaration\n////////////////////////////////////////////\nvoid rotateCoordinateSystem(inout vec2 q, in vec2 r, in float angle);\nvoid drawSmoothAxis(inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor);\nvoid drawSmoothCircle(inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside, in vec3 color);\nvoid rotateCoordinateSystem(inout vec2 csR, in vec2 cs, in float angle);\nvoid translateCoordinateSystem(inout vec2 csT, in vec2 cs, in vec2 translation);\nvoid scaleCoordinateSystem(inout vec2 csS, in vec2 cs, in vec2 scale);\n\n////////////////////////////////////////////\n// Function implementation\n////////////////////////////////////////////\n\n/**\n* Function to rotate r to q, angle\n* q is the rotated coordinate system proyection sin & cos\n*/\nvoid rotateCoordinateSystem(inout vec2 csR, in vec2 cs, in float angle)\n{\n\tcsR.x =   cos(angle) * cs.x + sin(angle) * cs.y;\n\tcsR.y = - sin(angle) * cs.x + cos(angle) * cs.y;\n}\nvoid translateCoordinateSystem(inout vec2 csT, in vec2 cs, in vec2 translation)\n{\n\tcsT.x = cs.x - translation.x;\n\tcsT.y = cs.y - translation.y;\n}\nvoid scaleCoordinateSystem(inout vec2 csS, in vec2 cs, in vec2 scale)\n{\n\tcsS.x = scale.x * cs.x;\n\tcsS.y = scale.y * cs.y;\n}\n/**\n* Function that draws an (anti-aliased) grid of coordinate system\n*/\nvoid drawSmoothAxis(inout vec3 pixel, in vec2 r, in vec3 axesColor, in vec3 gridColor)\n{\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) \n    {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n        pixel = mix(pixel, gridColor, ret * 0.01 );\n\t}\n\t// Draw the axes\n    ret = 0.0;\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\t\n    pixel = mix(pixel, axesColor, ret * 0.4 );\n}\n\nvoid drawSmoothCircle(inout vec3 pixel, in vec2 r, in vec2 center, in float radius, in float lineThickness, in bool inside, in vec3 color) \n{\n    float value;\n    if(inside)\n    {\n        // Inside a circle\n        value = 1.0 - smoothstep( radius-lineThickness, radius+lineThickness, length(r-center));\n    }\n    else\n    {\n        // Out of a circle\n        value = smoothstep( radius-lineThickness, radius+lineThickness, length(r-center));\n    }\n    pixel = mix(pixel, color, value);\n}\n// initPoint (x0, y0)\n// size (width, height)\nvoid drawSmoothRectangle(inout vec3 pixel, in vec2 r, in vec2 center, in vec2 size, in float lineThickness, in bool inside, in vec3 color) \n{\n    vec2 initPoint;\n    initPoint.x = center.x - size.x/2.0;\n    initPoint.y = center.y - size.y/2.0;\n    vec2 bottomRight;\n    bottomRight.x = initPoint.x + size.x;\n    bottomRight.y = initPoint.y + size.y;\n    float value;\n\tvalue = smoothstep(initPoint.x-lineThickness, initPoint.x+lineThickness, r.x);\n\tvalue *= smoothstep(initPoint.y-lineThickness, initPoint.y+lineThickness, r.y);\n\tvalue *= 1.0 - smoothstep(bottomRight.y-lineThickness, bottomRight.y+lineThickness, r.y);\n\tvalue *= 1.0 - smoothstep(bottomRight.x-lineThickness, bottomRight.x+lineThickness, r.x);\n    \n    pixel = mix(pixel, color, value);\n}\n\n// Blue static\n// Red rotate\n// Green translate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 cs =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\t// C.S\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\t// Basic variables\n    vec3 blackColor = vec3(0.0);\n    vec3 grayColor = vec3(0.5);\n    vec3 whiteColor = vec3(1.0);\n    vec3 redColor = vec3(1.0, 0.0, 0.0);\n    vec3 greenColor = vec3(0.0, 1.0, 0.0);\n    vec3 blueColor = vec3(0.0, 0.0, 1.0);\n    vec3 purpleColor = vec3(0.4, 0.05, 0.5);\n\t\n\tvec3 pixel = whiteColor;\n\t\n\tvec2 csR = cs;\t\t// C.S rotated\n    vec2 csT = cs; \t\t// C.S translated\n    vec2 csS = cs; \t\t// C.S scaled\n    \n\tfloat angle = 0.2*PI*sin(iTime);\n    float scaleFactor = 2.0 * (PI/2.0 + sin(iTime) );\n    vec2 translation = vec2(0.5*sin(iTime), 0.0);\n    \n    rotateCoordinateSystem(csR, cs, angle);\n    translateCoordinateSystem(csT, cs, translation);\n    scaleCoordinateSystem(csS, cs, vec2(scaleFactor, scaleFactor));\n    \n    //vec2 tq = q + t;\n\t\n    // Axis static and rotates\n    drawSmoothAxis(pixel, cs, blueColor, blueColor);\t\t// Axis without rotate\n    drawSmoothAxis(pixel, csR, redColor, redColor);\t\t\t// Axis angle-rotated\n\t\n\t// Circles, Normal, rotated, translated, and scaled\n    drawSmoothCircle(pixel, cs, vec2(-1.1,0.3), 0.25, 0.05, true, blueColor);\n    drawSmoothCircle(pixel, csR, vec2(-1.1,0.3), 0.2, 0.01, true, redColor);\n    drawSmoothCircle(pixel, csT, vec2(-1.1,0.3), 0.15, 0.01, true, greenColor);\n    drawSmoothCircle(pixel, csS, vec2(0.0,0.0), 0.15, 0.001, true, grayColor);\n    \n    // Circles, Normal, rotated, translated, and scaled\n    drawSmoothRectangle(pixel, cs, vec2(0.5, 0.5), vec2(0.3, 0.3), 0.05, true, blueColor);\n    drawSmoothRectangle(pixel, csR, vec2(0.5, 0.5), vec2(0.22, 0.22), 0.01, true, redColor);\n    drawSmoothRectangle(pixel, csT, vec2(0.5, 0.5), vec2(0.22, 0.22), 0.01, true, greenColor);\n    drawSmoothRectangle(pixel, csS, vec2(0.5, 0.0), vec2(0.4, 0.4), 0.001, true, grayColor);\n\t\t\n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1042, 1142, 1215, 1215, 1317], [1318, 1318, 1399, 1399, 1463], [1464, 1464, 1535, 1535, 1587], [1588, 1661, 1749, 1749, 2228], [2230, 2230, 2371, 2371, 2718], [2719, 2765, 2906, 2906, 3519], [3521, 3569, 3626, 3626, 5587]], "test": "untested"}
{"id": "MtlXDs", "name": "black goo", "author": "stef_levesque", "description": "based on \"Deformed\" by xbe", "tags": ["procedural", "3d", "raymarching", "noise"], "likes": 6, "viewed": 183, "published": "Public", "date": "1440777642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////\n// XBE\n// Deformed\n// Sphere + Plane + Noise\n//\n\nvec4 spect;\n\n// Value Noise by IQ\n#define USE_PROCEDURAL\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat fbm(vec3 uv)\n{\n\tfloat f;\n\tmat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\tf  = 0.5000*noise( uv ); uv = m*uv*2.01;\n\tf += 0.2500*noise( uv ); uv = m*uv*2.02;\n\tf += 0.1250*noise( uv ); uv = m*uv*2.03;\n\tf += 0.0625*noise( uv ); uv = m*uv*2.01;\n//\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// Distance Functions for Raymarching\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat map( in vec3 pos )\n{\n\tfloat deform = spect.x*fbm( pos + spect.y*fbm((spect.z+5.)*pos));\n\tfloat d = opU( sdPlane(pos+vec3(0.,0.5,0.)) + 3.14*deform,\n\t\tsdSphere( pos, 0.35 ) - deform);\n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\n// Raymarching\nbool raymarch(vec3 origin, vec3 dir, out float dist, out vec3 norm)\n{\n\tfloat epsilon = 0.003;\n\tfloat maxdist = 10.0;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n\tdist = -1.0;\n\tfor (int steps=0; steps < 60; steps++)\n\t{\n\t\tif ( ( abs(delta) < epsilon ) || (marched > maxdist) ) continue;\n\t\tmarched += delta;\n\t\tdelta = map(origin + marched * dir);\n\t}\n\tbool res = false;\n\tif (marched < maxdist)\n\t{\n\t\tnorm = calcNormal(origin + marched * dir);\n\t\tdist = marched;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tvec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = vec3(0.0);\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n//\t\tbrdf += 2.20*amb*vec3(0.20,0.22,0.26)*ao;\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dt = iTime * 0.015;\n    vec2 uv = vec2(0.0+dt,0.75+dt);\n    spect = 1.5*(texture(iChannel1, uv));\n    spect.w = texture(iChannel1, vec2(0.5+dt,0.75+dt)).x;\n\t//spect.x = 1.5*(texture(iChannel1, vec2(0.0+dt,.0)).x+texture(iChannel1, vec2(0.1,.0)).x+texture(iChannel1, vec2(0.2,.0)).x)/3.0;\n\t//spect.y = 1.*texture(iChannel1, vec2(0.5+dt,.0+dt)).x;\n\t//spect.z = 1.5*texture(iChannel1, vec2(0.75+dt,.0)).x;\n\t//spect.w = texture(iChannel1, vec2(0.5+dt,.0)).x;\n\n\tfloat Time = 0.45*(15.0 + iTime)/* - 2.*spect.w*/;\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3( 4.0*cos(Time+45.), 0.5, 2.0*sin(Time) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n    //col = vec3(1) - col;\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 871, 891, 891, 1222], [1224, 1262, 1297, 1297, 1323], [1325, 1325, 1350, 1350, 1365], [1367, 1367, 1400, 1400, 1429], [1431, 1431, 1457, 1457, 1635], [1637, 1637, 1669, 1669, 1850], [1852, 1867, 1936, 1936, 2359], [2361, 2361, 2403, 2403, 2706], [2708, 2708, 2747, 2747, 3952], [3954, 3954, 4011, 4011, 5075]], "test": "untested"}
{"id": "MtlXWj", "name": "Attack of the Space Slugs", "author": "tsherif", "description": "Took the terrain from the SIGGRAPH 2015 Shadertoy workshop and added some flying slugs to it.\n\nClick and drag to look around.", "tags": ["raymarching", "siggraph", "slugs"], "likes": 7, "viewed": 1763, "published": "Public API", "date": "1440160232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sinNoise(in vec2 pos) {\n  return 0.5 * (sin(pos.x) + sin(pos.y));\n}\n\nconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\nfloat mapH(in vec3 pos) {\n    float h = 0.0;\n    vec2 q = pos.xz * 0.5;\n    float s = 0.5;\n    for (int i = 0; i < 12; i++){\n        h += s * sinNoise(q);\n        s *= 0.49;\n        q = m2 * q * 1.7;\n    }\n    \n    return pos.y - h * 3.0;\n}\n\nfloat mapS(in vec3 pos) {\n    pos.z -= iTime * 2.0;\n    vec3 c = mod(pos, 10.0) - 4.0;\n    c.y = pos.y - 6.0 + sin(iTime * 2.0 + pos.z * 2.5 + pos.x);\n    float r = 1.0;\n    float d = length(c) - r;\n    \n    d += 0.1 * sin(pos.x * 10.0 + iTime) * sin(pos.y * 10.0 + iTime) * sin(pos.z * 10.0 + iTime);\n    \n    return d;\n}\n\nfloat map(in vec3 pos) {\n    return min(mapH(pos), mapS(pos));   \n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 nor;\n    vec2 e = vec2(0.01, 0.0);\n    \n    nor.x = map(pos + e.xyy) - map(pos - e.xyy);\n    nor.y = map(pos + e.yxy) - map(pos - e.yxy);\n    nor.z = map(pos + e.yyx) - map(pos - e.yyx);\n    \n    return normalize(nor);\n}\n\nfloat calcShadow(vec3 ro, vec3 rd) {\n    float res = 1.0;\n    \n    float t = 0.1;\n    \n    for (int i = 0; i < 16; i++) {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        res = min(res, 10.0 * max(h, 0.0) / t);\n        \n        if (res < 0.1) break;\n        \n        t += h;\n    }\n    \n    return max(res, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    pos = pos * 2.0 - 1.0;\n    mouse = mouse * 2.0 - 1.0;\n    \n    pos.x *= iResolution.x / iResolution.y;\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.7, 0.8, 0.9);    \n    vec3 ro = vec3(0.0, 2.0, 1.0 * -iTime);\n    vec3 rd = vec3(pos, -1.0);\n    \n    if (iMouse.x > 0.0) {\n    \trd.xy += mouse;\n    }\n    \n    rd = normalize(rd);\n    \n    color *= 1.0 - 0.5 * rd.y;\n\n    \n    float tmax = 80.0;\n    float t = 0.0;\n    \n    for (int i = 0; i < 256; i++) {\n      vec3 pos = ro + rd * t;\n        float h = map(pos);\n        if (h < 0.001 || t > tmax) break;\n        t += h * 0.5;\n    }\n    \n    vec3 light = normalize(vec3(1.0,1.0,0.5));\n    \n    if (t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        float sha = calcShadow(pos + nor * 0.1, light);\n        vec3 spec = vec3(0.0);\n        \n        vec3 mat;\n        if (pos.y > 3.0) {\n            mat = vec3(1.0, 0.7, 0.6);\n            spec = vec3(1.0) * pow(max(dot(-rd, reflect(-light, nor)), 0.0), 100.0);\n        } else {\n            mat = vec3(0.5, 0.2, 0.1);\n        \tmat = mix(mat, vec3(0.2, 0.5, 0.1), smoothstep(0.7, 0.9, nor.y));\n        }\n        \n        vec3 diff = max(0.0, dot(light, nor)) * vec3(1.0) * sha;\n        color = mat * (diff + spec);\n        \n        float fog = exp(-0.001 * t * t);\n        color = mix(vec3(0.6, 0.7, 0.8), color, fog);\n    }\n    \n    color = sqrt(color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 73], [119, 119, 144, 144, 359], [361, 361, 386, 386, 683], [685, 685, 709, 709, 752], [754, 754, 784, 784, 1014], [1016, 1016, 1052, 1052, 1348], [1350, 1350, 1407, 1407, 2961]], "test": "untested"}
{"id": "MtsSRf", "name": "Siggraph'15 Workshop", "author": "iq", "description": "This is the full code for the 90 minutes workshop on Shadertoy creation held last week at Siggraph. Thanks to everybody who attended!", "tags": ["3d", "raymarching", "tutorial", "course", "siggraph"], "likes": 47, "viewed": 5684, "published": "Public API", "date": "1439835376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Beautypi/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nfloat cosNoise( in vec2 p )\n{\n    return 0.5*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {\n        h += s*cosNoise( q ); \n        q = m2*q*0.85; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.2*h;\n    }\n    h *= 2.0;\n    \n    float d1 = pos.y - h;\n    \n    // rings\n    vec3 r1 = mod(2.3+pos+5.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h;// + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float d2 = sdTorus( r1.xzy, vec2(1.0,0.05) );\n    \n    \n    return smin( d1, d2, 1.0 );\n}\n\nfloat mapH( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = 0.5;\n    for( int i=0; i<12; i++ )\n    {\n        h += s*cosNoise( q ); \n        q = m2*q*0.85; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.2*h;\n    }\n    h *= 3.0;\n    \n    float d1 = pos.y - h;\n    \n    // rings\n    vec3 r1 = mod(2.3+pos+5.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h;// + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float d2 = sdTorus( r1.xzy, vec2(1.0,0.05) );\n    \n    \n    return smin( d1, d2, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0) * 0.001;\n    \n    return normalize( e.xyy*mapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx ) );\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        res = min( res, max(h,0.0)*164.0/t );\n        if( res<0.001 ) break;\n        t += h*0.5;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = (-iResolution.xy + 2.0* fragCoord.xy) / iResolution.y;\n    \n    float ani = -20.0 + iTime + iMouse.x*0.1;\n    \n    // ray\n    vec3 ro = vec3( 0.0, 2.0, -ani*0.5 );\n    \n    float roll = 0.2*sin(0.1*ani);\n    q = mat2( cos(roll), -sin(roll), sin(roll), cos(roll) ) * q;\n    \n    vec3 rd = normalize( vec3(q-vec2(-0.4,0.4),-2.0) );\n    \n    vec3 col = vec3( 0.7, 0.8, 1.0 );\n    col *= 1.0 - 0.5*rd.y;\n\n    // raymarcher\n    float tmax = 120.0;\n    float t = 0.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h*0.5;\n    }\n\n    vec3 light = normalize( vec3( 1.0, 0.5, -1.0) );\n    // hit\n    if( t<tmax )\n    {\n        // shade and light\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        float bak = clamp( dot(nor,normalize(-vec3(light.x,0.0,light.z))), 0.0, 1.0 );\n        float dif = clamp( dot(nor,light), 0.0, 1.0 );\n        float sha =softShadows( pos+nor*.01, light );\n        vec3 lig = vec3(2.0,1.5,1.0)*dif*1.5*sha;\n             lig += vec3(0.2,0.3,0.4)*max(nor.y,0.0)*0.9;\n             lig += vec3(0.1,0.1,0.1)*bak*0.5;\n        vec3 mate = vec3(0.3,0.3,0.3)*0.5;\n        mate = mix( mate, vec3(0.2,0.15,0.1)*0.73, smoothstep( 0.7,0.9,nor.y) );\n        mate *= 0.5 + texture( iChannel0, 0.5*pos.xz ).x*1.0;\n \n        col = mate * lig;\n\n        float fog = exp( -0.0015*t*t );\n        col *= fog;\n        col += (1.0-fog)*vec3(0.5,0.6,0.7);\n    }\n\n    float sun = clamp( dot(rd,light), 0.0, 1.0 );\n    col += vec3(1.0,0.8,0.6)*0.4*pow(sun,16.0);\n    col += vec3(1.0,0.8,0.6)*0.3*pow(sun,8.0);\n    \n    col = sqrt( col );\n    \n    col *= 0.5 + 0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.2);\n    \n    col = smoothstep( 0.0, 1.0, col );\n\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.25 );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsSRf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 99, 128, 128, 170], [236, 236, 269, 269, 322], [325, 325, 366, 366, 455], [457, 457, 483, 483, 975], [977, 977, 1004, 1004, 1497], [1499, 1499, 1531, 1531, 1734], [1736, 1736, 1781, 1781, 2044], [2047, 2047, 2104, 2104, 4032]], "test": "untested"}
{"id": "MtsXDj", "name": "Relativistic lattice", "author": "makc", "description": "In case you wanted to know how does the space look like when you move really fast...", "tags": ["rocket", "relativity"], "likes": 15, "viewed": 409, "published": "Public", "date": "1439933388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shadertoy version of http://makc.github.io/misc/relativity-1.html\n\n// What you are looking at here is the giant cubic lattice with the\n// side of ten light seconds. Click or hold the mouse button to pick\n// rocket velocity (0 at the bottom, 0.95c at the top) and the camera\n// direction. The result is what the rocket pilot would actually see\n// in his(her) window - also known as relativistic aberration. Funny\n// shit happens at high velocities, e g you begin to see objects' far\n// side - for visual explanation, see 2nd video here:\n// http://people.physics.anu.edu.au/~cms130/TEE/site/tee/learning/aberration/aberration.html\n\n// Ok, to the code...\n\n// butt first - the rocket from https://www.shadertoy.com/view/ltjGD1\n\nfloat pi = 3.14159265359;\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nvec2 frot(const float a, in vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n    return v;\n}\n\nvoid rotate(const float a, inout vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat dfRocketBody(vec3 p)\n{\n    vec3 p2 = p;\n    vec3 pWindow = p;\n    \n    angularRepeat(pi*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, frot(pi*-.125, p2.xz+vec2(-.7,0)).y);\n    d = max(d, frot(pi*-.25*.75, p2.xz+vec2(-0.95,0)).y);\n    d = max(d, frot(pi*-.125*.5, p2.xz+vec2(-0.4,0)).y);\n    d = max(d, frot(pi*.125*.25, p2.xz+vec2(+0.2,0)).y);\n    d = max(d, frot(pi*.125*.8, p2.xz+vec2(.55,0)).y);\n    d = max(d,-.8-p.x);\n    d -= .5;\n    \n    pWindow -= vec3(.1,.0,.0);\n    angularRepeat(pi*.25,pWindow.xy);\n    pWindow -= vec3(.17,.0,.0);\n    d = min(d,mBox(pWindow,vec3(.03,.2,.55)));\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    vec3 pFins = p;\n    angularRepeat(pi*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.2)*.5,.0,.0);\n    rotate(pi*.25,pFins.xz);\n    float scale = 1.0-pFins.z*.5;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat df(vec3 p)\n{\n    float proxy = mBox(p,vec3(2.5,.8,.8));\n    if (proxy>1.0)\n    \treturn proxy;\n    return min(dfRocketBody(p),dfRocketFins(p));\n}\n\nvec3 nf(vec3 p)\n{\n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\n\nvoid rocket (inout vec3 color, in vec3 pos, in vec3 dir) {\n    \n    float dist,tdist = .0;\n    \n    for (int i=0; i<100; i++)\n    {\n     \tdist = df(pos);\n       \tpos += dist*dir;\n        tdist+=dist;\n        if (dist<0.000001||dist>20.0)break;\n    }\n\n    vec3 materialColor = vec3(.0);\n    vec3 orangeColor = vec3(1.5,.9,.0);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n    \n    \n    float r = pow (length(pos.yz), 1.5);\n\n    vec3 normal = nf(pos);\n    \n    if (dfRocketBody(pos)<dfRocketFins(pos))\n    {\n        if (pos.x<-.85)\n            if (pos.x<-1.30)\n                materialColor = orangeColor + vec3(0.03 / r);\n            else\n                materialColor = vec3(.9,.1,.1);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.6,.1,.1);\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.9,.1,.1);\n        if (length (pos - 0.1 * vec3(0.0, normal.yz)) > length (pos)) { \n\n            materialColor -= vec3(1.5,.9,.0) * min(0.0, pos.x + 1.3) / r;\n        }\n    }\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    if (dist<1.0) color = ao * materialColor;\n}\n\n// second, the beams from https://www.shadertoy.com/view/MllXDB\n\nconst float beam_half_side = 0.1, cell_side = 10.0, beam_side = beam_half_side * 2.0;\n\nvoid beams (inout vec3 color, in vec3 p, in vec3 d) {\n    p = mod (p + cell_side * 0.5, cell_side);\n    vec3 ad = abs(d), sd = sign(d), normal = vec3(0.0);\n    vec3 offsets = (0.5 * cell_side - beam_half_side) * (sd + 1.0) + beam_half_side;\n    vec2 test;\n    float closest_hit_distance = 1e2 * cell_side, ray_distance, step = cell_side / max (ad.x, max (ad.y, ad.z));\n    vec3 p1 = p, p2, dist;\n    float p1_to_p_distance = 0.0;\n    for (int i = 0; i < 10; i++) {\n        dist = (offsets - mod (p1, cell_side)) / d;\n        dist += 0.5 * (1.0 - sign (dist)) * cell_side / ad;\n\n        p2 = p1 + d * dist.x;\n        ray_distance = p1_to_p_distance + dist.x;\n        if (closest_hit_distance > ray_distance) {\n            test = mod (p2.yz + beam_half_side, cell_side);\n            if ((test.x < beam_side) || (test.y < beam_side)) {\n                closest_hit_distance = ray_distance;\n                normal = vec3 (-sd.x, 0.0, 0.0);\n            }\n        }\n\n        p2 = p1 + d * dist.y;\n        ray_distance = p1_to_p_distance + dist.y;\n        if (closest_hit_distance > ray_distance) {\n            test = mod (p2.xz + beam_half_side, cell_side);\n            if ((test.x < beam_side) || (test.y < beam_side)) {\n                closest_hit_distance = ray_distance;\n                normal = vec3 (0.0, -sd.y, 0.0);\n            }\n        }\n\n        p2 = p1 + d * dist.z;\n        ray_distance = p1_to_p_distance + dist.z;\n        if (closest_hit_distance > ray_distance) {\n            test = mod (p2.xy + beam_half_side, cell_side);\n            if ((test.x < beam_side) || (test.y < beam_side)) {\n                closest_hit_distance = ray_distance;\n                normal = vec3 (0.0, 0.0, -sd.z);\n            }\n        }\n\n        p1 += d * step;\n        p1_to_p_distance += step;\n    }\n\n    color = (vec3 (dot (normal, vec3(0.1, 0.2, 0.3))) * 0.5 + 0.5) * (cell_side / closest_hit_distance);\n\n    p1 = p + closest_hit_distance * d;\n    color *= mod (floor ((p1.x + p1.y + p1.z) * 4.0), 2.0) * 0.5 + 0.5;\n}\n\n// third, camera utility - this calculates ray direction in spaceship frame\n\nvec3 ray_dir (float fov, vec2 size, vec2 pos, float angle) {\n    vec2 xy = pos - 0.5 * size;\n\n    float cot_half_fov = tan ((90.0 - 0.5 * fov) * 0.01745329252);\t\n    float z = size.y * 0.5 * cot_half_fov;\n\n    vec3 dir = vec3 (xy, -z);\n    mat3 rot = mat3 (\n        vec3 (cos (angle), 0.0, -sin (angle)),\n        vec3 (        0.0, 1.0,          0.0),\n        vec3 (sin (angle), 0.0,  cos (angle))\n    );\n\n    dir = rot * dir;\n\n    #ifdef tilted\n    dir = vec3 (0.7071*(dir.x + dir.y), 0.7071*(dir.x - dir.y), dir.z);\n    #endif\n\n    return normalize (dir);\n}\n\n// stuff to show the speed (by unknown author at glslsandbox.com)\n\nfloat extract_bit(float n, float b);\nfloat sprite(float n, float w, float h, vec2 p);\nfloat digit(float num, vec2 p);\n\n// combining the shit together...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = 2.0 * pi * iMouse.x / iResolution.x;\n\n    // map 0 .. 1 to 0 .. ~0.95 with more detail in upper end\n    float velocity = (1.0 - exp (-pow (iMouse.y / iResolution.y, 0.7))) / 0.665;\n    \n    if (length (iMouse) == 0.0) {\n        float t = iTime;\n        if (iResolution.y < 200.0) t-= 10.0;\n        angle = -0.2 * t;\n        velocity = 0.85;\n    }\n    \n    // 1st, calculate how much distance did the spaceship travel in lattice frame\n    // in units where c = 1 we have:\n    // spaceship time ^2 - 0 ^2 = distant time ^2 - covered distance ^2\n    // and\n    // covered distance = velocity * distant time\n    // ergo...\n    float inverse_root = inversesqrt (1.0 - velocity * velocity);\n    float covered_dist = inverse_root * velocity * iTime;\n\n    // 2nd, pick the ray in spaceship frame\n    vec3 ray = ray_dir (75.0, iResolution.xy, fragCoord.xy, angle);\n\n    // 3rd, transform the ray to distant observer frame (aka Lorentz transformation)\n    // since the ray is normalized, its length divided by c is 1\n    vec3 transformed_ray = vec3 (ray.xy,\n         inverse_root * (ray.z + velocity));\n    \n    vec3 pos = vec3 (0.0, 0.0, -covered_dist);\n    transformed_ray = normalize (transformed_ray);\n\n    beams (fragColor.xyz, pos, transformed_ray);\n\n    // now let's add the rocket on top of it\n    pos.x = -5.0 * cos (angle);\n    pos.y =  2.1;\n    pos.z =  5.0 * sin (angle);\n    rotate (.5 * pi, ray.zx);\n    \n    vec3 r_color = vec3 (0.0);\n    rocket (r_color, pos, ray);\n    \n    if (length (r_color) > 0.0) {\n        fragColor.xyz = r_color;\n    }\n    \n    // finally, display the speed\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor.xyz += vec3 (\n\t\tsprite(2., 3., 5., floor (uv * vec2(64.0, 32.0) + vec2( 11.0 -64.0, -1.0))) +\n\t\tdigit(velocity * 10.0, floor (uv * vec2(64.0, 32.0) + vec2( 8.0 -64.0, -1.0))) +\n\t\tdigit(velocity * 100.0, floor (uv * vec2(64.0, 32.0) + vec2( 4.0 -64.0, -1.0)))\n    );\n}\n\n//returns 0/1 based on the state of the given bit in the given number\nfloat extract_bit(float n, float b)\n{\n\tn = floor(n);\n\tb = floor(b);\n\tb = floor(n/pow(2.,b));\n\treturn float(mod(b,2.) == 1.);\n}\n\nfloat sprite(float n, float w, float h, vec2 p)\n{\n\tfloat bounds = float(all(lessThan(p,vec2(w,h))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn extract_bit(n,(2.0 - p.x) + 3.0 * p.y) * bounds;\n}\n\n//3x5 digit sprites stored in \"15 bit\" numbers\n/*\n     111\n       001\n  -> 111  -> 111001111100111 -> 29671\n       100\n     111\n*/\n\nfloat c_0 = 31599.0;\nfloat c_1 = 9362.0;\nfloat c_2 = 29671.0;\nfloat c_3 = 29391.0;\nfloat c_4 = 23497.0;\nfloat c_5 = 31183.0;\nfloat c_6 = 31215.0;\nfloat c_7 = 29257.0;\nfloat c_8 = 31727.0;\nfloat c_9 = 31695.0;\n\nfloat digit(float num, vec2 p)\n{\n\tnum = mod(floor(num),10.0);\n\t\n\tif(num == 0.0) return sprite(c_0, 3., 5., p);\n\tif(num == 1.0) return sprite(c_1, 3., 5., p);\n\tif(num == 2.0) return sprite(c_2, 3., 5., p);\n\tif(num == 3.0) return sprite(c_3, 3., 5., p);\n\tif(num == 4.0) return sprite(c_4, 3., 5., p);\n\tif(num == 5.0) return sprite(c_5, 3., 5., p);\n\tif(num == 6.0) return sprite(c_6, 3., 5., p);\n\tif(num == 7.0) return sprite(c_7, 3., 5., p);\n\tif(num == 8.0) return sprite(c_8, 3., 5., p);\n\tif(num == 9.0) return sprite(c_9, 3., 5., p);\n\t\n\treturn 0.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[656, 754, 803, 803, 927], [929, 929, 998, 998, 1138], [1140, 1140, 1168, 1168, 1228], [1230, 1230, 1267, 1267, 1389], [1391, 1391, 1433, 1433, 1541], [1543, 1543, 1571, 1571, 2158], [2160, 2160, 2188, 2188, 2421], [2423, 2423, 2441, 2441, 2573], [2575, 2575, 2592, 2592, 2687], [2690, 2690, 2748, 2748, 4111], [4113, 4265, 4318, 4318, 6272], [6274, 6351, 6411, 6411, 6910], [7098, 7133, 7190, 7190, 9122], [9124, 9194, 9231, 9231, 9320], [9322, 9322, 9371, 9371, 9519], [9521, 9940, 9972, 9972, 10490]], "test": "untested"}
{"id": "MtsXRl", "name": "[SIG15]Bustin makes me feel good", "author": "dcoombes", "description": "Gozer the Traveler. He will come in one of the pre-chosen forms. During the rectification of the Vuldrini, the traveler came as a large and moving Torg! Then, during the third reconciliation of the last of the McKetrick supplicants, they chose a new form ", "tags": ["sig15"], "likes": 3, "viewed": 285, "published": "Public", "date": "1439062588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//dcoombes 2015\n\n//Based on IQ's code found here. That shader includes a link back to the distance field documentation\n//https://www.shadertoy.com/view/Xds3zN\n//ghostbusters logo exported as \"compiled sprite\" using python and pil.\n\n\n#define \tM_PI   3.14159265358979323846\n#define \tDEG2RAD(x)   ((x) * 0.01745329251994329575)\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdCylinder2( vec3 p, vec2 h )\n{\n//  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nmat4 rotXMat(float a)\n{ \nmat4 m;\nm[0] = vec4(1.0, 0.0, 0.0, 1.0); //Sets the first column    \nm[1] = vec4(0.0, cos(a), sin(a), 0.0);    \nm[2] = vec4(0.0, -sin(a), cos(a), 0.0);    \nm[3] = vec4(0.0, 0.0, 0.0, 1.0);     \n    \nreturn m;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nmat4 rotZMat(float a)\n{ \nmat4 m;\nm[0] = vec4(cos(a),sin(a), 0.0, 0.0); //Sets the first column    \nm[1] = vec4(-sin(a), cos(a), 0.0,0.0);    \nm[2] = vec4(0.0, 0.0, 1.0, 0.0);    \nm[3] = vec4(0.0, 0.0, 0.0, 1.0);     \n    \nreturn m;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec4 q = m*vec4(p,1.0);\n    return q.xyz;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n\nfloat opS( float d1, float d2 ) //subtract\n{\n    return max(-d2,d1);\n}\n\n\n\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec2 map( in vec3 pos )\n{\n\n    vec2 res;\n    \n    float d = sdSphere( pos-vec3(  0.0,0.30, -0.0), 0.32 ); //body\n    float e = sdSphere( pos-vec3(  0.0,0.60, -0.0),0.15);   //head\n    \n    float f = sdCapsule(pos,vec3(-0.13,0.7,0.09), vec3(-0.05,0.66,0.17), 0.01   ); //left eyebrow\n    float g = sdCapsule(pos,vec3( 0.13,0.7,0.09), vec3( 0.05,0.66,0.17), 0.01   ); //right eyebrow\n\n    float h = sdSphere( pos-vec3(  0.0,0.58, 0.17),0.005);   //nose\n\n   \n     res = vec2(smin(h,smin(g,smin(f,smin(e,d,0.1),0.1),0.1),0.1),7.0);\n    \n     float i = sdSphere( pos-vec3(  0.0,0.36, 0.2),0.2);   //mouth\n\tres = vec2(opS( res.x,i),7.0);\n    \n    \n    \n\t//left arm\n    float j = sdCapsule( pos,vec3(-0.3,0.40,-0.0), vec3(-0.5,0.50,0.0), 0.05  );\n    float k = sdCapsule( pos,vec3(-0.5,0.50,-0.0), vec3(-0.6,0.55,0.0), 0.03  );\n    float m = sdCapsule( pos,vec3(-0.5,0.50,-0.0), vec3(-0.6,0.45,0.0), 0.03  );\n    float n = sdCapsule( pos,vec3(-0.5,0.50,-0.0), vec3(-0.5,0.60,0.0), 0.03  );\n    \n    \n    res = opU( res, vec2( j, 31.9 ) );\n    res = opU( res, vec2( k, 31.9 ) );\n    res = opU( res, vec2( m, 31.9 ) );\n    res = opU( res, vec2( n, 31.9 ) );\n\n    //right arm\n    j = sdCapsule( pos,vec3(0.3,0.40,-0.0), vec3(0.5,0.50,0.0), 0.05  );\n    k = sdCapsule( pos,vec3(0.5,0.50,-0.0), vec3(0.6,0.55,0.0), 0.03  );\n    m = sdCapsule( pos,vec3(0.5,0.50,-0.0), vec3(0.6,0.45,0.0), 0.03  );\n    n = sdCapsule( pos,vec3(0.5,0.50,-0.0), vec3(0.5,0.60,0.0), 0.03  );\n    \n    \n    res = opU( res, vec2( j, 0.12 ) );\n    res = opU( res, vec2( k, 21.2 ) );\n    res = opU( res, vec2( m, 31.3 ) );\n    res = opU( res, vec2( n, 41.4 ) );\n\n    \n    d = sdSphere( pos-vec3(  -0.08,0.63, 0.27), 0.03 ); //left eye\n    e = sdSphere( pos-vec3(  0.08,0.63, 0.27), 0.03 ); //left eye\n    \n\n        res = opU( res, vec2( d, 0.12 ) );\n    res = opU( res, vec2( e, 21.2 ) );\n\n\n    \n    \n    return res;\n}\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\nvec3 col = vec3(0.0, 0.0, 0.0);\nvec2 res = castRay(ro,rd);    \n    \nfloat t = res.x;\n\n    float m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n        \n        if( m<1.5 ) \n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n        \n        vec3  lig = normalize( vec3(-0.0, 0.3, 0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.6, 1.0 );\n        \n        amb = amb/4.;\n        col = vec3(0.0,0.6,0.0);\n        col = (col*dif)+amb;\n        \n    }\n    \n    \n    \n    \n    \nreturn vec3( clamp(col,0.0,1.0) );\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 sampleIt(float x, float y)  // don't look in here.\n{\n\n       float outc = 0.0;\n   float outr = 0.0;\nif(y <  0.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  1.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  2.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  3.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  4.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 33.0 ,x)  * step (x, 36.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  5.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 32.0 ,x)  * step (x, 36.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  6.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 31.0 ,x)  * step (x, 36.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  7.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 28.0 ,x)  * step (x, 37.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  8.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 27.0 ,x)  * step (x, 39.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  9.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 26.0 ,x)  * step (x, 35.0 );\n   outr+=  step( 39.0 ,x)  * step (x, 40.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  10.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 25.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 28.0 ,x)  * step (x, 32.0 );\n   outc+=  step( 33.0 ,x)  * step (x, 35.0 );\n   outr+=  step( 36.0 ,x)  * step (x, 43.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  11.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 23.0 ,x)  * step (x, 24.0 );\n   outc+=  step( 25.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 36.0 ,x)  * step (x, 45.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  12.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 21.0 ,x)  * step (x, 23.0 );\n   outc+=  step( 24.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 28.0 ,x)  * step (x, 31.0 );\n   outc+=  step( 32.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 36.0 ,x)  * step (x, 47.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  13.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 20.0 ,x)  * step (x, 23.0 );\n   outc+=  step( 24.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 28.0 ,x)  * step (x, 31.0 );\n   outc+=  step( 32.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 36.0 ,x)  * step (x, 49.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  14.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 19.0 ,x)  * step (x, 22.0 );\n   outc+=  step( 23.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 36.0 ,x)  * step (x, 50.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  15.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 17.0 ,x)  * step (x, 21.0 );\n   outc+=  step( 22.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 36.0 ,x)  * step (x, 51.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  16.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 16.0 ,x)  * step (x, 20.0 );\n   outc+=  step( 21.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 37.0 ,x)  * step (x, 52.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  17.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 15.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 28.0 );\n   outc+=  step( 30.0 ,x)  * step (x, 36.0 );\n   outr+=  step( 40.0 ,x)  * step (x, 53.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  18.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 15.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 37.0 );\n   outr+=  step( 42.0 ,x)  * step (x, 54.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  19.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 14.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 37.0 );\n   outr+=  step( 44.0 ,x)  * step (x, 55.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  20.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 13.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 28.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 37.0 );\n   outr+=  step( 45.0 ,x)  * step (x, 55.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  21.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 13.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 37.0 );\n   outc+=  step( 38.0 ,x)  * step (x, 40.0 );\n   outr+=  step( 46.0 ,x)  * step (x, 56.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  22.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 12.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 37.0 );\n   outc+=  step( 38.0 ,x)  * step (x, 43.0 );\n   outr+=  step( 47.0 ,x)  * step (x, 56.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  23.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 12.0 ,x)  * step (x, 20.0 );\n   outc+=  step( 21.0 ,x)  * step (x, 45.0 );\n   outr+=  step( 46.0 ,x)  * step (x, 57.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  24.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 11.0 ,x)  * step (x, 19.0 );\n   outc+=  step( 20.0 ,x)  * step (x, 36.0 );\n   outc+=  step( 37.0 ,x)  * step (x, 43.0 );\n   outr+=  step( 44.0 ,x)  * step (x, 57.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  25.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 11.0 ,x)  * step (x, 18.0 );\n   outc+=  step( 19.0 ,x)  * step (x, 21.0 );\n   outc+=  step( 22.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 35.0 );\n   outc+=  step( 36.0 ,x)  * step (x, 41.0 );\n   outr+=  step( 42.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  26.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 11.0 ,x)  * step (x, 17.0 );\n   outc+=  step( 18.0 ,x)  * step (x, 39.0 );\n   outr+=  step( 41.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  27.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 1.0 ,x)  * step (x, 3.0 );\n   outr+=  step( 10.0 ,x)  * step (x, 16.0 );\n   outc+=  step( 17.0 ,x)  * step (x, 37.0 );\n   outr+=  step( 39.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  28.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 3.0 ,x)  * step (x, 5.0 );\n   outr+=  step( 10.0 ,x)  * step (x, 15.0 );\n   outc+=  step( 16.0 ,x)  * step (x, 35.0 );\n   outr+=  step( 37.0 ,x)  * step (x, 59.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  29.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 4.0 ,x)  * step (x, 7.0 );\n   outr+=  step( 10.0 ,x)  * step (x, 13.0 );\n   outc+=  step( 15.0 ,x)  * step (x, 33.0 );\n   outr+=  step( 35.0 ,x)  * step (x, 50.0 );\n   outr+=  step( 51.0 ,x)  * step (x, 56.0 );\n   outc+=  step( 58.0 ,x)  * step (x, 61.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  30.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 3.0 ,x)  * step (x, 9.0 );\n   outr+=  step( 10.0 ,x)  * step (x, 12.0 );\n   outc+=  step( 13.0 ,x)  * step (x, 32.0 );\n   outr+=  step( 33.0 ,x)  * step (x, 48.0 );\n   outc+=  step( 50.0 ,x)  * step (x, 51.0 );\n   outr+=  step( 53.0 ,x)  * step (x, 54.0 );\n   outc+=  step( 56.0 ,x)  * step (x, 60.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  31.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 1.0 ,x)  * step (x, 11.0 );\n   outc+=  step( 12.0 ,x)  * step (x, 30.0 );\n   outr+=  step( 31.0 ,x)  * step (x, 47.0 );\n   outc+=  step( 48.0 ,x)  * step (x, 52.0 );\n   outc+=  step( 53.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  32.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 4.0 ,x)  * step (x, 28.0 );\n   outr+=  step( 29.0 ,x)  * step (x, 44.0 );\n   outc+=  step( 46.0 ,x)  * step (x, 57.0 );\n   outr+=  step( 58.0 ,x)  * step (x, 59.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  33.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 5.0 ,x)  * step (x, 26.0 );\n   outr+=  step( 27.0 ,x)  * step (x, 43.0 );\n   outc+=  step( 45.0 ,x)  * step (x, 57.0 );\n   outr+=  step( 57.0 ,x)  * step (x, 59.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  34.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 3.0 ,x)  * step (x, 20.0 );\n   outc+=  step( 22.0 ,x)  * step (x, 24.0 );\n   outr+=  step( 25.0 ,x)  * step (x, 41.0 );\n   outc+=  step( 42.0 ,x)  * step (x, 45.0 );\n   outc+=  step( 47.0 ,x)  * step (x, 56.0 );\n   outc+=  step( 57.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  35.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 2.0 ,x)  * step (x, 5.0 );\n   outc+=  step( 6.0 ,x)  * step (x, 18.0 );\n   outr+=  step( 24.0 ,x)  * step (x, 39.0 );\n   outc+=  step( 41.0 ,x)  * step (x, 45.0 );\n   outc+=  step( 46.0 ,x)  * step (x, 61.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  36.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 9.0 ,x)  * step (x, 16.0 );\n   outr+=  step( 21.0 ,x)  * step (x, 37.0 );\n   outc+=  step( 39.0 ,x)  * step (x, 44.0 );\n   outc+=  step( 45.0 ,x)  * step (x, 62.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  37.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 10.0 ,x)  * step (x, 13.0 );\n   outr+=  step( 15.0 ,x)  * step (x, 17.0 );\n   outr+=  step( 20.0 ,x)  * step (x, 35.0 );\n   outc+=  step( 37.0 ,x)  * step (x, 44.0 );\n   outc+=  step( 45.0 ,x)  * step (x, 49.0 );\n   outc+=  step( 51.0 ,x)  * step (x, 57.0 );\n   outr+=  step( 58.0 ,x)  * step (x, 59.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  38.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outc+=  step( 11.0 ,x)  * step (x, 13.0 );\n   outr+=  step( 13.0 ,x)  * step (x, 33.0 );\n   outc+=  step( 35.0 ,x)  * step (x, 44.0 );\n   outc+=  step( 45.0 ,x)  * step (x, 47.0 );\n   outc+=  step( 48.0 ,x)  * step (x, 49.0 );\n   outr+=  step( 52.0 ,x)  * step (x, 54.0 );\n   outc+=  step( 55.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  39.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 10.0 ,x)  * step (x, 11.0 );\n   outc+=  step( 12.0 ,x)  * step (x, 13.0 );\n   outr+=  step( 14.0 ,x)  * step (x, 32.0 );\n   outc+=  step( 33.0 ,x)  * step (x, 50.0 );\n   outr+=  step( 51.0 ,x)  * step (x, 56.0 );\n   outc+=  step( 57.0 ,x)  * step (x, 59.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  40.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 10.0 ,x)  * step (x, 29.0 );\n   outc+=  step( 31.0 ,x)  * step (x, 49.0 );\n   outr+=  step( 50.0 ,x)  * step (x, 57.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  41.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 11.0 ,x)  * step (x, 28.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 49.0 );\n   outr+=  step( 50.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  42.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 11.0 ,x)  * step (x, 26.0 );\n   outc+=  step( 28.0 ,x)  * step (x, 48.0 );\n   outr+=  step( 49.0 ,x)  * step (x, 58.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  43.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 11.0 ,x)  * step (x, 24.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 48.0 );\n   outr+=  step( 49.0 ,x)  * step (x, 57.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  44.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 12.0 ,x)  * step (x, 22.0 );\n   outc+=  step( 28.0 ,x)  * step (x, 30.0 );\n   outc+=  step( 31.0 ,x)  * step (x, 47.0 );\n   outr+=  step( 48.0 ,x)  * step (x, 57.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  45.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 12.0 ,x)  * step (x, 22.0 );\n   outc+=  step( 27.0 ,x)  * step (x, 33.0 );\n   outc+=  step( 35.0 ,x)  * step (x, 46.0 );\n   outr+=  step( 47.0 ,x)  * step (x, 56.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  46.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 13.0 ,x)  * step (x, 23.0 );\n   outc+=  step( 26.0 ,x)  * step (x, 45.0 );\n   outr+=  step( 46.0 ,x)  * step (x, 56.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  47.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 14.0 ,x)  * step (x, 24.0 );\n   outc+=  step( 25.0 ,x)  * step (x, 44.0 );\n   outr+=  step( 45.0 ,x)  * step (x, 55.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  48.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 14.0 ,x)  * step (x, 25.0 );\n   outc+=  step( 27.0 ,x)  * step (x, 42.0 );\n   outr+=  step( 44.0 ,x)  * step (x, 54.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  49.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 15.0 ,x)  * step (x, 27.0 );\n   outc+=  step( 29.0 ,x)  * step (x, 40.0 );\n   outr+=  step( 42.0 ,x)  * step (x, 53.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  50.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 16.0 ,x)  * step (x, 30.0 );\n   outr+=  step( 39.0 ,x)  * step (x, 53.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  51.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 17.0 ,x)  * step (x, 52.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  52.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 18.0 ,x)  * step (x, 51.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  53.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 19.0 ,x)  * step (x, 49.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  54.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 21.0 ,x)  * step (x, 48.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  55.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 22.0 ,x)  * step (x, 46.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  56.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 24.0 ,x)  * step (x, 44.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  57.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 27.0 ,x)  * step (x, 42.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  58.0 ){\n   outc = 0.0;\n   outr = 0.0;\n   outr+=  step( 32.0 ,x)  * step (x, 37.0 );\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  59.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  60.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  61.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  62.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\nif(y <  63.0 ){\n   outc = 0.0;\n   outr = 0.0;\nreturn (vec3(clamp(outr+outc,0.0,1.0),outc,outc));\n  }\n\n\n\n\nreturn (vec3(0.0,0.0,0.0) );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n //   vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.0+1.4*sin(0.0 ), 1.0 , 0.0 + 1.4*cos(0.0) );\n\n    float y = 0.4 + cos(4.1*time)/15.0;\n\tvec3 ta = vec3( -0.0, y, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col;// = vec3(0,0,0);\n    col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n    \n    \n    vec3 crimesAgainstProgramming = sampleIt((128.0*4.0*q.x)-440.5, (128.0*4.0*(1.0-q.y))-430.0);\n    \n    col+= crimesAgainstProgramming;\n    \n     \n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 433, 458, 458, 473], [475, 582, 617, 617, 643], [646, 753, 784, 784, 871], [873, 980, 1032, 1032, 1146], [1149, 1256, 1292, 1292, 1391], [1394, 1501, 1546, 1546, 1586], [1589, 1696, 1733, 1779, 1880], [1885, 1992, 2015, 2015, 2227], [2230, 2337, 2360, 2360, 2570], [2573, 2680, 2709, 2709, 2757], [2759, 2857, 2887, 2887, 2920], [2924, 2924, 2968, 2968, 2994], [2999, 3035, 3076, 3076, 3169], [3171, 3278, 3303, 3303, 5158], [5164, 5271, 5311, 5311, 5901], [5903, 6010, 6042, 6042, 6263], [6267, 6374, 6413, 6413, 7266], [7268, 7375, 7427, 7427, 7604], [7609, 7823, 7880, 7880, 22864], [22980, 23087, 23144, 23144, 23923]], "test": "untested"}
{"id": "MtsXWj", "name": "CIELAB Gamut Test", "author": "triclops200", "description": "A dynamic cielab/sRGB gamut generator", "tags": ["test", "cielab", "gamut"], "likes": 4, "viewed": 185, "published": "Public", "date": "1439906783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nfloat ref_X = 95.047;\nfloat ref_Y = 100.000;\nfloat ref_Z = 108.883;\n\nfloat mina = -86.1846;\nfloat minb = -107.86368;\nvec2 mins = vec2(mina,minb);\n\nfloat maxa = 98.2542;\nfloat maxb = 94.4825;\nvec2 maxes = vec2(maxa,maxb);\n\nfloat arange = maxa-mina;\nfloat brange = maxb-minb;\n\nvec2 ranges = vec2(arange,brange);\n\n\nvec3 xyz2rgb(vec3 xyz) {\n    float var_X = xyz[0] * 0.01;\n    float var_Y = xyz[1] * 0.01;\n    float var_Z = xyz[2] * 0.01;\n    \n    float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n    float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n    \n    if (var_R > 0.0031308) var_R = 1.055 * pow(var_R, 1.0/2.4) - 0.055;\n    else var_R = 12.92 * var_R;\n    if (var_G > 0.0031308) var_G = 1.055 * pow(var_G, 1.0/2.4) - 0.055;\n    else var_G = 12.92 * var_G;\n    if (var_B > 0.0031308) var_B = 1.055 * pow(var_B, 1.0/2.4) - 0.055;\n    else var_B = 12.92 * var_B;\n    \n    return vec3(var_R,var_G,var_B);\n}\n\nvec3 cielab2xyz(vec3 lab) {\n    float var_Y = (lab[0] + 16.0) / 116.0;\n    float var_X = lab[1] / 500.0 + var_Y;\n    float var_Z = var_Y - lab[2] / 200.0;\n    \n    \n\tfloat py = var_Y*var_Y*var_Y;\n    float px = var_X*var_X*var_X;\n    float pz = var_Z*var_Z*var_Z;\n\n    if (py > 0.008856) var_Y = py;\n    else var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n    if (px > 0.008856) var_X = px;\n    else var_X = (var_X - 16.0 / 116.0) / 7.787;\n    if (pz > 0.008856) var_Z = pz;\n    else var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n    \n    float X = ref_X * var_X;\n    float Y = ref_Y * var_Y;\n    float Z = ref_Z * var_Z;\n    return vec3(X, Y, Z);\n}\n\nvec3 cielab2rgb(vec3 lab) {\n    return xyz2rgb(cielab2xyz(lab));\n}\n\nfloat isGray(vec2 uv){\n\tvec3 color = cielab2rgb(vec3(sin(iTime)*50.0+50.0,uv*ranges+mins));\n    if(color[0] > 1.0 || color[1] > 1.0 || color[2] > 1.0 ||\n       color[0] < 0.0 || color[1] < 0.0 || color[2] < 0.0){\n    \treturn 1.0;\n    }\n    return 0.0;\n}\n\n\n\nfloat countGrayNeighbors(vec2 xy,vec2 res){\n\tfloat sum;\n    sum += isGray((xy+vec2(1.0,0.0))/res);\n    sum += isGray((xy+vec2(0.0,1.0))/res);\n    sum += isGray((xy+vec2(-1.0,0.0))/res);\n    sum += isGray((xy+vec2(0.0,-1.0))/res);\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = cielab2rgb(vec3(sin(iTime)*50.0+50.0,uv*ranges+mins));\n    float n = 2.0; //countGrayNeighbors(fragCoord.xy,iResolution.xy);\n    if(n < 1.0 ||\n       color[0] > 1.0 || color[1] > 1.0 || color[2] > 1.0 ||\n       color[0] < 0.0 || color[1] < 0.0 || color[2] < 0.0){\n    \tcolor = vec3(0.5,0.5,0.5);\n    }\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 360, 360, 1032], [1034, 1034, 1061, 1061, 1670], [1672, 1672, 1699, 1699, 1738], [1740, 1740, 1762, 1762, 1993], [1997, 1997, 2040, 2040, 2244], [2246, 2246, 2303, 2303, 2696]], "test": "untested"}
{"id": "MtXSzf", "name": "Cantharellus", "author": "rohtie", "description": "This is not raymarched, it is created using plane deformations :)\n\n", "tags": ["deformation", "plane", "mushroom", "shroom"], "likes": 2, "viewed": 183, "published": "Public", "date": "1438643118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin (float a, float b, float k) {\n    a = pow(a, k); b = pow(b, k);\n    return pow((a*b)/(a + b), 1.0/k);\n}\n\nvoid mainImage( out vec4 col, in vec2 p ) {\n    p /= iResolution.xy;\n\n\n    p.x -= 0.13;\n\n    float t = iTime;\n\n    // Hat\n    vec2 hat = p - vec2(0.47, 0.76);\n    hat *= mat2(1.0, -0.27 + sin(t)*0.5,\n                -0.1 - sin(t) * 0.21, 1.6);\n\n    float hat_r = length(hat) * 1.2;\n    hat_r += cos(atan(hat.x, hat.y)*10.0)* 0.0074;\n\n\n    // Stalk\n    vec2 stalk = p - vec2(0.5, 0.42);\n    stalk *= mat2(3.4 + stalk.y * 5.0, 0.16 - sin(t)*0.02,\n                  sin(t) * 0.025, 1.2);\n\n    float stalk_r = length(stalk) * 1.25 + stalk.y * 0.57 + sin(t) * 0.05 + 0.052;\n\n    // Shroom\n    float shroom = min(hat_r + 0.034, stalk_r);\n    shroom = smoothstep(0.15, 0.1 * pow(p.y + 0.2, 2.2), shroom - 0.15);\n\n    float shroomBody = smin(hat_r, stalk_r, 0.87 - abs(sin(t))*0.05);\n    shroomBody = smoothstep(0.20, 0.21, shroomBody);\n    float shroomBody_m = 1.0 - shroomBody;\n\n    // Hat details\n    float hatDetails = smoothstep(0.4, 0.0, hat_r + length(\n        hat*mat2(1.0, 0.0,\n                 1.0, 0.0))\n        * -cos(atan(hat.x * 1.4, hat.y * 1.2))\n    ) * 0.85;\n\n    // Stalk texture\n    vec2 stalkTex = stalk * 2.4 * stalk_r;\n    float angle = t;\n    stalkTex *= mat2(1.0, sin(angle),\n                     0.0, 1.0);\n\n    float stalkT = smoothstep(2.1, 0.1, length(stalkTex));\n    stalkT = pow(stalkT, 10.0);\n\n    // Shadow\n    vec2 shadow = p - vec2(0.5, 0.42 + sin(t)*0.05);\n    shadow *= mat2(1.0 - shadow.y * 3.0, 0.15 + sin(t)*0.05,\n                   0.0, 1.0 + sin(t)*0.15);\n\n    float shadow_r = length(shadow);\n    shadow_r = smoothstep(0.25, 0.06, shadow_r);\n\n    // Composite\n    col.rgb = (\n        // Background\n        sqrt(p.y) *\n        vec3(0.12, 0.77, 0.2) *\n        texture(iChannel1, sin(t)*0.031 + 1.0 - p * exp(p.y * 5.2)*0.25).rgb * 1.75 *\n        shroomBody +\n\n        (p * 1.55 - vec2(0.0, 0.55) + p.x*0.37).y * vec3(0.052, 0.12, 0.75) *\n        shroomBody +\n\n        // Textures\n        texture(iChannel0, hat).rgb\n        * smoothstep(0.44, 0.2, hat_r)\n        * shroomBody_m +\n\n        texture(iChannel0, p / stalkT).rgb\n        * smoothstep(0.5, 0.0, stalk_r) * 1.5\n        * shroomBody_m +\n\n        // Lighting\n        shroomBody * -shadow_r * 0.25 +\n        shroom * 0.66 +\n        -smoothstep(0.4, 0.0, stalk_r) * 0.45 +\n        smoothstep(0.21, 0.1, stalk_r) * 0.32 +\n\n        // Post\n        (1.0 - hat_r) * 0.25 * shroomBody_m +\n        shroomBody_m * pow(p.y, 2.0) * vec3(1.35, 1.25, 0.0) * 0.15 +\n        -vec3(1.35, 1.25 + p.x, 0.0) * 0.06 +\n        -hatDetails * shroomBody_m * 0.732 +\n        + 0.0\n    );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 114], [116, 116, 159, 159, 2670]], "test": "untested"}
{"id": "MtXXDl", "name": "Mandelmaze", "author": "dr2", "description": "Touring the Mandelbox (best viewed in fullscreen mode, a complete trip\ntakes about 20 min).", "tags": ["raymarching", "fractal", "mandelbox"], "likes": 14, "viewed": 1147, "published": "Public API", "date": "1440521580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Mandelmaze\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nmat3 vuMat;\nvec3 gloPos[2], vuPos;\nfloat tCur, chRingO, chRingI, vuVel, bxSize, chSize, qnStep;\nint idObj;\nconst float mScale = 2.62;\nconst float dstFar = 30.;\nconst float pi = 3.14159;\n\nfloat MBoxDf (vec3 p)\n{\n  vec4 q, q0;\n  const int nIter = 12;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;\n  }\n  return length (q.xyz) / abs (q.w);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dm, tWid;\n  dMin = dstFar;\n  d = MBoxDf (p);\n  q = p;\n  q.y -= vuPos.y;\n  tWid = 0.9 * chSize;\n  dm = min (PrCylAnDf (q.xzy, chRingO, chSize, chSize),\n     PrCylAnDf (q.xzy, chRingI, tWid, chSize));\n  dm = min (min (dm, PrBox2Df (q.xy, vec2 (tWid, chSize))),\n     PrBox2Df (q.zy, vec2 (tWid, chSize)));\n  d = max (d, - dm);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const int nStep = 150;\n  float dHit, d, s;\n  dHit = 0.;\n  s = 0.;\n  for (int j = 0; j < nStep; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    ++ s;\n    if (d < 0.0003 || dHit > dstFar) break;\n  }\n  qnStep = s / float (nStep);\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[9], aDir, a, d, r, tO, tI, tR, rGap;\n  bool rotStep;\n  tO = 0.5 * pi * chRingO / vuVel;\n  tI = 0.5 * pi * chRingI / vuVel;\n  rGap = chRingO - chRingI;\n  tR = rGap / vuVel;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tO;  ti[2] = ti[1] + tR;\n  ti[3] = ti[2] + tI;  ti[4] = ti[3] + tR;\n  ti[5] = ti[4] + tO;  ti[6] = ti[5] + tR;\n  ti[7] = ti[6] + tI;  ti[8] = ti[7] + tR;\n  aDir = 2. * mod (floor (t / ti[8]), 2.) - 1.;\n  p.y = 0.7 * bxSize * sin (2. * pi * floor (t / (2. * ti[8])) / 11.);\n  t = mod (t, ti[8]);\n  r = chRingO;\n  tr = vec2 (0.);\n  if (t < ti[4]) {\n    if (t < ti[1]) {\n      rotStep = true;\n      a = (t - ti[0]) / (ti[1] - ti[0]);\n    } else if (t < ti[2]) {\n      tr.y = chRingO - rGap * (t - ti[1]) / (ti[2] - ti[1]);\n    } else if (t < ti[3]) {\n      rotStep = true;\n      a = 1. + (t - ti[2]) / (ti[3] - ti[2]);\n      r = chRingI;\n    } else {\n      tr.x = - (chRingI + rGap * (t - ti[3]) / (ti[4] - ti[3]));\n    }\n  } else {\n    if (t < ti[5]) {\n      rotStep = true;\n      a = 2. + (t - ti[4]) / (ti[5] - ti[4]);\n    } else if (t < ti[6]) {\n      tr.y = - chRingO + rGap * (t - ti[5]) / (ti[6] - ti[5]);\n    } else if (t < ti[7]) {\n      rotStep = true;\n      a = 3. + (t - ti[6]) / (ti[7] - ti[6]);\n      r = chRingI;\n    } else {\n      tr.x = chRingI + rGap * (t - ti[7]) / (ti[8] - ti[7]);\n    }\n  }\n  if (rotStep) {\n    a *= 0.5 * pi * aDir;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    if (aDir < 0.) tr.y *= -1.;\n    p.xz = tr;\n  }\n  return p;\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel;\n  float a, ca, sa, dt;\n  dt = 1.;\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.y = fpB.y;\n  vel = (fpF - fpB) / (2. * dt);\n  a = atan (vel.z, vel.x) - 0.5 * pi;\n  ca = cos (a);  sa = sin (a);\n  vuMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 gloDir;\n  float gloDist, wGlow;\n  wGlow = 0.;\n  for (int j = 0; j < 2; j ++) {\n    gloDir = gloPos[j] - ro;\n    gloDist = length (gloDir);\n    gloDir /= gloDist;\n    if (gloDist < dstHit) wGlow +=\n       pow (max (dot (rd, gloDir), 0.), 1024.) / sqrt (gloDist);\n  }\n  return (0.7 + 0.2 * sin (10. * tCur)) * clamp (wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, rdo, col, vn, ltDir;\n  float dstHit;\n  int idObjT;\n  ltDir = normalize (vec3 (0.5, 1., -0.5));\n  idObj = -1;\n  roo = ro;\n  dstHit = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (dstHit < dstFar) {\n    ro += dstHit * rd;\n    vn = ObjNf (ro);\n    if (idObjT == 1) {\n      col = mix (vec3 (1., 1., 0.), vec3 (1., 1., 0.8),\n\t clamp (1.2 * length (ro) / bxSize, 0., 1.));\n      col = col * clamp (1. - 1.5 * qnStep * qnStep, 0.3, 1.);\n    }\n    col = col * (0.2 +\n       0.6 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n  } else {\n    col = vec3 (0., 0., 0.1);\n    rdo = rd;\n    rdo += vec3 (1.);\n    for (int j = 0; j < 10; j ++)\n       rdo = 11. * abs (rdo) / dot (rdo, rdo) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rdo)), 5.)) *\n       vec3 (0.7, 0.6, 0.6);\n  }\n  col = mix (col, vec3 (1., 0.5, 0.3), GlowCol (roo, rd, dstHit));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd;\n  bxSize = 4.;\n  chSize = 0.08 * bxSize;\n  chRingO = 0.8 * bxSize;\n  chRingI = 0.4 * bxSize;\n  vuVel = 0.1 * bxSize;\n  gloPos[0] = vec3 (0.);\n  VuPM (tCur + 1.5 * vuVel);\n  gloPos[1] = vuPos;\n  VuPM (tCur);\n  gloPos[0].y = vuPos.y;\n  gloPos[1].y = vuPos.y - 0.2 * chSize;\n  ro = vuPos;\n  rd = normalize (vec3 (uv, 1.1)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXXDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 118, 151, 151, 235], [237, 237, 290, 290, 351], [540, 540, 563, 563, 824], [826, 826, 848, 848, 1258], [1260, 1260, 1293, 1293, 1550], [1552, 1552, 1573, 1573, 1781], [1783, 1783, 1809, 1809, 3332], [3334, 3334, 3355, 3355, 3674], [3676, 3676, 3724, 3724, 4064], [4066, 4066, 4101, 4101, 5035], [5037, 5037, 5093, 5093, 5594]], "test": "untested"}
{"id": "MtXXWS", "name": "star stage", "author": "johnnyscript", "description": "yay", "tags": ["yay"], "likes": 3, "viewed": 111, "published": "Public", "date": "1439277247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LOOK AHEAD INTO THE FUTURE\n\nfloat angle(vec2 coord, vec2 center){\n\tfloat dx = coord.x - center.x;\n    float dy = coord.y - center.x;\n    return atan(dx/dy);\n}\n\nfloat diric (float n, float x);\nvec3 hsl2rgb (float h, float s, float l);\n\nvec3 hsl(in float h, float s, float l) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\nfloat amod(float c, float r, float f, float t){\n    return c + r * ((log((1.0001 + sin(f * t * 6.282)) * 50.0) / log(10.0))/2.0-2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float w = iResolution.x - (15.0 * cos(iTime * 2.0));\n    float h = iResolution.y + (5.0 * cos(iTime * 3.0));\n\n    float x = fragCoord.x - w / 2.0 ;\n    float y = fragCoord.y - h /  2.0 ;\n    float t = iTime * 1.0;\n    float xx = mod(x, 20.0);\n    float yy = mod(y, 20.0);\n    vec2 c = vec2( w / 2.0, h / 2.0);\n    float a = angle(vec2(xx, yy), c);\n    float vv = sin(t* y * x + log(t)) + sin(a - 0.5 * 72.0 / 60.0);\n    vec3 uv2 = hsl(1.0 - mod(vv, amod(.5, 1.0, t, 4.0 / 24.0)), 1.0, .5);\n\tfragColor = vec4(uv2, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 68, 68, 161], [238, 238, 278, 278, 408], [410, 410, 457, 457, 545], [547, 547, 604, 604, 1179]], "test": "untested"}
{"id": "XlBSRz", "name": "VolumetricIntegration", "author": "SebH", "description": "A volumetric rendering demo.\nThis shader also presents the advantage of integrating analytically the scattered light within participating media having high scattering value.", "tags": ["volumetric", "integration", "participatingmedia"], "likes": 481, "viewed": 42620, "published": "Public API", "date": "1440854078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Hi there!\n * Here is a demo presenting volumetric rendering single with shadowing.\n * Did it quickly so I hope I have not made any big mistakes :)\n *\n * I also added the improved scattering integration I propose in my SIGGRAPH'15 presentation\n * about Frostbite new volumetric system I have developed. See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n * Basically it improves the scattering integration for each step with respect to extinction\n * The difference is mainly visible for some participating media having a very strong scattering value. \n * I have setup some pre-defined settings for you to checkout below (to present the case it improves):\n * - D_DEMO_SHOW_IMPROVEMENT_xxx: shows improvement (on the right side of the screen). You can still see aliasing due to volumetric shadow and the low amount of sample we take for it.\n * - D_DEMO_SHOW_IMPROVEMENT_xxx_NOVOLUMETRICSHADOW: same as above but without volumetric shadow\n *\n * To increase the volumetric rendering accuracy, I constrain the ray marching steps to a maximum distance.\n *\n * Volumetric shadows are evaluated by raymarching toward the light to evaluate transmittance for each view ray steps (ouch!)\n *\n * Do not hesitate to contact me to discuss about all that :) \n * SebH\n */\n\n\n\n/*\n * This are predefined settings you can quickly use\n *    - D_DEMO_FREE play with parameters as you would like\n *    - D_DEMO_SHOW_IMPROVEMENT_FLAT show improved integration on flat surface\n *    - D_DEMO_SHOW_IMPROVEMENT_NOISE show improved integration on noisy surface\n *    - the two previous without volumetric shadows\n */\n#define D_DEMO_FREE\n//#define D_DEMO_SHOW_IMPROVEMENT_FLAT\n//#define D_DEMO_SHOW_IMPROVEMENT_NOISE\n//#define D_DEMO_SHOW_IMPROVEMENT_FLAT_NOVOLUMETRICSHADOW\n//#define D_DEMO_SHOW_IMPROVEMENT_NOISE_NOVOLUMETRICSHADOW\n\n\n\n\n\n#ifdef D_DEMO_FREE\n\t// Apply noise on top of the height fog?\n    #define D_FOG_NOISE 1.0\n\n\t// Height fog multiplier to show off improvement with new integration formula\n    #define D_STRONG_FOG 0.0\n\n    // Enable/disable volumetric shadow (single scattering shadow)\n    #define D_VOLUME_SHADOW_ENABLE 1\n\n\t// Use imporved scattering?\n\t// In this mode it is full screen and can be toggle on/off.\n\t#define D_USE_IMPROVE_INTEGRATION 1\n\n//\n// Pre defined setup to show benefit of the new integration. Use D_DEMO_FREE to play with parameters\n//\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT)\n    #define D_STRONG_FOG 10.0\n    #define D_FOG_NOISE 0.0\n\t#define D_VOLUME_SHADOW_ENABLE 1\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE)\n    #define D_STRONG_FOG 5.0\n    #define D_FOG_NOISE 1.0\n\t#define D_VOLUME_SHADOW_ENABLE 1\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT_NOVOLUMETRICSHADOW)\n    #define D_STRONG_FOG 10.0\n    #define D_FOG_NOISE 0.0\n\t#define D_VOLUME_SHADOW_ENABLE 0\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE_NOVOLUMETRICSHADOW)\n    #define D_STRONG_FOG 3.0\n    #define D_FOG_NOISE 1.0\n\t#define D_VOLUME_SHADOW_ENABLE 0\n#endif\n\n\n\n/*\n * Other options you can tweak\n */\n\n// Used to control wether transmittance is updated before or after scattering (when not using improved integration)\n// If 0 strongly scattering participating media will not be energy conservative\n// If 1 participating media will look too dark especially for strong extinction (as compared to what it should be)\n// Toggle only visible zhen not using the improved scattering integration.\n#define D_UPDATE_TRANS_FIRST 0\n\n// Apply bump mapping on walls\n#define D_DETAILED_WALLS 0\n\n// Use to restrict ray marching length. Needed for volumetric evaluation.\n#define D_MAX_STEP_LENGTH_ENABLE 1\n\n// Light position and color\n#define LPOS vec3( 20.0+15.0*sin(iTime), 15.0+12.0*cos(iTime),-20.0)\n#define LCOL (600.0*vec3( 1.0, 0.9, 0.5))\n\n\nfloat displacementSimple( vec2 p )\n{\n    float f;\n    f  = 0.5000* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.2500* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.1250* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.0625* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    \n    return f;\n}\n\n\nvec3 getSceneColor(vec3 p, float material)\n{\n\tif(material==1.0)\n\t{\n\t\treturn vec3(1.0, 0.5, 0.5);\n\t}\n\telse if(material==2.0)\n\t{\n\t\treturn vec3(0.5, 1.0, 0.5);\n\t}\n\telse if(material==3.0)\n\t{\n\t\treturn vec3(0.5, 0.5, 1.0);\n\t}\n\t\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n\nfloat getClosestDistance(vec3 p, out float material)\n{\n\tfloat d = 0.0;\n#if D_MAX_STEP_LENGTH_ENABLE\n    float minD = 1.0; // restrict max step for better scattering evaluation\n#else\n\tfloat minD = 10000000.0;\n#endif\n\tmaterial = 0.0;\n    \n    float yNoise = 0.0;\n    float xNoise = 0.0;\n    float zNoise = 0.0;\n#if D_DETAILED_WALLS\n    yNoise = 1.0*clamp(displacementSimple(p.xz*0.005),0.0,1.0);\n    xNoise = 2.0*clamp(displacementSimple(p.zy*0.005),0.0,1.0);\n    zNoise = 0.5*clamp(displacementSimple(p.xy*0.01),0.0,1.0);\n#endif\n    \n\td = max(0.0, p.y - yNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 2.0;\n\t}\n\t\n\td = max(0.0,p.x - xNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 1.0;\n\t}\n\t\n\td = max(0.0,40.0-p.x - xNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 1.0;\n\t}\n\t\n\td = max(0.0,-p.z - zNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 3.0;\n    }\n    \n\treturn minD;\n}\n\n\nvec3 calcNormal( in vec3 pos)\n{\n    float material = 0.0;\n    vec3 eps = vec3(0.3,0.0,0.0);\n\treturn normalize( vec3(\n           getClosestDistance(pos+eps.xyy, material) - getClosestDistance(pos-eps.xyy, material),\n           getClosestDistance(pos+eps.yxy, material) - getClosestDistance(pos-eps.yxy, material),\n           getClosestDistance(pos+eps.yyx, material) - getClosestDistance(pos-eps.yyx, material) ) );\n\n}\n\nvec3 evaluateLight(in vec3 pos)\n{\n    vec3 lightPos = LPOS;\n    vec3 lightCol = LCOL;\n    vec3 L = lightPos-pos;\n    return lightCol * 1.0/dot(L,L);\n}\n\nvec3 evaluateLight(in vec3 pos, in vec3 normal)\n{\n    vec3 lightPos = LPOS;\n    vec3 L = lightPos-pos;\n    float distanceToL = length(L);\n    vec3 Lnorm = L/distanceToL;\n    return max(0.0,dot(normal,Lnorm)) * evaluateLight(pos);\n}\n\n// To simplify: wavelength independent scattering and extinction\nvoid getParticipatingMedia(out float sigmaS, out float sigmaE, in vec3 pos)\n{\n    float heightFog = 7.0 + D_FOG_NOISE*3.0*clamp(displacementSimple(pos.xz*0.005 + iTime*0.01),0.0,1.0);\n    heightFog = 0.3*clamp((heightFog-pos.y)*1.0, 0.0, 1.0);\n    \n    const float fogFactor = 1.0 + D_STRONG_FOG * 5.0;\n    \n    const float sphereRadius = 5.0;\n    float sphereFog = clamp((sphereRadius-length(pos-vec3(20.0,19.0,-17.0)))/sphereRadius, 0.0,1.0);\n    \n    const float constantFog = 0.02;\n\n    sigmaS = constantFog + heightFog*fogFactor + sphereFog;\n   \n    const float sigmaA = 0.0;\n    sigmaE = max(0.000000001, sigmaA + sigmaS); // to avoid division by zero extinction\n}\n\nfloat phaseFunction()\n{\n    return 1.0/(4.0*3.14);\n}\n\nfloat volumetricShadow(in vec3 from, in vec3 to)\n{\n#if D_VOLUME_SHADOW_ENABLE\n    const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    float dd = length(to-from) / numStep;\n    for(float s=0.5; s<(numStep-0.1); s+=1.0)// start at 0.5 to sample at center of integral part\n    {\n        vec3 pos = from + (to-from)*(s/(numStep));\n        getParticipatingMedia(sigmaS, sigmaE, pos);\n        shadow *= exp(-sigmaE * dd);\n    }\n    return shadow;\n#else\n    return 1.0;\n#endif\n}\n\nvoid traceScene(bool improvedScattering, vec3 rO, vec3 rD, inout vec3 finalPos, inout vec3 normal, inout vec3 albedo, inout vec4 scatTrans)\n{\n\tconst int numIter = 100;\n\t\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    \n    vec3 lightPos = LPOS;\n    \n    // Initialise volumetric scattering integration (to view)\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n\tfloat d = 1.0; // hack: always have a first step of 1 unit to go further\n\tfloat material = 0.0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n    float dd = 0.0;\n\tfor(int i=0; i<numIter;++i)\n\t{\n\t\tvec3 p = rO + d*rD;\n        \n        \n    \tgetParticipatingMedia(sigmaS, sigmaE, p);\n        \n#ifdef D_DEMO_FREE\n        if(D_USE_IMPROVE_INTEGRATION>0) // freedom/tweakable version\n#else\n        if(improvedScattering)\n#endif\n        {\n            // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n            vec3 S = evaluateLight(p) * sigmaS * phaseFunction()* volumetricShadow(p,lightPos);// incoming light\n            vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE; // integrate along the current step segment\n            scatteredLight += transmittance * Sint; // accumulate and also take into account the transmittance from previous steps\n\n            // Evaluate transmittance to view independentely\n            transmittance *= exp(-sigmaE * dd);\n        }\n\t\telse\n        {\n            // Basic scatering/transmittance integration\n        #if D_UPDATE_TRANS_FIRST\n            transmittance *= exp(-sigmaE * dd);\n        #endif\n            scatteredLight += sigmaS * evaluateLight(p) * phaseFunction() * volumetricShadow(p,lightPos) * transmittance * dd;\n        #if !D_UPDATE_TRANS_FIRST\n            transmittance *= exp(-sigmaE * dd);\n        #endif\n        }\n        \n\t\t\n        dd = getClosestDistance(p, material);\n        if(dd<0.2)\n            break; // give back a lot of performance without too much visual loss\n\t\td += dd;\n\t}\n\t\n\talbedo = getSceneColor(p, material);\n\t\n    finalPos = rO + d*rD;\n    \n    normal = calcNormal(finalPos);\n    \n    scatTrans = vec4(scatteredLight, transmittance);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //iTime\n    //iMouse\n    //iResolution\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float hfactor = float(iResolution.y) / float(iResolution.x); // make it screen ratio independent\n\tvec2 uv2 = vec2(2.0, 2.0*hfactor) * fragCoord.xy / iResolution.xy - vec2(1.0, hfactor);\n\t\n\tvec3 camPos = vec3( 20.0, 18.0,-50.0);\n     if(iMouse.x+iMouse.y > 0.0) // to handle first loading and see somthing on screen\n        camPos += vec3(0.05,0.12,0.0)*(vec3(iMouse.x, iMouse.y, 0.0)-vec3(iResolution.xy*0.5, 0.0));\n\tvec3 camX   = vec3( 1.0, 0.0, 0.0);\n\tvec3 camY   = vec3( 0.0, 1.0, 0.0);\n\tvec3 camZ   = vec3( 0.0, 0.0, 1.0);\n\t\n\tvec3 rO = camPos;\n\tvec3 rD = normalize(uv2.x*camX + uv2.y*camY + camZ);\n\tvec3 finalPos = rO;\n\tvec3 albedo = vec3( 0.0, 0.0, 0.0 );\n\tvec3 normal = vec3( 0.0, 0.0, 0.0 );\n    vec4 scatTrans = vec4( 0.0, 0.0, 0.0, 0.0 );\n    traceScene( fragCoord.x>(iResolution.x/2.0),\n        rO, rD, finalPos, normal, albedo, scatTrans);\n\t\n    \n    //lighting\n    vec3 color = (albedo/3.14) * evaluateLight(finalPos, normal) * volumetricShadow(finalPos, LPOS);\n    // Apply scattering/transmittance\n    color = color * scatTrans.w + scatTrans.xyz;\n    \n    // Gamma correction\n\tcolor = pow(color, vec3(1.0/2.2)); // simple linear to gamma, exposure of 1.0\n   \n#ifndef D_DEMO_FREE\n    // Separation line\n    if(abs(fragCoord.x-(iResolution.x*0.5))<0.6)\n        color.r = 0.5;\n#endif\n    \n\tfragColor = vec4(color ,1.0);\n}\n\n\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3625, 3766, 3802, 3802, 4088], [4091, 4091, 4135, 4135, 4343], [4346, 4346, 4400, 4400, 5219], [5222, 5222, 5253, 5253, 5639], [5641, 5641, 5674, 5674, 5791], [5793, 5793, 5842, 5842, 6024], [6026, 6091, 6168, 6168, 6761], [6763, 6763, 6786, 6786, 6815], [6817, 6817, 6867, 6867, 7390], [7392, 7392, 7533, 7533, 9547], [9550, 9550, 9607, 9650, 11039]], "test": "untested"}
{"id": "XlfSDB", "name": "woop", "author": "marina", "description": "woop", "tags": ["woop"], "likes": 1, "viewed": 100, "published": "Public", "date": "1439260292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb(in float h, float s, float l) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n  return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = mod(iTime / 3.0, 2.0) + 1000.0;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float x = uv.x, y = uv.y;\n  float h = sin(t + (1.0/y * sin(x*t - y + sin(tan(x)/1000.0)/100.0)/tan(t)) + tan(t - x * y));\n  float s = 1.0;\n  float l = mod(sin(t + x * x * x + y), 1.0);\n  fragColor = vec4(hsl2rgb(h, s, l), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 173], [175, 175, 230, 230, 549]], "test": "untested"}
{"id": "XlfSDl", "name": "Metaeaux - Glow", "author": "metaeaux", "description": "Volumetric shading with distance fields.", "tags": ["raymarching", "distancefields", "glow", "volumetricshading"], "likes": 9, "viewed": 1700, "published": "Public API", "date": "1440390559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 ambientColor = vec4(0.15, 0.2, 0.32, 1.0);\nconst vec4 skyColor = 0.3 * vec4(0.31, 0.47, 0.67, 1.0);\nconst float PI = 3.14159;\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cube(vec3 p, vec3 size)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(abs(p) - size, vec3(0.0)));\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec3 rotate(vec3 p, float theta)\n{\n    theta *= 2. * 3.14159;\n    mat3 ry = mat3(cos(theta), 0., sin(theta),\n                0., 1., 0.,\n                -sin(theta), 0., cos(theta));\n    return ry * p;\n}\n\nfloat distanceField(vec3 p) {\n    //vec3 rotation = rotate(p, iTime * 0.2);\n    //rotation = rotate(rotation.zxy, iTime * 0.4);\n    //vec3 repeated = repeat(p, vec3(1.));\n    float d1 = torus(p, vec2(.3, .1));\n    return d1;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\n// phong shading\nvec4 phong(vec3 p, vec3 normal, vec3 lightPos, vec4 lightColor)\n{\n\tfloat lightIntensity = 0.0;\n\tvec3 lightDirection = normalize(lightPos - p);\n    \n    // lambert shading\n\tlightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.);\n    \n    // lambert shading\n    vec4 colour = lightColor * lightIntensity;\n    \n    // specular highlights\n    colour += pow(lightIntensity, 32.0) * (1.0 - lightIntensity*0.5);\n        \n    // ambient colour\n    colour += ambientColor * (1.0 - lightIntensity);\n    \n    \n\treturn colour;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 theta = 2. * 3.14159 * (iResolution.xy - iMouse.xy) / iResolution.xy;\n    \n    theta.x += iTime;\n    \n    vec3 camUp = vec3(0., -0.5, 0.);\n    vec3 camForward = vec3(sin(theta.x), sin(theta.y), cos(theta.x));\n    vec3 camRight = cross(camForward, camUp); // vec3(1., 0., 0.);\n    float focalLength = 1.97;\n\n    vec3 ro = -vec3(sin(theta.x), sin(theta.y), cos(theta.x)); //vec3(0., 0., -1.);\n\tvec3 rd = normalize(camForward * focalLength + camRight * uv.x + camUp * uv.y);\n    vec4 color = skyColor;\n\n    float t = 0.0;\n    const int maxSteps = 1000;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = distanceField(p);\n        if(d < 0.0002)\n        {\n            vec3 normal = getNormal(p);\n            color += 0.03*phong(p, normal, vec3(2.0, -2.0, -2.0), vec4(1.0, 0.5, 0.5, 0.01));\n\t\t\tif (color.a >= 1.0) break;\n        }\n\n\n        t += 0.01;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 174, 174, 207], [209, 209, 240, 240, 305], [307, 307, 338, 338, 448], [450, 450, 484, 484, 518], [520, 520, 551, 551, 596], [598, 598, 632, 632, 801], [803, 803, 832, 973, 1029], [1031, 1031, 1055, 1055, 1316], [1318, 1335, 1400, 1400, 1857], [1860, 1860, 1915, 1915, 2938]], "test": "untested"}
{"id": "XlfSWS", "name": "Gravity", "author": "charlieamer", "description": "Shows amount of gravity in interaction with planets/sun.", "tags": ["procedural", "2d", "simulation", "physics", "planets", "gravity"], "likes": 12, "viewed": 1887, "published": "Public API", "date": "1439195578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define numOfPlanets 3\n#define scale 5.0\n\nvec3 planet[numOfPlanets];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy * 0.5;\n    planet[0] = vec3(  center.x,   center.y,   400);\n    planet[1] = vec3(center.x + sin(iTime) * 70.0, center.y + cos(iTime) * 70.0, 50);\n    planet[2] = vec3(center.x - sin(iTime * 1.3) * 120.0, center.y + cos(iTime * 1.3) * 120.0, 100);\n\tvec2 uv = fragCoord.xy;\n    vec2 res = vec2(0,0);\n    for (int i=0;i<numOfPlanets;i++) {\n        vec2 dist = uv - vec2(planet[i]);\n        res += normalize(dist) * (scale * planet[i].z) / (length(dist) * length(dist));\n    }\n    res.x = abs(res.x);\n    res.y = abs(res.y);\n\tfragColor = vec4(length(res),length(res),length(res),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 127, 743]], "test": "untested"}
{"id": "XlfXDB", "name": "AGTestShader", "author": "gerst20051", "description": "Test Shader", "tags": ["test"], "likes": 0, "viewed": 87, "published": "Public", "date": "1439264709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 151]], "test": "untested"}
{"id": "XlfXDl", "name": "Ghost in the noise ", "author": "tomkh", "description": "Based on my previous experiment: MtlSWX\nJust added some colors, animated light and relfections.\nNoise is in fact 4d now - distance to light is affecting 4th dimension.", "tags": ["raymarching", "noise", "distancefield"], "likes": 15, "viewed": 360, "published": "Public", "date": "1440408319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A simple example tracing over value-noise\n// tomkh@2015\n\nconst int iterations = 200;\nconst float dist_eps = .004;\nconst float ray_max = 50.0;\nconst float fog_density = .05;\n\nconst float cam_dist = 8.5;\n\n// Estimated inverse \"steepness\" factor:\nfloat invslope_factor = .9;\n\nvec3 light_pos;\n\n//------------------------------------------------------------------------\n// Some of IQ's noise that is in fact a value-noise (not a gradient-noise)\n// Extended with offset\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x, in float offset )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z + offset*17.0;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//------------------------------------------------------------------------\n\nfloat dField(in vec3 p)\n{\n   // Simply take a noise value * invslope_factor as a distance:\n   p += vec3(.7,1.2,-5.0);\n   \n   // Take distance to light as interpolation factor:\n   vec3 dp = p - light_pos;\n   float m = max(0.0, 3.0 - length(dp)*.5);\n    \n   // Interpolate two noise values:\n   float value;\n   if (m > 0.0) {\n     float o = floor(m);\n     float f = m - o;\n     f = f*f*(3.0-2.0*f);\n     value = mix(noise(p,o),noise(p,o+1.0),f);\n   } else {\n     value = noise(p,0.0);\n   }\n   \n    return (value - .33)*invslope_factor;\n}\n\nvec3 dNormal(in vec3 p)\n{\n   const float eps = .005;\n   const vec3 x_eps = vec3(eps,0,0);\n   const vec3 y_eps = vec3(0,eps,0);\n   const vec3 z_eps = vec3(0,0,eps);\n   return normalize(vec3(\n      dField(p + x_eps) - dField(p - x_eps),\n      dField(p + y_eps) - dField(p - y_eps),\n      dField(p + z_eps) - dField(p - z_eps) ));\n}\n\nvec4 trace(in vec3 ray_start, in vec3 ray_dir, inout float ray_len, inout float light_gather)\n{\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = dField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      \n      vec3 light_dir = light_pos - p;\n      float light_dist = dot(light_dir, light_dir);\n      float light_falloff = (5.0/light_dist)*(1.0-dist);\n      //light_falloff *= texture(iChannel0, normalize(light_dir).xy*.1).x*.5+.5;\n      light_gather += light_falloff*dist; // gather along the ray\n      \n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\nvec4 shade(in vec3 ray_dir, in float ray_len, in float light_gather, in vec4 hit, out vec3 norm)\n{\n   const vec3 ambient = vec3(-.08,.22,.08);\n   const vec3 light_color = vec3(1.,1.,.7);\n   vec3 fog_color = light_color*(light_gather*.07) + ambient;\n   \n   if (hit.w == 0.0) {\n      return vec4(fog_color, 1.0);\n   }\n   \n   norm = dNormal(hit.xyz);\n   vec3 light_dir = light_pos - hit.xyz;\n   float light_dist = dot(light_dir, light_dir);\n   light_dir *= inversesqrt(light_dist);\n   float light_falloff = min(1.5,(5.0/light_dist));\n   float diffuse = max(0.0, dot(norm, light_dir));\n   float spec = max(0.0,dot(reflect(light_dir,norm),ray_dir));\n   spec = pow(spec, 16.0)*.5;\n   diffuse *= light_falloff;\n   spec *= light_falloff;\n\n   vec3 base_color = vec3(.7,.5,.1);\n   //vec3 anorm = abs(norm.xyz);\n   //vec2 uv = (anorm.x>max(anorm.y,anorm.z))?hit.yz:(anorm.y>anorm.z)?hit.xz:hit.xy;\n   //base_color *= texture(iChannel0, uv).x*.1 + .9;\n   vec3 color = mix(ambient,light_color*base_color,diffuse) +\n      spec*vec3(1.,1.,.9);\n   \n   float fog = 1.0 - 1.0/exp(ray_len*fog_density);\n   color = mix(color, fog_color, fog);\n\n   return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   float ang, si, co;\n    \n   float light_anim = iTime*.25;\n   si = sin(light_anim*.6); co = cos(light_anim*.4);\n   light_pos = vec3(sin(light_anim)*3.0*si,co*1.0,si*cos(light_anim*.7)*3.0);\n    \n   //if (iMouse.z > 0.0) {\n   //  invslope_factor = iMouse.y * 2.0 / iResolution.y;\n   //}\n   \n   // Simple rotating camera:\n   ang = (iMouse.z > 0.0) ? -(iMouse.x - iResolution.x*.5)*.003 : sin(iTime*.5)*.05;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   if (iMouse.z > 0.0) {\n      ang = -(iMouse.y - iResolution.y*.5)*.003;\n\t  si = sin(ang); co = cos(ang);\n      cam_mat *= mat4(\n         1., 0., 0., 0.,\n         0., co, si, 0.,\n         0.,-si, co, 0.,\n         0., 0., 0., 1.);\n   }\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n\n   light_pos += vec3(cam_mat*vec4(0., 0., -cam_dist + 3.0, 1.0));\n   \n   vec3 norm;\n   \n   float ray_len = 0.0, light_gather = 0.0;\n   vec4 hit = trace(pos + dir*.25, dir, ray_len, light_gather);\n   vec4 col = shade(dir, ray_len, light_gather, hit, norm);\n   \n   if (hit.w > 0.0) {\n      dir = reflect(dir, norm);\n      pos = hit.xyz + dir*.01;\n      light_gather = 0.0;\n      vec4 hit = trace(pos, dir, ray_len, light_gather);\n      col = mix(col, shade(dir, ray_len, light_gather, hit, norm), .25);\n   }\n   \n   fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 467, 490, 490, 526], [527, 527, 570, 570, 953], [954, 1030, 1055, 1120, 1564], [1566, 1566, 1591, 1591, 1895], [1897, 1897, 1992, 1992, 2550], [2552, 2552, 2650, 2650, 3705], [3707, 3707, 3764, 3764, 5272]], "test": "untested"}
{"id": "XlfXWB", "name": "Red Space (NMS)", "author": "mech4rhork", "description": "No Man's Sky inspired", "tags": ["3d", "raymarching", "distancefields"], "likes": 3, "viewed": 1500, "published": "Public API", "date": "1439244489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t\t\t\t3.14159265359\n\n#define GAMMA \t\t\t2.2\n#define time\t\t\tvec4( iTime*.125, iTime*.25, iTime*1., iTime*5. )\n#define mouse \t\t\tvec2( iMouse.xy / iResolution.xy )\n#define MAX_ITERATIONS\t97\n#define RENDER_INTERVAL\tvec2( 0.1, 11000.0 )\n\n#define MATERIAL_01\t\t1.0\n#define MATERIAL_02\t\t2.0\n#define MATERIAL_03\t\t3.0\n#define MATERIAL_04\t\t4.0\n#define MATERIAL_05\t\t5.0\n#define MATERIAL_06\t\t6.0\n#define MATERIAL_07 \t7.0\n\n#define SHADOWS\n//#define SPACE_STATION\n//#define FREIGHTER\n//#define PLANET\n\n//#define ASTEROID_FIELD // TODO\n\n\nconst float startDelta = RENDER_INTERVAL.x;\nconst float stopDelta = RENDER_INTERVAL.y;\n\n// ________\n// |||||||| gamma correction\nvec3 toGamma( vec3 col ) {\n\treturn pow( col, vec3( 1.0 / GAMMA ) );\n}\n\n// ________\n// |||||||| transformations\nmat3 rotate( mat3 mat, vec3 theta ) {\n    float sx = sin( theta.x ), sy = sin( theta.y ), sz = sin( theta.z ),\n        cx = cos( theta.x ), cy = cos( theta.y ), cz = cos( theta.z );\n\treturn mat *\n        mat3( 1.0, 0.0, 0.0, 0.0, cx, -sin( theta.x ), 0.0, sx, cx ) *\n        mat3( cy, 0.0, sy, 0.0, 1.0, 0.0, -sy, 0.0, cy ) *\n        mat3( cz, -sz, 0.0, sz, cz, 0.0, 0.0, 0.0, 1.0 );\n}\nvec3 rotate( vec3 p, vec3 theta ) {\n    float  cx = cos( theta.x ), sx = sin( theta.x ), cy = cos( theta.y ),\n        sy = sin( theta.y ), cz = cos( theta.z ), sz = sin( theta.z );\n    p.yz *= mat2( cx, -sx, sx, cx ); p.xz *= mat2( cy, -sy, sy, cy ); p.xy *= mat2( cz, -sz, sz, cz );\n    return p;\n}\n\n// ________\n// |||||||| noise\n// by Dave_Hoskins\nfloat hash(float p) {\n\tvec2 p2 = fract(vec2(p) * vec2(443.8975,397.2973));\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n// by iq\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fbm( vec3 p, vec3 scale, vec3 offset ) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60, -0.80,  0.36, -0.48, -0.60, -0.48,  0.64 );\n    vec3 q = scale*p + offset;\n    float f = 0.0;\n   \tf  = 0.5000*noise( q ); q = m*q*2.01;\n   \tf += 0.2500*noise( q ); q = m*q*2.02;\n   \tf += 0.1250*noise( q ); q = m*q*2.03;\n   \tf += 0.0625*noise( q ); q = m*q*2.01;\n\treturn f;\n}\n\n// ________\n// |||||||| primitives - from iq\nfloat sdPlane( vec3 p, vec4 n ) {\n    n = normalize( n );\n    return dot( p, n.xyz ) + n.w;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs( p ) - b;\n  \treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length( p ) - s;\n}\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs( p );\n    float d1 = q.z - h.y;\n    float d2 = max( ( q.x * 0.866025 + q.y * 0.5 ), q.y ) - h.x;\n    return length( max( vec2( d1, d2), 0.0 ) ) + min( max( d1, d2 ), 0.0 );\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs( p );\n    float d1 = q.z - h.y;\n    float d2 = max( q.x * 0.866025 + p.y * 0.5, - p.y ) - h.x * 0.5;\n    return length( max( vec2( d1, d2 ),0.0 ) ) + min( max( d1, d2 ), 0.0 );\n}\nfloat sdCone( vec3 p, vec3 c ) {\n    vec2 q = vec2( length( p.xz ), p.y );\n    float d1 = -p.y - c.z;\n    float d2 = max( dot( q, c.xy ), p.y );\n    return length( max( vec2( d1, d2 ), 0.0 ) ) + min( max( d1, d2 ), 0.0 );\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    return length( vec2( length( p.xz ) - t.x, p.y ) ) - t.y;\n}\n// ----\nvec2 opS( vec2 d1, vec2 d2 ) {\n    return ( -d2.x > d1.x ) ? vec2( -d2.x, d2.y ) : d1;\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\nvec2 opI( vec2 d1, vec2 d2 ) {\n\treturn ( d1.x > d2.x ) ? d1 : d2;\n}\n// ----\nvec2 udPyramid( vec3 p, vec2 s ) {\n    vec3 e = vec3( abs( p.x ), p.y, abs( p.z ) ) - vec3( 0.0, -s.x, 0.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    float an = PI/4.0 * s.y * 0.05;\n    vec2 d = vec2( sdPlane( e - vec3( 0.0, -2.0 * s.x, 0.0 ), vec4( rotate( up, vec3( 0.0, 0.0, PI ) ), 1.0 ) ), 7.1 );   \n   \td = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( an, 0.0, 0.0 ) ), 1.0 ) ),\n            7.1 ) );\n    d = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( 0.0, 0.0, -an ) ), 1.0 ) ),\n            7.1 ) );\n    d = opI(d, vec2(\n            sdPlane( e - vec3( 0.0, -2.0 * s.x, 0.0 ), vec4( rotate( up, vec3( 0.0, 0.0, PI ) ), 1.0 ) ),\n            7.1 ) );   \n    return d;\n}\nvec2 udPyramid2( vec3 p, vec2 s ) {    \n    vec3 e = vec3( abs( p.x ), p.y, abs( p.z ) ) - vec3( 0.0, -s.x, 0.0 );\n    vec3 up = vec3( 0.0, -1.0, 0.0 );\n    float an = ( -PI/2.0 + PI/4.0 ) * s.y * 0.05;\n    vec2 d = vec2(\n        sdPlane( e - vec3( 0.0, 2.0 * s.x, 0.0 ), vec4( rotate( up, vec3( 0.0, 0.0, PI ) ), 1.0 ) ),\n        7.1 );\n   \td = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( an, 0.0, 0.0 ) ), 1.0 ) ),\n            7.1 ) );\n    d = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( 0.0, 0.0, -an ) ), 1.0 ) ),\n            7.1 ) );\n    return d;\n}\nvec2 sdCockpit( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n \tvec3 s;\n    //vec2 handle = 2.0 * mouse - 1.0;\n    \n    s = vec3( abs( p.x ), p.yz );\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.75, 0.0, 2.4 ), vec3( PI/6.0, 0.0, PI/6.5 ) ), vec3( 0.08, 2.0, 0.09 ) ),\n        3.1 ) );\n    d = opS( d, vec2(\n        sdBox( rotate( s - vec3( 1.68, 0.044, 2.383 ), vec3( PI/6.0, 0.0, PI/6.5 ) ), vec3( 0.04, 1.9, 0.045 ) ),\n        3.1 ) );\n    \n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.66, -2.2, 2.5 ), vec3( 0.0, -PI/7.0, 0.0 ) ), vec3( 0.25, 0.9, 2.8 ) ),\n        3.1 ) );\n    d = opS( d, vec2(\n        sdBox( rotate( s - vec3( 1.4, -1.07, 2.5 ), vec3( 0.0, -PI/7.0, 0.0 ) ), vec3( 0.3, 0.3, 2.8 ) ),\n        3.1 ) );\n    \n    d = opU( d, vec2(\n        sdBox( s - vec3( 0.0, 1.57, 1.57 ), vec3( 3.0, 0.1, 0.05 ) ),\n        3.1 ) );\n    d = opU( d, vec2(\n        sdHexPrism( rotate( s - vec3( 1.0, -1.0, 2.85 ), vec3( PI/40.0, 0.0, 0.0 ) ), vec2( 0.5, 0.2 ) ),\n        3.1 ) );\n    d = opU( d, vec2(\n        sdHexPrism( rotate( s - vec3( 0.0, -1.96, 2.8 ), vec3( -PI/32.0, 0.0, 0.0 ) ), vec2( 1.55, 0.33 ) ),\n        3.1 ) );\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 2.2, 1.4, 1.91 ), vec3( -PI/6.0, 0.0, -PI/6.5 ) ), vec3( 0.05, 0.485, 0.03 ) ),\n        3.1 ) );\n    /*d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.65, -1.1, 2.92 ), vec3( -PI/6.0, -PI/20.0, -PI/8.0 ) ), vec3( 0.03, 0.6, 0.07 ) ),\n        3.1 ) );*/\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.85, -1.15, 2.5), vec3( -PI/8.0, -PI/8.0, -PI/6.0 ) ), vec3( 0.03, 0.85, 0.08 ) ),\n        3.1 ) );\n    /*d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 2.0, -2.05, 0.27 ), vec3( -PI/6.0, PI/9.0, -PI/16.0 ) ), vec3( 0.1, 1.4, 1.1 ) ),\n        3.1 ) );*/ // R\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.0, -3.2, 1.9 ), vec3( PI/4.0, 0.0, 0.0 ) ), vec3( 1.484, 1.2, 2.1 ) ),\n        3.1 ) );\n    \n    // monitors\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.0, -1.13, 2.6 ), vec3( PI/4.0, 0.0, 0.0 ) ), vec3( 0.99, 0.3, 0.025 ) ),\n        5.1 ) );\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.53, -1.42, 2.0 ), vec3( -PI/4.0, 0.0, 0.0 ) ), vec3( 0.47, 0.5, 0.05 ) ),\n        6.1 ) );\n    \n    // top\n    s = mod( vec3( abs( p.x * 1.33 ) - 0.2, p.yz - vec2( 0.1 * step( 0.99, abs( p.x ) ), 0.0 ) ), vec3( 2.0, 0.0, 0.0 ) ) - 0.15;\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.2, 1.39, 1.58 ), vec3( PI/4.0, 0.0, 0.0 ) ), vec3( 1.4, vec2( 0.1 ) ) ),\n        3.1 ) );\n    \n    // buttons\n    s = mod( vec3( abs( p.x * 6.0 ) - 0.88, p.yz - vec2( 0.5 * step( 0.99, abs( p.x ) ), 0.0 ) ), vec3( 2.0, 0.0, 0.0 ) ) - 0.074;\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.0, 1.41, 1.59 ), vec3( PI/4.0, 0.0, 0.0 ) ), vec3( 0.67, 0.06, 0.099 ) ),\n        4.1 ) );\n    \n    return d;\n}\nvec2 sdFreighter( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n \t//vec3 s;\n    vec2 handle = 2.0 * mouse - 1.0;\n    \n    /*d = opU( d, vec2(\n        sdBox( p, vec3( 35.0, 15.0, 125.0 ) ),\n        7.1 ) );*/\n    p *= 1.1;\n    d = opU( d, vec2(\n        sdTriPrism( rotate( p * vec3( 0.5, 2.0, 1.0 ), vec3( PI, 0.0, 0.0 ) ), vec2( 23.0, 125.0 ) ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, 10.0, 60.0 ), vec3( 20.0, 33.0, 20.0 ) ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, 40.0, 60.0 ), vec3( 1.5, 30.0, 1.5 ) ),\n        7.1 ) );\n    \n    return d;\n}\nvec2 sdSpaceStation( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n \t//vec3 s;\n    //vec2 handle = 2.0 * mouse - 1.0;\n    \n    d = opU( d, udPyramid( p, vec2( 39.0, 24.0 ) ) );\n    d = opU( d, udPyramid2( p - vec3( 0.0, -155.0, 0.0 ), vec2( 40.0, 24.75 ) ) );\n    d = opU( d, vec2(\n        sdSphere( p - vec3( 0.0, -69.5, 0.0 ), 26.8 ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdSphere( p - vec3( 0.0, -45.5, 0.0 ), 10.6 ),\n        7.1 ) );\n    \n    d = opS( d, vec2(\n        sdBox( p - vec3( 0.0, -186.5, 0.0 ), vec3( 17.0 ) ),\n        7.1 ) );\n    \n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, -169.5, 0.0 ), vec3( 13.8, 6.2, 13.8 ) ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, -175.5, 0.0 ), vec3( 4.0, 15.0, 4.0 ) ),\n        7.1 ) );\n    \n    return d;\n}\nvec2 sdAsteroidField( vec3 p ) { // TODO\n    return vec2( 0.0 );\n}\n\n// ________\n// |||||||| scene\nvec2 map( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n    vec3 s;\n    vec2 handle = mouse;\n    \n    // cockpit\n    d = opU( d, sdCockpit( p ) );\n    \n    // space station\n    #ifdef SPACE_STATION\n    d = opU( d, sdSpaceStation( rotate( p - vec3( -79.0, 212.0, 428.0 ), vec3( -PI/15.0, -PI/2.9, -PI/7.2 ) ) ) );\n    #endif\n    \n    // freighter\n    #ifdef FREIGHTER\n    d = opU( d, vec2( sdFreighter( rotate( p - vec3( 165.0, 85.0, 550.0 ), vec3( PI/6.5, PI/3.25, -PI/16.0 ) ) ) ) );\n    #endif\n    \n    // planet\n    #ifdef PLANET\n    d = opU( d, vec2( sdSphere( p - vec3( 6900.0, 750.0, 7450.0 ), 950.0 ), 2.1 ) );\n    #endif\n        \n    // asteroid field TODO\n    #ifdef ASTEROID_FIELD\n    // TODO\n    #endif\n    \n    // debug\n    /*d = opU( d, vec2(\n        sdBox( rotate( p - vec3( -100.0, -180.0, 400.0 ), vec3( -PI/2.0, 0.0, 0.0 ) ), vec3( 50.0, 1200.0, 50.0 ) ), // TEST BOX\n        1.1 ) );\n    d = opU( d, vec2(\n        sdBox( rotate( p - vec3( 100.0, -180.0, 400.0 ), vec3( 0.0, 0.0, 0.0 ) ), vec3( 20.0, 250.0, 20.0 ) ), // TEST BOX\n        1.1 ) );\n    d = opU( d, vec2(\n        sdPlane( p - vec3( 0.0, -200.0, 0.0 ), vec4( 0.0, 1.0, 0.0, 1.0 ) ),\n        1.1 ) );*/\n    \n    return d;\n}\n\n// ________\n// |||||||| raymarching\nvec2 castRay( vec3 ro, vec3 rd ) {\n    vec2 delta = vec2( startDelta, -100.0 );\n    float maxDist = 0.002;\n    for( int i = 0; i < MAX_ITERATIONS; i++ ) {\n        vec2 dist = map( ro + rd * delta.x );\n        if( dist.x <= maxDist || dist.x > stopDelta ) break;\n        delta = vec2( delta.x + dist.x, dist.y );\n    }\n    return delta;\n}\n\nvec3 calcNormal( vec3 pos, float delta ) {\n    vec2 unit = vec2( 1.0, 0.0 );\n    return normalize( vec3(\n        map( pos + unit.xyy * delta ).x - map( pos - unit.xyy * delta ).x,\n        map( pos + unit.yxy * delta ).x - map( pos - unit.yxy * delta ).x,\n        map( pos + unit.yyx * delta ).x - map( pos - unit.yyx * delta ).x\n    ) );\n}\n\n// from \"Star Nest\" by Kali  --  https://www.shadertoy.com/view/XlfGRj\n// ------------------------------\n// Copyright Pablo Romn Andrioli\n// ------------------------------\nvec3 StarNest_by_Kali() {\n    \n    // parameters\n    #define iterations \t15\n\t#define formuparam \t0.53\n\t#define volsteps \t11\n\t#define stepsize \t0.25\n\t#define zoom   \t\t0.500\n\t#define tile   \t\t0.850\n\t#define speed  \t\t0.010 \n\t#define brightness \t0.0015\n\t#define darkmatter \t0.300\n\t#define distfading \t0.730\n\t#define saturation \t0.99\n    \n\t//get coords and direction\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\n\t//mouse rotation\n\tfloat a1=.5+0.7151277;\n\tfloat a2=.8+0.2445;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(0.0,0.0,100.5);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=fade;\n\t\tv+=vec3(s*s*s*s,s*s,s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;  \n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec3(v*.01);\n}\n\nfloat getFog( float dist ) {\n    return 1.0 - exp( -dist * dist * 0.000003 );\n}\n\nvec3 getSkyColor( vec3 lig, vec3 rd ) {    \n    vec3 uv = vec3( gl_FragCoord.xy / iResolution.xy, 10.335454 ) + vec3( -1.0, 0.05, 0.03 );\n    \n    vec3 red = vec3( 0.67, 0.02, 0.01 );\n    vec3 color = red; // vec3( 0.89, 0.021, 0.02 ); // background\n        \n    float sun = 2.2 * pow( clamp( dot( rd, lig )*1.0055, 0.0, 1.0 ), 260.0 );\n    float halo = 3.0 * pow( clamp( sqrt( dot( rd, lig ) ), 0.0, 1.0 ), 150.0 ); // 0.8 * pow( clamp( length( lig - rd ), 0.0, 1.0 ), 0.99 );\n    vec3 stars = StarNest_by_Kali();\n    \n    // noise\n    float n = fbm( uv, vec3( 8.6 ), vec3( 0.0 ) );\n    n *= fbm( uv, vec3( 2.0, n*1.14, 5.0 ), vec3( n * 3.112 ) );\n    float n2 = exp(-n*n*21.0);\n    \n    color *= 0.5 + n2;\n    color = mix( color, stars * vec3( 1.0, 0.5, 0.6 ), n );\n    color += 0.5 * red;\n    color += 0.8 * halo + 0.4 * halo * red;\n    color += sun * vec3( 0.94, 0.93, 0.85 );\n    \n    /*\n    color *= vec3( n*n, 0.1 * n, n );\n    //color += 0.033 * mix( stars, color, 1.0 - halo * 10.0 );\n    color.gb *= n;\n    color += sun * vec3( 0.94, 0.93, 0.81 );\n    color += 0.95 * vec3( 0.89, 0.021, 0.02 ) * (0.77 + sun);*/\n    \n    //return vec3( exp(-n*n*25.0) * stars * vec3( 0.99, 0.025, 0.01 ) );\n\treturn color;\n}\n\n// by iq\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in int samples ) {\n\tfloat res = 1.0;\n    float t = mint;\n    float stepDist = ( tmax - mint ) / float( samples );\n    for( int i = 0; i < 32; i++ ) {\n\t\tfloat h = map( ro + rd * t ).x;\n        res = min( res, 8.0 * h / t );\n        t += clamp( h, stepDist, 1e10 );\n        if( h < 0.001 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n// by iq\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < 4; i++ ) {\n        float hr = 0.01 + 0.03 * float( i );\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -( dd - hr ) * sca;\n        sca *= 0.99;\n    }\n    return clamp( 1.0 - 4.0 * occ, 0.0, 1.0 );    \n}\nfloat calcSSS( in vec3 pos, in vec3 lig ) {\n    float sss = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < 4; i++ ) {\n        float delta = 0.01 + 0.03 * float( i );\n        vec3 sspos = pos + lig * delta;\n        float dist = map( sspos ).x;\n        sss += -( dist - delta ) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 4.0*sss, 0.0, 1.0 );\n}\n\n// ________\n// |||||||| rendering <_______________________________________________________________\nvec3 render( vec3 ro, vec3 rd ) {\n    vec3 color = vec3( 0.0 );\n    \n    vec2 res = castRay( ro, rd );\n    float dist = res.x;\n\tfloat material = res.y;\n    vec3 pos = ro + rd * dist;\n    \n    vec3 lightDir = normalize( vec3( 0.93, 0.5, 3.0 ) );\n    vec3 lightColor = vec3( 1.0, 0.942, 0.77 );\n    vec3 skyColor = getSkyColor( lightDir, rd );\n    vec3 ambientColor = vec3( 0.89, 0.021, 0.02 );\n    \n    if( dist > stopDelta )\n        return getSkyColor( lightDir, rd );\n    else {\n    \tvec3 nor = calcNormal( pos, 0.001);\n    \n    \tfloat dif = clamp( dot( nor, lightDir ), 0.0, 1.0 ), dif2;\n    \tfloat spe = pow( clamp( dot( reflect( -lightDir, nor ), -rd ), 0.0, 1.0 ), 10.0 );\n    \tfloat amb = 1.0;\n    \tfloat fre = pow( clamp( 1.0 + dot( nor, rd ), 0.0, 1.0 ), 5.0 );\n        \n        vec3 brdf = vec3( 0.0 );\n        \n        if( material - MATERIAL_01 < 0.5 ) { // MATERIAL : space station\n            color = vec3( 0.27, 0.25, 0.34 ) * 0.4;\n            //dif *= calcSoftShadow( pos, lightDir, 0.1, 10.0, 4 );\n            \n            brdf += 1.2 * dif * lightColor; // lambert\n    \t\tbrdf += 1.2 * spe * lightColor * dif; // blinn phong\n    \t\tbrdf += 0.1 * amb * ambientColor; // ambient\n    \t\tbrdf += 1.0 * fre * lightColor; // fresnel schlick\n            \n            color *= brdf;\n            color = mix( color, vec3( 0.89, 0.021, 0.02 ) * 100.0 / dist, getFog( dist ) ); // fog\n        }\n        \n        else if( material - MATERIAL_02 < 0.5 ) { // MATERIAL : planet            \n            float n = fbm( pos, vec3( 2.0, 10.0, 2.0 ) * 0.0006, vec3( -6.0 ) );\n            n += 0.5 * fbm( vec3( n * pos.x, pos.y, n * pos.z ) * 0.0006, vec3( 5.0 ), vec3( 0.0 ) );\n            \n            color = vec3( n * n );\n            nor = calcNormal( pos, 0.01);\n            vec3 pll = vec3( -1.0, 0.5, 2.5 ); // planet light\n            float dif2 = clamp( dot( nor, pll ), 0.0, 1.0 );\n            fre += mix( fre, 0.7, step( 0.25, fre ) );\n            \n            brdf += 1.45 * dif2 * lightColor; // lambert\n    \t\tbrdf += 1.9 * spe * lightColor * dif; // blinn phong\n    \t\tbrdf += 0.2 * amb * ambientColor; // ambient\n    \t\tbrdf += 1.4 * fre * vec3( 0.5, 1.0, 0.8 ) * lightColor; // fresnel schlick\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_03 < 0.5 ) { // MATERIAL : cockpit\n            color = vec3( 0.08 );\n            vec3 cpl = vec3( 0.0, -1.0, -0.5 ); // cockpit light\n            float dif2 = clamp( dot( nor, cpl ), 0.0, 1.0 );\n            float occ = calcAO( pos, nor );\n            #ifdef SHADOWS\n            dif *= calcSoftShadow( pos, lightDir, 0.02, 1.0, 8 );\n            #endif\n            \n            brdf += 1.9 * dif * lightColor; // lambert\n    \t\tbrdf += 1.5 * spe * ambientColor * dif; // blinn phong\n    \t\tbrdf += 0.2 * amb * ambientColor * occ; // ambient\n    \t\tbrdf += 0.3 * fre * ambientColor * occ; // fresnel schlick\n            brdf += 0.6 * dif2 * ambientColor; // lambert\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_04 < 0.5 ) { // MATERIAL : cockpit / buttons / yellow\n            color = vec3( 1.0, 0.9, 0.16 );\n            vec3 cpl = vec3( 0.0, -1.0, -0.5 ); // cockpit light direction\n            float dif2 = clamp( dot( nor, cpl ), 0.0, 1.0 );\n            \n            brdf += 0.2 * dif2 * lightColor; // lambert\n    \t\tbrdf += 1.0 * amb * ambientColor; // ambient\n            brdf += 0.15; // emission\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_05 < 0.5 ) { // MATERIAL : cockpit / monitors / orange\n            color = vec3( 0.5, 0.184, 0.184 );\n            vec3 cpl = vec3( 0.0, -1.0, -0.5 ); // cockpit light direction\n            float dif2 = clamp( dot( nor, cpl ), 0.0, 1.0 );\n            \n            brdf += 0.4 * dif2 * lightColor; // lambert\n    \t\tbrdf += 0.8 * amb * ambientColor; // ambient\n            brdf += 0.05; // emission\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_06 < 0.5 ) { // MATERIAL : cockpit / monitors / black\n            return vec3( 0.0 );\n        }\n        \n        else if( material - MATERIAL_07 < 0.5 ) { // MATERIAL : dark / metallic\n            color = vec3( 0.07, 0.07, 0.09 );\n            float sss = calcSSS( pos, lightDir );\n            \n            brdf += 1.3 * dif * lightColor; // lambert\n    \t\tbrdf += 1.3 * spe * ambientColor * dif; // blinn phong\n    \t\tbrdf += 0.5 * amb * ambientColor; // ambient\n    \t\tbrdf += 1.2 * fre * ambientColor; // fresnel schlick\n            brdf += 1.1 * sss * lightColor; \n            \n            color *= brdf;\n        }\n        \n        else { // DEFAULT MATERIAL\n            return vec3( 1.0, 0.0, 1.0 );\n        }\n    }\n    \n    \n    return color;\n}\n\n// ________\n// |||||||| camera\nmat3 getCameraMatrix( vec3 camFow ) {\n    vec3 forward = normalize( camFow );\n    vec3 up = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    vec3 right = normalize( cross( up, forward ) );\n    \n    mat3 mat = mat3( right, up, forward );\n    \n    // shaky cam effect / mouse animation\n    mat = rotate(\n        mat,\n        vec3(\n            //0.005 * PI * sin( iTime * 4.0 ) - ( iMouse.xy / iResolution.xy ).y * PI * 0.3,\n            0.002 * PI * sin( iTime * 2.0 ),\n            0.001 * PI * ( cos( iTime * 1.0 ) + sin( iTime * 1.0 ) ) - 0.2 * ( 2.0 * mouse.x - 1.0 ) * mouse.y,\n            0.0 * PI * cos( iTime*2.0 ) ) );\n    \n    return mat;\n}\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n\tvec2 uv = i.xy / iResolution.xy;\n    vec2 pixel = uv * 2.0 - 1.0;\n    float viewRatio = iResolution.x / iResolution.y;\n    pixel.x *= viewRatio;\n    \n    float deltaRot = mouse.x * PI * 2.0;\n\n    //vec3 camPos = vec3( -7.0 * cos( deltaRot ) - 2.0 * mouse.y, 0.0 + mouse.y * 6.0, -7.0 * sin( deltaRot ) - 2.0 * mouse.y );\n    //vec3 camFow = vec3( 1.0 * cos( deltaRot ), 0.0, 1.0 * sin( deltaRot ) );\n    vec3 camPos = vec3( 0.0, 0.125, -1.0 );\n    vec3 camFow = vec3( 0.0, 0.0, 1.0 );\n    mat3 camMat = getCameraMatrix( camFow );\n    \n    vec3 rayDir = camMat * normalize( vec3( pixel, viewRatio + ( 0.5 * mouse.y - 0.1 ) ) );\n    \n    // scene\n    vec3 color = render( camPos, rayDir );\n    \n    // vignette\n    vec2 q = uv, c = q - 0.5;\n    q += length( c ) * c * 2.0;\n    float vig = 0.0 + 0.92 * clamp(\n        pow( 1.0 - 0.4 * length( ( q - vec2( 0.5, 0.25 ) ) * vec2( viewRatio * 0.5, 1.5 ) ), 1.1 ),\n        0.0, 1.0 );\n    vig *= 0.4 + pow( uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 0.1 );\n    \n    color *= vig;\n    color *= vec3( 1.17, 0.51, 0.53 );\n    \n    o = vec4( toGamma( color ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[616, 657, 683, 683, 726], [728, 768, 805, 805, 1153], [1154, 1154, 1189, 1189, 1453], [1455, 1504, 1525, 1525, 1643], [1644, 1653, 1679, 1679, 2046], [2047, 2047, 2093, 2093, 2413], [2415, 2460, 2493, 2493, 2553], [2554, 2554, 2585, 2585, 2688], [2689, 2689, 2724, 2724, 2754], [2755, 2755, 2791, 2791, 2983], [2984, 2984, 3020, 3020, 3216], [3217, 3217, 3249, 3249, 3440], [3442, 3442, 3475, 3475, 3539], [3540, 3548, 3578, 3578, 3636], [3637, 3637, 3667, 3667, 3704], [3705, 3705, 3735, 3735, 3772], [3773, 3781, 3815, 3815, 4488], [4489, 4489, 4524, 4524, 5077], [5078, 5078, 5104, 5104, 7937], [7938, 7938, 7966, 7966, 8541], [8542, 8542, 8573, 8573, 9341], [9342, 9342, 9374, 9382, 9408], [9410, 9440, 9460, 9460, 10642], [10644, 10680, 10714, 10714, 11017], [11019, 11019, 11061, 11061, 11358], [11360, 11536, 11561, 11584, 12998], [13000, 13000, 13028, 13028, 13079], [13081, 13081, 13120, 13120, 14297], [14299, 14308, 14402, 14402, 14733], [14734, 14743, 14785, 14785, 15092], [15093, 15093, 15136, 15136, 15452], [15454, 15553, 15586, 15586, 20334], [20336, 20367, 20404, 20404, 21004], [21006, 21006, 21047, 21047, 22159]], "test": "untested"}
{"id": "XllSWf", "name": "Hyperbolic Mario", "author": "paniq", "description": "Using atanh to compress infinite space onto a disc, greatly expanding visibility; Space can be compressed along any axis, e.g. just along the x-axis (uncomment POLAR to test)", "tags": ["mattdamon"], "likes": 17, "viewed": 2845, "published": "Public API", "date": "1440212690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is just a small modification that changes the fragment coordinate\n// before the rest of the processing.\n\n// uncomment for horizontal compression only\n#define POLAR\n\n// uncomment for rectification when POLAR is enabled\n// #define RECTIFY\n\n// Original: \n// [SIG15] Mario World 1-1\n// by Krzysztof Narkowicz @knarkowicz\n// \n// Intersting findings from original NES Super Mario Bros.:\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\n// -Overworld (main theme) drum sound uses only the APU noise generator\n\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n\nconst float MARIO_SPEED\t = 89.0;\nconst float GOOMBA_SPEED = 32.0;\nconst float INTRO_LENGTH = 2.0;\n\nvoid SpriteBlock( inout vec3 color, float x, float y )\n{\n    // black\n    float idx = 1.0;\n    \n    // light orange\n    idx = x < y ? 3.0 : idx;\n    \n    // dark orange\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\n    idx = x == 15.0 - y ? 2.0 : idx;\n    \n    color = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteHill( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    // dark green\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\n    \n    // black\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n}\n\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\n{\n    float offset = h * 16.0;\n\n    // light green\n\tfloat idx = 3.0;\n    \n    // dark green\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \n    \n    // black\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \n    \n    // transparent\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\n\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\n\tcolor = idx == 2.0 ? colorB \t\t: color;\n\tcolor = idx == 3.0 ? colorC \t\t: color;\n}\n\nvoid SpriteFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? 43690.0 : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\n{\n\tfloat idx = 0.0;\n\n    // second frame is flipped first frame\n    x = frame == 1.0 ? 15.0 - x : x;\n\n    if ( frame <= 1.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\n        idx = y ==  6.0 ? 43690.0 : idx;\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\n\t\tidx = y == 3.0 ? 43690.0 : idx;\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\n}\n\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\n{    \n\tfloat idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\n    }\n\telse\n\t{\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\n\t}\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 0.0 ? 21845.0 : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\n}\n\nvoid SpriteMushroom( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\n\tidx = y == 5.0 ? 43690.0 : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGround( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\n\tidx = y == 7.0 ? 1360.0  : idx;\n\tidx = y == 6.0 ? 6836.0  : idx;\n\tidx = y == 5.0 ? 27309.0 : idx;\n\tidx = y == 4.0 ? 27309.0 : idx;\n\tidx = y == 3.0 ? 27305.0 : idx;\n\tidx = y == 2.0 ? 27305.0 : idx;\n\tidx = y == 1.0 ? 6820.0  : idx;\n\tidx = y == 0.0 ? 1360.0  : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 3.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 4.0 )\n    {\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\n    }\n    else if ( frame == 5.0 )\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\n    }\n    else if ( frame == 6.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \n}\n\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n    }\n    \n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBrick( inout vec3 color, float x, float y )\n{    \n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \n    float xmod8 = floor( mod( x, 8.0 ) );\n    float ymod8 = floor( mod( y, 8.0 ) );\n    \n    // dark orange\n    float idx = 2.0;\n   \n    // black\n    idx = ymod4 == 0.0 ? 1.0 : idx;\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\n\n    // light orange\n    idx = y == 15.0 ? 3.0 : idx;\n\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid DrawCastle( inout vec3 color, float x, float y )\n{\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\n\t{\n\t\tfloat ymod4    = mod( y, 4.0 );\n\t\tfloat xmod8    = mod( x, 8.0 );\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\n\t\tfloat ymod8    = mod( y, 8.0 );\n\n\t\t// dark orange\n\t\tfloat idx = 2.0;\n\n\t\t// black\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \n\n\t\t// white\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\n\n\t\t// transparent\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\n\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n\t}\n}\n\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\n{\n    if ( x >= 0.0 && x <= 15.0 )\n    {\n        SpriteKoopa( color, x, y, frame );\n    }\n}\n\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\n{\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\n    DrawKoopa( color, x, worldY - 16.0, frame );    \n}\n\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\n{\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\n    t = 1.0 - abs( 2.0 * t - 1.0 );\n\n    questionY -= floor( t * 8.0 );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {            \n    \tif ( time >= questionHitTime )\n        {                \n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n            {\n                color = RGB( 231, 90, 16 );\n            }\n        }\n        else\n        {\n         \tSpriteQuestion( color, questionX, questionY, questionT );\n        }\n    }\n}\n\nvoid DrawW( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 || x >= 10.0 ) \n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawO( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\n             || ( x >= 2.0 && x <= 4.0 )\n             || ( x >= 9.0 && x <= 11.0 )\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawR( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 )\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\n             || ( x >= 8.0  && y <= 1.0 )\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawL( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( x <= 3.0 || y <= 1.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawD( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n    \tcolor = RGB( 255, 255, 255 );        \n        \n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\n           )\n        {\n            color = RGB( 0, 0, 0 );\n        }\n    }\n}\n\nvoid Draw1( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( y <= 1.0 )\n             || ( x >= 5.0 && x <= 8.0 )\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawM( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( y >= 4.0 && y <= 7.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\n{\n    color = RGB( 0, 0, 0 );\n        \n    float offset \t= 18.0;     \n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\n    float marioX\t= textX - offset * 4.0;\n    float marioY\t= textY + 16.0 * 3.0;\n\t\n    DrawW( color, textX - offset * 0.0, textY );\n    DrawO( color, textX - offset * 1.0, textY );\n    DrawR( color, textX - offset * 2.0, textY );\n    DrawL( color, textX - offset * 3.0, textY );\n    DrawD( color, textX - offset * 4.0, textY );\n    Draw1( color, textX - offset * 6.0, textY );\n    DrawM( color, textX - offset * 7.0, textY );\n    Draw1( color, textX - offset * 8.0, textY );\n    \n    if ( marioX >= 0.0 && marioX <= 15.0 )\n    {\n    \tSpriteMario( color, marioX, marioY, 4.0 );\n    }\n}\n\nfloat CoinAnimY( float worldY, float time, float coinTime )\n{\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\n}\n\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\n{\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\n}\n\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\n{\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\n}\n\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\n{\n    float mushroomPauseStart \t= 16.25;    \n    float mushroomPauseLength \t= 2.0;    \n    float flagPauseStart\t\t= 38.95;\n    float flagPauseLength\t\t= 1.5;\n\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\n    float worldX \t\t= pixelX + cameraX;\n    float worldY  \t\t= pixelY - 8.0;\n    float tileX\t\t\t= floor( worldX / 16.0 );\n    float tileY\t\t\t= floor( worldY / 16.0 );\n    float tile2X\t\t= floor( worldX / 32.0 );\n    float tile2Y\t\t= floor( worldY / 32.0 );    \n    float worldXMod16\t= mod( worldX, 16.0 );\n    float worldYMod16 \t= mod( worldY, 16.0 );\n\n\n    // default background color\n    color = RGB( 92, 148, 252 );\n\n    \n    // draw hills\n    float bigHillX \t = mod( worldX, 768.0 );\n    float smallHillX = mod( worldX - 240.0, 768.0 );\n    float hillX \t = min( bigHillX, smallHillX );\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\n    SpriteHill( color, hillX, hillY );\n\n\n    // draw clouds and bushes\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \n    float scCloudX  = min( sc1CloudX, sc2CloudX );\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\n    float sCloudX\t= min( scCloudX, sbCloudX );\n    float mCloudX\t= min( mcCloudX, mbCloudX );\n    float lCloudX\t= min( lcCloudX, lbCloudX );\n    float cloudX\t= min( cCloudX, bCloudX );\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\n    {\n        if ( cloudSeg == 1.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\n        }\n        if ( cloudSeg == 2.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\n        }\n        \n    \tSpriteCloud( color, cloudX, cloudY, isBush );\n    }\n\n    \n    \n    // draw flag pole\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \n    {\n        color = RGB( 189, 255, 24 );\n    }\n    \n    // draw flag\n    float flagX = worldX - 3160.0;\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\n    if ( flagX >= 0.0 && flagX <= 15.0 )\n    {\n    \tSpriteFlag( color, flagX, flagY );\n    }     \n    \n    // draw flagpole end\n    float flagpoleEndX = worldX - 3172.0;\n    float flagpoleEndY = worldY - 176.0;\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\n    {\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\n    }\n    \n    \n\n    // draw blocks\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\n         || ( tileX == 198.0 && tileY == 1.0 )\n       )\n    {\n        SpriteBlock( color, worldXMod16, worldYMod16 );\n    }\n    \n    \n    // draw pipes\n    float pipeY = worldY - 16.0;  \n    float pipeH\t= 0.0;    \n    float pipeX = worldX - 179.0 * 16.0;\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 163.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 57.0 * 16.0;\n        pipeH = 2.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 46.0 * 16.0;\n        pipeH = 2.0;\n    } \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 38.0 * 16.0;\n        pipeH = 1.0;\n    }         \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 28.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\n\t{\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\n\t}\n    \n    \n    // draw mushroom\n    float mushroomStart = 15.7;    \n    if ( time >= mushroomStart && time <= 17.0 )\n    {\n        float jumpTime = 0.5;\n        \n        float mushroomX = worldX - 1248.0;\n        float mushroomY = worldY - 4.0 * 16.0;\n        if ( time >= mushroomStart )\n        {\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\n        }\n        if ( time >= mushroomStart + 0.5 )\n        {\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\n        }\n        if ( time >= mushroomStart + 0.5 + 0.4 )\n        {\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\n        }\n        \n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\n        {\n        \tSpriteMushroom( color, mushroomX, mushroomY );\n        }\n    }\n\n    \n    // draw coins\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\n    float coinX \t= worldX - 2720.0;\n    float coinTime \t= 33.9;    \n    float coinY \t= CoinAnimY( worldY, time, coinTime );\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 1696.0;\n    \tcoinTime \t= 22.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \n    }\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 352.0;\n    \tcoinTime \t= 5.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\n    } \n    \n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\n    {   \n        SpriteCoin( color, coinX, coinY, coinFrame );\n    }\n\n    \n    // draw questions\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\n    }\n    \n    \n    // draw hitted questions\n    float questionHitTime \t= 33.9;\n    float questionX \t\t= worldX - 2720.0;\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 22.4;\n        questionX\t\t= worldX - 1696.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 15.4;\n        questionX\t\t= worldX - 1248.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 5.3;\n        questionX\t\t= worldX - 352.0;\n    }    \n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {\n    \tSpriteQuestion( color, questionX, questionY, questionT );\n    }\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n    {\n        color = RGB( 231, 90, 16 );\n    }    \n\n    \n    // draw bricks\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteBrick( color, worldXMod16, worldYMod16 );\n    }   \n    \n    \n    // draw castle flag\n    float castleFlagX = worldX - 3264.0;\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\n    {\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\n\t}\n    \n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\n\n    // draw ground\n    if ( tileY <= 0.0\n         && !( tileX >= 69.0  && tileX < 71.0 )\n         && !( tileX >= 86.0  && tileX < 89.0 ) \n         && !( tileX >= 153.0 && tileX < 155.0 ) \n       )\n    {\n        SpriteGround( color, worldXMod16, worldYMod16 );\n    }    \n    \n\n    // draw Koopa\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\n    \n    \n    // draw stomped walking Goombas\n    float goombaY \t\t\t= worldY - 16.0;        \n    float goombaLifeTime \t= 26.3;\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 25.3;\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n\t\tgoombaLifeTime \t= 23.5;\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n        goombaLifeTime \t= 20.29;\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 10.3;\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    }\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }    \n    \n    // draw walking Goombas\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }\n    \n\n    \n    // Mario jump\n    float marioBigJump1 \t= 27.1;\n    float marioBigJump2 \t= 29.75;\n    float marioBigJump3 \t= 35.05;    \n    float marioJumpTime \t= 0.0;\n    float marioJumpScale\t= 0.0;\n    \n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\n    \n    float marioJumpOffset \t\t= 0.0;\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\n    {\n        float t = ( time - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n    \n    // Mario land\n    float marioLandTime \t= 0.0;\n    float marioLandAplitude = 0.0;\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\n    \n    float marioLandLength = marioLandAplitude / 120.0;\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\n    {\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\n    }\n    \n    \n    // Mario flag jump\n    marioJumpTime \t\t= flagPauseStart - 0.3;\n    marioJumpLength \t= 1.5  * 0.45;\n    marioJumpAmplitude\t= 76.0 * 0.45;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \n    {\n        float time2 = time;\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \n        {\n            time2 = flagPauseStart;\n        }\n        else if ( time >= flagPauseStart )\n        {\n            time2 = time - flagPauseLength;\n        }\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n\n    // Mario base (ground offset)\n    float marioBase = 0.0;\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\n    {\n        marioBase = 16.0 * 3.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\n    {\n        marioBase = 16.0 * 7.0;\n    }\n\n    float marioX\t\t= pixelX - 112.0;\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\n    {\n    \tmarioFrame = 1.0;\n    }    \n    if ( time > mushroomPauseStart + 0.7 )\n    {\n        float t = time - mushroomPauseStart - 0.7;\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\n        {\n            // super mario offset\n            marioFrame += 4.0;\n        }\n    }    \n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\n    {\n        SpriteMario( color, marioX, marioY, marioFrame );\n    }\n}\n\nvec2 CRTCurveUV( vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid DrawVignette( inout vec3 color, vec2 uv )\n{    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\n\nvoid DrawScanline( inout vec3 color, vec2 uv )\n{\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nvoid RectifyCircle(inout vec2 p) {\n    p *= 2.0;\n    vec2 q = vec2(\n        p.x * sqrt(1.0 - 0.5*p.y*p.y),\n        p.y * sqrt(1.0 - 0.5*p.x*p.x)\n        );\n    p = q;\n    p /= 2.0;\n}\n\nvoid HyperbolicDisc(inout vec2 fragCoord) {\n    fragCoord -= iResolution.xy * 0.5;\n#ifdef RECTIFY\n    fragCoord /= iResolution.xy;\n    RectifyCircle(fragCoord);\n#else\n    fragCoord /= iResolution.x;\n#endif\n    float r = length(fragCoord);\n    vec2 d = fragCoord / r;\n    fragCoord = d * atanh(r * 2.0) / 2.0;\n#ifdef RECTIFY\n    fragCoord *= iResolution.xy;\n#else\n    fragCoord *= iResolution.x;\n#endif\n    fragCoord += iResolution.xy * 0.5;\n}\n\nvoid HyperbolicX(inout vec2 fragCoord) {\n    fragCoord /= iResolution.xy;\n    fragCoord.x -= 0.5;\n    fragCoord.x = atanh(fragCoord.x * 2.0) / 2.0;\n    fragCoord.x += 0.4;\n    fragCoord *= iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef POLAR\n    HyperbolicDisc(fragCoord);\n#else\n    HyperbolicX(fragCoord);\n#endif\n\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\n    float resMultX  = floor( iResolution.x / 224.0 );\n    float resMultY  = floor( iResolution.y / 192.0 );\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\n    \n    \n    float time\t\t\t= iTime;\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\n\n    vec3 color = RGB( 92, 148, 252 );\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\n    if ( time < INTRO_LENGTH )\n    {\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\n    }    \n\n    \n   \n\t//fragColor.xyz \t= vec3(og,0.0);\n    fragColor.xyz \t= color;\n    fragColor.w\t\t= 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 1006, 1062, 1075, 1416], [1418, 1418, 1473, 1473, 2866], [2868, 2868, 2932, 2932, 4019], [4021, 4021, 4091, 4091, 6510], [6512, 6512, 6567, 6567, 7599], [7601, 7601, 7662, 7662, 8655], [8657, 8657, 8727, 8727, 10541], [10543, 10543, 10612, 10612, 13801], [13803, 13803, 13871, 13871, 15019], [15021, 15021, 15080, 15080, 16174], [16176, 16176, 16233, 16233, 17350], [17352, 17352, 17414, 17414, 17886], [17888, 17888, 17957, 17957, 30418], [30420, 30420, 30488, 30488, 34244], [34246, 34246, 34302, 34302, 34807], [34809, 34809, 34864, 34864, 36235], [36237, 36237, 36304, 36304, 36394], [36396, 36396, 36499, 36499, 36616], [36618, 36618, 36746, 36746, 37362], [37364, 37364, 37414, 37414, 37797], [37799, 37799, 37849, 37849, 38219], [38221, 38221, 38271, 38271, 38751], [38753, 38753, 38803, 38803, 38971], [38973, 38973, 39023, 39023, 39469], [39471, 39471, 39521, 39521, 39807], [39809, 39809, 39859, 39859, 40031], [40033, 40033, 40126, 40126, 40929], [40931, 40931, 40992, 40992, 41119], [41121, 41121, 41193, 41193, 41327], [41329, 41329, 41413, 41413, 41497], [41499, 41499, 41613, 41613, 58132], [58134, 58134, 58162, 58162, 58316], [58318, 58318, 58366, 58366, 58526], [58528, 58528, 58576, 58576, 58822], [58824, 58824, 58858, 58858, 59006], [59008, 59008, 59051, 59051, 59450], [59452, 59452, 59492, 59492, 59658], [59660, 59660, 59717, 59717, 60641]], "test": "untested"}
{"id": "XllSzs", "name": "plants", "author": "miloszmaki", "description": "lifecycle of plants, made for competition on warsztat.gd\nthis is one of my first attempts on raymarching, any ideas on how to optimize it are welcome (or maybe my poor notebook is the problem)", "tags": ["3d", "raymarching", "warsztat"], "likes": 5, "viewed": 1760, "published": "Public API", "date": "1439049407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_PLANTS_SQRT = 3;\nconst float LIFE_TIME = 10.0;\nconst vec2 DIMENSIONS = vec2(20);\n#define REPEAT\n\nconst int RAYMARCH_ITER = 50;\nconst float RAYMARCH_EPS = 0.01;\nconst float DITHERING = 2.0;\n\nconst float PI = 3.14159265;\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat rand(float x) { return fract(sin(x * 42.5723) * 12571.1385); }\nfloat rand(vec2 x) { return fract(sin(dot(x, vec2(13.3571,65.1495))) * 32718.2741); }\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = p - i;\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( rand( i + vec2(0,0) ), \n                     rand( i + vec2(1,0) ), u.x),\n                mix( rand( i + vec2(0,1) ), \n                     rand( i + vec2(1,1) ), u.x), u.y);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = x - p;\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( rand(n+  0.0), rand(n+  1.0),f.x),\n                   mix( rand(n+157.0), rand(n+158.0),f.x),f.y),\n               mix(mix( rand(n+113.0), rand(n+114.0),f.x),\n                   mix( rand(n+270.0), rand(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat dPlane(vec3 p) { return p.y; }\nfloat dSphere(vec3 p, float r) { return length(p) - r; }\nfloat dBox(vec3 p, vec3 s) { return length(max(abs(p) - s, 0.)); }\nfloat dRoundBox(vec3 p, vec3 s, float r) { return length(max(abs(p) - s, 0.)) - r; }\n\nvec2 dUnion(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nvec3 pMov(vec3 p, vec3 t) { return p - t; }\nvec3 pRep(vec3 p, vec3 s) { return mod(p+.5*s, s) - .5*s; }\nvec3 pRotY(vec3 p, float a) { float s=sin(a), c=cos(a); return vec3(mat2(c,-s,s,c)*p.xz, p.y).xzy; }\n\nvoid addLeaf(inout vec2 d, vec3 pos, vec3 ext, float skew, float mtl)\n{\n    pos.y -= ext.y;\n    float h1 = pos.y / ext.y;\n    float h2 = abs(h1);\n    h1 = h1 * .5 + .5;\n    ext.xz *= vec2(0.01, 0.1) + (1. - h2*h2);\n    pos.z += h1*h1 * skew;\n    d = dUnion(d, vec2(dRoundBox(pos, ext, 0.02), mtl));\n}\n\nfloat plantMtl(float age, float f)\n{\n    return age * (1. - f) + f;\n}\n\nvoid addPlant(inout vec2 d, vec3 pos, float age)\n{\n    vec4 h;\n    h.x = 1.09091-0.1/(age+0.1); h.y = h.x*h.x; h.z = h.y*h.x; h.w = 1.0;\n    float s = smoothstep(0.5, 1.0, age);\n    vec3 h2 = vec3(1., 1.-s, 1.);\n    \n    float th = 0.1;    \n    vec3 ls1 = vec3(1.5,3.2,th), ls2 = vec3(2.2,4.8,th),\n         ls3 = vec3(1.1,2.4,th), ls4 = vec3(0.5,5.6,th);\n    \n    vec4 sk = h.yzyx * vec4(2.5, 4.0, 2.0, 0.8);\n    sk = mix(sk, vec4(ls1.y,ls2.y,ls3.y,ls4.y), s);\n    \n    float mtl = age + 1.0;\n    \n    addLeaf(d, pMov(pos, vec3(0,0,-0.2)),\t\t\t\th2*h.zyw*ls1, sk.x, plantMtl(age,0.05));\n    addLeaf(d, pRotY(pMov(pos, vec3(0.0,0,0.3)), 2.5),\th2*h.yxw*ls2, sk.y, plantMtl(age,0.08));\n    addLeaf(d, pRotY(pos, -1.9),\t\t\t\t\t\th2*h.zxw*ls3, sk.z, plantMtl(age,0.1));\n    addLeaf(d, pRotY(pMov(pos, vec3(0.2,0,0.2)), -1.2),\th2*h.zzw*ls4, sk.w, plantMtl(age,0.0));\n}\n\nvec2 scene(vec3 pos)\n{\n    vec2 d = vec2(dPlane(pMov(pos, vec3(0,0.4,0))), 2.0);\n    \n    vec3 dim = vec3(DIMENSIONS.x, 1000, DIMENSIONS.y);\n    vec2 grid = dim.xz / float(NUM_PLANTS_SQRT);\n    \n    for (int i=0; i<NUM_PLANTS_SQRT; i++)\n        for (int j=0; j<NUM_PLANTS_SQRT; j++)\n    {\n        float t = rand(float(i*NUM_PLANTS_SQRT+j+1)) + iTime / LIFE_TIME;\n        float f = floor(t);\n        float age = t - f;\n        vec3 p = vec3(0);\n        p.xz = vec2(rand(f), rand(f+53.5421)) * 0.4 + 0.3;\n        p.xz += vec2(i,j);\n        p.xz *= grid;\n        p.xz -= 0.5 * dim.xz;\n        p = pMov(pos, p);\n        #ifdef REPEAT\n        p = pRep(p, dim);\n        #endif\n    \taddPlant(d, p, age);\n    }\n    return d;\n}\n\nfloat rayMarch(vec3 eye, vec3 dir, float zn, float zf, out float mtl)\n{\n    float z = zn;\n    mtl = -1.0;\n    \n    for (int i=0; i < RAYMARCH_ITER; i++)\n    {\n        vec2 d = scene(eye + z * dir);\n        mtl = d.y;\n        if (d.x < RAYMARCH_EPS || z > zf) break;\n        z += d.x * 0.5;\n    }\n    \n    if (z > zf) mtl = -1.0;\n    return z;\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec3 e = vec3(0.001,0.,0.);\n\treturn normalize(vec3(\n        \tscene(p+e.xyy).x - scene(p-e.xyy).x,\n\t\t\tscene(p+e.yxy).x - scene(p-e.yxy).x,\n\t\t\tscene(p+e.yyx).x - scene(p-e.yyx).x ));\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat ao = 0.0;\n    float s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        float hr = 0.01 + 1.5*float(i)/4.0;\n        float dd = scene(n * hr + p).x;\n        ao += -(dd-hr)*s;\n        s *= 0.5;\n    }\n    return saturate(1.0 - 0.4 * ao);\n}\n\nfloat groundNoise(vec3 pos)\n{\n    return fbm(0.2*pos.xz);\n}\n\nvec3 groundNorm(vec3 pos)\n{\n    vec3 e = vec3(0.01,0.,0.);\n    float n = groundNoise(pos);\n    return normalize(vec3(groundNoise(pos+e.xyy) - n, 0.01,\n                          groundNoise(pos+e.yyx) - n));\n}\n\n\nvec3 render(vec3 eye, vec3 dir)\n{\n    float zn = 5., zf = 200.;\n    float mtl;\n    float dist = rayMarch(eye, dir, zn, zf, mtl);\n    vec3 pos = eye + dist * dir;\n    vec3 norm = calcNormal(pos);\n    vec3 light = normalize(vec3(0.7,1.,0.));\n\tvec3 refl = reflect(dir, norm);\n    \n    if (mtl > 1.0) norm = groundNorm(pos);\n    \n    float ndl = dot(norm, light);\n    float back = saturate(-ndl);\n    ndl = saturate(ndl);\n    \n    vec3 albedo = vec3(step(0.,mtl));\n    vec3 plant_alb = mix(vec3(0.3,0.9,0.1), vec3(0.6,0.4,0.15), saturate(mtl));\n    plant_alb *= fbm(0.8*pos) * 0.3 + 0.7;\n\tvec3 ground_alb = mix(vec3(0.36,0.23,0.17), 0.8*vec3(0.23,0.16,0.1), groundNoise(pos));\n    albedo *= mix(plant_alb, ground_alb, saturate(mtl - 1.0));\n    \n    vec3 scat = albedo * vec3(1.2, 1.4, 1.0);\n    scat *= back*back;\n    \n    float spec = pow(saturate(dot(refl, light)), 32.);\n    \n    float ao = calcAO(pos, norm);\n    vec3 ambient = 0.2 * albedo * ao;\n    spec *= ao;\n        \n\tvec3 color = ambient + albedo * (1. + 0.5 * spec) * ndl + scat;\n    float fog = dist / zf;\n    color = mix(color, vec3(0.7,0.8,1.0)*1.3, saturate(fog));\n                         \n    return saturate(color);\n}\n\nvec3 lookAtDir(vec2 uv, vec3 eye, vec3 at, vec3 up, float fov)\n{\n    vec3 f = normalize(at - eye);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = normalize(cross(f, r));\n    return normalize(f + fov * (uv.x*r + uv.y*u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = iTime * 0.1;\n    angle += iMouse.x / iResolution.x * 2. * PI;\n    vec3 eye = vec3(sin(angle), 1.0 + 0.2 * sin(angle * 4.5)*0.1, cos(angle));\n    eye *= 15.;\n    vec3 dir = lookAtDir(uv, eye, vec3(0, 0, 0), vec3(0, 1, 0), 1.0);\n\t\n    vec3 color;\n    eye += dir * rand(uv + angle) * DITHERING;\n    color = render(eye, dir);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 293, 293, 340], [341, 341, 361, 361, 426], [428, 428, 449, 449, 717], [719, 719, 740, 740, 1104], [1106, 1106, 1125, 1125, 1295], [1297, 1297, 1316, 1316, 1486], [1488, 1488, 1510, 1510, 1524], [1525, 1525, 1557, 1557, 1581], [1582, 1582, 1610, 1610, 1648], [1649, 1649, 1691, 1691, 1733], [1735, 1735, 1766, 1766, 1800], [1802, 1802, 1829, 1829, 1845], [1846, 1846, 1873, 1873, 1905], [1906, 1906, 1935, 1935, 2006], [2008, 2008, 2079, 2079, 2308], [2310, 2310, 2346, 2346, 2379], [2381, 2381, 2431, 2431, 3236], [3238, 3238, 3260, 3260, 3956], [3958, 3958, 4029, 4029, 4302], [4304, 4304, 4329, 4329, 4513], [4515, 4515, 4545, 4545, 4788], [4790, 4790, 4819, 4819, 4849], [4851, 4851, 4878, 4878, 5059], [5062, 5062, 5095, 5095, 6243], [6245, 6245, 6309, 6309, 6471], [6473, 6473, 6530, 6530, 7029]], "test": "untested"}
{"id": "XllXRX", "name": "asdfasdfasf", "author": "jnalanko", "description": "asdfasdfasd", "tags": ["asdfasf"], "likes": 1, "viewed": 111, "published": "Public", "date": "1438892635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdf(vec4 p){\n\treturn length(p) - 1.0;   \n}\n\n// Clamped dot\nfloat cdot(vec3 a, vec3 b){\n    return max(0.0,dot(a,b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sphere at origin\n    \n    float aspect_ratio = 16.0/9.0;\n    float radius = 5.0;\n\tvec2 pixel_pos = fragCoord.xy / iResolution.xy; // [0,1]\n    pixel_pos -= vec2(0.5,0.5); // [-1/2, 1/2]\n    pixel_pos *= vec2(2,2); // [-1,1]\n    pixel_pos.x *= aspect_ratio;\n    vec3 ray = vec3(pixel_pos.x, pixel_pos.y,-1);\n    vec3 p = vec3(0,0,0); // Center of sphere\n    vec3 v = ray;\n    vec3 v_0 = vec3(0,0,5); // Camera position\n    \n    float sun_intensity = 70.0;\n    vec3 sun = vec3(30.0 * sin(iTime),20,30.0*cos(iTime));\n    // Phong model parameters\n    // Phong: k_s * cos(alpha)^q * intensity / r^2\n    float k_s = 10.0;\n    float q = 2.0;    \n    \n    // Compute intersection\n    float D = 4.0 * dot(v,v_0) * dot(v,v_0) - 4.0*dot(v,v)*(dot(v_0,v_0) - radius);\n    if(D < 0.0) // No hit\n        fragColor = vec4(0,0,0,0);\n    else{\n        float t1 = (-2.0 * dot(v,v_0) + sqrt(D)) / (2.0 * dot(v,v));\n        float t2 = (-2.0 * dot(v,v_0) - sqrt(D)) / (2.0 * dot(v,v));\n        vec3 surface = v_0 + min(t1,t2) * v;  // note: negative t not handled\n        vec3 normal = surface / length(surface);\n        vec3 l = surface - sun; // Sun to surface\n        float intensity_at_surface = sun_intensity / dot(l,l); // Inverse square decay\n        \n    \tvec3 l_prime = l + 2.0*dot(l,normal)*normal;\n        vec3 to_camera = v_0 - surface;\n        float cos_angle = cdot(-l_prime, to_camera)/(length(l_prime) * length(to_camera));\n        float specular = k_s * pow(cos_angle,q) * intensity_at_surface;\n        float diffuse = 0.2 * cdot(normal, -l) * intensity_at_surface;\n        float ambient = 0.05;\n        vec3 light = vec3(clamp(diffuse + specular + ambient,0.0,1.0));\n        fragColor = vec4(light,1);\n    }\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 48], [50, 65, 92, 92, 124], [126, 126, 183, 207, 1899]], "test": "untested"}
{"id": "XlsSDj", "name": "shifting rainbow v2", "author": "JamesHagerman", "description": "Playing with some basic math and the hsv2rgb function to build some crazy color options...", "tags": ["sensatron"], "likes": 2, "viewed": 146, "published": "Public", "date": "1439879544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mv = iMouse.xy/iResolution.xy;\n    \n    uv.y = atan(uv.y-0.5-sin(iTime*0.5),uv.x)+sin(iTime*0.5);\n    \n    uv.y += atan(uv.x-0.5-cos(iTime*0.5),uv.y)+cos(iTime*0.5);\n    \n    //uv.y += log(sqrt(uv.x*uv.x+uv.y*uv.y));\n    \n    \n    vec3 outputColor = hsv2rgb_smooth(vec3(uv.y, 1.0, 1.0));\n    \n        // Use the color pallet:\n    vec3 pallet1 = pal( uv.y, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    vec3 pallet2 = pal( uv.y, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    outputColor = mix(outputColor, pallet1, mv.x);\n    outputColor = mix(outputColor, pallet2, mv.y);\n    \n\tfragColor = vec4(outputColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 67, 67, 243], [246, 246, 314, 314, 357], [359, 359, 416, 416, 1157]], "test": "untested"}
{"id": "XlsXD2", "name": "Carbon Tissue", "author": "kynd", "description": "not optimized", "tags": ["raymarching"], "likes": 3, "viewed": 151, "published": "Public", "date": "1439870635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 cpos = vec3(0,0,5);\nmat3 cam;\nvec3 light = normalize(vec3(.6, .6, 1));\n\n#define K .21\n#define smoothen(d1,d2)  -log( exp(-K*(d1)) + exp(-K*(d2)) ) / K\n\nmat3 rotMatrix(float angle, vec3 a){\n    a = normalize(a);\n    float s= sin(angle), c= cos(angle);\n\n    return   mat3(a.x*a, a.y*a, a.z*a) * (1.-c)\n           + mat3(     c, a.z*s, -a.y*s,\n                  -a.z*s,     c,  a.x*s,\n                   a.y*s, -a.x*s,     c  );\n}\n\nfloat dist(vec3 p){\n    float  t = iTime/60.;\n    mat3 rm0 = rotMatrix(    t*6.3 + p.x*.005, vec3(1,0,0) );\n    mat3 rm1 = rotMatrix( 2.*t*6.3 + p.y*.006, vec3(0,1,0) );\n    mat3 rm2 = rotMatrix( 3.*t*6.3 + p.z*.007, vec3(0,0,1) );\n    p = rm0 * rm1 * rm2 * p;\n    p = mod(p, 48.) - 24.;\n    float d0 = length(p.xy) - 1.;\n    float d1 = 100.;\n    float d2 = length(p.zx) - 2.;\n\n    return smoothen(d0, smoothen(d1, d2));\n}\n\n#define EPS vec2(.001, 0)\n#define norm(p) normalize(dist(p) - vec3(dist(p-EPS.xyy), dist(p-EPS.yxy), dist(p-EPS.yyx)));\n\n\nvec4 phong(vec3 p, vec3 ray) {\n    vec3 n = norm(p);\n    return   vec4(.1) * .5 \n           + vec4(.3) * clamp(dot(light, n) * .5, .0, 1.)\n\t\t   + pow(clamp(dot(normalize(light-ray), n), .0, 1.), 128.);\n}\n\nvoid mainImage(out vec4 o, vec2 uv )\n{\n\tvec2 R = iResolution.xy,\n         p = (uv * 2. - R) / min(R.x, R.y);\n    cam[0] = -normalize(cpos),\n    cam[1] = vec3(1,0,0),\n    cam[2] = cross(cam[1], cam[0]);\n\tvec3 ray = normalize(cam*vec3(2,p));\n\n\tfloat len = 0., di;\n\tvec3 rhead = cpos;\n\tfor(int i = 0; i < 128; i++){\n\t\tdi = dist(rhead);\n        if (abs(di) < .001) break;\n\t\tlen += di;\n\t\trhead = cpos + len * ray;\n\t}\n\n\to = abs(di)<.001 ? phong(rhead, ray) : vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 195, 195, 434], [436, 436, 455, 455, 858], [982, 982, 1012, 1012, 1185], [1187, 1187, 1225, 1225, 1650]], "test": "untested"}
{"id": "XlsXDB", "name": "cloudy sunset", "author": "miloszmaki", "description": "cloudy sunset, inspired by today's evening sky", "tags": ["procedural", "2d", "noise", "sunset", "clouds"], "likes": 43, "viewed": 3386, "published": "Public API", "date": "1439419260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x,0.,1.)\n#define rgb(r,g,b) (vec3(r,g,b)/255.)\n\nfloat rand(float x) { return fract(sin(x) * 71.5413291); }\n\nfloat rand(vec2 x) { return rand(dot(x, vec2(13.4251, 15.5128))); }\n\nfloat noise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    f *= f*(3.-2.*f);\n    return mix(mix(rand(i), rand(i+vec2(1,0)), f.x),\n               mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n}\n\nfloat fbm(vec2 x)\n{\n    float r = 0.0, s = 1.0, w = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nfloat cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n{\n    return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*iTime))-(1.0-density)), 1.0-sharpness);\n}\n\nvec3 render(vec2 uv)\n{\n    // sky\n    vec3 color = mix(rgb(255,212,166), rgb(204,235,255), uv.y);\n    // sun\n    vec2 spos = uv - vec2(0., 0.4);\n    float sun = exp(-20.*dot(spos,spos));\n    vec3 scol = rgb(255,155,102) * sun * 0.7;\n    color += scol;\n    // clouds\n    vec3 cl1 = mix(rgb(151,138,153), rgb(166,191,224),uv.y);\n    float d1 = mix(0.9,0.1,pow(uv.y, 0.7));\n    color = mix(color, cl1, cloud(uv,2.,8.,d1,0.4,0.04));\n    color = mix(color, vec3(0.9), 8.*cloud(uv,14.,18.,0.9,0.75,0.02) * cloud(uv,2.,5.,0.6,0.15,0.01)*uv.y);\n    color = mix(color, vec3(0.8), 5.*cloud(uv,12.,15.,0.9,0.75,0.03) * cloud(uv,2.,8.,0.5,0.0,0.02)*uv.y);\n    // post\n    color *= vec3(1.0,0.93,0.81)*1.04;\n    color = mix(0.75*rgb(255,205,161), color, smoothstep(-0.1,0.3,uv.y));\n    color = pow(color,vec3(1.3));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = vec4(render(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 95, 95, 132], [134, 134, 154, 154, 201], [203, 203, 224, 224, 413], [415, 415, 434, 434, 594], [596, 596, 691, 691, 799], [801, 801, 823, 834, 1623], [1625, 1625, 1682, 1682, 1826]], "test": "untested"}
{"id": "XlXXDB", "name": "presentworthy", "author": "marina", "description": "x", "tags": ["nice"], "likes": 1, "viewed": 224, "published": "Public", "date": "1439263245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb(in float h, float s, float l) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n  return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = mod(iTime / 3.0, 30.0);\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float x = uv.x, y = uv.y;\n  float h = \n      (sin(y * t) + (y - sin(t + (1.0/y * sin(x*t - y + sin(tan(x)/1000.0)/100.0)/tan(t))\n               + tan(t - x * y))) - tan(t - x * y));\n  float s = 1.0;\n  float l = mod(sin(t - x * t * x + sin(y * t)), 1.0);\n  fragColor = vec4(hsl2rgb((mod(h, .05) - sin(y * x) - t), s, l), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 173], [175, 175, 230, 230, 639]], "test": "untested"}
{"id": "XlXXDs", "name": "Superformula (3D)", "author": "mech4rhork", "description": "testing Johan Gielis's superformula&trade; in 3D", "tags": ["3d", "raymarching", "fractal", "superformula", "supershape"], "likes": 22, "viewed": 2827, "published": "Public API", "date": "1440460445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define time iTime\n#define speed 5.\n\n//#define NORMAL_RGB // colors from normal vector\n#define ANIMATION\n//#define MSAA // antialiasing\n#define MSAA_SAMPLES 4\n#define SHADOWS\n\n\n\nconst vec2 renderRange = vec2(0.001, 300.0);\n// parameters ( shape1, shape2 ) // another cool shape // another\nvec2 m  = vec2( 12, 3 ),   // 10, 4   // 12, 6      // 1, 10\n     a  = vec2( 1, -4 ),   // .9, .6  // 1, .9      // 1, 1\n     b  = vec2( .2, .2 ),  // -1, -.5 // .25, 10    // 1, 1\n     n1 = vec2( -.4, .3 ), // 1, 1    // .05, -.05  // 1, 1\n     n2 = vec2( 2, 1 ),    // 3, .2   // 25, 20     // 1, 1\n     n3 = vec2( 1, 1 );    // 4, -1   // 9.79225, 8 // 1, 1\nvec3 rd; // ray direction - used in map()\nvec4 S1, S2; // m, n1, n2, n3\nvec2 S1_ab, S2_ab; // a, b\n\nvec2 rotate( vec2 p, vec2 c, float theta ) {\n    float co=cos(theta), si=sin(theta);\n    return (p-c)*mat2(co,-si,si,co);\n}\nvec3 rotate( vec3 p, vec3 theta ) {\n    float cx=cos(theta.x), sx=sin(theta.x), cy=cos(theta.y),\n          sy=sin(theta.y), cz=cos(theta.z), sz=sin(theta.z);\n    p.yz*=mat2(cx, -sx, sx, cx); p.xz*=mat2(cy, -sy, sy, cy); p.xy*=mat2(cz, -sz, sz, cz);\n    return p;\n}\nfloat superformula( float m, float a, float b, float n1, float n2, float n3, float phi ) {\n    return pow(pow(abs(cos(m*phi/4.)/a), n2) + pow(abs(sin(m*phi/4.)/b), n3), -n1);\n}\nvec4 shape2d( float m, float a, float b, float n1, float n2, float n3, vec2 p ) {\n    p *= 1.+(abs(a-b)+abs(n1-n2)+abs(n1-n3)+abs(n2-n3));\n    float rd = length(p) - superformula(m, a, b, n1, n2, n3, atan(p.y/p.x));\n    float alpha = step(0., rd*10.); // alpha = step(2.0, abs(rd*10.0)); // for outline\n    return vec4(vec3(.37), 1.-alpha);\n}\nfloat shape3d( vec3 p ) {\n    float d = length(p); \n    float theta = atan(p.z/p.x); // longitude\n    float phi = asin(p.y/d); // latitude\n    float r1 = superformula(m.x, a.x, b.x, n1.x, n2.x, n3.x, theta);\n    float r2 = superformula(m.y, a.y, b.y, n1.y, n2.y, n3.y, phi);\n    vec3 q = r2 * vec3(r1*cos(theta)*cos(phi), r1*sin(theta)*cos(phi), sin(phi));\n\treturn d - length(q);\n}\nfloat map( vec3 p ) {\n    float d = shape3d(p);\n\tfloat s = d*.5, dr = (d-shape3d(p + rd*s))/s; // from eiffie\n\treturn d / (1.+max(dr, 0.)); // this one too\n}\nfloat castRay( vec3 ro, vec3 rd ) {\n    float startDelta=renderRange.x, delta=startDelta, stopDelta=renderRange.y;\n    float maxDist = 0.002;\n    for(int i = 0; i < 64; i++) {\n        float dist = map(ro + rd * delta);\n        if(dist <= maxDist || dist > stopDelta) break;\n        delta += dist;\n    }\n    return delta;\n}\nvec3 calcNormal( vec3 pos ) {\n    float delta = 0.01;\n    vec2 unit = vec2(1.0, 0.0);\n    return normalize( vec3(\n            map(pos + unit.xyy*delta) - map(pos - unit.xyy*delta),\n            map(pos + unit.yxy*delta) - map(pos - unit.yxy*delta),\n            map(pos + unit.yyx*delta) - map(pos - unit.yyx*delta)));\n}\nfloat calcSSS( vec3 pos, vec3 lig ) {\n    float sss = 0.0, sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float delta = 0.01 + 0.03*float(i);\n        vec3 sspos = pos + lig*delta;\n        float dist = map(sspos);\n        sss += -(dist - delta)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1. - 3.0*sss, 0., 1.);\n}\n// by iq\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0, sca = 1.0;\n    for(int i = 0; i < 4; i++) {\n        float hr = 0.01 + 0.03*float(i);\n        vec3 aopos = nor*hr + pos;\n        float dd = map(aopos);\n        occ += -(dd - hr)*sca;\n        sca *= 0.97;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);    \n}\n// based on softshadow() by iq\nfloat calcSoftShadow( vec3 ro, vec3 rd, float mint, float tmax, int samples ) {\n\tfloat res=1.0, t=mint, stepDist=(tmax - mint)/float(samples);\n    for(int i = 0; i < 64; i++) {\n\t\tfloat h = map(ro + rd*t);\n        res = min(res, 8.0*h / t);\n        t += clamp(h, stepDist, 1e10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0., 1.);\n}\nvec4 render( vec3 ro, vec3 rd ) {\n    // color\n    vec3 col = vec3(0);\n    #ifndef ANIMATION\n    float t = 2. + m.x+m.y + n1.x+n1.y,\n          ps = m.x+m.y+a.x+a.y+b.x+b.y+n1.x+n1.y+n2.x+n2.y+n3.x+n3.y;\n    vec3 com = 0.3 + 0.3*(0.5+vec3( .5*sin(ps + 2.*t), .5*sin(ps + 3.*t), .5*sin(ps + 4.*t) ));\n    float maxCom = max(com.r, max(com.g, com.b));\n    vec3 f = 0.8*(1.0 + vec3(step(1., com.r/maxCom), step(1., com.g/maxCom), step(1., com.b/maxCom)));\n    col += com * f;\n    #else\n    col = vec3(.33,.49,.81)*(1.15 + .2*vec3(sin(m.x+a.y-n1.x+n3.y), cos(m.x+a.y-n1.y+n3.x), sin(m.y+a.y-n1.x+n2.y)));\n    #endif\n    \n    float dist = castRay(ro, rd);\n    vec3 pos = ro + rd * dist;\n    \n    if(dist > renderRange.y) return vec4(0); // background\n    else {\n        vec3 lig = normalize(vec3(1,3,-2)),\n             nor = calcNormal(pos),\n             ref = reflect(rd, nor);\n        #ifdef NORMAL_RGB\n        return vec4(nor*.5+.55, 1);\n        #endif\n        float dif = clamp(dot(nor, lig), 0., 1.),\n              spe = pow(clamp(dot(reflect(-lig, nor), -rd), 0., 1.), 25.),\n              fre = pow(clamp(1.0 + dot(nor, rd), 0., 1.), 5.),\n              dom = smoothstep(-0.15, 0.15, ref.y),\n              amb = 1.0,\n              occ = calcAO(pos, nor),\n              sss = calcSSS(pos, lig);\n        #ifdef SHADOWS\n        dif *= calcSoftShadow(pos, lig, .001, 3.1, 40);\n        #endif\n        vec3 brdf = vec3(0);\n        brdf += 0.8 * dif;\n        brdf += 1.0 * spe * dif;\n    \tbrdf += 0.3 * amb * occ;\n        brdf += 0.1 * fre * occ;\n        brdf += 0.1 * dom * occ;\n        brdf += 0.2 * sss * occ;\n        col *= brdf;\n    }\n    return vec4(col, 1);\n}\nvec4 renderAA( vec3 ro, vec3 rd ) {\n    const int k = (MSAA_SAMPLES < 0) ? 1 : MSAA_SAMPLES;\n    vec4 c = vec4(0); // color\n\tvec2 o = vec2(10, 0); // offset\n    o = rotate(o, vec2(0), PI/8.0);\n    for(int i = 0; i < k; i++) {\n        c += render(ro + o.x/iResolution.x, rd) / float(k);\n        o = rotate(o, vec2(0), 2.*PI/float(k));\n    }\n    return c;\n}\nvec4 params( float t ){\n\tt=mod(t,10.0);\n\tif(t<1.0)return vec4(2., .9, 1.6, 2.5);\n\tif(t<2.0)return vec4(8, .2, -1.9, 1);\n    if(t<3.0)return vec4(7, .8, 1, -1.39);\n    if(t<4.0)return vec4(9, 1, 1, 1);\n    if(t<5.0)return vec4(12, .1, 1.05, 4);\n    if(t<6.0)return vec4(5, 1, 2, 2);\n    if(t<7.0)return vec4(-4, 2, .4, 1.04);\n    if(t<8.0)return vec4(-2, 1, 2, 6);\n    if(t<9.0)return vec4(7, 1, 1, 1);\n    if(t<10.)return vec4(8, 1, -1, 1);\n    return vec4(7, 1, 4, -1);\n}\nvec2 params_ab( float t ){\n\tt=mod(t,10.0);\n\tif(t<1.0)return vec2(.8, 1.);\n\tif(t<2.0)return vec2(-1, 1);\n    if(t<3.0)return vec2(-1, .95);\n    if(t<4.0)return vec2(1.3, 1.);\n    if(t<5.0)return vec2(-1, 1.3);\n    if(t<6.0)return vec2(1.3, 1);\n    if(t<7.0)return vec2(-1, 1.5);\n    if(t<8.0)return vec2(1.3, 1.3);\n    if(t<9.0)return vec2(1.15, 1);\n    if(t<10.)return vec2(1, .9);\n    return vec2(1.4, 1);\n}\n\nvoid mainImage( out vec4 o, in vec2 uv ) {\n\tvec2 R = iResolution.xy,\n         p = (2.*uv - R)/R.y, q = p,\n         mo = -(iMouse.xy / R - 0.5)*2.;\n    p *= 3.0;\n    \n    // background\n    o = vec4(vec3(.099), 1);\n    \n    // animation - from effie\n    #ifdef ANIMATION\n    float t = time*0.25*speed;\n    S1 =    mix(params(t-1.),    params(t),    smoothstep(0.,1./speed*10.,fract(t)*2.));\n    S1_ab = mix(params_ab(t-1.), params_ab(t), smoothstep(0.,1./speed*10.,fract(t)*2.)); t /= 10.;\n    S2 =    mix(params(t-1.),    params(t),    smoothstep(0.,1./speed,fract(t)*2.));\n    S2_ab = mix(params_ab(t-1.), params_ab(t), smoothstep(0.,1./speed,fract(t)*2.));\n    m=vec2(S1.x, S2.x); n1=vec2(S1.y, S2.y); n2=vec2(S1.z, S2.z); n3=vec2(S1.w, S2.w);\n    a=vec2(S1_ab.x, S2_ab.x); b=vec2(S1_ab.y, S2_ab.y); \n    #endif\n    \n    // 2d shape 1\n    vec4 col = shape2d(m.x, a.x, b.x, n1.x, n2.x, n3.x, p - vec2(-3.0, 1.5));\n    o = mix(o, vec4(col.rgb, 1.), col.a);\n    // 2d shape 2\n    col = shape2d(m.y, a.y, b.y, n1.y, n2.y, n3.y, p - vec2(-3.0, -1.5));\n    o = mix(o, vec4(col.rgb, 1.), col.a);\n    \n    // 3d shape (raymarching)\n    float camDist = 20.;\n    vec2 drot = vec2(mo.x*PI*1.1, mo.y*PI/3.*1.1);\n    vec3 camPos = rotate(vec3(-camDist, 0, -camDist), vec3(drot.y, drot.x, 0));\n    vec3 forward=normalize(vec3(vec3(0)-camPos)), right=normalize(cross(vec3(0,1,0), forward)), up=cross(forward, right);\n    vec3 rayDir = mat3(right, up, forward) * normalize(vec3(q-vec2(0.48, -.125), R.y / R.x * 12.5)); rd = rayDir;\n    #ifdef MSAA\n    col = renderAA(camPos, rayDir);\n    #else\n    col = render(camPos, rayDir);\n    #endif\n    o = mix(o, vec4(col.rgb, 1.), col.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 775, 819, 819, 898], [899, 899, 934, 934, 1163], [1164, 1164, 1254, 1254, 1340], [1341, 1341, 1422, 1422, 1683], [1684, 1684, 1709, 1709, 2065], [2066, 2066, 2087, 2087, 2223], [2224, 2224, 2259, 2259, 2546], [2547, 2547, 2576, 2576, 2865], [2866, 2866, 2903, 2903, 3188], [3189, 3198, 3240, 3240, 3512], [3513, 3544, 3623, 3623, 3902], [3903, 3903, 3936, 3949, 5561], [5562, 5562, 5597, 5597, 5917], [5918, 5918, 5941, 5941, 6390], [6391, 6391, 6417, 6417, 6799], [6801, 6801, 6843, 6843, 8468]], "test": "untested"}
{"id": "XlXXzs", "name": "Mobius Hearts", "author": "XMunkki", "description": "Base model for a physical 3D printed object for my 8th wedding anniversary gift.\n\nhttp://xmunkki.org/wiki/doku.php?id=projects:mobiushearts", "tags": ["distancefields", "3dprinting"], "likes": 8, "viewed": 1345, "published": "Public", "date": "1438814232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// See the finished object and more information at:\n//    http://xmunkki.org/wiki/doku.php?id=projects:mobiushearts\n//\n// Based on Inigo Quilez raymarching tutorial at https://www.shadertoy.com/view/Xds3zN\n\n#define PI 3.14159265\n\nfloat sdPlane(vec3 p, float h)\n{\n\treturn p.y - h;\n}\n\nfloat sdCylinderY(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderZ(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(d1, -d2);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend(float d1, float d2)\n{\n    return sminPoly(d1, d2, 0.05);\n}\n\n// With extra information\nvec2 opU2( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n//----------------------------------------------------------------------\n// Transforms on position to affect the model\n\nvec3 posTranslate(vec3 p, vec3 offset)\n{\n    return p - offset;\n}\n\nvec3 posAxisAngle(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    angle = -angle; // Inverse rotation for distance fields\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return\n        c * p +\n        s * cross(axis, p) +\n        ((1.0 - c) * dot(axis, p)) * axis;\n}\n\n//----------------------------------------------------------------------\n\nfloat sdCircle(vec3 p, float radius, float thickness, float width)\n{\n    float t_half = thickness * 0.5;\n\n    float res = sdCylinderZ(p, vec2(radius + t_half, width * 0.5));\n    res = opS(res, sdCylinderZ(p, vec2(radius - t_half, width)));\n    return res;\n}\n\nfloat sdCircleRound(vec3 p, float radius, float thickness, float width)\n{\n    float t_half = thickness * 0.5;\n\n    // Get the direction and center point for the circle border (z = 0)\n    vec2 border_dir = normalize(p.xy);\n\tvec2 border_center = border_dir * radius;\n    \n    // Get the position of the projected 2D coordinate\n    vec2 proj_pos = vec2(length(p.xy - border_center), p.z);\n    \n    // Calculate the rounded box distance\n    float roundness = 0.02;\n    vec2 box_size = vec2(t_half, width * 0.5);\n    box_size = box_size.yx;\n    return length(max(abs(proj_pos) - box_size, 0.0)) - roundness;\n}\n\nfloat sdCircleTopTwist(vec3 p, float radius, float thickness, float width, bool twist_orient_dir)\n{\n    // Do a half twist at the top\n    if (p.y > 0.0)\n    {\n        vec3 twist_dir = normalize(vec3(p.x, p.y, 0.0));\n        vec3 twist_center = twist_dir * radius;\n        \n        float amt_dir = dot(twist_dir, p - twist_center);\n        float amt_z = p.z;\n\n        // Map the angle range to a half twist\n        float angle = atan(p.x, p.y);\n        float angle_range = 0.5;\n        angle_range = clamp((angle + angle_range) / (angle_range * 2.0), 0.0, 1.0);\n        angle_range = smoothstep(0.0, 1.0, angle_range);\n        angle = mix(0.0, (twist_orient_dir ? PI : -PI), angle_range);\n        \n        // Rotate the position along the twist position on the ring\n        float as = sin(angle);\n        float ac = cos(angle);\n        \n        float amt_a = ac * amt_dir - as * amt_z;\n        float amt_b = ac * amt_z + as * amt_dir;\n        \n        vec3 new_p = twist_center +\n            twist_dir * amt_a +\n            vec3(0.0, 0.0, amt_b);\n        \n        // If still above, keep the rotation\n        if (new_p.y > 0.0)\n            p = new_p;\n        \n        //p.y -= abs(p.x) * 1.5;\n    }\n    \n    float res = sdCircleRound(p, radius, thickness, width);\n    return res;\n}\n\nfloat sdHeartOrigin(vec3 p, bool twist_dir)\n{\n    // Do a heart shape\n    p.y -= pow(abs(p.x), 1.3) * 1.3;\n    \n    return sdCircleTopTwist(p, 0.5, 0.1, 0.15, twist_dir);\n}\n\nfloat sdHeart(vec3 p, bool twist_dir)\n{\n    p = posTranslate(p, vec3(0.0, 0.6, 0.0));\n    p = posAxisAngle(p, vec3(1.0, 0.0, 0.0), -0.35); // Tilt (major)\n    p = posAxisAngle(p, vec3(0.0, 0.0, 1.0), 0.15); // Tilt (side)\n    p = posTranslate(p, vec3(-0.15, 0.0, 0.04));\n    float res = sdHeartOrigin(p, twist_dir);\n    return res;\n}\n\nfloat sdHearts(vec3 p)\n{\n    // Mirror by x axis\n    vec3 p2 = vec3(-p.x, p.y, -p.z);\n    \n    return opU(sdHeart(p, false), sdHeart(p2, true));\n}\n\nfloat sdPlatform(vec3 p)\n{\n    float res = sdCylinderY(p, vec2(0.6, 0.1));\n    res -= 0.07; // Soft edges\n    \n    return res;\n}\n\nfloat sdObject(vec3 p)\n{\n    float res = sdPlatform(p);\n    res = opBlend(res, sdHearts(p));\n    res = opS(res, sdPlane(p, 0.0)); // Cut out anything that goes through the platform\n    return res;\n}\n\n//----------------------------------------------------------------------\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2(sdPlane(pos, 0.0), 1.0);\n\n    //res = opU2(res, vec2(sdCylinderY(pos - vec3(0,0.6,0), vec2(0.5, 0.5)), 2.0));\n    //res = opU2(res, vec2(sdCylinderZ(pos - vec3(0,0.6,0), vec2(0.5, 0.5)), 2.0));\n    //res = opU2(res, vec2(sdCircleRound(pos - vec3(0,0.6,0), 0.5, 0.1, 0.1), 128.0));\n    //res = opU2(res, vec2(sdHeartOrigin(pos - vec3(0,0.6,0), false), 128.0));\n    res = opU2(res, vec2(sdObject(pos), 128.0));\n    \n    // More accuracy (substepping)\n    res.x *= 0.5;\n    \n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<200; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( abs(res.x)<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n    ro *= 0.7;\n\tvec3 ta = vec3(0.0, 0.8, 0.0); //vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 233, 265, 265, 284], [286, 286, 321, 321, 420], [422, 422, 457, 457, 556], [558, 632, 665, 665, 692], [694, 694, 725, 725, 751], [753, 753, 798, 798, 891], [893, 893, 928, 928, 965], [967, 993, 1024, 1024, 1057], [1059, 1059, 1089, 1089, 1118], [1120, 1240, 1280, 1280, 1305], [1307, 1307, 1358, 1358, 1609], [1611, 1685, 1753, 1753, 1942], [1944, 1944, 2017, 2017, 2548], [2550, 2550, 2649, 2683, 3830], [3832, 3832, 3877, 3901, 4004], [4006, 4006, 4045, 4045, 4339], [4341, 4341, 4365, 4389, 4487], [4489, 4489, 4515, 4515, 4617], [4619, 4619, 4643, 4643, 4817], [4819, 4893, 4916, 4916, 5426], [5428, 5428, 5466, 5466, 6062], [6065, 6065, 6137, 6137, 6398], [6400, 6400, 6430, 6430, 6651], [6653, 6653, 6695, 6695, 6994], [6996, 6996, 7033, 7033, 8619], [8621, 8621, 8673, 8673, 8850], [8852, 8852, 8909, 8909, 9541]], "test": "untested"}
{"id": "XtBXzz", "name": "color sine", "author": "rcread", "description": "a variant of https://www.shadertoy.com/view/4tBSRz", "tags": ["2d", "short", "1tweet"], "likes": 1, "viewed": 130, "published": "Public", "date": "1440882292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\ta variant of https://www.shadertoy.com/view/4tBSRz\n\n//\tcos or sin( vec4... don't know which is better\n\nvoid mainImage( out vec4 o, vec2 p ) {\n    p\t\t=\t2. * p / iResolution.xy - 1.;\n    o\t\t=\tabs( cos( vec4( p.yx, p + p ) / abs( p.x / .5 + cos( iTime + p.y ) ) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBXzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[182, 233, 271, 271, 395]], "test": "untested"}
{"id": "XtfSzs", "name": "Just some fog", "author": "Josh1billion", "description": "Based on some stuff from http://pixelshaders.com/examples/noise.html", "tags": ["fog"], "likes": 2, "viewed": 288, "published": "Public", "date": "1438796223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(float p)\n{\n    return fract(sin(p)*10000.0);\n}\n\nfloat noise(vec2 p) {\n    return random(p.x + p.y*10000.0);\n}\n\nfloat stepNoise(vec2 p) {\n    return noise(floor(p));\n}\n\nvec2 sw(vec2 p) { return vec2( floor(p.x), floor(p.y) ); }\nvec2 se(vec2 p) { return vec2( ceil(p.x), floor(p.y) ); }\nvec2 nw(vec2 p) { return vec2( floor(p.x), ceil(p.y) ); }\nvec2 ne(vec2 p) { return vec2( ceil(p.x), ceil(p.y) ); }\n\nfloat smoothNoise(vec2 p) {\n  vec2 inter = smoothstep(0., 1., fract(p));\n  float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  return mix(s, n, inter.y);\n  return noise(nw(p));\n}\n\nfloat fractalNoise(vec2 p) {\n  float total = 0.0;\n  total += smoothNoise(p);\n  total += smoothNoise(p*2.) / 2.;\n  total += smoothNoise(p*4.) / 4.;\n  total += smoothNoise(p*8.) / 8.;\n  total += smoothNoise(p*16.) / 16.;\n  total /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n  return total;\n}\n\nfloat normalizedSin(float x) {\n    return abs(sin(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = uv * 6.0;\n    float brightness = fractalNoise(p + iTime*0.4);\n    \n    float fogIntensity = 0.4 + 0.2*(normalizedSin(iTime));\n    \n    fragColor = vec4(brightness, brightness, brightness, 1.0)*fogIntensity + texture(iChannel0, uv)*(1.0 - fogIntensity);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 59], [61, 61, 82, 82, 122], [124, 124, 149, 149, 179], [181, 181, 198, 198, 239], [240, 240, 257, 257, 297], [298, 298, 315, 315, 355], [356, 356, 373, 373, 412], [414, 414, 441, 441, 648], [650, 650, 678, 678, 934], [936, 936, 966, 966, 992], [994, 994, 1051, 1051, 1366]], "test": "untested"}
{"id": "XtfXDl", "name": "glitchy eatbrain logo", "author": "nexor", "description": "\"From the mind of neurofunk pioneer Jade, comes EATBRAIN - a forward thinking imprint standing at the crux of heavy dancefloor rhythms and the razors edge of drum & bass.\"\n\nThis is an attempt to recreate the eatbrain logo using 2d distance functions.", "tags": ["glitch", "distancefunctions"], "likes": 6, "viewed": 548, "published": "Public", "date": "1440407477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define time iTime\n#define resolution iResolution.xy\n\nconst float pi = 3.14159265359;\nconst float pi2 = 2.0*pi;\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.x *= resolution.x/resolution.y;\n\t return p;\n}\n\nvec2 pix(vec2 p, int s)\n{\n\t return floor(p*float(s)+0.5)/float(s);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 rot(vec2 p, float a)\n{\n\t a = radians(a);\n\t float c = cos(a);\n\t float s = sin(a);\n\t return p*mat2(c,s,s,-c);\n}\n\nfloat saw2(float x)\n{\n\t return abs(fract(x)*2.-1.);\n}\n\nfloat saw(float x)\n{\n\t return abs(fract(x)*4.-2.)-1.;\n}\n\n#define ss(x,f) smoothstep(f+.01,f,x)\n\nfloat rct(vec2 p,float w,float h)\n{\n\tp=abs(p);\n\treturn ss(p.x,w)\n\t      *ss(p.y,h);\n}\n\nfloat crc(vec2 p,float r)\n{\n\treturn ss(length(p),r);\n}\n\nfloat tri(vec2 p,float w,float h)\n{\n\treturn ss(abs(p.x),w*saw(p.y*w/h))\n\t      *ss(abs(p.y+h),h);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = tr(fragCoord.xy);\n\n\tvec2 pq = uv;\n\n\n float t = time*.8;\n\n float len = length(pq);\n\tvec3 col = vec3(0.0);\n\n\tuv *= 2.5;\n\t//pq = rot(pq,fbm(vec2(0.)+t)*45.);\n\tvec2 gl = floor(2.*cos(2.*t))/2.*step(mod(pq.yx-.0625,.125),vec2(.0625));\n\tuv.y += mix(mix(gl,gl.yx,floor(2.*saw2(4.*t))/2.),\n\t\t         vec2(0.),floor(4.*saw2(2.*t))/4.).y;\n    //uv.y += mix(mix(gl,gl.yx,floor(2.*saw2(4.*t))/2.),vec2(0.),floor(4.*saw2(2.*t))/4.).y;\n\t//uv.x += floor(2.*tan(2.*t))/2.*step(mod(pq.y-.0625,.125),.0625);\n\n\tuv = rot(uv,cos(2.*t)*10.+180.);\n\n float sw = .25;\n float sh = .3;\n float shb = sh+.1;\n float ch = .05;\n float ew = .3;\n float eh = .1;\n float er = 45.;\n\n\tvec2 pc = vec2(0.,-.2);\n\n\tvec2 pl = vec2(-.5,.5);\n\tvec2 pr = vec2(.5,.5);\n\n\tvec2 sll = vec2(-sw,pc.y-ch);\n\tvec2 slr = vec2(sw,pc.y-ch);\n\n\tvec2 sbl = vec2(-sw*3.,pc.y-ch);\n\tvec2 sbr = vec2(sw*3.,pc.y-ch);\n\n\tvec2 tmpv = vec2(0.);\n\tfloat tmpf = 0.;\n\n\tvec3 v = vec3(.0);\n\t//*\n\tv = max(v,rct(uv-pc,sw*5.,ch));\n tmpv = rot(uv-pl,45.0);\n\tv = max(v,rct(tmpv,ew,eh));\n\tv = max(v,rct(tmpv.yx,ew,eh));\n\n tmpv = uv-pr;\n tmpf = (1.+cos(5.*t))*.5;\n tmpf = max(rct(rot(tmpv,er),ew,eh),\n \t           rct(rot(tmpv,-er),ew,eh));\n\n\tv = max(v,tmpf);\n //*/\n\tv = max(v,tri(uv-sll,sw,sh));\n\tv = max(v,tri(uv-slr,sw,sh));\n\n\tv = max(v,tri(uv-sbl,sw,shb));\n\tv = max(v,tri(uv-sbr,sw,shb));\n    \n    tmpv = uv-vec2(0.,0.1);\n    tmpv = rot(tmpv,45.0);\n    v = mod(v+crc(tmpv,1.5),2.);\n\n\tfloat q = 1.0\n\t//*fbm(pq*32.+time)\n\t;\n\n col = v*q;\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 132, 132, 222], [224, 224, 249, 249, 292], [294, 294, 317, 317, 359], [361, 361, 387, 387, 606], [658, 658, 679, 679, 878], [880, 880, 907, 907, 994], [996, 996, 1017, 1017, 1049], [1051, 1051, 1071, 1071, 1106], [1147, 1147, 1182, 1182, 1232], [1234, 1234, 1261, 1261, 1288], [1290, 1290, 1325, 1325, 1389], [1391, 1391, 1445, 1445, 2947]], "test": "untested"}
{"id": "XtfXWl", "name": "Metaeaux - Warp drive", "author": "metaeaux", "description": "Experimenting with modulating the focal length to distort the perspective.", "tags": ["raymarching", "distancefields", "focallength"], "likes": 7, "viewed": 1606, "published": "Public API", "date": "1440375843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 ambientColor = vec4(0.15, 0.2, 0.32, 1.0);\nconst vec4 skyColor = 0.3 * vec4(0.31, 0.47, 0.67, 1.0);\nconst float PI = 3.14159;\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat cube(vec3 p, vec3 size)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(abs(p) - size, vec3(0.0)));\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 twist(vec3 p, float amount)\n{\n    float  c = cos(amount*p.y+amount);\n    float  s = sin(amount*p.y+amount);\n    mat2   m = mat2(c,-s,s,c);\n    return mix(p, vec3(m*p.xz,p.y), amount);\n}\n\nfloat intersection( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat distanceField(vec3 p) {\n    vec3 repeatedSpace = repeat(p, vec3(1.2));\n    float d1 = cube(repeatedSpace, vec3(.2));\n    float d2 = sphere(repeatedSpace, 0.25);\n    float d3 = mix(intersection(d2, d1), d2, -1.);\n    return d3;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\nvec4 lambert(vec3 p, vec3 normal, vec3 lightPos, vec4 lightColor)\n{\n\tfloat lightIntensity = 0.0;\n\tvec3 lightDirection = normalize(lightPos - p);\n    \n    // lambert shading\n\tlightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.);\n\t\n\treturn lightColor * lightIntensity + ambientColor * (1.0 - lightIntensity);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float gridSize = 4.0;\n    float u = gl_FragCoord.x * gridSize / iResolution.x - gridSize / 2.;\n    float v = gl_FragCoord.y * gridSize / iResolution.y - gridSize / 2.;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camRight = vec3(1., 0., 0.);\n    vec3 camForward = vec3(0., 0., 1.);\n    \n    // modulate the focal length based on time\n    float maxFocalLength = 1.97;\n    float focalLength = maxFocalLength - (maxFocalLength - 0.01) * abs(sin(iTime * 0.5));\n    \n    float time = 15.0 + iTime;\n\n\t// camera\t\n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3( 3. - 6. * mo.x, 3. - 6. * mo.y, iTime);\n\tvec3 rd = normalize(camForward * focalLength + camRight * u * aspectRatio + camUp * v);\n    \n    vec4 color = skyColor;\n\n    float t = 0.0;\n    vec3 lightDirection = vec3(2.0, 1.0, -2.0);\n    vec4 lightColour;\n    const int maxSteps = 64;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = distanceField(p);\n        if(d < 0.0002)\n        {\n            vec3 normal = getNormal(p);\n            float far = 1. / t;\n\n            // focal length modulates the colour, a bit like the doppler effect\n            lightColour = vec4(hsv2rgb(vec3(fract(far * focalLength), 1.0, 1.0)), 1.0);\n            color = lambert(p, normal, lightDirection, lightColour);\n            \n            // fade to dark in the distance;\n            color *= far;\n            \n            break;\n        }\n        \n        if(t > 10.)\n        {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 174, 174, 207], [209, 209, 240, 240, 350], [352, 352, 386, 386, 420], [422, 422, 453, 453, 482], [484, 484, 518, 518, 674], [676, 676, 718, 718, 744], [746, 746, 775, 775, 980], [982, 982, 1006, 1006, 1267], [1269, 1269, 1336, 1336, 1585], [1587, 1587, 1639, 1639, 1816], [1818, 1818, 1840, 1840, 2171], [2173, 2173, 2195, 2195, 2364], [2366, 2366, 2421, 2421, 4026]], "test": "untested"}
{"id": "XtjSzR", "name": "Worley Tunnely", "author": "akaitora", "description": "A Worley Tunnel", "tags": ["tunnel", "worely"], "likes": 12, "viewed": 1767, "published": "Public API", "date": "1441050653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Endless Tunnel\n// By: Brandon Fogerty\n// bfogerty at gmail dot com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nvec2 hash( vec2 p )\n{\n\tmat2 m = mat2( \t34789.23472, 28371.2387,\n\t\t      \t58217.2387, 947823.213 );\n\t\n    p = mod( p, 4. );\n    \n\treturn fract( sin( m * p ) * 48938.43982 );\n}\n\nfloat v( vec2 p )\n{\n    p.x = mod(p.x,4.0);\n\tvec2 g = floor( p );\n\tvec2 f = fract( p );\n\t\n\tvec2 res = vec2( 1.0 );\n\tfor( int y = -1; y <= 1; y++ )\n\t{\n\t\tfor( int x = -1; x <= 1; x++ )\n\t\t{\n\t\t\tvec2 off = vec2( x, y );\n\t\t\tfloat h = distance( off + hash( g + off), f );\n\t\t\t\n\t\t\tif( h < res.x )\n\t\t\t{\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = h;\n\t\t\t}\n            else if( h < res.y )\n            {\n                res.y = h;\n            }\n\t\t}\n\t}\n\t\n\treturn res.y - res.x;\n}\n\n\nvec3 tunnel( vec2 p, float scrollSpeed, float rotateSpeed )\n{    \n    float a = 2.0 * atan( p.x, p.y );\n\n    a *= (3.0 / 3.141596);\n    \n    float r = length(p) * 0.9;\n    vec2 uvp = vec2( 0.4/r + (iTime*scrollSpeed), a + (iTime*rotateSpeed));\t\n    vec3 finalColor = vec3( v( uvp * 1.0 ) );\n    finalColor *= r * 5.0;\n\t\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float timeSpeedX = iTime * 0.3;\n    float timeSpeedY = iTime * 0.2;\n    vec2 p = uv + vec2( -0.50+cos(timeSpeedX)*0.2, -0.5-sin(timeSpeedY)*0.3 );\n\n    vec3 finalColor = tunnel( p , 1.0, 0.0);\n\n    fragColor = vec4( finalColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 184, 205, 205, 358], [360, 360, 379, 379, 813], [816, 816, 877, 877, 1160], [1162, 1162, 1219, 1219, 1505]], "test": "untested"}
{"id": "XtlXRs", "name": "metan grid", "author": "miloszmaki", "description": "experimenting with raymarching", "tags": ["3d", "raymarching"], "likes": 10, "viewed": 1315, "published": "Public API", "date": "1438990924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAYMARCH_ITER = 50;\nconst float RAYMARCH_EPS = 0.01;\nconst float PI = 3.14159265;\n\nfloat dPlane(vec3 p) { return p.y; }\nfloat dSphere(vec3 p, float r) { return length(p) - r; }\nfloat dBox(vec3 p, vec3 s) { return length(max(abs(p) - s, 0.)); }\n\nvec2 dUnion(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nvec3 pMov(vec3 p, vec3 t) { return p - t; }\nvec3 pRep(vec3 p, vec3 s) { return mod(p+.5*s, s) - .5*s; }\n\nvoid addSphere(inout vec2 d, vec3 pos, vec3 t, float mtl)\n{\n    d = dUnion(d, vec2(dSphere(pRep(pMov(pos, t), vec3(10,4,5)), 0.35), mtl));\n}\n\nvec2 scene(vec3 pos)\n{\n    vec2 d = vec2(dPlane(pMov(pos, vec3(0,-2,0))), 1.0);\n    addSphere(d, pos, vec3(0,1,0), 1.0);\n    addSphere(d, pos, vec3(0,-1,0), 1.0);\n    addSphere(d, pos, vec3(1,0,0), 1.0);\n    addSphere(d, pos, vec3(-1,0,0), 1.0);\n    addSphere(d, pos, vec3(0,0,1), 1.0);\n    addSphere(d, pos, vec3(0,0,-1), 1.0);\n    addSphere(d, pos, vec3(0,0,0), 1.0);\n    return d;\n}\n\nfloat rayMarch(vec3 eye, vec3 dir, float zn, float zf, out float mtl)\n{\n    float z = zn;\n    mtl = -1.0;\n    \n    for (int i=0; i < RAYMARCH_ITER; i++)\n    {\n        vec2 d = scene(eye + z * dir);\n        mtl = d.y;\n        if (d.x < RAYMARCH_EPS || z > zf) break;\n        z += d.x;\n    }\n    \n    if (z > zf) mtl = -1.0;\n    return z;\n}\n\nvec3 render(vec3 eye, vec3 dir)\n{\n    float mtl;\n    float dist = rayMarch(eye, dir, 1., 100., mtl);\n    \n    vec3 color = vec3(dist / 100.);\n    //if (mtl > 0.) color *= mtl;\n    \n    return clamp(color, 0., 1.);\n}\n\nvec3 lookAtDir(vec2 uv, vec3 eye, vec3 at, vec3 up, float fov)\n{\n    vec3 f = normalize(at - eye);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = normalize(cross(f, r));\n    return normalize(f + fov * (uv.x*r + uv.y*u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    vec2 uv0 = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = iTime * 0.3 + 0.5;\n    if (iMouse.z > 0.) angle = iMouse.x / iResolution.x * 2. * PI;\n    vec3 eye = vec3(sin(angle), 0.5 + sin(angle * 4.5)*0.1, cos(angle));\n    eye *= 8. + 2. * sin(iTime * 0.6);\n    vec3 dir = lookAtDir(uv, eye, vec3(0, 0, 0), vec3(0, 1, 0), 1.0);\n\t\n    float at = 0.005 + 0.008 * fract(sin(iTime) * 204.512598);\n    vec3 color;\n    color.r = render(eye, dir + vec3(-1,1,0)*at).x;\n    color.g = render(eye, dir).x;\n    color.b = render(eye, dir + vec3(0,-1,0)*at).x;\n    \n    color *= 1. - pow(max(0., length(uv0)-.5), 3.);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 115, 115, 129], [130, 130, 162, 162, 186], [187, 187, 215, 215, 253], [255, 255, 286, 286, 320], [322, 322, 349, 349, 365], [366, 366, 393, 393, 425], [427, 427, 486, 486, 567], [569, 569, 591, 591, 954], [956, 956, 1027, 1027, 1294], [1296, 1296, 1329, 1329, 1511], [1513, 1513, 1577, 1577, 1739], [1741, 1741, 1798, 1798, 2538]], "test": "untested"}
{"id": "XtsSWj", "name": "Hurrying To A Talk", "author": "Alway_PanicButton", "description": "A quick sketch of a familiar place.", "tags": ["sdf"], "likes": 17, "viewed": 1953, "published": "Public API", "date": "1439762093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t;\n#define HALF_PI 1.570796327\n\nfloat cube( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.));\n}\n\nfloat repeat( float p, float frequency )\n{\n    p = mod( p + frequency*.25, frequency );\n    p = abs( p - frequency * .5 );\n    return p;\n}\n\nfloat repeatfor( float p, float frequency, float n )\n{\n    if( abs(p) < frequency * n * .4999 )\n    {\n        p = mod( p + frequency*.25, frequency );\n    \tp = abs( p - frequency * .5 );\n    }\n    else\n    {\n        p = p - mod( frequency * n * .4999 + frequency*.25, frequency );\n        p = abs(p) - frequency * n * .5;\n    }\n    return p;\n}\n\nfloat mirror( float p, float offset )\n{\n    p = abs( p );\n    p -= offset;\n    return p;\n}\n\nvec2 mirrorDiag( vec2 p, vec2 offset )\n{\n    p -= offset;\n    if( p.x < p.y )\n        p.xy = p.yx;\n    p += offset;\n    return p;\n}\n\nvec2 mirrorDiag2( vec2 p, vec2 offset )\n{\n    p -= offset;\n    if( p.x > -p.y )\n        p.xy = -p.yx;\n    p += offset;\n    return p;\n}\n\nvec2 rot2( vec2 p, float theta )\n{\n    float co = cos( theta );\n    float si = sin( theta );\n    return vec2( co * p.x + si * p.y,\n                -si * p.x + co * p.y );\n}\n\nfloat sc( vec3 p )\n{\n    p.z -= 50.;\n    vec3 pb = p;\n    pb.z = repeatfor( pb.z, 16., 25. );\n    pb.x += 25.0;\n    vec3 pb8 = pb;\n    pb8.x -= 19.5;\n    pb8.y += 1.;\n    pb8.y = mirror( pb8.y, 5. );\n    float rail = cube( pb8, vec3( 0.1, 0.1, 8.0 ) );\n    vec3 pb7 = pb;\n    pb7.x -= 19.;\n    float pillar = cube( pb7, vec3( 0.2, 10.0, 0.2 ) );\n    vec3 pb6 = pb;\n    pb6.x -= 27.0;\n    float bar6 = cube( pb6, vec3( 8.0, 1.0, 8.0 ));\n    vec3 pb5 = pb;\n    pb5.x += 0.8;\n    if( pb5.y > 10. )\n    {\n        float theta = atan( .75*(pb5.y - 10.)/ ( pb5.x - 20.));\n        pb5.xy = rot2( pb5.xy, theta );\n    }\n    pb5.y -= 10.0;\n    pb5.y = mirror(pb5.y, 0.0);\n    pb5.y -= 10.0;\n    pb5.y = mirror( pb5.y, 0.0 );\n    pb5.z = mirror( pb5.z, 4.0 );\n    pb5.z = mirror( pb5.z, 2.0 );\n    pb5.z = abs(pb5.z);\n    pb5.z = -pb5.z;\n    pb5.y -= 3.0;\n    pb5.y = repeatfor( pb5.y, 2.4, 4.0 );\n    pb5.zy = mirrorDiag( pb5.zy, vec2(0.,1.2) );\n    float bar5 = cube( pb5, vec3( 0.1, 2.0, 0.1 ));\n    vec3 pb4 = pb;\n    pb4.x += 1.5;\n    pb4.y += 2.0;\n    float bar4 = cube( pb4, vec3( 0.75, 1., 8.));\n    vec3 pb3 = pb;\n    pb3.y -= 10.0;\n    float bar3 = cube( pb3, vec3( 1., 1., 8. ) );\n    vec3 pb2 = pb;\n    pb2.y = repeatfor( pb2.y, 2.0, 10. );\n    float bar2 = cube( pb2, vec3( 0.5, 0.5, 0.1 ));\n    vec3 pb1 = pb;\n    pb1.x = mirror( pb1.x, 0.55 );\n    float bar1 = cube( pb1, vec3( 0.25, 10.0, 0.25 ));\n    float bars = min(min(min( bar1, bar2 ), min(bar3, bar4)), \n                     min(min(bar5, bar6), min(pillar, rail)));\n    return bars;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n    \n  \tt = iTime;\n    \n    vec3 dir = normalize(vec3(uv, 1.0) );\n    vec3 p = vec3( -11., -4.75, -60. );\n    \n    p.xz = rot2( p.xz, 0. );\n    \tdir.xz = rot2( dir.xz, - .25 );\n    if( iMouse.z > 0.0 )\n    \tdir.xz = rot2( dir.xz, iMouse.x / iResolution.x - .25 );\n    \n    p.y += sin(5. * t) * .2;\n    p.z += mod(t * 10., 16.);\n    \n    float minDist = 0.;\n    for( float i = 0.; i < 50.; i++ )\n    {\n        minDist = sc( p );\n        p += dir * minDist;\n    }\n    \n    vec3 col = vec3( 1. );\n    if( minDist < .1 )\n    {\n        col = vec3(minDist * 10.0);\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 107], [109, 109, 151, 151, 247], [249, 249, 303, 303, 592], [594, 594, 633, 633, 684], [686, 686, 726, 726, 817], [819, 819, 860, 860, 953], [955, 955, 989, 989, 1127], [1129, 1129, 1149, 1149, 2676], [2678, 2678, 2735, 2735, 3420]], "test": "untested"}
{"id": "XtsSWl", "name": "Copy of motion blur from Iq", "author": "jacko", "description": "Copy of motion blur from Iq", "tags": ["motionblur"], "likes": 6, "viewed": 234, "published": "Public", "date": "1440603203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Analytic motion blur, for spheres\n//\n// (Linearly) Moving Spheres vs ray intersection test. The resulting equation is a double\n// quadratic in two parameters, distance (as usual in regular raytracing) and time. It's sort\n// of space-time raytracing if you wish.\n// \n// The quadratic(s) are solved to get the time interval of the intersection, and the distances.\n// Shading is performed only once at the middle of the time interval.\n//\n// This method allows for (virtually) inexpensive motion blur, without time supersampling.\n//\n// Uncomment the define bellow to have a side by side comparison with brute force supersampled \n// motion blur. Most of the look differences come from the choice of a single shading instant/point\n// rather than the full sequence. I think I might have done some small mistake somewhere in the \n// maths though.\n//\n// 2D case here: https://www.shadertoy.com/results?sort=newest\n\n#define USE_ANALYTICAL_MBLUR\n\n// intersect a MOVING sphere\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sp, in vec3 ve, out vec3 nor )\n{\n    float t = -1.0;\n\tfloat s = 0.0;\n\tnor = vec3(0.0);\n\t\n\tvec3  rc = ro - sp.xyz;\n\tfloat A = dot(rc,rd);\n\tfloat B = dot(rc,rc) - sp.w*sp.w;\n\tfloat C = dot(ve,ve);\n\tfloat D = dot(rc,ve);\n\tfloat E = dot(rd,ve);\n\tfloat aab = A*A - B;\n\tfloat eec = E*E - C;\n\tfloat aed = A*E - D;\n\tfloat k = aed*aed - eec*aab;\n\t\t\n\tif( k>0.0 )\n\t{\n\t\tk = sqrt(k);\n\t\tfloat hb = (aed - k)/eec;\n\t\tfloat ha = (aed + k)/eec;\n\t\t\n\t\tfloat ta = max( 0.0, ha );\n\t\tfloat tb = min( 1.0, hb );\n\t\t\n\t\tif( ta < tb )\n\t\t{\n            ta = 0.5*(ta+tb);\t\t\t\n            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );\n            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );\n            s = 2.0*(tb - ta);\n\t\t}\n\t}\n\n\treturn vec2(t,s);\n}\n\n// intersect a STATIC sphere\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sp, out vec3 nor )\n{\n    float t = -1.0;\n\tnor = vec3(0.0);\n\t\n\tvec3  rc = ro - sp.xyz;\n\tfloat b =  dot(rc,rd);\n\tfloat c =  dot(rc,rc) - sp.w*sp.w;\n\tfloat k = b*b - c;\n\tif( k>0.0 )\n\t{\n\t\tt = -b - sqrt(k);\n\t\tnor = normalize( (ro+rd*t) - sp.xyz );\n\t}\n\n\treturn t;\n}\n\nvec3 getPosition( float time ) { return vec3(     2.5*sin(8.0*time), 0.0,      1.0*cos(8.0*time) ); }\nvec3 getVelocity( float time ) { return vec3( 8.0*2.5*cos(8.0*time), 0.0, -8.0*1.0*sin(8.0*time) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\t\n\n\t// camera\n\tvec3  ro = vec3(0.0,0.0,4.0);\n    vec3  rd = normalize( vec3(p.xy,-2.0) );\n\t\n    // sphere\t\n\t\n\t// render\n\tvec3  col = vec3(0.0);\n\t\n\t#ifdef USE_ANALYTICAL_MBLUR\n\t\n    //---------------------------------------------------\t\n    // render with analytical motion blur\n    //---------------------------------------------------\t\n\tvec3  ce = getPosition( iTime );\n\tvec3  ve = getVelocity( iTime );\n    \t\n\tcol = vec3(0.25) + 0.3*rd.y;\n\tvec3 nor = vec3(0.0);\n\tvec3 tot = vec3(0.25) + 0.3*rd.y;\n    vec2 res = iSphere( ro, rd, vec4(ce,1.0), ve/24.0, nor );\n    \n    vec3  ce2 = getPosition( iTime -  0.001);\n\tvec3  ve2 = getVelocity( iTime - 0.001);\n    \t\n    vec2 res2 = iSphere( ro, rd, vec4(ce2,1.0), ve2/24.0, nor );\n    \n\tfloat t = res.x;\n//\tif( t>0.0 )\n//\t{\n//\t\tfloat dif = clamp( dot(nor,vec3(0.5703)), 0.0, 1.0 );\n//\t\tfloat amb = 0.5 + 0.5*nor.y;\n//\t\tvec3  lcol = dif*vec3(1.0,0.9,0.3) + amb*vec3(0.1,0.2,0.3);\n//\t\tcol = mix( tot, lcol, res.y );\n//\t}\n    col = vec3(abs(res.y - res2.y));\n\t\n\t#else\n\t\n    //---------------------------------------------------\t\n    // render with brute force sampled motion blur\n    //---------------------------------------------------\t\n\t\n    #define NUMSAMPLES 32\n\tvec3 tot = vec3(0.0);\n\tfor( int i=0; i<NUMSAMPLES; i++ )\n\t{\n\t\tfloat fi = float(i)/float(NUMSAMPLES);\n        vec3  ce = getPosition( iTime + fi/24.0 );\n        vec3 nor = vec3(0.0);\n        vec3 tmp = vec3(0.25) + 0.3*rd.y;\n        float t = iSphere( ro, rd, vec4(ce,1.0), nor );\n        if( t>0.0 )\n        {\n            float dif = clamp( dot(nor,vec3(0.5703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            tmp = dif*vec3(1.0,0.9,0.3) + amb*vec3(0.1,0.2,0.3);\n        }\n        col += tmp;\n\t}\t\t\n\tcol /= float(NUMSAMPLES);\n\t\t\n    #endif\n\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsSWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1064, 1093, 1171, 1171, 1880], [1882, 1911, 1978, 1978, 2217], [2219, 2219, 2251, 2251, 2320], [2321, 2321, 2353, 2353, 2422], [2424, 2424, 2481, 2481, 4431]], "test": "untested"}
{"id": "XtSSzR", "name": "Anemone Ocean", "author": "public_int_i", "description": "anemone ocean", "tags": ["raymarch"], "likes": 5, "viewed": 298, "published": "Public", "date": "1440813669", "time_retrieved": "2021-10-01T00:00:00", "image_code": " //Ethan Alexander Shulman 2015   http://etahn.com/\n  //Raymarched scene\n\n  \n  #define EPSILON .01\n  #define ITERATIONS 128\n  //#define USE_SMIN\n  #define SMIN_AMOUNT .4\n  #define VIEW_DISTANCE 90.\n  \n  //thank you to inigo quilez for your awesome tutorials and examples on raymarching http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n  float sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n  }\n  \n  float smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n  }\n  \n  \n  vec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n  \n      const vec3 REPEAT = vec3(2.,0.,2.); \n  float thingy(in vec3 p) {\n    vec3 lp = mod(abs(p),REPEAT)-REPEAT/2.;\n    vec3 flp = floor(abs(p)/vec3(REPEAT.x,1.,REPEAT.z));\n    float ph = ((cos(flp.x+iTime)+cos(flp.z+cos(flp.x*16.452+iTime*2.234)))+2.5);\n        \n      \n    vec3 pa = lp;\n    vec3 ba = vec3(0.,1.,0.);\n      ba.y *= ph*1.4;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      float r = .5;//.499-max(0.,(ph-2.5))*.2;\n    return length( pa - ba*h ) - r;\n      \n      //return sdCapsule(lp,vec3(0.,0.,0.),vec3(0.,ph*1.4,0.),.499-max(0.,(ph-2.5))*.2);\n  }\n\n  float getDistance(in vec3 p) {\n    #ifdef USE_SMIN\n      return smin(thingy(p),\n          smin(thingy(p-vec3(.5,0.,0.)*REPEAT),\n            smin(thingy(p-vec3(0.,0.,.5)*REPEAT),\n              smin(thingy(p+vec3(.5,0.,0.)*REPEAT),thingy(p+vec3(0.,0.,.5)*REPEAT),SMIN_AMOUNT),SMIN_AMOUNT),SMIN_AMOUNT), SMIN_AMOUNT\n          )*.65;\n    #else\n    return min(thingy(p),\n          min(thingy(p-vec3(.5,0.,0.)*REPEAT),\n            min(thingy(p-vec3(0.,0.,.5)*REPEAT),\n              min(thingy(p+vec3(.5,0.,0.)*REPEAT),thingy(p+vec3(0.,0.,.5)*REPEAT))))\n          )*.65;\n  #endif\n  }\n  vec3 getNormal(in vec3 p) {\n     const vec2 NE = vec2(0.04,0.0);\n     return normalize(vec3(getDistance(p+NE.xyy)-getDistance(p-NE.xyy),\n                          getDistance(p+NE.yxy)-getDistance(p-NE.yxy),\n                          getDistance(p+NE.yyx)-getDistance(p-NE.yyx)));\n  }\n  vec3 getBackground(in vec3 dir) {\n    return vec3(0.);\n  }\n  \n  float ambientOcclusion(in vec3 p, in vec3 norm) {\n\n  #define AO_ITERATIONS 14\n  #define AO_PRECISION .25\n  #define AO_INTENSITY 1.\n  #define AO_ATTEN 0.44\n\n    float sum = 0.0;\n    float atten = 1.0;\n    float s = AO_PRECISION;\n    \n    float d;\n    \n\t    for (int i = 0; i < AO_ITERATIONS; i++) {\n        d = getDistance(p+norm*s);\n        \n        sum += (s-d)*atten;\t\t\n        s += AO_PRECISION;\t\n        atten *= AO_ATTEN;\n\t    }\n\t\n\t    return 1.0-max(0.0,sum*AO_INTENSITY);\n  \n  }\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 R = iResolution.xy;\n\n    vec3 ro = vec3(0.,10.,0.);\n    vec2 cuv = (fragCoord.xy-R*.5)/R;\n    vec3 rd = normalize(vec3(rot(cuv,0.),1.0));\n  \n    float d,s = 0.01;\n    for (int i = 0; i < ITERATIONS; i++) {\n         d = getDistance(ro+rd*s);\n         if (d < EPSILON || s > VIEW_DISTANCE) break;\n         s += d;\n         rd = normalize(vec3(rot(cuv,pow(s/40.,2.4)),1.0));\n    }\n  \n    if (d > EPSILON) {\n      fragColor = vec4(0.,0.,0.,1.);\n      return;\n    }\n  \n    vec3 hit = ro+rd*s;\n    vec3 normal = -getNormal(hit);\n    vec3 c = vec3(.3,.45,.94)*(.6+(cos(hit.x*.2+iTime)+cos(hit.y*.2+iTime)+cos(hit.z*.2-iTime*3.)*.2+.4));\n    \n    vec3 globalLightDir = normalize(vec3(2.,8.,4.));\n    c = c*ambientOcclusion(hit,-normal)*(.5+max(0.,1.-dot(normal,rd))*.5);\n    c *= 1.6;\n  \n    c = mix(c,vec3(0.),min(1.,pow(s/VIEW_DISTANCE,.5)));\n    \n   fragColor = vec4(c,1.0);\n  }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 359, 411, 411, 540], [546, 546, 587, 587, 682], [691, 691, 726, 726, 811], [860, 860, 885, 885, 1393], [1397, 1397, 1427, 1427, 1973], [1976, 1976, 2003, 2003, 2260], [2263, 2263, 2296, 2296, 2321], [2327, 2327, 2376, 2376, 2812], [2816, 2816, 2873, 2873, 3756]], "test": "untested"}
{"id": "XtsXRX", "name": "Crazy Waves", "author": "Alkama", "description": "A more hectic (and simpler) version of \"waves by bonniem\" https://www.shadertoy.com/view/4dsGzH", "tags": ["2d", "waves"], "likes": 43, "viewed": 6399, "published": "Public API", "date": "1438554186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 wave_color = vec3(0.0);\n\n\tfloat wave_width = 0.0;\n\tuv  = -3.0 + 2.0 * uv;\n\tuv.y += 0.0;\n\tfor(float i = 0.0; i <= 28.0; i++) {\n\t\tuv.y += (0.2+(0.9*sin(iTime*0.4) * sin(uv.x + i/3.0 + 3.0 *iTime )));\n        uv.x += 1.7* sin(iTime*0.4);\n\t\twave_width = abs(1.0 / (200.0*abs(cos(iTime)) * uv.y));\n\t\twave_color += vec3(wave_width *( 0.4+((i+1.0)/18.0)), wave_width * (i / 9.0), wave_width * ((i+1.0)/ 8.0) * 1.9);\n\t}\n\n\tfragColor = vec4(wave_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 557]], "test": "untested"}
{"id": "XtsXzX", "name": "Creepers", "author": "dirkadirkadan", "description": "creepin'", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 161, "published": "Public", "date": "1438572340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define eps 0.05\n\nvec3 mat;\n\nfloat noise (vec2 p)\n{\n    p += 0.00132*iTime;\n\treturn sin(5355.*p.x)+sin(5494.*p.y)+cos(345.*p.x)+cos(3572.*p.y);\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat lacunarity = 2.2;\n\tfloat gain = .5832;\n\tfloat total = 0.0;\n\tfloat frequency = .00012;\n\tfloat amplitude = gain;\n                \n\tfor (int i = 0; i < 4; ++i)\n\t{\n        total += noise(p.xz*frequency) * amplitude;         \n        frequency *= lacunarity;\n        amplitude *= gain;\n\t}\n\t\n\treturn total;\n}                       \n\nfloat de(vec3 z)\n{\t\n    float flr = z.y + .3+.2*sin(z.z+z.x)+.125*cos(2.+z.z);\n\tfloat creeper = z.y + 2.3 + flr +fbm(z);\n    \n    float sandiness = step(flr, creeper);\n    float creeperness = 1.-sandiness;\n    mat = sandiness*vec3(.7,.6,.3) + creeperness*vec3(.1);\n    \n\treturn min(creeper, flr);\n}\n\nvec3 norm(vec3 p)\n{\n\tfloat d = de(p);\n\tfloat x = de(vec3(p.x+eps,p.y,p.z))-d;\n\tfloat y = de(vec3(p.x,p.y+eps,p.z))-d;\n\tfloat z = de(vec3(p.x,p.y,p.z+eps))-d;\n\t\n\treturn normalize(vec3(x,y,z));\n}\n\nvoid fog(in vec3 fog_color, in float dist, inout vec3 col)\n{\n\tfloat amount = 1.-exp(-dist*dist*.00052);\n\tcol = mix(col, fog_color, amount);\n}\n\nvoid trace(in vec3 ro, in vec3 rd, out vec3 col)\n{\n\tfloat d = 0.;\n\t\t\n\tvec3 fog_color = vec3(.8, .7, .1);\n\tcol = vec3(0.);\n\t\t\n\tfor (int i = 0; i < 120; i++)\n\t{\n\t\tvec3 pt = ro+rd*d;\n\t\t\n\t\tfloat s = de(pt);\n\t\n\t\td += .91*s;\n\t\t\n\t\tif (s < eps)\n\t\t{\n\t\t\tvec3 n = norm(pt);\n\t\t\t\n\t\t\tfloat light = pow(dot(-n, normalize(vec3(-1.))), 1.);\n\t\t\tcol += .7*vec3(light);\n\t\t\t\t\t\t\n\t\t\tfloat edge = 1.-abs(dot(normalize(pt-ro), n));\n\t\t\t\n\t\t\tcol += .9*edge*edge*edge;\n\t\t\tcol *= mat;\t\t\t\n\t\t\n            fog(fog_color, d, col);\n            \n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvec3 sky_color = vec3(.0, .0, .9);//+vec3(1.)*abs(.2*noise(rd.xz*.007));\n\t\n\tif (dot(col, col) == 0.) col = mix(fog_color, sky_color, rd.y*5.);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.*uv-1.;\n    \n    vec3 col;\n    \n    trace(vec3(uv+vec2(0.,1.), 10.), normalize(vec3(uv, -1.)), col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 145], [147, 147, 166, 166, 476], [501, 501, 519, 519, 799], [801, 801, 820, 820, 994], [996, 996, 1056, 1056, 1137], [1139, 1139, 1189, 1189, 1814], [1817, 1817, 1874, 1874, 2063]], "test": "untested"}
{"id": "XtXXWX", "name": "9 Sensatron Countdown Sequence", "author": "evilzug", "description": "a sequence that plays when sensatron is about to head out - colors change from blue, to red, to yellow, to green, to flashing green and white", "tags": ["sensatron", "sensatom", "countdown"], "likes": 0, "viewed": 157, "published": "Public", "date": "1440022477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb_smooth( in vec3 c ) { vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y); }\nvec3 outputColor(float aFinalHue, float aFinalSaturation, float aFinalValue) { return hsv2rgb_smooth(vec3(aFinalHue, aFinalSaturation, aFinalValue)); }\nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\nfloat convertHue(float aHue) { return aHue/360.0; }\n\nconst float PURPLE = 304.0;\nconst float BLUE = 239.0;\nconst float CYAN = 183.0;\nconst float GREEN = 131.0;\nconst float YELLOW = 62.0;\nconst float ORANGE = 42.0;\nconst float RED = 0.0;\n\nfloat ROWS = 12.0;\n\nfloat evaluateColor(in vec2 fragCoord, in float aCycle, in float aCycleDelay) {\n//float evaluateColor(in float aRow, in vec2 fragCoord, in float aCycle) {\n    float tFinalHue = 0.0;\n    float iCurrentTime = iTime - aCycleDelay;\n    //float iCurrentTime = iTime - (aCycle * aRow);\n    float tPercentTimeUntilAllRed = iCurrentTime/aCycle;\n    if (tPercentTimeUntilAllRed > (fragCoord.x/iResolution.x) + sin(iTime * 5.0)*.1 + sin(iTime * 3.0)*.1 ) {\n        tFinalHue = convertHue(RED) + sin(iTime*1.1)*.075;\n        if (tPercentTimeUntilAllRed > 1.0) {\n            float tPercentTimeUntilAllYellow = (iCurrentTime-aCycle*12.0)/aCycle;\n            if (tPercentTimeUntilAllYellow > (fragCoord.x/iResolution.x)  + sin(iTime * 5.0)*.1 + sin(iTime * 3.0)*.1 ) {\n                tFinalHue = convertHue(YELLOW) + abs(sin(iTime*0.9)*.05)*-1.0;\n                float tPercentageTimeUntilAllGreen = (iCurrentTime-aCycle*2.0*12.0)/aCycle;\n                if (tPercentageTimeUntilAllGreen > (fragCoord.x/iResolution.x)  + sin(iTime * 5.0)*.1 + sin(iTime * 3.0)*.1 ) { \n                    tFinalHue = convertHue(GREEN);\n                }\n            }\n        }\n    } else {\n        tFinalHue = convertHue(BLUE) + abs(sin(iTime * .6)*.075);\n    }\n    return tFinalHue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tCountdownTimeInMinutes = 10.0;\n    float tSecondsInAMinute = 60.0;\n    float tTotalTimeInSeconds = tCountdownTimeInMinutes * tSecondsInAMinute;\n    float tColors = 3.0;\n    float tCycle = (tTotalTimeInSeconds/tColors)/ROWS;\n    float tFinalHue = 0.0;\n    float tFinalSaturation = 1.0;\n    if (fragCoord.y > (iResolution.y * (11.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*0.0);\n    } else if (fragCoord.y > (iResolution.y * (10.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*1.0);\n    } else if (fragCoord.y > (iResolution.y * (9.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*2.0);\n    } else if (fragCoord.y > (iResolution.y * (8.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*3.0);\n    } else if (fragCoord.y > (iResolution.y * (7.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*4.0);\n    } else if (fragCoord.y > (iResolution.y * (6.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*5.0);\n    } else if (fragCoord.y > (iResolution.y * (5.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*6.0);\n    } else if (fragCoord.y > (iResolution.y * (4.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*7.0);\n    } else if (fragCoord.y > (iResolution.y * (3.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*8.0);\n    } else if (fragCoord.y > (iResolution.y * (2.0/ROWS))) {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*9.0);\n    } else if (fragCoord.y > (iResolution.y * (1.0/ROWS))) {    \n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*10.0);\n    } else {\n        tFinalHue = evaluateColor(fragCoord, tCycle, tCycle*11.0);\n    }\n    \n    float tPercentageTimeUntilDone = iTime/(tCycle*3.0*12.0);\n    if (tPercentageTimeUntilDone > 1.0 ) {\n        tFinalSaturation = abs(sin(iTime)) * .5;\n    }\n    \n\tfragColor = vec4(outputColor(tFinalHue, tFinalSaturation, 1.0), 1.0);\n}\n\n/*\nfor (float i = 0.0; i < 12.0; i++) {\n        if (fragCoord.y > (iResolution.y * (11.0/ROWS)) && \n            fragCoord.y < (iResolution.y * (12.0/ROWS))) { //trying to figure out how to mod with 'i'\n            tFinalHue = evaluateColor(i, fragCoord, tCycle); //???\n            break;\n        }\n    }\n*/\n\n/* previous non-for-looped code\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 184], [185, 185, 263, 263, 336], [337, 337, 358, 358, 428], [429, 429, 459, 459, 480], [687, 687, 766, 841, 1943], [1945, 1945, 2002, 2002, 4024]], "test": "untested"}
