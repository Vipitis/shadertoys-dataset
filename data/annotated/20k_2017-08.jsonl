{"id": "4d2BDV", "name": "crosshairs", "author": "BigotedSJW", "description": "just a simple thing illustrating the mouse coordinates; was thinking of making either https://www.shadertoy.com/view/4dtSzN or https://www.shadertoy.com/view/XstGRf per pixel interactive, but per insomnia, I settled with this", "tags": ["2d", "simple"], "likes": 0, "viewed": 109, "date": "1502278502", "time_retrieved": "2024-06-20T18:59:07.492480", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   //https://www.shadertoy.com/view/ldjSzd\n    bool iMouseDown = !(iMouse.z < 0.);//thanks aaaidan\n\t\n    vec2 uv = fragCoord.xy / iResolution.x;\n    float height = iResolution.y / iResolution.x;\n    \n    vec2 normMouse = iMouse.xy / iResolution.x;\n    \n    //corrected for preview per FabriceNeyret\n    if(!iMouseDown || iMouse == vec4(0.)) { normMouse = vec2(0.5,0.5*height); }\n    \n    vec2 dirMouse = normMouse-uv;\n    vec2 clamped = 1.0-step(abs(dirMouse), vec2(1.0)/iResolution.x); \n    //todo: make 1px wide instead of 2, round to upper right\n    \n\tvec3 color = vec3(uv,0.5+0.5*sin(iTime));\n    vec3 negColor = 1.0-color;\n    vec3 choosenColor = mix(negColor,color,clamped.x*clamped.y);\n    \n    \n    fragColor =vec4(choosenColor,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2BDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 99, 802]]}
{"id": "4d2BWG", "name": "36.0202", "author": "etrepum", "description": "eclipse", "tags": ["eclipse"], "likes": 2, "viewed": 96, "date": "1501953742", "time_retrieved": "2024-06-20T18:59:07.492480", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.4 * min(iResolution.x, iResolution.y);\n    vec3 blur = 30.0 + 28.0 * sin(iTime * vec3(1, 1.1, 1.2));\n    vec2 c = 0.5 * iResolution.xy;\n    float d0 = max(0.0, distance(fragCoord, c) - radius);\n    vec3 dist = smoothstep(-0.25 * blur, blur, vec3(d0));\n    vec2 pt = fragCoord - c;\n    float amul = 1.0 + 0.5 * sin(iTime * 0.002) * sin(iTime + atan(pt.y, pt.x));\n    float alpha = 1.0 - smoothstep(0.0, amul * max(max(blur.x, blur.y), blur.z), d0);\n\tfragColor = vec4(\n        alpha * dist,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2BWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 588]]}
{"id": "4d2fDd", "name": "Hyperbolic Trig", "author": "dust", "description": "Experimenting with ray-marched trig functions\nEDIT: Implemented DIY cosh/sinh to improve support for early versions of GLSL ES", "tags": ["procedural", "3d", "raymarching", "grayscale"], "likes": 1, "viewed": 164, "date": "1502860643", "time_retrieved": "2024-06-20T18:59:07.990255", "image_code": "// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Manual implementation of [sinh] for devices with early\n// versions of GLSL ES\nfloat Sinh(float area)\n{\n    float e = 2.718;\n    return (pow(e, area) - pow(e, area * -1.0)) / 2.0;\n}\n\n// Manual implementation of [cosh] for devices with early\n// versions of GLSL ES\nfloat Cosh(float area)\n{\n    float e = 2.718;\n    return (pow(e, area) + pow(e, area * -1.0)) / 2.0;    \n}\n\nfloat TrigDF(vec3 coord, vec3 trigPos)\n{\n    coord -= trigPos;\n    coord = QtnRotate(coord, vec4(vec3(0.9, 0.0, 0.0) * sin(iTime), cos(iTime)));\n    float coordAccum = coord.x * coord.y + coord.z;\n    return length(coord) - Cosh(coordAccum) / Sinh(coordAccum);\n}\n\nvec3 GetNormal(vec3 samplePoint, float eps, vec3 trigPos)\n{\n    float normXA = TrigDF(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z), trigPos);\n    float normXB = TrigDF(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z), trigPos);\n\n    float normYA = TrigDF(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z), trigPos);\n    float normYB = TrigDF(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z), trigPos);\n\n    float normZA = TrigDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps), trigPos);\n    float normZB = TrigDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps), trigPos);\n\n    return normalize(vec3(normXA - normXB,\n                          normYA - normYB,\n                          normZA - normZB));\n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float eps = 0.00001;\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 trigPos = vec3(0.0, 0.0, 4.0);\n    for (int i = 0; i < 255; i += 1)\n    {\n        vec3 eyePos = vec3(0.0, 0.0, -3.0);\n    \tvec3 rayVec = eyePos + (rayDir * currRayDist);\n        float trgDist = TrigDF(rayVec, trigPos);\n        if (trgDist < eps)\n        {   \n            float nDL = dot(GetNormal(rayVec, eps, trigPos), \n                            normalize(vec3(1.0, 1.0, -1.0)));\n            fragColor = vec4(nDL, nDL, nDL, 1.0);\n            return;\n        }\n        \n        currRayDist += trgDist;\n    }\n    \n\tfragColor = vec4(0.8, 0.8, 0.8, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2fDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 46, 73, 73, 115], [117, 159, 198, 198, 421], [423, 499, 535, 535, 632], [634, 715, 739, 739, 817], [819, 900, 924, 924, 1006], [1008, 1008, 1048, 1048, 1270], [1272, 1272, 1331, 1331, 2025], [2027, 2027, 2083, 2083, 2209], [2211, 2211, 2268, 2268, 2949]]}
{"id": "4d2fWV", "name": "Matrix Pixels", "author": "k_kondrak", "description": "Single pixel-based matrix rain.", "tags": ["procedural", "2d", "matrix", "onetweet"], "likes": 17, "viewed": 917, "date": "1502280391", "time_retrieved": "2024-06-20T18:59:07.990255", "image_code": "// ----------------------------------------------------\n//  \"Matrix Pixels\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    p.y /= iResolution.y;\n    p.y += tan(iTime + tan(p.x) + sin(.2 * p.x));\n    o = vec4(0., .3 + (p.y < 0. ? 0. : 1. - p.y * 3.), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2fWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 165, 201, 201, 343]]}
{"id": "4dBBWt", "name": "Basic Raymarching - Spheres", "author": "CaliCoastReplay", "description": "My first attempt at truly learning raymarching principles from the ground up.  Experiments in faked backlit \"global illumination\" and Fresnel shadows. Using tutorial work from:\n\nhttp://www.michaelwalczyk.com/blog/2017/5/25/ray-marching", "tags": ["raymarching"], "likes": 4, "viewed": 272, "date": "1502636125", "time_retrieved": "2024-06-20T18:59:08.674941", "image_code": "//Learning from : http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching\n\n//Contains some experimental terms to simulate global illumination\n//on backside of object via a variation\n//on specular highlights, and the use of Fresnel terms\n//for both light and shadow on the outside of objects.\n\n//Comments encouraged - code will be commented for teaching purposes soon.\n\n//--CaliCoastReplay\n\nfloat distance_from_sphere(in vec3 world_point, in vec3 sphere_center, float radius)\n{\n    return length(world_point - sphere_center) - radius;\n}\n\n\nfloat map_the_world(in vec3 world_point)\n{\n    \n //   float sphere_0 = distance_from_sphere(p, vec3(-0.4 + cos(iTime), 0.0, 0.0), 1.5);    \n //   float sphere_1= distance_from_sphere(p, vec3(2.4 + sin(iTime), 1.0, 1.5), 1.5);\n //   float sphere_2= distance_from_sphere(p, vec3(-0.0 + cos(iTime+1.57), 2.0,3.0),1.5);\n      \n    float sphere_0 = distance_from_sphere(world_point, vec3(-0.4, 0.0, 0.0), 1.5);    \n    float sphere_1= distance_from_sphere(world_point, vec3(2.4, 1.0, 1.0), 1.5);\n    float sphere_2= distance_from_sphere(world_point, vec3(-0.0, 2.0,2.0),1.5);\n    \n    return min(min(sphere_0, sphere_1), sphere_2);\n}\n\nvec3 calculate_normal(in vec3 world_point)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(world_point + small_step.xyy)\n        - map_the_world(world_point - small_step.xyy);\n    float gradient_y = map_the_world(world_point + small_step.yxy) \n        - map_the_world(world_point - small_step.yxy);\n    float gradient_z = map_the_world(world_point + small_step.yyx) \n        - map_the_world(world_point - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_march(in vec3 ray_origin, in vec3 ray_direction)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 64;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ray_origin + total_distance_traveled * ray_direction;\n\n\t\tfloat distance_to_closest = map_the_world(current_position);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            \n            vec3 light_positions[3];\n            light_positions[0] = vec3(1.0+sin(iTime)*5.0, -3.0+3.0*cos(iTime/3.0), 4.0 + 1.0 *sin(iTime/5.0));\n            light_positions[1] = vec3(1.0-sin(iTime/2.0)*2.0, -1.0-cos(iTime/2.0), 7.0 + 1.0 -sin(iTime/4.0));\n            light_positions[2] = vec3(2.0-sin(iTime/2.0)*2.0, -5.0-sin(iTime/4.0), 2.0 + 1.0 -sin(iTime/1.0));\n            float light_intensities[3];\n            light_intensities[0] = 0.8;\n            light_intensities[1] = 0.4;\n            light_intensities[2] = 0.7;\n            vec3 direction_to_view = normalize(current_position - ray_origin);\n            \n            vec3 col = vec3(0.0);\n            \n            for (int j = 0; j < 3; j++)\n            {\n                vec3 direction_to_light = normalize(current_position - light_positions[j]);\n                vec3 light_reflection_unit_vector =\n                \t reflect(direction_to_light ,normal);                \n\n                float diffuse_intensity = 0.6*pow(max(0.0, dot(normal, direction_to_light)),5.0);            \n                float ambient_intensity = 0.2;            \n                float specular_intensity = \n                    1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 50.0);\n                float backlight_specular_intensity =             \n                    0.2* pow(clamp(dot(direction_to_light, light_reflection_unit_vector),0.0,1.0), 3.0); \n                float fresnel_base = 1.0 + dot(direction_to_view, normal);\n                float fresnel_intensity = 0.10*pow(fresnel_base, 0.3);\n                float fresnel_shadowing = pow(fresnel_base, 5.0);            \n                float fresnel_supershadowing = pow(fresnel_base, 50.0);\n                float attenuation =  pow(total_distance_traveled,2.0)/180.0;\n\n                \n            \tvec3 colFromLight = vec3(0.0);\n                colFromLight += vec3(0.89, 0.0, 0.0) * diffuse_intensity;\n                colFromLight += vec3(0.3, 0.1, 0.1) * ambient_intensity;\n                colFromLight += vec3(1.0) * specular_intensity;            \n                colFromLight += vec3(1.0,0.5,0.5) * backlight_specular_intensity;            \n                colFromLight += vec3(1.0, 0.1, 0.2) * fresnel_intensity;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_shadowing ;\n                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_supershadowing * col * col;\n                colFromLight += vec3(.3, 0.1, 0.1) - attenuation ; \n               \tcolFromLight /= 1.2;\n                colFromLight *= light_intensities[j];\n                col += colFromLight;\n            }\n            return col;\n        }\n\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\n    vec3 camera_position = vec3(0.5, 0.5 + sin(iTime)/2.0, -6.0+cos(iTime));\n    vec3 ray_origin = camera_position;\n    vec3 ray_direction = vec3(uv, 1.0);\n\n    vec3 shaded_color = ray_march(ray_origin, ray_direction);\n\n    fragColor = vec4(shaded_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBBWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[371, 392, 478, 478, 537], [540, 540, 582, 855, 1168], [1170, 1170, 1214, 1214, 1728], [1730, 1730, 1789, 1789, 5160], [5162, 5162, 5219, 5219, 5548]]}
{"id": "4dBBWV", "name": "EquirectRemap", "author": "diroru", "description": "This is probably cheating, but alas, couldn't find a better way. The latlon-translation is mapped to two rotations in 3d space and then brought back to an equirectangular projection. Waiting to be lapidated (since \"stoned\" is a bit ambiguous).", "tags": ["projection", "equirectangular", "geovis", "platecarre", "rhumbs"], "likes": 12, "viewed": 410, "date": "1502138013", "time_retrieved": "2024-06-20T18:59:08.674941", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat map(float v, float low1, float high1, float low2, float high2) {\n\treturn (v-low1)/(high1-low1)*(high2-low2);\n}\n\nvec2 xyzToLonLat(vec3 v) {\n    vec3 p = normalize(v);\n    float lat = map(asin(p.y), PI*0.5, -PI*0.5, 0.0, 1.0);\n    float lon = map(atan(p.x, -p.z), PI, -PI, 0.0, 1.0);\n    return vec2(lon, lat);\n}\n\nvec3 lonLatToXYZ(vec2 lonLat) {\n  float lon = map(lonLat.x, 0.0, 1.0, -PI, PI);\n  float lat = map(lonLat.y, 0.0, 1.0, -PI*0.5, PI*0.5);\n  float x = sin(lat)*sin(lon);\n  float y = cos(lat);\n  float z = sin(lat)*cos(lon);\n  return vec3(x,y,z);\n}\n\nvec3 xRot(vec3 v, float theta) {\n  float x = v.x;\n  float y = v.y*cos(theta) - v.z*sin(theta);\n  float z = v.y*sin(theta) + v.z*cos(theta);\n  return vec3(x,y,z);\n}\n\nvec3 yRot(vec3 v, float theta) {\n  float x = v.z*sin(theta) + v.x*cos(theta);\n  float y = v.y;\n  float z = v.z*cos(theta) - v.x*sin(theta);\n  return vec3(x,y,z);\n}\n\nvec3 zRot(vec3 v, float theta) {\n  float x = v.x*cos(theta) - v.y*sin(theta);\n  float y = v.x*sin(theta) + v.y*cos(theta);\n  float z = v.z;\n  return vec3(x,y,z);\n}\n\nvec2 equiRemap(vec2 lonLat, vec2 delta) {\n    vec3 v = lonLatToXYZ(lonLat);\n\tv = yRot(v,delta.x);\n    v = xRot(v,delta.y);\n    return xyzToLonLat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float graticuleSize = 0.05;\n    float graticuleWeight = 0.003;\n    //line to be visualised\n\n    //normalized lonLat\n\tvec2 lonLat = fragCoord.xy / iResolution.xy;\n    lonLat = equiRemap(lonLat, vec2(iTime*0.2,iTime*0.4));\n\tfragColor = vec4(lonLat,0.0,1.0);\n    vec2 graticuleDist = mod(lonLat + vec2(graticuleWeight*0.5),vec2(graticuleSize));\n    if (graticuleDist.x < graticuleWeight || graticuleDist.y < graticuleWeight) {\n    \tfragColor += vec4(0.5);\n    }\n    \n    //visualising a rhumb line, x is lon, y is lat\n    //normalized over \n    vec2 p0 = vec2(0.0,0.0);\n    vec2 p1 = vec2(7.0,1.0);\n    float slope = (p1.y-p0.y)/(p1.x-p0.x);\n    float theta = atan(p1.y-p0.y,p1.x-p0.x);\n    float lineHalfWeight = 0.01*(1.0+cos(theta));\n    bool b0 = atan(mod(lonLat.y,slope)-p0.y,lonLat.x-p0.x+lineHalfWeight) < theta;\n    bool b1 = atan(mod(lonLat.y,slope)-p0.y,lonLat.x-p0.x-lineHalfWeight) > theta;\n    if (b0 && b1 ){\n    \tfragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBBWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[46, 46, 116, 116, 162], [164, 164, 190, 190, 362], [364, 364, 395, 395, 607], [609, 609, 641, 641, 772], [774, 774, 806, 806, 937], [939, 939, 971, 971, 1102], [1104, 1104, 1145, 1145, 1255], [1257, 1257, 1314, 1314, 2289]]}
{"id": "4dBfWV", "name": "Laser Beam", "author": "AlphaRogue", "description": "Sinus waves, looking like circular laser beam.", "tags": ["waves", "sin", "cos", "sinus", "helix", "circular", "cosinus"], "likes": 4, "viewed": 309, "date": "1502143075", "time_retrieved": "2024-06-20T18:59:08.674941", "image_code": "#define M_PI2 1.570796326\n#define MOD .001\n#define FREQ .8\n\nfloat cosinus (float angle, float amplitude) { return cos(angle / FREQ) * amplitude; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 lM = vec2(max(iResolution.x, iResolution.y), min(iResolution.x, iResolution.y));\n\tvec2 pos = ( fragCoord -.5 * lM) / lM.x;\n\n\tfloat advance = pos.x + .5;\n\n\tfloat thickness = MOD / 1.5;\n\tfloat val = iTime * .4 + (advance / MOD) * M_PI2;\n\tfloat size = thickness * 5. * (cosinus(val, 1.) + 2.);\n\n\tpos.x = mod(advance, MOD);\n\tbool isIn = abs(pos.y) - thickness < 0.;\n\tif (distance(pos, vec2(0., sin(val / FREQ) * .05)) < size && (!isIn || cosinus(val, 1.) > .1 * M_PI2)) \n        fragColor = vec4(cosinus(val, -1.), cosinus(val, 1.), .8, 1.);\n\telse if (isIn) {\n\t\tfloat delta = abs(sin(advance - iTime));\n\t\tfragColor = vec4(.2, .1 + .1 * delta, .4 + .3 * delta, 1.);\n\t}\n\telse fragColor = vec4(0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBfWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[60, 60, 106, 106, 146], [148, 148, 204, 204, 904]]}
{"id": "4djBDc", "name": "Shadow Fractal", "author": "mu6k", "description": "Used in an intro of mine. ", "tags": ["raymarchfractal3dshadow"], "likes": 13, "viewed": 627, "date": "1502532159", "time_retrieved": "2024-06-20T18:59:08.681053", "image_code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. */\n\nfloat dfpart(vec3 pos, float rep,float interp){\n    vec3 rep3 = vec3(rep,rep,rep);\n\tpos = mod(pos+rep3,rep3*2.0)-rep3;\n    float d=rep;\n    /*d = min(d,length(pos.xy));\n    d = min(d,length(pos.yz));\n    d = min(d,length(pos.zx));\n    return rep*.5-d;*/\n    return rep*(1.15+interp*.27)-length(pos);\n}\n\nfloat hash(vec2 v){\n\treturn fract(fract(sin(dot(v,vec2(51.651244215,2.141625)*7.12311)*412.1234)*517.5126751)*711.123173173+iTime);\n}\n\nfloat df(vec3 pos){\n    float interp = cos(iTime*0.1);\n    interp = interp*interp*interp;\n    float d = 0.0,e=16.0;\n    for (float i=.0; i<4.; i++){\n    \td = max(d,dfpart(pos,e,interp));\n        if (d>e*.125) break;\n        e*=.2712;\n    }\n    return d;\n}\n\nvec3 nf(vec3 p){\n    vec2 e = vec2(.0,.001);\n    float c = df(p);\n    return normalize(vec3(df(p-e.yxx)-df(p+e.yxx),df(p-e.xyx)-df(p+e.xyx),df(p-e.xxy)-df(p+e.xxy)));\n}\n\nvoid rot(inout vec2 v,float a){\n\tfloat c=cos(a),s=sin(a);\n    v*=mat2(c,s,-s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy - vec2(.85,.5);\n    float t = iTime + hash(uv)/60.0;\n    vec3 p = sin(vec3(t*.172, t*.271, t*.314)*2.0)+t;\n    float luv = length(uv);\n    vec3 dir = normalize(vec3(uv.xy,1.0-luv*luv*.6));\n    \n    vec3 lightp = vec3(t) + normalize(sin(p*.1))*5.0 + dir*15.0;\n    \n    rot(dir.xy,t*.1);\n    rot(dir.yz,t*.05);\n    rot(dir.zx,t*.025);\n    p+=dir*hash(uv)*.1;\n    float it;\n    \n    for(float i=0.0; i<100.0; i+=1.){\n    \tfloat d = df(p);\n        p+=d*dir;\n        it = i;\n        if (d<.01){\n        \tbreak;\n        }\n    }\n    \n    vec3 d2 = normalize(lightp-p);\n    float td = .01;\n    vec3 p2 = p+d2*(td+td*hash(uv));\n    float occlusion = 1.0;\n    float mtd = distance(lightp,p);\n    \n    for(float i=0.0; i<100.0;i++){\n        float d = df(p2);\n    \tp2 += d*d2;\n        td += d;\n        if (td>mtd || occlusion<.0) break;\n        occlusion = min(occlusion,d/(td*.05));\n    }\n    occlusion=max(occlusion,0.0);\n    \n    float diffuse = dot(nf(p),-d2)*.5+.5;\n    vec3 lcolor = vec3(.9,.3,.1)*.5;\n    vec3 color= diffuse*lcolor/(1.0+mtd*mtd*.0005)*4.0*occlusion+lcolor/(1.0+mtd*mtd*.0005)*.5;\n    color += (vec3(1)-lcolor)*(td*.001+occlusion+it/200.0)*.5;\n\tcolor *= (1.0-length(uv));\n    color = vec3(1.8)*color/(vec3(1)+color);\n    color = pow(color,vec3(0.8));\n\n    //color = nf(p)*.5+.5;\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djBDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 98, 145, 145, 399], [401, 401, 420, 420, 534], [536, 536, 555, 555, 791], [793, 793, 809, 809, 961], [963, 963, 994, 994, 1045], [1047, 1047, 1104, 1104, 2467]]}
{"id": "4djBWd", "name": "Rotating Candy", "author": "nightfox", "description": "My first shader on Shadertoy. Uses input from the microphone.", "tags": ["2d", "distancefield", "microphone"], "likes": 3, "viewed": 607, "date": "1502824810", "time_retrieved": "2024-06-20T18:59:08.681053", "image_code": "float circle(vec2 uv, float r, float blur) {\n \tfloat d = length((uv)*5.0);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nmat2 rotate2d(vec2 uv, float angle) {\n \treturn mat2(-cos(angle),sin(angle),-sin(angle),-cos(angle));   \n}\n\nmat2 scale2d(vec2 scale) {\n\treturn mat2(scale.x,0.0,0.0,scale.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float f = texture(iChannel0, vec2(20.0)).r;\n    \n    uv *= 6.0;\n    \n    float c = circle(uv, 5.5*sin(iTime)+6.0+f, 0.2);\n    vec3 color = vec3(c);\n    vec3 color2 = color;\n    vec2 leftCircle = uv + vec2(0.5*sin(iTime),0.0);\n    vec2 rightCircle = uv + vec2(-0.5*sin(iTime),0.0);\n    float d = length(leftCircle);\n    float d2 = length(rightCircle);\n    \n    uv = rotate2d(uv,100.0*sin(iTime/10.0))*uv;\n    uv = scale2d(vec2(5.0*sin(iTime/5.0)+2.5))*uv;\n    \n    color *= vec3(fract(d*20.0*f),fract(d*20.0*f),uv.x);\n    color2 *= vec3(fract(d2*20.0*f),uv.x,fract(d2*20.0*f));\n    color += color2;\n    color += vec3(0.0,sin(uv.y*20.0)*sin(iTime/5.0),sin(uv.y*20.0));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djBWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 44, 44, 130], [132, 132, 169, 169, 237], [239, 239, 265, 265, 306], [308, 308, 365, 365, 1176]]}
{"id": "4djfW3", "name": " Cubic Hermite Rectangle patched", "author": "ollj", "description": "repost of\nhttps://www.shadertoy.com/view/ltsXzl\nas element of\nhttps://www.shadertoy.com/view/MtsXzl", "tags": ["3d", "terrain", "tiled", "spline", "blinn", "tile", "interpolation", "hermite", "bilinear", "cloth", "bezer", "2linear"], "likes": 14, "viewed": 1025, "date": "1502493068", "time_retrieved": "2024-06-20T18:59:10.705208", "image_code": "/*\n\nsingle pass tracing of a \"bezier-patch\"\nand its 4*4 control points;\n\nhttps://www.shadertoy.com/view/MtsXzl\nShows that these are seamless.\n...There multiple iterations are just multiple octaves of noise\n...to vary amplitude and frequency over time more than here.\n... here frequency is constant, duh.\n\n2 cubic bezier splines (4 CVs) over 2 domains\n1 quadratic interpolation of 2 domain's cubic beziers.\n\nthis is a re-post of \nhttps://www.shadertoy.com/view/ltsXzl\nwith global \"float a=b\" changed to \"#define a (b)\"\nThis increases compatibility and compile time.\n\n\nTextures disabled, they are just distracting.\n\ncubic spline has nice first and second derivative.\nfirst derivative at corner points\ntends to be close to 0, but unlike smoothstep() it is not ==0.\nthat would be possible, but look worse for no good reason.\n\nUsing ray marching to render a cubic hermite rectangle. \nRaytrace bounding box, raymarch interior. \nThe control points of the rectangle are 1d, \nwhich makes it easier to render, \nbut limits the control points to only moving on the Y axis.\n*/\n\n\n/*\n3 modesof computing the bilinear smoothstep()\nmode==0 ; original, likely slowest\nmode==1 ; likely faster, a few less multiplications\nmode==-1; likely fastest, like mode1, but with type vec3()\n*/\n#define mode 0\n\n#define SHOW_BOUNDINGBOX   0\n#define SHOW_CONTROLPOINTS 1\n\nfloat scale = 0.5;\nfloat offset = 0.5;\n\n#define CP00 ( (sin(iTime*0.30) * 0.5 + 0.5) * scale + offset)\n#define CP01  ((sin(iTime*0.10) * 0.5 + 0.5) * scale + offset)\n#define CP02  ((sin(iTime*0.70) * 0.5 + 0.5) * scale + offset)\n#define CP03  ((sin(iTime*0.52) * 0.5 + 0.5) * scale + offset)\n#define CP10  ((sin(iTime*0.20) * 0.5 + 0.5) * scale + offset)\n#define CP11  ((sin(iTime*0.40) * 0.5 + 0.5) * scale + offset)\n#define CP12  ((sin(iTime*0.80) * 0.5 + 0.5) * scale + offset)\n#define CP13  ((sin(iTime*0.61) * 0.5 + 0.5) * scale + offset)\n#define CP20  ((sin(iTime*0.50) * 0.5 + 0.5) * scale + offset)\n#define CP21  ((sin(iTime*0.90) * 0.5 + 0.5) * scale + offset)\n#define CP22  ((sin(iTime*0.60) * 0.5 + 0.5) * scale + offset)\n#define CP23  ((sin(iTime*0.32) * 0.5 + 0.5) * scale + offset)\n#define CP30  ((sin(iTime*0.27) * 0.5 + 0.5) * scale + offset)\n#define CP31  ((sin(iTime*0.64) * 0.5 + 0.5) * scale + offset)\n#define CP32  ((sin(iTime*0.18) * 0.5 + 0.5) * scale + offset)\n#define CP33  ((sin(iTime*0.95) * 0.5 + 0.5) * scale + offset)\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\n\n\n#if mode==0\n float CubicHermite (float A, float B, float C, float D, float t){\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    float a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    float b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    float c = -A/2.0 + C/2.0;\n   \tfloat d = B;    \n    return a*t3 + b*t2 + c*t + d;\n }\n//above is easy to modify, below likely performs faster\n#endif\n\n#if mode>0\n #define MAD(a,b,c) (a*b+c) \n float CubicHermite(float A,float B,float C,float D,float t){D*=.5; \n  //return MAD(MAD(MAD(D+.5*(((B-C)*3.)-A),t,A-2.5*B+2.*C-D),t,.5*(C-A)),t,B); \n  float a=D+.5*(((B-C)*3.)-A),b=A-2.5*B+2.*C-D,c=.5*(C-A);\n  //return MAD(MAD(MAD(a,t,b),t,c),t,B); \n return ((a*t+b)*t+c)*t+B;}\n//above is not optimized borvector processing,\n//below may perform even better, or at least is smaller?\n#endif\n#if mode<0\n #define MAD(a,b,c) (a*b+c) \n float CubicHermite(float A,float B,float C,float D,float t){D*=.5;\n //return MAD(MAD(MAD(D+.5*(((B-C)*3.)-A),t,A-2.5*B+2.*C-D),t,.5*(C-A)),t,B); \n vec3 p=vec3(D+.5*(((B-C)*3.)-A),A-2.5*B+2.*C-D,.5*(C-A)); \n //return MAD(MAD(MAD(p.x,t,p.y),t,p.z),t,B); \n return ((p.x*t+p.y)*t+p.z)*t+B; }\n#endif\n\n\n//=======================================================================================\nfloat HeightAtPos(vec2 P){\n    float CP0X = CubicHermite(CP00, CP01, CP02, CP03, P.x);\n    float CP1X = CubicHermite(CP10, CP11, CP12, CP13, P.x);\n    float CP2X = CubicHermite(CP20, CP21, CP22, CP23, P.x);\n    float CP3X = CubicHermite(CP30, CP31, CP32, CP33, P.x);\n    return CubicHermite(CP0X, CP1X, CP2X, CP3X, P.y);\n}\n\n//=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n}\n\n//=======================================================================================\nbool RayIntersectAABoxNoY (vec2 boxMin, vec2 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec2 roo = rayPos.xz - (boxMin+boxMax)*0.5;\n    vec2 rad = (boxMax - boxMin)*0.5;\n    vec2 m = 1.0/rayDir.xz;\n    vec2 n = m*roo;\n    vec2 k = abs(m)*rad;\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    time = vec2( max( t1.x, t1.y ),\n                 min( t2.x, t2.y ));\n    return time.y>time.x && time.y>0.0;}\n\n//=======================================================================================\nfloat RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir){\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn -1.0;\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t\tcollisionTime = -b + sqrt(discr);\n    return collisionTime;}\n\n//=======================================================================================\nvec3 DiffuseColor (in vec3 pos){// checkerboard pattern\n return vec3(mod(floor(pos.x*10.)+floor(pos.z * 10.),2.)< 1.?1.:.4);}\n\n//=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time, bool fromUnderneath)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n    normal *= fromUnderneath ? -1.0 : 1.0;\n\n    // diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n    \n    // specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\t\n    \n    // reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    //color += texture(iChannel0, reflection).rgb * 0.25;    \n    \n    return color;\n}\n\n//=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectAABoxNoY(vec2(0.0), vec2(1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) / float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n    float firstSign = sign(pos.y - HeightAtPos(pos.xz));\n    \n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = HeightAtPos(pos.xz);\n        \n        if (sign(pos.y - height) * firstSign < 0.0)\n        {\n            fromUnderneath = firstSign < 0.0; \n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n    }\n    \n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time, fromUnderneath);\n        hitTime = time;\n\t}\n    else\n    {\n        #if SHOW_BOUNDINGBOX\n        \tpixelColor += vec3(0.2);\n        #endif\n    }\n    \n\treturn pixelColor;\n}\n\n//=======================================================================================\nvec3 HandleControlPoints (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, inout float hitTime)\n{\n    const float c_controlPointRadius = 0.02;\n    #if SHOW_CONTROLPOINTS\n    float cpHitTime = RayIntersectSphere(vec4(-1.0, CP00, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP01, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP02, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP03, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }        \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(-1.0, CP10, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP11, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP12, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }       \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP13, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }      \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(-1.0, CP20, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP21, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP22, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP23, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(-1.0, CP30, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP31, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP32, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }     \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP33, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }       \n    #endif\n    \n    return pixelColor;\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    //----- camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 5.0;\n    cameraPos += vec3(0.5,0.5,0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\t\n\t\t\n\t// Objects\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = vec3(0);// texture(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    pixelColor = HandleControlPoints(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[3657, 3747, 3773, 3773, 4069], [4071, 4161, 4189, 4189, 4446], [4448, 4538, 4639, 4639, 4953], [4955, 5045, 5116, 5190, 5933], [5935, 6025, 6057, 6080, 6150], [6152, 6242, 6322, 6322, 7092], [7094, 7184, 7272, 7272, 8542], [8544, 8634, 8734, 8734, 12554], [12556, 12646, 12703, 12724, 14129]]}
{"id": "4djfWt", "name": "Tunnel 3D Shape", "author": "ingagard", "description": "I have never worked with shaders before, only software rendering. Hope you enjoy it anyway. :-) ", "tags": ["3d", "tunnel", "cube", "demoeffect", "textured", "classic", "splitting", "mixture"], "likes": 64, "viewed": 4222, "date": "1502964941", "time_retrieved": "2024-06-20T18:59:11.705636", "image_code": "#define rotate(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat lineWidth=7.0;\nfloat tunneRotSpeed = 0.05;\nfloat tunnelSpeed = 0.06;\nfloat size=100.0;\nvec3 objectStartPos = vec3(0, 0, -50.0);    \nfloat camRange=1000.0;\nfloat scale[8];\nvec3 projPos[8];    \n\nvec4 quads[6] = vec4[]( \n    vec4(0, 1, 2, 3), \n    vec4(4, 5, 6, 7), \n    vec4(3, 7, 4, 0), \n    vec4(6, 5, 1, 2), \n    vec4(0, 1, 5, 4), \n    vec4(2, 3, 7, 6));\n\nvec3 edges[24];\n\n\nvoid oval(vec2 screenCoord, vec2 center, float radius, float strokeThickness, vec4 strokeColor, vec4 fillColor, inout vec4 pixel)\n{\n  float dist= distance(screenCoord, center);\n\n  if (dist<radius)\n  { \n    if (dist<radius-strokeThickness)\n    {\n      pixel = fillColor;\n    } else\n    {\n      pixel = strokeColor;\n    }\n  }\n}\n\n\nbool lineItersection(vec2 v1, vec2 v2, vec2 v3, vec2 v4) \n{    \n  float bx = v2.x - v1.x;\n  float by = v2.y - v1.y;\n  float dx = v4.x - v3.x;\n  float dy = v4.y - v3.y;\n\n  float b_dot_d_perp = bx * dy - by * dx;\n\n  if (b_dot_d_perp == 0.0) return false;\n\n  float cx = v3.x - v1.x;\n  float cy = v3.y - v1.y;\n\n  float t = (cx * dy - cy * dx) / b_dot_d_perp;\n  if (t < 0.0 || t > 1.0)  return false;\n\n  float u = (cx * by - cy * bx) / b_dot_d_perp;\n  if (u < 0.0 || u > 1.0)  return false;\n\n  return true;\n}\n\n\nvoid Line(vec2 screenCoord, vec2 p1, vec2 p2, float thickness, vec4 color, inout vec4 pixel)\n{\n\n  float a = distance(p1, screenCoord);\n  float b = distance(p2, screenCoord);\n  float c = distance(p1, p2);\n\n  if ( a >= c || b >=  c ) return;\n\n  float p = (a + b + c) * 0.5;\n\n  float dist = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  if (dist<thickness)\n  {\n    pixel = mix(pixel, color, 1.0/max(1.0, dist*3.0));\n  }\n}\n\n\n\nbool insideQuad(vec2 v1, vec2 v2, vec2 v3, vec2 v4, vec2 point)\n{\n\n  vec2 point2 = vec2(point.x-10000.0,point.y);\n    \n  int colCount = 0;\n\n  if (lineItersection(point, point2, v1, v2))         \n  {     colCount++;  }\n  if (lineItersection(point, point2, v2, v3))\n  {     colCount++;  }\n  if (lineItersection(point, point2, v3, v4))\n  {     colCount++;  }\n  if (lineItersection(point, point2, v4, v1))\n  {     colCount++;  }\n\n  return (colCount==1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float frame = float(iTime)*60.0;\n  float FrameRad = radians(frame);\n  float sinFrame = sin(FrameRad);\n  float cosFrame = cos(FrameRad);\n  float sinFrame2 = sinFrame*0.2;\n  float cosFrame2 = cosFrame*2.2;\n  vec2 center = (iResolution.xy/2.0)+vec2((cosFrame*sinFrame2)*250.0, (cosFrame-cosFrame2)*50.0);\n  vec2 centerFragDist = center-fragCoord;\n  vec3 halfRes = vec3(iResolution.x*0.5, iResolution.y*0.5, 0);   \n  vec2 uvTunnel = fragCoord.xy / iResolution.xy;\n  float angle = atan( centerFragDist.y, centerFragDist.x)*3.14;\n  float dist = length(fragCoord-center);\n\n  uvTunnel.x=1.0/(dist*0.0005);\n  uvTunnel.y=angle;\n\n  vec4 color = texture(iChannel3, uvTunnel*vec2(0.4, 3.0)+vec2(frame*tunnelSpeed, frame*tunneRotSpeed));\n  color*=vec4(0.2, 0.4, 1.0, 1.0)*(2.0/(dist*0.01));   \n\n  float rot = frame*0.02;\n  vec2 uv = (fragCoord.xy / iResolution.xy);\n  vec2 uv2 = (fragCoord.xy / iResolution.xy +vec2(frame*0.01, frame*0.003))*0.1;\n  vec2 screenCoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n\n  vec3 camPos = vec3(0, 0, 90.0+cos(FrameRad)*50.0);\n    \n  vec3 verts[8] = vec3[](\n    vec3(-1.0, -1.0, -1.0), \n    vec3(-1.0, -1.0, 1.0), \n    vec3(1.0, -1.0, 1.0), \n    vec3(1.0, -1.0, -1.0), \n    vec3(-1.0, 1.0, -1.0), \n    vec3(-1.0, 1.0, 1.0), \n    vec3(1.0, 1.0, 1.0), \n    vec3(1.0, 1.0, -1.0));\n    \n  for (int i=0; i<8; i++)\n  {           \n      // Y ROTATION    \n      verts[i].xz *= rotate(rot); \n      // X ROTATION\n      verts[i].yz *= rotate(rot*0.7);  \n      // Z ROTATION\n      verts[i].xy *= rotate(rot*0.2);  \n      \n      verts[i]+=objectStartPos;\n  }\n\n  for (int i=0; i<8; i++)\n  {                            \n    float camDistance = distance(verts[i], camPos);\n    scale[i] = (camRange/camDistance)*0.1;\n    projPos[i] = verts[i]-camPos;\n    projPos[i]*=size*scale[i];    \n    projPos[i]+= halfRes;\n  }\n\n  float range =  max(0.0, 1.0*sin(FrameRad));\n \n  for (int i=0; i<6; i++)\n  {\n    vec3 center = (projPos[int(quads[i].x)]+projPos[int(quads[i].y)]+projPos[int(quads[i].z)]+projPos[int(quads[i].w)])/4.0;           \n    edges[i*4 + 0]=projPos[int(quads[i].x)]+((center-projPos[int(quads[i].x)])*range);\n    edges[i*4 + 1]=projPos[int(quads[i].y)]+((center-projPos[int(quads[i].y)])*range);\n    edges[i*4 + 2]=projPos[int(quads[i].z)]+((center-projPos[int(quads[i].z)])*range);\n    edges[i*4 + 3]=projPos[int(quads[i].w)]+((center-projPos[int(quads[i].w)])*range);            \n  }\n\n  for (int i=0; i<6; i++)\n  {  \n    if (insideQuad(edges[i*4 + 0].xy, edges[i*4 + 1].xy, edges[i*4 + 2].xy, edges[i*4 + 3].xy, screenCoord))\n    { \n      vec2 center = (edges[i*4 + 0].xy+edges[i*4 + 1].xy+edges[i*4 + 2].xy+edges[i*4 + 3].xy)/4.0;                \n\n      float minX = min(edges[i*4 + 0].x, min(edges[i*4 + 1].x, min(edges[i*4 + 2].x, edges[i*4 + 3].x)));\n      float minY = min(edges[i*4 + 0].y, min(edges[i*4 + 1].y, min(edges[i*4 + 2].y, edges[i*4 + 3].y)));\n      float maxX = max(edges[i*4 + 0].x, max(edges[i*4 + 1].x, max(edges[i*4 + 2].x, edges[i*4 + 3].x)));\n      float maxY = max(edges[i*4 + 0].y, max(edges[i*4 + 1].y, max(edges[i*4 + 2].y, edges[i*4 + 3].y)));\n\n      float width = maxX-minX;\n      float height = maxY-minY;       \n      float xDist = distance(minX, screenCoord.x)/width;\n      float yDist = distance(minY, screenCoord.y)/height;\n\n      color = (color+texture(iChannel2, vec2(xDist, 1.0-yDist)*0.1))*0.75;\n      color-=0.2*((distance(center, screenCoord)/width));\n    }\n  }\n\n  vec4 lineColor = color*3.0;\n\n  for (int i=0; i<6; i++)      \n  {    \n    Line(screenCoord, edges[i*4 + 0].xy, edges[i*4 + 1].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 1].xy, edges[i*4 + 2].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 2].xy, edges[i*4 + 3].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 3].xy, edges[i*4 + 0].xy, lineWidth, lineColor, color);\n  }\n\n  for (int i=0; i<24; i++)\n  {       \n    oval(screenCoord, edges[i].xy, 4.0, lineWidth, vec4(1.0), color*5.0, color);\n  }\n\n  vec2 sunPos = vec2(400.0+(cos(FrameRad)*300.0), 200.0+(sin(FrameRad)*100.0));      \n  float sunDist = distance(screenCoord, sunPos)*0.02;\n\n  fragColor = color + vec4(0.1/sunDist, 0.1/sunDist, 0.2/sunDist, 0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djfWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[435, 435, 566, 566, 760], [763, 763, 822, 822, 1266], [1269, 1269, 1363, 1363, 1697], [1701, 1701, 1766, 1766, 2152], [2155, 2155, 2212, 2212, 6418]]}
{"id": "4dlBzl", "name": "triangle fractal", "author": "adambene", "description": "triangle fractal", "tags": ["fractal", "triangle"], "likes": 0, "viewed": 78, "date": "1502475893", "time_retrieved": "2024-06-20T18:59:11.705636", "image_code": "#define t iTime\n#define PI 3.141592654\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nbool sameSide(vec3 p1,vec3 p2, vec3 a,vec3 b) {\n    vec3 cp1 = cross(b-a, p1-a);\n    vec3 cp2 = cross(b-a, p2-a);\n    return (dot(cp1, cp2) >= 0.);\n}\n\nbool pointInTriangle(vec3 p, vec3 a,vec3 b,vec3 c) {\n    return (\n        sameSide(p,a, b,c) &&\n        sameSide(p,b, a,c) &&\n        sameSide(p,c, a,b)\n    );\n}\n\nbool isInTriangle(vec2 a, vec2 b, vec2 c, vec2 p) {\n\treturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5, .5);\n    mat2 r = rotate2d(PI/20. + t / PI);\n    bool e = false;\n    int iter = 30;\n\n    vec3 bias = vec3(0., .16666, .0);\n\n    vec3 a = vec3(  0, .5, 0) + bias;\n    vec3 b = vec3(-.5,-.5, 0) + bias;\n    vec3 c = vec3( .5,-.5, 0) + bias;\n    \n\tfloat d = .8 + 1000. * pow((.5 + .5*sin(t / 2. - PI / 2.)), 2.);\n    \n    a *= d;\n    b *= d;\n    c *= d;\n    \n    for (int i = 0; i < iter; i++) {\n        if (pointInTriangle(vec3(uv.xy, 0), a, b, c)) {\n        \te = i % 2 == 0;\n        }\n        vec3 aa = vec3(a.xy * r, 0.);\n        vec3 bb = vec3(b.xy * r, 0.);\n        vec3 cc = vec3(c.xy * r, 0.);\n\n        a = (aa + bb) / 2.;\n        b = (bb + cc) / 2.;\n        c = (cc + aa) / 2.;\n\n    }\n\n    fragColor = vec4(e ? 1. : 0., uv.xy + vec2(.5, .5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[40, 40, 68, 68, 154], [156, 156, 203, 203, 305], [307, 307, 359, 359, 468], [470, 470, 521, 521, 538], [540, 540, 597, 597, 1403]]}
{"id": "4dSBDc", "name": "Painty", "author": "manylegged", "description": "interesting paint-esque fire-like effect by integrating over fractal noise and using it to offset a texture. The texture is a number of generated pseudocolor maps. ", "tags": ["2d", "fractal", "temperature"], "likes": 5, "viewed": 273, "date": "1502394665", "time_retrieved": "2024-06-20T18:59:12.996614", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                  dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nfloat fractal_noise(vec3 v, int octaves)\n{\n    float x = 0.0;\n    float a = 0.5;\n    float f = 0.0;\n    for (int i=0; i<octaves; i++)\n    {\n        x += a * snoise(v);\n        v *= 2.0;\n        a *= 0.5;\n    }\n    return x;\n}\n\nfloat fractal_noise(vec3 v)\n{\n    return fractal_noise(v, 6);\n}\n\nvec3 temp2rgb(float temp)\n{\n    temp /= 100.0;\n\n    // draper point\n    // if (temp <= 8)\n        // return vec3(0);\n\n    // if (temp < 10)\n        // return mix(vec3(0), vec3(1.0, 0.2663545845364998, 0.0), smoothstep(0, 1, (temp-8)/2.0));\n\n    float red, green, blue;\n    \n    if (temp <= 66.0) {\n        red = 255.0;\n    } else {\n        red = temp - 60.0;\n        red = 329.698727446 * pow(red, -0.1332047592);\n        red = clamp(red, 0.0, 255.0);\n    }\n\n    if (temp <= 66.0) {\n        green = 99.4708025861 * log(temp) - 161.1195681661;\n    } else {\n        green = temp - 60.0;\n        green = 288.1221695283 * pow(green, -0.0755148492);\n    }\n    green = clamp(green, 0.0, 255.0);\n\n    if (temp >= 66.0) {\n        blue = 255.0;\n    } else if (temp <= 19.0) {\n        blue = 0.0;\n    } else {\n        blue = temp - 10.0;\n        blue = 138.5177312231 * log(blue) - 305.0447927307;\n        blue = clamp(blue, 0.0, 255.0);\n    }\n\n    return vec3(red, green, blue) / 255.0;\n}\n\n\nfloat cardinal(float y0, float y1, float y2, float y3, float t, float c)\n{\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float h1 = 2.0 * t3 - 3.0 * t2 + 1.0;\n    float h2 = -2.0 * t3 + 3.0 * t2;\n    float h3 = t3 - 2.0 * t2 + t;\n    float h4 = t3 - t2;\n    float m1 = c * (y2 - y0);\n    float m2 = c * (y3 - y1);\n    float r  = m1 * h3 + y1 * h1 + y2 * h2 + m2 * h4;\n    return r;\n}\n\nvec2 cardinal(vec2 y0, vec2 y1, vec2 y2, vec2 y3, float t, float c)\n{\n    return vec2(cardinal(y0.x, y1.x, y2.x, y3.x, t, c),\n                cardinal(y0.y, y1.y, y2.y, y3.y, t, c));\n}\n\nvec3 cardinal(vec3 y0, vec3 y1, vec3 y2, vec3 y3, float t, float c)\n{\n    return vec3(cardinal(y0.x, y1.x, y2.x, y3.x, t, c),\n                cardinal(y0.y, y1.y, y2.y, y3.y, t, c),\n                cardinal(y0.z, y1.z, y2.z, y3.z, t, c));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scale(float v, float r)\n{\n    return (v - r) / (1.0 - r);\n}\n\nvec3 img(vec2 uv)\n{\n    vec3 c = vec3(0.0);\n    \n    if (uv.y > 0.75)\n    {\n        if (uv.x < 0.25)\n            c = cardinal(vec3(0.0), vec3(0.0), temp2rgb(1000.0), temp2rgb(2000.0), 4.0 * uv.x, 0.0);\n        else\n        \tc = temp2rgb(1000.0 + scale(uv.x, 0.25) * 5500.0);\n    }\n    else if (uv.y > 0.5)\n    {\n        c = vec3(uv.x);\n    }\n    else if (uv.y > 0.25)\n    {\n        c = hsv2rgb(vec3(280.0/360.0 - 280.0/360.0 * uv.x, 1.0, 0.5 * uv.x + 0.5));\n    }\n    else\n    {\n\t\tc = vec3(0.0, 0.98, 1.0) * uv.x;\n    }\n    return c;\n}\n\nvec3 painty(vec2 uv, float t)\n{\n    vec3 a = vec3(0.0);\n    const int c = 10;\n    for (int i=0; i<c; i++) {\n        vec2 v = uv + 0.1 * fractal_noise(vec3(uv * 10.0, t - float(i) * 0.016));\n        a += img(v) / float(c);\n    }\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 c = painty(uv, iTime);\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSBDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 394, 415, 415, 466], [468, 468, 489, 489, 540], [542, 542, 564, 564, 603], [605, 605, 633, 633, 687], [689, 689, 711, 711, 3003], [3006, 3006, 3048, 3048, 3231], [3233, 3233, 3262, 3262, 3296], [3298, 3298, 3325, 3325, 4277], [4280, 4280, 4354, 4354, 4666], [4668, 4668, 4737, 4737, 4852], [4854, 4854, 4923, 4923, 5094], [5096, 5096, 5118, 5118, 5287], [5289, 5289, 5320, 5320, 5354], [5356, 5356, 5375, 5375, 5891], [5893, 5893, 5924, 5924, 6136], [6138, 6138, 6195, 6195, 6308]]}
{"id": "4dSfDy", "name": "iq flower", "author": "arkenthera", "description": "modified IQ flower", "tags": ["flower", "iq"], "likes": 1, "viewed": 74, "date": "1501854807", "time_retrieved": "2024-06-20T18:59:13.002725", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    float a = atan(p.x,p.y);\n    float r = length(p)*(0.8+0.2*sin(0.3*iTime));\n\n    float w = cos(2.0*iTime-r*2.0);\n    float h = 0.5+0.5*cos(12.0*a-w*7.0+r*8.0+ 0.7*iTime);\n    float d = 0.25+0.75*pow(h,1.0*r)*(0.7+0.3*w);\n\n    float f = sqrt(1.0-r/d)*r*2.5;\n    f *= 1.25+0.25*cos((12.0*a-w*7.0+r*8.0)/2.0);\n    f *= 1.0 - 0.35*(0.5+0.5*sin(r*30.0))*(0.5+0.5*cos(12.0*a-w*7.0+r*8.0));\n\t\n\tvec3 col = vec3( f,\n\t\t\t\t\t f-h*0.5+r*.2 + 0.35*h*(1.0-r),\n                     f-h*r + 0.1*h*(1.0-r) );\n\tcol = clamp( col, 0.0, 1.0 );\n\t\n\tvec3 bcol = mix( 0.5*vec3(0.8,0.9,1.0), vec3(1.0), 0.5+0.5*p.y );\n\tcol = mix( col, bcol, smoothstep(-0.3,0.8,r-d) );\n    \n    col *= vec3(1,0.05,0.4);\n    float tt = 0.8*sin(iTime);\n    col.x *= tt;\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSfDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 125, 182, 182, 1025]]}
{"id": "4dSfWV", "name": "SNOWVIKING", "author": "Coolok", "description": "SNOWVIKING", "tags": ["snowviking"], "likes": 5, "viewed": 208, "date": "1502140848", "time_retrieved": "2024-06-20T18:59:13.002725", "image_code": "\n#define LIGHT_SNOW // Comment this out for a blizzard\n\n#ifdef LIGHT_SNOW\n\t#define LAYERS 50\n\t#define DEPTH .5\n\t#define WIDTH .3\n\t#define SPEED .6\n#else // BLIZZARD\n\t#define LAYERS 200\n\t#define DEPTH .1\n\t#define WIDTH .8\n\t#define SPEED 1.5\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uv = iMouse.xy/iResolution.xy + vec2(1.,iResolution.y/iResolution.x)*fragCoord.xy / iResolution.xy;\n\tvec3 acc = vec3(0.0);\n\tfloat dof = 5.*sin(iTime*.1);\n\tfor (int i=0;i<LAYERS;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uv*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\ts += .01*abs(2.*fract(10.*q.yx)-1.); \n\t\tfloat d = .6*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .005+.05*min(.5*abs(fi-5.-dof),1.);\n\t\tacc += vec3(smoothstep(edge,-edge,d)*(r.x/(1.+.02*fi*DEPTH)));\n\t}\n\tfragColor = vec4(vec3(acc),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSfWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[248, 248, 305, 305, 1155]]}
{"id": "4l3GRn", "name": "retro fractal adventure", "author": "bergi", "description": "old kaliset toying-around reanimated", "tags": ["numbers", "kaliset", "magic"], "likes": 11, "viewed": 540, "date": "1502406388", "time_retrieved": "2024-06-20T18:59:13.002725", "image_code": "#define TIME (iTime)\n\n// returns average value from kaliset\nvec3 kali_trees(in vec2 uv)\n{\n    uv = uv.yx / 100. - vec2(0.022,0.04);\n    uv.x += 0.001*sin(TIME/33.);\n    uv.y += 0.003*sin(TIME/17.3);\n    vec3 p = vec3(uv, .03);\n    \n    vec3 col = vec3(0.);\n    const int num_iter = 67;\n    for (int i=0; i<num_iter; ++i)\n    {\n        p = abs(p) / dot(p, p);\n        col += exp(-p*22.);\n        p -= vec3(1.+0.005*sin(TIME/11.), 0.585, .03);\n    }\n    col /= float(num_iter);\n    col *= 4.;\n    \n    //col = pow(clamp(col, 0., 1.), vec3(2.));\n    \n    return col;\n}\n\nvec3 kali_stars(in vec2 uv)\n{\n    uv = (uv+vec2(2.,1.)) / 14.;\n    uv.x += sin(TIME/150.);\n    vec3 p = vec3(uv, .03);\n    \n    vec3 col = vec3(0.);\n    const int num_iter = 50;\n    for (int i=0; i<num_iter; ++i)\n    {\n        p = abs(p) / dot(p, p);\n        col += exp(-p*32.);\n        p -= vec3(.285, .409, .874);\n    }\n    col /= float(num_iter);\n    col *= 4.;\n    \n    //col = pow(clamp(col, 0., 1.), vec3(2.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.y * 2.;\n    \n    vec3 kt = kali_trees(uv);\n\tvec3 ks = kali_stars(uv);\n    \n    vec3 col = mix(vec3(.9,.3+.2*cos(suv.y*8.),.1), vec3(.5,.2+ks.x, 1.), suv.y-ks.z);\n    \n    col *= smoothstep(0.0, .2, kt.y-.6-suv.y*.1);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l3GRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[22, 60, 89, 89, 565], [567, 567, 596, 596, 1006], [1008, 1008, 1065, 1065, 1431]]}
{"id": "4lfcz4", "name": "Snow is falling", "author": "tholzer", "description": "Simulate falling snow. This shader is a mixture of two old shaders (see source code).\nMouse.x changes horizontal view direction, mouse.y changes some simulation parameters.\n\nUse this shader to cool down your room a little bit and relax ;-)", "tags": ["procedural", "2d", "noise", "fbm", "perlin", "worley", "snow"], "likes": 34, "viewed": 2482, "date": "1503570557", "time_retrieved": "2024-06-20T18:59:13.826928", "image_code": "//-----------------------------------------------------\n// SnowIsFalling.glsl\n//  v1.0  2017-08-24  initial version\n//  v1.1  2018-04-17  test with mysteryMountain\n// combining background of https://www.shadertoy.com/view/4dl3R4\n// and falling snow of     https://www.shadertoy.com/view/ldsGDn\n//-----------------------------------------------------\n\n//=== background ===\n\n#define mod289(x) mod(x, 289.)\n\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//-----------------------------------------------------\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  \n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  \n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                \t+ i.x + vec3(0.0, i1.x, 1.0 ));\n  \n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  \n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  \n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  \n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  \n  return 130.0 * dot(m, g);\t\t\n}\n//-----------------------------------------------------\nfloat fbm(vec2 p) \n{\n  float f = 0.0;\n  float w = 0.5;\n  for (int i = 0; i < 5; i ++) \n  {\n    f += w * snoise(p);\n    p *= 2.;\n    w *= 0.5;\n  }\n  return f;\n}\n//-----------------------------------------------------\n// background of https://www.shadertoy.com/view/4dl3R4\n//-----------------------------------------------------\nfloat background (vec2 uv)\n{\n  uv.x += iMouse.x / iResolution.x - 1.0;\n  float speed=2.0;\n  \n  vec2 sunCenter = vec2(0.3,0.9);\n  float suns = clamp(1.2-distance(uv,sunCenter), 0.0, 1.0);\n  float sunsh = smoothstep(0.85,0.95,suns);\n  \n  float slope = 1.0 - smoothstep(0.55, 0.0, 0.8 +uv.x -2.3*uv.y);\t\t\t\t\t\t\t\t\n  \n  float noise = abs(fbm(uv*1.5));\n  slope = (noise*0.2)+(slope-((1.0-noise)*slope*0.1))*0.6;\n  slope = clamp(slope, 0.0, 1.0);\n  \t\t\t\t\t\t\n  vec2 GA = speed * vec2 (iTime*1.8, iTime*0.9);\n  \n  // Snow layers, somewhat like an fbm with worley layers.\n  return 0.35 + (slope*(suns+0.3))+(sunsh*0.6);    \n}\n\n//-----------------------------------------------------\n// falling snow of https://www.shadertoy.com/view/ldsGDn\n//-----------------------------------------------------\n\n#define LAYERS 66\n\n#define DEPTH1 .3\n#define WIDTH1 .4\n#define SPEED1 .6\n\n#define DEPTH2 .1\n#define WIDTH2 .3\n#define SPEED2 .1\n\nfloat snowing(in vec2 uv, in vec2 fragCoord )\n{\n  const mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n  vec2 mp = iMouse.xy / iResolution.xy;\n  uv.x += mp.x*4.0;    \n  mp.y *= 0.25;\n  float depth = smoothstep(DEPTH1, DEPTH2, mp.y);\n  float width = smoothstep(WIDTH1, WIDTH2, mp.y);\n  float speed = smoothstep(SPEED1, SPEED2, mp.y);\n  float acc = 0.0;\n  float dof = 5.0 * sin(iTime * 0.1);\n  for (int i=0; i < LAYERS; i++)\n  {\n    float fi = float(i);\n    vec2 q = uv * (1.0 + fi*depth);\n    float w = width * mod(fi*7.238917,1.0)-width*0.1*sin(iTime*2.+fi);\n    q += vec2(q.y*w, speed*iTime / (1.0+fi*depth*0.03));\n    vec3 n = vec3(floor(q),31.189+fi);\n    vec3 m = floor(n)*0.00001 + fract(n);\n    vec3 mp = (31415.9+m) / fract(p*m);\n    vec3 r = fract(mp);\n    vec2 s = abs(mod(q,1.0) -0.5 +0.9*r.xy -0.45);\n    s += 0.01*abs(2.0*fract(10.*q.yx)-1.); \n    float d = 0.6*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n    float edge = 0.05 +0.05*min(.5*abs(fi-5.-dof),1.);\n    acc += smoothstep(edge,-edge,d)*(r.x/(1.+.02*fi*depth));\n  }\n  return acc;\n}\n//-----------------------------------------------------\n// '[2TC 15] Mystery Mountains' by David Hoskins.\n// Add layers of the texture of differing frequencies and magnitudes...\n//-----------------------------------------------------\n#define F +texture(iChannel1,.3+p.xz*s/3e3)/(s+=s) \nbool MysteryMountains( inout vec4 c, vec2 w )\n{\n    vec4 p = vec4(w/iResolution.xy,1,1)-.5,d=p,t;\n    p.z += iTime*2.;\n //   d.x-=0.04;\n    for(float i=1.5; i > 0.3; i-=.002)\n    {\n        float s = 0.8;\n        t = F F F F F;\n        c = vec4(1,1.,.9,9)+d.x-t*i;\n        if (t.x > p.y*.017+1.3) return true;\n        p += d;\n    }\n    return false;\n}\n//-----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.y;\n  \n//  if (!MysteryMountains(fragColor, fragCoord))\n//  {\n  float bg = background(uv);\n  fragColor = vec4(bg*0.9, bg, bg*1.1, 1.0);\n//  }\n  float snowOut = snowing(uv,fragCoord);\n  fragColor += vec4(vec3(snowOut), 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXXDX", "previewfilepath": "https://soundcloud.com/endingsatellites/children-at-seas", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/endingsatellites/children-at-seas", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfcz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[351, 405, 427, 427, 462], [464, 520, 542, 542, 1421], [1422, 1478, 1498, 1498, 1637], [1638, 1805, 1833, 1833, 2416], [2418, 2717, 2764, 2764, 3809], [3810, 4096, 4143, 4143, 4446], [4447, 4503, 4560, 4560, 4824]]}
{"id": "4lfyR7", "name": "Pi In The Sky", "author": "dr2", "description": "Digits of pi (more optionally available)", "tags": ["text", "texture", "pi", "font"], "likes": 4, "viewed": 555, "date": "1503951390", "time_retrieved": "2024-06-20T18:59:15.160493", "image_code": "// \"Pi In The Sky\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Digits of pi (more optionally available); digit orientation alternates (mouse enabled)\n\n#define MORE_DIG 0\n\n#define txFnt iChannel0\n\nint GetTxChar (vec2 p);\nfloat Fbm2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 sunDir;\nvec2 qnTex;\nfloat dstFar, txDep;\nbool vText;\nconst float pi = 3.14159;\n\nfloat FontTexDf (vec3 p)\n{\n  vec3 tx;\n  vec2 s;\n  float d;\n  int ic;\n  ic = GetTxChar (p.xz);\n  if (ic != 0) {\n    s = (vText) ? p.xy + vec2 (0., 0.5) : p.xz;\n    tx = texture (txFnt, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (s)) * (1. / 16.), 1.)).gba - 0.5;\n    qnTex = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  } else d = 1.;\n  return d;\n}\n\nfloat ObjRayT (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, dLim, d, w;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  srd = - sign (rd.xz);\n  rdi = 1. / abs (rd);\n  w = (vText) ? 1. : txDep;\n  dHit = max (rdi.y * (abs (ro.y) - 0.5 * w - 0.02), 0.);\n  dLim = min (dHit + rdi.y * (w + 0.02), dstFar);\n  for (int j = 0; j < 160; j ++) {\n    p = ro + dHit * rd;\n    h = fract (rdi.xz * fract (srd * p.xz));\n    d = max (FontTexDf (p), abs (p.y) - 0.5 * w);\n    if (vText) d = max (d, fract (p.z) - txDep);\n    dHit += min (d, 0.01 + min (h.x, h.y));\n    if (d < 0.0001 || dHit > dLim) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y) + 0.0001;\n  return 0.7 * mix (vec3 (0.1, 0.2, 0.4), vec3 (1.),\n     clamp (0.1 + 0.8 * Fbm2 (0.05 * (ro.xz + rd.xz * (100. - ro.y) / rd.y)) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstTxt, s;\n  bool isMat;\n  bgCol = BgCol (ro, rd);\n  dstTxt = ObjRayT (ro, rd);\n  if (dstTxt < dstFar) {\n    ro += rd * dstTxt;\n    isMat = true;\n    if (vText) {\n      s = mod (ro.z, 1.) - 0.5 * txDep;\n      if (abs (s) > 0.495 * txDep) {\n        vn = vec3 (0., 0., - sign (s * rd.z));\n      } else {\n        isMat = false;\n        vn = normalize (vec3 (qnTex, 0.00001));\n      }\n    } else {\n      if (abs (ro.y) < 0.495 * txDep) {\n        vn = normalize (vec3 (qnTex.x, 0.00001, qnTex.y));\n      } else {\n        isMat = false;\n        vn = vec3 (0., - sign (ro.y * rd.y), 0.);\n      }\n    }\n    if (isMat) col = vec3 (1., 1., 0.7) * (0.3 + 0.7 * max (dot (sunDir, vn), 0.) +\n       0.4 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.));\n    else col = 1.5 * BgCol (ro, reflect (rd, vn));\n    col = mix (col, bgCol, pow (min (dstTxt / dstFar, 1.), 5.));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, tCur, tCyc;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  el = -0.3 * pi + 0.1 * pi * sin (0.1 * pi * tCur);\n  if (mPtr.z > 0.) {\n    az -= 3. * pi * mPtr.x;\n    el -= 1.5 * pi * mPtr.y;\n  }\n  rd = normalize (vec3 (uv, 3.));\n  ro = vec3 (0.01, 0., -40.);\n  sunDir = normalize (vec3 (0.5, 1., -1.));\n  rd.xz = Rot2D (rd.xz, 0.5 * pi + az);\n  rd.yz = Rot2D (rd.yz, 0.5 * pi + el);\n  ro.xz = Rot2D (ro.xz, 0.5 * pi + az);\n  ro.yz = Rot2D (ro.yz, 0.5 * pi + el);\n  sunDir.xz = Rot2D (sunDir.xz, 0.5 * pi + az);\n  sunDir.yz = Rot2D (sunDir.yz, 0.5 * pi + el);\n#if MORE_DIG\n  tCyc = 60.;\n#else\n  tCyc = 30.;\n#endif\n  vText = (mod (tCur, tCyc) > 0.5 * tCyc);\n  if (vText) {\n    txDep = 0.4;\n    ro.z += 1.5 * tCur;\n  } else {\n    txDep = 0.6;\n    ro.z += 1.5 * (tCyc - tCur);\n  }\n  ro.x -= 0.5;\n  dstFar = 200.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\n#define C(c) _ic = (_nc -- == 0) ? (c) : _ic;\n\n#define _0     C(0x30)\n#define _1     C(0x31)\n#define _2     C(0x32)\n#define _3     C(0x33)\n#define _4     C(0x34)\n#define _5     C(0x35)\n#define _6     C(0x36)\n#define _7     C(0x37)\n#define _8     C(0x38)\n#define _9     C(0x39)\n\nint GetTxChar (vec2 p)\n{\n  vec2 fp;\n  ivec2 ip;\n  float d;\n  int _ic, _nc;\n  fp = floor (p);\n  if (! vText) fp.y = - fp.y;\n#if MORE_DIG\n  fp.y = mod (fp.y, 38.);\n#else\n  fp.y = mod (fp.y, 21.);\n#endif\n  ip = ivec2 (fp);\n  ip.x += 20;\n  _nc = ip.x;\n  _ic = 0;\n  if (ip.x >= 0 && ip.x < 80) {\n    if (ip.y ==  0) { _3 _1 _4 _1 _5 _9 _2 _6 _5 _3 _5 _8 _9 _7 _9 _3 _2 _3 _8 _4 _6 _2 _6 _4 _3 _3 _8 _3 _2 _7 _9 _5 _0 _2 _8 _8 _4 _1 _9 }\n    if (ip.y ==  1) { _7 _1 _6 _9 _3 _9 _9 _3 _7 _5 _1 _0 _5 _8 _2 _0 _9 _7 _4 _9 _4 _4 _5 _9 _2 _3 _0 _7 _8 _1 _6 _4 _0 _6 _2 _8 _6 _2 _0 }\n    if (ip.y ==  2) { _8 _9 _9 _8 _6 _2 _8 _0 _3 _4 _8 _2 _5 _3 _4 _2 _1 _1 _7 _0 _6 _7 _9 _8 _2 _1 _4 _8 _0 _8 _6 _5 _1 _3 _2 _8 _2 _3 _0 }\n    if (ip.y ==  3) { _6 _6 _4 _7 _0 _9 _3 _8 _4 _4 _6 _0 _9 _5 _5 _0 _5 _8 _2 _2 _3 _1 _7 _2 _5 _3 _5 _9 _4 _0 _8 _1 _2 _8 _4 _8 _1 _1 _1 }\n    if (ip.y ==  4) { _7 _4 _5 _0 _2 _8 _4 _1 _0 _2 _7 _0 _1 _9 _3 _8 _5 _2 _1 _1 _0 _5 _5 _5 _9 _6 _4 _4 _6 _2 _2 _9 _4 _8 _9 _5 _4 _9 _3 }\n    if (ip.y ==  5) { _0 _3 _8 _1 _9 _6 _4 _4 _2 _8 _8 _1 _0 _9 _7 _5 _6 _6 _5 _9 _3 _3 _4 _4 _6 _1 _2 _8 _4 _7 _5 _6 _4 _8 _2 _3 _3 _7 _8 }\n    if (ip.y ==  6) { _6 _7 _8 _3 _1 _6 _5 _2 _7 _1 _2 _0 _1 _9 _0 _9 _1 _4 _5 _6 _4 _8 _5 _6 _6 _9 _2 _3 _4 _6 _0 _3 _4 _8 _6 _1 _0 _4 _5 }\n    if (ip.y ==  7) { _4 _3 _2 _6 _6 _4 _8 _2 _1 _3 _3 _9 _3 _6 _0 _7 _2 _6 _0 _2 _4 _9 _1 _4 _1 _2 _7 _3 _7 _2 _4 _5 _8 _7 _0 _0 _6 _6 _0 }\n    if (ip.y ==  8) { _6 _3 _1 _5 _5 _8 _8 _1 _7 _4 _8 _8 _1 _5 _2 _0 _9 _2 _0 _9 _6 _2 _8 _2 _9 _2 _5 _4 _0 _9 _1 _7 _1 _5 _3 _6 _4 _3 _6 }\n    if (ip.y ==  9) { _7 _8 _9 _2 _5 _9 _0 _3 _6 _0 _0 _1 _1 _3 _3 _0 _5 _3 _0 _5 _4 _8 _8 _2 _0 _4 _6 _6 _5 _2 _1 _3 _8 _4 _1 _4 _6 _9 _5 }\n    if (ip.y == 10) { _1 _9 _4 _1 _5 _1 _1 _6 _0 _9 _4 _3 _3 _0 _5 _7 _2 _7 _0 _3 _6 _5 _7 _5 _9 _5 _9 _1 _9 _5 _3 _0 _9 _2 _1 _8 _6 _1 _1 }\n    if (ip.y == 11) { _7 _3 _8 _1 _9 _3 _2 _6 _1 _1 _7 _9 _3 _1 _0 _5 _1 _1 _8 _5 _4 _8 _0 _7 _4 _4 _6 _2 _3 _7 _9 _9 _6 _2 _7 _4 _9 _5 _6 }\n    if (ip.y == 12) { _7 _3 _5 _1 _8 _8 _5 _7 _5 _2 _7 _2 _4 _8 _9 _1 _2 _2 _7 _9 _3 _8 _1 _8 _3 _0 _1 _1 _9 _4 _9 _1 _2 _9 _8 _3 _3 _6 _7 }\n    if (ip.y == 13) { _3 _3 _6 _2 _4 _4 _0 _6 _5 _6 _6 _4 _3 _0 _8 _6 _0 _2 _1 _3 _9 _4 _9 _4 _6 _3 _9 _5 _2 _2 _4 _7 _3 _7 _1 _9 _0 _7 _0 }\n    if (ip.y == 14) { _2 _1 _7 _9 _8 _6 _0 _9 _4 _3 _7 _0 _2 _7 _7 _0 _5 _3 _9 _2 _1 _7 _1 _7 _6 _2 _9 _3 _1 _7 _6 _7 _5 _2 _3 _8 _4 _6 _7 }\n    if (ip.y == 15) { _4 _8 _1 _8 _4 _6 _7 _6 _6 _9 _4 _0 _5 _1 _3 _2 _0 _0 _0 _5 _6 _8 _1 _2 _7 _1 _4 _5 _2 _6 _3 _5 _6 _0 _8 _2 _7 _7 _8 }\n    if (ip.y == 16) { _5 _7 _7 _1 _3 _4 _2 _7 _5 _7 _7 _8 _9 _6 _0 _9 _1 _7 _3 _6 _3 _7 _1 _7 _8 _7 _2 _1 _4 _6 _8 _4 _4 _0 _9 _0 _1 _2 _2 }\n    if (ip.y == 17) { _4 _9 _5 _3 _4 _3 _0 _1 _4 _6 _5 _4 _9 _5 _8 _5 _3 _7 _1 _0 _5 _0 _7 _9 _2 _2 _7 _9 _6 _8 _9 _2 _5 _8 _9 _2 _3 _5 _4 }\n    if (ip.y == 18) { _2 _0 _1 _9 _9 _5 _6 _1 _1 _2 _1 _2 _9 _0 _2 _1 _9 _6 _0 _8 _6 _4 _0 _3 _4 _4 _1 _8 _1 _5 _9 _8 _1 _3 _6 _2 _9 _7 _7 }\n    if (ip.y == 19) { _4 _7 _7 _1 _3 _0 _9 _9 _6 _0 _5 _1 _8 _7 _0 _7 _2 _1 _1 _3 _4 _9 _9 _9 _9 _9 _9 _8 _3 _7 _2 _9 _7 _8 _0 _4 _9 _9 _5 }\n#if MORE_DIG\n    if (ip.y == 20) { _1 _0 _5 _9 _7 _3 _1 _7 _3 _2 _8 _1 _6 _0 _9 _6 _3 _1 _8 _5 _9 _5 _0 _2 _4 _4 _5 _9 _4 _5 _5 _3 _4 _6 _9 _0 _8 _3 _0 }\n    if (ip.y == 21) { _2 _6 _4 _2 _5 _2 _2 _3 _0 _8 _2 _5 _3 _3 _4 _4 _6 _8 _5 _0 _3 _5 _2 _6 _1 _9 _3 _1 _1 _8 _8 _1 _7 _1 _0 _1 _0 _0 _0 }\n    if (ip.y == 22) { _3 _1 _3 _7 _8 _3 _8 _7 _5 _2 _8 _8 _6 _5 _8 _7 _5 _3 _3 _2 _0 _8 _3 _8 _1 _4 _2 _0 _6 _1 _7 _1 _7 _7 _6 _6 _9 _1 _4 }\n    if (ip.y == 23) { _7 _3 _0 _3 _5 _9 _8 _2 _5 _3 _4 _9 _0 _4 _2 _8 _7 _5 _5 _4 _6 _8 _7 _3 _1 _1 _5 _9 _5 _6 _2 _8 _6 _3 _8 _8 _2 _3 _5 }\n    if (ip.y == 24) { _3 _7 _8 _7 _5 _9 _3 _7 _5 _1 _9 _5 _7 _7 _8 _1 _8 _5 _7 _7 _8 _0 _5 _3 _2 _1 _7 _1 _2 _2 _6 _8 _0 _6 _6 _1 _3 _0 _0 }\n    if (ip.y == 25) { _1 _9 _2 _7 _8 _7 _6 _6 _1 _1 _1 _9 _5 _9 _0 _9 _2 _1 _6 _4 _2 _0 _1 _9 _8 _9 _3 _8 _0 _9 _5 _2 _5 _7 _2 _0 _1 _0 _6 }\n    if (ip.y == 26) { _5 _4 _8 _5 _8 _6 _3 _2 _7 _8 _8 _6 _5 _9 _3 _6 _1 _5 _3 _3 _8 _1 _8 _2 _7 _9 _6 _8 _2 _3 _0 _3 _0 _1 _9 _5 _2 _0 _3 }\n    if (ip.y == 27) { _5 _3 _0 _1 _8 _5 _2 _9 _6 _8 _9 _9 _5 _7 _7 _3 _6 _2 _2 _5 _9 _9 _4 _1 _3 _8 _9 _1 _2 _4 _9 _7 _2 _1 _7 _7 _5 _2 _8 }\n    if (ip.y == 28) { _3 _4 _7 _9 _1 _3 _1 _5 _1 _5 _5 _7 _4 _8 _5 _7 _2 _4 _2 _4 _5 _4 _1 _5 _0 _6 _9 _5 _9 _5 _0 _8 _2 _9 _5 _3 _3 _1 _1 }\n    if (ip.y == 29) { _6 _8 _6 _1 _7 _2 _7 _8 _5 _5 _8 _8 _9 _0 _7 _5 _0 _9 _8 _3 _8 _1 _7 _5 _4 _6 _3 _7 _4 _6 _4 _9 _3 _9 _3 _1 _9 _2 _5 }\n    if (ip.y == 30) { _5 _0 _6 _0 _4 _0 _0 _9 _2 _7 _7 _0 _1 _6 _7 _1 _1 _3 _9 _0 _0 _9 _8 _4 _8 _8 _2 _4 _0 _1 _2 _8 _5 _8 _3 _6 _1 _6 _0 }\n    if (ip.y == 31) { _3 _5 _6 _3 _7 _0 _7 _6 _6 _0 _1 _0 _4 _7 _1 _0 _1 _8 _1 _9 _4 _2 _9 _5 _5 _5 _9 _6 _1 _9 _8 _9 _4 _6 _7 _6 _7 _8 _3 }\n    if (ip.y == 32) { _7 _4 _4 _9 _4 _4 _8 _2 _5 _5 _3 _7 _9 _7 _7 _4 _7 _2 _6 _8 _4 _7 _1 _0 _4 _0 _4 _7 _5 _3 _4 _6 _4 _6 _2 _0 _8 _0 _4 }\n    if (ip.y == 33) { _6 _6 _8 _4 _2 _5 _9 _0 _6 _9 _4 _9 _1 _2 _9 _3 _3 _1 _3 _6 _7 _7 _0 _2 _8 _9 _8 _9 _1 _5 _2 _1 _0 _4 _7 _5 _2 _1 _6 }\n    if (ip.y == 34) { _2 _0 _5 _6 _9 _6 _6 _0 _2 _4 _0 _5 _8 _0 _3 _8 _1 _5 _0 _1 _9 _3 _5 _1 _1 _2 _5 _3 _3 _8 _2 _4 _3 _0 _0 _3 _5 _5 _8 }\n    if (ip.y == 35) { _7 _6 _4 _0 _2 _4 _7 _4 _9 _6 _4 _7 _3 _2 _6 _3 _9 _1 _4 _1 _9 _9 _2 _7 _2 _6 _0 _4 _2 _6 _9 _9 _2 _2 _7 _9 _6 _7 _8 }\n#endif\n  }\n  return _ic;\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfyR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[121, 418, 444, 444, 808], [810, 810, 844, 844, 1523], [1525, 1525, 1556, 1556, 1736], [1738, 1738, 1773, 1773, 2724], [2726, 2726, 2782, 2782, 3872], [4152, 4152, 4176, 4176, 9558], [9681, 9681, 9705, 9705, 9752], [9754, 9754, 9779, 9779, 9978], [9980, 9980, 10001, 10001, 10140], [10142, 10142, 10172, 10172, 10230]]}
{"id": "4lscRn", "name": "Public Transport", "author": "josemorval", "description": "A kind of public transport abstraction", "tags": ["lines", "abstract", "shapes", "split", "collapse", "trains"], "likes": 7, "viewed": 530, "date": "1503146341", "time_retrieved": "2024-06-20T18:59:15.160493", "image_code": "//Fabrice's way :)\nvoid mainImage( out vec4 c, vec2 U )\n{\n    float t = iTime, a = .1*t;\n\tU = 10.* ( U -.5 * iResolution.xy ) /iResolution.y\n           *  mat2(cos(a),-sin(a),sin(a),cos(a));\n    U.x += iTime;\n    vec2 p = U; p.x = round(p.x);\n    \n    float dis = U.x-p.x,\n          f = dot(p,p),\n          r = fract(1001.*sin(112.*p.x));\n    r = floor(r*10.)/10.-.5;\n  \tr *= 30.;\n    \n    f = sin(f+r*t) * (1.+.2*cos(f+3.*t));\n    f = .03+.2*smoothstep(.2,1.,f);\n    \n    c -= c;\n    c.r = smoothstep(.75*f, f, abs(dis));\n}\n\n\n/*void mainImage( out vec4 c, in vec2 uv )\n{\n\tuv = uv.xy / iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=10.;\n    \n    float angle = 0.1*iTime;\n    uv=mat2(cos(angle),sin(angle),-sin(angle),cos(angle))*uv;\n    uv.x+=iTime;\n    vec2 p = uv, pd = p;\n    pd.x=floor(pd.x+.5)/1.;\n    \n    float r = fract(1001.*sin(112.*pd.x));\n    r=floor(r*10.)/10.-.5;\n  \tr*=30.;\n    \n    float f = sin(dot(pd,pd)+r*iTime)*(1.+.2*cos(dot(pd,pd)+3.*iTime));\n    f = .03+.2*smoothstep(.2,1.,f);\n    float dis = p.x-pd.x;\n    f=smoothstep(0.75*f,f,abs(dis)); \n    \n\tc = vec4(f,0.,0.,0.);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lscRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 19, 57, 57, 524]]}
{"id": "4lsyzr", "name": "Moss MossesEgg EarVagEgg ", "author": "ollj", "description": "mouse.xy sets upper and lower radii (blue and red), \nThe larger radius will always be red.\nA r3d/largest radius rounds the middle part (green), oscillating between \"circle\" and \"nearly flat\"\n\nShape input is overly constrained for now", "tags": ["heart", "egg", "egg", "ear", "superprim", "earvagegg", "tangentcapsule", "mosss"], "likes": 2, "viewed": 620, "date": "1503195135", "time_retrieved": "2024-06-20T18:59:16.627188", "image_code": "/*\nsketch showing underlying trigonometry:\nhttp://imgur.com/a/WjcwM\n\nThis is a dirty first draft, inefficient and with no clear context, \nbecause i got too tired of this for today to optimize oand clean it contextually.\nIt lacks user friendly oconstrains, like, flickering if m.y is too high or too low\nbecause i have not decided on ui constrains beyond basic functionality:\n\nmouse.xy sets upper and lower radii (blue and red), \nthe larger radius will alway be red.\na r3d/largest radius rounds the middle part (green)\nits radius is set by \n*/\n#define  rac mix(.5,3.,sin(iTime)*.5+.5)\n//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n/*\nthe 3rd/larger circle contains the 2 smaller circles and touches them at 1 point.\nThis results in a very precise egg-shaped distance field:\n\nA rounder \"tangential capsule\" has the middle part not as straight line, \nbut a 3rd large circle with a radius \nthat contains the other 2 circles and touches them once.\n\nif (3rd circle has infinite radius) this would be [tangentCapsule superprim].\n\nthe whole shapes implicit curve is constrained to 0<=y<=1 due to the input setup.\n\n*/\n\n\n\n/*\ntiny framework 2017-08\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//apply:  c=abs(c)-.05; making the distance field an outline of itself.\n#define toisoline\n\n\n//zoom of view Frame\n#define ViewZoom 1.5\n\n\n/* end__.Parameters\n   start.Static\n*/\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -maxv(-a)\n#define dd(a) dot(a,a)\n//making a triangle wave;\n#define fr(a) fract(a)\n#define ss2t(a) a=abs(a*2.-1.)\n#define grid(u) mav(abs(fr(u)*2.-1.))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n//----------- mirror symmetry mirror == swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\n/* end__.Static\n   start.Implicit\n*/\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nv0 sat(v0 a,v1 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nv0 sat(v0 a){return sat(a,v1(1));}//return clamp(a,0.,1.); \n\n\n//fast good monochrome distance field visualization.\n//blue is grid, red and green are distance fields\nv2 rg(v2 c,v1 u){v0 fsaa=1./min(iResolution.x,iResolution.y);\n return vec3(c.rg=mix(fract(c.rg*4.),smoothstep(fsaa,-fsaa,c.rg),\n  .5+(atan(c.rg))/acos(-1.)),grid(u));}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important here.   \n \n\n//rectangle from v1(0) to v1(m)\nv0 rect(v1 u,v3 m){return mav(abs(u*2.-m.xy)-m.xy)*.5;}\n//for a \"class\" of ring/arc shapes.\nv1 arc(v1 u,v3 m){return v1(m.x-abs(m.y),dd(u));}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x);//calculate dorated differential\n return dot(u-m.xy,(f));//signed distance to line \n //more generally, f should be normalized here for proper caling.\n //but scaling is irrelevant as we only care fror the sign \n}\n /**/\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n v1 u=fra(U);\n v2 c=v2(0);\n v3 m=v3(fra(iMouse.xy),fra(iMouse.zw));\n    \n\n //m.xy=abs(m.xy);//mouse is always positive.\n /*main*/\n\n u.y+=.5; \n m.y+=.5;\n\n if(iMouse.z<=0.)m.xy=vec2(cos(iTime),sin(iTime*.61))*.4;\n \n //m.y=0.;\n m.xy=min(m.xy,vec2(.49999));\n m.xy=max(m.xy,vec2(-.49999));\n m=abs(m);\n if(m.x>m.y)m.xy=m.yx;\n \n\n vec3 ad=vec3(m.y-rac,m.y,rac);   //tangential large circle\n vec3 d=vec3(0,m.y,m.y);          //smaller upper circle .xy=center .z=radius\n    \n vec3 ae=vec3(m.x-rac,1.-m.x,rac); //tangential large circle\n vec3 e=vec3(0,1.-m.x,m.x);       //smaller lower circle .xy=center .z=radius\n    \n    \n //u.y-=m.x;\n    \n //c.g=length(u-d.xy)-d.z;\n //c.g=length(u-ad.xy)-ad.z;\n\n \n\n \n    \n vec3 hig=vec3(0,1.-m.x,rac-m.x);//upper intersect ring\n vec3 low=vec3(0,m.y,rac-m.y);//lower intersect ring\n  vec2 i=vec2(0);//center of 2 large circles, to be calculated by intersection\n  i.y=ad.y-cci(vec3(low.z,hig.z,ad.y-ae.y));//circle circle intersection.y\n  float y=m.y-i.y;\n  c.r=min(abs(length(u-hig.xy)-hig.z),abs(length(u-low.xy)-low.z));\n  i.x=-sqrt(low.z*low.z-y*y);//circle circle intersection.x\n \n    \n    \n    \n    \n    \n    \n    \n c.g=max(length(u-ad.xy)-ad.z,-length(u-d.xy)+d.z);\n c.b=max( length(u-ae.xy)-ae.z,-length(u-e.xy)+e.z);\n \n   \n c.r=min(c.r,abs(u.y-i.y));\n c.r=min(c.r,abs(u.x-i.x));\n \n    \n      u.x=abs(u.x);\n    \n  c.r=smoothstep(.1,-.1,c.r);//yes, this shows circlecircle intersection.\n c.r=length(u-i)-low.z-m.y;//yes this is the middle one!!!!!!!!!!!!\n \n  \n    \n    \n float da=sd2l(u,vec4(i,d.xy));\n float db=sd2l(u,vec4(i,e.xy));\n    c=vec3(0);\n         if(da<.0)c.b=length(u-d.xy)-d.z;\n else if(db>.0)   c.g=length(u-e.xy)-e.z; \n  else c.r=length(u-i)-low.z-m.y;\n \n \n    \n//remaining problem is the branching, calculating if u is above or below a line\n    \n \n    \n    \n    \n    \n /*O*/\n #ifdef toisoline\n c=abs(c)-.03;\n #endif\n v0 fsaa=1./min(iResolution.x,iResolution.y);\n c=mix(fract(c*4.),smoothstep(fsaa,-fsaa,c),.6);\n return c*.3+c.yzx*.7;}\n\nvoid mainImage(out vec4 O, vec2 U){O=vec4(c(U),1);\n}\n//#define mainImage(O,U)O=vec4(c(U),1);\n/* end__.Main\n   start.Tail\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsyzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1422, 1586, 1599, 1599, 1620], [1621, 1621, 1634, 1634, 1661], [1662, 1662, 1675, 1675, 1708], [3216, 3305, 3323, 3323, 3400], [3401, 3401, 3414, 3414, 3435], [3463, 3566, 3583, 3583, 3733], [3735, 3850, 3868, 3868, 3911], [4001, 4033, 4052, 4052, 4088], [4089, 4125, 4143, 4143, 4174], [4176, 4235, 4262, 4373, 4620], [4622, 4662, 4673, 4680, 6663], [6665, 6665, 6700, 6700, 6717]]}
{"id": "4lXyRH", "name": "Moss Egg Branchless", "author": "ollj", "description": "Return distance to 2 circles and a 3rd circle that is a \"rounded tangent\".\n\ncleaned up version of  https://www.shadertoy.com/view/4lsyzr\n", "tags": ["arrow", "egg", "tangent", "moss", "bisymmetry", "earvagegg", "earvagegg", "tangentcapsule", "superpimm", "pointer", "appolonean"], "likes": 4, "viewed": 957, "date": "1503323516", "time_retrieved": "2024-06-20T18:59:17.578782", "image_code": "//https://www.shadertoy.com/view/4lsyzr\n\n/*\nsketch showing underlying trigonometry:\nhttp://imgur.com/a/WjcwM\n\nThis is a dirty first draft, inefficient and with no clear context, \nbecause i got too tired of this for today to optimize oand clean it contextually.\nIt lacks user friendly oconstrains, like, flickering if m.y is too high or too low\nbecause i have not decided on ui constrains beyond basic functionality:\n\nmouse.xy sets upper and lower radii (blue and red), \nthe larger radius will alway be red.\na r3d/largest radius rounds the middle part (green)\nits radius is set by \n*/\n//#define  rac mix(.5,3.,sin(iTime)*.5+.5)\n//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n/*\nthe 3rd/larger circle contains the 2 smaller circles and touches them at 1 point.\nThis results in a very precise egg-shaped distance field:\n\nA rounder \"tangential capsule\" has the middle part not as straight line, \nbut a 3rd large circle with a radius \nthat contains the other 2 circles and touches them once.\n\nif (3rd circle has infinite radius) this would be [tangentCapsule superprim].\n\nthe whole shapes implicit curve is constrained to 0<=y<=1 due to the input setup.\n\n*/\n\n\n\n/*\ntiny framework 2017-08\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//set size of 3rd circle==inverseRoundness of the \"tangent\" between the 2 smaller circles.\n#define rac mix(.5,3.,sin(iTime)*.5+.5)\n//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n\n//show segment cases\n#define showCases\n\n//apply:  c=abs(c)-.05; making the distance field an outline of itself.\n//#define toisoline\n\n//zoom of view Frame\n#define ViewZoom 1.5\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n/* end__.Parameters\n   start.Static\n*/\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n/* end__.Static\n   start.Implicit\n*/\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\nv0 cci(vec3 r){v0 d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important here.   \n\n//smart way <- NEVER give input values that result in undefined axiomes <- arbituarity.\n//slow  way <- make all unsave inputs WorkSafe <- more if(),symmetrySolds,BVH\n#define GoedelTarski\n//return distance to 2 circles with a rounded tangent between them. http://imgur.com/a/WjcwM\n//m.xy set radius of upper and lower small circle\n//m.z sets radius of a large circle, which rounds the tangent\nv2 moss(v1 u,v2 m){u.x=abs(u.x);//make bilateral              \n #ifdef GoedelTarski\n //catch division by 0 cases before they can occur:\n m.xy=mod(abs(m.xy),.5);m.z=max(m.z,.5);//catch sqrt(<0); too small 3rd circle radius (make 3rd circle minimum size)\n if(m.z==.5)return vec3(length(u-v1(0,.5))-.5);//catch 3rd circle border case. (shape is a circle)\n #endif               \n //m.z=.5;//test border case, expect pseudo-arbitiary flickering\n v0 c=cci(v2(m.zz-m.yx,m.y+m.x-1.)),//calculate circle circle intersection.y\n l=m.z-m.y;//other length for pytagorean theorem below, to get intersection.x\n v1 d=v1(0,m.y),//smaller upper circle center\n e=v1(0,1.-m.x),  //smaller lower circle center\n i=v1(-sqrt(l*l-c*c),m.y-c);//3rd circle center.y\n v1 h=v1(sign(dot(u-d,v1(           -c,d.x-i.x))),\n         sign(dot(u-e,v1(-1.+m.x+m.y-c,d.x-i.x))))+1.;//2 branching \"lines\"\n v1 j=d+.5*(i-d)*h.x;l*=h.x;\n vec3 r=vec3(length(u-j-.5*(e-j)*h.y) -m.y +.5*(h.y*(.5*l+m.y-m.x)-l));\n #ifdef showCases\n  r.xy*=h.xy-1.;\n #endif\n return r;}\n//https://www.shadertoy.com/view/4lXyRH\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n v1 u=fra(U);\n v2 c=v2(0);\n vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));\n u.y+=.5;m.y+=.5;//optional frame shift\n  if(iMouse.z<=0.)m.xy=vec2(cos(iTime),sin(iTime*.61))*.4;///assive mouse\n /*main*/\n \n m.z=rac;//.5== circle;  5.= pretty straight red segment;  +inf=straight red segment.\n c=moss(u,vec3(m.xy,m.z));\n\n /*O*/\n #ifdef toisoline\n  c.b=abs(c.r)-.03;\n #endif\n v0 fsaa=1./min(iResolution.x,iResolution.y);\n c=mix(fract(c*4.),smoothstep(fsaa,-fsaa,c),.6);\n return c*.3+c.yzx*.7;}\n \n \nvoid mainImage(out vec4 O,vec2 U){O=vec4(c(U),1);}\n// #define mainImage(O,U)O=vec4(c(U),1);  //no longer functional\n\n/* end__.Main\n   start.Tail\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXyRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1862, 2014, 2029, 2029, 2069], [2344, 2549, 2568, 2568, 3570], [3612, 3647, 3658, 3665, 4149], [4154, 4154, 4188, 4188, 4204]]}
{"id": "4lXyWn", "name": "Fbm Raymarch Spheres", "author": "vamoss", "description": "Fbm raymarch spheres", "tags": ["fbmraymarchspheres"], "likes": 5, "viewed": 253, "date": "1504207746", "time_retrieved": "2024-06-20T18:59:18.585462", "image_code": "// Original work:\n// Cubes and Spheres by @paulofalcao\n// https://www.shadertoy.com/view/MsX3zr\n\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat fbm(vec2 uv, float t)\n{\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f;\n    f  = 0.5000*noise( uv+vec2(+t, +t) ); uv *= m;\n    f += 0.2500*noise( uv+vec2(+t, -t) ); uv *= m;\n    f += 0.1250*noise( uv+vec2(-t, +t) ); uv *= m;\n    f += 0.0625*noise( uv+vec2(-t, -t) ); uv *= m;\n    return f;\n}\n\n\n//Scene Start\n\nvec2 sim2d(\n  in vec2 p,\n  in float s)\n{\n   vec2 ret=p;\n   ret=p+s/2.0;\n   ret=fract(ret/s)*s-s/2.0;\n   return ret;\n}\n\nvec3 stepspace(\n  in vec3 p,\n  in float s)\n{\n  return p-mod(p-s/2.0,s);\n}\n\n//Object\nfloat obj(in vec3 p)\n{ \n  vec3 fp=stepspace(p,2.0);;\n  float d=fbm(fp.xz/20., iTime/2.)*3.;//sin(fp.x*0.3+iTime*4.0)+cos(fp.z*0.3+iTime*2.0);\n  p.y=p.y+d;\n  p.xz=sim2d(p.xz,2.0);\n  float c2=length(p)-0.5;\n  return c2;\n}\n\n//Object Color\nvec3 obj_c(vec3 p)\n{\n  vec2 fp=sim2d(p.xz-1.0,4.0);\n  if (fp.y>0.0) fp.x=-fp.x;\n  if (fp.x>0.0) return vec3(1.0,0.0,0.0);\n    else return vec3(1.0,1.0,1.0);   \n}\n\n//Scene End\n\n\n//Raymarching Framework Start\n\nfloat PI=3.14159265;\n\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3 lightv=normalize(light-pt);\n   float diffuse=dot(normal,lightv);\n   vec3 refl=-reflect(lightv,normal);\n   vec3 viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec);\n   return (max(diffuse,0.0)+ambLight)*color+specular;\n}\n\nfloat raymarching(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  out int objfound)\n{ \n  const vec3 e=vec3(0.1,0,0.0);\n  float s=startf;\n  vec3 c,p,n;\n  float f=startf;\n  objfound=1;\n  for(int i=0;i<256;i++){\n    if (abs(s)<precis||f>maxd||i>maxite) break;\n    f+=s;\n    p=prp+scp*f;\n    s=obj(p);\n  }\n  if (f>maxd) objfound=-1;\n  return f;\n}\n\nvec3 camera(\n  in vec3 prp,\n  in vec3 vrp,\n  in vec3 vuv,\n  in float vpd,\n  in vec2 fragCoord)\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  return normalize(scrCoord-prp);\n}\n\nvec3 normal(in vec3 p)\n{\n  //tetrahedron normal\n  const float n_er=0.01;\n  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er));\n  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er));\n  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er));\n  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er));\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvec3 render(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  in vec3 background,\n  in vec3 light,\n  in float spec,\n  in vec3 ambLight,\n  out vec3 n,\n  out vec3 p,\n  out float f,\n  out int objfound)\n{ \n  objfound=-1;\n  f=raymarching(prp,scp,maxite,precis,startf,maxd,objfound);\n  if (objfound>0){\n    p=prp+scp*f;\n    vec3 c=obj_c(p);\n    n=normal(p);\n    vec3 cf=phong(p,prp,n,light,c,spec,ambLight);\n    return vec3(cf);\n  }\n  f=maxd;\n  return vec3(background); //background color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n  //Camera animation\n  vec3 vuv=vec3(0,1,0);\n  vec3 vrp=vec3(0.0, 4.0, 0.0);//vec3(iTime*4.,4.0,0.0);\n  float mx=iMouse.x/iResolution.x*PI*2.0;\n  float my=iMouse.y/iResolution.y*PI/2.01;\n  if ((iMouse.x<=0.0)||(iMouse.y<=0.0)){mx=1.0,my=0.5;};//quick hack to detect no mouse input for thumbnail\n  vec3 prp=vrp+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0; //Trackball style camera pos\n  float vpd=1.5;\n  vec3 light=prp+vec3(5.0,0,5.0);\n  \n  vec3 scp=camera(prp,vrp,vuv,vpd,fragCoord);\n  vec3 n,p;\n  float f;\n  int o;\n  const float maxe=0.01;\n  const float startf=0.1;\n  const vec3 backc=vec3(0.0,0.0,0.0);\n  const float spec=8.0;\n  const vec3 ambi=vec3(0.1,0.1,0.1);\n  \n  vec3 c1=render(prp,scp,256,maxe,startf,60.0,backc,light,spec,ambi,n,p,f,o);\n  c1=c1*max(1.0-f*.015,0.0);\n  vec3 c2=backc;\n  if (o>0){\n    scp=reflect(scp,n);\n    c2=render(p+scp*0.05,scp,32,maxe,startf,10.0,backc,light,spec,ambi,n,p,f,o);\n  }\n  c2=c2*max(1.0-f*.1,0.0);\n  fragColor=vec4(c1.xyz*0.75+c2.xyz*0.25,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXyWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 97, 117, 117, 221], [223, 223, 249, 249, 549], [552, 552, 581, 581, 858], [861, 876, 916, 916, 993], [995, 995, 1039, 1039, 1068], [1070, 1079, 1101, 1101, 1298], [1300, 1315, 1335, 1335, 1476], [1492, 1545, 1676, 1676, 1930], [1932, 1932, 2074, 2074, 2331], [2333, 2333, 2429, 2429, 2680], [2682, 2682, 2706, 2729, 3019], [3021, 3021, 3276, 3276, 3560], [3562, 3562, 3618, 3641, 4617]]}
{"id": "4lXyz8", "name": "Simple Raymarcher With Shadows", "author": "Assossa", "description": "Simple raymarcher with shadows\n\nCamera ray code from https://www.shadertoy.com/view/XlBXWR", "tags": ["raymarcher"], "likes": 1, "viewed": 86, "date": "1503343430", "time_retrieved": "2024-06-20T18:59:18.591132", "image_code": "const float maxRender = 10e4; // Max distance to ray march\nconst float epsilon = 0.001; // Margin of error\nconst vec3 light = vec3(1.5, 1.5, -1.5); // Light position\nconst vec3 up = vec3(0, 1, 0);\n\n// Spheres\nint sphereCount = 2;\nvec3 sphereCenters[2];\nfloat sphereRadius[2];\nfloat floorHeight = -2.0;\n\n// Find distance between sphere and ray\nfloat sphereDistance(vec3 p, vec3 center, float radius) {\n    return distance(p, center) - radius;\n}\n\n// Find normal of sphere from hit location\nvec3 sphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\n// Get the hit location for a sphere and ray\nfloat sphereHit(vec3 o, vec3 d, vec3 center, float radius) {\n    // Keep track of the distance we have traveled\n    float dist = 0.0;\n    \n    // Kill the marching if we go too far\n    while(dist <= maxRender) {\n        // Get distance to sphere\n        float tempDist = sphereDistance(o, center, radius);\n        \n        // Add it to our distance counter and update the ray origin\n        dist += tempDist;\n        o += d * tempDist;\n        \n        // If we hit a sphere, then return the hit\n        if(tempDist <= epsilon) return dist;\n    }\n    \n    // We didn't hit anything\n    return -1.0;\n}\n\n// Get the hit for the floor\nfloat floorHit(vec3 o, vec3 d, float height) {\n    float du = dot(d, up);\n    if(du == 0.0) return -1.0;\n    \n    float dist = dot(vec3(0, height, 0) - o, up) / du;\n    if(dist < 0.0) return -1.0;\n    \n    return dist;\n}\n\nvec2 findHit(vec3 origin, vec3 ray, int ignore) {    \n    // Find a hit\n    float hit = maxRender;\n    int hitID = -1;\n    \n    for(int i = 0; i < sphereCount; i++) {\n        if(i == ignore) continue;\n    \tfloat tempHit = sphereHit(origin, ray, sphereCenters[i], sphereRadius[i]);\n        if(tempHit < hit  && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = i;\n        }\n    }\n    \n    if(ignore != -1) {\n        // Check for hit with floor\n        float tempHit = floorHit(origin, ray, floorHeight);\n        if(tempHit < hit && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = -1;\n        }\n    }\n    \n    return vec2(hit == maxRender ? -1.0 : hit, hitID);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Create ray for current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, -3.0);\n    \n    // Initialize the spheres\n    sphereCenters[0] = vec3(0.0);\n    sphereCenters[1] = vec3(cos(iTime) * 1.8, sin(iTime) * 1.8, -0.8);\n    sphereRadius[0] = 1.0;\n    sphereRadius[1] = 0.5;\n    \n    // Find a hit\n    vec2 tempHit = findHit(origin, ray, -10);\n    float hit = tempHit.x;\n    int hitID = int(tempHit.y);\n    \n    // If no hit, then use the sky color\n    if(hit < 0.0) {\n        fragColor = vec4(0.3, 0.5, 0.7, 1.0);\n        return;\n    }\n    \n    // Find hit point & light direction\n    vec3 hitPoint = origin + (ray * hit);\n    vec3 lightDir = normalize(light - hitPoint);\n    \n    // Find if we need a shadow\n    vec2 shadowHit = findHit(hitPoint, lightDir, hitID);\n    float shadow = shadowHit.y >= 0.0 ? 0.5 : 0.0;\n    \n    // Find the normal of the sphere and the diffuse lighting from the normal\n    vec3 nml = hitID == -1 ? vec3(0, 1, 0) : sphereNormal(hitPoint, sphereCenters[hitID]);\n    float diffuse = max(dot(nml, lightDir) + 0.4 - shadow, 0.0) * 0.95;\n    \n    fragColor = vec4(vec3(diffuse), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXyz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[303, 343, 400, 400, 443], [445, 488, 528, 528, 564], [566, 611, 671, 722, 1211], [1213, 1242, 1288, 1288, 1462], [1464, 1464, 1513, 1535, 2156], [2158, 2158, 2215, 2251, 3479]]}
{"id": "4s2BDc", "name": "Quasicrystal dipole zoom", "author": "ttoinou", "description": "Tweaked [url=https://www.shadertoy.com/view/4tcXDl]Quasicrystal zoom[/url]", "tags": ["quasicrystal"], "likes": 5, "viewed": 170, "date": "1502545959", "time_retrieved": "2024-06-20T18:59:19.124491", "image_code": "// Number of plane waves\nconst int K = 5;\n\n// Number of stripes per wave\nconst int NUM_STRIPES = 7;\n\nconst int NUM_FREQUENCIES = 10;\n\n// The main (central) spatial frequency\nfloat MEAN_FREQUENCY = 2.;\n\n// The spread of the spatial frequency envelope\nconst float SIGMA = 2.;\n\nconst float PERIOD = 4.;\n\nconst float PI = 4.0 * atan(1.0);\n\nfloat mean;\n\nfloat gaussian(float x) {\n    x -= mean;\n    return exp(-x * x / 2.) / SIGMA;\n}\n\n// Adjust the  wavelengths for the current spatial scale\nfloat wavelength(int i, float sc) {\n    return pow(2., float(i)) * sc;\n}\n\n// Modulate each wavelength by a Gaussian envelope in log\n// frequency, centered around aforementioned mean with defined\n// standard deviation\nfloat weight(int i, float sc) {\n    return gaussian(log(wavelength(i, sc)));\n}\n\n// 7-th order smoothstep function:\n// https://en.wikipedia.org/wiki/Smoothstep\n// https://gist.github.com/kylemcdonald/77f916240756a8cfebef\nfloat superSmooth(float x) {\n\tfloat xSquared = x * x;\n\treturn xSquared * xSquared * (x * (x * (x * -20. + 70.) - 84.) + 35.);\n}\n\nfloat quasi(in vec2 uv, float rotation) {\n\tfloat scale = pow(0.5, fract(iTime / PERIOD));\n\n    float weightSum = 0.;\n    for (int l = 0; l < NUM_FREQUENCIES; l++) {\n        weightSum += weight(l, scale);\n    }\n    \n    // Cartesian coordinates\n\tvec2 coords = uv * 2. * PI * float(NUM_STRIPES);\n\n    float c = 0.;  // Accumulator\n    \n    // Iterate over all k plane waves\n    for (int t = 0; t < K; t++) {\n    \tfloat tScaled = ( float(t) / float(K) + rotation ) * PI;\n        vec2 omega = vec2(cos(tScaled), sin(tScaled));\n\n        // Compute the phase of the plane wave\n        float ph = dot(coords, omega);\n\n        // Take a weighted sum over the different spatial scales\n        for (int l = 0; l < NUM_FREQUENCIES; l++) {\n\t\t\tc += cos(ph * wavelength(l, scale)) * weight(l, scale);\n        }\n    }\n    // Convert the summed waves to a [0,1] interval\n    // and then convert to color\n    return superSmooth((c / (weightSum * float(K)) + 1.) / 2.);\n\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 uv = (coord.xy - iResolution.xy / 2.) / iResolution.x;\n    vec2 dipole = vec2(.2,.0);\n    float rot = iTime/17.;\n    MEAN_FREQUENCY = 2.;\n    mean = MEAN_FREQUENCY * log(2.);\n        \n    col =vec4(.0);\n    col.r +=  quasi(uv-dipole,rot)*.8;\n    \n    MEAN_FREQUENCY *= sqrt(2.);\n    mean = MEAN_FREQUENCY * log(2.);\n    col.b += quasi(uv+dipole,-rot*sqrt(3./2.));\n    \n    col.g = (col.r+col.b)/2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2BDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[202, 349, 374, 374, 428], [430, 487, 522, 522, 559], [561, 704, 735, 735, 782], [784, 924, 952, 952, 1051], [1053, 1053, 1094, 1094, 2007], [2009, 2009, 2054, 2054, 2464]]}
{"id": "4sBfDc", "name": "360 video rendered on gpu [Rays]", "author": "mjdr", "description": "360 video rendered on gpu", "tags": ["raymarch", "vr", "360"], "likes": 3, "viewed": 209, "date": "1502403477", "time_retrieved": "2024-06-20T18:59:20.203091", "image_code": "#define PI 3.141592\n\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    vec3 distKoef;\n    float power;\n};  \nstruct Material {\n    vec3 color;\n    float reflectionFactor;\n};\n\nint entry = -1;\n\n\n//Setup lights\n#define LIGTHS 2\nLight getLight(int i){\n    \n  float a = iTime /2.;\n    if(i == 0)\n        return Light(\n      \t\tvec3(5.0*cos(a),5.0,5.0*sin(a)),\n      \t\tvec3(1.),\n      \t\tvec3(.5,1.,1.),\n      \t\t1.0);\n    a += PI;\n    if(i == 1)\n        return Light(\n      \t\tvec3(5.0*cos(a),5.0,5.0*sin(a)),\n      \t\tvec3(1.),\n      \t\tvec3(.5,1.,1.),\n      \t\t1.0);\n}\n//Setup materials\nMaterial getMaterial(int i){\n    if(i == -1)//default\n        return Material(vec3(0.0),0.);\n    if(i == 0)//walls\n        return Material(vec3(0.5,0.5,0.9),0.0);\n    if(i == 1)//colls\n        return Material(vec3(0.,1.,0.),0.5);\n    if(i == 2)// sphere\n        return Material(vec3(1.,0.,0.),0.0);\n}\n\n\n//Track current shape\nint shapeId = -1;\nvoid resetShape(){\n  shapeId = -1;\n}\nfloat track(float D, float d, int index){\n    if(D > d){\n        D = d;\n        shapeId = index;\n    }\n    return D;\n}\n    \n//Building geomery\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 b){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeat(vec3 p, vec3 d){\n    return mod(p,d)- d / 2.; \n}\n\nfloat room(vec3 p){\n  float d = 1.0e10;\n  \n  float walls =\n    max(\n      -box(p,vec3(40.0,7.,40.)),\n       box(p,vec3(45.0,10.,45.))\n    );\n  \n  float colls = box(\n      repeat(p, vec3(13.)),\n      vec3(0.8,10.,0.8)\n  );\n    \n  d = track(d,walls,0);\n  d = track(d,colls,1);\n  d = track(d,sphere(p-vec3(0.,0.,5.0),1.5 * (1.5 + sin(1.0+p.y + 2.0*iTime)/2.)),2);\n  \n  return d;\n}\n\n\nfloat world(vec3 p){\n    float d = 1.0e10;\n    \n    d = min(d,room(p));\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,0.01);\n    float d = world(p);\n    return normalize(\n        vec3(\n        \tworld(p + e.yxx) - d,\n        \tworld(p + e.xyx) - d,\n        \tworld(p + e.xxy) - d\n            )\n    );\n}\n\n\nfloat tracer(vec3 O, vec3 D,float N){\n    \n    for(int i = 0;i < 512;i++){\n        float w = world(O + D*N);\n        \n        if(w < .005)\n            return N;\n        \n        N += w * 0.5;\n    }\n    return -1.0;\n}\n//Lighting\nvec3 applyLight(vec3 p, vec3 n,vec3 c, Light l){\n  \tvec3 toLight = l.pos - p;\n    float emb = 0.04;\n  \tvec3 lightDir = normalize(toLight);\n  \tfloat d = length(toLight);\n    \n  \tfloat k = dot(n,lightDir) * l.power;\n    if(k < 0.)\n    \treturn c * emb;\n    \n    //Shadow\n    float lightTrace = tracer(p,lightDir,0.3);\n    if(lightTrace != -1. && lightTrace <= d)\n    \treturn c * emb;\n    //\n    \n    float g = dot(vec3(k*k,k,1.0),1.0/(d*l.distKoef));\n        \n  \treturn c*l.color*g + c * emb;\n    \n}\n\n\nvec3 lighting(vec3 p, vec3 n, vec3 c){\n \n  vec3 color = vec3(0.0);\n    \n  for(int i = 0;i < LIGTHS;i++)\n  \tcolor += applyLight(p,n,c,getLight(i));\n    \n  return color;\n}\n\n\n\n\n\n//Cameras\nvec3 camera(vec2 fragCoord){\n    vec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.;\n    vec2 p = uv * vec2(1.,iResolution.y/iResolution.x);\n    return normalize(vec3(p,1.0));\n}\n\nvec3 camera360(vec2 fragCoord){\n    vec2 uv = (2.0 * fragCoord / iResolution.xy) - 1.;\n    vec2 a = vec2(uv.x * PI,uv.y * PI/2.);\n    vec3 vec = vec3(sin(a.x) * cos(a.y),sin(a.y),cos(a.y)*cos(a.x));\n    return vec;\n}\n\n\n\nvec3 getColor(vec3 O, vec3 D , out vec3 pos , out vec3 out_n, out int shape){\n    resetShape();\n    float t = tracer(O,D,0.4);\n    shape = shapeId;\n    vec3 color = vec3(0.0);\n    pos = O + D * t;\n    vec3 n = normal(pos);\n    \n    out_n = reflect(D,n);\n    \n    float ttt = float(shape+1);\n    if(t > 0.0)\n        color = lighting(pos,n,getMaterial(shape).color);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 o = vec3(0.,1.,-3.);\n    vec3 d = camera360(fragCoord);\n    \n    vec3 \n        tN1 = vec3(0.0),\n        tN2 = vec3(0.0),\n        tP1 = vec3(0.0),\n        tP2 = vec3(0.0),\n        color = vec3(0.0);\n    \n    tN1 = d;\n    tP1 = o;\n    \n    float k = 1.;\n    int shape = -1;\n    for(int i = 0;i < 2;i++){\n        color += getColor(tP1,tN1,tP2,tN2,shape) * k;\n        k *= getMaterial(shape).reflectionFactor;\n        if(k == 0.) break;\n        \n            \n        tP1 = tP2;\n        tN1 = tN2;\n    }\n    \n    \n    \n\tfragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[192, 224, 246, 246, 557], [558, 576, 604, 604, 876], [879, 919, 937, 937, 955], [956, 956, 997, 997, 1074], [1080, 1099, 1130, 1130, 1158], [1159, 1159, 1185, 1185, 1272], [1274, 1274, 1302, 1302, 1334], [1336, 1336, 1355, 1355, 1713], [1716, 1716, 1736, 1736, 1808], [1810, 1810, 1830, 1830, 2032], [2035, 2035, 2072, 2072, 2251], [2252, 2263, 2311, 2311, 2759], [2762, 2762, 2800, 2800, 2931], [2937, 2947, 2975, 2975, 3126], [3128, 3128, 3159, 3159, 3344], [3348, 3348, 3425, 3425, 3737], [3739, 3739, 3796, 3796, 4359]]}
{"id": "4sBfRt", "name": "Daily 2017-08-01", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 2, "viewed": 421, "date": "1501589027", "time_retrieved": "2024-06-20T18:59:20.203091", "image_code": "// inspired by https://www.facebook.com/photo.php?fbid=10213540067038752&set=pcb.10213540068238782&type=3&theater\n\n#define TAU 6.28318531\n#define hash(x) fract(sin(x)*1e4)\n#define h2(x,m) hash(dot(mod(x,m),vec2(3,5)))\n#define h3(x) hash(dot(mod(x,20.),vec3(3,5,7)))\n\nfloat n2(vec2 x, vec2 m) {\n    vec2 i=floor(x),\n        f=smoothstep(0.,1.,fract(x));\n    vec2 oi=vec2(0.,1.);\n    return mix(\n        mix(h2(i+oi.xx,m),h2(i+oi.yx,m),f.x),\n        mix(h2(i+oi.xy,m),h2(i+oi.yy,m),f.x),\n        f.y);\n}\n\nfloat n3(vec3 x) {\n    vec3 i=floor(x),\n        f=smoothstep(0.,1.,fract(x));\n    vec2 oi=vec2(0.,1.);\n    return mix(\n        mix(\n            mix(h3(i+oi.xxx),h3(i+oi.yxx),f.x),\n            mix(h3(i+oi.xyx),h3(i+oi.yyx),f.x),\n            f.y),\n        mix(\n            mix(h3(i+oi.xxy),h3(i+oi.yxy),f.x),\n            mix(h3(i+oi.xyy),h3(i+oi.yyy),f.x),\n            f.y),\n        f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    float ac=atan(uv.y,uv.x),\n        lc=length(uv);\n    uv+=(n3(vec3(uv*30.,iTime))-.5)*.02;\n    float a=atan(uv.y,uv.x),\n        l=length(uv);\n    a+=sin(iTime+l*10.)*.2;\n    vec3 c=mix(vec3(0.,.4,1.),vec3(0.,.8,1.),smoothstep(.6,.62,n2(vec2(a/TAU*80.,l*5.-iTime*.5),vec2(80.,1e4))+.2-l*.3));\n    c-=smoothstep(.6,.62,n2(vec2(a/TAU*20.,l*30.-iTime*3.),vec2(20.,1e4))+l*.2)*.5;\n    vec3 cc=mix(vec3(.9,.7,.1),vec3(1.,1.,.4),smoothstep(.5,.52,n3(vec3(ac/TAU*20.+sin(iTime*2.+lc*50.)*1.,lc*100.-iTime*1.,iTime))));\n    c=mix(cc,c,smoothstep(.1,.11,lc));\n\tfragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBfRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 267, 293, 293, 501], [503, 503, 521, 521, 891], [893, 893, 950, 950, 1591]]}
{"id": "4sBfWy", "name": "Procedural Gears", "author": "paulo69", "description": "Procedural Gears", "tags": ["procedural", "2d", "gears", "animation", "rotation"], "likes": 1, "viewed": 112, "date": "1501850804", "time_retrieved": "2024-06-20T18:59:20.348626", "image_code": "float dents = 13.0; // Nombre de dents de la roue\nfloat cirgen = .25;  // Epaisseur du \"pneu\" La valeur doit être égale ou supérieure à .14\nfloat tdents = .055; // Longueur des dents\nfloat biseaudents = .75;  // Forme des dents (arrondi le bout des dents, les coupe à une certaine valeur)\nfloat rayroue = 6.0; \nfloat raytrou = .09;\nfloat cirtrou = .6;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                -sin(_angle),-cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 p = vec2(.9,.5)-uv;\n    p*=rotate2d( -iTime);\n    vec3 c = vec3 (1.0);\n    float r = cirgen+tdents*clamp((cos(atan(p.x,p.y)*dents)),0.0,biseaudents);\n    r=min(min(r,step(.03,length(p))),step(raytrou+.04*(sign(cos((atan(p.x,p.y)*rayroue)))),length(p))) ;\n    c*=min(step(r,length(p)),step(.05,length(p)));\n\tfragColor = vec4(c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[20, 358, 386, 386, 474], [476, 476, 533, 533, 914]]}
{"id": "4sjfDK", "name": "Technicolor Hypno-Disc copy", "author": "greentec", "description": "copy from https://www.shadertoy.com/view/ldsfDX, and added some.", "tags": ["2d", "simple", "hypnosis"], "likes": 0, "viewed": 99, "date": "1502247376", "time_retrieved": "2024-06-20T18:59:20.348626", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    //rotate center\n    p -= vec2(sin(iTime) / 1.5, cos(iTime) / 1.5);\n    \n    float angle = atan(p.y, p.x);\n    float distance = length(p);\n    float color = sin(angle + distance * 15.0 + 30.0 / exp2(sin(iTime)));\n    float color2 = sin(angle + distance * 15.0 + 30.0 / exp2(sin(iTime)) + 3.14);\n    color = 1.0 - color;\n    color = clamp(color, 0.0, 0.6);\n    color2 = 1.0 - color2;\n    color2 = clamp(color2, 0.0, 0.6);\n    \n    \n    \n    vec3 pixel = vec3(color, color2, color);\n   \tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 650]]}
{"id": "4sjfzd", "name": "The Two Worlds", "author": "andyborrell", "description": "My first submission!\n\nIt uses the grid iteration technique used in iq's Cubescape (www.shadertoy.com/view/Msl3Rr), but transforms the coordinate space so that each square of the grid corresponds to two equilateral triangles.  Thanks Íñigo!\n\nSupports AA.\n", "tags": ["3d", "raymarching", "sound", "music", "bezier", "soundcloud"], "likes": 3, "viewed": 668, "date": "1501753607", "time_retrieved": "2024-06-20T18:59:23.700477", "image_code": "/**\n * Created by Andy Borrell 2017\n *\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader uses lots of code by iq and is inspired by his Cubescape (https://www.shadertoy.com/view/Msl3Rr). \n * It uses the grid iteration technique used in iq's Cubescape, but I transform the coordinate space first so that each\n * grid square of the iteration corresponds to two equilateral triangles.   \n * It uses raymarching (also iq's) through each grid cell using an SDF describing the two triangles.\n *\n * Credit to F.O.D. for the remix of DeadMau5's 4ware  (https://soundcloud.com/therealfod/deadmau5-4ware-01-fod-remake)\n *\n */\n\n//#define ANTIALIAS   \n\n//=========================================================================\nconst float animSpeed = 1.4;\n\n\nconst vec4 light1 = vec4(1.0000000,0.0000000,0.0000000,1.0000000);\nconst vec4 light2 = vec4(1.0000000,1.0000000,1.0000000,1.0000000);\nconst vec3 beamColor = vec3(1.0000000,1.0000000,1.0000000);\nconst float colorRange =  0.3500000;\nconst vec3 skyColor1 = vec3(0.0078431,0.0078431,0.0549020);\nconst vec3 skyColor2 = vec3(0.0313726,0.0313726,0.0470588);\nconst vec3 upDir = vec3(0,1,0);\nconst vec3 flip = vec3(-1,1,-1);\nconst vec2 tri = vec2(0,1);\n\nconst float root3 = 1.73205080756887;\nconst float root2 = 1.4142135623730951;\nconst float pi = 3.141592653589793;\n\nconst mat4 f1mat = mat4(1, 0, 0, 0, 0, -0.8164966, 0.5773503, 0, 0, 0.5773503, 0.8164966, 0, 0, 0.3333333, 0, 1);\nconst mat4 f2mat = mat4(0.5, -0.8164966, -0.2886752, 0, -0.5, -8.413279E-09, -0.8660254, 0, -0.7071068, -0.5773503, 0.4082483, 0, 0, 0.3333333, 0, 1);\nconst mat4 f3mat = mat4(0.5, -8.413279E-09, -0.8660254, 0, 0.5, 0.8164966, 0.2886752, 0, -0.7071068, 0.5773503, -0.4082483, 0, 0, 0.3333333, 0, 1);\nconst mat4 f4mat = mat4(-0.5, 0.8164966, 0.2886752, 0, 0.5, 8.413279E-09, 0.8660254, 0, -0.7071068, -0.5773503, 0.4082483, 0, 0, 0.3333333, 0, 1);\nconst mat3 warp = mat3(1, 0, 0, 0, 1, 0,1. / root3, 0, -2. / root3);\n\nconst vec3 bevelPlane1 = vec3(-0.5980844128924556, 0.8014331132758906, 0.0);\nconst vec3 bevelPlane2 = vec3(0.0, 0.8014331132758906, -0.5980844128924556);\nconst vec3 bevelPlane3 = vec3(0.47827732475813883, 0.7365470801275338, 0.47827732475813883);\n\nconst float surface = 0.002;\nconst int gridTraverseIterations = 18;\nconst int rayMarchIterations = 40;\nconst float tmax = 1000000000.;\n\nconst float tileThickness = 0.25;\nconst vec3 pyramid1Pos = vec3(0, 0, 0);\nconst vec3 pyramid2Pos = vec3(2, 16, -24);\nconst float pyramidSize =  9.;\nconst vec3 color1 = vec3(0.6468425,0.4779412,1.0000000);\nconst vec3 color2 = vec3(0.3088235,0.6035901,1.0000000);\n\nconst float beamStartHeight = 2.13;\nconst float beamWideningPoint = 7.82;\nconst float beamEnd = -0.31;\nconst float beamTailOff = 2.2;\n\nconst float fov = 2.6;\n\nconst float loopLen = 8.;\nconst float segmentDuration = 10.;\n\nconst float darkModeRoll = -2.;\nconst float transitionHeading = -0.8;\n\n// Global variables, some WebGL compilers seems more stable using globals instead\n// of function params\nfloat darkMode;\nfloat showInnerBeams;\nfloat scaledTime;\nfloat beamWidth;\nvec3 orbitPos;\n\nmat4 rot1, rot2, rotA, rotB;\nvec3 ro_alt;\nmat3 cam;\nvec3 ro;\n\nfloat fft[8];\n\nvec2 hash2(vec2 n) { return fract(sin(n)*63763.8465261); }\nfloat maxcomp(in vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat mincomp(in vec3 v) { return min(min(v.x, v.y), v.z); }\n\nmat3 rotate_x(float t)\n{\n    return mat3(1, 0, 0,\n                0, cos(t), sin(t),\n                0, -sin(t), cos(t));\n}\nmat3 rotate_y(float t)\n{\n    return mat3(cos(t), 0, -sin(t),\n                0, 1, 0,\n                sin(t), 0, cos(t));\n}\nmat3 rotate_z(float t)\n{\n    return mat3(cos(t), sin(t), 0,\n               -sin(t), cos(t), 0,\n                0, 0, 1);\n}\n\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p, n) - d;\n}\n\nmat3 setLookAt(in vec3 ro, in vec3 ta, float roll)\n{\n    vec3  cw = normalize(ta - ro);\n    vec3  cp = upDir;\n    vec3  cu = normalize(cross(cw, cp));\n    vec3  cv = cross(cu, cw);\n    return mat3(cu, cv, cw) * rotate_z(roll);\n}\n\nfloat fftLookup(int index)\n{\n    if (index < 3)  // Webgl doesn't support non-const array indices\n    {\n        if (index == 0) return fft[0];\n        if (index == 1) return fft[1];\n        if (index == 2) return fft[2];\n    }\n    else\n    {\n        if (index == 3) return fft[3];\n        if (index == 4) return fft[4];\n        if (index == 5) return fft[5];\n    }\n}\n\n// Returns height of both triangles in a square of the grid\nvec2 mapH(vec2 ipos)\n{\n    vec2 realPos = vec2(ipos.x + 0.5 * ipos.y + 0.25, ipos.y * root3/2. + root3/12.);\n    ivec2 layer =  ivec2(min(min (-tri + (8. - ipos.x - ipos.y) * 2.,  tri + ipos.x * 2.), tri + ipos.y * 2.));\n    return vec2(fftLookup(layer.x), fftLookup(layer.y)) * (2.44 - length(realPos - vec2(0.4444,0.2633) * pyramidSize)*0.44) + 0.37;\n}\n\n// Returns color of tile (tri should be 0 or 1)\nvec3 mapColour(vec2 ipos, float tri)\n{\n    vec2 seed =  vec2 (0,631) + (ipos.x*30. + ipos.y + tri * 2041.);\n    vec2 random = hash2(seed);\n    return vec3(vec3(mix(color1,color2,tri) + (vec3(random.x,random.y,1. - random.x - random.y)- 0.5) * colorRange) );    \n}\n\n// SDF function for two triangles\nfloat twotris(vec3 p, vec2 h, int numTris)\n{\n    const float ss = 0.995; // Having this scale factor stops the normal calculation from spanning multiple cells\n    float s = dot(p, vec3(1. / root2, 0., 1. / root2));\n\n    //Vertical planes\n    s = intersect(s, -p.x - 0.5*ss); \n    s = intersect(s, -p.z - 0.5*ss); \n\n    // horizontal planes\n    s = intersect(s, p.y - h.x);\n    s = intersect(s, -p.y + h.x - tileThickness);\n\n    // bevel\n    float bevelH = dot(bevelPlane1, vec3(-0.5, h.x - 0.1, 0));\n    s = intersect(s, plane(p, bevelPlane1, bevelH));\n\n    // other bevel\n    s = intersect(s, plane(p, bevelPlane2, bevelH));\n\n    // third bevel\n    bevelH = bevelPlane3.y*(h.x - 0.1);\n    s = intersect(s, plane(p, bevelPlane3, bevelH)); \n\n    if (numTris == 1)\n        return s;\n   \n    // Now the other triangle...\n    bevelH = dot(bevelPlane1, vec3(-0.5, h.y - 0.1, 0));\n    float t = plane(p, vec3(-1. / root2, 0., -1. / root2), 0.);\n    t = intersect(t, plane(p, vec3(1., 0., 0.), 0.5*ss));\n    t = intersect(t, plane(p, vec3(0., 0., 1.), 0.5*ss));\n    t = intersect(t, plane(p, vec3(0, 1, 0), h.y));\n    t = intersect(t, plane(p, vec3(0, -1, 0), -h.y + tileThickness));\n    p = p * flip;\n    t = intersect(t, plane(p, bevelPlane1, bevelH));\n    t = intersect(t, plane(p, bevelPlane2, bevelH));\n    bevelH = bevelPlane3.y*(h.y - 0.1);\n    t = intersect(t, plane(p, bevelPlane3, bevelH)); \n    return  _union(s, t);\n}\n\n// Get normal from twotris signed distance field\nvec3 trisNormal(in vec3 pos, vec2 h, int numTris)\n{\n    const float eps = 0.0001;\n    vec3 n;\n    float d = twotris(pos, h, numTris);\n    n.x = twotris(vec3(pos.x + eps, pos.y, pos.z), h, numTris) - d;\n    n.y = twotris(vec3(pos.x, pos.y + eps, pos.z), h, numTris) - d;\n    n.z = twotris(vec3(pos.x, pos.y, pos.z + eps), h, numTris) - d;\n    return normalize(n);\n}\n\n// return (rgb, dist)\nvec4 traceTiles(vec3 ro, in vec3 rd, in float tmin, in float tmax, inout vec3 normal)\n{\n    /* Transform into triangular space. Squares in this space\n     * look like two equilateral triangles in world space\n     * This allows me to use iq's grid traversal code  */\n    ro = warp * ro; \n    rd = warp * rd; \n    ro += tmin * rd;\n\n    vec3 rdi = 1.0 / rd;\n    vec3 rda = abs(rdi);\n    vec2 rds = sign(rd.xz);\n    vec4 res = vec4(tmax*2.);\n\n    float tgtz_x;\n    float tgtz_z;\n    float tgtz = 0.;\n\n    // The following if statement checks whether the ray origin is a point within the bounds of the \n    // grid. If it is then we'll just start the grid traversal from where we are. If we're not then \n    // jump to a point on the edge of the grid. The + 0.0001 is so that we don't end up outside\n    // the grid and do an early exit on the grid straight away\n\n    if (!(ro.x > 0. && ro.x < pyramidSize && ro.z > 0. && ro.z < pyramidSize))\n    {\n        if (rds.x > 0.)\n        {\n            tgtz_x = (0.0001 - ro.x) * rda.x;\n        }\n        else\n        {\n            tgtz_x = -(pyramidSize - 0.0001 - ro.x) * rda.x;\n        }\n        if (rd.z > 0.)\n        {\n            tgtz_z = ( 0.0001 - ro.z) * rda.z;\n        }\n        else\n        {\n            tgtz_z = -(pyramidSize - 0.0001 - ro.z) * rda.z;\n        }\n        tgtz = max(tgtz_x, tgtz_z);\n        ro += tgtz * rd;\n    }\n\n    vec2 pos = floor(ro.xz); //always points to corner of cell\n    vec2 dis = (pos - ro.xz + 0.5 + rds*0.5) * rdi.xz; // a vector of how many rd vectors we need to add to get to next boundary\n\n    for (int i = 0; i<gridTraverseIterations; i++)\n    {\n        if (pos.x >= pyramidSize || pos.y >= pyramidSize || pos.x < 0. || pos.y < 0.)\n        {\n            return vec4(0, 0, 0, tmax);\n        }\n\n        if ((pos.x + pos.y) < pyramidSize) // we're iterating over a grid, but we just ignore half so that it's a triangle\n        {\n            vec2 hs = mapH(pos); \n\n            float hmax = max(hs.x, hs.y);\n\n            // intersect box\n            vec3  ce = vec3(pos.x + 0.5, 0.33 + 0.5 * hmax, pos.y + 0.5);\n            vec3  rb = vec3(0.5, hmax*0.5, 0.5);\n            vec3  rc = ro - ce;\n            float tN = maxcomp(-rdi*rc - rda*rb);\n            float tF = mincomp(-rdi*rc + rda*rb);\n            if (tN < tF)\n            {\n                rc.y = rc.y + 0.5 * hmax; // let rc be relative to ground plane\n                                    \n                float s = tN;\n\n                int numTris = 2;\n\n                if (pos.x + pos.y  + 1. == pyramidSize)\n                    numTris = 1;  // Only one triangle in a 'square' for squares along the diagonal\n\n                float h = 1.0;\n\n                for (int j = 0; j<rayMarchIterations; j++) \n                {\n                    vec3 p = rc + s * rd;\n                    h = twotris(p, hs, numTris);\n                    s += h;\n\n                    if (s>tF) break;\n\n                    if (h < surface)\n                    {\n                        res = vec4(mapColour(pos, step(p.x, -p.z) ) + \n                               (1. -darkMode * 1.3) * vec3(fft[5],fft[6],fft[7]),s + tmin + tgtz);\n                        normal = trisNormal(p, hs, numTris);\n                        break;\n                    }\n                }\n                if (h < (surface))\n                    break;\n            }\n        }\n\n        // step to next cell          \n        vec2 mm = step(dis.xy, dis.yx); \n        dis += mm*rda.xz;\n        pos += mm*rds;\n    }\n    return res;\n}\n\n// returns (rgb, dist)\nvec4 testPyramidFace(mat4 transform, vec3 ro, in vec3 rd, vec4 current, inout vec3 normal)\n{\n    ro = (transform*vec4(ro, 1)).xyz + vec3(0.5, -0.2, -0.288) * pyramidSize; \n    \n    rd = (transform*vec4(rd, 0)).xyz; //direction\n    vec3 rdi = 1.0 / rd;\n    vec3 rda = abs(rdi);\n\n    // intersect box\n    vec3  ce = vec3(4.4, 0.97, -3.93);\n    vec3  rb = vec3(4.69, 1., 3.98);\n    vec3  ra = rb;\n    vec3  rc = ro - ce;\n    float tN = maxcomp(-rdi*rc - rda*ra);\n    float tF = mincomp(-rdi*rc + rda*ra);\n\n    // Early out based on enclosing box to improve perf\n    if (tN > tF || tN > current.w)\n    {\n        return current;\n    }\n    \n    vec3 newNormal;\n    vec4 r = traceTiles(ro, rd, 0., current.w, newNormal);\n\n    if (r.w < current.w)\n    {\n        normal = newNormal;\n        return r;\n    }\n    else\n    {\n        return current;\n    }\n}\n\n// return (rgb, dist)\nvec4 tracePyramid(vec3 centre, vec3 ro, in vec3 rd, vec4 a, mat4 rot, inout vec3 normal)\n{\n    ro -= centre;\n    float d = length(ro);\n    float sd = dot(rd,ro);\n    \n    if ((d*d) - (sd*sd) < 38.)  // Test against an enclosing sphere\n    {\n        a = testPyramidFace(f1mat * rot, ro, rd,  a, normal);\n        a = testPyramidFace(f3mat * rot, ro, rd,  a, normal);\n        a = testPyramidFace(f2mat * rot, ro, rd,  a, normal);\n        a = testPyramidFace(f4mat * rot, ro, rd,  a, normal);\n    }\n    return a;\n}\n\n// Returns beam intensity for beam\nfloat pyramidBeamFace(mat4 transform, vec3 ro, in vec3 rd, float tmax, float widthMod)\n{\n    ro = (transform*vec4(ro, 1)).xyz; \n    rd = (transform*vec4(rd, 0)).xyz; //direction\n    \n    float distance2D = length(ro.xz);\n    float lengthToIntersection = distance2D / length(rd.xz);\n    float beamExtent = -(lengthToIntersection * rd.y + ro.y - beamStartHeight); \n    float effBeamWidth = beamWidth * widthMod;\n\n    if (beamExtent < beamWideningPoint)\n        effBeamWidth += smoothstep(0., 11.7, beamWideningPoint - beamExtent) * 4.37;\n\n    effBeamWidth = min(effBeamWidth, 5.);\n\n    if (dot(ro.xz, rd.xz) < 0.  // viewed in 2D (looking down the beam) our rd goes towards the beam\n        && beamExtent > beamEnd)\n    {\n        float distanceToCenterLine = abs(dot(normalize(vec3(-rd.z, 0, rd.x)),ro));\n        if (distanceToCenterLine < effBeamWidth && -beamExtent < 0. * pyramidSize && lengthToIntersection < tmax)\n        {\n            float d = (effBeamWidth - distanceToCenterLine) / effBeamWidth;\n            float tailOff = smoothstep(beamEnd, beamEnd + beamTailOff, beamExtent);\n            return d * d * tailOff;\n        }\n    }\n    return 0.;\n}\n\n// Returns beam intensity for a pyramid\nfloat pyramidBeam(vec3 centre, vec3 ro, in vec3 rd, in float tmax, mat4 rot, float widthMod)\n{\n    float beamIntensity = 0.;\n    ro -= centre;\n    beamIntensity += pyramidBeamFace(f1mat * rot, ro, rd, tmax, widthMod);\n    beamIntensity += pyramidBeamFace(f3mat * rot, ro, rd, tmax, widthMod);\n    beamIntensity += pyramidBeamFace(f2mat * rot, ro, rd, tmax, widthMod);\n    beamIntensity += pyramidBeamFace(f4mat * rot, ro, rd, tmax, widthMod);\n    return beamIntensity;\n}\n\n// Returns beam intensity for whole scene\nfloat traceBeams(vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    float beamIntensity = 0.;\n\n    beamIntensity += pyramidBeam(pyramid1Pos, ro, rd, tmax, rot1, 1.);\n    beamIntensity += pyramidBeam(pyramid2Pos, ro, rd, tmax, rot2, 1.);\n\n    beamIntensity += 0.4 * pyramidBeam((vec3(1., -3.5, 0)) * 300., ro, rd, tmax, rot1 * rotA, 5.);\n    beamIntensity += 0.4 * pyramidBeam((vec3(0., 2.5, -3)) * 300., ro, rd, tmax, rot1 * rotB, 5.);\n    beamIntensity += 0.4 * pyramidBeam((vec3(-1., -0.5, 3)) * 300., ro, rd, tmax, rotB * rot1, 5.);\n\n    return beamIntensity;\n}\n\n//returns (rgb,dist)\nvec4 raytrace(vec3 ro, in vec3 rd, in float tmin, in float tmax, out vec3 normal, inout float beamIntensity)\n{\n    vec3 normal_;\n    vec4 a = vec4(0, 0, 0, tmax);\n\n    a = tracePyramid(pyramid2Pos, ro, rd, a, rot2, normal_);\n    a = tracePyramid(pyramid1Pos, ro, rd, a, rot1, normal_);\n\n    beamIntensity += traceBeams(ro,rd,tmin,a.w);\n\n    normal = normal_;\n    return a;\n}\n\nvec3 light(vec3 n, vec3 ld, vec3 c)\n{\n    return max(0., dot(n, ld)) *c;\n}\n\nvec3 shade(vec3 n)\n{\n    vec3 s = vec3(0.3, 0.3, 0.4);\n    s += light(n, vec3(0.707, 0.707, 0), light1.xyz);\n    s += light(n, vec3(-0.707, 0.707, 0), light2.xyz);\n    return s;\n}\n\n// Star field\nvec3 background(vec3 rd)  \n{\n    vec3 ird = floor(rd* 300. + 300.);\n    vec2 f = hash2(vec2(11,17) + ird.x * 1.42 + ird.y + 529.38 + ird.z*12.59);\n    float v = max(0.,(f.x-0.995)*200.);\n    vec3 col = skyColor2;\n    col = mix(col, skyColor1, smoothstep(-1.6, 1.6, rd.y + ((f.x + f.y)-1.) *0.2));\n    col *= (1. - abs(rd.y)*0.4) ;\n    col += v;\n    return col;\n}\n\nvec3 bezier(vec3 c1, vec3 c2, vec3 c3, vec3 c4, float t)\n{\n    float u = 1.0 - t;\n    vec3 p = u * u * u * c1; //first term\n    p += 3. * u * u * t * c2; //second term\n    p += 3. * u * t * t * c3; //third term\n    p += t * t * t * c4; //fourth term\n    return p;\n}\nvec3 evalCameraPath(int seg, float pos) \n{\n    vec3 c1,c2,c3,c4;\n    if (seg == 0)  // Webgl doesn't support non-const array indices\n    {\n        c1 = vec3(-69.15625,-37.01953,14.89063);\n        c2 = vec3(14.695648,-3.814006,13.818855);\n        c3 = vec3(-34.1875,-17.6355,4.976563);\n        c4 = vec3(-27.82813,-8.571045,7.039063);\n    }\n    else if (seg == 1)\n    {\n        c1 = vec3(-27.82813,-8.571045,7.039063);\n        c2 = vec3(-21.46875,0.4934082,9.101562);\n        c3 = vec3(0.07781601,16.25562,11.31726);\n        c4 = vec3(7.265625,15.62646,3.328125);\n    }\n    else if (seg == 2)\n    {\n        c1 = vec3(7.265625,15.62646,3.328125);\n        c2 = vec3(14.45343,14.99731,-4.661015);\n        c3 = vec3(12.55197,5.271613,17.65821);\n        c4 = vec3(-2.833279,4.214956,7.524496);\n    }\n    else if (seg == 3)\n    {\n        c1= vec3(-2.833279,4.214956,7.524496);\n        c2 = vec3(-18.21852,3.158299,-2.609218);\n        c3 = vec3(7.624943,-10.94614,8.888105);\n        c4 = vec3(20.26089,-2.148565,3.707624);\n    }\n    else if (seg == 4)\n    {\n        c1 = vec3(20.26089,-2.148565,3.707624);\n        c2 = vec3(32.89684,6.649014,-1.472857);\n        c3 = vec3(14.2766,37.21476,-26.53634);\n        c4 = vec3(6.103022,24.72848,-31.09239);\n    }\n    else if (seg == 5)\n    {\n        c1 = vec3(6.103022,24.72848,-31.09239);\n        c2 = vec3(-2.070557,12.24219,-35.64844);\n        c3 = vec3(-28.85156,6.828128,-17.52344);\n        c4 = vec3(6.235493,-9.495728,10.07811);\n    }\n    else if (seg == 6)\n    {\n        c1 = vec3(6.235493,-9.495728,10.07811);\n        c2 = vec3(41.32255,-25.81958,37.67965);\n        c3 = vec3(30.60639,-26.02213,49.62637);\n        c4 = vec3(47.02772,-15.55794,56.22538);\n    }\n    else if (seg == 7)\n    {\n        c1 = vec3(47.02772,-15.55794,56.22538);\n        c2 = vec3(63.44905,-5.09375,62.82439);\n        c3 = vec3(68.44682,0.9838867,59.15281);\n        c4 = vec3(0.06239128,0.1552048,-0.006980419);\n    }\n    return bezier(c1, c2, c3, c4, pos);\n}\n\nvoid animate(float t)\n{\n    float tos = t / segmentDuration;\n    float segment = floor(tos);\n    float posInSegment = fract(tos);\n    float posInLoop = fract(tos/(loopLen*2.0));\n    float pathSeg = mod(segment, loopLen);\n\n    float roll = 0.;\n    float heading = 0.;\n    darkMode = 0.;\n\n    if (posInLoop > 0.5)\n    {\n        darkMode = 1.;\n        roll = darkModeRoll;\n    }\n   \n    showInnerBeams = smoothstep(0.47,0.49,posInLoop);\n    beamWidth = fft[2]*1.6 + 0.16;\n\n    float rotTime = 24. * pi * posInLoop;\n\n    rot1 = mat4(rotate_y(2.5) * rotate_x(rotTime) * rotate_y(-2.5));\n    rot2 = mat4(rotate_y(rotTime));\n    rotA = mat4(rotate_z(5.));\n    rotB = mat4(rotate_x(rotTime*0.08333333));\n\n    if (pathSeg == 0.)\n        heading = transitionHeading * (1. - smoothstep(0.2, 1., posInSegment));\n\n    ro = evalCameraPath(int(pathSeg),posInSegment);\n\n    float op = posInLoop*20.*pi+5.2;\n    vec2 orbit = vec2(sin(op), cos(op));\n    orbitPos = orbit.xxy * 3. * smoothstep(0.01,0.025,abs(0.25-mod((posInLoop+0.25),0.5)));\n    cam = rotate_y(heading) *setLookAt(ro, orbitPos, roll);\n    ro_alt = length (ro- vec3(0.06239128,0.1552048,-0.006980419)) * vec3(-0.9296872740068233, -0.36815807186055766, 0.011883041) + vec3(-69.15625,-37.01953,14.89063);\n}\n\n//returns rgb\nvec3 scene(vec2 fragCoord)\n{\n    vec3 color = vec3(0, 0, 0);\n    float beamIntensity =  0.;\n    vec2 xy0 = (fragCoord - iResolution.xy * 0.5) * 2. / iResolution.y;\n\n    float sampleScale = 1.;\n\n#ifdef ANTIALIAS  // Doing AA on these two loops separately is quicker than on the whole function\n    sampleScale = 0.25;\n    float aastep = 1./ iResolution.y;\n    for (float i = 0.; i < 1.; i+=0.5)\n        for (float j = 0.; j < 1.; j+=0.5)\n        {\n            vec2 xy = xy0 + vec2(i,j) * aastep;\n#else\n            vec2 xy = xy0 ;\n#endif\n            vec3 rd = (cam*vec3(xy , fov));\n            rd = normalize(rd);\n            vec3 normal;\n            vec4 res = raytrace(ro, rd, 0., tmax, normal, beamIntensity); \n\n            if (res.w < tmax - surface)\n            {\n                color += vec3(res.xyz  * (0.2 + 0.8 * shade(normal)));\n            }\n            else\n            {\n                color += background(rd) * (1.-darkMode);\n            }\n#ifdef ANTIALIAS\n        }\n#endif\n    color *= sampleScale; \n    beamIntensity *= sampleScale;\n    color += beamColor * beamIntensity * 2.5;\n    color = clamp(mix(color, 1.- color, darkMode),0.,1.);\n   \n    if (beamIntensity > 0.165 && showInnerBeams > 0.01)  //todo fade in this effect\n    {\n        float roll = darkModeRoll * (1.-darkMode);\n        mat3 cam = rotate_y(transitionHeading) *setLookAt(ro_alt, orbitPos, roll);\n#ifdef ANTIALIAS\n        for (float i = 0.; i < 1.; i+=0.5)\n            for (float j = 0.; j < 1.; j+=0.5)\n            {\n            vec2 xy = xy0 + vec2(i,j) * aastep;\n#else\n            vec2 xy = xy0 ;\n#endif\n            vec3 rdd = normalize(cam*vec3(xy, fov));\n            color +=  (-1. + darkMode*2.) *traceBeams(ro_alt, rdd, 0., tmax)\n                      * smoothstep(0.165,0.24, beamIntensity) *2. * showInnerBeams * sampleScale;\n            if (darkMode > 0.)\n               color += darkMode * background(rdd) * sampleScale;  \n            }\n#ifdef ANTIALIAS         \n    }\n#endif   \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    scaledTime = iTime * animSpeed + 40.18; \n     \n    // Control points for bezier camera animation\n    \n\n    // fourier transform samples from music channel\n    fft[0] = texture( iChannel0, vec2( 96 ,0 )/512. ).x;\n    fft[1] = texture( iChannel0, vec2(113,0)/512.).x * 1.4; \n    fft[2] = texture( iChannel0, vec2(133,0)/512.).x * 1.3; \n    fft[3] = texture( iChannel0, vec2(146,0)/512.).x; \n    fft[4] = texture( iChannel0, vec2(232,0)/512.).x; \n    fft[5] = texture( iChannel0, vec2(424,0)/512.).x * 1.7; \n    fft[6] = texture( iChannel0, vec2(432,0)/512.).x * 2.; \n    fft[7] = texture( iChannel0, vec2(463,0)/512.).x * 2.; \n\n    animate(scaledTime);\n\n    fragColor = vec4(scene(fragCoord), 1.) ;\n}\n", "image_inputs": [{"id": "XsfSD2", "previewfilepath": "https://soundcloud.com/therealfod/deadmau5-4ware-01-fod-remake", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/therealfod/deadmau5-4ware-01-fod-remake", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2932, 3202, 3222, 3222, 3260], [3261, 3261, 3287, 3287, 3321], [3322, 3322, 3348, 3348, 3382], [3384, 3384, 3408, 3408, 3507], [3508, 3508, 3532, 3532, 3631], [3632, 3632, 3656, 3656, 3754], [3756, 3756, 3788, 3788, 3812], [3814, 3814, 3849, 3849, 3873], [3875, 3875, 3911, 3911, 3936], [3938, 3938, 3976, 3976, 4004], [4006, 4006, 4058, 4058, 4234], [4236, 4236, 4264, 4264, 4602], [4604, 4664, 4686, 4686, 5018], [5020, 5068, 5106, 5106, 5331], [5333, 5367, 5411, 5411, 6789], [6791, 6840, 6891, 6891, 7204], [7206, 7228, 7315, 7493, 10746], [10748, 10771, 10863, 10863, 11615], [11617, 11639, 11729, 11729, 12149], [12151, 12186, 12274, 12274, 13341], [13343, 13383, 13477, 13477, 13853], [13855, 13897, 13966, 13966, 14467], [14469, 14490, 14600, 14600, 14864], [14866, 14866, 14903, 14903, 14940], [14942, 14942, 14962, 14962, 15121], [15123, 15137, 15165, 15165, 15499], [15501, 15501, 15559, 15559, 15766], [15767, 15767, 15809, 15809, 17743], [17745, 17745, 17768, 17768, 18997], [20226, 21007, 21062, 21062, 21765]]}
{"id": "4sSBW3", "name": "Glossy Cubes", "author": "Klems", "description": "Cone tracing cubes to get glossy reflection. Distance function is a bit too expensive so I can't do much, I'll try another scene.", "tags": ["3d", "raymarch", "conetracing"], "likes": 27, "viewed": 1165, "date": "1502551865", "time_retrieved": "2024-06-20T18:59:24.427826", "image_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n\nvec3 hsv( in vec3 c ) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0,4,2),6.0)-3.0)-1.0, 0.0, 1.0);\n\treturn c.z * mix(vec3(1), rgb, c.y);\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash22( in vec2 p ) {\n    #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat perlin( in float x, in float seed ) {\n    float a = floor(x);\n    float b = a + 1.0;\n    float f = x - a;\n    f = f*f*(3.0-2.0*f);\n    return mix(hash22(vec2(seed, a)).x, hash22(vec2(seed, b)).x, f);\n}\n\n// main distance function\nfloat de( in vec3 p, in float r, out vec3 color ) {\n    \n    float d = -p.z;\n    \n    vec2 center = floor(p.xy)+0.5;\n    \n    color = vec3(0);\n    float colorAcc = 0.0;\n    \n    for (int x = -1 ; x <= 1 ; x++) {\n        for (int y = -1 ; y <= 1 ; y++) {\n            \n            vec2 offset = center + vec2(x, y);\n            vec3 inCenter = p - vec3(offset, 0);\n            \n            // get random stuff for the cube\n            vec2 rnd = hash22(offset);\n            float height = 1.0 + perlin( iTime+rnd.x, rnd.y )*0.75;\n            vec3 colorHere = hsv( vec3(-offset.y*0.1 + rnd.y*0.3, 1, 1) );\n            // select the nearest cube\n            float dist = sdBox(inCenter, vec3(vec2(0.45), height))-0.05;\n            d = min(d, dist);\n            // accumulate the color\n            float alpha = max(0.001, smoothstep(r, -r, dist));\n            color += colorHere*alpha;\n            colorAcc += alpha;\n\n        }\n    }\n    \n    color /= colorAcc;\n    \n    return d;\n\n} \n\n// normal function\nvec3 normal( in vec3 p, float here ) {\n\tvec3 e = vec3(0.0, 0.001, 0.0);\n    vec3 dummy = vec3(0);\n\treturn normalize(vec3(\n\t\there-de(p-e.yxx, 0.0, dummy),\n\t\there-de(p-e.xyx, 0.0, dummy),\n\t\there-de(p-e.xxy, 0.0, dummy)));\t\n}\n\n// cone-tracing\nvec4 trace( in vec3 from, in vec3 dir, in float sinTheta ) {\n    \n    float totdist = 0.01;\n    vec4 acc = vec4(0, 0, 0, 1);\n    \n    for (int i = 0 ; i < 10 ; i++) {\n        \n        vec3 p = from + totdist * dir;\n        \n        // find color here, as well as distance\n        float r = totdist*sinTheta;\n        vec3 color = vec3(0);\n        float dist = de(p, r, color);\n        \n        // find opacity here\n        float alpha = clamp(dist / r * -0.5 + 0.5, 0.0, 1.0);\n        acc.rgb += acc.a * alpha * color;\n        acc.a *= 1.0 - alpha;\n        \n        // break early if the accumulated opacity is almost zero\n        if (acc.a < 0.01) break;\n        // otherwise continue forward\n        totdist += abs(dist);\n        \n    }\n    \n    acc.a = 1.0 - acc.a;\n    return acc;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(iTime, 0.2*iTime, -5)+vec3(iMouse.xy*0.04, 0);\n\tvec3 dir = normalize(vec3(uv, 0.5));\n    \n\tfloat totdist = 0.0;\n\t\n\tfor (int steps = 0 ; steps < 20 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n        vec3 dummy = vec3(0);\n\t\tfloat dist = de(p, 0.0, dummy);\n\t\ttotdist += dist;\n\t\tif (dist < 0.001) {\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    vec3 p = from + totdist * dir;\n    vec3 color = vec3(0);\n\tvec3 norm = normal(p, de(p, 0.01, color));\n    \n    // glossy reflection\n    vec3 refl = reflect(dir, norm);\n    vec4 gloss = trace(p, refl, 0.5);\n    gloss.rgb = mix(vec3(1), gloss.rgb, gloss.a);\n    \n    // fresnel\n    float fres = pow(max(0.0, dot(-dir, norm)), 2.0);\n    \n    fragColor.rgb = mix(color, gloss.rgb, fres);\n    fragColor.a = 1.0;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSBW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[79, 79, 102, 102, 217], [219, 219, 256, 256, 347], [349, 349, 375, 375, 548], [550, 550, 593, 593, 757], [759, 785, 836, 836, 1764], [1767, 1786, 1824, 1824, 2008], [2010, 2026, 2086, 2086, 2816], [2818, 2818, 2875, 2875, 3730]]}
{"id": "4sSfWy", "name": "Baby Talk", "author": "paulo69", "description": "2D MoGraph based on the music \"Baby Talk\" composed by David HURET (  https://soundcloud.com/user-337195955  )\n", "tags": ["2d", "music", "animation", "heart", "soundcloud"], "likes": 3, "viewed": 595, "date": "1501883007", "time_retrieved": "2024-06-20T18:59:24.973403", "image_code": "// Warning : abusive use of smileys ! \n\n/*\n\nCurrently my best shader.\n\nI haven't corrected my shader before publishing it, \nso it's not optimized and doesn't respect the art of writing shaders ! \n\nI haven't more shaders on reserve, after the time will come for me to \nreally learn to write shaders ! So your reviews are welcome... 😀\n\n*/\n\nvec3 signal (float lo, float ho, float l, vec3 col, vec2 p, float time) {\n    return  col *= abs (l/((p.y)*(800.0*cos(time))+cos(p.x*lo)*ho));\n}\n\n/*\n\nAt the beginning I wrote an article \"How to seduce with maths\" (😂) for the high school magazine (this year). \nIt describes how to draw a heart in \"GeoGebra\" with an equation that I've found. \nAfter I saw the video of Inigo Quilez dealing with this subject : his equation is x10000 better than mine !\nHis awesome tutorial : https://www.youtube.com/watch?v=aNR4n0i2ZlM    😊\n\nMine : X²+(a*Y-abs(X))²=b+c*Y*cos(atan2(d*X,Y)*e)\n\n*/\n\nfloat FonctionCoeur (float x, float y,float t, float scaleY, float scaleX) {\n    t=t*3.0;\n    return pow(x*scaleX+(cos(1.2)*.005),2.0) + pow((y* scaleY+(sin(t)*.002)- abs(x) - (abs(x) / (x-10.0))),2.0)-.2*y*cos(atan(1.0*x,y)*.6);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/ iResolution.x;  // Not correct, I know 😉\n    float sound = texture( iChannel0, vec2(uv.x,1.0)).x;\n    float taille = .02;\n    float t = iTime;\n    float x = .5;\n    if(t<11.55) {\n     \tx=.1+abs(cos(t));   \n    }\n    vec2 pos = uv-vec2(x,.2+cos(t)/50.0); \n    if (t<63.0&&t>50.0) {\n    \ttaille = .001;    \n        pos.y = uv.y-.4;\n        pos.x= uv.x+cos(t);\n    }\n    vec3 lightdirection = vec3 (uv.x*uv.y);\n    vec3 couleur = vec3 (1.0,uv.x*.5,uv.y*.5);\n    couleur+= vec3 (abs(pos.x));\n    float diffusion = 2.0;\n    float i = 5.0;\n    vec3 img = couleur*vec3(0.2,.6,0.9);\n    vec3 col = vec3(0.9,0.4,0.0);\n    if (t<75.0) {\n    \timg+= vec3 (signal (5.0,9.0*sound*sound*19.0,1.0,vec3 (2.0),vec2 (t,.15)-uv, 0.5))*col;\n    \timg+= vec3 (signal (3.0,9.0,sound,vec3 (1.5),vec2 (t,.22)-uv, 0.5))*col;\n    \timg+= vec3 (signal (10.0,18.0*sound*sound,1.0,vec3 (1.0),vec2 (t,.35)-uv, 0.5))*col;\n    \timg+= vec3 (signal (3.0,9.0,1.0,vec3 (2.5,0.0,0.0),vec2 (t,.36)-uv, 0.5))*col;\n    }\n\timg*=1.0+cos(sound)*.05;\n    img*=(.6+vec3(.49,.5,.9)*cos(sound)*.15 )*1.0;\n    img*=.8;\n    img+= vec3 (mod(floor(pos.x*t)+floor(pos.y*t),2.0))*.1;\n    vec3 col1 = img;\n    float xa = pos.x;\n    if (t<62.0&&t>50.0) {\n    \txa = mod(abs(pos.x),cos(t));\n    }\n    if (FonctionCoeur(xa,pos.y,t,1.5,1.2) < taille+abs(cos(t*7.0))*.02) {\n    \timg = couleur*lightdirection*lightdirection*diffusion*i+vec3(0.1,pos.y*.1,0.0);\n        img+=vec3(pos.x*.9,0.0,0.0)*cos(sound);\n        if(t<50.0&&t>40.0) {\n         \timg=col1;   \n        }\n        if (t<11.5) {\n         \timg=col1;   \n        }\n        if (t>75.0) {\n         \timg=col1;   \n        }\n    }\n    if (t<75.0) {\n        float azerty = 4.0; //Why this name, I don't know either 😐\n        if (t>45.0&&t<55.0) {\n         \tazerty+=cos(t)*6.0;   \n        }\n    \timg+= vec3 (signal (5.0,8.0,1.0,vec3 (0.0,azerty,1.0),vec2 (t,.28)-uv, 0.5))*col;\n    \timg+= vec3 (signal (9.0,18.0,1.0,vec3 (2.1),vec2 (t,.33)-uv, 0.5))*col;\n    }\n    img+= vec3 (signal (1.2,sound*sound*80.0,1.0,vec3 (6.0),vec2 (0.0,.05)-uv, 0.5))*col;\n    if (t>83.0) {\n    \timg*=0.0;   \n    }\n    if(t>63.0&&t<75.0) {\n     img+= vec3 (0.0,.2+sin(t)*.2,.5+cos(t)*.4);   \n    }\n\tfragColor = vec4(img*(lightdirection+.6)*clamp(t*.07,0.0,1.0),1.0);\n}", "image_inputs": [{"id": "XdXXD2", "previewfilepath": "https://soundcloud.com/user-337195955/08-baby-talk", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-337195955/08-baby-talk", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[40, 341, 414, 414, 485], [487, 927, 1003, 1003, 1161], [1163, 1163, 1220, 1220, 3484]]}
{"id": "4tfcRH", "name": "hexes!", "author": "Coolok", "description": "hexes!", "tags": ["hexes"], "likes": 0, "viewed": 81, "date": "1503311969", "time_retrieved": "2024-06-20T18:59:25.452148", "image_code": "// inspired by and copied from iq:\n// https://www.shadertoy.com/view/Xd2GR3\n\n#define TWO_PI 6.283185\n\nvec3 iq_color_palette(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b * cos(TWO_PI * (c*t + d));\n}\n\n// copied from iq\n// { 2d cell id, distance to border, distance to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\n// copied from iq\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\n// copied from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\t\n    float t = .8 * (1. - pow(uv.y, .5))*cos(iTime);\n    pos.y += -.5;\n\tpos *= 2. - 0.3*pos.y;\n    \n    vec4 h = vec4(0.);\n    float n = 0.;\n    vec3 col = vec3(0.);\n\n\th = hexagon(12.0*pos);\n    n = noise( vec3(0.3*h.xy+vec2(iTime*.7, 0.),0.) );\n    t += .2 * (1. - n);\n    \n\tcol = .5 * abs(sin( hash1(h.xy)*.4 + 1.6 + vec3(1.) ));\n\tcol *= smoothstep( 0.0+t, 0.1+t, h.z );\n\tcol *= 1. + 0.5*h.z*n;        \t\n    col *= 1. + .5 * iq_color_palette(vec3(0.5, 0.5, 0.5),\n                                 vec3(0.5, 0.5, 0.5),\n                                 vec3(2.0, 1.0, 0.0),\n                                 vec3(0.5, 0.2, 0.25),\n                                 iTime * .02);\n    col *= .7 + .3 * iq_color_palette(vec3(.5, .5, .5),\n                                      vec3(.5, .5, .5),\n                                      vec3(.3, 1., 1.),\n                                      vec3(0., .25, .25),                                      \n\t        uv.y-.8-iTime*.05);\n\tcol *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.4 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfcRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 102, 166, 166, 212], [214, 290, 315, 315, 826], [828, 846, 870, 870, 942], [944, 962, 988, 988, 1196], [1199, 1199, 1257, 1257, 2426]]}
{"id": "4tfcz7", "name": "Dance of the charges", "author": "zardoru", "description": "An electric-field inspired shader.", "tags": ["2d"], "likes": 1, "viewed": 122, "date": "1503987332", "time_retrieved": "2024-06-20T18:59:25.743174", "image_code": "float wavy(float v)\n{\n    return 0.8 * abs(cos(v)) + 0.2;\n}\n\nfloat particleEF(vec2 origin, float charge, vec2 uv)\n{\n    vec2 tmp = origin - uv;\n    float modsqr = dot(tmp, tmp);\n    return charge / modsqr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy - .5 ) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float _angle = iTime / 3.;\n    mat2 rot = mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    \n    uv = rot * uv;\n    \n    float dx = sin(iTime);\n    float ampl = 0.7;\n    // two particles\n    // part1\n    vec2 p1 = vec2(0, ampl + ampl * dx);\n    // part2\n    vec2 p2 = vec2(0, -ampl - ampl * dx);\n    // part3\n    vec2 p3 = vec2(ampl + ampl * dx, 0);\n    // part 4\n    vec2 p4 = vec2(-ampl - ampl * dx, 0);\n    \n    float cFlair = sin(iTime * 0.2) * 0.2 + 0.8;\n    // a sine for flair\n   \tfloat E1 = particleEF(p1, 1. * cFlair, uv);\n    float E2 = particleEF(p2, -1. * cFlair, uv);\n    float E3 = particleEF(p3, -1. * -cFlair, uv);\n    float E4 = particleEF(p4, 1. * -cFlair, uv);\n    \n    vec4 c1 = vec4(0.3, 0.2, 0.3, 1.);\n    vec4 c2 = vec4(0.2, 0.4, 0.5, 1.);\n    vec4 c3 = vec4(0.5, 0.1, 0.5, 1.);\n    vec4 c4 = vec4(0.1, 0.5, 0.3, 1.);\n    vec4 colorsum = abs(E1) * c1 + \n        \t\t\tabs(E2) * c2 + \n        \t\t\tabs(E3) * c3 + \n        \t\t\tabs(E4) * c4;\n    float elecField = wavy(E1 + E2 + E3 + E4);\n\tfragColor = colorsum * elecField;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfcz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 59], [61, 61, 115, 115, 207], [209, 209, 266, 266, 1442]]}
{"id": "4tfyRr", "name": "Binary Twister", "author": "Vovosunt", "description": "Saw something simlar on pinterest", "tags": ["2d"], "likes": 3, "viewed": 113, "date": "1502993489", "time_retrieved": "2024-06-20T18:59:25.924897", "image_code": "#define c30 0.86602540378\n#define grid 15.0\n#define split 5.0\n#define smooth 0.002\n#define timeScale 0.2\n#define PI      3.14159265359\n#define count 10.0\n#define curve 5.0\n#define EE 2.7182818284590\n#define cutoff 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (fragCoord.xy -0.5 * iResolution.xy)/ iResolution.y;\n    float a = (atan(st.x,st.y) + PI) /PI /2.;\n    float len = length(st) * 2.0;\n    float l = pow(8.,pow(len,1.5));\n    float l2 = pow(2.,floor(l));\n    float rt = pow(sin(iTime),2.0) * 4.;\n    float col = smoothstep(smooth, -smooth, abs(fract(a * l2 + 0.25 +rt )-0.5) * 2.0 - 0.5);\n   \tcol = mix(1.0, col,step(l,cutoff));\n\tfragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfyRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[219, 219, 276, 276, 689]]}
{"id": "4tfyzH", "name": "polar map 2", "author": "zhaxiu3", "description": " try polar map", "tags": ["basic", "polar"], "likes": 0, "viewed": 161, "date": "1503471530", "time_retrieved": "2024-06-20T18:59:25.924897", "image_code": "\n#define PI 3.141592653\nvec2 polar(vec2 uv)\n{\n    float angle = atan(uv.y,uv.x);\n    float radius = length(uv);\n    \n    return vec2(radius, angle);\n}\n\nfloat polarCircle(vec2 uv, float r, float angle, float size)\n{\n    float dist = uv.x*uv.x+r*r-2.0*uv.x*r*cos(angle-uv.y);\n    //return 0.00002/dist;\n    return smoothstep(size/iResolution.x,0.0,dist);\n    \n}\n\n\nvec2 color2(vec2 uv)\n{\n    vec2 col= vec2(0.0);\n    float r = fract(iTime)*0.4+0.1;\n    \n    for(float i = 0.0; i <2.0*PI; i+=0.1*PI)\n    {\n    col +=vec2(polarCircle(uv,r,i,0.05));\n    }\n    col.y = smoothstep(0.0,1.0,1.0-fract(iTime)*1.2);\n    col.x *= col.y;\n    return col;\n}\n\nvec2 color3(vec2 uv, float angle, float dir, float start)\n{\n    vec2 col = vec2(0.0);\n    float r =0.04;\n    vec2 offset = vec2(0.5*dir*pow((fract(iTime)-0.2)*2.0,3.0),0.0);\n    \n    vec2 pos = vec2(uv.x*cos(uv.y),uv.x*sin(uv.y));\n    vec2 diff = pos+(offset);\n    vec2 polardiff = polar(diff);\n    \n    for(float i = start*2.0; i <6.0; i+=2.0)\n    {\n        col += vec2(polarCircle(polardiff,r*i,angle,0.8));\n    }\n    col.y = smoothstep(0.0,0.3,pow(1.0-fract(iTime),2.0));\n    col.x *= col.y;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = polar((2.0*fragCoord.xy - iResolution.xy)/mx);    \n    \n    fragColor.y=1.0;\n    \n    vec2 col= color2(uv);\n    col += color3(uv,0.25*PI,1.0,0.0);\n    col += color3(uv,-0.25*PI,1.0,1.0);\n    col += color3(uv,1.25*PI,-1.0,0.0);\n    col += color3(uv,PI-0.25*PI,-1.0,1.0);\n    col.x = smoothstep(0.0,1.0,col.x);\n\tfragColor = vec4(col.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfyzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 24, 45, 45, 150], [152, 152, 214, 214, 359], [362, 362, 384, 384, 641], [643, 643, 702, 702, 1155], [1157, 1157, 1214, 1214, 1615]]}
{"id": "4tGGzd", "name": "Sampling Spherical Triangle", "author": "koiava", "description": "Sampling spherical triangle.\n\nStratified Sampling of Spherical Triangles.\nJames Arvo. 1995", "tags": ["triangle", "sampling", "montecarlo"], "likes": 16, "viewed": 1925, "date": "1503662583", "time_retrieved": "2024-06-20T18:59:30.361592", "image_code": "#define PIXEL_SAMPLES \t\t2\t\t\t//Increase for higher quality\n#define LIGHT_SAMPLES\t\t2\t\t\t//Increase for higher quality\n\n#define GAMMA \t\t\t\t2.2\t\t\t//\n#define SHADOWS\n#define LIGHT_CLIPPING\n#define STRATIFIED_SAMPLING\nconst vec3 backgroundColor = vec3( 0.0 );\n\n#define SAMPLE_TOTAL_AREA\t\t\t0\n#define SAMPLE_SPHERICAL_TRIANGLE\t1\n#define SAMPLE_NONE\t\t\t\t\t2\nint samplingTechnique;\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n// random number generator **********\n// from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_TRIANGLE\t4\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n};\n    \n// ************ SCENE ***************\nObject objects[7];\nCamera camera;\n//***********************************\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//radius\n    obj.params_[1] = minY;\t\t\t//min z\n    obj.params_[2] = maxX;\t\t\t//max z\n    obj.params_[3] = maxY;\t\t\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createTriangle(mat4 transform, vec2 v1, vec2 v2, vec2 v3, int mtl, out Object obj) {\n    obj.type_ = OBJ_TRIANGLE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = v1.x;\t\t\t\n    obj.params_[1] = v1.y;\t\t\t\n    obj.params_[2] = v2.x;\t\t\t\n    obj.params_[3] = v2.y;\t\t\t\n    obj.params_[4] = v3.x;\t\t\n    obj.params_[5] = v3.y;\t\t\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\nvoid initScene() {\n    float time = iTime;\n    \n    //init lights\n    float r = 0.1;\n    \n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = 0.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -1.8+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 3.0, z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n    vec2 v1 = vec2(-2.0, -2.0);\n    vec2 v2 = vec2(0.0, 2.0);\n    vec2 v3 = vec2(2.0, -2.0);\n    createTriangle(trans, v1, v2, v3, MTL_LIGHT, objects[0]);\n    //createCylinder(trans, 0.1, 0.0, 7.0, TWO_PI, MTL_LIGHT, objects[0]);\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 2.5, 0.0, -2.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( -1.0, 0.0, -5.0, 1.0 ));\n\n    createSphere(trans, 1.0, MTL_DIFFUSE, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), MTL_DIFFUSE, objects[6]);\n}\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool rayIntersectsTriangle(in Ray ray, vec3 v0, vec3 v1, vec3 v2, in bool forShadowTest, out float t, out SurfaceHitInfo isect){\n    vec3 p = ray.origin;\n    vec3 d = ray.dir;\n    \n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn false;\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tif (u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\t//uv = vec2(u, v);\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n        isect.uv_.x = isect.position_.x;\n        isect.uv_.y = isect.position_.y;\n    }\n\t\n\tif (t > 0.00001) // ray intersection\n\t\treturn true;\n    \n\t// this means that there is a line intersection\n\t// but not a ray intersection\n\treturn false;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_TRIANGLE ) {\n        vec3 v1 = vec3(obj.params_[0], obj.params_[1], 0.0);\n        vec3 v2 = vec3(obj.params_[2], obj.params_[3], 0.0);\n        vec3 v3 = vec3(obj.params_[4], obj.params_[5], 0.0);\n        hitResult = rayIntersectsTriangle(rayLocal, v1, v2, v3, forShadowTest, t, currentHit);\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    CHECK_OBJ( objects[0] );\n    if(!forShadowTest) {\t//Hack optimization for shadow rays\n        CHECK_OBJ( objects[1] );\n        CHECK_OBJ( objects[2] );\n        CHECK_OBJ( objects[3] );\n    }\n    CHECK_OBJ( objects[4] );\n    CHECK_OBJ( objects[5] );\n    CHECK_OBJ( objects[6] );\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n \n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformPointWitinTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in float Xi1, in float Xi2 ) {\n    Xi1 = sqrt(Xi1);\n    return (1.0-Xi1)*v1 + Xi1*(1.0-Xi2)*v2 + Xi1*Xi2*v3;\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( sin(iTime*0.154)*2.0, 2.0 + sin(iTime*0.3)*2.0, cameraZ + sin(iTime*0.8) );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( sin(iTime*0.4)*0.3, 1.0, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\treturn ray;\n}\n\nbool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { \n    // assuming vectors are all normalized\n    float denom = dot(plane_n, ray_d); \n    if (abs(denom) > 1e-7) { \n        vec3 vec = plane_p - ray_o; \n        t = dot(vec, plane_n) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec2 angular_to_cartesian(float phi) {\n    return vec2(cos(phi), sin(phi));\n}\n\nfloat cartesian_to_angular(vec2 w) {\n\treturn atan(float(-w.y), float(-w.x)) + PI;\n}\n\n//Gram-Schmidt method\nvec3 orthogonalize(in vec3 a, in vec3 b) {\n    //we assume that a is normalized\n\treturn normalize(b - dot(a,b)*a);\n}\n\nvec3 slerp(vec3 start, vec3 end, float percent)\n{\n\t// Dot product - the cosine of the angle between 2 vectors.\n\tfloat cosTheta = dot(start, end);\n\t// Clamp it to be in the range of Acos()\n\t// This may be unnecessary, but floating point\n\t// precision can be a fickle mistress.\n\tcosTheta = clamp(cosTheta, -1.0, 1.0);\n\t// Acos(dot) returns the angle between start and end,\n\t// And multiplying that by percent returns the angle between\n\t// start and the final result.\n\tfloat theta = acos(cosTheta)*percent;\n\tvec3 RelativeVec = normalize(end - start*cosTheta);\n     // Orthonormal basis\n\t\t\t\t\t\t\t\t // The final result.\n\treturn ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - ‎1995\n// * Stratified sampling of 2d manifolds. J Arvo - ‎2001\nvoid sampleSphericalTriangle(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n\t//calculate internal angles of spherical triangle: alpha, beta and gamma\n\tvec3 BA = orthogonalize(A, B-A);\n\tvec3 CA = orthogonalize(A, C-A);\n\tvec3 AB = orthogonalize(B, A-B);\n\tvec3 CB = orthogonalize(B, C-B);\n\tvec3 BC = orthogonalize(C, B-C);\n\tvec3 AC = orthogonalize(C, A-C);\n\tfloat alpha = acos(clamp(dot(BA, CA), -1.0, 1.0));\n\tfloat beta = acos(clamp(dot(AB, CB), -1.0, 1.0));\n\tfloat gamma = acos(clamp(dot(BC, AC), -1.0, 1.0));\n\n\t//calculate arc lengths for edges of spherical triangle\n\tfloat a = acos(clamp(dot(B, C), -1.0, 1.0));\n\tfloat b = acos(clamp(dot(C, A), -1.0, 1.0));\n\tfloat c = acos(clamp(dot(A, B), -1.0, 1.0));\n\n\tfloat area = alpha + beta + gamma - PI;\n\n\t//Use one random variable to select the new area.\n\tfloat area_S = Xi1*area;\n\n\t//Save the sine and cosine of the angle delta\n\tfloat p = sin(area_S - alpha);\n\tfloat q = cos(area_S - alpha);\n\n\t// Compute the pair(u; v) that determines sin(beta_s) and cos(beta_s)\n\tfloat u = q - cos(alpha);\n\tfloat v = p + sin(alpha)*cos(c);\n\n\t//Compute the s coordinate as normalized arc length from A to C_s.\n\tfloat s = (1.0 / b)*acos(clamp(((v*q - u*p)*cos(alpha) - v) / ((v*p + u*q)*sin(alpha)), -1.0, 1.0));\n\n\t//Compute the third vertex of the sub - triangle.\n\tvec3 C_s = slerp(A, C, s);\n\n\t//Compute the t coordinate using C_s and Xi2\n\tfloat t = acos(1.0 - Xi2*(1.0 - dot(C_s, B))) / acos(dot(C_s, B));\n\n\t//Construct the corresponding point on the sphere.\n\tvec3 P = slerp(B, C_s, t);\n\n\tw = P;\n\twPdf = 1.0 / area;\n}\n\nvoid sampleDirectLight( vec3 pos,\n                       \tvec3 normal,\n                        float Xi1,\n                        float Xi2, \n                       \tout vec3 dir,\n                       \tout float pdf ) {\n    float height = objects[0].params_[2] - objects[0].params_[1];\n    float r = objects[0].params_[0];\n    float pdfA;\n    float d2;\n    float aCosThere;\n    float theta;\n    float thetaPdf;\n    float h;\n    float hPdf;\n    \n    //convert position to object space\n    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );\n    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );\n    \n    vec3 v1 = vec3(objects[0].params_[0], objects[0].params_[1], 0.0);\n    vec3 v2 = vec3(objects[0].params_[2], objects[0].params_[3], 0.0);\n    vec3 v3 = vec3(objects[0].params_[4], objects[0].params_[5], 0.0);\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    if(samplingTechnique == SAMPLE_TOTAL_AREA){\n        vec3 p = uniformPointWitinTriangle( v1, v2, v3, Xi1, Xi2 );\n        float triangleArea = length(cross(v1-v2,v3-v2)) * 0.5;\n        pdfA = 1.0/triangleArea;\n        \n        dir = p - pos;\n        d2 = dot(dir,dir);\n        dir /= sqrt(d2);\n        aCosThere = max(0.0,dot(-dir,n));\n        pdf = PdfAtoW( pdfA, d2, aCosThere );\n    } else {\n        vec3 A = normalize(v1 - pos);\n        vec3 B = normalize(v2 - pos);\n        vec3 C = normalize(v3 - pos);\n        sampleSphericalTriangle(A, B, C, Xi1, Xi2, dir, pdf);\n        if(dot(-dir,n) < 0.0){\n            pdf = 0.0;\n        }\n    }\n    \n    //convert dir to world space\n    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 L = vec3(4.0);\n    vec3 Lo = vec3( 0.0 );\n    \n    vec3 Wo = ray.dir*(-1.0);\n    SurfaceHitInfo hit;\n    float dist = 1000.0;\n\n    if( raySceneIntersection( ray, 0.0, false, hit, dist ) ) {\n        if( hit.material_id_ == MTL_LIGHT ) {\n            Lo = (dot(hit.normal_, Wo) > 0.0)? L : vec3(0.0, 0.0, 0.0);\n        } else {\n            for(int i=0; i<LIGHT_SAMPLES; i++){\n                vec3 Wi;\n                float pdfWi;\n                vec3 n = hit.normal_ * ((dot(hit.normal_, Wo) > 0.0 )? 1.0 : -1.0);\n                \n            \tfloat Xi1 = rnd();\n            \tfloat Xi2 = rnd();\n#ifdef STRATIFIED_SAMPLING\n                float strataSize = 1.0 / float(LIGHT_SAMPLES);\n                Xi2 = strataSize * (float(i) + Xi2);\n#endif\n                \n                sampleDirectLight( hit.position_, n, Xi1, Xi2, Wi, pdfWi );\n                float dotNWi = dot( Wi, n );\n\n                if ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n                    bool visible = true;\n#ifdef SHADOWS\n                    Ray shadowRay = Ray( hit.position_ + n*EPSILON, Wi );\n                    if ( !isLightVisible( shadowRay ) ) {\n                        visible = false;\n                    }\n#endif\n                    if(visible) {\n                        float brdf_pdf;\n\n                        vec3 brdf = vec3(1.0/PI);//max(0.0, dot(Wi, hit.normal_))*vec3(1.0);//Material_Evaluate( hit, Wo, Wi );\n\t\t\t\t\t\tvec3 Li = L/pdfWi;\n                        Lo += (brdf*Li*abs(dotNWi));\n                    }\n                }\n            }\n            Lo *= 1.0/float(LIGHT_SAMPLES);\n            \n        }\n    }\n        \n    return Lo;\n}\n\nvoid initSamplingTechnique(float p) {\n    float split = iMouse.x;\n    split = (split == 0.0)? iResolution.x * 0.5 : split;\n    float k = iMouse.x/iResolution.x;\n    float split1 = iMouse.x*k;\n    float split2 = iMouse.x + (iResolution.x-iMouse.x)*k;\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLE_TOTAL_AREA;\n    } else if(p > split+1.0){\n        samplingTechnique = SAMPLE_SPHERICAL_TRIANGLE;\n    } else {\n        samplingTechnique = SAMPLE_NONE;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    initSamplingTechnique(fragCoord.x);\n\n    if(samplingTechnique == SAMPLE_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        float fov = radians(45.0);\n        initCamera( vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 0.0, 0.0 ),\n                    vec3( 0.0, 1.0, 0.0 ),\n                    fov\n                    );\n\n        initScene();\n\n        vec3 accumulatedColor = vec3( 0.0 );\n        float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n        float strataSize = oneOverSPP;\n        Ray ray;\n\n        for( int si=0; si<PIXEL_SAMPLES; ++si ){\n            updateCamera( si );\n\n            vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n            ray = genRay( screenCoord, rnd(), rnd() );\n\n            if( length( ray.dir ) < 0.2 ) {\n                accumulatedColor = vec3( 0.0 );\n            } else {\n                accumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n            }\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*oneOverSPP;\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[764, 855, 868, 868, 911], [951, 1069, 1129, 1129, 1222], [1224, 1275, 1335, 1335, 1475], [1476, 1552, 1575, 1575, 1665], [1667, 1667, 1794, 1794, 1902], [1904, 1904, 2074, 2074, 2205], [2207, 2207, 2238, 2238, 2389], [2391, 2430, 2461, 2461, 2847], [3456, 3494, 3585, 3585, 4021], [4023, 4023, 4130, 4130, 4497], [4499, 4499, 4588, 4588, 4909], [4911, 4911, 4980, 4980, 5347], [5349, 5349, 5460, 5460, 5827], [5829, 5829, 5868, 5868, 6061], [6063, 6063, 6081, 6081, 8410], [8412, 8491, 8567, 8567, 8857], [8859, 8859, 9033, 9033, 11436], [11438, 11438, 11566, 11566, 12498], [12500, 12500, 12628, 12628, 13510], [13513, 13513, 13682, 13682, 14307], [14309, 14309, 14477, 14477, 15755], [15757, 15757, 15910, 15910, 17772], [18018, 18018, 18147, 18147, 18495], [18578, 18660, 18738, 18738, 18846], [18848, 18848, 18946, 18946, 19026], [19028, 19028, 19118, 19118, 19268], [19270, 19270, 19325, 19325, 19579], [19581, 19581, 19656, 19656, 19799], [19801, 19801, 19877, 19877, 19996], [19998, 19998, 20050, 20050, 20178], [20180, 20252, 20397, 20397, 20651], [20653, 20653, 20686, 20686, 21293], [21295, 21295, 21352, 21352, 21602], [21604, 21604, 21690, 21734, 21939], [21941, 21941, 21979, 21979, 22018], [22020, 22020, 22056, 22056, 22103], [22105, 22127, 22169, 22206, 22243], [22245, 22245, 22294, 22355, 22916], [22918, 23171, 23290, 23364, 24762], [24764, 24764, 24985, 24985, 26376], [26378, 26378, 26416, 26416, 26598], [26601, 26601, 26640, 26640, 28283], [28285, 28285, 28322, 28322, 28757], [28759, 28759, 28816, 28816, 30141]]}
{"id": "4tlcz7", "name": "Train Builder", "author": "dr2", "description": "Assemble your toy train, watch it run day and night, then put it away (based on \"Toy Train\", mouse enabled)", "tags": ["raymarching", "modeling", "font", "train"], "likes": 13, "viewed": 600, "date": "1504116007", "time_retrieved": "2024-06-20T18:59:34.543841", "image_code": "// \"Train Builder\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txFnt iChannel0\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nint GetTxChar (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\n\nmat3 trainMat[3], trMat;\nvec3 trainPos[3], trPos, qHit, qtTxt, ltDir;\nvec2 fntSize, qnFnt, qnTxt;\nfloat tCur, dstFar, tRun, tPlay, tBuild, trVel, trkRad, trkLin, trkWid, gHt, azRot, rngBlk;\nint idObj, idTxt;\nbool showObj[8], onTxt, onTrk, sigStop, isShad, isDark;\nconst float pi = 3.14159;\n\n#define ID_Eng    1\n#define ID_Cabin  2\n#define ID_Coal   3\n#define ID_Base   4\n#define ID_Band   4\n#define ID_Axle   4\n#define ID_Car    5\n#define ID_Roof   6\n#define ID_Wheel  7\n#define ID_Spoke  7\n#define ID_Crod   8\n#define ID_Funl   9\n#define ID_Funt   10\n#define ID_Stripe 10\n#define ID_Lamp   11\n#define ID_Rail   12\n#define ID_Tie    13\n#define ID_Plat   14\n#define ID_Sig    15\n#define ID_SigV   16\n#define ID_Cpl    17\n#define ID_Tun    18\n#define ID_Grnd   19\n#define ID_Tree   20\n#define ID_Trunk  21\n\n#define SH_Engn  0\n#define SH_Cars  1\n#define SH_TrkCv 2\n#define SH_TrkSt 3\n#define SH_Plat  4\n#define SH_Sig   5\n#define SH_Tun   6\n#define SH_Tree  7\n\nfloat EngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, aw, sx;\n  wRad = 0.8;\n  q = p - vec3 (0., -0.2, 0.5);\n  d = max (PrCapsDf (q, 1., 2.), - (q.z + 1.7));\n  if (d < dMin) { dMin = d;  idObj = ID_Eng; }\n  q = p;  q.z = abs (q.z - 0.85);  q -= vec3 (0., -0.2, 1.8);\n  d = PrCylDf (q, 1.05, 0.05);\n  if (d < dMin) { dMin = d;  idObj = ID_Band; }\n  q = p - vec3 (0., -1.3, -0.25);\n  d = PrBoxDf (q, vec3 (1., 0.1, 3.2));\n  if (d < dMin) { dMin = d;  idObj = ID_Base; }\n  q = p - vec3 (0., -1.4, 3.);\n  d = PrBoxDf (q, vec3 (1.1, 0.2, 0.07));\n  if (d < dMin) { dMin = d;  idObj = ID_Base; }\n  q.x = abs (q.x);  q -= vec3 (0.6, 0., 0.1);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dMin) { dMin = d;  idObj = ID_Roof; }\n  q = p - vec3 (0., 0.01, -1.75);\n  d = max (max (PrBoxDf (q, vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -0.2), vec3 (0.95, 1.3, 0.65))),\n     - PrBoxDf (q - vec3 (0., 0.7, 0.), vec3 (1.1, 0.4, 0.5)));\n  q.x = abs (q.x);  q -= vec3 (0.4, 1., 0.4);\n  d = max (d, - PrBoxDf (q, vec3 (0.35, 0.15, 0.3)));\n  if (d < dMin) { dMin = d;  idObj = ID_Cabin;  qHit = q; }\n  q = p - vec3 (0., -2.4, -1.75);\n  d = max (PrCylDf (q, 4., 0.65), - (q.y - 3.75));\n  if (d < dMin) { dMin = d;  idObj = ID_Roof; }\n  q = p - vec3 (0., -0.5, -3.15);\n  d = PrBoxDf (q, vec3 (1., 0.7, 0.3));\n  if (d < dMin) { dMin = d;  idObj = ID_Coal;  qHit = q; }\n  q = p - vec3 (0., -1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dMin) { dMin = d;  idObj = ID_Cpl; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (trkWid - 0.12, -1.4, 1.1);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  if (d < dMin) { dMin = d;  idObj = ID_Wheel; }\n  if (! isShad) {\n    q = p;  q.x = abs (q.x);  q -= vec3 (trkWid - 0.17, -1.4, 1.1 * sign (q.z));\n    aw = - (trVel / wRad) * tRun;\n    q.yz = Rot2D (q.yz, aw);  \n    q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. /\n       (2. * pi) + 0.5) / 8.);\n    q.z += 0.5 * wRad;\n    d = PrCylDf (q, 0.05, 0.5 * wRad);\n    if (d < dMin) { dMin = d;  idObj = ID_Spoke; }\n    q = p;\n    sx = sign (q.x);\n    q.x = abs (q.x);  q -= vec3 (trkWid + 0.08, -1.4, 0.);\n    aw -= 0.5 * pi * sx; \n    q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n    d = PrCylDf (q, 0.04, 1.2);\n    if (d < dMin) { dMin = d;  idObj = ID_Crod; }\n    q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n    d = PrCylDf (q.zyx, 0.06, 0.15);\n    if (d < dMin) { dMin = d;  idObj = ID_Crod; }\n    q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n    d = PrCylDf (q.zyx, 0.1, trkWid - 0.1);\n    if (d < dMin) { dMin = d;  idObj = ID_Axle; }\n    q = p - vec3 (0., 1.1, 2.15);\n    d = PrCylDf (q.xzy, 0.3, 0.5);\n  }\n  if (d < dMin) { dMin = d;  idObj = ID_Funl; }\n  q = p - vec3 (0., 1.5, 2.15);\n  d = max (PrCylDf (q.xzy, 0.4, 0.15), - PrCylDf (q.xzy, 0.3, 0.2));\n  if (d < dMin) { dMin = d;  idObj = ID_Funt; }\n  q = p - vec3 (0., 0.8, 0.55);\n  d = PrCapsDf (q.xzy, 0.3, 0.2);\n  if (d < dMin) { dMin = d;  idObj = ID_Funt; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, 0.85);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 1.8));\n  if (d < dMin) { dMin = d;  idObj = ID_Stripe; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -1.75);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 0.6));\n  if (d < dMin) { dMin = d;  idObj = ID_Stripe; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1., -0.2, -3.15);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 0.3));\n  if (d < dMin) { dMin = d;  idObj = ID_Stripe; }\n  q = p - vec3 (0., -0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dMin) { dMin = d;  idObj = ID_Lamp; }\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d;\n  wRad = 0.35;\n  q = p;\n  d = max (max (PrBoxDf (q, vec3 (1.3, 1.4, 2.8)),\n     - PrBoxDf (q, vec3 (1.2, 1.3, 2.7))), - PrBoxDf (q, vec3 (0.5, 1., 2.9)));\n  q.z = abs (q.z);  q -= vec3 (0., 0.6, 1.2);\n  d = max (d, - PrBoxDf (q, vec3 (1.4, 0.7, 1.1)));\n  if (d < dMin) { dMin = d;  idObj = ID_Car; qHit = q; }\n  q = p;  q.y -= -2.35;\n  d = max (PrCylDf (q, 4., 2.8), - (q.y - 3.75));\n  if (d < dMin) { dMin = d;  idObj = ID_Roof; }\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -0.2, 2.75);\n  d = PrCylDf (q.zyx, 0.05, 0.5);\n  if (d < dMin) { dMin = d;  idObj = ID_Roof;  qHit = q; }\n  q = p;  q.y -= -1.6;\n  d = PrBoxDf (q, vec3 (0.8, 0.3, 2.));\n  if (d < dMin) { dMin = d;  idObj = ID_Base; }\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dMin) { dMin = d;  idObj = ID_Cpl; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (trkWid - 0.12, -1.85, 1.1);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  if (d < dMin) { dMin = d;  idObj = ID_Wheel; }\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.85, 1.1);\n  d = PrCylDf (q.zyx, 0.1, trkWid - 0.15);\n  if (d < dMin) { dMin = d;  idObj = ID_Axle; }\n  q = p;  q.x = abs (q.x);  q -= vec3 (1.3, -0.2, 0.);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 2.8));\n  if (d < dMin) { dMin = d;  idObj = ID_Stripe; }\n  return dMin;\n}\n\nfloat TrackDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dbs, dbc, nt, gap;\n  q = p;\n  if (onTrk) {\n    if (! showObj[SH_TrkSt]) dbs = PrBox2Df (q.xz, vec2 (trkRad + 1.4 * trkWid, 0.6 * trkLin));\n    if (! showObj[SH_TrkCv]) dbc = PrBox2Df (vec2 (q.x, abs (q.z) - 0.6 * trkLin - 0.5 * trkRad - trkWid),\n       vec2 (trkRad + 1.4 * trkWid, 0.5 * trkRad + 1.4 * trkWid));\n    q.z -= 0.5 * trkLin * clamp (p.z / (0.5 * trkLin), -1., 1.);\n    q.x = abs (length (q.xz) - trkRad);\n    q -= vec3 (trkWid - 0.03, - gHt + 0.45, 0.);\n    d = length (max (abs (q.xy) - vec2 (0.07, 0.13), 0.));\n    if (! showObj[SH_TrkSt]) d = max (d, - dbs);\n    if (! showObj[SH_TrkCv]) d = max (d, - dbc);\n  } else {\n    q.x = abs (q.x);  q -= vec3 (trkWid - 0.03, - gHt + 0.45, 0.);\n    d = max (length (max (abs (q.xy) - vec2 (0.07, 0.13), 0.)),\n       abs (q.z) - 0.5 * trkLin);\n  }\n  if (d < dMin) { dMin = d;  idObj = ID_Rail; }\n  q = p;\n  if (onTrk) q.x = abs (q.x) - trkRad;\n  q -= vec3 (0., - gHt + 0.2, 0.);\n  nt = 2.;\n  gap = trkLin / nt;\n  q.z = mod (q.z + 0.5 * gap, gap) - 0.5 * gap;\n  d = PrBoxDf (q, vec3 (trkWid + 0.5, 0.2, 0.4));\n  q = p;  q.y -= - gHt + 0.2;\n  d = max (d, PrBoxDf (q, vec3 (trkRad + 3., 2., 0.5 * trkLin + 2.)));\n  if (onTrk) {\n    if (! showObj[SH_TrkSt]) d = max (d, - dbs);\n  }\n  if (d < dMin) { dMin = d;  idObj = ID_Tie; }\n  if (onTrk) {\n    q = p;  q.x = abs (q.x);  q -= vec3 (0., - gHt + 0.2, 0.5 * trkLin * sign (q.z));\n    nt = 12.;\n    q.xz = Rot2D (q.xz, 2. * pi * floor ((atan (q.x, q.z) + pi) *\n       nt / (2. * pi) + 0.5) / nt);\n    q.z -= - trkRad;\n    d = PrBoxDf (q, vec3 (0.4, 0.2, trkWid + 0.5));\n    q = p;  q.y -= - gHt + 0.2;\n    d = max (d, - PrBoxDf (q, vec3 (trkRad + 3., 2., 0.5 * trkLin + 2.)));\n    if (! showObj[SH_TrkCv]) d = max (d, - dbc);\n    if (d < dMin) { dMin = d;  idObj = ID_Tie; }\n    if (showObj[SH_Plat]) {\n      q = p - vec3 (trkRad - trkWid - 2., - gHt + 0.6, 0.);\n      d = 0.8 * max (PrBoxDf (q, vec3 (trkWid, 0.4, 14.)), 0.5 * (abs (q.z) - 8.) + q.y);\n      q -= vec3 (-1.2, 1.9, 0.);\n      d = min (d, PrBoxDf (q, vec3 (0.2, 1.8, 5.)));\n      q.z = abs (q.z) - 2.4;\n      d = max (d,  - PrBoxDf (q, vec3 (0.3, 1.3, 1.7)));\n      if (d < dMin) { dMin = d;  idObj = ID_Plat;  qHit = q; }\n    }\n    if (showObj[SH_Sig]) {\n      q = p - vec3 (trkRad - trkWid - 2.5, 0.8, 6.);\n      d = PrCylDf (q.xzy, 0.15, 3.);\n      if (d < dMin) { dMin = d;  idObj = ID_SigV; }\n      q.y -= 3.;\n      d = PrSphDf (q, 0.35);\n      if (d < dMin) { dMin = d;  idObj = ID_Sig; } \n    }\n    if (showObj[SH_Tun]) {\n      q = p - vec3 (0., - gHt, trkRad + 0.5 * trkLin - 0.5 * trkWid);\n      d = max (PrCylAnDf (q.yzx, 5.5, 0.2, 6.), - q.y);\n      if (d < dMin) { dMin = d;  idObj = ID_Tun;  qHit = q; } \n    }\n    q = p;  q.y -= - gHt;\n    d = PrBoxDf (q, vec3 (trkRad + trkWid + 4., 0.1,\n       trkRad + 0.5 * trkLin + trkWid + 4.));\n    if (d < dMin) { dMin = d;  idObj = ID_Grnd;  qHit = q; } \n    if (showObj[SH_Tree]) {\n      q = p;  q.xz = abs (q.xz) - vec2 (0.4 * trkRad, 0.7 * trkLin);  q.y -= - gHt + 3.;\n      d = PrCylDf (q.xzy, 0.3, 3.);\n      if (d < dMin) { dMin = d;  idObj = ID_Trunk;  qHit = q; } \n      q.y -= 2.5;\n      d = SmoothMin (PrSphDf (q, 1.5), PrSphDf (q - vec3 (0., 1.4, 0.), 1.2), 0.5);\n      if (d < dMin) { dMin = d;  idObj = ID_Tree;  qHit = q; } \n    }\n  }\n  return dMin;\n}\n\nvoid TrainCarPM (float s)\n{\n  float a, ca, sa;\n  if (onTrk) {\n    s = mod (s, 2. * (pi * trkRad + trkLin));\n    if (s < trkLin) {\n      trPos = vec3 (trkRad, 0., s - 0.5 * trkLin);\n      ca = 1.;  sa = 0.;\n    } else if (s < trkLin + pi * trkRad) {\n      a = (s - trkLin) / trkRad;\n      ca = cos (a);  sa = sin (a);\n      trPos = vec3 (trkRad * ca, 0., 0.5 * trkLin + trkRad * sa);\n    } else if (s < 2. * trkLin + pi * trkRad) {\n      trPos = vec3 (- trkRad, 0., 1.5 * trkLin + pi * trkRad - s);\n      ca = -1.;  sa = 0.;\n    } else {\n      a = (s - (pi * trkRad + 2. * trkLin)) / trkRad + pi;\n      ca = cos (a);  sa = sin (a);\n      trPos = vec3 (trkRad * ca, 0., - 0.5 * trkLin + trkRad * sa);\n    }\n  } else {\n    trPos = vec3 (0., 0., 0.3 * trkLin + s);\n    ca = 1.;  sa = 0.;\n  }\n  trMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < 3; k ++) {\n    if (k == 0 && showObj[SH_Engn] || k > 0 && showObj[SH_Cars]) {\n      q = p - trainPos[k];\n      d = PrCylDf (q.xzy, 4., 2.);\n      dMin = (isShad || d < 0.2) ? ((k == 0) ? EngDf (trainMat[k] * q, dMin) :\n         CarDf (trainMat[k] * q, dMin)) : min (dMin, d);\n    }\n  }\n  dMin = TrackDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy),\n     ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.3;\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return sh;\n}\n\nvec3 BrickSurfCol (vec2 p) \n{\n  vec2 q = p * (1. / 20.);\n  vec2 i = floor (q);\n  if (2. * floor (i.y / 2.) != i.y) {\n    q.x += 0.5;\n    i = floor (q);\n  }\n  q = smoothstep (0.02, 0.04, abs (fract (q + 0.5) - 0.5));\n  return (1. + Noisefv2 (10. * p)) * (0.5 + 0.5 * q.x * q.y) *\n     (0.3 + 0.2 * sin (2. * Hashfv2 (i) + vec3 (1., 1.2, 1.4)));\n}\n\nvec3 BrickCol (vec3 p, vec3 n)\n{\n  n = abs (n);\n  p *= 60.;\n  return BrickSurfCol (p.zy) * n.x + BrickSurfCol (p.xz) * n.y +\n     BrickSurfCol (p.xy) * n.z;\n}\n\nvec4 ObjCol (vec3 n)\n{\n  const vec4 cLo = vec4 (0.4, 0.2, 0.1, 0.3), cHi = vec4 (0., 0.8, 0., 0.5),\n     cBlk = vec4 (vec3 (0.01), 0.1), cCab = vec4 (0.2, 0.2, 0.8, 0.5),\n     cRf = vec4 (0.8, 0.1, 0.1, 0.5);\n  vec4 col4;\n  if (idObj == ID_Grnd) col4 =\n     vec4 (0., 0.2, 0., 0.) + 0.03 * Noisefv2 (10. * qHit.xz);\n  else if (idObj == ID_Tun) col4 = vec4 (0.4, 0.3, 0.2, 0.03) *\n     (1. - 0.4 * Noisefv2 (vec2 (500. * (1. + atan (qHit.y, qHit.z) / pi), 25. * qHit.x)));\n  else if (idObj == ID_Eng) col4 = cHi;\n  else if (idObj == ID_Cabin) col4 = (qHit.y > -1.3) ? cCab : cLo;\n  else if (idObj == ID_Coal)\n     col4 = (qHit.y > 0.3) ? ((n.y > 0.9) ? cBlk : cCab) : cLo;\n  else if (idObj == ID_Base || idObj == ID_Band || idObj == ID_Axle)\n     col4 = vec4 (0.3, 0.2, 0.2, 0.3);\n  else if (idObj == ID_Car) col4 = (qHit.y > -0.8) ? cHi : cLo;\n  else if (idObj == ID_Roof) col4 = cRf;\n  else if (idObj == ID_Wheel || idObj == ID_Spoke) col4 = vec4 (0.5, 0.5, 0.6, 1.);\n  else if (idObj == ID_Crod) col4 = vec4 (0.7, 0.7, 0.1, 1.);\n  else if (idObj == ID_Funl) col4 = (n.y > 0.9) ? cBlk : cRf;\n  else if (idObj == ID_Stripe || idObj == ID_Funt) col4 = vec4 (1., 1., 0., 0.5);\n  else if (idObj == ID_Lamp)\n     col4 = (isDark || mod (tCur, 2.) < 1.) ? vec4 (1., 1., 0.7, -1.) : vec4 (0.8, 0.8, 0.4, -1.);\n  else if (idObj == ID_Rail) col4 = vec4 (0.8, 0.8, 0.8, 0.5);\n  else if (idObj == ID_Tie) col4 = vec4 (0.4, 0.2, 0.1, 0.1);\n  else if (idObj == ID_Plat)\n     col4 = vec4 (vec3 (0.5, 0.3, 0.3) * BrickCol (0.3 * qHit, n), 0.1);\n  else if (idObj == ID_Sig)\n     col4 = sigStop ? vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.);\n  else if (idObj == ID_Cpl) col4 = vec4 (0.2, 0.1, 0.2, 0.2);\n  else if (idObj == ID_SigV) col4 = vec4 (0.8, 0.4, 0.2, 0.5);\n  else if (idObj == ID_Tree) col4 = vec4 (0., 0.4, 0., 0.) *\n     (1. - 0.5 * Noisefv2 (vec2 (50. * (1. + atan (qHit.x, qHit.z) / pi), 20. * qHit.y)));\n  else if (idObj == ID_Trunk) col4 = vec4 (0.4, 0.1, 0., 0.1) *\n     (1. - 0.3 * Noisefv2 (vec2 (30. * (1. + atan (qHit.x, qHit.z) / pi), 10. * qHit.y)));\n  return col4;\n}\n\nfloat FontTexDf (vec2 p)\n{\n  vec3 tx;\n  float d;\n  int ic;\n  ic = GetTxChar (p);\n  if (ic != 0) {\n    tx = texture (txFnt, mod ((vec2 (mod (float (ic), 16.),\n       15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n    qnFnt = vec2 (tx.r, - tx.g);\n    d = tx.b + 1. / 256.;\n  } else d = 1.;\n  return d;\n}\n\nfloat ObjRayT (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 srd, h;\n  float dHit, d;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  srd = - sign (rd.xy);\n  rdi = 1. / abs (rd.xyz);\n  dHit = 0.;\n  ro.xy /= fntSize.x;\n  rd.xy /= fntSize.x;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + dHit * rd;\n    h = rdi.xy * fract (srd * p.xy);\n    d = max (min (fntSize.x, 1.) * FontTexDf (p.xy), abs (p.z) - 0.5 * fntSize.y);\n    dHit += min (d, 0.01 + fntSize.x * min (h.x, h.y));\n    if (d < 0.0001 || dHit > rngBlk) break;\n  }\n  if (d >= 0.0001) dHit = dstFar;\n  return dHit;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    rngBlk = df - dn;\n  }\n  return dMin;\n}\n\nfloat DstTxt (vec3 ro, vec3 rd)\n{\n  vec3 q, qt;\n  float db, d, dstTxt;\n  rd.xz = Rot2D (rd.xz, - azRot);\n  dstTxt = dstFar;\n  for (int k = 0; k <= 7; k ++) {\n    idTxt = -1;\n    if (k == 0 && showObj[SH_Engn]) {\n      qt = trainPos[k] + vec3 (0., 2.5, 0.);\n      idTxt = k;\n    } else if (k < 3 && showObj[SH_Cars]) {\n      qt = trainPos[k] + vec3 (0., 2.5, 0.);\n      idTxt = k;\n    } else if (k == 3 && (onTrk && showObj[SH_TrkSt] || ! onTrk)) {\n      qt = (onTrk) ? vec3 (- trkRad + trkWid + 5., - gHt + 1., 0.) : vec3 (trkWid + 1., -3., 0.);\n      idTxt = k;\n    } else if (k == 4 && onTrk && showObj[SH_Plat]) {\n      qt = vec3 (trkRad - trkWid - 3., 3., 0.);\n      idTxt = k;\n    } else if (k == 5 && onTrk && showObj[SH_Sig]) {\n      qt = vec3 (trkRad - trkWid - 3., 5., 6.);\n      idTxt = k;\n    } else if (k == 6 && onTrk && showObj[SH_Tun]) {\n      qt = vec3 (0., 4., trkRad + 0.5 * trkLin - trkWid);\n      idTxt = k;\n    } else if (k == 7 && onTrk && showObj[SH_Tree]) {\n      qt = vec3 (-0.4 * trkRad, - gHt + 1., -0.7 * trkLin + 3.);\n      idTxt = k;\n    }\n    if (idTxt >= 0) {\n      qt.y -= 0.5 * fntSize.x;\n      q = ro - qt;\n      q.xz = Rot2D (q.xz, - azRot);\n      db = BlkHit (q, rd, vec3 (4. * fntSize.x, fntSize.x, 0.5 * fntSize.y));\n      if (db < dstFar) {\n        d = db + ObjRayT (q + db * rd, rd);\n        if (d < dstTxt) {\n          dstTxt = d;\n          qtTxt = qt;\n          qnTxt = qnFnt;\n        }\n      }\n    }\n  }\n  return dstTxt;\n}\n\nvoid SetState ()\n{\n  float t;\n  tBuild = 14.;\n  t = mod (tCur, tPlay);\n  onTrk = (t < 8. || t > tBuild);\n  onTxt = (t < tBuild + 9.);\n  if (t < 0.5 * tPlay) {\n    showObj[SH_TrkSt] = (t > 2.);\n    showObj[SH_TrkCv] = (t > 3.);\n    showObj[SH_Plat] = (t > 4.);\n    showObj[SH_Sig] = (t > 5.);\n    showObj[SH_Tun] = (t > 6.);\n    showObj[SH_Tree] = (t > 7.);\n    showObj[SH_Engn] = (t > 9.);\n    showObj[SH_Cars] = (t > 10.);\n  } else {\n    t = tPlay - t + 0.5;\n    showObj[SH_TrkSt] = (t > 1.);\n    showObj[SH_TrkCv] = (t > 2.);\n    showObj[SH_Plat] = (t > 3.);\n    showObj[SH_Sig] = (t > 3.);\n    showObj[SH_Tun] = (t > 4.);\n    showObj[SH_Tree] = (t > 5.);\n    showObj[SH_Engn] = (t > 6.);\n    showObj[SH_Cars] = (t > 7.);\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, objCol, col, ds, ld;\n  float dstHit, dstTxt, sh, lDist, f;\n  bool isBg;\n  isBg = false;\n  dstTxt = (onTxt) ? DstTxt (ro, rd) : dstFar;\n  isShad = false;\n  dstHit = ObjRay (ro, rd);\n  if (min (dstHit, dstTxt) < dstFar) {\n    if (dstHit < dstTxt) {\n      ro += rd * dstHit;\n      vn = (idObj != ID_Grnd) ? ObjNf (ro) : vec3 (0., 1., 0.);\n      col4 = ObjCol (vn);\n      isShad = true;\n      col = col4.xyz;\n      if (col4.w >= 0.) {\n        if (isDark) {\n          ld = ro - (trainPos[0] + vec3 (0., -0.2, 3.6) * trainMat[0]);\n          lDist = length (ld);\n          ld = normalize (ld);\n          f = pow (max (dot (ld, vec3 (0., 0., 1.) * trainMat[0]), 0.), 1.5);\n          sh = (f > 0.) ? ObjSShadow (ro, - ld, lDist - 0.5) : 1.;\n          col *= 0.2 + 0.2 * max (vn.y, 0.) + sh * f * min (1., 100. * pow (1. + lDist, -2.));\n          if (f > 0.) col += sh * col4.w * pow (max (dot (normalize (- ld - rd), vn), 0.), 64.);\n        } else {\n          sh = (onTrk) ? 0.4 + 0.6 * ObjSShadow (ro, ltDir, dstFar) : 1.;\n          col *= 0.2 + 0.1 * max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.) +\n             sh * 0.8 * max (dot (vn, ltDir), 0.);\n          col += sh * col4.w * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n        }\n      } else col *= clamp (0.6 - 0.5 * dot (rd, vn), 0., 1.);\n    } else if (dstTxt < dstFar) {\n      ro += rd * dstTxt;\n      ds = ro - qtTxt;\n      ds.xz = Rot2D (ds.xz, - azRot);\n      if (abs (ds.z) < 0.49 * fntSize.y) {\n        col = vec3 (0.3, 0.3, 1.);\n        vn = normalize (vec3 (qnTxt, 0.00001));\n      } else {\n        col = vec3 (0.7, 0.7, 1.);\n        vn = vec3 (0., 0., sign (ds.z));\n      }\n      ld = normalize (vec3 (1., 1., -1.));\n      col = col * (0.5 + 0.5 * max (dot (ld, vn), 0.)) +\n         0.5 * pow (max (dot (normalize (ld - rd), vn), 0.), 64.);\n    } else isBg = true;\n  } else isBg = true;\n  if (isBg) col = vec3 (0.1, 0.1, 0.2) * (0.6 + 0.4 * rd.y) * (isDark ? 0.5 : 1.);\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, dist, tCirc, tPause, tHalt, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  trkRad = 20.;\n  trkLin = 20.;\n  trkWid = 1.42;\n  gHt = 2.8;\n  trVel = 6.;\n  tPlay = 120.;\n  SetState ();\n  fntSize = vec2 (0.8, 0.1);\n  if (onTrk) fntSize *= 1.5;\n  tCirc = 2. * (pi * trkRad + trkLin) / trVel;\n  tPause = 0.1 * tCirc;\n  tCirc += tPause;\n  if (onTrk) {\n    tRun = mod (tCur, tPlay);\n    s = floor ((tRun - tBuild) / tCirc);\n    isDark = (s == 1.);\n    tRun = (tRun > tBuild) ? mod (tRun - tBuild, tCirc) : 0.;\n    tHalt = trkLin / trVel;\n    sigStop = (tRun < tHalt + 0.8 * tPause);\n    if (tRun > tHalt + tPause) tRun = tRun - tPause;\n    else if (tRun > tHalt) tRun = tHalt;\n  } else {\n    tRun = 0.;\n    isDark = false;\n  }\n  for (int k = 0; k < 3; k ++) {\n    s = trVel * tRun;\n    if (k == 1) s -= 7.;\n    else if (k == 2) s -= 13.4;\n    TrainCarPM (s);\n    trainPos[k] = trPos;\n    trainMat[k] = trMat;\n  }\n  if (onTrk) {\n    dist = 2. * (trkRad + 0.5 * trkLin + 10.);\n  } else {\n    dist = 1.5 * trkLin;\n    trVel = 1.;\n    tRun = tCur;\n  }\n  ro = vec3 (0., 0., - dist);\n  rd = normalize (vec3 (uv, 3.2));\n  el = 0.15 * pi;\n  az = 0.5 * pi;\n  if (mPtr.z > 0.) {\n    el -= pi * mPtr.y;\n    el = (onTrk) ? clamp (el, 0., 0.45 * pi) : clamp (el, -0.4 * pi, 0.4 * pi);\n    az -= 2.3 * pi * mPtr.x;\n  } else {\n    el -=  0.05 * pi * sin (0.02 * pi * tCur);\n    az -= -0.4 * pi + (4. * pi / tPlay) * tCur;\n  }\n  azRot = az;\n  ltDir = normalize (vec3 (0.3, 0.4, -1.));\n  rd.yz = Rot2D (rd.yz, el);\n  ro.yz = Rot2D (ro.yz, el);\n  rd.xz = Rot2D (rd.xz, az);\n  ro.xz = Rot2D (ro.xz, az);\n  ltDir.yz = Rot2D (ltDir.yz, el);\n  ltDir.xz = Rot2D (ltDir.xz, az);\n  if (onTrk) ro.y -= gHt + 0.2;\n  dstFar = 150.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\n#define CP(i) _nc += i\n#define C(c) _ic = (_nc -- == 0) ? (c) : _ic;\n\n#define _SP    C(0x20)\n#define _EXCL  C(0x21)\n#define _QUOT  C(0x22)\n#define _NUM   C(0x23)\n#define _DOLLR C(0x24)\n#define _PCENT C(0x25)\n#define _AMP   C(0x26)\n#define _SQUOT C(0x27)\n#define _LPAR  C(0x28)\n#define _RPAR  C(0x29)\n#define _AST   C(0x2A)\n#define _PLUS  C(0x2B)\n#define _COMMA C(0x2C)\n#define _MINUS C(0x2D)\n#define _PER   C(0x2E)\n#define _SLASH C(0x2F)\n#define _0     C(0x30)\n#define _1     C(0x31)\n#define _2     C(0x32)\n#define _3     C(0x33)\n#define _4     C(0x34)\n#define _5     C(0x35)\n#define _6     C(0x36)\n#define _7     C(0x37)\n#define _8     C(0x38)\n#define _9     C(0x39)\n#define _COLON C(0x3A)\n#define _SEMI  C(0x3B)\n#define _LT    C(0x3C)\n#define _EQUAL C(0x3D)\n#define _GT    C(0x3E)\n#define _QUEST C(0x3F)\n#define _AT    C(0x40)\n#define _A     C(0x41)\n#define _B     C(0x42)\n#define _C     C(0x43)\n#define _D     C(0x44)\n#define _E     C(0x45)\n#define _F     C(0x46)\n#define _G     C(0x47)\n#define _H     C(0x48)\n#define _I     C(0x49)\n#define _J     C(0x4A)\n#define _K     C(0x4B)\n#define _L     C(0x4C)\n#define _M     C(0x4D)\n#define _N     C(0x4E)\n#define _O     C(0x4F)\n#define _P     C(0x50)\n#define _Q     C(0x51)\n#define _R     C(0x52)\n#define _S     C(0x53)\n#define _T     C(0x54)\n#define _U     C(0x55)\n#define _V     C(0x56)\n#define _W     C(0x57)\n#define _X     C(0x58)\n#define _Y     C(0x59)\n#define _Z     C(0x5A)\n#define _LSQB  C(0x5B)\n#define _BSLSH C(0x5C)\n#define _RSQB  C(0x5D)\n#define _CARET C(0x5E)\n#define _USCOR C(0x5F)\n#define _GRAVE C(0x60)\n#define _a     C(0x61)\n#define _b     C(0x62)\n#define _c     C(0x63)\n#define _d     C(0x64)\n#define _e     C(0x65)\n#define _f     C(0x66)\n#define _g     C(0x67)\n#define _h     C(0x68)\n#define _i     C(0x69)\n#define _j     C(0x6A)\n#define _k     C(0x6B)\n#define _l     C(0x6C)\n#define _m     C(0x6D)\n#define _n     C(0x6E)\n#define _o     C(0x6F)\n#define _p     C(0x70)\n#define _q     C(0x71)\n#define _r     C(0x72)\n#define _s     C(0x73)\n#define _t     C(0x74)\n#define _u     C(0x75)\n#define _v     C(0x76)\n#define _w     C(0x77)\n#define _x     C(0x78)\n#define _y     C(0x79)\n#define _z     C(0x7A)\n#define _LBRC  C(0x7B)\n#define _VBAR  C(0x7C)\n#define _RBRC  C(0x7D)\n#define _TILDE C(0x7E)\n\nint GetTxChar (vec2 p)\n{\n  vec2 fp;\n  ivec2 ip;\n  float d;\n  int _ic, _nc;\n  fp = floor (p);\n  ip = ivec2 (fp);\n  _ic = 0;\n  _nc = ip.x;\n  if (ip.y == 0) {\n    if (idTxt < 3) {\n      CP(3);\n      if (idTxt == 0) {\n        _E _n _g _i _n _e\n      } else if (idTxt == 1) {\n        _C _a _r _SP _NUM _1\n      } else if (idTxt == 2) {\n        _C _a _r _SP _NUM _2\n      }\n    } else if (idTxt == 3) {\n      CP(3);\n      _T _r _a _c _k\n    } else if (idTxt == 4) {\n      CP(4);\n      _P _l _a _t _f _o _r _m\n    } else if (idTxt == 5) {\n      CP(3);\n      _S _i _g _n _a _l\n    } else if (idTxt == 6) {\n      CP(3);\n      _T _u _n _n _e _l\n    } else if (idTxt == 7) {\n      CP(2);\n      _T _r _e _e\n    }\n  }\n  return _ic;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlcz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1489, 1523, 1523, 5133], [5135, 5135, 5169, 5169, 6655], [6657, 6657, 6693, 6693, 10002], [10004, 10004, 10031, 10031, 10848], [10850, 10850, 10872, 10872, 11269], [11271, 11271, 11304, 11304, 11507], [11509, 11509, 11530, 11530, 11743], [11745, 11745, 11794, 11794, 12017], [12019, 12019, 12048, 12048, 12364], [12366, 12366, 12398, 12398, 12524], [12526, 12526, 12548, 12548, 14603], [14605, 14605, 14631, 14631, 14934], [14936, 14936, 14970, 14970, 15555], [15557, 15557, 15602, 15602, 15964], [15966, 15966, 15999, 15999, 17432], [17434, 17434, 17452, 17452, 18163], [18165, 18165, 18200, 18200, 20245], [20247, 20247, 20303, 20303, 22250], [24508, 24508, 24532, 24532, 25228], [25230, 25230, 25262, 25262, 25362], [25364, 25364, 25397, 25397, 25486], [25488, 25488, 25521, 25521, 25548], [25550, 25550, 25592, 25592, 25643], [25645, 25645, 25688, 25688, 25752], [25754, 25754, 25807, 25807, 25868], [25870, 25870, 25915, 25915, 26018], [26020, 26020, 26050, 26050, 26108], [26231, 26231, 26255, 26255, 26302], [26304, 26304, 26328, 26328, 26383], [26385, 26385, 26410, 26410, 26589]]}
{"id": "4tlyR4", "name": "XOR Sphere", "author": "jaburns", "description": "3d rotating sphere", "tags": ["3d", "sphere", "rotation"], "likes": 1, "viewed": 160, "date": "1503703533", "time_retrieved": "2024-06-20T18:59:34.968179", "image_code": "#define PI 3.14159265358979\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,   s,\n        0.0,  -s,   c\n    );\n}\n\nmat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n}\n\nmat3 rotateZ(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n          c,   s, 0.0,\n         -s,   c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.5 * fragCoord.xy / iResolution.yy - 1.25;\n    p.x -= 1.0;\n    float xx = p.x*p.x, yy = p.y*p.y;\n\n    // Return a black pixel if we're outside of the sphere.\n    if (xx + yy > 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    fragColor = vec4(1.0);\n\n    vec3 rotated = rotateY(iTime*2.0) * rotateX(iTime) * rotateZ(iTime/2.0)\n        * vec3(p.x, p.y, sqrt(1.0 - xx - yy));\n    \n    float phi   = atan(rotated.x, rotated.y) + PI;         // 0 < phi < 2pi\n    float theta = atan(rotated.z,   1.0    ) + PI / 4.0;   // 0 < theta < pi/2\t\n\n    // Transform the angles in to texture coordinates in [0,255].\n\tint u = int(floor( 256.0 *   phi / PI / 2.0 ));\n    int v = int(floor( 256.0 * theta / PI * 2.0 ));\n    \n    // Look up the texture coordinates in a colored XOR texture. \n    vec4 rgba;\n    fragColor.r = float(u ^ v);\n    fragColor.g = 2.0*abs(128.0 - fragColor.r);\n    fragColor.b = 255.0 - fragColor.r;\n    fragColor.a = 255.0;\n\n    // Compute the pixel's distance from the center of the lighting glare.\n    float ldx = p.x + 0.5;\n    float ldy = p.y - 0.5;\n    float ld = sqrt( ldx*ldx + ldy*ldy ) + 0.4; // Constant added here for anti-glare effect. 0 = glare, 1 = no glare.\n    ld *= ld;\n\n    // Divide all colors by the squared distance from the glare center, and we're done.\n    fragColor /= 255.0 * ld;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlyR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[29, 29, 54, 54, 196], [198, 198, 223, 223, 365], [367, 367, 392, 392, 534], [536, 536, 593, 593, 1938]]}
{"id": "4tscR4", "name": "Proceudual Landscape(jp comment)", "author": "sw", "description": "based on:\nhttps://www.shadertoy.com/view/4tlSDS\n\nadd japanese comment.\n\nほぼすべての行に日本語のコメントを足しました。\n理解が深めやすいかも?", "tags": ["landscape", "proceudual"], "likes": 1, "viewed": 464, "date": "1503723643", "time_retrieved": "2024-06-20T18:59:34.968179", "image_code": "float cosNoise(in vec2 pos){\n    return 0.5*(sin(pos.x) + sin(pos.y));\n}\n\nconst mat2 m2 = mat2(0.8, -0.6,\n                     0.6, 0.8); \n\nfloat map(in vec3 pos){// pos:レイの位置\n//  return length(pos - vec3(0.0,0.0,-2.0)) -1.0;\n    vec2 q = pos.xz * 0.5; // 山々の感覚を広げる\n    float h = 0.0;\n\n    float s = 0.5;  // noiseの量\n    for(int i = 0; i<10; i++){\n        h += s*cosNoise(q);   // xzから高さを求める\n        s *= 0.5;            // noiseの量を減らす 減らすことで山の先端の細さを作ってる\n        q = m2 * q * 1.7;    // 回転することでボコボコさせる\n    }\n    \n    h *= 3.0;   // 山を高くする\n  \n    return pos.y - h;   // レイの位置から高さを引く　判定側で山のほうが高かったら衝突しているとみなす\n}\n\n\n\n// ノーマルの計算\nvec3 calcNormal(in vec3 pos){\n    vec3 nor;\n    vec2 e = vec2(0.01,0.0);\n    nor.x = map(pos + e.xyy) - map(pos - e.xyy);    //少しだけずらしたときにあたる場所をもとめて　差分からノーマルを作成\n    nor.y = map(pos + e.yxy) - map(pos - e.yxy);\n    nor.z = map(pos + e.yyx) - map(pos - e.yyx);\n    return normalize(nor);\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd){ // ro:カメラの座標 rd:ライトベクトル\n    //ライト方向にレイを飛ばして、衝突したら影にする\n    float res = 1.0;\n    float t = 0.1;\n    for (int i = 0; i <64; i++){\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n       res = min( res, max(h,0.0)*164.0/t );\n        if(res< 0.0001) break;\n        t+=h*0.5;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy; //解像度の比\n    vec2 q = -1.0 + 2.0*p;                  // 解像度の比を-1~1にまとめた\n    q.x *= 1.777;                           // x方向を大きく　なぜ1.777?\n \n    vec3 ro = vec3(0.0, 1.65, -iTime);      // カメラのポジション\n    vec3 rd = normalize( vec3(q, -1.0));    // レイの方向\n    \n    vec3 col = vec3(0.7, 0.8, 1.0);         // 初期カラー\n    col *= 1.0 -0.5 *rd.y;                  // 上ほど色を落としている\n    float tmax =40.0;                       // 探索最大距離　４０以上奥になにかあっても打ち切られる\n    float t = 0.0;                          // レイを伸ばしていく係数\n    \n    for(int i=0; i<256; i++){               // 256回レイを進めていく \n        vec3 pos = ro + rd*t;               // カメラ位置からレイ方向にｔ分だけ移動する\n        float h = map(pos);                 // レイ方向にある一番近い山の面までの距離を取得\n        if(h < 0.001 || t > tmax) break;    // 0.001以下だったらそこに山の面がある　tmax以上だったらなにもない\n        \n        t += h*0.5;                         // 山の面までの半分の距離分だけレイをすすめる\n    }\n    \n    vec3 light = normalize(vec3(1.0,0.1,-0.5)); // ライトベクトル\n    \n    if(t < tmax){   // 山の面に衝突している\n        vec3 pos = ro + t*rd;   // 山の面の座標\n        vec3 nor = calcNormal(pos); // 法線を計算\n        float sha = calcShadow(pos + nor *0.1,light); // 影を計算\n\n        float dif = clamp (dot(nor,light), 0.0,1.0);  // lumbert拡散照明によるライティング\n        vec3 lig = vec3(2.0, 1.5,1.0)*dif *sha;       // ライト色*ライティング*影\n        lig += vec3(0.1,0.2,0.3)*nor.y *2.0;          // 上方向ほど色を明るめに\n        \n        // 法線による色変化　上に向いているほど色をつけている\n        vec3 mate = vec3(0.2, 0.3, 0.3)*0.5; \n        mate = mix(mate, vec3(0.2,0.15,0.1), smoothstep(0.7,0.9,nor.y));\n        col = lig * mate;\n        \n        float fog = exp(-0.002 *t * t); // fog\n        col *= fog;\n        col += ((1.0 - fog)*vec3(0.5,0.6,0.7));\n    }\n    \n    // gamut for monitor\n    col = sqrt(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tscR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 28, 28, 72], [140, 140, 163, 235, 818], [822, 847, 876, 876, 1200], [1202, 1202, 1243, 1369, 1618], [1620, 1620, 1677, 1677, 4037]]}
{"id": "4tscR8", "name": "Optical deconstruction 5b", "author": "ollj", "description": "the [optical circuit demo] video source code once appeared on glslsandbox.com\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\nit is fractal code golf overkill in [0..6] scenes.\nthis is a deconstruction of scene 5", "tags": ["fractal", "optical", "glow", "kifs", "laser", "battle", "circuit", "0x4015", "spaseship"], "likes": 61, "viewed": 4893, "date": "1503414390", "time_retrieved": "2024-06-20T18:59:36.040853", "image_code": "//scene1: https://www.shadertoy.com/view/MlfczH\n//self 5: https://www.shadertoy.com/view/4tscR8\n//Optical-Circuit optical circuit scene 5 deconstruction b\n\n/*\n\nnot my code, just deconstructing it:\n\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\n\nThe [optical circuit demo] video source code once appeared on glslsandbox.com\n... with very nondesctiptic labels, \n... only using single letter names for functions and vars..\n\nIt is fractal code golf overkill in [0..6] scenes.\nThis is a deconstruction of scene 5. , not the whole demo.\nUn-used functions (only used in other scenes) are removed;\nscene-specific branches are set to 1, or removed \n... (multiplying by *0. or adding -0 iterations)\n... all changes are annotated.\n\nThis may run slightly faster due to removing all schene-specific branching\nMost of that modifies iteration count (between scenes, which are static per shader)\nThe [smart re-use of schene specific branches and modifiers] is what makes this a 4k demo.\n... at a cost of running slightly slower, by summing up scene-modifiers.\n*/\n\n\n//#define scene 5\n#define timeOffset 23.984083\n\n//scene5 skips all the black fractal code.\n//and it replaces it with +50% more iterations over the 2 main loops\n\nconst float pi=acos(-1.);//3.14\nconst float t1=sqrt(.5); //0.707\n\nfloat A,D,E;vec3 B,C;\n\nfloat mav(vec2 a){return max(a.y,a.x);}\nfloat mav(vec3 a){return max(a.z,mav(a.xy));}\nfloat mav(vec4 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n#define dd(a) dot(a,a)\nfloat vsum(vec3 a){return dot(a,vec3(1));}//dot() is generally faster on a gpu than 2add()\n //return a.x+a.y+a.z;}\n\n//spaceship distance field is the min() of many sub-distance fields\n//sub of H and I\nvec3 F(vec3 a, float b){float c=sin(b),d=cos(b);return mat3(d,-c,0,c,d,0,0,0,1)*a;}\n//sub of T,used once\nvec3 H(vec3 a){a=F(a,(floor(atan(a.y,a.x)*1.5/pi)*2.+1.)*pi/3.);\n return vec3(a.x,abs(a.y),a.z);}\n//sub of T, used once, modifies a internally though\nvec3 I(vec3 a){a.z-=A*1.5;float b=A*.5 + floor(a.z);\n return F(vec3(a.x,a.y+sin(b),fract(a.z)-.5),pi-cos(b));}\n//\n//sub of S and T\nfloat R(vec3 a){vec3 b=abs(a);return max(b.y,dot(vec3(.87,.5, 0), b))- 1.;}\n//sub of T, used twice\nfloat S(vec3 a){return max(max(abs(length(a-vec3(0,0,5.))-5.)-.05,R(a)),a.z-2.);}\n//sub of T, used twice\nfloat Q(vec3 a){return max(abs(length(a*vec3(1,1,.3))-.325)-.025,-a.z);}\n//sub of T,used twice\nfloat P(vec3 a){vec3 b=abs(a);\n return max(mav(b),max(max(length(b.xy),length(b.yz)),length(b.zx))-.2)-1.;}\n//t is most scene specific\n//for scene5 it is the distance field of chasing spaceships\nfloat T(vec3 a){\n vec3 b=I(a)*20.,c=H(b*2.+vec3(0,0,2))-vec3(1.4,0,0),d=b;\n d.y=abs(d.y);\n return min(min(min(\n           min(max(R(d*4.-vec3(2,5,0))*.25,abs(d.z)-1.),S(d.yzx*vec3(1,.5,.5)*1.5 + vec3(.3,0,0))/1.5),\n           max(min(.1-abs(d.x),-d.z),S(vec3(0, 0, 1) - d.xzy * vec3(1, .5, .5)))),\n          min(\n           min(max(P(c),-P(c * 1.2 + vec3(0,0, 1.5)) / 1.2),Q(c + vec3(0, 0, 1.5))),\n           Q(vec3(abs(c.xy), c.z) - vec3(.5,.5,-1.5)))*.5)*.05,\n  .15-abs(a.x));}\n\n//sub of W and Y\nvec3 V(float a,vec3 b,float c){a*=c;return 1./((1.+2.*b/a+b*b/(a*a))*c+.0001);}\n//used twice in Mainimage\nvec3 W(vec3 a,float b,float c,float d){\n vec3 e=(V(.01,abs(a),d)*2.+V(.05, vec3(length(a.yz),length(a.zx),length(a.xy)),d)*5.)\n       *(sin(A * vec3(2.1,1.3,1.7)+b*10.0)+1.);\n return(e*7.+e.yzx*1.5+e.zxy*1.5)*max(1.-c*200./d,0.)/d*12.;}\n\n//glowing planes:\n//sub of X\nvec3 Z(float t){\n return vec3(0,-sin(t*.6),t*1.6+.5)+sin(t*.01*vec3(11,23,19))*vec3(.135,.25,.25);}\n//sub of Y\nfloat X(vec3 a,float t,float b){\n float c=fract(t+b),e=t-c;\n vec3 f=Z(e)* vec3(0, 1, 1) + sin(vec3(0,23,37)*e),\n g=normalize(sin(vec3(0, 17, 23) * e))*8.,\n h=f+g+vec3(sin(e*53.)*.15,0,9),\n j=f-g+vec3(sin(e*73.)*.15,0,9),\n k=mix(h,j,c-.15),\n l=mix(h,j,c+.15);\n t=dot(a-k,l-k)/dot(l-k,l-k);\n return length((t<.0?k:t>1.?l:k+t*(l-k))-a);}\n//used in main\nvec4 Y(vec3 a,float b,float t){\n vec3 c=I(a)*20.,\n d=vec3(length(c + vec3(-.35,.57,2)),length(c + vec3(-.35, -.57, 2)), length(c + vec3(.7, 0, 2))),\n e=V(.2,d,b),\n f=vec3(X(a, t, 0.0), X(a, t, .3), X(a, t, .6)), g = V(.001, f, b);\n return vec4(\n  vsum(e)*vec3(30, 75, 150) * (E + 1.0) + vsum(g) * vec3(1.0, .1, .2) * 5000.0,\n  min(min(min(d.y, d.z), d.x) * .05, min(min(f.y, f.z), f.x)));}\n\n//used once in MainImage\nvec3 G(vec3 a, float b){a=fract(a*.2)*2.-1.;a.z=b;float c=50.;\n for(int i=0;i<6+1;++i){//scene5 adds +1 iteration here\n  float d = clamp(dd(a),.05,.65);c*=d;a=abs(a)/d-1.31;a.xy*=mat2(1,1,-1,1)*t1;\n }return a*c;}\n//U is very scene specific, used 5* in mainImage\nfloat U(vec3 a){return .15-abs(a.x);}\n\n#define resolution iResolution\nvoid mainImage(out vec4 O, in vec2 Uuu){\n {//this looks like it used to be an initiating function\n  A=iTime + timeOffset;\n  vec2 glVertex=Uuu.xy/resolution.xy*2.-1.;\n  vec3 a=Z(A),//a b c d are very scene specific\n  b=normalize((vec3(0,-sin((A+sin(A*.2)*4.)*.5+A*.1),(A+sin(A*.2)*4.)*1.6+.5)-a)),\n  c=normalize(cross(b,sin(A*.001*vec3(31,17,29))));\n  float d=A*5.;\n  for(int i=0;i< 20;++i){\n   float t=A-float(i)*.1;\n   vec4 y=Y(Z(t),25.,t);\n   d+=1.*sin((y.w+t)* 5.)*y.x*.05*exp(float(i)*-.25);//scene specific\n  }/**/\n  vec3 e=normalize(vec3(sin(vec2(.53,.47)*d)*4.+sin(vec2(.91,1.1)* d)*2.+sin(vec2(2.3,1.7)*d),200)),\n  f=normalize(cross(e, vec3(sin(d), 50, 0)));\n  B=a;\n  C=mat3(c,cross(c,b),b)*(f*glVertex.x*1.78+cross(f,e)*glVertex.y+e*1.4);\n  D=fract(sin(vsum(C)*99.317*pi)*85.081*pi);\n  E=fract(sin(A      *99.317*pi)*85.081*pi);\n }\n vec3 a=normalize(C),c=vec3(1),e=B,f=a,g=e,b=vec3(0),s=vec3(1,-1,-1)*.0005;\n vec4 l=vec4(B,1),k=vec4(0),j=k,h=j;\n int m=1;\n float t=.0,o=1.,p=1.,q=D*.01+.99,n;\n for(int i=0;i<64;++i) {//scene5 adds +32 iterations here. \n  //...i removed that. performance loss not wirth that.\n  g=e+f*t;\n  float d=T(g);\n  if(d<(t*5.+1.)*.0001){\n   vec3 u=normalize(T(g+s)*s+T(g+s.yyx)*s.yyx+T(g+s.yxy)*s.yxy+T(g+s.xxx)*s.xxx);//normal\n   float r=pow(abs(1.-abs(dot(u,f))),5.)*.9+.1;\n   o+=t*p;p*=5./r;\n   e=g+u*.0001;f=reflect(f,u);t=.0;\n   float v=dd(u);\n   if(v<.9||1.1<v||v!= v)u=vec3(0);\n   if(m<4){h=j;j=k;k=l;l=vec4(g,max(floor(o),1.)+clamp(r,.001,.999));++m;\n   }\n  }else t=min(t+d*q,100.);\n }\n if(m<4){h=j;j=k;k=l;l=vec4(g,o+t*p);++m;}\n int nn=m;for(int i=0;i<4;++i)if(nn < 4){h=j;j=k;k=l;++nn;}\n f=normalize(j.xyz-h.xyz);n=length(j.xyz-h.xyz);\n t=.0;o=1.;p=.0;e=h.xyz;\n q=D*.1+.8;//scene specific, no mod for scene5\n for(int i=0;i<64+32;++i){//scene5 adds 32 iterations here\n  if(t>n){\n   if(m<3)break;\n   h=j;j=k;k=l;\n   --m;\n   e=h.xyz;\n   f=normalize(j.xyz - h.xyz);\n   n=length(j.xyz - h.xyz);\n   t=.0;\n   if(n<.0001)break;\n   float r=fract(h.w);\n   o = h.w-r;\n   p=(floor(j.w)-o)/n;\n   c*=mix(vec3(.17,.15,.12),vec3(1),r);}\n  g=e+f*t;\n  vec4 y=Y(g,o+p*t,A);//scene specific\n  float u=U(g);\n  u=min(u, y.w);//scene specific\n  g-=normalize(U(g+s)*s+U(g+s.yyx)*s.yyx+U(g+s.yxy)*s.yxy+U(g+s.xxx)*s.xxx)*u;\n  float v=sin(A*.05+g.z)*.5,w=u*q;//scene specific\n  vec3 x=G(g,v);//scene specific\n  b+=(W(x,v,u,o+p*t)+W(x,v,u,o+p*t+50.)+ y.xyz)*c*w;//scene specific\n  c*=pow(.7,w);t+=w;\n }\n //O is scene specific, nno modifier for scene 5.\n O = vec4(pow(b, vec3(.45)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tscR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1268, 1332, 1350, 1350, 1371], [1372, 1372, 1390, 1390, 1417], [1418, 1418, 1436, 1436, 1469], [1517, 1517, 1536, 1536, 1559], [1633, 1718, 1742, 1742, 1801], [1802, 1823, 1838, 1838, 1920], [1921, 1973, 1988, 1988, 2083], [2084, 2104, 2120, 2120, 2179], [2180, 2203, 2219, 2219, 2284], [2285, 2308, 2324, 2324, 2380], [2381, 2403, 2419, 2419, 2510], [2511, 2598, 2614, 2614, 3077], [3079, 3096, 3127, 3127, 3175], [3176, 3202, 3241, 3241, 3438], [3440, 3469, 3485, 3485, 3568], [3569, 3580, 3612, 3612, 3914], [3915, 3930, 3961, 3961, 4319], [4321, 4346, 4370, 4370, 4558], [4559, 4608, 4624, 4624, 4645], [4678, 4678, 4718, 4718, 7181]]}
{"id": "4tsyzn", "name": "Perpetual mitosis", "author": "tdhooper", "description": "I wanted this to have the feel of a Marvel movie intro, but finding an interesting camera path, and doing 'realistic' shading was hard; so we got neon colours instead ;)", "tags": ["fractal", "zoom", "infinite", "dodecahedron", "neon", "subdivide"], "likes": 34, "viewed": 969, "date": "1503153584", "time_retrieved": "2024-06-20T18:59:39.544222", "image_code": "/* \n\n\tPerpetual mitosis\n\t-----------------\n\n\tEssentially a fractal dodecahedron, where we animate between each iteration.\n\n*/\n\n\nfloat time;\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\n// --------------------------------------------------------\n// Config\n// --------------------------------------------------------\n\nfloat stepScale = .275;\nfloat stepMove = 2.;\nfloat stepDuration = 2.;\nfloat ballSize = 1.5;\n\n// How far into the subdivision animation do we start animating\n// the next subdivision\nfloat transitionPoint = .5; \n\n// #define DEBUG_ANIMATION\n\n#ifdef DEBUG_ANIMATION\n    const float initialStep = 0.;\n    const float MODEL_STEPS = 2.;\n#else\n    const float initialStep = 2.;\n    const float MODEL_STEPS = 3.;\n#endif\n\n\n\n// --------------------------------------------------------\n// Rotation controls\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 cameraRotation() {\n    vec2 r = vec2(.66 + .5, 0.) * PI;\n    return sphericalMatrix(r.x, r.y);\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// --------------------------------------------------------\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float r) {\n    float m = min(a, b);\n    if ((a < r) && (b < r) ) {\n        return min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n    } else {\n     return m;\n    }\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\n// fCapsule, but with a break at the midpoint\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r, float breakSize) {\n    vec3 m = mix(b, a, .5);\n    float s1 = fLineSegment(p, a, mix(m, a, breakSize));\n    float s2 = fLineSegment(p, b, mix(m, b, breakSize));\n    return min(s1 - r, s2 - r);\n}\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nstruct Tri {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n    \nstruct TriPlanes {\n    vec3 ab;\n    vec3 bc;\n    vec3 ca;\n};\n    \n    \nvec3 nc;\nTri triV;\nTriPlanes triP;\n\nint Type = 5;\n\nvoid init() {//setup folding planes and vertex\n    vec3 pab,pbc,pca;\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pab=vec3(0.,0.,1.);\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n    // Triangle vertices\n    triV = Tri(pbc, pab, pca);\n    // Triangle edge plane normals \n    triP = TriPlanes( \n        normalize(cross(triV.a, triV.b)),\n        normalize(cross(triV.b, triV.c)),\n        normalize(cross(triV.c, triV.a))\n    );\n}\n\n\nvoid fold(inout vec3 p) {\n    for(int i=0;i<5 /*Type*/;i++){\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p,nc)) * nc;\n    }\n}\n\n\n// --------------------------------------------------------\n// Closest icosahedron vertex\n// Branchless version of the one in\n// https://www.shadertoy.com/view/Mtc3RX\n// --------------------------------------------------------\n\nvec3 icosahedronVertex(vec3 p) {\n    vec3 sp, v1, v2, v3, result, plane;\n    float split;\n    sp = sign(p);\n    v1 = vec3(PHI, 1, 0) * sp;\n    v2 = vec3(1, 0, PHI) * sp;\n    v3 = vec3(0, PHI, 1) * sp;\n    plane = cross(cross(v1, v2), v1 + v2);\n    split = max(sign(dot(p, plane)), 0.);\n    result = mix(v1, v2, split);\n    plane = cross(cross(result, v3), v3 + result);\n    split = max(sign(dot(p, plane)), 0.);\n    result = mix(result, v3, split);\n    return normalize(result);\n}\n\n\n// --------------------------------------------------------\n// Easing\n// --------------------------------------------------------\n\nfloat hardstep(float a, float b, float t) {\n    float s = 1. / (b - a);\n    return clamp((t - a) * s, 0., 1.);\n}\n\n// https://www.shadertoy.com/view/ldBfR1\nfloat gain(float x, float P) {\n    if (x > 0.5)\n        return 1.0 - 0.5*pow(2.0-2.0*x, P);\n    else\n        return 0.5*pow(2.0*x, P);\n}\n\nfloat gainIn(float x, float P) {\n    return gain(x * .5, P) * 2.;\n}\n\nfloat gainOut(float x, float P) {\n    return 1. - gain(.5 - x * .5, P) * 2.;\n}\n\nfloat gainStep(float start, float end, float x, float e) {\n    return gain(hardstep(start, end, x), e);\n}\n\nfloat gainStep(float x, float e) {\n    return gainStep(0., 1., x, e);\n}\n\nfloat kink(float x, vec2 p, float e1, float e2) {\n    float a = (1. - pow(1. - x / p.x, e1)) * p.y;\n    float b = pow((x - p.x) / (1. - p.x), e2) * (1. - p.y) + p.y;\n    return mix(a, b, step(p.x, x));\n}\n\nfloat wobble(float x, float freq) {\n    float w = sin(x * PI * 2. * freq - PI * .5) * .5 + .5;\n    w *= sin(x * PI + PI * .5) * .5 + .5;\n    return w;\n}\n\nfloat circleEaseIn(float radius, float slope, float x) {\n    float iSlope = 1. - slope;\n    float scale = radius / length(vec2(iSlope, 1.));\n    float u = (iSlope * -scale + radius) * iSlope + slope;\n    float line = (x - slope) / iSlope;\n    float uu = u - scale;\n    float circle = -sqrt(radius * radius - (x - uu) * (x - uu)) + radius;\n    float ramp = mix(0., circle, step(uu, x));\n     \n    // This breaks when x < u, something to do with\n    // 1. - x in circleEaseOut\n    // return mix(max(ramp, 0.), line, step(u, x));\n    \n    if (x < u) {\n        return max(ramp, 0.);\n    } else {\n        return line;\n    }\n}\n\nfloat circleEaseOut(float radius, float slope, float x) {\n    return 1. - circleEaseIn(radius, slope, 1. - x);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Noise\n// --------------------------------------------------------\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n\n// --------------------------------------------------------\n// Animation\n// --------------------------------------------------------\n\nfloat tweakAnim(float x) {\n    return mix(x, kink(x, vec2(.4), 2., .8), .5);\n}\n\n// Get the timeline for a single subdivision iteration step\nfloat animStep(float t, float stepIndex) {\n    float x = t;\n    x *= MODEL_STEPS;\n    x -= stepIndex;\n    x *= transitionPoint;\n    x = tweakAnim(x);\n    return x;\n}\n\nfloat animStep(float t, float stepIndex, float delay) {\n    return animStep(t - delay, stepIndex);\n}\n\nfloat moveAnim(float x) {\n    float a = 1.;\n    float h = 1.;\n    float blend = x;\n    blend = gainStep(-a, a, blend, 2.) * h * 2. - h;\n    blend = gainStep(blend, 1.5);\n    return blend;\n}\n\nfloat scaleAnim(float x) {\n    x /= transitionPoint;\n    float a = 1.;\n    float h = 1.;\n    float blend = x;\n    blend = hardstep(0., .85, x);\n    blend = gainStep(-a, a, blend, 1.2) * h * 2. - h;\n    blend = gainStep(blend, 1.2);\n    return blend;\n}\n\nfloat wobbleScaleAnim(float x) {\n    float blend = scaleAnim(x);\n    x /= transitionPoint;\n    blend -= wobble(hardstep(.6, 2.2, x), 3.5) * .1;\n    return blend;\n}\n\nconst float ANIM_CAM_START = .96;\n\nfloat animCamRotateA(float x) {\n    return mix(gainOut(x, 3.), x, .9);\n}\n\nfloat animCamRotate(float x) {\n    float o = ANIM_CAM_START;\n    return animCamRotateA(mod(x - o, 1.)) + (1. - animCamRotateA(1. - o)) + floor(x - o);    \n}\n\nfloat camZoomInOutA(float x) {\n    float back = -.1;\n    float p = .5;\n    \n    float zIn, zOut;\n\n    zOut = hardstep(0., p + .1, x);\n    zOut = gainOut(zOut, 5.);\n    \n    zIn = hardstep(p - .3, 1., x);\n    zIn = gain(zIn, 1.5);\n    zIn = gainIn(zIn, 2.5);\n\n    return zOut * back + zIn * (1.- back);\n}\n\nfloat camZoomInOut(float x) {\n    float o = ANIM_CAM_START;\n    float y = camZoomInOutA(mod(x - o, 1.)) + (1. - camZoomInOutA(1. - o)) + floor(x - o);\n    y -= .2;\n    return y;\n}\n\nfloat animTimeA(float x) {\n    return circleEaseOut(.25, .3, x);\n}\n\nfloat animTime(float x) {\n    float o = .78;\n    return animTimeA(mod(x - o, 1.)) + (1. - animTimeA(1. - o)) + floor(x - o);\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    float level;\n};\n\nModel makeBounds(float dist) {\n    return Model(dist, 0.);\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\n\n// Description of a single ball subdivision animation\n// at a given iteration step\nstruct ModelSpec {\n    float move; // How much the outer ball moves by\n    float sizeScale; // How much to shrink the outer ball\n    float sizeScaleCore; // How much to shrink the inner ball\n    float bounds; // Bounding distance for the model\n    float level; // Iteration/subdivision level for this animation\n};\n\nfloat boundsForStep(vec3 p, float move, float sizeScale, float scale) {\n    float overfit = .3;\n    p /= scale;\n    float d = (length(p) - move - ballSize * sizeScale - overfit);\n    d *= scale;\n    return d;\n}\n\nfloat levelStep(vec3 p, float move, float size, float x) {\n    float transition = smoothstep(0., .1, x);\n    float blend = hardstep(move + size, size, length(p));\n    blend = mix(0., blend, transition);\n    return blend;\n}\n\nModelSpec specForStep(vec3 p, float x, float scale) {\n    float move = moveAnim(x) * stepMove;\n    float sizeScale = mix(1., stepScale, wobbleScaleAnim(x));\n    float sizeScaleCore = mix(1., stepScale, scaleAnim(x));\n    float bounds = boundsForStep(p, move, sizeScale, scale);\n    float level = levelStep(p / scale, move, sizeScale * ballSize, x);\n    return ModelSpec(move, sizeScale, sizeScaleCore, bounds, level);\n}\n\n\nfloat boundsThreshold;\n\n// Animation of the ball subdividing with smooth blending\n// and connective struts that snap\nModel blendedModel(vec3 p, float x, float scale, float level) {\n    ModelSpec spec = specForStep(p, x, scale);\n    level += spec.level;\n    \n    if (spec.bounds > boundsThreshold) {\n        return makeBounds(spec.bounds);\n    }\n    \n    p /= scale;\n    fold(p);\n\n    float move = spec.move;\n    float size = spec.sizeScale * ballSize;\n    float sizeCore = spec.sizeScaleCore * ballSize;\n\n    // Setup smoothing\n\n    float radiusBlend = hardstep(.1, transitionPoint * .8, x);\n    radiusBlend = smoothstep(0., 1., radiusBlend);\n    float radius = mix(0., .4, radiusBlend);\n\n    // Core ball\n\n    vec3 posCore = vec3(0);\n    float d = length(p - posCore) - sizeCore;\n\n    // Setup outer ball\n\n    vec3 posOuter = triV.a * move;\n\n    // Setup connective strut\n\n    float capRadius = 0.04;\n    float gapBlend = hardstep(transitionPoint * .8, transitionPoint, x);\n    float gap = mix(0., 1., gapBlend);\n\n    // Ball and bridge\n\n    d = smin(d, fCapsule(p, posCore, posOuter, capRadius, gap), radius);\n    d = smin(d, length(p - posOuter) - size, radius);\n    \n    // First reflection\n\n    vec3 rPlane = triP.bc;\n    p = reflect(p, rPlane);\n    \n    d = smin(d, fCapsule(p, posCore, posOuter, capRadius, gap), radius);\n    d = smin(d, fCapsule(p, posOuter, reflect(posOuter, rPlane), capRadius, gap), radius);\n    d = smin(d, length(p - posOuter) - size, radius);\n\n    // Second reflection\n\n    vec3 rPlane2 = reflect(triP.ca, rPlane);\n    p = reflect(p, rPlane2);\n\n    d = smin(d, fCapsule(p, posCore, posOuter, capRadius, gap), radius);\n    d = smin(d, fCapsule(p, posOuter, reflect(posOuter, rPlane2), capRadius, gap), radius);\n    d = smin(d, fCapsule(p, posOuter, reflect(reflect(posOuter, rPlane), rPlane2), capRadius, gap), radius);\n    d = smin(d, length(p - posOuter) - size, radius);\n\n    d *= scale;\n\n    return Model(d, level);\n}\n\n\n// Iterates through each subdivision of the ball, restricting the\n// smooth blending method above to just the currently-animated level\nModel iteratedModel(vec3 p) {\n\n    float stepIndex = -initialStep;\n    float prevStepIndex;\n    float x;\n    float scale = 1.;\n    float sizeScale = 1.;\n\n    // Scale at the transition point\n    float midSizeScale = mix(1., stepScale, scaleAnim(transitionPoint));\n    \n    float level = 0.; // Iteration level used for colouring\n    float delayLevel = 0.;\n    vec3 iv;\n    float delay = 0.;\n\n    float coreBoundry;\n    float coreOverstepBounds = 1e12;\n    float coreOverstepBoundsCandidate;\n\n    #ifndef DEBUG_ANIMATION\n        float time = animTime(time);\n    #endif\n\n    for (float i = 1. - initialStep; i < MODEL_STEPS; i++) {\n\n        x = animStep(time, i, delay);\n\n        if (x >= 0.) {\n \n            stepIndex = i;\n            prevStepIndex = stepIndex - 1.;\n\n            scale = pow(midSizeScale, prevStepIndex);\n\n            x = animStep(time, prevStepIndex, delay);\n            ModelSpec spec = specForStep(p, x, scale);\n            level += spec.level;\n\n            coreBoundry = (length(p / scale) - spec.move * .55) * scale;\n            if (coreBoundry > 0.) {\n                iv = icosahedronVertex(p);\n                fold(p);\n                p -= triV.a * spec.move * scale;\n                sizeScale = spec.sizeScale;\n                // Adjust the start time of each ball for some variety\n                delay += hash(iv * 1.5 - spectrum(mod(delayLevel, 3.) / 6.)) * .6;\n            } else {\n                sizeScale = spec.sizeScaleCore;\n                delayLevel += 1.;\n            }\n            \n            coreOverstepBoundsCandidate = coreBoundry + .3 * scale;\n            if (coreOverstepBoundsCandidate > -.0) {\n                coreOverstepBounds = min(coreOverstepBounds, coreOverstepBoundsCandidate);\n            }\n        }\n    }\n\n    x = animStep(time, stepIndex, delay);\n    Model model = blendedModel(p, x, scale * sizeScale, level);\n    \n    if (coreOverstepBounds > boundsThreshold) {\n        model.dist = min(model.dist, coreOverstepBounds);\n    }\n\n    return model;\n}\n\nfloat modelScale;\n\nModel map( vec3 p ){\n    p /= modelScale;\n    boundsThreshold = .1 / modelScale;\n    Model model = iteratedModel(p);\n    model.dist *= modelScale;\n    return model;\n}\n\nvec3 camPos;\nfloat camDist;\nvec3 camTar;\n\n// Return the modelScale for the given subdivision iteration step,\n// such that all steps look the same size\nfloat scaleForStep(float step) {\n    return pow(1./stepScale, step);\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out vec3 camUp) {\n    float x = time;\n\n    camDist = 8.;\n\n    float camZoom = camZoomInOut(x);\n    modelScale = scaleForStep(camZoom * MODEL_STEPS);\n\n    camUp = vec3(0,-1,0);\n    camTar = vec3(0.);\n    camPos = vec3(0,0,camDist);\n        \n    pR(camPos.xz, animCamRotate(x) * PI * 2.);\n\n    #ifdef DEBUG_ANIMATION\n        camDist = 5.;\n        modelScale = 1.;\n        camPos = vec3(0,0,camDist);\n    #endif\n\n    camPos *= cameraRotation();\n}\n\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Shading\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 background = vec3(.95, .95, 1.);\n\n    if (hit.isBackground) {\n        hit.color = background;\n        return;\n    }\n\n    float glow = 1. - dot(normalize(camPos), hit.normal);\n    glow += .5 * (1. - dot(hit.normal, normalize(hit.pos)));\n    glow *= .5;\n    glow = gainStep(glow, 2.);\n    \n    float level = hit.model.level;\n    vec3 diffuse = spectrum(level / MODEL_STEPS + .1 - 1./3.);\n    diffuse = mix(diffuse * 1., diffuse * 1.5, glow);\n\n    float fog = smoothstep(camDist *.1, camDist, length(camTar - hit.pos)) * .5;\n    fog = mix(fog, 1., smoothstep(0., camDist * 2.5, length(camTar - hit.pos)));\n\n    diffuse = mix(diffuse, background, fog);\n    hit.color = diffuse;\n}\n\n\nvec3 render(Hit hit){\n    shadeSurface(hit);\n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in vec3 up )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up));\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 1.;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    float loopDuration = 3. * stepDuration;\n\n    time = iTime;\n    time *= 1.5;\n    time = time/loopDuration;\n    time = mod(time, 1.);\n\n    camPos = vec3( 0., 0., 2.);\n    camTar = vec3( 0. , 0. , 0. );\n    vec3 camUp = vec3(0., 1., 0.);\n    doCamera(camPos, camTar, camUp);\n\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camUp );  // 0.0 is the camera roll\n    vec3 rd = normalize( camMat * vec3(p, 2.) ); // 2.0 is the lens length\n    Hit hit = raymarch(CastRay(camPos, rd));\n    vec3 color = render(hit);\n\n    color = linearToScreen(color);\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsyzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[743, 885, 931, 931, 1143], [1145, 1145, 1168, 1168, 1246], [1249, 1418, 1450, 1450, 1495], [1497, 1497, 1536, 1536, 1688], [1690, 1774, 1818, 1818, 1930], [1932, 2004, 2053, 2053, 2093], [2095, 2141, 2207, 2207, 2383], [2385, 2737, 2750, 2783, 3503], [3506, 3506, 3531, 3531, 3643], [3646, 3874, 3906, 3906, 4354], [4357, 4488, 4531, 4531, 4600], [4602, 4643, 4673, 4673, 4779], [4781, 4781, 4813, 4813, 4848], [4850, 4850, 4883, 4883, 4928], [4930, 4930, 4988, 4988, 5035], [5037, 5037, 5071, 5071, 5108], [5110, 5110, 5159, 5159, 5313], [5315, 5315, 5350, 5350, 5467], [5469, 5469, 5525, 5525, 6089], [6091, 6091, 6148, 6148, 6203], [6206, 6398, 6466, 6466, 6509], [6511, 6511, 6535, 6535, 6633], [6636, 6766, 6797, 6797, 6874], [6877, 7011, 7037, 7037, 7089], [7091, 7151, 7193, 7193, 7316], [7318, 7318, 7373, 7373, 7418], [7420, 7420, 7445, 7445, 7609], [7611, 7611, 7637, 7637, 7862], [7864, 7864, 7896, 7896, 8027], [8064, 8064, 8095, 8095, 8136], [8138, 8138, 8168, 8168, 8294], [8296, 8296, 8326, 8326, 8599], [8601, 8601, 8630, 8630, 8780], [8782, 8782, 8808, 8808, 8848], [8850, 8850, 8875, 8875, 8976], [8979, 9165, 9195, 9195, 9225], [9227, 9273, 9305, 9305, 9393], [9396, 9794, 9865, 9865, 10004], [10006, 10006, 10064, 10064, 10228], [10230, 10230, 10283, 10283, 10649], [10676, 10769, 10832, 10832, 12603], [12606, 12741, 12770, 12770, 14746], [14767, 14767, 14787, 14787, 14933], [14977, 15086, 15118, 15118, 15156], [15158, 15158, 15223, 15223, 15649], [16048, 16335, 16366, 16366, 16623], [16625, 16625, 16655, 16655, 17444], [17447, 17579, 17612, 17612, 18298], [18301, 18301, 18322, 18322, 18369], [18372, 18544, 18605, 18605, 18754], [18757, 18953, 18986, 18986, 19020], [19022, 19022, 19059, 19059, 19103], [19107, 19107, 19164, 19164, 19832]]}
{"id": "4tXcR7", "name": "Psychedelic Mandelbrot", "author": "ageron", "description": "Newbe's mandelbrot. :)", "tags": ["2d", "mandelbrot"], "likes": 0, "viewed": 421, "date": "1503954233", "time_retrieved": "2024-06-20T18:59:39.550219", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - 0.5) * 5.0 * (1.1 + sin(iTime));\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.5;\n\n    vec2 z = vec2(0.0);\n    float i = 0.0;\n    for (; i < 100.0; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y + uv.x, 2.0 * z.x * z.y + uv.y);\n        if (length(z) > 5.0) break;\n    }\n    i += iTime;\n    vec3 col = vec3(0.5 * sin(i) + 0.5, 0.5 * cos(i) + 0.5, 0.5 * sin(i*3.0) + 0.5);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXcR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 530]]}
{"id": "4tXyRN", "name": "almost identity (improved)", "author": "ollj", "description": "almost identity, avoiding zero:\nmouse.y sets gap width\nmouse.x rolls a ball on it\n\nhttp://www.iquilezles.org/www/articles/functions/functions.htm\n\nas optional explicit non_division_by_0, where you would rather skip 0 than dividing by /0", "tags": ["linear", "branchless", "infinity", "zero", "undefined", "division", "null", "discontinuity", "continuity", "almostidentity", "bisymmetry", "675"], "likes": 4, "viewed": 648, "date": "1503586045", "time_retrieved": "2024-06-20T18:59:40.986701", "image_code": "/*\nWanted to to dot() of (nearly) parallel lines, \nImproved the almostidentity() function from\nhttp://www.iquilezles.org/www/articles/functions/functions.htm\nrenamed; aiB(); (branching) and; ai(); (branchless);\nWrote ifu0a() to avoid the y=0 case that ai*() still have.\n\nMildly surprsed how a barely special case ondenses down to dividing by /6.75\n\nI use this function to have a line NEVER get parallel to another line,\n... and instead approach a minimum angle as soon as it is below an angle-threshold\nSimilar to how you can only approach the speed of light, \n...but never reach it, due to having mass.\n*/\n\n/*\ntiny framework 2017-08 : https://www.shadertoy.com/view/MdSBDd\nI use \"bisymmetry\" as shorthand for \"gradient from symmetry to assymmetry\"\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//zoom of view Frame\n#define ViewZoom 8.\n//for WorkSafe <-> rather having a discontinuity near 0, than diving by /0\n//we define a \"smallest positive float\" to replace .0 with.\nconst float tiny=1e-7;//smallest (denormal_)16bit_float>0 == pow(2,-24)\n\n/* end__.Parameters\n   start.Common\n*/\n\n//set viewFrame for 2d modelling\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 miv(v1 a){return min(a.y,a.x);}//return max domain of vector.\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}\n#define u2(a) (a*2.-1.)\n#define u5(a) (a*.5+.5)\n#define dd(a) dot(a,a)\n//perpendicular dot() used for line intersections.\n#define dotp(a,b) dot(vec2(-a.y,a.x),b)\n#define mav(a) -miv(-a)\n//making a triangle wave\n#define fr(a) fract(a)\n#define ss2t(a) a=abs(a*2.-1.)\n//render euclidean grid\n#define grid(u) mav(abs(u2(fr(u))))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define sat(a) clamp(a,0.,1.)\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n\n//null avoidance: if(u==0.) return a, else return 0.;\nfloat ifu0a(float u,float a){return a*(1.-sign(u)*sign(u));}\nfloat ifu0a(vec2 u){return ifu0a(u.x,u.y);}\n//below ai and aiB function do return 0 for u==0 ! this defeats most of their purpose!\n//to make them return something else for u==0, you MUST add +=ifu0a(u.x,m.y) above\n//\n//Almost_Identity of: http://www.iquilezles.org/www/articles/functions/functions.htm\n//to enfoce no divisions by /0 by smoothly skipping over y=f(u)=0\n//m.y= abs(minimum), never return anything smaller than abs(m.y)\n//both gunctions also have a general case where..\n//m.x= threshold.x (cubic only exists within <abs(m.x) )\n//where the special cases calculate a minimum shreshold.\n//[aifs] is optional constrain to general case; keeps sign of first drivative constant.\n#define aifs m.x=max(m.x,m.y*1.5)\n#define aif (2.*(m.y*(t-1.5)+m.x)-u)*t*t+m.y\nfloat aiB(float u,vec2 m){aifs;float t=u/m.x;if(u<m.x)return aif;return u;}\n//special case where m.y is minimal, and m.x becomes u.y for speed.\nfloat aiB(vec2 u){u.y=max(u.y,tiny);if(u.x<u.y*1.5){\n float a=u.y;u*=u*u;return a*(u.x/u.y/6.75+1.);}return u.x;}\nfloat aiB(float u,float a){return aiB(vec2(u,a));}\nfloat ai(float u,vec2 m){aifs;float t=u/m.x;return u+.5*(aif-u)*(1.-sign(u-m.x));}\n//special case where m.y is minimal, and m.x becomes u.y for speed.\n//is undefined for a=0. its trivial case AND purpose of this function\nfloat ai(float u,float a){a=max(a,tiny);float b=u/a;//... therefore a=max(a,tiny)\n return u+(.5*(u*(b*b/6.75-1.)+a))*(1.-sign(u-a*1.5));}\nfloat ai(vec2 u){return ai(u.x,u.y);}\nfloat ai(float u){float b=u/tiny;return u+(.5*(u*(b*b/6.75-1.)+tiny))*(1.-sign(u-tiny*1.5));}\n/*\n//use case examples:\n  //c.g=-ai(u.x,m.y)+u.y;if(u.x<0.)c.g=u.y-m.y;\n  c.r=-sign(u.x)*ai(abs(u.x),m.y)+u.y; \n  //c.r=-sign(u.x)*ai(abs(u.x),m.xy)+u.y;//show more general function\n  vec2 p=vec2(m.x,sign(m.x)*ai(abs(m.x),m.y));//uuse m.y to \"ride\" on the special case\n  p.y+=ifu0a(p.y,m.y);//making m.x case non-zero;\n  c.g=length(u-p)-.5;\n*/\n\n//return distance of [u] from segment, from [a] to [b]\nv0 segment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n/*\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n//----------- mirror symmetry mirror == swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\n/* end__.Common\n   start.Implicit\n*/\n\n//fast good monochrome distance field visualization.\n//blue is grid, red and green are distance fields\nv2 rg(v2 c,v1 u){v0 fsaa=1./min(iResolution.x,iResolution.y);\n return vec3(c.rg=mix(fract(c.rg*4.),smoothstep(fsaa,-fsaa,c.rg),\n  .5+(atan(c.rg))/acos(-1.)),grid(u));}\n\n/*\n//return intersection from line (a b) and line (c d).\nvec2 gLLxX( vec2 A, vec2 B, vec2 C, vec2 D ){\n vec2 b=B-A,d=D-C,c=C-A;\n float dotperp=b.x*d.y-b.y*d.x;\n if0(dotperp);\n float t=(c.x*d.y-c.y*d.x)/dotperp;\n return vec2 (A.x+t*b.x, A.y+t*b.y);}\n\n//rectangle from v1(0) to v1(m)\nv0 rect(v1 u,v3 m){return mav(abs(u*2.-m.xy)-m.xy)*.5;}\n//for a \"class\" of ring/arc shapes.\nv1 arc(v1 u,v3 m){return v1(m.x-abs(m.y),dd(u));}\n /**/\n\n//float circleY(vec2 u){return u.y-sqrt(1.-(u.x*u.x));}//i keep forgetting this one.\n/*\n//one extra step to round the gradient of a box.\n#define RoundBox\n/*note how hg_sdf differnetiates this with 2 functions:\n//non-rounded border, underestimates distance\n  float fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}\n//rounded border exact distance  \nfloat fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}\n//where RoundBox uses;\nc.g=fBoxCheap();\n//...and an additional function that modifies fBoxCheap() into fBox();\nc.g+=.5*(sign(c.g)+1.)*(length(mStretchP(u,m.xy))-c.g)\n//yes, above line adds the EXACT amount of underestimated distance.\n// (which is neglible for most cases)\n// (for a  main-axis-aligned box)\n//and i got this via the \"bisymmetry principle\".\n*/\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n v1 u=fra(U);v2 c=v2(0);v3 m=v3(fra(iMouse.xy),fra(iMouse.zw));\n /*Comp*/   \n if(iMouse.z<=.0)m.xy=3.*vec2(cos(iTime),u5(sin(iTime*.61)));\n \n //m.xy=abs(m.xy);//mouse is always positive.\n \n \n \n \n //c.g=-ai(u.x,m.y)+u.y;if(u.x<0.)c.g=u.y-m.y;\n c.r=-sign(u.x)*ai(abs(u.x),m.y)+u.y; \n //c.r=-sign(u.x)*ai(abs(u.x),m.xy)+u.y;//use more general function\n vec2 p=vec2(m.x,sign(m.x)*ai(abs(m.x),m.y));//center of green circle\n p.y+=ifu0a(p.y,m.y);//set u.x=.0=p,y case to m.y\n c.g=length(u-p)-.5; \n   \n    \n    \n \n /*Out*/\n c=rg(c,u);\n c.b=c.b*4.-3.;    \n //c.g*=.5;\n return c;}\n \n//#define mainImage(O,U)O=vec4(c(U),1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor=vec4(c(fragCoord),1);\n   // fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\n/* end__.Main\n   start.Tail\n*/\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXyRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1080, 1238, 1251, 1251, 1272], [1272, 1303, 1316, 1316, 1343], [1344, 1344, 1357, 1357, 1390], [1858, 1910, 1929, 1929, 1995], [1997, 2051, 2080, 2080, 2111], [2112, 2112, 2132, 2132, 2155], [2156, 2876, 2902, 2902, 2951], [2952, 3020, 3038, 3038, 3133], [3134, 3134, 3161, 3161, 3184], [3185, 3185, 3210, 3210, 3267], [3268, 3406, 3432, 3432, 3543], [3544, 3544, 3561, 3561, 3581], [3582, 3582, 3600, 3600, 3675], [4021, 4076, 4103, 4103, 4153], [5457, 5560, 5577, 5577, 5727], [6996, 7031, 7042, 7050, 7622], [7625, 7666, 7723, 7723, 7798]]}
{"id": "ld2BRd", "name": "Pentagram of Protection", "author": "k_kondrak", "description": "1996 Quake's \"Pentagram of Protection\" powerup, done using SDF and raymarching.", "tags": ["3d", "raymarching", "sdf", "quake", "pentagram"], "likes": 3, "viewed": 585, "date": "1501783056", "time_retrieved": "2024-06-20T18:59:41.895861", "image_code": "// ----------------------------------------------------------------------------------\n// Raymarched 1996 Quake's \"Pentagram of Protection\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------------------------------------\n\nconst float M_PI = 3.141592;\n\n// ---------------------------\n//  signed distance functions\n// ---------------------------\n// see http://iquilezles.org/www/articles/distfunctions/distfunctions.htm for more!\nfloat Box(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Cylinder(in vec3 p, in float r, in float h) \n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat Subtract(in float a, in float b)\n{\n    return max(a, -b);\n}\n\nfloat Union(in float d1, in float d2)\n{\n    return min(d1, d2);\n}\n\nfloat Intersect(in float d1, in float d2)\n{\n    return max(d1, d2);\n}\n\n// -----------\n//  rotation\n// -----------\nmat3 rotX(in float a)\n{\n    return mat3(1.0,    0.0,  0.0,\n                0.0, cos(a), -sin(a),\n                0.0, sin(a),  cos(a));\n}\n\nmat3 rotY(in float a)\n{\n    return mat3(cos(a), 0.0, sin(a),\n                   0.0, 1.0, 0.0,\n               -sin(a), 0.0, cos(a));\n}\n\nmat3 rotZ(in float a)\n{\n    return mat3(cos(a), -sin(a), 0.0,\n                sin(a),  cos(a), 0.0,\n                   0.0,     0.0, 1.0);      \n}\n\n// -------------------------\n//  draw hellish background\n// -------------------------\nvec3 Background(in vec2 pos)\n{\n    vec2 offset = vec2(0.0,0.01 * iTime);\n    vec3 color  = vec3(1.0);\n\n    for(int i = 0; i < 3; i++) \n    {\n        color += mix(texture(iChannel1, pos - 0.25 * offset + 0.5),\n                     texture(iChannel1, pos - offset), \n                     abs(mod(float(i) * 0.666, 2.0) - 1.0)).xyz * color * color;\n    }\n\n    return color * vec3(.0666, .0444, .00444);\n}\n\n// ---------------------------\n//  SDF pentagram composition\n// ---------------------------\nfloat Pentagram(in vec3 p)\n{\n    // pentagram octagonal frame\n    mat3 r1 = rotZ(0.12 * M_PI);\n    mat3 r2 = rotZ(0.38 * M_PI);\n    float a = Box(p * r1, vec3(0.6, 0.6, 0.15));\n    float b = Box(p * r2, vec3(0.6, 0.6, 0.15));\n    float c = Box(p * r1, vec3(0.7, 0.7, 0.05));\n    float d = Box(p * r2, vec3(0.7, 0.7, 0.05));\n\n    float frame = Subtract(Intersect(c, d), Intersect(a, b));\n\n    // inside of the pentagram\n    vec3 offset = vec3(0.22, 0.0, 0.0);\n    float star  = Cylinder( p * rotZ(-0.5 * M_PI) + vec3(0.17, 0.0, 0.0), 0.04, 0.61);\n    star = Union(star, Cylinder(p * rotZ(0.115 * M_PI) - offset, 0.04, 0.61 ));\n    star = Union(star, Cylinder(p * rotZ(-.115 * M_PI) + offset, 0.04, 0.61 ));\n    star = Union(star, Cylinder(p * rotZ(-0.68 * M_PI) - offset, 0.04, 0.61 ));\n    star = Union(star, Cylinder(p * rotZ(-0.32 * M_PI) - offset, 0.04, 0.61 ));\n\n    return Union(frame, star);\n}\n\n// ----------------\n//  surface normal\n// ----------------\nvec3 SurfaceNormal(in vec3 pos, in mat3 matrix)\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    return normalize(-vec3(Pentagram((pos + eps.xyy) * matrix) - Pentagram((pos - eps.xyy) * matrix),\n                           Pentagram((pos + eps.yxy) * matrix) - Pentagram((pos - eps.yxy) * matrix),\n                           Pentagram((pos + eps.yyx) * matrix) - Pentagram((pos - eps.yyx) * matrix)));\n}\n\n// ----------------------\n//  pentagram raymarcher\n// ----------------------\n#define MIN_DIST  0.001\n#define MAX_DIST  3.0\n#define NUM_STEPS 50\nfloat Raymarch(in vec3 from, in vec3 to, in mat3 matrix)\n{\n    float dist  = MIN_DIST;\n    float depth = 0.0;\n\n    for(int i = 0; i < NUM_STEPS; ++i)\n    {\n        if(dist < MIN_DIST || depth > MAX_DIST) \n            break;\n\n        dist  = Pentagram((from + to * depth) * matrix);\n        depth += dist;\n\n        // past maximum raymarch distance - no surface hit\n        if(depth > MAX_DIST)\n            return 0.0;\n    }\n\n    return depth;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n    vec2 pos = 2.0 * uv - 1.0;\n    vec2 bgPos = uv * vec2(0.0666);\n    pos.x   *= ratio;\n    bgPos.x *= ratio;\n\n    // raymarch vectors and initial background pixel color\n    vec3 from  = vec3(0.0, 0.0, -1.666);\n    vec3 to    = normalize(vec3(pos.xy, 1.666));\n    vec3 color = Background(bgPos);\n\n    // pentagram rotation\n    mat3 transform = rotY(iTime);\n\n    float t = Raymarch(from, to, transform);\n\n    // surface hit?\n    if(t > 0.0)\n    {\n        vec3 p = from + t * to;\n        vec3 n = SurfaceNormal(p, transform);\n\n        vec3 tx = texture(iChannel0, p.yz + 0.1666 * iTime).xyz * n.x * 4.666;\n        vec3 ty = texture(iChannel0, p.xz + 0.2666 * iTime).xyz * n.y * 3.666;\n        vec3 tz = texture(iChannel0, p.xy + 0.3666 * iTime).xyz * n.z * 2.666;\n\n        // BLOOD!\n        color.r  = clamp((tx + ty + tz) * 0.333, 0.0, 1.0).r;\n        color.gb = vec2(0.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[288, 464, 497, 497, 592], [594, 594, 646, 646, 696], [698, 698, 738, 738, 763], [765, 765, 804, 804, 830], [832, 832, 875, 875, 901], [903, 946, 969, 969, 1083], [1085, 1085, 1108, 1108, 1219], [1221, 1221, 1244, 1244, 1367], [1369, 1455, 1485, 1485, 1856], [1858, 1950, 1978, 2011, 2849], [2851, 2910, 2959, 2959, 3309], [3311, 3455, 3513, 3513, 3899], [3901, 3901, 3956, 3956, 4968]]}
{"id": "ld2BWG", "name": "Floating bubbles in room.", "author": "Cierpliwy", "description": "Simple shader with shadows.", "tags": ["3d"], "likes": 5, "viewed": 134, "date": "1502030625", "time_retrieved": "2024-06-20T18:59:42.465754", "image_code": "#define MAX 10.0\n#define N 3.0\n#define PI 3.14159265359\n#define time iTime\n\nfloat map(vec3 p) {\n    float d = MAX;\n    for (float i = 0.; i < N; i++) {\n        for (float j = 0.; j < N; j++) {\n            float a = PI * i / N + time * 0.1;\n            float b = 2.0 * PI * j / N;\n            vec3 p2 = vec3(sin(a+time*0.1)*sin(b+time), sin(a)*cos(b), cos(a));\n        \td = min(d, length(p-p2) - 0.2);\n        }\n    }\n\n    d += 0.01 * (sin(time + 20.*p.x + p.z) + cos(time + 20.*p.y));\n    d = min(d, abs(p.y + 1.5));\n    d = min(d, abs(p.z - 3.5));\n    d = min(d, abs(abs(p.x) - 3.5));\n    d = min(d, length(p-vec3(2,-1.4,0)) - 1.0 + sin(p.y*10.)*0.1);\n    return d;\n}\n\nfloat march(vec3 o, vec3 r) {\n    float t = 0.0;\n    for(int i = 0; i < 64; i++) {\n        vec3 p = o + r  *t;\n \t\tfloat d = map(p);\n        t += d * 0.47;\n        if (t > MAX || t < 0.01) break;\n    }\n    return t;\n}\n\nfloat shadow(vec3 o, vec3 r) {\n    float t = 0.0;\n    for(int i = 0; i < 32; i++) {\n        vec3 p = o + r  *t;\n \t\tfloat d = map(p);\n        t += d * 0.4;\n        if (t > MAX || t < 0.01) break;\n    }\n    return t;\n}\n\nfloat light(vec3 o, vec3 r, vec3 p2) {\n    float t = 0.0;\n    for(int i = 0; i < 8; i++) {\n        vec3 p = o + r * t;\n \t\tfloat d = length(p - p2) - 0.01;\n        t += d * 0.9;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec3 eps = vec3(0.0001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t   map(pos+eps.xyy) - map(pos-eps.xyy),\n\t   map(pos+eps.yxy) - map(pos-eps.yxy),\n\t   map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat fog(in float t) {\n    return 1.0 / (1.0 + t * t * 0.05);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Normal eye\n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0, 0.0, -3.0);\n    \n    // Get distance and hit point\n    float d = march(o, r);\n    vec3 p = o + r * d;\n    \n    // Shadow eye\n    vec3 so = vec3(sin(time), cos(time) + 1.0, 0.5*sin(time) - 0.0);\n    \n    // Get shadow ray parameters\n    vec3 srt = p - so;\n    vec3 sr = normalize(srt);\n    float sd = srt.x / sr.x;\n    float sd2 = shadow(so, sr);\n    float diff = clamp(100.0 * (sd - sd2), 0.0, 1.0);\n\n    // Calculate color\n    vec3 color = vec3(fog(d));\n    \n    // Mix color with shadow\n    color = (1.0 - diff * 0.2) * color;\n    \n    // Draw Light Source\n    float ld = light(o, r, so);\n    ld = ld - length(p - so);\n    ld = 1.0 - clamp(ld, 0.0, 1.0);\n    color = (vec3(1., 1., 1.) * ld) + color * (1.0 - ld);\n    \n    // Draw light\n    vec3 n = normal(p);\n    vec3 ray = normalize(so - p);\n    vec3 r2 = ray - 2.0 * dot(ray, n) * n;\n    float ra = clamp(dot(r, r2), 0.0, 1.0);\n    ra = ra * 0.2 * (1.0 - diff);\n    color = (vec3(0., 1., 1.) * ra) + color * (1.0 - ra);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[76, 76, 95, 95, 668], [670, 670, 699, 699, 886], [888, 888, 918, 918, 1104], [1106, 1106, 1144, 1144, 1304], [1306, 1306, 1332, 1332, 1537], [1539, 1539, 1562, 1562, 1603], [1609, 1609, 1666, 1666, 2877]]}
{"id": "ld2BWy", "name": "Music Visualizer Test", "author": "Hendrik_King123", "description": "Test", "tags": ["music"], "likes": 1, "viewed": 141, "date": "1502213769", "time_retrieved": "2024-06-20T18:59:42.738119", "image_code": "#define MAX_DIST 0.15\n#define FADE_BEGIN 0.12\n#define PI 3.14159265359\n\n#define SIN_X_SCALE 100.0\n#define SIN_Y_SCALE 12.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res_rel = iResolution.y / iResolution.x;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 center_value = vec2(abs(uv - 0.5));\n    \n    center_value = vec2(center_value.x, center_value.y * res_rel);\n    \n    float dist = length(center_value);\n    float angle_to_center = atan(center_value.y / center_value.x);\n    float apos = (angle_to_center + PI) / (2.0 * PI);\n    \n    int tx = int(apos*512.0);\n    \n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    float freq = texelFetch( iChannel0, ivec2(0,0), 0).x;\n    \n    wave = wave / 0.5;\n    \n    float modify = wave;\n    float out_value = (dist*modify < MAX_DIST) ? (dist-FADE_BEGIN) *(1.0/(MAX_DIST-FADE_BEGIN)) : 0.0;\n    float sin_dist =abs(1.0 - abs((sin(uv.x*freq*SIN_X_SCALE)+SIN_Y_SCALE/2.0)/SIN_Y_SCALE-uv.y ));\n    \n    sin_dist = (sin_dist > 0.998)? sin_dist : 0.0;\n    sin_dist = (length(center_value) < FADE_BEGIN)? sin_dist : 0.0;\n    \n    vec3 bg_color = vec3(uv,0.5+0.5*sin(iTime));\n    \n    bg_color.x = (out_value > 0.0)? ((out_value < 1.0) ? abs(bg_color.x-0.3*out_value) : abs(bg_color.x-0.3)) : bg_color.x;\n    bg_color.y = (out_value > 0.0)? ((out_value < 1.0) ? abs(bg_color.y-0.3*out_value) : abs(bg_color.y-0.3)) : bg_color.y;\n    bg_color.z = (out_value > 0.0)? ((out_value < 1.0) ? abs(bg_color.z-0.3*out_value) : abs(bg_color.z-0.3)) : bg_color.z;\n    \n    bg_color.x = (sin_dist > 0.0)? abs(bg_color.x-0.3) : bg_color.x;\n    bg_color.y = (sin_dist > 0.0)? abs(bg_color.y-0.3) : bg_color.y;\n    bg_color.z = (sin_dist > 0.0)? abs(bg_color.z-0.3) : bg_color.z;\n    \n\tfragColor = vec4(bg_color,1.0);\n}\n\n", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2BWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[123, 123, 180, 180, 1786]]}
{"id": "ld2fDG", "name": "testing1231313", "author": "jnalanko", "description": "test", "tags": ["sdf"], "likes": 0, "viewed": 90, "date": "1502055188", "time_retrieved": "2024-06-20T18:59:42.738381", "image_code": "mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m)*vec4(p,1)).xyz;\n    return sdBox(q,vec3(1,2,1));\n}\n\n\nfloat sdf(vec3 p){\n\t//return sqrt(p.z*p.z + p.y*p.y) - 1.0;   \n    //return sdBox(p,vec3(1,2,1));\n    //return opTx(p, rotationMatrix(vec3(1,1,1), iTime));\n    mat4 m = rotationMatrix(vec3(1,1,1), iTime);\n    vec3 rep = vec3(0.5,0.5,0.5);\n    vec3 p2 = (inverse(m)*vec4(p,1)).xyz; // Rotate\n    vec3 p3 = mod(p2,rep)-0.5*rep; // Repeat\n    return sdBox(p3,vec3(1,2,1));\n}\n\nvec3 get_normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.01,0,0);\n\treturn normalize(vec3(\n\t\tsdf(pos + eps.xyy) - sdf(pos - eps.xyy),\n\t\tsdf(pos + eps.yxy) - sdf(pos - eps.yxy),\n\t\tsdf(pos + eps.yyx) - sdf(pos - eps.yyx)\n\t));\n}\n\n// Clamped dot\nfloat cdot(vec3 a, vec3 b){\n    return max(0.0,dot(a,b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Fix coordinate system\n    float aspect_ratio = 16.0/9.0;\n\tvec2 pixel_pos = fragCoord.xy / iResolution.xy; // [0,1]\n    pixel_pos -= vec2(0.5,0.5); // [-1/2, 1/2]\n    pixel_pos *= vec2(2,2); // [-1,1]\n    pixel_pos.x *= aspect_ratio;\n    \n    // Raymarch\n    vec3 ray = vec3(pixel_pos.x, pixel_pos.y,-1);\n    vec3 v_0 = vec3(0,0,5); // Camera position\n    vec3 pos = v_0;\n    for(int step = 0; step < 30; step++){\n  \t\tpos += ray * sdf(pos)*0.98;\n    }\n    \n    // Phong: k_s * cos(alpha)^q * intensity / r^2\n    float sun_intensity = 70.0;\n    //vec3 sun = vec3(30.0 * sin(iTime),20,30.0*cos(iTime));\n    vec3 sun = vec3(0,0,50);\n    float k_s = 20.0;\n    float q = 2.0;    \n    \n    if(sdf(pos) > 0.1) // No hit\n        fragColor = vec4(0.1,0.1,0.3,1);\n    else{\n        vec3 surface = pos;\n        vec3 normal = get_normal(surface);\n        vec3 l = surface - sun; // Sun to surface\n        float intensity_at_surface = sun_intensity / dot(l,l); // Inverse square decay\n        \n    \tvec3 l_prime = l + 2.0*dot(l,normal)*normal;\n        vec3 to_camera = v_0 - surface;\n        float cos_angle = cdot(-l_prime, to_camera)/(length(l_prime) * length(to_camera));\n        float specular = k_s * pow(cos_angle,q) * intensity_at_surface;\n        float diffuse = 0.2 * cdot(normal, -l) * intensity_at_surface;\n        float ambient = 0.05;\n        vec3 light = vec3(clamp(diffuse + specular + ambient,0.0,1.0));\n        fragColor = vec4(light.x*0.2, light.y, light.z,1);\n    }\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2fDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 45, 45, 673], [675, 675, 706, 706, 793], [796, 796, 831, 831, 855], [857, 857, 890, 890, 955], [957, 957, 987, 987, 1063], [1066, 1066, 1084, 1221, 1437], [1439, 1439, 1466, 1466, 1653], [1655, 1670, 1697, 1697, 1729], [1731, 1731, 1788, 1822, 3274]]}
{"id": "ld2fDt", "name": "Polar_Mapping", "author": "zhaxiu3", "description": "learn how to use polar mapping", "tags": ["basic"], "likes": 1, "viewed": 132, "date": "1502900097", "time_retrieved": "2024-06-20T18:59:42.738381", "image_code": "\n#define PI 3.1415926535\n#define _Color vec4(1.0)\n#define mul(x) ((x)*(x)*2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor;\n\tvec2 uv = 2.0* fragCoord.xy / iResolution.y -vec2(iResolution.x/iResolution.y, 1.0);\n    \n\n\tfloat angle = atan(uv.y, uv.x)/ PI*0.5;\n\tfloat radius = length(uv);\n    \n    #define CutRing(ds, dl, dw, dr) (step(fract(angle+iTime*(ds)),dl)*(dw)/(dr))\n    #define Radi(r) (abs(radius-(r)))\n    float col = CutRing(0.3,0.5,0.005,mul(Radi(0.3)));\n    \n    col += CutRing(0.1,0.6,0.01,mul(Radi(0.45)))\n        +CutRing(0.2,0.5,0.001,mul(Radi(0.55)))\n        +CutRing(0.05,0.3,0.007,mul(Radi(0.65)))\n        +CutRing(0.2,0.7,0.03,mul(Radi(0.8)))\n        +CutRing(0.2,1.0,0.02,Radi(0.8));\n    col /=6.0;\n    fragColor = col*_Color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2fDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[80, 80, 137, 137, 789]]}
{"id": "ldBBWd", "name": "Gearworld", "author": "Vovosunt", "description": "Simple layered gears", "tags": ["t"], "likes": 7, "viewed": 106, "date": "1502729052", "time_retrieved": "2024-06-20T18:59:43.029282", "image_code": "#define c30     (1.0 / 0.86602540378)\t\n#define thick   0.04\n#define smooth  0.001\n#define PI      3.14159265359\n#define grid    30.0\n#define timeScale 0.1\n#define rt      (iTime / timeScale)\n#define gears   (20.0 * PI)\n#define gears2  (12.0 * PI)\n#define size    4.0\n#define size2   2.0\n\nfloat rand(vec3 v){\n    return fract(cos(dot(v,vec3(13.46543,67.1132,123.546123)))*43758.5453);\n}\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3132)))*43758.5453);\n}\n\nfloat layer(float col, vec2 st, float scale, float lcol){\n    st = st * scale;\n    float r = rand(floor(st));\n    vec2 st2 = fract(st + 0.5) - 0.5;\n    float r2 = rand(floor(st  + 0.5)+ 12345.);\n    st = fract(st) - 0.5;\n    float a = (atan(st.x,st.y) + PI) /PI /2.;\n    float l = length(st);\n    \n    float col1 = smoothstep(smooth*700.0,-smooth*700.0,cos(a*gears - rt)) * 0.025 * size + 0.1* size;\n    col1 = smoothstep(col1,col1 + smooth,l) + smoothstep(smooth*2.0,-smooth*2.0,l-0.03 * size);;\n    \n    float a2 = (atan(st2.x,st2.y) + PI) /PI /2.;\n    float l2 = length(st2);\n    \n    float col2 = smoothstep(smooth*700.0,-smooth*700.0,cos(a2*gears2 + rt + PI)) * 0.05 * size2 + 0.1* size2;\n    col2 = smoothstep(col2,col2 + smooth,l2) + smoothstep(smooth*2.0,-smooth*2.0,l2-0.03 * size2);\n    float fin = mix(step(r,0.5),1.0,col1);\n    fin  = mix(step(r2,0.5), fin,col2);\n   \tfin = mix(lcol,col,fin);\n    return fin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = gl_FragCoord.xy/iResolution.x;\n    \n    float fin = layer(0.0,st + 25.,11.0,0.25);\n    fin = layer(fin,st + 11.,23.0,0.5);\n    fin = layer(fin,st + 23.,21.0,0.75);\n    fin = layer(fin,st,16.0,1.);\n    fragColor = vec4(fin);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBBWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[288, 288, 307, 307, 385], [386, 386, 405, 405, 471], [473, 473, 530, 530, 1395], [1397, 1397, 1453, 1453, 1693]]}
{"id": "ldjBDm", "name": "Keynote Hex Background", "author": "mplanck", "description": "Used for a keynote slide presentation background. Subtle and dark on purpose so not to make too distracting from slide content. I slowed down the animation and darkened color a bit more for final usage. Amplified here for demo.", "tags": ["background", "hex"], "likes": 11, "viewed": 432, "date": "1503287996", "time_retrieved": "2024-06-20T18:59:43.502160", "image_code": "// inspired by and copied from iq:\n// https://www.shadertoy.com/view/Xd2GR3\n\n#define TWO_PI 6.283185\n\nvec3 iq_color_palette(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b * cos(TWO_PI * (c*t + d));\n}\n\n// copied from iq\n// { 2d cell id, distance to border, distance to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\n// copied from iq\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\n// copied from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\t\n    float t = .8 * (1. - pow(uv.y, .5));\n    pos.y += -.5;\n\tpos *= 2. - 0.3*pos.y;\n    \n    vec4 h = vec4(0.);\n    float n = 0.;\n    vec3 col = vec3(0.);\n\n\th = hexagon(12.0*pos);\n    n = noise( vec3(0.3*h.xy+vec2(iTime*.7, 0.),0.) );\n    t += .2 * (1. - n);\n    \n\tcol = .5 * abs(sin( hash1(h.xy)*.4 + 1.6 + vec3(1.) ));\n\tcol *= smoothstep( 0.0+t, 0.1+t, h.z );\n\tcol *= 1. + 0.5*h.z*n;        \t\n    col *= 1. + .5 * iq_color_palette(vec3(0.5, 0.5, 0.5),\n                                 vec3(0.5, 0.5, 0.5),\n                                 vec3(2.0, 1.0, 0.0),\n                                 vec3(0.5, 0.2, 0.25),\n                                 iTime * .02);\n    col *= .7 + .3 * iq_color_palette(vec3(.5, .5, .5),\n                                      vec3(.5, .5, .5),\n                                      vec3(.3, 1., 1.),\n                                      vec3(0., .25, .25),                                      \n\t        uv.y-.8-iTime*.05);\n\tcol *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.4 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 102, 166, 166, 212], [214, 290, 315, 315, 826], [828, 846, 870, 870, 942], [944, 962, 988, 988, 1196], [1199, 1199, 1257, 1257, 2415]]}
{"id": "ldjBWy", "name": "aasdgasdafasdg", "author": "jnalanko", "description": "aaaaa", "tags": ["sdf"], "likes": 0, "viewed": 104, "date": "1502056034", "time_retrieved": "2024-06-20T18:59:43.502160", "image_code": "mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m)*vec4(p,1)).xyz;\n    return sdBox(q,vec3(1,2,1));\n}\n\n\nfloat sdf(vec3 p){\n\t//return sqrt(p.z*p.z + p.y*p.y) - 1.0;   \n    //return sdBox(p,vec3(1,2,1));\n    //return opTx(p, rotationMatrix(vec3(1,1,1), iTime));\n    mat4 m = rotationMatrix(vec3(1,1,1), iTime);\n    vec3 rep = vec3(10,10,10);\n    p = mod(p,rep)-0.5*rep; // Repeat\n    p = (inverse(m)*vec4(p,1)).xyz; // Rotate\n    return max(-sdSphere(p,1.8),sdBox(p,vec3(1.0 + sin(iTime),2,1)));\n}\n\nvec3 get_normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.01,0,0);\n\treturn normalize(vec3(\n\t\tsdf(pos + eps.xyy) - sdf(pos - eps.xyy),\n\t\tsdf(pos + eps.yxy) - sdf(pos - eps.yxy),\n\t\tsdf(pos + eps.yyx) - sdf(pos - eps.yyx)\n\t));\n}\n\n// Clamped dot\nfloat cdot(vec3 a, vec3 b){\n    return max(0.0,dot(a,b));\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvec3 gamma(vec3 c) {\n\treturn pow(c, vec3(1.6/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Fix coordinate system\n    float aspect_ratio = 16.0/9.0;\n\tvec2 pixel_pos = fragCoord.xy / iResolution.xy; // [0,1]\n    pixel_pos -= vec2(0.5,0.5); // [-1/2, 1/2]\n    pixel_pos *= vec2(2,2); // [-1,1]\n    pixel_pos.x *= aspect_ratio;\n    \n    vec3 v_0 = vec3(cos(0.5*iTime)*10.0,sin(0.5*iTime)*15.0, 5.0 - iTime*10.0); // Camera position\n    mat4 camera_roll = rotationMatrix(vec3(0,0,-1), 0.0);\n    mat4 camera_pitch = rotationMatrix(vec3(1,0,0), -atan(0.5*cos(iTime))*0.4);\n    mat4 camera_yaw = rotationMatrix(vec3(0,1,0), 0.0);\n    \n    // Raymarch\n    vec3 ray = normalize(vec3(pixel_pos.x, pixel_pos.y,-1));\n    ray = (camera_yaw * camera_pitch * camera_roll * vec4(ray,1)).xyz;\n    \n    vec3 pos = v_0;\n    for(int step = 0; step < 50; step++){\n  \t\tpos += ray * sdf(pos)*0.8;\n    }\n    \n    // Phong: k_s * cos(alpha)^q * intensity / r^2\n    float sun_intensity = 5.0;\n    vec3 background = vec3(0.01,0.01,0.01);\n    //vec3 sun = vec3(30.0 * sin(iTime),20,30.0*cos(iTime));\n    vec3 sun = v_0 + vec3(0,10,-20);\n    float k_s = 1.0; // Specular coefficient\n    float q = 2.0; // Specular exponent\n    \n    vec3 diffuse_color = vec3(0.2,0.8,0.4);\n    vec3 ambient_color = vec3(0.6,1,0.6);\n    vec3 specular_color = vec3(0.7,1,0.7);\n    \n    if(sdf(pos) > 0.05) // No hit\n        fragColor = vec4(background,1);\n    else{\n        vec3 surface = pos;\n        vec3 normal = get_normal(surface);\n        vec3 l = surface - sun; // Sun to surface\n        float intensity_at_surface = sun_intensity / dot(l,l); // Inverse square decay\n        \n    \tvec3 l_prime = l + 2.0*dot(l,normal)*normal;\n        vec3 to_camera = v_0 - surface;\n        float cos_angle = cdot(-l_prime, to_camera)/(length(l_prime) * length(to_camera));\n        vec3 specular = specular_color * k_s * pow(cos_angle,q) * intensity_at_surface;\n        vec3 diffuse = diffuse_color * 0.2 * cdot(normal, -l) * intensity_at_surface;\n        vec3 ambient = ambient_color * 0.01;\n        vec3 light = vec3(clamp(diffuse + specular + ambient,0.0,1.0));\n        float fogfactor = clamp(length(pos-v_0)/200.0,0.0,1.0);\n        //fogfactor = 0.0;\n        vec3 finallight = vec3(light.x, light.y, light.z);\n        finallight = mix(finallight, background, fogfactor);\n        finallight = gamma(filmicToneMapping(finallight));\n        fragColor = vec4(finallight,1);\n    }\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 45, 45, 673], [675, 675, 706, 706, 793], [796, 796, 831, 831, 855], [857, 857, 890, 890, 955], [957, 957, 987, 987, 1063], [1066, 1066, 1084, 1221, 1457], [1459, 1459, 1486, 1486, 1673], [1675, 1690, 1717, 1717, 1749], [1751, 1751, 1787, 1787, 1927], [1929, 1929, 1949, 1949, 1982], [1984, 1984, 2041, 2075, 4386]]}
{"id": "ldjfDd", "name": "Digital fish tank", "author": "marcthenarc", "description": "Played with samples in The Book of Shaders.  ", "tags": ["2d", "noise"], "likes": 0, "viewed": 103, "date": "1502926979", "time_retrieved": "2024-06-20T18:59:43.502160", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n    vec2(12.9898,78.233)))*\n    43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv *= 30.;\n\n    vec2 floor1 = floor(uv);\n    float neg = (floor(floor1.y / 2.) * 2. == floor1.y) ? 1. : -1.;\n    uv.x += neg * iTime * 20. * fract(random(vec2(floor1.y, 64.)));\n\n    float rnd = random(floor(uv)) * 100.; // Saturate it so that random single bits stick out.\n    \n    fragColor = vec4(vec3(rnd, sin(iTime * 0.1), cos(iTime * 0.2)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjfDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 106], [108, 108, 165, 165, 568]]}
{"id": "ldSBD3", "name": "Infinite Yin Yangs 2", "author": "KilledByAPixel", "description": "Endless zooming yin yangs with some values tweaked to make the dots larger. I think this one kind of looks like a face.", "tags": ["procedural", "2d", "fractal", "zoom", "recursion"], "likes": 24, "viewed": 4840, "date": "1502422006", "time_retrieved": "2024-06-20T18:59:44.368792", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yang Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.4;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.08;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst float saturation\t\t\t= 0.4;\t// how much to scale saturation (0 == black and white)\nconst float turnSpeed\t\t\t= 0.7;\t// how fast to rotate (0 = no rotation)\nconst int   recursionCount\t\t= 10;\t// how deep to recurse\nconst float dotSize \t\t\t= 0.6;\t// how much to scale recursion at each step\nconst float blur\t\t\t\t= 5.0;\t// how much blur\nconst float outline\t\t\t\t= 0.12;\t// how thick is the outline\nconst float timeWarp\t\t\t= 1.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n    \nconst float pi = 3.14159265359;\nconst float e = 2.718281828459;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nvec2 Rotate(vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2((p.x*c - p.y*s), (p.x*s + p.y*c));\n}\nvec4 HsvToRgb(vec4 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec4(s_n) + vec4(s) * cos(2.0 * pi * (c.x + vec4(1.0, 0.6666, .3333, 1.0)));\n}\n\nfloat GetFocusRotation(int i) \n{ \n    float theta = 2.0*pi*RandFloat(i);\n    float s = mix(-1.0, 1.0, RandFloat(30+i));\n    //s += ((s < 0.0)? -.5 : 0.5);\n    return theta + turnSpeed*s*iTime; \n}\n\nvec2 GetFocusPos(int i) \n{ \n    bool side = (RandFloat(50+i) < 0.5);\n    vec2 p = vec2(0.0, side? -0.5 : 0.5); \n    return Rotate(p, GetFocusRotation(i));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat YinYang2( vec2 p, out float dotDistance, float co, float scale)\n{\n   \tfloat b = blur*scale/min(iResolution.y, iResolution.x);\n    float d = dotSize;\n    \n    float c = 1.0;\n    float r;\n    \n    // bottom\n    r = length(2.0*p + vec2(0, 1));\n    if (p.x < 0.0)\n\t   c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, r));\n    dotDistance = r;\n    \n    // top\n    r = length(2.0*p - vec2(0, 1));\n    if (p.x >= 0.0)\n\t\tc = mix(0.0, c, smoothstep(1.0-b, 1.0+b, r));\n    if (p.y >= 0.0)\n         dotDistance = r;\n    \n    // outline\n    r = length(p);\n    c = mix(c, co, smoothstep(1.0-b, 1.0, r));\n    \n    return c;\n}\n\nvec4 RecursiveYinYang(vec2 p, int iterations, float scale)\n{\n    // recursive iteration\n    float co = 0.0;\n    for (int r = 0; r < recursionCount; ++r)\n    {\n        // apply rotation\n  \t\tfloat theta = -GetFocusRotation(iterations + r);\n        p = Rotate(p, theta);\n        \n        float dotDistance = 0.0;\n        co = YinYang2(p, dotDistance, co, scale);\n        \n        if (dotDistance > dotSize || r == recursionCount)\n        {\n            float co2 = (p.y < 0.0)? 0.0 : 1.0;\n   \t\t\tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n            \n            co = mix(co2, co, smoothstep(dotSize+outline,dotSize+outline+b,dotDistance));\n            int i2 = (dotDistance < dotSize+outline+b && p.y > 0.0)? 1 : 0;\n            float hue = 0.233*float(iterations + r + i2);\n            return vec4(hue, saturation*co, co, 1.0); // stop if outside or reached limit\n        }\n     \t\n\t\t// check if top or bottom\n        co = (p.y > 0.0)? 1.0 : 0.0;\n        p.y += mix(0.5, -0.5, co);\n        \n        scale *= 2.0/dotSize;\n        p *= 2.0/dotSize;\t\t// apply recursion scale\n        p = Rotate(p, -theta);\t// cancel out rotation\n    }\n    return vec4(0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n    // fixed aspect ratio\n\tvec2 p = (2.0*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 p2 = p;\n    \n    // wander center\n\tp.x += 0.5*sin(0.234*iTime);\n\tp.y += 0.5*sin(0.2*iTime);\n    \n    // time warp\n    float time = iTime + timeWarp*length(p);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n    \n\t// update zoom, apply pow to make rate constant\n    const float recursionSize = 2.0 / dotSize;\n\tfloat zoom = pow(e, -log(recursionSize)*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get focus offset\n\tvec2 offset = GetFocusPos(iterations);\n\tfor (int i = 0; i < 10; ++i)\n\t\toffset += (GetFocusPos(iterations+i+1) / recursionSize) * pow(1.0 / recursionSize, float(i));\n    \n    // apply zoom and offset\n\tp = p*zoom + offset;\n    \n    // make the yin yang\n    color = RecursiveYinYang(p, iterations, zoom);\n    \n    // wander hue\n    color.x += (0.1*p2.y + 0.1*p2.x + 0.05*time);\n    \n    // map to rgp space\n    color = HsvToRgb(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[932, 1084, 1108, 1108, 1154], [1155, 1155, 1189, 1189, 1294], [1295, 1295, 1319, 1319, 1464], [1466, 1466, 1498, 1498, 1661], [1663, 1663, 1689, 1689, 1819], [1821, 1905, 1976, 1976, 2514], [2516, 2516, 2576, 2603, 3678], [3680, 3764, 3810, 3836, 4844]]}
{"id": "ldSBDG", "name": "drawing shapes in shaders", "author": "jaman4dbz", "description": "fghfgh", "tags": ["shapes"], "likes": 0, "viewed": 72, "date": "1501892853", "time_retrieved": "2024-06-20T18:59:44.374904", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float px = fragCoord.x / iResolution.x;\n    float py = fragCoord.y / iResolution.y;\n    \n    float width = 0.01;\n    \n    float vBlock = step(width, mod(px, width * 2.0));\n    float hBlock = step(width, mod(py, width * 2.0));\n    \n    vec4 final = vec4(vBlock * hBlock);\n    \n    //add a sin wave\n    float lineWidth = 0.02;\n    float squareWidth = 0.1;\n    float radius = 0.05;\n    vec2 squarePosition = vec2(0.5, 0.5);\n    \n    if(final.r + final.g + final.b < 2.9) {\n        //draw sin wave based on time\n    \tfinal.r = step(-lineWidth, -abs(sin((px * 2.0 * 3.14) + iTime) - ((py * 2.0) - 1.0)));\n\t\t//draw a square between x 0.4 and 0.6 and y 0.4, and 0.6\n        final.g = step(-squareWidth, -abs(px - squarePosition.x))\n            * step(-squareWidth, -abs(py - squarePosition.y));\n        //Note: step is like an if statement, without being an if statement\n       \t//\t\tconditionals make shaders slow, so step is used instead\n        \n        //draw blue near the mouse cursor\n        final.b = step(-radius, -abs(px - iMouse.x / iResolution.x))\n            * step(-radius, -abs(py - iMouse.y / iResolution.y));\n    }\n\tfragColor = final;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1211]]}
{"id": "ldSBDK", "name": "Ball in a Room", "author": "slerpy", "description": "A ball in a room with a lot of reflections", "tags": ["reflection", "simple", "raytracer"], "likes": 8, "viewed": 180, "date": "1502185864", "time_retrieved": "2024-06-20T18:59:44.374904", "image_code": "#define TAU 6.28318530718\n\n#define FAR 25.\n#define ITER 128\n#define QUA .001\n#define NORK 5e-4\n\n#define REF 0.56\n#define RITER 16\n#define RRFB .001\n\n#define BRG 0.83\n\nfloat map(vec3 p)\n{\n    float d = FAR;\n\td = min(d, length(p-vec3(0.75,vec2(.0)))-1.);\t// center ball\n\td = min(d, 5. - abs(p.x));\t\t\t\t\t\t// left & right wall\n\td = min(d, 3. - abs(p.y - 2.));\t\t\t\t\t// floor & ceil\n\td = min(d, 5. - abs(p.z));\t\t\t\t\t\t// front & back wall\n\treturn d;\n}\n\nvec3 normal(vec3 p, float k)\n{\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tmap(p) - map(p - e.yxx),\n\t\tmap(p) - map(p - e.xyx),\n\t\tmap(p) - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t || t > FAR) break;\n        t += d;\n    } \n    return t + QUA;\n}\n\nfloat hard_shadow(vec3 sp, vec3 lp, int iter)\n{   \n\tvec3 p, ld = normalize(sp - lp);\n\n\tfloat t = .0;\n\tfor(int i = 0; i < iter; i++)\n\t{\n\t\tp = lp + ld * t;\n\t\tfloat m = map(p);\n\t\tif (m < .0 || t > FAR) break;\n\t\tt += m;\n\t}\n\n\treturn max(1. - distance(p, sp), 0.);\n}\n\nvec3 color(vec3 sp, vec3 sn)\n{   \n    vec3 lp = vec3(-1, 1, -2);\n\tvec3 ld = normalize(lp - sp);\n    \n    float diff = max(dot(sn,ld),0.);\n    float shd = hard_shadow(sp, lp, 30);\n    \n    vec3 col = (sn.xyz+1.)/2.;\n    return col * diff * shd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    if(fract((iTime-5.)/20.) < 0.5) uv.x *= -1.0;\n    \n\tvec3 ro = vec3(abs(10. - mod(iTime-5.,20.)) - 5., .0, -3.);\n    vec3 rd = normalize(vec3(uv,2.));\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n\tvec3 sn = normal(sp,NORK);\n    \n    vec3 col = color(sp, sn);\n    \n    for(int i=0; i<RITER; i++)\n    {\n        if(t > FAR) break;\n            \n        rd = normalize(reflect(rd, sn));\n        ro = sp + rd * RRFB;\n        \n        t = tracer(ro, rd);\n        \n        sp = ro + rd * (t - RRFB);\n\t\tsn = normal(sp,NORK);\n    \n        col += color(sp, sn) * pow(REF, float(i) + 1.);\n    }\n    \n\tfragColor = BRG * vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[167, 167, 186, 186, 441], [443, 443, 473, 473, 606], [608, 608, 640, 640, 820], [822, 822, 869, 869, 1082], [1084, 1084, 1114, 1114, 1329], [1331, 1331, 1388, 1388, 2090]]}
{"id": "ldSBDV", "name": "No Signal", "author": "k_kondrak", "description": "TV \"space noise\" in one Tweet.", "tags": ["procedural", "noise", "tv", "onetweet"], "likes": 5, "viewed": 550, "date": "1502214296", "time_retrieved": "2024-06-20T18:59:44.374904", "image_code": "// ----------------------------------------------------\n//  \"No Signal\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    float r = fract(cos(p.x*42.98 + p.y*43.23) * 1427.53) * iTime;\n\tc = vec4(.5 * r * sin(45. * r));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSBDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 161, 200, 200, 303]]}
{"id": "ldSfD3", "name": "BubbleVerse 152 chars", "author": "coyote", "description": "So much happening in first 15 seconds with so few characters. :)\n\nBased on phenomenal [url]https://www.shadertoy.com/view/MsjfDK[/url]", "tags": ["2d", "short", "tweet"], "likes": 6, "viewed": 486, "date": "1502433009", "time_retrieved": "2024-06-20T18:59:44.575292", "image_code": "//practically the same as benoitM's https://www.shadertoy.com/view/MsjfDK\n//only differences are the constants and swizzling\n\n//define mainImage does not work anymore.\n//well, it was nice while it lasted...\nvoid mainImage( out vec4 o, vec2 u ) {\n    o = 20.*vec4((u+u-(o.xy=iResolution.xy))/o.y, iTime*.1,0);\n    for(int i=0; i++ < 33;)               \\\n        o.wxzy = abs( o/dot(o,o) - vec4(.8,.2,.01,.4) );\n}\n\n//136 chars by Fabrice\n/*\nvoid mainImage(out vec4 o, vec2 u){                                         \\\n    o.xy = 20.*(u+u- (o.xy=iResolution.xy) )/o.y,\n     o.z = 2. * iTime;\n    for(int i=0; i++ < 33;)\n        o.wxzy = abs( o/dot(o,o) - .1*vec4(8,2,.1,4) );}           /*\n\n//original 138\n\n#define mainImage( o, u )                   \\\n    o = 20.*vec4((u+u-(o.xy=iResolution.xy))/o.y, iTime*.1,0); \\\n    for(int i=0; i++ < 33;)               \\\n        o.wxzy = abs( o/dot(o,o) - vec4(.8,.2,.01,.4) )\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSfD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[126, 207, 245, 245, 411]]}
{"id": "ldSfW3", "name": "Mesmerizing Spiral", "author": "Homaniac", "description": "Interesting effect from modulating the amplitude and frequency of sin waves over time.", "tags": ["simple", "sin", "rgb"], "likes": 2, "viewed": 164, "date": "1502411191", "time_retrieved": "2024-06-20T18:59:44.575292", "image_code": "#define PI 3.14159265359\n#define NUM_PI_DIVS 8.0\n\n#define PI_DIV PI/NUM_PI_DIVS\n#define HALF_PI_DIV PI_DIV*0.5\n#define THIRD_PI_DIV PI_DIV/3.0\n\n#define SMOOTH_HALF_INTERVAL HALF_PI_DIV*0.5\n\n#define SIN_AMP_MAX HALF_PI_DIV*3.0\n#define SIN_AMP_TIME_AMP 3.0\n#define SIN_FREQ_MAX 10.0\n#define SIN_FREQ_TIME_AMP 0.5\n\n#define SIN_TIME_AMP 10.0\n#define MOD_TIME_AMP 1.5\n\nfloat posSin(float x) {\n  return (sin(x)/2.0 + 0.5);\n}\n\nfloat plot(float pct, vec2 st){\n  return smoothstep(pct - SMOOTH_HALF_INTERVAL, pct, st.y)\n      - smoothstep(pct, pct + SMOOTH_HALF_INTERVAL, st.y);\n}\n\nfloat computeAmp(float time_factor) {\n  return SIN_AMP_MAX*(sin(iTime*time_factor*SIN_AMP_TIME_AMP)/2.0 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = vec2(fragCoord.x /iResolution.x, fragCoord.y/iResolution.y);\n  st = (st - 0.5) * 2.0;\n  st.x *= iResolution.x/iResolution.y;\n\n  // Determine the polar coordinate\n  float oTheta = atan(st.y, st.x);\n  float r = length(st);\n\n  float theta = mod(oTheta + iTime*MOD_TIME_AMP, PI_DIV) - HALF_PI_DIV;\n  float theta2 = mod(oTheta - THIRD_PI_DIV + iTime*MOD_TIME_AMP*2.0/3.0, PI_DIV) - HALF_PI_DIV;\n  float theta3 = mod(oTheta - 2.0*THIRD_PI_DIV + iTime*MOD_TIME_AMP/3.0, PI_DIV) - HALF_PI_DIV;\n\n  float freq = SIN_FREQ_MAX*posSin(iTime*SIN_FREQ_TIME_AMP);\n\n  float ampR = computeAmp(1.0/3.0);\n  float ampG = computeAmp(2.0/3.0);\n  float ampB = computeAmp(1.0);\n\n  float polarPct = plot(ampR*sin(r*freq - iTime*SIN_TIME_AMP), vec2(theta));\n  float polarPct2 = plot(ampG*sin(r*freq - iTime*SIN_TIME_AMP/3.0), vec2(theta2));\n  float polarPct3 = plot(ampB*sin(r*freq - iTime*SIN_TIME_AMP*2.0/3.0), vec2(theta3));\n\n  vec3 color = vec3(polarPct, polarPct2, polarPct3);\n  // vec3 color = vec3(polarPct*posSin(u_time*2.0/3.0), polarPct2*posSin(u_time), polarPct3*posSin(u_time/3.0));\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[364, 364, 387, 387, 418], [420, 420, 451, 451, 571], [573, 573, 610, 610, 686], [688, 688, 745, 745, 1860]]}
{"id": "llfcR8", "name": "3D Simplex Noise with Philox4x32", "author": "tomohiro", "description": "3D simplex noise using random number generated by philox4x32.\nIt also calculate gradient and partial differential of the gradient.", "tags": ["2d", "simplexnoise", "philox"], "likes": 4, "viewed": 562, "date": "1503343340", "time_retrieved": "2024-06-20T18:59:46.090157", "image_code": "const float PI = 3.1415926;\n\n/*\nCounter based pseudorandom number generator Philox\n\nIt is introduced in this paper:\nParallel Random Numbers: As Easy as 1, 2, 3\nby John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw\n\nPhilox is a modification of Threefish.\nIt is explained in 2.2 and 3.3 in this paper:\nThe Skein Hash Function Family\nby Niels Ferguson, Stefan Lucks, Bruce Schneier, Doug Whiting, Mihir Bellare, Tadayoshi Kohno, Jon Callas, Jesse Walker\n\nYou can download original Random123 source code from here:\nhttp://www.thesalmons.org/john/random123/\n\nHow to use:\nuvec4 counter;\nuvec2 key;\nuintToFloat(philox4x32_7(counter, key))\nreturns pseudorandom float4 value where each components are [0, 1).\n*/\n\n//umulExtended is not available in\n//umulExtended was added GLSL ES 3.1\n//This function is based on _mulhilo_c99_tpl macro in Random123-1.09/include/Random123/philox.h in Random123 source code.\nvoid umulExtended_(uint a, uint b, out uint hi, out uint lo) {\n    const uint WHALF = 16u;\n    const uint LOMASK = (1u<<WHALF)-1u;\n    lo = a*b;               /* full low multiply */\n    uint ahi = a>>WHALF;\n    uint alo = a& LOMASK;\n    uint bhi = b>>WHALF;\n    uint blo = b& LOMASK;\n\n    uint ahbl = ahi*blo;\n    uint albh = alo*bhi;\n\n    uint ahbl_albh = ((ahbl&LOMASK) + (albh&LOMASK));\n    hi = ahi*bhi + (ahbl>>WHALF) +  (albh>>WHALF);\n    hi += ahbl_albh >> WHALF; /* carry from the sum of lo(ahbl) + lo(albh) ) */\n    /* carry from the sum with alo*blo */\n    hi += ((lo >> WHALF) < (ahbl_albh&LOMASK)) ? 1u : 0u;\n}\n\nuvec2 philox4x32Bumpkey(uvec2 key) {\n    uvec2 ret = key;\n    ret.x += 0x9E3779B9u;\n    ret.y += 0xBB67AE85u;\n    return ret;\n}\n\nuvec4 philox4x32Round(uvec4 state, uvec2 key) {\n    const uint M0 = 0xD2511F53u, M1 = 0xCD9E8D57u;\n    uint hi0, lo0, hi1, lo1;\n//    umulExtended(M0, state.x, hi0, lo0);\n//    umulExtended(M1, state.z, hi1, lo1);\n    umulExtended_(M0, state.x, hi0, lo0);\n    umulExtended_(M1, state.z, hi1, lo1);\n\n    return uvec4(\n        hi1^state.y^key.x, lo1,\n        hi0^state.w^key.y, lo0);\n}\n\nuvec4 philox4x32_7(uvec4 plain, uvec2 key) {\n    uvec4 state = plain;\n    uvec2 round_key = key;\n\n    for(int i=0; i<7; ++i) {\n        state = philox4x32Round(state, round_key);\n        round_key = philox4x32Bumpkey(round_key);\n    }\n\n    return state;\n}\n\nfloat uintToFloat(uint src) {\n    return uintBitsToFloat(0x3f800000u | (src & 0x7fffffu))-1.0;\n}\n\nvec4 uintToFloat(uvec4 src) {\n    return vec4(uintToFloat(src.x), uintToFloat(src.y), uintToFloat(src.z), uintToFloat(src.w));\n}\n\n\nfloat skewF(float n)\n{\n/*\nn∈N\nX∈R^n\nX'∈R^n\nA∈R^n ∧ |A| = 1\ns∈R\nf is a non-uniform scaling along direction A and s is the scaling factor.\nf:R^n → R^n\nX' = f(X)\n   = X・A*s*A - X・A*A + X\n   = X・A*(s-1)*A + X\n\n∀B(B∈R^n ∧ B・A = 0 ⇒ f(X)・B = X・B)\n\nX' = f^-1(X)\n   = X・A*(1/s-1)*A + X\n\nf^-1(f(X)) = X\nX' = X・A*(s-1)*A + X\nX = X'・A*(1/s-1)*A + X'\n  = (X・A*(s-1)*A + X)・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(s-1)*(A・A)*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(1-s-1/s+1)*A          + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = -X・A*(s-1)*A - X・A*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X\n\nWhen creating simplex noise, A is a unit vector parallel to a unit hypercube's longest diagonal.\nA = (1/√(n), 1/√(n), ...)\n  = 1/√(n)(1, 1, ...)\n\nX' = f(X) = (s-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nIn skewed coordinate system, basis is not orthogonal.\nAny points P in skewed coordinate system such that P∈Z^n become a vertex of a simplex.\nIn the Cartesian coordinate, all edge of a simplex should have a same length.\nBut it is not possible in 3D and higher dimension.\nEquilateral triangle alone can fill space, but regular tetrahedra alone do not.\nFind 's' such that |f^-1((1, 0, 0, ...))| = |f^-1((1, 1, 1, ...))|\n|(1/s-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)/n*(1, 1, ...)・(1, 1, ...)*(1, 1, ...) + (1, 1, 1)|\n|(1/s-1)/n*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)*(1, 1, ...) + (1, 1, 1)|\n((1/s-1)/n+1)^2 + (((1/s-1)/n)^2)*(n-1) = ((1/s)^2)*n\n(1/s-1)*(1/s-1)/(n*n)+ 2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*(n-1)/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*n/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)/n = n/(s*s)\n(1/s-1)/n*(2 + (1/s-1)) + 1 = n/(s*s)\n(1/s-1)/n*(1 + 1/s) + 1 = n/(s*s)\n(1-s)/n*(s + 1) + s*s = n\n(1-s)*(s + 1) + s*s*n = n*n\n(n-1)*s*s + 1 = n*n\ns*s = (n*n - 1)/(n-1) = (n+1)(n-1)/(n-1) = n+1\ns = sqrt(n+1)\n\nX' = f(X) = (√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\nf^-1(X) = (1/√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nLength of edge of a simplex in Cartesian coordinate system:\n f^-1((1, 0, 0, ...))  = (1/√(n+1)-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)\n                       = (1/√(n+1)-1)/n*(1, 1, ...) + (1, 0, 0, ...)\n|f^-1((1, 0, 0, ...))| = √( ((1/√(n+1)-1)/n+1)^2 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n                       = √( ((1/√(n+1)-1)/n)^2 + 2*(1/√(n+1)-1)/n + 1 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n                       = √( (((1/√(n+1)-1)/n)^2)*n + 2*(1/√(n+1)-1)/n + 1 )\n                       = √( (1/√(n+1)-1)/n*(1/√(n+1)-1 + 2) + 1 )\n                       = √( (1/(n+1) - 1)/n + 1 )\n                       = √( -n/(n+1)/n + 1 )\n                       = √( -1/(n+1) + 1 )\n                       = √( n/(n+1) )\nhttps://www.wolframalpha.com/input/?i=sqrt(+((1%2Fsqrt(n%2B1)-1)%2Fn%2B1)^2+%2B+(((1%2Fsqrt(n%2B1)-1)%2Fn)^2)*(n-1)+)\n\nLength of edges of a simplex in Cartesian coordinate system in 3 or higher dimension are not equal.\nY∈{0,1}^n\nm = Y・(1, 1, ...)\nf^-1(Y) = m*(1/√(n+1)-1)/n*(1, 1, ...) + Y\n|f^-1(Y)| = √( ((m*(1/√(n+1)-1)/n+1)^2)*m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n          = √( ((m*(1/√(n+1)-1)/n)^2)*m + 2*m*m*(1/√(n+1)-1)/n + m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n          = √( ((m*(1/√(n+1)-1)/n)^2)*n + 2*m*m*(1/√(n+1)-1)/n + m )\n          = √( (m*(1/√(n+1)-1)/n)*( (m*(1/√(n+1)-1)) + 2*m ) + m )\n          = √( (m*(1/√(n+1)-1)/n)*m*( 1/√(n+1)+1 ) + m )\n          = √( m*m*(1/(n+1)-1)/n + m )\n          = √( m*m*(-n)/(n+1)/n + m )\n          = √( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*m/(n+1))/√( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0 when m = 0.5*(n+1)\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2/(n+1))/√( n/(n+1) )\n                = 0.5*(n-1)/√( n*(n+1) ) > 0 when m = 1\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*n/(n+1))/√( n/(n+1) )\n                = 0.5*(1-n)/√( n*(n+1) ) < 0 when m = n\n\nSo length of edge is shortest when m = 1 or m = n and other edge is longer than them.\n\nShortest distance between a vertex on simplex and the opposite edge:\nL = √( n/(n+1) )*√(3)/2\n\nReferences:\nhttps://en.wikipedia.org/wiki/Simplex_noise\nhttp://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n*/\n    return (sqrt(n + 1.0) - 1.0)/n;\n}\n\nfloat unskewG(float n)\n{\n    return (1.0/sqrt(n + 1.0) - 1.0)/n;\n}\n\nvoid randThetaPhi(vec3 id[4], uvec2 randKey, out vec2 tp[4])\n{\n    for(int i=0; i<4; ++i)\n    {\n        //According to 5.4.1 Conversion and Scalar Constructors in The OpenGL Shading Language Version 4.5, \n        //it is undefined to convert a negative floating-point value to an uint.\n        //The constructor uint(int) preserves the bit pattern in the argument, which will change its value if it is negative.\n        vec4 rand = uintToFloat(philox4x32_7(uvec4(ivec3(id[i]), 0), randKey));\n\n        //Spherical coordinate of a point which is uniformly distributed on sphere.\n        //http://mathworld.wolfram.com/SpherePointPicking.html\n        tp[i] = vec2(\n            2.0*PI*rand.x,\n            acos(2.0*rand.y - 1.0)\n        );\n    }\n}\n\nvec3 smplxNoise3DDeriv(vec3 x, float m, vec3 g)\n{\n    vec3 dmdxy = max(vec3(0.5) - dot(x, x), 0.0);\n    dmdxy = -8.0*x*dmdxy*dmdxy*dmdxy;\n    return dmdxy*dot(x, g) + m*g;\n}\n\nvec3 smplxNoise3DDeriv2xxyyzz(vec3 x, vec3 g)\n{\n    float m = max(0.5 - dot(x, x), 0.0);\n    return 48.0*m*m*dot(x, g)*x*x - 8.0*m*m*m*(2.0*g*x + vec3(dot(x, g)));\n}\n\nvec3 smplxNoise3DDeriv2xyxzyz(vec3 x, vec3 g)\n{\n    float m = max(0.5 - dot(x, x), 0.0);\n    return 48.0*m*m*dot(x, g)*x.yzz*x.xxy - 8.0*m*m*m*(x.xxy*g.yzz + x.yzz*g.xxy);\n}\n\n//f(x)=simplexNoise3D(x)\n//deriv is vec3(∂f/∂x, ∂f/∂y, ∂f/∂z)\n//ddxxyyzz is vec3(∂∂f/∂x∂x, ∂∂f/∂y∂y, ∂∂f/∂z∂z)\n//ddxyxzyz is vec3(∂∂f/∂x∂y, ∂∂f/∂x∂z, ∂∂f/∂y∂z)\n//∂∂f/∂x∂y == ∂∂f/∂y∂x, ∂∂f/∂x∂z == ∂∂f/∂z∂x, ∂∂f/∂y∂z == ∂∂f/∂z∂y\nfloat smplxNoise3D(vec3 p, out vec3 deriv, out vec3 ddxxyyzz, out vec3 ddxyxzyz, uvec2 randKey)\n{\n    vec3 id[4];\n    id[0] = floor(p + vec3( (p.x + p.y + p.z)*skewF(3.0) ));\n    float unskew = unskewG(3.0);\n    vec3 x[4];\n    x[0] = p - (id[0] + vec3( (id[0].x + id[0].y + id[0].z)*unskew ));\n\n    vec3 cmp1 = step(vec3(0.0), x[0] - x[0].zxy);\n    vec3 cmp2 = vec3(1.0) - cmp1.yzx; //= step(vec3(0.0), x[0] - x[0].yzx);\n    vec3 ii1 = cmp1*cmp2;    //Largest component is 1.0, others are 0.0.\n    vec3 ii2 = min(cmp1 + cmp2, 1.0);    //Smallest component is 0.0, others are 1.0.\n    vec3 ii3 = vec3(1.0);\n\n//  vec3 id[1] = id[0] + ii1;\n//  x[1] = p - (id[1] + vec3(id[1].x + id[1].y + id[1].z)*unskew);\n//       = p - (id[0] + ii1 + vec3(id[0].x + id[0].y + id[0].z + 1.0)*unskew);\n//       = p - (id[0] + vec3(id[0].x + id[0].y + id[0].z)*unskew) - ii1 - vec3(1.0)*unskew);\n    x[1] = x[0] - ii1 - vec3(unskew);\n    x[2] = x[0] - ii2 - vec3(2.0*unskew);\n    x[3] = x[0] - ii3 - vec3(3.0*unskew);\n\n    float m[4];\n    for(int i=0; i<4; ++i)\n    {\n        m[i] = max(0.5 - dot(x[i], x[i]), 0.0);\n        m[i] = m[i]*m[i];\n        m[i] = m[i]*m[i];\n    }\n\n    id[1] = id[0]+ii1;\n    id[2] = id[0]+ii2;\n    id[3] = id[0]+ii3;\n\n    vec2 tp[4];\n    randThetaPhi(id, randKey, tp);\n\n    //Gradients;\n    vec3 g[4];\n    for(int i=0; i<4; ++i)\n    {\n        float r = sin(tp[i].y);\n        g[i] = vec3(r*cos(tp[i].x), r*sin(tp[i].x), cos(tp[i].y));\n    }\n\n    float ret = 0.0;\n    deriv = vec3(0.0);\n    ddxxyyzz = vec3(0.0);\n    ddxyxzyz = vec3(0.0);\n    for(int i=0; i<4; ++i)\n    {\n        ret += m[i] * dot(x[i], g[i]);\n        deriv += smplxNoise3DDeriv(x[i], m[i], g[i]);\n        ddxxyyzz += smplxNoise3DDeriv2xxyyzz(x[i], g[i]);\n        ddxyxzyz += smplxNoise3DDeriv2xyxzyz(x[i], g[i]);\n    }\n\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy*2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 deriv, ddxxyyzz, ddxyxzyz;\n    float c = smplxNoise3D(vec3(uv*2., iTime), deriv, ddxxyyzz, ddxyxzyz, uvec2(0xfeedbeefu, 0xacebeefu));\n\tfragColor = vec4(c*54.0 + 0.5);\n    fragColor = distance(uv, mouse) > 0.4 ? vec4(c*54.0 + 0.5) : vec4(ddxxyyzz*2., 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfcR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[716, 910, 972, 972, 1533], [1535, 1535, 1571, 1571, 1662], [1664, 1664, 1711, 1711, 2047], [2049, 2049, 2093, 2093, 2303], [2305, 2305, 2334, 2334, 2401], [2403, 2403, 2432, 2432, 2531], [2534, 2534, 2556, 6791, 6829], [6831, 6831, 6855, 6855, 6897], [6899, 6899, 6961, 6961, 7641], [7643, 7643, 7692, 7692, 7816], [7818, 7818, 7865, 7865, 7983], [7985, 7985, 8032, 8032, 8158], [8160, 8495, 8592, 8592, 10305], [10307, 10307, 10364, 10364, 10766]]}
{"id": "llfcz4", "name": "Soft Shadows", "author": "rocifier", "description": "Forked a toy and implemented soft shadows on it", "tags": ["raytracing"], "likes": 3, "viewed": 92, "date": "1503653689", "time_retrieved": "2024-06-20T18:59:47.641722", "image_code": "// Ray tracing is a topic I have always wanted to explore, but never really had\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\n// lamp hanging from the ceiling. Light is constantly being emitted from the\n// lamp in the form of light rays, which bounce around the room until they hit\n// your eye. Ray tracing follows a similar concept by simulating the path of\n// light through a scene, except in reverse. There is no point in doing the math\n// for light rays you cannot see!\n\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\n// ray from the camera through each pixel on screen. If the ray collides with\n// geometry in the scene, create new rays that perform the same process for both\n// reflection, as in a mirror, and refraction, as in through water. Repeat\n// to your satisfaction.\n\n// Having worked extensively with OpenCL in the past, this seemed like a good\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\n// line-by-line explanation, I decided to write a parallel ray tracer with\n// extensive annotations. The results are below ...\n\n// ![screenshot](/uploads/raytracer.png)\n\n// I start with a simple ray definition, consisting of an origin point and a\n// direction vector. I also define a directional light to illuminate my scene.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 color;\n    vec3 direction;\n};\n\n// In real life, objects have many different material properties. Some objects\n// respond very differently to light than others. For instance, a sheet of paper\n// and a polished mirror. The former exhibits a strong *diffuse* response;\n// incoming light is reflected at many angles. The latter is an example of a\n// *specular* response, where incoming light is reflected in a single direction.\n// To model this, I create a basic material definition. Objects in my scene\n// share a single (RGB) color with diffuse and specular weights.\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\n// To render the scene, I need to know where a ray intersects with an object.\n// Since rays have infinite length from an origin, I can model the point of\n// intersection by storing the distance along the ray. I also need to store the\n// surface normal so I know which way to bounce! Once I create a ray, it loses\n// the concept of scene geometry, so one more thing I do is forward the surface\n// material properties.\nstruct Intersect {\n    float len;\n    vec3 normal;\n    Material material;\n};\n\n// The last data structures I create are for objects used to fill my scene. The\n// most basic object I can model is a sphere, which is defined as a radius at\n// some center position, with some material properties. To draw the floor, I\n// also define a simple horizontal plane centered at the origin, with a normal\n// vector pointing upwards.\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 normal;\n    Material material;\n};\n\n// At this point, I define some global variables. A more advanced program might\n// pass these values in as uniforms, but for now, this is easier to tinker with.\n// Due to floating point precision errors, when a ray intersects geometry at a\n// surface, the point of intersection could possibly be just below the surface.\n// The subsequent reflection ray would then bounce off the *inside* wall of the\n// surface. This is known as self-intersection. When creating new rays, I\n// initialize them at a slightly offset origin to help mitigate this problem.\nconst float epsilon = 1e-3;\n\n// The classical ray tracing algorithm is recursive. However, GLSL does not\n// support recursion, so I instead use an iterative approach to control the\n// number of light bounces.\nconst int iterations = 3;\nconst int shadow_feelers = 700;\nconst float soft_diameter = 1.1;\n\n// Next, I define an exposure time and gamma value. At this point, I also create\n// a basic directional light and define the ambient light color; the color here\n// is mostly a matter of taste. Basically ... lighting controls.\nconst float exposure = 1e-2;\nconst float gamma = 2.2;\nconst float intensity = 100.0;\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\n\n// For a Static Light\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\n\n// For a Rotating Light\n// Light light = Light(vec3(1.0) * intensity, normalize(\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\n//                      1.0 + 4.0 * sin(iTime))));\n\n// I strongly dislike this line. I needed to know when a ray hits or misses a\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\n// the ray misses all geometry and instead hits the sky box. In a language that\n// supports dynamic return values, I could `return false`, but that is not an\n// option in GLSL. In the interests of making progress, I created an intersect\n// of distance zero to represent a miss and moved on.\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\n// intersection is relatively straightforward. For reflection purposes, a ray\n// either hits or misses, so I need to check for no solutions, or two solutions.\n// In the latter case, I need to determine which solution is \"in front\" so I can\n// return an intersection of appropriate distance from the ray origin.\nIntersect intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\n// Since I created a floor plane, I likewise have to handle reflections for\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\n// intersection. I only care about the intersect for the purposes of reflection,\n// so I only check if the quotient is non-zero.\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n    if (len < 0.0) return miss;\n    return Intersect(len, plane.normal, plane.material);\n}\n\n// In a *real* ray tracing renderer, geometry would be passed in from the host\n// as a mesh containing vertices, normals, and texture coordinates, but for the\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\n// input ray and iterate through all geometry to determine intersections.\nIntersect trace(Ray ray) {\n    const int num_spheres = 3;\n    Sphere spheres[num_spheres];\n\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\n    // scene definition, but soon found performance was abysmal on very large\n    // spheres. I kept the general format, modified to fit my data structures.\n\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\n\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\n    // with the plane, then loop through all spheres back-to-front.\n\n    Intersect intersection = miss;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\n    for (int i = 0; i < num_spheres; i++) {\n        Intersect sphere = intersect(ray, spheres[i]);\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n            intersection = sphere;\n    }\n    return intersection;\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rand_uv(float s) {\n    return vec2(rand(vec2(5.0+s, 6)), rand(vec2(0.97+s, 9.2)));\n}\n\n// This is the critical part of writing a ray tracer. I start with some empty\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\n// using an input ray, and continue to fire new rays until the iteration depth\n// is reached, at which point I return the total sum of the color values from\n// computed at each bounce.\nvec3 radiance(Ray ray) {\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    for (int i = 0; i <= iterations; ++i) {\n        Intersect hit = trace(ray);\n\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\n        // trace returns an intersection with either a diffuse or specular\n        // coefficient, then it has encountered a surface of a sphere or plane.\n        // Otherwise, the current ray has reached the ambient-colored sky box.\n\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\n\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\n            // to determine the Fresnel specular contribution factor, a measure\n            // of how much incoming light is reflected or refracted. I compute\n            // the Fresnel term and use a mask to track the fraction of\n            // reflected light in the current ray with respect to the original.\n\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;\n\n            // partial shade or full shade\n            vec3 hit_origin = ray.origin + hit.len * ray.direction + epsilon * light.direction;\n            vec3 intersection_tangent_u = cross(hit.normal, light.direction);\n            vec3 intersection_tangent_v = cross(hit.normal, intersection_tangent_u);\n            float lighten = 0.0;\n            for (int s=0; s < shadow_feelers; s++) {\n                vec2 rand_offset = rand_uv(float(s)) * soft_diameter - soft_diameter/2.0;\n                vec3 feeler_origin = hit_origin + intersection_tangent_u * rand_offset.x\n                                                + intersection_tangent_v * rand_offset.y;\n                Intersect shadowHit = trace(Ray(feeler_origin, light.direction));\n                if (shadowHit == miss) {\n                    lighten++;\n                }\n            }\n            float penumbra_ratio = lighten / float(shadow_feelers);\n            color += (clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\n                * hit.material.color.rgb * hit.material.diffuse\n                * (1.0 - fresnel) * mask / fresnel)\n                * penumbra_ratio;\n\n            // After computing diffuse colors, I then generate a new reflection\n            // ray and overwrite the original ray that was passed in as an\n            // argument to the radiance(...) function. Then I repeat until I\n            // reach the iteration depth.\n\n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\n\n        } else {\n\n            // This is the other half of the tracing branch. If the trace failed\n            // to return an intersection with an attached material, then it is\n            // safe to assume that the ray points at the sky, or out of bounds\n            // of the scene. At this point I realized that real objects have a\n            // small sheen to them, so I hard-coded a small spotlight pointing\n            // in the same direction as the main light for pseudo-realism.\n\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\n            color += mask * (ambient + spotlight); break;\n        }\n    }\n    return color;\n}\n\n// The main function primarily deals with organizing data from OpenGL into a\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\n// the fragment coordinates by the viewport resolution. I then offset that by a\n// fixed value to re-center the coordinate system.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\n    // For each fragment, create a ray at a fixed point of origin directed at\n    // the coordinates of each fragment. The last thing before writing the color\n    // to the fragment is to post-process the pixel values using tone-mapping.\n    // In this case, I adjust for exposure and perform linear gamma correction.\n\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}\n\n// If all goes well, you should see an animated scene below!\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\n\n// This was my first foray into ray tracing. Originally, I wanted to write this\n// using the OpenGL Compute Shader. That was harder to setup than I originally\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\n// before deciding to just sit down and start programming.\n\n// All things considered, this is a pretty limited ray tracer. Some low hanging\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\n// latter involves finding a quality random number generator. Maybe a summer\n// project before I start working ...\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfcz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[5119, 5633, 5678, 5718, 6168], [6170, 6468, 6511, 6511, 6685], [6687, 7001, 7027, 7027, 8427], [8429, 8429, 8450, 8450, 8521], [8523, 8523, 8546, 8546, 8612], [8614, 8958, 8982, 8982, 12448], [12450, 12898, 12953, 12953, 13536]]}
{"id": "llfyRM", "name": "Antialiased barycentric triangle", "author": "etale_cohomology", "description": "I was unable to find an antialiased barycentric triangle on Shadertoy, so I stole sea's shader (https://www.shadertoy.com/view/ltK3R1) and turned his Boolean barycentric triangle into an antialiased barycentric triangle", "tags": ["2d", "simple", "math", "tutorial", "triangle", "mobius", "antialias", "barycentric"], "likes": 2, "viewed": 347, "date": "1503998744", "time_retrieved": "2024-06-20T18:59:48.120696", "image_code": "// Fork of sea's https://www.shadertoy.com/view/ltK3R1\n\n// A barycentric triangle is a triangle on the plane given by 3 position vectors a, b, and c.\n// By stealing everything from sea's shader, we render an antialiased barycentric triangle,\n// which I was unable to find anywhere on Shadertoy...\n\n#define ANTIALIAS 4.\n\n// ------------------------------------------------------------------------------------------------\n// This function, by @sea, allowed me to turn @sea's boolean barycentric triangle into an antialiased barycentric triangle!\nbool draw_line(vec2 p, vec2 a, vec2 b){\n    vec2 ab = normalize(b - a);\n    vec2 ap = p - a;\n    return length((a + ab * dot(ab, ap)) - p) < .01;\n} \n\n// Find the intersection of vec_p with dvec_ab\nvec2 intersect(vec2 vec_p, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ab     = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 dvec_ap     = vec_p - vec_a;  // Displacement vector from vec_a to vec_p\n    vec2 vproj_ab_ap = dvec_ab * dot(dvec_ab, dvec_ap) / dot(dvec_ab, dvec_ab);  // Standard linear algebra way of computing the vector projection!\n    return vec_a + vproj_ab_ap;  // Intersection of vec_p with vec_ab\n}\n\n// By sea\nfloat sdf_triangle2(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n    vec2 a_intersect_bc = intersect(vec_a, vec_b, vec_c);  // Using vector projection, find the intersection of vec_a with dvec_bc\n    float bary_x = dot(a_intersect_bc - vec_p, normalize(a_intersect_bc - vec_a)) / distance(a_intersect_bc, vec_a);\n\n    vec2 b_intersect_ca = intersect(vec_b, vec_c, vec_a);  // Using vector projection, find the intersection of vec_b with dvec_ca\n    float bary_y = dot(b_intersect_ca - vec_p, normalize(b_intersect_ca - vec_b)) / distance(b_intersect_ca, vec_b);\n\n    float bary_z = 1. - bary_x - bary_y;  // The 3rd barycentric coordinate is easy!\n\n    // Barycentric coordinates range over [0; 1]. Any value outside [0; 1] is not in the triangle!\n    return min(min(bary_x, bary_y), bary_z);\n}\n\n// ------------------------------------------------------------------------------------------------\n// Courtesy of Dave_Hoskins! Only works for certain configurations of vertices...!\nfloat sdf_triangle1(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n \tvec2 dvec_ap = vec_p - vec_a;\n\tvec2 dvec_bp = vec_p - vec_b;\n\n\tfloat r1 = (vec_b.x - vec_a.x) * dvec_ap.y - (vec_b.y - vec_a.y) * dvec_ap.x;\n\tfloat r2 = (vec_a.x - vec_c.x) * dvec_ap.y - (vec_a.y - vec_c.y) * dvec_ap.x;\n   \tfloat r3 = (vec_c.x - vec_b.x) * dvec_bp.y - (vec_c.y - vec_b.y) * dvec_bp.x;\n\n    return min(min(r1, r2), r3);\n}\n\n// ------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;\n\n    //vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    //mouse_uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * mouse_uv;\n\n    // Specify & draw triangle!\n    vec2 triangle_a = vec2(-.4, -.5);\n    vec2 triangle_b = vec2( .8,  .0);\n    vec2 triangle_c = vec2( .0,  .8);  // mouse_uv\n    float triangle = sdf_triangle1(uv, triangle_a, triangle_b, triangle_c);  // Try changing this to triangle2()!\n    triangle = smoothstep(.0, ANTIALIAS / iResolution.y, triangle);\n\n\tfragColor.rgb = vec3(triangle);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfyRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[320, 544, 583, 583, 691], [694, 741, 792, 792, 1176], [1178, 1188, 1256, 1256, 1986], [1988, 2171, 2239, 2239, 2579], [2581, 2681, 2735, 2735, 3425]]}
{"id": "lllyRn", "name": "Pulsar Fractal", "author": "tz", "description": "Inspired by CBS's Simplicity Galaxy: https://www.shadertoy.com/view/MslGWN", "tags": ["fractal", "chromaticabberation", "pulsar"], "likes": 15, "viewed": 384, "date": "1503207789", "time_retrieved": "2024-06-20T18:59:48.217660", "image_code": "\nvec3 pulsar(in vec3 p, in vec2 uv)\n{\n\tfloat\tstr = 15.0,\n        \taccum = 0.5,\n        \tprev = mod((iTime+sin(iTime*20.0)*0.025)*10.1, 60.0),\n        \ttw = 1.0;\n    \n    p.z += sin(iTime*1.0)*0.01;\n    \n\tfor (int i = 0; i < 18; ++i)\n    {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.42 - cos(iTime*0.2)*0.02, -1.75 + sin(iTime*0.2)*0.003);\n\t\tfloat w = exp(-float(i) / str);\n\t\taccum += w * exp(-str * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n    float t = clamp(5.0 * accum / tw - 0.9, 0.0, 1.0);\n\treturn vec3(1.3*t*t*t*(1.0 - length(uv)*0.2) , 1.2*t*t, 1.0*t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = iResolution.xy * 0.5 + (iMouse.z > 0.5 ? iMouse.xy : vec2(0.0));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1. + offset/iResolution.xy - 0.5;\n\tvec3 p = vec3(uv * (iResolution.xy / iResolution.x) / 0.2, 0.0);\n    \n    vec3 noise = texture(iChannel0, uv*(3.0-mod(iTime*2.0,0.2))).rgb*0.1;\n    \n    vec2 vig_coord = fragCoord.xy / iResolution.xy - pow(fragCoord.xy / iResolution.xy,vec2(2.0));\n    float vig_highlight = 1.0-pow(vig_coord.x*vig_coord.y*3.0, 0.05);\n    \n\tfragColor = vec4((vec3(pulsar(p*0.99,uv).r, pulsar(p, uv).gb)-noise)+vig_highlight, 1.0) ;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllyRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 37, 37, 591], [593, 593, 650, 650, 1237]]}
{"id": "llscz4", "name": "Watery waves", "author": "rkibria", "description": "A moving wavy pattern composed of 2 sines.", "tags": ["procedural", "2d"], "likes": 5, "viewed": 174, "date": "1503841764", "time_retrieved": "2024-06-20T18:59:48.217660", "image_code": "#define TWOPI 6.28318530718\n\nvec4 WATER_COLOR = vec4(0.0, 0.412, 0.58, 1.0); // sea blue\nvec4 CREST_COLOR = vec4(1.0, 1.0, 1.0, 1.0);\n\n// Goes 0 to 1 at period/2 and back to 0\nfloat trianglefunction(float t, float period) {\n    float ps = mod(t, period) / period; // 0 to 1 in period\n    if (ps > 0.5)\n        ps = 1.0 - ps;    \n    return ps * 2.0;\n}\n\n// Returns 1 where the crest is strongest, can go <0 too though\nfloat waterwave(vec2 uv,\n                float t,\n    \t\t\tfloat period, \n                float horzSpeed, \n                float vertSpeed,\n                float amplitude, \n                float crestWidth\n               ) {\n\t// canvas moves\n    float cx = uv.x;\n    float cy = uv.y + vertSpeed * sin(t);\n    \n    // map area to [0..TWOPI, -1..1]\n\tfloat sx = cx * TWOPI;\n    float sy = cy * 2.0 - 1.0;\n\n    float ss = trianglefunction(t, period);\n    ss = ss * 2.0 - 1.0;\n\n    float f = sin(t * horzSpeed + sx) * ss * amplitude;\n\n    float d = abs(sy - f) / crestWidth;\n    return 1.0 - d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float w1 = waterwave(vec2(uv.x, uv.y - 0.2),\n                        iTime,\n        \t\t\t    8.0, // period\n                        1.0, // horzSpeed\n                        0.2, // vertSpeed\n                        0.5, // amplitude\n                        1.5 // crestWidth\n                        );\n    \n    float w2 = waterwave(vec2(uv.x, uv.y + 0.3),\n                        iTime,\n        \t\t\t    5.0, // period\n                        2.5, // horzSpeed\n                        0.1, // vertSpeed\n                        0.15, // amplitude\n                        0.5 // crestWidth\n                        );\n    \n    float waves = w1 + w2 * 0.25;\n\n    fragColor = mix(WATER_COLOR, CREST_COLOR, waves);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llscz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[135, 176, 223, 223, 351], [353, 417, 641, 658, 1008], [1010, 1010, 1067, 1067, 1829]]}
{"id": "llsyR7", "name": "solved nth root?", "author": "ollj", "description": "mouse.xy moves the middle Control Vectors, and a 180deg rotated one.\nIs \nmin(DistanceToquadraticBezierA,DistanceToquadraticBezierB)\nequal to solving a cubic root?\nif (that is true) an nth root is solvable by solving for distances to [n cubic Bezier]s.", "tags": ["bezier", "intersection", "spline", "cubic", "euclidean", "root", "bisymmetry", "qudratic", "solving"], "likes": 7, "viewed": 839, "date": "1504183337", "time_retrieved": "2024-06-20T18:59:49.999730", "image_code": "//2d Euclidean Bezier spline is root solving\n//self       : https://www.shadertoy.com/view/llsyR7\n//grandparent: https://www.shadertoy.com/view/MtscRM\n//parent     : https://www.shadertoy.com/view/4ddXRH\n// - Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n// - - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// - - Inspired by http://www.pouet.net/topic.php?which=9119\n// - - ... and various shaders by iq, T21, and demofox\n//\n//Uses [Lib.Frame.7] 2017-09 extending: https://www.shadertoy.com/view/4tfcz4\n//\"Bisymmetry\"= shorthand for \"gradient from symmetry to assymmetry\", explained below:\n\n/* end__.Attributes\n   start.Head\n*/\n\n/*\nYou can analytically solve for n-roots over n-domains relatively easily (proof later)\nThe number of domains is the number of dimensions that a function/surface/line has.\n- linear, quadratic, cubic, hypercubic\nA \"root\" is a point where f(xyzw)=.0; this is root-solving a function.\n- Highest exponent of a function == Upper limit of number of roots.\n- Highest exponent is described with the same namespaces;\n- - linear, quadratic, cubic, hypercubic\nA \"root\" equates to \"where does f(x) intersect with a line\"\n- For simplicity, f(x) is rotaed/transformed so that the line is y=0;\n- The tricky part (for opengl) is to store an array of roots\n- - For simplicity, assume we tested that a root exist or just know it):\n- - - this is done by testing where your function WOULD BE undefined:\n- - - - check if any divisor==0.;\n- - - - check if log(a) has an a<=0;\n- - - - check if pow(a,b) has any a==.0 AND B==.0 //\n- - - - check if pow(a,b) has any a<0. AND  0.<abs(b)<1. (still doable with complex numbers)\n- - - - ... + anything else where your axiomes are incomplete or inconsistent (or both)\n- - - the problem os assuming that a root exists where there is none is that your function is not defined there.\n- 2 non parallel coplanar lines have 1 root\n- a line and a non-tangential circle/ellipse/parabola/QuadraticFunction\n- .... has 2 roots.  it has 1 root if it is tangential.\n- ...\n- This shader solves roots for a QuadraticFunction==bezier.\n- beziers can be extended smoothly, when the normals at the fused ends are the same.\n- fusing 2 quadratic functions makes a cubic function.\n-...\n- [bezier][n] can have all its roots solved, by splitting it into multiple quadratic bezier][0], and solving a cubic function?\n- - distance to quadratic bezier is cubic, because length(a)==sqrt(dot(a,a)) adds one root.\n- - getting shortest euclidean distance to a (planar) [cubic bezier] equals cubic root solving.\n- if (BezierA and BezierB share one start/end controlVector, with identical normal)\n- - distanceto.BezierA returns one root of a cubic function?\n- - distanceto.BezierB returns one root of a cubic function?\n-         if (BezierA and BezierB share one start/end controlVector, with identical normal)\n- ... and if (BezierB and BezierC share one start/end controlVector, with identical normal)\n- -  distanceto.BezierA returns one     root of a quadratic function?\n- - distanceto.BezierB returns one     root of a quadratic function?\n- - distanceto.BezierB returns one     root of a quadratic function?\n\n... We just calculate the smallest absolute root of all roots.\n*/\n\n/* end__.Head\n   start.Parameters\n*/\n\n//planar zoom.\n#define ViewZoom 3.\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n//View Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n/* End__.Parameters\n   Start.Lib.Frame.7\n*/\n\n//index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a) (a*.5+.5)\n#define u2(a) (a*2.-1.)\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}//max of vector\n#define miv(a) -mav(-a)\n//triangle wave //euclidean grid\n#define tri(a) a=abs(u2(fract(a))\n#define grid(a) mav(tri(a))\n//clamp().special clamp.general; //clamp().pseudo.inverse\n#define sat(a) clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch; mirror_centric, most common, atomic\n#define stretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus; positive values do not change; stretchPlus; negatives do not change.\n#define stretchM(u,m) stretch((u*2.+m),m)*.5\n#define stretchP(u,m) stretch((u*2.-m),m)*.5\n#define dd(a) dot(a,a)\n//perpendicular ==90deg rotation, relevant for distance to line\nv1 perp(v1 a){return v1(-a.y,a.x);}\n//return [perpendicular dot product], relevant for distance to line\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}\n//return distance of [u] from segment, from [a] to [b]\nv0 dSegment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n//---trigonometry, rotations and (distance to) Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a) vec2(cos(a),sin(a))\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because; phi.xy-1.=1/phi.xy\nconst v1 phi=v1(sqrt(5.)*.5)+v1(-.5,.5);\n//a not too work save plotter for quadratic functions.\nv1 evalQuad(v1 t,v1 A,v1 B,v1 C){A=(1.-t)*(A/B+C/A);return A*A;}\n//Solve quadratic equation for roots \nv2 SolveQuad(v2 a){float e=-a.x/3.;v0 p=a.y+a.x*e,t=p*p*p,\n q=-(2.*a.x*a.x-9.*a.y)*e/9.+a.z,d=q*q+4.*t/27.;if(d>.0){v1 x=(v1(1,-1)*sqrt(d)-q)*.5;\n return v2(suv(sign(x)*pow(abs(x),v1(1./3.)))+e);}v1 m=cs(acos(-sqrt(-27./t)*q*.5)/3.)\n  *v1(1,sqrt(3.));return v2(m.x+m.x,-suv(m),m.y-m.x)*sqrt(-p/3.)+e;}\n//return squared distance to line segment\nv0 dLine(v1 a,v1 b,v1 p){a=a-p;b-=p;p=b-a;return dd(a+p*sat(-dot(a,p)/dd(p)));}\n#define ddb(a) (dd(d+(c+b*t.a)*t.a))\n// Find the signed distance from a point to a bezier curve\nv0 dBezier(v1 p,v1 A,v1 B,v1 C){   \n //B=mix(B+v1(1e-4), B, abs(sign(B * 2.0 - A - C)));//colinear CV triviality\n v1 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;v2 k=v2(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b),\n t=sat(SolveQuad(k));return sqrt(miv(v2(ddb(x),ddb(y),ddb(z))));}\n//---window function curve fittings.y:  https://www.shadertoy.com/view/Xtscz7\n#define bma(b,a,c) (((b)-(a))*(c)+a)\n//float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define wLinear(x,a,b) a*(x*(b/a-1.)+1.)\n//float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define wCosine(x,a,b) (bma(b,a,(1.-cos(x*acos(-1.)))*.5)\n//float Smoothstep(0,1,x), without sat(a);\n#define wSs2(x) (x)*(x)*(3.-2.*(x))\n#define wSs(x,a,b) wSs2((x)-(a)/((b)-(a)))//this is not too useful, without sat it sucks\n//bma(b,a,x*x*(3.-2.*x))\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define wHermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define wHermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define wCatmullRom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define wCubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n//fast good monochrome distance field visualization.\nv3 rg(v3 c){v3 b=smoothstep(fsaa,-fsaa,c);\n return mix(fract(c*4.),b,.5+(atan(c))/acos(-1.));}\n//---hash\n//hash11 fast mediocre, better for mobile gpu.\nv0 h11(float p){v2 f=fract(v2(p)*.1031);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\n\n/* End__.Lib.Frame.7\n   Start.Main\n*/\n\n#define dd(a) dot(a,a)\nvoid mainImage(out v3 O, in v1 U ){\n v1 u=fra(U);\n v1 m=mix(fra(iMouse.xy),v1(u5(cs(iTime))*vec2(1,phi.x)*2.),step(iMouse.z,.0));\n // set the bezier cubic control vectors\n const v1 A=vec2(0);\n v1 C=v1(0,1),B=2.*m-.5*(A+C);   \n vec4 c=vec4(1);//4 colors .a is yellow\n    \n //render 2* quadratic Bezier\n c.r=dBezier(u,A, B, C);//unsigned distance to                bezier curve\n c.g=dBezier(u,A,-B,-C);//unsigned distance to 180deg rotated bezier curve (lazy symmetry)\n \n c.a=min(c.r,c.g);//yellow is min() union.\n c.rg=mix(c.rg,c.aa,u5(cos(iTime*phi.y)));//mix yellow into rg, oscillating cos([0..1]) \n //c.r=min(c.r,c.g);//c.g=c.r;//monochrome alternative\n \n c-=.1;//all above Lie-spheres (Lie-beziers) have the same radius\n\n //add dots for UI illustration:\n c.a=min(length(u-m),length(u+m));\n c.a-=.05;//UI dots have a different radius.\n c.b=min(c.b,c.a);//add blue, (or white)?\n  \n //c=fract(c*4.)\n c=rg(c);//illustrate gradient with mix(fract(),smoothstep())\n O=vec4(c.xyz,1.);}\n/* End__.Main\n   Start.Bisymmetry\n*/\n\n\n/*\nthe BISYMETRY PRINCIPLE: v3\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/\n\n/* End__.Bisymmetry\n   Start.Dump.Memo\n*/\n\n//memo on bezier bounding volume: http://i.imgur.com/b4q3r2n.jpg\n//if a bezier is meant to define a surface, and i want to trace the BV first\n//but the *.tricky points for the BV possibly make the BV not worth calculating.\n//still worth buffering for a static object?", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llsyR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[3530, 3664, 3677, 3677, 3698], [3698, 3698, 3711, 3711, 3732], [3733, 3733, 3746, 3746, 3762], [3762, 3778, 3791, 3791, 3812], [3812, 3812, 3825, 3825, 3852], [3853, 3853, 3866, 3866, 3899], [4034, 4122, 4141, 4141, 4207], [4513, 4577, 4591, 4591, 4612], [4613, 4681, 4700, 4700, 4723], [4724, 4779, 4807, 4807, 4857], [5264, 5319, 5352, 5352, 5383], [5384, 5422, 5441, 5441, 5723], [5724, 5766, 5791, 5791, 5845], [5883, 5942, 5974, 6054, 6209], [7385, 7474, 7486, 7486, 7568], [7569, 7626, 7642, 7642, 7719], [7721, 7783, 7818, 7818, 8764]]}
{"id": "llXyzH", "name": "August 21, 2017", "author": "mhnewman", "description": "My view from Corvallis, Oregon of the August 21, 2017 solar eclipse", "tags": ["eclipse", "solar", "21", "2017", "august"], "likes": 8, "viewed": 223, "date": "1503387789", "time_retrieved": "2024-06-20T18:59:49.999730", "image_code": "float hash13(vec3 p) {\n\tp  = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat noise13(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(mix(hash13(i + vec3(0.0, 0.0, 0.0)), \n                                   hash13(i + vec3(1.0, 0.0, 0.0)), u.x),\n                               mix(hash13(i + vec3(0.0, 1.0, 0.0)), \n                                   hash13(i + vec3(1.0, 1.0, 0.0)), u.x), u.y),\n                           mix(mix(hash13(i + vec3(0.0, 0.0, 1.0)), \n                                   hash13(i + vec3(1.0, 0.0, 1.0)), u.x),\n                               mix(hash13(i + vec3(0.0, 1.0, 1.0)), \n                                   hash13(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\nconst mat3 m = mat3( 0.51162, -1.54702,  1.15972,\n                    -1.70666, -0.92510, -0.48114,\n                     0.90858, -0.86654, -1.55678);\n\nfloat fbm13(vec3 p) {\n    float f = noise13(p); p = m * p;\n    f += 0.4 * noise13(p); p = m * p;\n    f += 0.16 * noise13(p); p = m * p;\n    f += 0.064 * noise13(p);\n    return 0.5 + 0.30788 * f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = 3.0 * (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    float r = length(pos);\n    if (r < 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    vec2 p = pos / r;\n    r -= 1.0;\n    float aa = 6.0 / iResolution.y;\n    vec3 color = vec3(0.0, 0.1, 0.3);\n    \n    float f = fbm13(vec3(10.0 * pos, 0.4 * iTime));\n    f = clamp(f + 1.1 * exp(-5.0 * r) - 1.5, 0.0, 10.0);\n    color += f * vec3(3.0, 0.8, 0.4);\n    \n    f = fbm13(vec3(5.0 * p, 0.2 * iTime - 0.5 * r));\n    f = clamp(f + 1.2 * exp(-0.8 * r) - 0.8, 0.0, 1.0);\n    color += vec3(0.6 * f);\n    \n    r = clamp(r / aa, 0.0, 1.0);    \n    fragColor = vec4(r * clamp(color, 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXyzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 148], [150, 150, 173, 173, 846], [1000, 1000, 1021, 1021, 1196], [1198, 1198, 1253, 1253, 1932]]}
{"id": "ls2BRt", "name": "Volumetric Stanford Bunny 2", "author": "FabriceNeyret2", "description": "Volumetric 32x32x32 Stanford Bunny from [url]https://www.shadertoy.com/view/MdlyDs[/url]\nOriginal doesn't compile on many GPUs. Indeed, this is the 3linear interpolation that is causing this:\ntry uncommenting line 20. \n", "tags": ["voxel", "bug", "volumetricrendering", "stanfordbunny"], "likes": 16, "viewed": 1102, "date": "1501765701", "time_retrieved": "2024-06-20T18:59:50.242079", "image_code": "// data from SebH https://www.shadertoy.com/view/MdlyDs\n// Packed 32^3 bunny data as 32x32 uint where each bit represents density per voxel\nconst uint packedBunny[1024] = uint[1024](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,917504u,917504u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1966080u,12531712u,16742400u,16742400u,16723968u,16711680u,8323072u,4128768u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,6144u,2063360u,16776704u,33553920u,33553920u,33553920u,33553920u,33520640u,16711680u,8323072u,8323072u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,402653184u,134217728u,201326592u,67108864u,0u,0u,7168u,2031104u,16776960u,33554176u,33554176u,33554304u,33554176u,33554176u,33554176u,33553920u,16744448u,8323072u,4128768u,1572864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,939524096u,402653184u,478150656u,260046848u,260046848u,260046848u,125832192u,130055680u,67108608u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554176u,16776704u,8355840u,4128768u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,1056964608u,1056964608u,528482304u,528482304u,260046848u,260046848u,260046848u,130039296u,130154240u,67108739u,67108807u,33554375u,33554375u,33554370u,33554368u,33554368u,33554304u,33554304u,16776960u,8330240u,4128768u,393216u,0u,0u,0u,0u,0u,0u,0u,0u,939524096u,1040187392u,1040187392u,520093696u,251658240u,251658240u,260046848u,125829120u,125829120u,130088704u,63045504u,33554375u,33554375u,33554375u,33554407u,33554407u,33554370u,33554370u,33554374u,33554310u,16776966u,4144642u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,15360u,130816u,262017u,4194247u,33554383u,67108847u,33554415u,33554407u,33554407u,33554375u,33554375u,33554318u,2031502u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,262019u,2097151u,134217727u,134217727u,67108863u,33554415u,33554407u,33554415u,33554383u,2097102u,982926u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,524263u,117964799u,127926271u,134217727u,67108863u,16777215u,4194303u,4194303u,2097151u,1048574u,65422u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,31751u,130951u,524287u,252182527u,261095423u,261095423u,59768830u,2097150u,1048574u,1048575u,262143u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,7u,31751u,130959u,503840767u,520617982u,529530879u,261095423u,1048575u,1048574u,1048574u,524286u,524287u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,1799u,32527u,134348750u,1040449534u,1057488894u,520617982u,51380223u,1048575u,1048575u,524287u,524287u,524287u,131070u,65534u,15886u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1536u,3968u,8175u,65535u,1006764030u,1040449534u,1057488894u,50855934u,524286u,524286u,524287u,524287u,524286u,262142u,131070u,65534u,32270u,14u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8160u,8191u,805371903u,2080505854u,2114191358u,101187582u,34078718u,524286u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,32766u,8078u,3590u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8176u,16383u,2013331455u,2080505854u,235143166u,101187582u,524286u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,131070u,32766u,16382u,8070u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8160u,8184u,1879064574u,2013331455u,470024190u,67371006u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,65534u,16382u,8160u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8184u,805322750u,402718719u,134479870u,524286u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8184u,16382u,131071u,262142u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1792u,8184u,16380u,65535u,262143u,524286u,524286u,1048574u,1048574u,1048575u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16376u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8176u,16376u,32767u,262143u,524286u,1048574u,1048574u,1048575u,1048575u,1048575u,1048575u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4032u,8184u,32766u,262142u,524286u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,384u,8184u,32766u,131070u,262142u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,131070u,32766u,16368u,1920u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4080u,32764u,65534u,262142u,524286u,524286u,524286u,1048574u,1048574u,524286u,524286u,524286u,262142u,131070u,32764u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,256u,16376u,32760u,131068u,262140u,262142u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,65532u,16368u,3840u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,32752u,65528u,131068u,262142u,262142u,262142u,262142u,262142u,262142u,262140u,131064u,32752u,7936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8064u,32736u,65528u,131070u,131070u,131070u,131070u,131070u,131070u,65532u,32752u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3456u,16376u,32764u,65534u,65534u,65534u,32766u,32764u,16380u,4048u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,48u,2680u,8188u,8188u,8188u,8188u,4092u,120u,16u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,120u,248u,508u,508u,508u,248u,240u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,96u,240u,504u,504u,504u,240u,96u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,224u,224u,224u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\n#define voxelB(x,y,z) float( ( packedBunny[ int(x) + int(y)*32 ] >> int(z) ) % 2u )\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat voxel(float x, float y, float z) {\n    int ix = int(x), iy = int(y), iz = int(z);\n    if (min(ix,min(iy,iz)) < 0 || max(ix,max(iy,iz)) > 30 ) return 0.;\n    return mix( mix( mix( voxelB(ix,iy  ,iz  ), voxelB(ix+1,iy  ,iz  ), fract(x) ),\n                     mix( voxelB(ix,iy+1,iz  ), voxelB(ix+1,iy+1,iz  ), fract(x) ), fract(y)),\n                mix( mix( voxelB(ix,iy  ,iz+1), voxelB(ix+1,iy  ,iz+1), fract(x) ),\n                     mix( voxelB(ix,iy+1,iz+1), voxelB(ix+1,iy+1,iz+1), fract(x) ), fract(y)), fract(z) );\n}\n\nvoid mainImage( out vec4 O,vec2 V )\n{\n    O -= O; \n // O += voxel(iTime,.5,.5);  // won't compile: even with only bilinear interp:\n                              //    \"cannot locate suitable resource to bind variable\"\n    \n    V = 1.7* ( (V+V - iResolution.xy) / iResolution.y);\n    for (float i=-1.; i<1.; i+=1./16.) {  \n        vec3 P = vec3( V, i); \n        P.yz *= rot(.78);\n        P.xz *= rot(-iTime);\n        vec3 A = abs(P); if (max(A.x,max(A.y,A.z))>1.) continue;\n        P = 16.*(P+1.);\n        O += (1.-O.a) * voxelB( P.x , P.z, P.y  )  // try voxel() vs voxelB()\n                      * vec4( vec3(.5-.5*i), 1) ;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2BRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 6002, 6042, 6042, 6532], [6534, 6534, 6571, 6571, 7166]]}
{"id": "ls2fDc", "name": "Spiral Circles", "author": "Vovosunt", "description": "Seen something similar on pinterest, decided to try it out myself.\nHex is my own buggy implementation, didn't want to steal iq's implementation without fully understanding it.", "tags": ["2d", "spiral", "circle"], "likes": 16, "viewed": 251, "date": "1502612279", "time_retrieved": "2024-06-20T18:59:50.460373", "image_code": "#define c30 0.86602540378\n#define hm  1.33333333333\n#define grid 15.0\n#define smooth 0.00002 * iResolution.y\n#define timeScale 0.2\n\n\nvec2 hex(vec2 v){\n\tfloat yc = abs(mod(v.x + floor((v.y*hm + 0.5))*(c30 / 2.0),c30) / c30 - 0.5);\n\tfloat y = floor(v.y*hm + yc);\n\tfloat x = floor(v.x/c30 + 0.5 + fract(y / 2.0))- fract(y / 2.0);\n\treturn vec2(x*c30,y /hm + 1.0/(hm * 4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy  / vec2(iResolution.y,iResolution.y);\n    \n    float rt = iTime * timeScale;\n    vec2 gv = hex(uv*grid)/grid;\n    vec2 mv = gv - 0.5;\n    vec2 rv = vec2(((atan(mv.x,mv.y)/3.141526) + 1.0) / 2.0, length(mv));\n    float fv = fract((rv.x- rt) * 2.0 + rv.y * 2.0);\n    \n    float dist = length(uv - gv) * grid;\n    float dist2 = 1.0 - smoothstep(-smooth,0.0,dist - c30/2.);\n    dist += fv;\n    dist = smoothstep(0.5,0.5 + smooth,fract(dist));\n    float finCol = float(0.5);\n    finCol = mix(finCol, dist, dist2);\n\tfragColor = vec4(finCol);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2fDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[133, 133, 150, 150, 372], [374, 374, 431, 431, 993]]}
{"id": "lsSfW3", "name": "Voronoi Cells", "author": "Homaniac", "description": "simple voronoi noise where the space is tiled and a point within the tile randomly moves within it. Shader function finds the tile the pixel is in, and checks all the neighboring ones to find the nearest moving point.", "tags": ["cells", "voronoinoise", "nearestcell"], "likes": 4, "viewed": 300, "date": "1502412068", "time_retrieved": "2024-06-20T18:59:50.460373", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 hsb2rgb( in vec3 c ){\n  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                           6.0)-3.0)-1.0,\n                   0.0,\n                   1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = f*f*(3.0-2.0*f);\n\n  return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                   dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n              mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 10.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n          // Neighbor place in the grid\n          vec2 neighbor = vec2(float(x),float(y));\n\n          // Random position from current + neighbor place in the grid\n          vec2 point = random2(i_st + neighbor);\n\n          // Animate the point\n          point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n          // Vector between the pixel and the point\n          vec2 diff = neighbor + point - f_st;\n\n          // Distance to the point\n          // float dist = length(diff);\n          float dist = length(diff)*((0.25*sin(iTime*0.3) + 0.25) + 0.6);\n\n          // Keep the closer distance\n          m_dist = min(m_dist, dist);\n          // m_dist = min(m_dist, 3.0*dist*dist*dist - 2.0*dist*dist + dist);\n        }\n    }\n\n\n    // Draw the min distance (distance field)\n    // color += m_dist;\n    // color += smoothstep(0.0,1.0,m_dist);\n    // color += hsb2rgb(vec3(0.4,1.0,m_dist + 0.2*sin(iTime*0.5)));\n\n      // color += mix(hsb2rgb(vec3(0.385, 1.0, 0.9)),\n      //              hsb2rgb(vec3(0.6, 1.0, 0.1)),\n      //              smoothstep(0.0, 1.0, 1.2*m_dist*m_dist));\n\n      color += mix(hsb2rgb(vec3(0.385, 1.0, 0.7)),\n                   hsb2rgb(vec3(0.6, 1.0, 0.1)),\n                   smoothstep(0.0, 1.0, 1.2*m_dist*m_dist));\n\n      color += mix(hsb2rgb(vec3(0.385,1.0,0.3)),\n                   hsb2rgb(vec3(0.7,1.0,0.5)),\n                   smoothstep(0.0, 0.5, m_dist));\n\n      color += mix(hsb2rgb(vec3(0.0,0.9,1.0*(0.5*sin(iTime + st.x)*cos(iTime + st.y) + 0.5))),\n                   hsb2rgb(vec3(0.0,0.0,0.0)),\n                   smoothstep(0.0, 0.35, m_dist));\n\n      color += mix(hsb2rgb(vec3(0.8,0.0,0.0)),\n                   hsb2rgb(vec3(0.9,1.0,0.8)),\n                   smoothstep(0.8, 1.9, m_dist));\n\n      // color += mix(hsb2rgb(vec3(0.385, 1.0, 0.9)),\n      //              hsb2rgb(vec3(0.6, 1.0, 0.3)),\n      //              1.0 / m_dist);\n\n    // Draw cell center\n    // color += 1.-step(.02, m_dist);\n\n    // Draw grid\n    // color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n    // color -= step(.7,abs(sin(27.0*m_dist)))*.5;\n\n    fragColor = vec4(1.0 - color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 24, 24, 117], [119, 119, 145, 145, 365], [367, 449, 471, 471, 863], [865, 865, 922, 922, 3379]]}
{"id": "lsXfW2", "name": "Menger Sponger Cross Section", "author": "Polygon", "description": "I found a way to modify my voxel raytracer to render the Menger Sponge with relatively few iterations, even for high order Menger Sponges!\nI then sliced it, making the cross-sections visible.", "tags": ["fractal", "voxels", "mengersponge"], "likes": 7, "viewed": 257, "date": "1503352366", "time_retrieved": "2024-06-20T18:59:50.460373", "image_code": "#define ORDER 4\n#define FOV 100.\n\n//Don't mess with these.\n#define pi 3.14159265\n#define d2r 0.0174533\n#define WIDTH int(pow(3., float(ORDER)))\n#define TIME iTime * 0.75\n\nvec4 render(vec2 coord);\nint modint(int a, int b) {return a - a/b*b;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = render(fragCoord.xy);\n}\n\n\n\nvec4 render(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv -= .5;\n    \n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 s = coord.xy / maxRes - vec2(0.5 * iResolution.x / maxRes, 0.5 * iResolution.y / maxRes);\n    \n    vec2 uvM = iMouse.xy / iResolution.xy - .5;\n    \n    \n    vec2 rot = 5.*vec2(-uvM.x,-uvM.y);\n    vec3 pos = -1.75 * float(WIDTH) * vec3(sin(rot.x) * cos(rot.y), sin(rot.y), cos(rot.x) * cos(rot.y)) + float(WIDTH) / 2.;\n    \n    vec3 d = vec3(2.0 * s.x * tan(d2r * FOV / 2.0), 2.0 * s.y * tan(d2r * FOV / 2.0), 1.0);\n    d = normalize(d);\n    \n    //Rotations\n    d = vec3(d.x, d.y * cos(rot.y) + d.z * sin(rot.y), d.z * cos(rot.y) - d.y * sin(rot.y));\n    d = vec3(d.x * cos(rot.x) + d.z * sin(rot.x), d.y, d.z * cos(rot.x) - d.x * sin(rot.x));\n    \n    \n    vec4 sky = vec4(0.5 - 0.5 * sin(d.y), 0.7 - 0.3 * sin(d.y),1.0,0.0);\n    vec4 o = sky;\n    \n    \n    vec3 bounderies = vec3(WIDTH) * (0.5 - 0.5 * sign(d));\n    vec3 t = (bounderies - pos) / d;\n    \n    vec3 mask = vec3(greaterThanEqual(t.xyz, max(t.yzx, t.zxy)));\n    \n    if (dot(t, mask) < 0.)\n        return sky;\n    \n    vec3 endPos = (1. - mask) * (pos + d * dot(t, mask))   +   mask * bounderies;\n    \n    //MAIN LOOP\n    for (int j = 0; j < 10; j++) {\n        \n        bool plane = false;\n        \n        if ((endPos.x - float(WIDTH) / 2.)*sin(TIME) + (endPos.z - float(WIDTH) / 2.)*cos(TIME) + (endPos.y - float(WIDTH) / 2.)*sin(TIME/3.14) > (.25 + sin(TIME * 1.4) / 4.) * float(WIDTH)) {\n            plane = true;\n            float T = -(sin(TIME)*(pos.x - float(WIDTH) / 2.) + cos(TIME)*(pos.z - float(WIDTH) / 2.) + (pos.y - float(WIDTH) / 2.)*sin(TIME/3.14) - (.25 + sin(TIME * 1.4) / 4.) * float(WIDTH)) / (sin(TIME)*d.x + cos(TIME)*d.z + sin(TIME/3.14)*d.y);\n            endPos = (pos + d*T);\n        }\n        \n        if (max(endPos.x, max(endPos.y, endPos.z)) > float(WIDTH) || min(endPos.x, min(endPos.y, endPos.z)) < 0.)\n            break;\n        \n        vec3 lastEntered = vec3(equal(endPos, floor(endPos)));\n        ivec3 enter = ivec3(floor(endPos) - (.5 + .5 * -sign(d)) * lastEntered);\n        \n        bvec3 inf;\n        int num = WIDTH / 3;\n        for (int i = 0; i < ORDER; i++) {\n            \n            bvec3 thing = bvec3(!(bool(modint(enter.y / num - 1, 3)) || bool(modint(enter.z / num - 1, 3))), !(bool(modint(enter.x / num - 1, 3)) || bool(modint(enter.z / num - 1, 3))), !(bool(modint(enter.x / num - 1, 3)) || bool(modint(enter.y / num - 1, 3))));\n            \n            if (thing.x || thing.y || thing.z) {\n                \n                if (thing.x && thing.y && thing.z)\n                    inf = bvec3(0);\n                else\n                    inf = thing;\n                \n                break;\n            }\n            \n            num /= 3;\n        }\n        \n        if (num == 0) {\n            o = vec4(1);\n            float dist = distance(endPos, pos);\n            \n            vec3 normal = sign(d) * (lastEntered);\n            if (plane) normal = vec3(sin(iTime), 0, cos(iTime));\n            \n            vec3 lightPos = pos;\n            \n            o = vec4(0);\n            o.xy = vec2(dot(normalize(-lightPos + float(WIDTH) / 2.), normal));\n            o.xy = o.xy / 2. + .5;\n            if (plane) o.xyz = vec3(1,0,0);\n            \n            o /= (dist * dist / float(WIDTH * WIDTH) / 4. + 1.);\n            break;\n        }\n        \n        ivec3 nextPlane = num * (enter / num) + num * ivec3(.5 + .5 * sign(d));\n        //ivec3 nextPlane = enter + (ivec3(sign(d)) + 1) / 2;\n        \n        nextPlane += 10000 * ivec3(inf) * ivec3(floor(sign(d)));\n        \n        vec3 distToNext = (vec3(nextPlane) - endPos) / d;\n        bvec3 mask = lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy));\n        float time = dot(distToNext, vec3(mask));\n        \n        endPos = vec3(mask) * vec3(nextPlane) + (endPos + d * time) * (1. - vec3(mask));\n        \n    }\n    \n    \n    return o;\n}\n\n\n/*\nbool check(vec3 pos) {\n    ivec3 uv = ivec3(pos);\n    \n    int num = WIDTH;\n    for (int i = 0; i < ORDER; i++) {\n        num /= 3;\n        if (!((bool(modint(uv.x / num - 1, 3)) || bool(modint(uv.y / num - 1, 3)) && bool(modint(uv.z / num - 1, 3))) && (bool(modint(uv.y / num - 1, 3)) || bool(modint(uv.z / num - 1, 3)))))\n            return false;\n    }\n    \n    return true;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[34, 196, 222, 222, 240], [242, 242, 299, 299, 339], [343, 343, 368, 368, 4309]]}
{"id": "ltlcR8", "name": "Assert macro in glsl", "author": "gloinart", "description": "Implementation of an assert macro in GLSL\n- Blinks where the assertion has failed\n- Blinks in different colors depending on how many times the asserts has failed\n- Toggle DEBUG to enable\\disable\n- Requires MAIN_IMAGE_EXIT() as last line of mainImage(...)\n", "tags": ["tricks", "assert"], "likes": 1, "viewed": 437, "date": "1503479458", "time_retrieved": "2024-06-20T18:59:50.805807", "image_code": "/* License: Use as you will as long as you credit me somewhere! */\n\n\n// Toggle to enable-disable ASSERTS\n#define DEBUG 1\n\n// Asserts enabled\n#if DEBUG == 1\nint _assertion_fail_count_ = 0;\nvec4 _assert_color_func(int ifail_count) {\n  // Blink in different colors depending on how many times the assert broke\n  vec4 blink_color = vec4(1.0, 1.0, 1.0, 1.0);\n  if(ifail_count == 1)      blink_color = vec4(0.0, 0.0, 1.0, 1.0);\n  else if(ifail_count == 2) blink_color = vec4(0.0, 1.0, 0.0, 1.0);\n  else if(ifail_count == 3) blink_color = vec4(0.0, 1.0, 1.0, 1.0);\n  else if(ifail_count == 4) blink_color = vec4(1.0, 0.0, 0.0, 1.0);\n  else if(ifail_count == 5) blink_color = vec4(1.0, 0.0, 1.0, 1.0);\n  else                      blink_color = vec4(1.0, 1.0, 0.0, 1.0);\n    \n  return (mod(iTime, 1.0) > 0.5) ? blink_color :  vec4(1.0, 1.0, 1.0, 1.0);\n}\n\n#define ASSERT(condition) while(!(condition)){ ++_assertion_fail_count_; break; }\n#define MAIN_IMAGE_EXIT() while(_assertion_fail_count_ != 0) { fragColor = _assert_color_func(_assertion_fail_count_); break; }\n\n// Asserts disabled\n#else\n#define ASSERT(condition)\n#define MAIN_IMAGE_EXIT()\n#endif\n\n\n\n\n\n// Use in free functions\nfloat func(vec2 iuv) {\n  if(iuv.y < 0.02) ASSERT(false);\n  return iuv.y;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Assert just like regular C code\n    ASSERT(uv.x < 0.90); \n    ASSERT(uv.x < 0.95); \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor.g += func(uv);\n    MAIN_IMAGE_EXIT(); // Required at exit of main function\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlcR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1147, 1172, 1194, 1194, 1246], [1250, 1250, 1307, 1307, 1582]]}
{"id": "ltlyzN", "name": "Julia fractal viewer", "author": "asteriskman", "description": "Display julia fractal for the mouse point. Add some jiggle to help explore the space. Aspect ratio fixed thanks to help from the user named iq", "tags": ["fractal"], "likes": 1, "viewed": 413, "date": "1503870099", "time_retrieved": "2024-06-20T18:59:51.363462", "image_code": "\nfloat absVal2(float r, float i) {\n  return r*r + i*i;\n}\n\nfloat rnd(float seed) {\n  float x = sin(seed) * 10000.0;\n  return x - floor(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    float width = iResolution.x;\n    float height = iResolution.y;\n    \n    float maxTime = 5.0;\n    float modTime = mod(floor(iTime), maxTime) + fract(iTime);\n    float modNum = floor(iTime / maxTime);\n    float modRnd = rnd(modNum);\n    \n    \n    float targetX;\n    float targetY;\n    targetX = -0.5495;\n    targetY = 0.5377;\n    //targetX = rnd(modRnd*11.0) * 4.0 - 2.0;\n    //targetY = 0.0;\n    targetX = 0.0;\n    targetY = 0.0;\n\n    \n    \n    float minx = -2.0;\n    float maxx = 2.0;\n    float miny = -1.5;\n    float maxy = 1.5;\n    \n    float scale;\n    scale = pow(2.0, - modTime);\n    scale = 1.0;\n    \n    minx = targetX - 2.0 * scale;\n    maxx = targetX + 2.0 * scale;\n    miny = targetY - 1.5 * scale;\n    maxy = targetY + 1.5 * scale;\n    \n\n    //float x = (fragCoord.x / width) * (maxx - minx) + minx;\n    //float y = (fragCoord.y / height) * (maxy - miny) + miny;\n    float x = ((fragCoord.x-width*0.5) / height) * (maxy - miny);\n    float y = (fragCoord.y / height) * (maxy - miny) + miny;\n    \n    int maxIter = 200;\n    \n    float zr = 0.0;\n    float zi = 0.0;\n    float cr = x;\n    float ci = y;\n    float zrt;\n    float zit;\n    \n    int i = 0;\n    \n    zr = x ;\n    zi = y ;\n    float mouseScale = 2.0;\n    //cr = mouseScale * (iMouse.x / width - 0.5) * sin(iTime * 1.3);\n    //ci = mouseScale * (iMouse.y / height - 0.5) * cos(iTime * 0.98);\n    float timeScale = 50.0;\n    float wiggleScale = 0.001;\n    cr = mouseScale * (iMouse.x / width - 0.5) + wiggleScale * sin(iTime * timeScale);\n    ci = mouseScale * (iMouse.y / height - 0.5) + wiggleScale * cos(iTime * timeScale);\n    \n    while ((absVal2(zr, zi) < 4.0) && (i < maxIter)) {\n        //z = z^2 + c\n        //    (zr + zi)^2 + cr + ci\n        //    zr*zr -zi*zi + 2*zr*zi + cr + ci\n        zrt = zr*zr - zi*zi + cr;\n        zit = 2.0*zr*zi + ci;\n        zr = zrt;\n        zi = zit;\n        i = i + 1;\n    }\n    \n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    /*\n    if (i < maxIter) {\n        //r = float(i) / float(maxIter);\n        r = sin((float(i)/float(maxIter)) * 3.14159/2.0 + iTime*0.1);\n        g = sin((float(i)/float(maxIter)) * 3.14159/2.0 + iTime*0.3);\n        b = sin((float(i)/float(maxIter)) * 3.14159/2.0 + iTime*0.9);\n    } else {\n        r = 1.0-sin(iTime*0.1);\n        g = 1.0-sin(iTime*0.3);\n        b = 1.0-sin(iTime*0.9);\n    }\n    */\n    //r = absVal2(zr, zi) / 10.0;\n    g = 1.0 - absVal2(zr, zi) / 10.0;\n    //r = sin(absVal2(zr, zi));\n    r = absVal2(zr, zi) * float(i) / float(maxIter);\n    b = absVal2(zr, zi) / 10.0;\n    \n    fragColor = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlyzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 34, 34, 56], [58, 58, 81, 81, 139], [141, 141, 198, 295, 2880]]}
{"id": "ltscRN", "name": "sliding bar", "author": "aferriss", "description": "Simple bar, back and forth", "tags": ["sin", "wipe", "bar", "slide"], "likes": 4, "viewed": 434, "date": "1503860985", "time_retrieved": "2024-06-20T18:59:51.363462", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat o = iResolution.x;\n    o += smoothstep(1.0/o, 0., abs(sin(iTime)*0.5+0.5 -uv.x) - .05)-o;\n\tfragColor = vec4(o,o,o,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltscRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 228]]}
{"id": "ltXyRM", "name": "Hotomopy of linear maps", "author": "etale_cohomology", "description": "A homotopy is a map between maps. Here we show a homotopy between the identity linear map and a user-given linear map.\n\nIs there a better way of making a grid? This grid sucks if the linear map zooms in/out too much!", "tags": ["2d", "simple", "math", "linear", "algebra", "transformations", "maps", "homotopy"], "likes": 4, "viewed": 126, "date": "1503990502", "time_retrieved": "2024-06-20T18:59:51.654551", "image_code": "// A linear map is a map between vector spaces that preserves linear combinations.\n\n// Every linear map admits a representation as a matrix; \n// this matrix representation is unique if we fix a basis for both vector spaces (domain and codomain),\n// otherwise the linear map has infinitely-many matrix representations.\n// Conversely, every matrix represents a linear map;\n// this linear map is unique if we fix a basis for both vector spaces (domain and codomain),\n// otherwise the matrix represents infinitely-many linear maps.\n\n// A homotopy is a map between maps.\n// If f and g are 2 maps, then a simple homotopy between f and g is given by (1 - t) * f + t * g,\n// as t ranges over the unit interval.\n\n// Here we show a homotopy between the identity linear map and a user-given linear map.\n\n// Define your linear map here!\nconst mat2 LINEAR_MAP = mat2(1, 0, 1, 0);//mat2(2, -1, 1, 1);  // Write the linear map in row-major!\n\nfloat draw_grid(vec2 uv){\n    float zoom = 2.;\n    float antialias = 12. * zoom / iResolution.y;\n    vec2 grid_2D = smoothstep(antialias, 0., abs(sin(3.14159 * zoom * uv)));\n    return max(grid_2D.x, grid_2D.y);\n}\n\nvec2 linear_map(vec2 uv){\n\tmat2 identity_matrix = mat2(1, 0, 0, 1);\n    mat2 matrix = LINEAR_MAP;\n\n    float t = (1. + sin(iTime)) * .5;  // Squash the sine map to [0; 1]\n\n    uv.x *= -1.;  // Ensure the linear map retains it handedness!\n    mat2 deformed_matrix = (1. - t) * identity_matrix + t * matrix;\n    return uv * deformed_matrix;  // Apply to linear map to each point `uv`!\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n\n    uv = linear_map(uv);\n\n    float grid = draw_grid(uv);\n    fragColor.rgb = vec3(grid);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltXyRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[793, 927, 952, 952, 1140], [1142, 1142, 1167, 1167, 1526], [1528, 1528, 1582, 1582, 1761]]}
{"id": "MdBBDK", "name": "raymarching-tests", "author": "bytearray", "description": "facncy and trippy :D", "tags": ["3d", "raymarching", "visualization"], "likes": 2, "viewed": 461, "date": "1502389925", "time_retrieved": "2024-06-20T18:59:51.654644", "image_code": "#define PI 3.1415926535897932384626433832795\n#define MAX_MARCHING_STEPS 100\n#define EPSILON 0.0001\n#define start 0.1\n#define end 100.0\n\nvec3 bug = vec3(0);\n\n\nfloat sphere(in vec3 pos, in float r)\n{\n    return length(pos) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat soundSphere(vec3 pos, float r)\n{\n    float ry = atan(pos.x / pos.z);\n    float rx = atan(pos.y / pos.z);\n    \n    int a = int(fract((ry / PI / 4. + .5) * 3.) * 512.);\n    int b = int(fract((rx / PI / 4. + .5) * 3.) * 512.);\n    \n    float freq = texelFetch( iChannel0, ivec2(0, 0), 0).x; \n    float wave = texelFetch( iChannel0, ivec2(0, 1), 0).x;\n    //bug.r = float(a);\n    float disp = wave / 10. + freq;\n    \n    return length(pos) - r - disp;\n}\n\n\nvoid intersect(inout float distA, float distB)\n{\n    distA = max(distA, distB);\n}\n\nvoid combine(inout float distA, float distB)\n{\n    distA = min(distA, distB);\n}\n\nvoid difference(inout float distA, float distB)\n{\n    distA = max(-distA, distB);\n}\n\n//pos, layer direction, layer gap, laver offet, ball size\nfloat layer(vec3 p, vec3 d, vec3 g, vec3 o, float s)\n{\n    p += mod(d * iTime + o, g);\n    vec3 q = mod(p, vec3(g))-0.5*vec3(g);\n    return sphere(q, s);\n}\n\nfloat sdf(vec3 pos)\n{\n    float b = 10000.;\n    float u = .4;\n    float s = .33;\n    float k = .5;\n    \n    combine(b, layer(pos, vec3( 0., 0., s ), vec3(u*3.), vec3(0., u , 0.), k));\n    combine(b, layer(pos, vec3( 0., s , 0.), vec3(u*3.), vec3(u , 0., 0.), k));\n    combine(b, layer(pos, vec3( s , 0., 0.), vec3(u*3.), vec3(0., 0., u ), k));\n    combine(b, layer(pos, vec3( 0., 0.,-s ), vec3(u*3.), vec3(0., -u, 0.), k));\n    combine(b, layer(pos, vec3( 0.,-s , 0.), vec3(u*3.), vec3(-u, 0., 0.), k));\n    combine(b, layer(pos, vec3(-s , 0., 0.), vec3(u*3.), vec3(0., 0., -u), k));\n    \n    difference(b, soundSphere(pos, 1.));\n    return b;\n}\n\nfloat ray(vec3 eye, vec3 dir)\n{\n    float depth = start;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        float dist = sdf(eye + depth * dir);\n        \n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    uv.x += (1. - iResolution.x / iResolution.y) / 2.;\n    vec2 st = uv - vec2(.5);\n    \n    vec3 eye = vec3(sin(iTime)*7., cos(iTime)*5., 4.);\n    vec3 dir = vec3(st / 2., -1.);\n    \n    mat4 mat = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.));\n    dir = (mat * vec4(dir, 1.)).xyz;\n    \n    float depth = ray(eye, dir);\n    if(!(depth >= end - EPSILON))\n    {\n        vec3 hit = eye + dir * depth;\n    \tvec3 norm = estimateNormal(hit);\n        \n        fragColor = vec4(norm+vec3(.5), 1.);\n    }\n    else\n    {\n        fragColor = vec4(0);\n    }\n    fragColor.rgb += bug;\n}\n", "image_inputs": [{"id": "lsXSD2", "previewfilepath": "https://soundcloud.com/dodo-ahmed-611/macklemore-ryan-lewis-cant-hold-us-feat-ray-dalton", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dodo-ahmed-611/macklemore-ryan-lewis-cant-hold-us-feat-ray-dalton", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBBDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[158, 158, 197, 197, 227], [229, 229, 258, 258, 345], [347, 347, 385, 385, 802], [805, 805, 853, 853, 886], [888, 888, 934, 934, 967], [969, 969, 1018, 1018, 1052], [1054, 1112, 1166, 1166, 1267], [1269, 1269, 1290, 1290, 1914], [1916, 1916, 1947, 1947, 2259], [2261, 2261, 2290, 2290, 2570], [2572, 2572, 2621, 2621, 2808], [2810, 2810, 2867, 2867, 3518]]}
{"id": "MdBBWG", "name": "36.0174", "author": "etrepum", "description": "circle", "tags": ["smoothstep"], "likes": 0, "viewed": 89, "date": "1501869800", "time_retrieved": "2024-06-20T18:59:51.654644", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.4 * min(iResolution.x, iResolution.y);\n    vec3 blur = 30.0 + 28.0 * sin(iTime * vec3(1, 1.1, 1.2));\n    vec2 c = 0.5 * iResolution.xy;\n    vec3 dist = smoothstep(-blur, blur, vec3(abs(distance(fragCoord, c) - radius)));\n\tfragColor = vec4(\n        dist,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 353]]}
{"id": "MdBBWK", "name": "Variable depth simplex terrain", "author": "tiusic", "description": "Varying the depth of simplex noise based on more simplex noise. This changes the average feature size of the terrain in different areas, allowing for huge continents and intricate archipelagos.", "tags": ["procedural", "fractal", "simplex"], "likes": 2, "viewed": 117, "date": "1502172128", "time_retrieved": "2024-06-20T18:59:51.654644", "image_code": "float R2 = 0.5;\nfloat TAU = 6.28318530718;\nfloat F = 0.86602540378;\n\nvec2 hash(vec2 p, float z) {\n    vec3 p3 = vec3(p, z);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    float t = TAU * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(t), sin(t));\n}\n\nvec2 skew(vec2 p) {\n    p.y /= F;\n    p.x += 0.5 * p.y;\n    return p;\n}\n\nvec2 unskew(vec2 q) {\n    q.x -= 0.5 * q.y;\n    q.y *= F;\n    return q;\n}\n\nfloat surflet(vec2 q, vec2 p, float z) {\n    vec2 h = hash(q, z);\n    vec2 d = unskew(q) - p;\n    float d2 = d.x * d.x + d.y * d.y;\n    return pow(max(0.0, R2 - d2), 4.0) * dot(d, h);\n}\n\nfloat simplex(vec2 p, float z) {\n    vec2 q = skew(p);\n    vec2 qa = floor(q);\n    vec2 qi = q - qa;\n    vec2 qb = qa + vec2(1.0, 1.0);\n    vec2 qc;\n    \n    if (qi.x < qi.y) {\n\t\tqc = qa + vec2(0.0, 1.0);\n    } else {\n\t\tqc = qa + vec2(1.0, 0.0);\n    }\n    \n    float ka = surflet(qa, p, z);\n    float kb = surflet(qb, p, z);\n    float kc = surflet(qc, p, z);\n    return ka + kb + kc;\n}\n\nfloat lim(float x) {\n    return max(0.0, min(1.0, x));\n}\n\nfloat noise(vec2 p, float l, float w) {\n    float k = 0.0;\n    float o = 1.0;\n    float z;\n    for (z = 0.0; z < l; ++z) {\n        k += simplex(p / o, z + w) * o;\n        o *= 2.0;\n    }\n    k += (l + 1.0 - z) * simplex(p / o, z + w) * pow(2.0, l);\n    return lim(0.5 + 50.0 * k / pow(2.0, l));\n}\n\nvec4 terrain(float k) {\n    k = lim(k);\n    if (k < 0.5) {\n        return vec4(0.0, k, 0.7 + 0.6 * k, 1.0);\n    } else if (k < 0.55) {\n        return vec4(1.0, 4.0 * (k - 0.5) + 0.8, 0.6, 1.0);\n    } else if (k < 0.8) {\n        return vec4(0, 0.5 * k + 0.5, 0.0, 0.0);\n    } else if (k < 0.85) {\n        return vec4(0, -9.1 * k + 8.18, 0.0, 1.0);\n    }\n    return vec4(0, (1.0 - k) * 0.3 + 0.4, 0.0, 1.0);\n}\n\nfloat grid(vec2 p, float cam, float size) {\n    size *= 30.0;\n    float cc = sqrt(0.25 * cam / size);\n    vec2 d = abs(mod(p / size + 0.5, 1.0) - 0.5);\n    float dd = min(d.x, d.y);\n    if (dd < cc) {\n        return 1.0 - dd / cc;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = 0.5 + 0.5 * sin(0.1 * iTime);\n    float cam = 1.0 + 50.0 * zoom;\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) * cam;\n    p += 1000.0 * vec2(10.0 * sin(iTime / 10.0), iTime);\n    \n    float l = noise(p / 100.0, 7.0, 0.0);\n    float k = noise(p, 9.0 + 5.0 * l, 100.0);\n    float m = noise(p, 16.0, 0.0);\n    float h = 3.0 * m + 0.6 * k - 2.0;\n    float r = 1.0 - abs(noise(p / 6.0, 12.0, 200.0) - 0.5) * 100.0;\n    if (r > 0.0 && h > 0.5) {\n        h = min(h, 0.55 - 0.1 * r);\n    }\n    fragColor = terrain(h);\n    \n    if (zoom < 0.25) fragColor += 0.1 * grid(p, cam, 1.0) * smoothstep(zoom, 0.25, 0.15);\n    fragColor += 0.1 * grid(p, cam, 10.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBBWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[69, 69, 97, 97, 268], [270, 270, 289, 289, 341], [343, 343, 364, 364, 416], [418, 418, 458, 458, 603], [605, 605, 637, 637, 990], [992, 992, 1012, 1012, 1048], [1050, 1050, 1089, 1089, 1346], [1348, 1348, 1371, 1371, 1755], [1757, 1757, 1800, 1800, 2011], [2013, 2013, 2068, 2068, 2737]]}
{"id": "MdBfW3", "name": "Blinn Phong Sphere", "author": "vondirac", "description": "This is a simple implementation of the modified Blinn-Phong Shading model (as presented in Real-Time Rendering)  applied to a sphere with multiple light sources.\n", "tags": ["phong", "sphere", "blinn", "blinnphong", "shaderequation"], "likes": 2, "viewed": 380, "date": "1502413773", "time_retrieved": "2024-06-20T18:59:51.654644", "image_code": "#define PI 3.1415926535897932384626433832795\n#define t iTime * 0.5\n\nvec3 shade(float r, vec2 center, vec2 pos, vec3 l[2])\n{\n    float z = sqrt(r * r - pos.x * pos.x - pos.y * pos.y);\n    vec3 n = normalize(vec3(pos.x, pos.y, z)); \t\t// Surface normal\n\n    vec3 c_diff = vec3(0.9, 0.0, 0.7);\t\t\t\t// Diffuse color    \n    vec3 c_spec = vec3(0.0, 1.0, 1.0);\t\t\t\t// Specular color\n\n    float m = 11.0; \t\t\t\t\t\t\t\t// Surface Smoothness\n    float El = 0.9; \t\t\t\t\t\t\t\t// Irradiance of light source\n    vec3 Kd = c_diff.xyz / PI; \t\t\t\t\t\t// Diffuse term\n    vec3 Ks = c_spec.xyz * ((m + 8.0) / (8.0 * PI));// Specular term\n\n    vec3 Lo = vec3(0.0);\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 h = normalize(l[i] + n); // Half vector\n\n        float cosTi = max(dot(n, l[i]), 0.0);\n        float cosTh = max(dot(n, h), 0.0);\n        Lo += (Kd.xyz + Ks.xyz * pow(cosTh, m)) * El * cosTi; // Outgoing radiance\n    }  \n\n    return Lo; \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//\tSphere Definition\n\tvec2 center = iResolution.xy / 2.0;\n\tfloat r = iResolution.y / 3.0;\n\tvec2 pos = fragCoord.xy - center;\n\n\t//\tLight vector\n\tvec3 l[2];\n    l[0] = normalize(vec3(sin(t), sin(t), cos(t)));\n    l[1] = normalize(vec3(-sin(t), cos(t), sin(t)));\n\n    // Outgoing radiance\n\tvec3 Lo = shade(r, center, pos, l);\n\n\tfragColor = vec4(Lo, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[68, 68, 123, 123, 926], [929, 929, 986, 1008, 1341]]}
{"id": "MdBfzt", "name": "Moving Sin", "author": "ircss", "description": "A moving Sin Funcction practicce", "tags": ["sin"], "likes": 2, "viewed": 96, "date": "1501665010", "time_retrieved": "2024-06-20T18:59:52.175655", "image_code": "vec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\n    \n\treturn  ((1.0 - value) * colorone) + (value * colortwo);\n}\n\n\n  vec3 HUEtoRGB(in float H)\n  {\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return abs(vec3(R,G,B));\n  }\n\n \n \n  vec3 HCYtoRGB(in vec3 HCY)\n  {\n     // The weights of RGB contributions to luminance.\n  // Should sum to unity.\n     vec3 HCYwts = vec3(0.299, 0.587, 0.114);\n    vec3 RGB = HUEtoRGB(HCY.x);\n    float Z = dot(RGB, HCYwts);\n    if (HCY.z < Z)\n    {\n        HCY.y *= HCY.z / Z;\n    }\n    else if (Z < 1.0)\n    {\n        HCY.y *= (1.0 - HCY.z) / (1.0 - Z);\n    }\n    return (RGB - Z) * HCY.y + HCY.z;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    // Setting up the uv coo\n    \n    vec2 uv = (fragCoord.xy / iResolution.xx);\n     vec2 uv0=uv;\n    \n    // Setting up the time. \n    float time=iTime*1.0;\n    \n    // Color Desenation and other settings\n    \n    \n    //vec3 colorHCY = vec3(0.2,1,0); \n    \n    \n    \n    \n    // Setting up color.\n    \n    vec2 centre = vec2(0.5, 0.2);\n    vec2 currentToCentre = uv - centre;\n    \n    float distanceToEdge = 1.0- length(currentToCentre)/2.0;\n    \n    vec3 background = vec3(0.2,0,distanceToEdge); \n    \n    \n    \n    float color = abs( sin(time * 0.5 + uv.x*0.7)) ;\n    \n    vec3 graphColor = vec3(color ,1.0, 0.1 + length(currentToCentre)/1.0 ); \n    \n    float graphThickness = 500.0;\n    \n    \n    // Graph Calculations \n    \n    \n    float height = 0.02 +  abs( cos(time * 2.0)) * 0.1;\n    height = 0.5;\n    \n    float desiredPixel =  sin(uv.x *30.0 + time) *height +  iResolution.y/1500.0;\n    \n    float distanceToDesiredPixel = abs(uv.y - desiredPixel);\n    \n    /*\n    if(distanceToDesiredPixel <= 0.005){\n        \n          float color = abs( sin(time * 0.5 + uv.x*0.7)) ;\n          colorHCY = vec3(color ,0.6,0.7); \n    }\n\t*/\n    \n    \n    \n    vec3 colorHCY = abs( mix(graphColor, background, \n                             clamp( distanceToDesiredPixel* graphThickness, 0.0, 1.0)));\n\n    \n    // Conversion\n\n    vec3 colorRGB = HCYtoRGB(colorHCY);\n\tfragColor= vec4(colorRGB,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdBfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 54, 54, 120], [125, 125, 154, 154, 307], [315, 315, 345, 426, 715], [718, 718, 775, 806, 2171]]}
{"id": "MdjBD3", "name": "hole to town", "author": "Coolok", "description": "hole to town", "tags": ["holetotown"], "likes": 1, "viewed": 75, "date": "1502567663", "time_retrieved": "2024-06-20T18:59:52.545417", "image_code": "float alterDistance(vec2 v1, vec2 v2, float strength, float speed) \n{\n  return sin(dot(normalize(v1), normalize(v2)) * strength + speed * iTime) / 100.0;\n}\n\nfloat alterDistance(vec2 uv, vec2 center) \n{\n  vec2 diff = center - uv;\n  float len = length(diff);\n\n  len += alterDistance(diff, vec2(0.0, 1.0), 10.0, 2.0);\n  len -= alterDistance(diff, vec2(1.0, 0.0), 10.0, 2.0);\n\n  return len;\n}\n\nfloat limit(float x, float min, float max)\n{\n    if (x < min)\n        x = 0.0;\n    \n    if (x > max)\n        x = 1.0;\n    \n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec4 color = texture(iChannel0, uv);\n    \n\tvec2 center = vec2(0.5, .5); \n    \n    vec2 p = ceil(uv * 300.0) / 300.0;\n\t\n\tfloat d = alterDistance(center, p);\n    \n    vec4 pink = vec4(0.89, 0.0, 0.69, 1.0) * 0.75;\n    \n    float t = iTime * 0.1;\n    \n    float cloud = texture(iChannel1, p +  vec2(t, t)).r;\n    float cloud2 = texture(iChannel1, 0.5 * p + vec2(t, -t)).r;\n    \n    cloud = mix(cloud, cloud2, 0.5);\n        \n    float r1 = 0.2;\n    float r2 = 0.225;\n    float r3 = 0.25;\n    \n    if (d <= r1)\n    {\n        fragColor = color;\n    }\n    else if (d <= r2)\n    {\n        fragColor = pink;\n    }\n    else if (d <= r3)\n    {\n        float nd = (d - r2) / (r3 - r2); \n    \tfragColor = limit(cloud, 0.3, mix(0.3, 0.4, nd)) * pink;\n    }\n    else\n    {\n    \tfragColor = limit(cloud, 0.3, 0.4) * pink;\n    }\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 69, 69, 155], [157, 157, 201, 201, 388], [390, 390, 434, 434, 528], [530, 530, 587, 587, 1446]]}
{"id": "MdjBWy", "name": "Malaysian flag", "author": "gsynuh", "description": "using http://pixelspiritdeck.com/ by Patricio Gonzales Vivo\nmy childhood/teenage country I wish to get back to\n\ntaking this opportunity to say hi to sonaone ;p", "tags": ["2d", "flag"], "likes": 2, "viewed": 184, "date": "1502100190", "time_retrieved": "2024-06-20T18:59:52.545417", "image_code": "// SDFs and fill function from http://pixelspiritdeck.com/ \n// simplifications and AA suggested by FabriceNeyret2 in the comments\n// noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n\nfloat starSDF(vec2 st, int V, float s) {\n\tst = st*4.-2.;\n    float a0 = atan(st.y,st.x),\n         seg = a0 * float(V)/TAU,\n           a = ((floor(seg) + 0.5) / float(V) + mix(s,-s,step(.5,fract(seg)))) * TAU;\n    return cos(a-a0)*length(st);\n}\n\nfloat rectSDF(vec2 st, vec2 s) {\n\tvec2 a = abs ( (st*2.-1.) / s);\n    return max(a.x,a.y);\n}\n\nfloat circleSDF(vec2 st) {\n\treturn length(st -.5)*2.;\n}\n\nfloat fill(float x, float size) {\n\treturn smoothstep(3./iResolution.y, 0., x-size);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\nfloat wavephase(float x) {\n    return noise(vec2(x + iTime*0.5))*4.3 + x*8. + iTime*6.223;\n}\n\nfloat wave(float x) {\n    return cos(wavephase(x))*x*x*0.5;\n}\n\nfloat waveS(float x) {\n    return sin(wavephase(x))*x*x*0.5;\n}\n\n\nfloat waveNoise(float x) {\n\treturn wave(x) - wave(0.);\n}\n\nfloat waveNoiseS(float x) {\n\treturn waveS(x) - waveS(0.);\n}\n\nvec3 yellow =  vec3(1.,0.8,0.);\nvec3 blue =  vec3(0.004,0.,0.4);\nvec3 red =  vec3(0.8,0.,0.004);\nvec3 black = vec3(0.);\nvec3 white = vec3(1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    //note : malaysian flag ratio is 2:1\n    \n    uv *= 1.4;\n    uv += vec2(1.,0.5);\n    \n    //wavy flag\n    uv.y += waveNoise(-uv.x)*0.01;\n    \n    //a bit of noise\n    uv += noise(uv*2. + iTime*3.)*0.008;\n    \n    //color base\n    vec3 color = vec3(1.);\n    \n    //Crescent and star\n\n    vec2 starPos = (vec2(uv) + vec2(0.05,-0.21)) ;\n    float crescentC = fill(circleSDF(starPos),0.4);\n    crescentC -= fill(circleSDF(starPos - vec2(0.05,0.)),0.35);\n    crescentC = clamp(crescentC,0.,1.);\n    \n    starPos -= vec2(0.2,0.);\n    \n    float s = smoothstep(\n        starSDF(starPos.yx,14,.18),\n        starSDF(starPos.yx,14,.177),\n        0.14);\n    \n    crescentC += s;\n    \n    //stripes\n    float stripesC = clamp(-8.* sin( 6.27*uv.y*(14. * .5) ) , 0.,1.);\n    \n    //rect\n    vec2 rectSize = vec2(1.0,8.05/14.);\n    vec2 rectPos = uv + vec2(0.005,-3.005/14.0);\n    float rectC = fill(rectSDF(rectPos,rectSize),1.);\n    \n    //shadow\n    float shadowDistance = 0.06;\n    float shadowSmooth = 0.06;\n    float shadowC = smoothstep(1.,1.-shadowSmooth,rectSDF(\n        uv - vec2(0.5+shadowDistance,-shadowDistance),\n        vec2(2.,1.)));\n                      \n    \n    color = mix(color,red,stripesC);\n    color = mix(color,blue,rectC);\n    color = mix(color,yellow,crescentC);\n    \n    //highlight\n    color *= (1.-waveNoiseS(-uv.x))* 0.10 + 0.9;\n    \n    //mask\n    float maskC = fill(rectSDF(vec2(uv) - vec2(0.5,0.),vec2(2.,0.99)),1.);\n    color = mix(yellow,color,maskC);\n    \n    \n    float shadowOut = clamp(shadowC-maskC,0.,1.);\n    color = mix(color,black, shadowOut * 0.05);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 293, 333, 333, 536], [538, 538, 570, 570, 630], [632, 632, 658, 658, 687], [689, 689, 722, 722, 774], [776, 776, 796, 796, 863], [865, 865, 885, 885, 1094], [1097, 1097, 1123, 1123, 1189], [1191, 1191, 1212, 1212, 1252], [1254, 1254, 1276, 1276, 1316], [1319, 1319, 1345, 1345, 1375], [1377, 1377, 1404, 1404, 1436], [1582, 1582, 1639, 1639, 3331]]}
{"id": "MdjBzd", "name": "Landscape22", "author": "Dude", "description": "Landscape", "tags": ["landscape"], "likes": 1, "viewed": 152, "date": "1501791474", "time_retrieved": "2024-06-20T18:59:52.551059", "image_code": "\n\n\n#define MAXIMUM_STEPS 1290\n#define DISTANCE_THRESHOLD .3\n#define FAR_CLIP 120.0\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opDisplace( vec3 p, vec4 t )\n{\n    float d1 = sdPlane(p, t);\n    float d2 = (sin(1.9*p.x+(sin(p.z)*2.))*0.9-1.)*.3;\n    float d3 = cos(mod(p.z,133.))*0.3*sin(iTime*4.);\n    return d1+d2+d3;\n}\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat nearestSurface(vec3 rp) {\n    \n    float msd = 99999.;\n    vec4 plo = vec4(.0,.2,.0,.0);\n    \n    float orientation = 0.2;\n    msd = min(msd, opDisplace(rp, plo)); \n\n    return msd;\n}\n\n/* RAY MARCHING */\n\n//march a single ray\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        float ns = nearestSurface(rp);\n        d += ns;\n        \n        if (abs(ns) < DISTANCE_THRESHOLD*0.5) {\n            rp.xyz += 4.;\n            rp.xyz /= 8.;\n            vec4 clr = vec4(1.);\n            \n            pc = vec4(sin(rp.x), sin(rp.y), sin(rp.z), 1)*clr;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            pc = vec4(0.1, 0.3, 0.9, 1.);\n            pc *= 1.-smoothstep(0.02, 0.33, rd.y) + 0.8;\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0, 7, -20.+float(iFrame)/15.);\n\n    rY(ro, -cos(iTime) * .0006);\n    rY(rd, sin(iTime) * .02);\n    rX(rd, .5);\n    \n\tfragColor = marchRay(ro, rd);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[85, 85, 118, 144, 175], [177, 177, 213, 213, 374], [376, 393, 425, 425, 545], [547, 547, 579, 579, 700], [702, 702, 734, 734, 854], [856, 856, 887, 887, 1045], [1067, 1088, 1121, 1121, 1793], [1795, 1795, 1850, 1850, 2190]]}
{"id": "MdSfW3", "name": "Branch and Bounce", "author": "Homaniac", "description": "updated version", "tags": ["snoise", "hsbcolors"], "likes": 4, "viewed": 198, "date": "1502411700", "time_retrieved": "2024-06-20T18:59:53.539351", "image_code": "#define PI 3.14159265358979\n#define TWO_PI 2.0*PI\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                           6.0)-3.0)-1.0,\n                   0.0,\n                   1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 random2(vec2 st){\n  st = vec2( dot(st,vec2(127.1,311.7)),\n             dot(st,vec2(269.5,183.3)) );\n  return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = f*f*(3.0-2.0*f);\n\n  return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                   dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n              mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n  return mat2(cos(angle),-sin(angle),\n              sin(angle),cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st = st*2.0 - vec2(1.0);\n  st.x *= iResolution.x / iResolution.y;\n\n  float rand = snoise(5.0*st);\n\n  float oA = atan(st.y,st.x) + PI;\n  float a = oA;\n  float oR = 0.5*length(st);\n  float r = oR;\n  r += 0.2*abs(rand);\n  a += rand;\n\n  // float f = 5.0*abs(0.2*sin(a*11.0+4.0*iTime)*cos(a*1.0+0.7*iTime));\n  float f = abs(cos(a*12. + iTime)*sin(a*3. + iTime))*(sin(iTime) + 1.) + .07;\n  // float f = smoothstep(-.5, .5, cos(a*20. + iTime))*(sin(iTime) + 0.3)+0.7;\n\n  vec3 rgb = hsb2rgb(mix(vec3(rand, step(r,f), step(r,f)),\n                         vec3(f, step(r,f), step(r,f)),\n                         clamp(oR, 0.0, 1.0)));\n\n  fragColor = vec4(rgb,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[51, 76, 97, 97, 144], [145, 145, 166, 166, 213], [214, 214, 236, 236, 271], [273, 594, 616, 669, 2366], [2368, 2442, 2468, 2468, 2688], [2690, 2690, 2712, 2712, 2846], [2848, 2930, 2952, 2952, 3344], [3346, 3346, 3373, 3373, 3451], [3453, 3453, 3510, 3510, 4212]]}
{"id": "MlfczH", "name": "Optical deconstruction 1b", "author": "ollj", "description": "Mouse in:\n\nthe [optical circuit demo] video source code once appeared on glslsandbox.com\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\nit is fractal code golf overkill in [0..6] scenes.\nthis is a deconstruction of scene 1.", "tags": ["fractal", "optical", "glow", "kifs", "circuit", "0x4015"], "likes": 77, "viewed": 3930, "date": "1503408217", "time_retrieved": "2024-06-20T18:59:54.921171", "image_code": "//self 1: https://www.shadertoy.com/view/MlfczH\n//scene5: https://www.shadertoy.com/view/4tscR8\n//Optical-Circuit optical circuit scene 1 deconstruction b\n\n\n/*\n\niMouse.x changes the glowing (somewhat planar) lines\niMouse.y changes the density of the black fractal\n\nnot my code, just deconstructing it:\n\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\n\nThe [optical circuit demo] video source code once appeared on glslsandbox.com\n... with very nondesctiptic labels, \n... only using single letter names for functions and vars..\n\n\nIt is fractal code golf overkill in [0..6] scenes.\nThis is a deconstruction of scene 1. , not the whole demo.\nUn-used functions (only used in other scenes) are removed;\nscene-specific branches are set to 1, or removed \n... (multiplying by *0. or adding -0 iterations)\n... all changes are annotated.\n\nThis may run slightly faster due to removing all schene-specific branching\nMost of that modifies iteration count (between scenes, which are static per shader)\nThe [smart re-use of schene specific branches and modifiers] is what makes this a 4k demo.\n... at a cost of running slightly slower, by summing up scene-modifiers.\n*/\n\n//this loop with 20 iterations seems to have no change for scene1, but i may be wrong\n//my guess is camera pathing???\n//skips a lot of code, so it is disabled for performance.\n//#define doScene1Loop\n\n//move vehicles in traffic over time., is often barely noticable, may be skipped.\n#define MoveVehicles\n\n//number of itterations of the black fractal. \n//it is pretty space filling with some max(a,-b) for safe camera paths, \n//4 is a good compromise. +-2 look fine too.\n#define Oiter 4\n\n//number of iterations of the glowing lines fractal patterns\n//more iterations make the lines more planar-space-filling, brighter\n#define Giter 6\n\n//#define scene 1\n#define timeOffset 115.984024\n\n#define dd(a) dot(a,a)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\nfloat vsum(vec3 a){return dot(a,vec3(1));}//dot() is generally faster on a gpu than 2add()\n //return a.x+a.y+a.z;}\n\nconst float pi=acos(-1.);//3.14\nconst float t0=sqrt(.5);//0.707\n\n//non const floats are not good style, will create warnings on some parsers.\nfloat A,D,E;\nvec3 B,C;\n\n//return a, rotated by b, originally called F()\nvec3 rot(vec3 a,float b){float c=sin(b),d=cos(b);return mat3(d,-c,0,c,d,0,0,0, 1)*a;}\n\n//fractal glowing planes\nvec3 G(vec3 a, float b){a=fract(a*.2)*2.-1.;a.z=b;\n float m=iMouse.x/iResolution.x;\n //a-=iMouse.x/iResolution.x; //this fucks up the tesselation\n float c=50.;//brightness modifier\n for(int i=0;i<Giter;++i){//iteration cout is scene specific\n  float d=clamp(dd(a),.05,.65);\n  c*=d;\n  a=abs(a)/d-1.31+m;\n  a.xy=a.xy*mat2(1,1,-1,1)*t0-m;\n }return a*c;}\n\n/*\n#ifdef doScene1Loop\n//sub of X\nvec3 Z(float t){return vec3(0,-sin(t*.6),t*1.6+.5)+sin(t*.01*vec3(11, 23, 19))*vec3(.135,.25,.25);}\n//sub of Y a and t are always thr same, this looks like i can optimize it, a lot\nfloat X(vec3 a, float t, float b){float c=fract(t+b),e=t-c;\n vec3 f=Z(e)*vec3(0,1,1)+sin(vec3(0,23,37)*e),\n g=normalize(sin(vec3(0,17,23)*e))*8.,\n h=f+g+vec3(sin(e*53.)*.15,0,0),\n j=f-g+vec3(sin(e*73.)*.15,0,0),\n k=mix(h,j,c-.15),\n l=mix(h,j,c+.15);//i smell a lot of symmetry potential for optimization\n t=dot(a-k,l-k)/dd(l-k);//i smell distance to line segment\n return length((t<0.?k:t>1.?l:k+t*(l-k))-a);}//i smell a lot of BIsymmetry potential for optimization\n//sub of Y, internally modifies a, while Y keeps usig an unmodified a.\nvec3 I(vec3 a){a.z=a.z-A*1.5;float b=A*.5+floor(a.z);\n return rot(vec3(a.x,a.y+sin(b),fract(a.z)-.5),pi-cos(b));}\n//only used once in mainImage, within a loop that seems to have no visual effect for scene 1\n\nvec4 Y(vec3 a,float b,float t) {\n vec3 c=I(a)*20.,\n d=vec3(length(c+vec3(-.35,.57,2)),length(c+vec3(-.35,-.57, 2)),length(c+vec3(.7,0,2))),\n e=V(.2,d,b),\n f=vec3(X(a,t,0.),X(a,t,.3),X(a,t,.6)),g=V(.001,f,b);\n return vec4(\n  vsum(e)*vec3(30,75,150)*(E+1.)+vsum(g)*vec3(1.,.1,.2)*5000.\n  ,min(miv(d)*.05, miv(f)));}\n#endif\n*/\n\n//L M N O define thedark fractal shape, O is a fractal, L M N are a \"strange hash\"\n//L is sub of M and N\nfloat L(vec3 a){vec3 b=abs(fract(a + vec3(0,.5,0))-.5),c=abs(fract(a+.5)-.5);\n return .033-min(max(b.x-.46, b.y),.08-max(c.x, c.y));}\n//M is sub of N\nfloat M(vec3 a) {vec3 b=abs(fract(a*4.+.5)-.5)*.25;\n return max(max(max(b.x,b.y),b.z)-.08,max(L(a)-.01,.012-length(fract(a*25.)-.5)*.04));}\n//M is sub of O\nfloat N(vec3 a){\n return min(min(min(M(a),M(a.zyx)),M(a.zxy)),min(min(L(a),L(a.zyx)),L(a.zxy)));}\n//iterations of the black fractal\n//o is used once by T()\nfloat O(vec3 a){vec4 b=vec4((fract(a*.2+.5)-.5)*4.,1.);\n for(int i=0;i<Oiter;++i){\n  b.xyz = clamp(b.xyz,-1.,1.)*2.-b.xyz;\n  b*=clamp(max(.21/dd(b.xyz),.21),.0,1.)*-15.7;\n }a=b.xyz/b.w*5.;return max(length(a)-1.,N(a))*.25;}\n//used 5* in mainImage T is a very schene specific function; \n//return distance of [a] to a fractal.\nfloat T(vec3 a){\n float m=iMouse.y/iResolution.y;\n vec3 b=a*(20.);//for scene 1, b modifies placement of \"lines of vehicles\"\n #ifdef MoveVehicles\n  b.y+=A*5.*(fract(dot(floor(b),vec3(1,0,1))*pi)-.5);//animate lines of vehicles\n #endif\n vec3 c=rot((fract(b.zxy)-.5)*.05,A*8.*(fract(dot(floor(b),vec3(pi)))-.5)),//defines vehicles\n e=abs(fract(a+vec3(.5,.5,0))-.5);//defines vehicles\n a=rot(a,A*.025*(fract((a.z * 2.-fract(a.z*2.))*.437)-.5));//defines black fractal\n float d=mav(abs(fract(a*2.)-.5)*.5);//for scene1, K is 100% absorbed into T, here\n return min(//this line is the only line that includes \"O()\"\n  max(min(max(d+(m*.35-.12)-.201,O(a)),.299-d),length(a)-20.),\n  max(max(e.x,e.z)-.05,min(max(length(c)-.006,L(c*10.)*.1-.0002),.04)));}\n\n//V and W modify color accumulator of the last loop (mostly increasing brightness)\n//sub of W and I\nvec3 V(float a,vec3 b,float c){a*=c;return 1./((1.+2.*b/a+b*b/(a*a))*c+.0001);}\n//only used twice in mainImage, a and b and c are the same both times.\nvec3 W(vec3 a,float b,float c,float d){\n vec3 e=(V(.01,abs(a),d)*2.+V(.05,vec3(length(a.yz),length(a.zx),length(a.xy)),d)*5.)\n  *(sin(A*vec3(2.1,1.3,1.7)+b*10.)+1.);\n return(e*7.+e.yzx*1.5+e.zxy*1.5)*max(1.-c*200./d,0.)/d*float(100-30);}//is scene specific\n\n#define tswap h=j;j=k;k=l\n#define resolution iResolution\nvoid mainImage(out vec4 O, in vec2 Uuu){\n {//this  seems to have been an Initiation procedure, as it sets global vars.\n  A=iTime+timeOffset;\n  vec2 glVertex=Uuu.xy/iResolution.xy*2.-1.;\n  //a,b,d are very scene specific (and c depends on b)\n  vec3 a=normalize(sin(A*.001*vec3(21,11,17)))*20.1,\n  b=normalize(sin(A*.001*vec3(26,106,62))-a*.05),\n  c=normalize(cross(b,sin(A*.001*vec3(31,17,29))));\n  float d=A*float(1);\n  /*\n  #ifdef doScene1Loop\n  for(int i=0;i<20;++i){//i notice no changes when skipping this on scene1\n   float t=A-float(i)*.1;\n   vec4 y=Y(Z(t),25.,t);\n   //here an d+=... modifier is scene specific, is +=0. for scene1\n  }\n  #endif\n  */\n  //set globals:\n  vec3 e=normalize(vec3(sin(vec2(.53,.47)*d)*4.+sin(vec2(.91, 1.1) * d)*2.+sin(vec2(2.3,1.7)* d),200)),\n  f=normalize(cross(e,vec3(sin(d),50,0)));\n  B=a;\n  C=mat3(c,cross(c,b),b)*(f*glVertex.x*1.78+cross(f,e)*glVertex.y+e*1.4);\n  D=fract(sin(vsum(C)*99.317*pi)*85.081*pi);\n  E=fract(sin(A      *99.317*pi)*85.081*pi);\n }\n vec3 a=normalize(C),c=vec3(1),e=B,f= a,g=e,b=g*.0,s=vec3(1,-1,-1)*.0005;\n vec4 l=vec4(B,1),k=l*.0,j=k,h=j;\n int m=1;\n float t=0.,o=1.,p=1.,q=D*.01+.99,n;\n //raymarching loop:\n for(int i=0;i<64;++i){//iteration steps depend on z, but scene 1 has no summands here.\n  g=e+f*t;\n  float d=T(g);\n  if(d<(t*5.+1.)*.0001){\n   vec3 u=normalize(T(g+s)*s+T(g+s.yyx)*s.yyx+T(g+s.yxy)*s.yxy+T(g+s.xxx)*s.xxx);//normal\n   float r=pow(abs(1.-abs(dot(u,f))),5.)*.9+.1;\n   o+=t*p;\n   p=p*5./r;\n   e=g+u*.0001;\n   f=reflect(f, u);\n   t=.0;\n   float v=dd(u);\n   if(v<.9||1.1<v||v!=v)u=vec3(0);\n   if(m<4){tswap;l=vec4(g,max(floor(o),1.)+clamp(r,.001,.999));++m;\n  }}\n  else t=min(t+d*q,100.);\n }\n if(m<4){tswap;l=vec4(g,o+t*p);++m;}{\n  int a=m;for(int i=0;i<4;++i)if(a<4){tswap;++a;}}//simple sorting?\n e=h.xyz;\n f=normalize(j.xyz-h.xyz);\n n=length(j.xyz-h.xyz);\n t=.0;\n q=D*.1+.9;//q is scene specific\n o=1.;\n p=.0;\n //this loop pushes fog away by adding more \"glow\"\n //looks like a reflection and illumination loop. \n //fun part is that light sources scattered dots in lines in planar areas.\n for(int i=0;i<64;++i){//iteration steps are cene specific, scene 1 has no summands here.\n  if(t>n){\n   if(m<3)break;\n   tswap;--m;\n   e=h.xyz;\n   f=normalize(j.xyz-h.xyz);\n   n=length(j.xyz-h.xyz);\n   t=0.;\n   if(n<.0001)break;\n   float r=fract(h.w);\n   o=h.w-r;\n   p=(floor(j.w)-o)/n;\n   c*=mix(vec3(.17,.15,.12),vec3(1),r);\n  }\n  g=e+f*t;\n  //next 5 lines are scene specific\n  float u=abs(fract(g.z)-.5);//this line 100% absorbs U(), for scene1\n  g-=vec3(0,0,vec2(sign(fract(g.z)-.5)))*u;\n  float v=sin(A*.05+g.z)*.5,w=u*q+.001;\n  vec3 x=G(g,v);\n  c*=pow(.7,w);\n  t+=w;\n  b+=(W(x,v,u,o+p*t    )    +W(x,v,u,o+p*t+50.))*c*w;\n }\n //this line is also scene specific\n O=vec4(pow(b,vec3(.45)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfczH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1820, 2017, 2030, 2030, 2051], [2052, 2052, 2065, 2065, 2092], [2093, 2093, 2106, 2106, 2139], [2164, 2164, 2183, 2183, 2206], [2446, 2494, 2519, 2519, 2579], [2581, 2606, 2630, 2630, 2956], [4242, 4347, 4363, 4363, 4480], [4481, 4497, 4514, 4514, 4636], [4637, 4653, 4669, 4669, 4750], [4751, 4809, 4825, 4825, 5032], [5033, 5134, 5150, 5150, 5879], [5881, 5981, 6012, 6012, 6060], [6061, 6132, 6171, 6171, 6369], [6369, 6447, 6487, 6487, 9214]]}
{"id": "MlfyRM", "name": "AA barycentric triangle 2", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/lslXDf\n\nAnother way of drawing an antialiased barycentric triangle", "tags": ["2d", "simple", "math", "tutorial", "triangle", "mobius", "antialias", "barycentric", "cramer"], "likes": 0, "viewed": 125, "date": "1503999517", "time_retrieved": "2024-06-20T18:59:55.169663", "image_code": "// Fork of https://www.shadertoy.com/view/lslXDf\n\n// An antialiased barycentric triangle!\n\n#define ANTIALIAS 4.\n\n// Does this use Cramer's rule?\nfloat sdf_triangle(vec2 vec_p, vec2 vec_a, vec2 vec_b, vec2 vec_c){\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement-vector\n    vec2 dvec_ac = vec_c - vec_a;  // Displacement-vector\n    vec2 dvec_ap = vec_p - vec_a;  // Displacement-vector\n\n    float det_dvec_ab_dvec_ac = dvec_ab.x * dvec_ac.y - dvec_ac.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ac\n\tfloat det_dvec_ap_dvec_ac = dvec_ap.x * dvec_ac.y - dvec_ac.x * dvec_ap.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ap and dvec_ac\n    float det_dvec_ab_dvec_ap = dvec_ab.x * dvec_ap.y - dvec_ap.x * dvec_ab.y;  // Determinant of the 2 x 2 matrix made of row vectors dvec_ab and dvec_ap\n    float inv_det_dvec_ab_dvec_ac = 1. / det_dvec_ab_dvec_ac;  // Multiplicative-inverse of a determinant\n\n    float bary_x = det_dvec_ap_dvec_ac * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_y = det_dvec_ab_dvec_ap * inv_det_dvec_ab_dvec_ac;  // Why does this work?\n    float bary_z = 1. - bary_x - bary_y;  // The last barycentric coordinate is easy!\n\n    return min(min(bary_x, bary_y), bary_z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n    uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;\n\n    //vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    //mouse_uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * mouse_uv;\n\n    vec2 triangle_a = vec2(.0, -.8);\n    vec2 triangle_b = vec2(.8,  .0);\n    vec2 triangle_c = vec2(.0,  .8);//mouse_uv;\n    float triangle = sdf_triangle(uv, triangle_a, triangle_b, triangle_c);\n    triangle = smoothstep(0., ANTIALIAS / iResolution.y, triangle);\n\n\tfragColor.rgb = vec3(triangle);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfyRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[113, 145, 212, 212, 1270], [1272, 1272, 1329, 1329, 1943]]}
{"id": "Mlfyz4", "name": "Lost_Astronaut", "author": "duvengar", "description": "Derived and inspired by iq's modelling techniques and Shane's transparency works.\nhttps://www.shadertoy.com/view/Xds3zN\nhttps://www.shadertoy.com/view/lstGRB\n", "tags": ["3d", "raymarching", "transparency", "modelling", "skull"], "likes": 53, "viewed": 783, "date": "1503671141", "time_retrieved": "2024-06-20T18:59:57.406304", "image_code": "// \"Lost_Astronaut\"\n// by Julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n// this shader is inspired by iq's \"Raymarching - Primitives's\",\n// https://www.shadertoy.com/view/Xds3zN\n// and article,\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// and Shane's \"Transparent 3D Noise\" ,\n// https://www.shadertoy.com/view/lstGRB\n// ====================================================================\n\n\n\n#define T iTime\n#define ORANGE vec3(1.0, 0.5, 0.3)\n#define GREEN  vec3(0.0, 1., 0.5)\n#define PINK   vec3(.9, 0.3, 0.4)\n\n\n//==========================================================//\n//                 NOISE 3D\n//\n// 3D noise and fbm function by Inigo Quilez\n//==========================================================//\n\nmat3 m = mat3( .00,  .80,  .60,\n              -.80,  .36, -.48,\n              -.60, -.48,  .64 );\n\nfloat hash( float n )\n{\n    float h =  fract(sin(n) * 4121.15393);\n\n    return  h + .444;   \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f );\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix( hash(n + 00.00), hash(n + 1.000), f.x),\n                   mix( hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix( hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix( hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm( vec3 p )\n{\n   float f = 0.0;\n\n   f += 0.5000 * noise( p ); p = m * p * 2.1;\n   f += 0.2500 * noise( p ); p = m * p * 2.2;\n   f += 0.1250 * noise( p ); p = m * p * 2.3;\n   f += 0.0625 * noise( p );\n    \n   return f / 0.9375;\n}\n\n\n//==========================================================\n//            signed DISTANCE FIELD PRIMITIVES \n//==========================================================\n//\n// distance field primitives by Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\n//\n//-----------------------------------------------------------\n//                       SPHERE            \n//-----------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n//-----------------------------------------------------------\n//                        BOX\n//-----------------------------------------------------------\nfloat sdBox( vec3 p, vec3 b )\n{   \n  vec3 d = abs(p) - b ;   \n  return max(min(d.x, min(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n\n\n// polynomial smooth min and max ref iq's article\n// http://www.iquilezles.org/www/articles/smin/smin.htm\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\n\nvec3 opRot( vec3 p, float a )\n{\n    float  c = cos(a);\n    float  s = sin(a);\n    mat2   m = mat2(c,-s,s,c);   \n    return vec3(m*p.xy,p.z);\n}\n\n//==========================================================\n//          SKULL SIGNED DISTANCE FIELD \n//==========================================================\n\n\nfloat sdSkull( vec3 p, float s )\n{\n    \n    \n  // --------------------------------------------------------\n  // domain deformation on radius (s) brings some interesting\n  // results this deformation sould be applied to big shapes \n  // in order to preserve details. \n    \n  float ss = noise(p * 9.);\n  ss = mix(s,ss *.5,.1);\n  \n  \n  // sp is using symetry on z axis\n  vec3 sp = vec3(p.x, p.y, abs(p.z));\n    \n      \n  // kind of morphing effect \n // s = clamp(cos(iTime*.5), .20,.35);\n\n  float shape = sdSphere(p - vec3(.0,.05,.0), s * .95 * cos(cos(p.y*11.)* p.z * 2.3) );\n  //---------------------------------------------------------  \n  // first part external skull top\n  // --------------------------------------------------------\n    \n  // globe front \n  shape = smin(shape,  sdSphere (p - vec3(.10, 0.23, 0.00), s * .82), .09);\n    \n  // globe back \n  shape = smin(shape,  sdSphere (p - vec3(-.1, 0.24, 0.00), s * .82), .09);\n    \n  // eye brow\n  shape = smin(shape,  sdSphere (sp - vec3(.25, 0.07, 0.10), s * .36 * cos(p.y * 7.0)), .02);\n    \n  // lateral holes - symmetry\n  shape = smax(shape, -sdSphere (sp - vec3(.15, -.01, 0.31), s * .28 * cos(p.x * .59)), .02);  \n    \n  //checkbones - symmetry\n  shape = smin(shape, sdSphere(sp-vec3(.22,-.13,.18), s*.11),.09);\n  \n  // empty the skull\n  shape = max(shape, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smax(shape,  -sdSphere (p - vec3(.10, 0.23, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(-.1, 0.24, 0.00), s * .74),.02);\n  shape = smax(shape,  -sdSphere (p - vec3(.0, 0.24, 0.00), s * .74),.02);\n  \n  // eye balls - symmetry\n  shape = smax(shape, -sdSphere(sp-vec3(.32,-.04,.140), s  * .28 * cos(p.y*10.)),.03);\n  \n  // nose\n  //-----------------------------------------------------------\n    \n  // base nose shape\n  float temp = sdSphere(p- vec3(cos(.0)*.220,-.05, sin(.0)*.3), s * .35 * cos(sin(p.y*22.)*p.z*24.));\n    \n  // substract the eyes balls ( symetrix) & skukl globe\n  temp = smax(temp, -sdSphere(sp-vec3(.32,-.04,.140), s * .35 * cos(p.y*10.)), .02); \n  temp = smax(temp, -sdSphere(p - vec3(.0,.05,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ),.02);\n  \n  // add nose shape to skull \n  shape = smin(shape,temp,.015);  \n  \n  // empty the nose\n  shape = smax(shape, - sdSphere(p- vec3(cos(.0)*.238,-.09, sin(.0)*.3), s * .3 * cos(sin(p.y*18.)*p.z*29.)),.002);\n  \n  // substract bottom\n  shape = smax(shape, -sdSphere(p- vec3(-.15,-0.97, .0), s * 2.5 ),.01);\n    \n  // I like the noise deformation on this edge with ss for the sphere radius.\n  // It give a more natural look to the skull.\n  shape = smax(shape, -sdSphere(p- vec3(-.23,-0.57, .0), abs(ss) * 1.6 ),.01);\n    \n  //--------------------------------------------------------- \n  // skull part2: UP jaws\n  // --------------------------------------------------------\n    \n  temp = smax(sdSphere(p - vec3(.13,-.26,.0), .45 * s), -sdSphere(p - vec3(.125,-.3,.0), .40 * s), .01);\n  \n  // substract back\n  temp = smax(temp,-sdSphere(p - vec3(-.2,-.1,.0), .9 * s), .03);\n  \n  // substract bottom  \n  temp = smax(temp,-sdSphere(p - vec3(.13,-.543,.0), .9 * s), .03);\n  \n  // substract up  \n  temp = max(temp, -sdSphere(p - vec3(.0,.02,.0), s * .90 * cos(cos(p.y*11.)* p.z * 2.3) ));  \n  shape = smin(shape, temp, .07);\n    \n   \n  // Teeths - symmetry\n  //-----------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.26, -.29, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.26, -.29, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.25, -.29, .05), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.235, -.29, .08), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.215, -.28, .1), .05 * s ));\n  temp = max(temp, -sdSphere(p - vec3(.16, -.35, .0), .33 * s ));   \n  temp = min(temp, sdSphere(sp - vec3(.18, -.28, .115), .05 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.28, .115), .06 * s ));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.28, .115), .06 * s ));\n\n   \n  shape = smin(shape, temp, .03); \n   \n  // DOWN Jaws\n  //-----------------------------------------------------------\n  \n  temp = sdSphere(p - vec3(.1,-.32,.0), .43 * s);  \n  temp = smax (temp, - sdSphere(p - vec3(.1,-.32,.0), .37 * s ),.02);  \n  temp = smax(temp, - sdSphere(p - vec3(.1,-.034,.0), 1.03 * s),.02) ;  \n  temp = smax(temp, - sdSphere(p - vec3(.0,-.4,.0), .35 * s),.02);   \n  // symmetry\n  temp = smin(temp, sdBox(sp - vec3(.04 -.03 * cos(p.y * 20.2),-.23, .27 + sin(p.y)*.27), vec3(cos(p.y*4.)*.03,.12,.014)), .13);\n  temp = max(temp, - sdSphere(sp - vec3(.0,.153,.2), .85 * s)); \n  temp = smin (temp, sdSphere(sp - vec3(.2, -.45, 0.05), .05 * s ),.07);  \n \n  shape = smin(shape, temp, .02);  \n    \n    \n  // Teeths -  symmetry\n  //--------------------------------------------------------\n \n  temp = sdSphere(p - vec3(.23, -.34, .018), .053 * s );\n  temp = min(temp, sdSphere(p - vec3(.23, -.34, -.018), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.22, -.34, .048), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.20, -.34, .078), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.17, -.35, .098), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.14, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.11, -.35, .11), .053 * s));\n  temp = min(temp, sdSphere(sp - vec3(.08, -.35, .11), .053 * s));\n      \n \n  shape = 1.5 * smin(shape, temp, .025);  \n    \n  \n    \n return shape ;  \n    \n // return mix(shape, sdSphere(p - vec3(.0, .0, .0), .5), cos(iTime*.1)*.5+.5);\n  //return mix(shape, sdBox(p-vec3(.0),vec3(.45)),abs(cos(iTime)));\n    \n  \n}\t\n\n//==========================================================\n//                      POSITION\n//==========================================================\n\nvec3 skullP ()\n{     \n   return vec3(.0,.0,.0);\n}\n\n//==========================================================\n//                     OBJECTS UNION\n//==========================================================\n\n/*vec2 add(vec2 d1, vec2 d2)\n{\n  \n\treturn (d1.x < d2.x) ? d1: d2 ;   \n}*/\n\n//==========================================================\n//                     SCENE MANAGER  \n//==========================================================\n\nvec2 map(vec3 pos)\n{\n    \n    vec2 scene = vec2(.5 * sdSkull(opRot(pos,T*.1) -  skullP(), .35), 39.);\n    return scene;     \n}\n\n//==========================================================\n//                     RAY CASTER  with transparency\n//\n// derived from iq's original raycaster\n// https://www.shadertoy.com/view/Xds3zN\n// and mixed with shane's transparency layers,\n// https://www.shadertoy.com/view/lstGRB\n//==========================================================\n\nfloat castRayTrans( vec3 ro, vec3 rd )    \n{\n    //int   i  = 0;                                   \n    float layers = 0.;\n    float thD = .0023; \n    float aD = 0.;\n    float col = .0;\n    float t = 1.0;\n       \n    for ( int i = 0; i <= 64; i++)\n    {    \n\t  vec2 res = map(ro + rd * t);                  // map() > response vec2(depth, id)\n      float d = res.x;\n        \n      if(layers > 20. || col > 1. || t > 3.) break; // break when object something is encountred or when outside of bounds\n\n         aD = (thD-abs(d)*13./14.)/thD;\n\n        if(aD > 0.) { \n            \n\t\t    col += aD/(1. + t*t*0.1)*0.1;\n            layers++; \n        }\n       t += max(abs(d)*.8, thD*1.6);\t\t       \n    }\n    return col;\t\t\t\t                        // return color value\n}\n\n\n//==========================================================\n//                       NORMALS \n//==========================================================\n\n\nvec3 calcNormal( vec3 pos )\n{\n    vec2 e = vec2(1., -1.) * .0005;\n    return normalize(e.xyy * map(pos + e.xyy).x + \n\t\t\t\t\t  e.yyx * map(pos + e.yyx).x + \n\t\t\t\t\t  e.yxy * map(pos + e.yxy).x + \n\t\t\t\t\t  e.xxx * map(pos + e.xxx).x );\n}\n\n//==========================================================\n//                       CAMERA \n//==========================================================\n\nmat3 setCamera(vec3 ro)\n{\n  vec3 cw = normalize(- ro);\n  vec3 cp = vec3(sin(.0), cos(.0), .0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  \n  return mat3(cu, cv, cw);\n}\n\n//==========================================================\n//                       MAIN \n//==========================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  // Pixel ratio\n  //-----------------------------------------------------------\n  // for background\n    \n  vec2 uv =(-1. + 2. * fragCoord.xy / iResolution.y)*4.;\n\n  // Pixel ratio for skull\n    \n  vec2 p = (-iResolution.xy + 2.0 * fragCoord)/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy;\n\n  // camera\t\n  //-----------------------------------------------------------\n  // noisy version of skull with distortion applied to camera.\n  // vec3 ro = vec3( 2. * cos(T)+ .2*cos(noise(vec3(p*15.,T))), 1., 2. * sin(T) );\n  // rotation of camera on Y axis.\n    \n  vec3 ro = vec3( 2. * cos(T), 1., 2. * sin(T) );\n  \n  // camera-to-world transformation\n    \n  mat3 ca = setCamera(ro);    \n  \n    \n  // ray direction\n  //-----------------------------------------------------------\n    \n  vec3 rd = ca * normalize(vec3(p.xy, 2.));\n\n  // render\t\n  //-----------------------------------------------------------\n    \n  vec3 tot = vec3(0.3,.30,.7)+ vec3(pow(fbm(vec3( fragCoord*.005,T*.1)),6.))*.2;  \n    \n  // cosmos\n  //-----------------------------------------------------------\n    \n  float ff = smoothstep(.7, 1.1,fbm(.1 * vec3(uv,T ) )); \n  tot *= mix(tot*.6, ORANGE, ff*.9  );\n  ff = smoothstep(.0, 0.9,fbm(.1 * vec3(uv,T ) )); \n  tot *= mix(tot*.4, PINK, ff*2.3  );\n  ff = smoothstep(.5, 0.7,fbm(.1 * vec3(uv,T ) )); \n  tot *= mix(tot*.6, GREEN, ff*.8  );\n  tot += smoothstep(.0,iResolution.y * 3.,iResolution.y-length(fragCoord));\n    \n  // skull\n  //-----------------------------------------------------------\n    \n  vec3 col = vec3(castRayTrans(ro,rd));  ;\n  tot += .9*col-.07;\n\n  // lights & starfield\n  //-----------------------------------------------------------\n    \n  vec2 n = vec2(T*.2,T*.5);\n  tot /= smoothstep(.45,1.1,fbm(vec3(n+fragCoord *.01,.1*T )));\n  tot /= smoothstep(.0,1.,fbm(vec3(  n+fragCoord *.01,.1*T )));\n  tot /= smoothstep(.55,.7,fbm(vec3(6.*uv+n*9. ,.1)));\n  \n\n  fragColor = vec4( tot, 1.0 );\n\n}", "image_inputs": [{"id": "lssSW2", "previewfilepath": "https://soundcloud.com/establishmentlabel/teaser-francesco-novara-astron-ep", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/establishmentlabel/teaser-francesco-novara-astron-ep", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlfyz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[685, 987, 1010, 1010, 1081], [1083, 1083, 1109, 1109, 1515], [1517, 1517, 1538, 1538, 1753], [1756, 2186, 2221, 2221, 2247], [2249, 2403, 2434, 2434, 2530], [2534, 2642, 2683, 2683, 2790], [2793, 2793, 2834, 2834, 2941], [2944, 2944, 2975, 2975, 3086], [3088, 3253, 3287, 3519, 8909], [8912, 9068, 9084, 9084, 9117], [9354, 9516, 9536, 9536, 9642], [9644, 9992, 10036, 10091, 10755], [10758, 10916, 10945, 10945, 11145], [11147, 11303, 11328, 11328, 11503], [11505, 11659, 11716, 11822, 13644]]}
{"id": "MllcR4", "name": "2D Blend Shape Normals", "author": "iq", "description": "In 3D normals cannot be blended from different blend shapes. Same in 2D, in principle... In fact it is possible to kind-of do so in 2D, at equal storage space, if the right strategies for storing normals is employed.", "tags": ["2d", "interpolation"], "likes": 13, "viewed": 1027, "date": "1503951268", "time_retrieved": "2024-06-20T18:59:58.636695", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// In 3D, normals cannot be blended from different blend shapes. Same in 2D, in\n// principle... However, it is in fact possible to kind-of do it in 2D, at equal\n// storage space, if the right strategies for computing normals is employed.\n\n// This shader generates a deforming shape by interpolating linearly between \n// three different static shapes. This is how \"blend shapes\" are usually employed\n// for facial animation in games. The position of each vertex in the final\n// deformed mesh is simply the weighted sum of the blend shapes:\n// \n// P[i] = a*Pa[i] + b*Pb[i] + c*Pc[i]  with a+b+c=1\n//\n// Often vertex normals are interpolated as well in this way, despite it is\n// mathematically incorrect to do so. This shaders displays the error introduced\n// by doing so. Yellow/orange normals are the interpolated normals while blue\n// normals are the true normals of the interpolated shape. As you can see, they\n// often don't match. This is due to the fact that normalization is not a linear\n// operator.\n// \n// However, I found a way to fix this in 2D. \"Method 0\" implements it, and\n// produces normals that match perfectly the true normals (yellow ones get\n// rendered bellow the blue ones).\n//\n// The trick is to not normalize the normals (or tangents), and instead\n// interpolating them un-normalized, deferring the normalization to\n// after-interpolation.\n//\n// So, Method 0 is the correct interpolation of normals proposed in this shader.\n// Method 1 and method 2 show the problem that arises in games, under two\n// different ways to compute vertex normals (area/length dependant and indepedent):\n//\n// method 2:  T[i] = norm( norm(P[i+1]-P[i]) + norm(P[i]-P[i-1]) );  \n// method 1:  T[i] = norm( norm(P[i+1]-P[i-1]) \n// method 0:  T[i] = P[i+1]-P[i-1]\n\n\n\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n; // integer hash copied from Hugo Elias\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffffU);\n}\n\nfloat sdot( vec2 v ) { return dot(v,v); }\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tp -= a; b-= a;\n    return sdot( p - b*clamp( dot(p,b)/sdot(b), 0.0, 1.0 ) );\n}\n\nfloat sdPointSq( in vec2 p, in vec2 a )\n{\n    return sdot( p - a );\n}\n\n//=================================================================================================\n\n\nconst int kNumPoints = 16;\nint gMethod;\n\nvoid generatePath( out vec2 path[kNumPoints], uint seed )\n{\n    const vec2 off = vec2(0.0,0.0);\n    const vec2 sca = vec2(2.0,1.5);\n    \n    vec2 d = vec2(1000.0);\n    vec2 q = vec2(0.0);           \n    path[0] = sca*q + off;\n    \n    float dir = 0.0;\n    for( int i=1; i<kNumPoints; i++ )\n    {\n        float h = float(i)/float(kNumPoints);\n        dir += 1.7*(-1.0+2.0*hash( uint(i*7)+seed) );\n        q += 0.16*vec2( cos(dir), sin(dir) );\n        q = mix( q, path[0], pow(h,16.0) );\n        path[i] = sca*q + off;\n    }\n}\n\nvec2 computeTangent( in vec2 a, in vec2 b, in vec2 c )\n{\n    return (gMethod==0) ? c - a :\n           (gMethod==1) ? normalize( c-a ) :\n                          normalize( normalize(c-b) + normalize(b-a) );\n}\n\nvoid computeNormals( out vec2 norm[kNumPoints], in vec2 path[kNumPoints] )\n{\n    for( int i=0; i<kNumPoints; i++ )\n    {\n        vec2 n = computeTangent( path[(i-1+kNumPoints)%kNumPoints],\n                                 path[(i+0+kNumPoints)%kNumPoints],\n                                 path[(i+1+kNumPoints)%kNumPoints] );\n        norm[i] = vec2(n.y, -n.x );\n    }\n}\n\nvec3 drawPathAndNormals( in vec3 col, in vec2 p, in float e, in vec2 path[kNumPoints], in vec3 pathColor, in float normLength )\n{\n    vec3 d = vec3(1000.0);\n    for( int i=0; i<kNumPoints; i++ )\n    {\n        vec2 a = path[(i-1+kNumPoints)%kNumPoints];\n        vec2 b = path[(i+0+kNumPoints)%kNumPoints];\n        vec2 c = path[(i+1+kNumPoints)%kNumPoints];\n\n        vec2 n = computeTangent( a, b, c );\n        \n        n = normLength*normalize(vec2(n.y, -n.x ));\n\n        d = min( d, vec3(sdSegmentSq(p,b,c), \n                         sdPointSq(p,b),\n                         sdSegmentSq(p,b,b+n)) );\n    }\n    d = sqrt(d);\n\n    col = mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d.x) );\n    col = mix( col, pathColor, 1.0-smoothstep(5.0*e,6.0*e,d.y) );\n    col = mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d.z) );\n    \n    return col;\n}\n\nvec3 drawNormals( in vec3 col, in vec2 p, in float e, in vec2 path[kNumPoints], in vec2 norm[kNumPoints], in vec3 pathColor, in float normLength )\n{\n    float d = 1000.0;\n    for( int i=0; i<kNumPoints; i++ )\n    {\n        vec2 b = path[i];\n        vec2 n = normLength*normalize(norm[i]);\n\n        d = min( d, sdSegmentSq(p,b,b+n) );\n    }\n    d = sqrt(d);\n\n    return mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d) );\n}\n\nivec2 letterOffsets[] = ivec2[]( \n    ivec2(13,11), ivec2(5,9), ivec2(4,8), ivec2(8,9),\n    ivec2(15,9), ivec2(4,9), ivec2(0,5), ivec2(0,12) );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // cycle through the three method to compute and stoer normals\n    float h = mod( iTime, 12.0 );\n         if( h>8.0 ) gMethod = 2;\n    else if( h>4.0 ) gMethod = 1;\n    else             gMethod = 0;\n        \n    letterOffsets[7].x = gMethod;\n        \n    // visualization        \n    float e = 2.0/iResolution.y;\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\n\n    // generate 3 shapes\n    vec2 pathA[kNumPoints];\n    vec2 pathB[kNumPoints];\n    vec2 pathC[kNumPoints];\n\tgeneratePath(pathA, 1U);\n\tgeneratePath(pathB, 8U);\n    generatePath(pathC,15U);\n\n    // compute their normals\n    vec2 normA[kNumPoints];\n    vec2 normB[kNumPoints];\n    vec2 normC[kNumPoints];\n    computeNormals( normA, pathA );\n    computeNormals( normB, pathB );\n    computeNormals( normC, pathC );\n        \n    // interpolate shapes and normals\n    float t = iTime*0.05;\n    vec3  w = 0.5 + 0.3*sin(vec3(10.0,11.0,12.0)*t + vec3(0.0,3.0,2.0)) + 0.2*sin(vec3(21.0,19.0,20.0)*t + vec3(1.0,4.0,3.0));\n    w /= (w.x+w.y+w.z);\n    \n    vec2 pathR[kNumPoints];\n    vec2 normR[kNumPoints];\n    for( int i=0; i<kNumPoints; i++ )\n    {\n        pathR[i] = w.x*pathA[i] + w.y*pathB[i] + w.z*pathC[i];\n        normR[i] = w.x*normA[i] + w.y*normB[i] + w.z*normC[i];\n    }\n\n    // draw interpolated path, its real normals (in blue), and the interpolated normals (in red)\n    vec3 col = vec3(1.0);\n\n    col = drawNormals(         col, p, e, pathR, normR, vec3(1.0,0.5,0.0), 0.3 );\n\tcol = drawPathAndNormals(  col, p, e, pathR,        vec3(0.0,0.3,0.8), 0.3 );\n\n    // text\n    {\n        vec2 uv = (p-vec2(-0.5,0.8))*8.0;\n\n        ivec2 iuv = ivec2(floor(uv));\n        vec2 fuv = fract(uv);\n\n        if( iuv.x>=0 && iuv.x<=7 && iuv.y==0 )\n        {\n            fuv = 0.5 + vec2(0.5,1.0)*(fuv-0.5);\n            float te = textureLod( iChannel0, ( vec2(letterOffsets[iuv.x]*64) + fuv*64.0 )/1024.0, 0.0 ).w;\n            te = smoothstep( 0.48, 0.51, te );\n            col *= te;\n        }\n    }\n \n    // vignette\n    col *= 1.0 - 0.15*length(p);\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/MllcR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1318, 2844, 2867, 2867, 3045], [3047, 3047, 3069, 3069, 3088], [3090, 3090, 3144, 3144, 3224], [3226, 3226, 3267, 3267, 3295], [3297, 3440, 3499, 3499, 3964], [3966, 3966, 4022, 4022, 4175], [4177, 4177, 4253, 4253, 4547], [4549, 4549, 4678, 4678, 5390], [5392, 5392, 5540, 5540, 5814], [5962, 5962, 6019, 6086, 8068]]}
{"id": "Mllyz4", "name": "Curve Revolute 2", "author": "aiekick", "description": "click on screen to control with :\n- axix x, the branch count\n- axis y, teh z shape section", "tags": ["curve", "2", "revolute"], "likes": 7, "viewed": 479, "date": "1503824601", "time_retrieved": "2024-06-20T18:59:59.527622", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nvec2 m;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.14159 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat shape(vec2 p)\n{\n    vec2 q = p;\n    \n    vec2 s = vec2(.1); // 2d box size\n    \n    // perturbation gice pretty result :)\n    //q.x += sin(q.y*5.)*.2 + sin(q.y*20.)*.1; // preturb box thickness along height\n    \n    float t = sin(iTime)*.5+0.8;\n    if (abs(q.y) < 2.*t)\n    \tq.y = mod(q.y, 1.*t) - 0.5*t;\n    \n    return length(max(abs(q) - s, 0.)); // 2d iq box shape\n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*floor(m.x*10.) + iTime;\n    \n    vec2 rev = vec2(length(p.xz), p.y) - 2.5;\n    \n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\n\tvec2 res = vec2(abs(shape(rev))-0.032, 0);\n    //if (iMouse.z > 0.)\n\t\tif (p.z+m.y*10.-5. > res.x) \n            res = vec2(p.z+m.y*10.-5., 1);\n\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,2);\n\t\t\n\treturn res; \n\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = iMouse.xy/iResolution.xy;\n    if (m.x == 0.) m.x = .1;\n    \n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tvec2 camp = vec2(.73,.37) * 5.;\n\tvec3 rayOrg = vec3(cos(1.57),sin(camp.y),sin(1.57)) * camp.x * 2.;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.2,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 0.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (log(d*d/s/1e6)>0. || d>dMax) break;\n\t\ts = df(p).x;\n\t\td += s * 0.15;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\t// iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mllyz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 272, 296, 296, 374], [376, 376, 397, 397, 752], [754, 754, 771, 771, 1158], [1160, 1160, 1192, 1192, 1370], [1372, 1388, 1462, 1462, 1701], [1703, 1719, 1761, 1761, 2060], [2062, 2257, 2314, 2314, 2602], [2604, 2604, 2661, 2661, 4186]]}
{"id": "Mlsyz4", "name": "Twotweet branchless pixel noise", "author": "PrzemyslawZaworski", "description": "Abs, sign, mod and ceil are my friends !\nPixelation, RGB noise with avoiding conditionals.", "tags": ["noise", "animation", "mod", "pixelation", "branchless", "abs", "ceil", "sign", "twotweet"], "likes": 3, "viewed": 202, "date": "1503827613", "time_retrieved": "2024-06-20T18:59:59.533728", "image_code": "void mainImage(out vec4 c, vec2 f){vec2 u=f/3e2,p=ceil(u*8.)/8.;\nc.w=abs(sign(mod(p.y*1e3,250.)));\np.y=iTime; u.x+=p.y*.1*(1.-c.w)-p.y*.3*c.w;u=ceil(u*8.)/8.;\nc=fract(sin(vec4(u.x*9e1,u.x*29.5+u.y*13.3,u.x*49.2+u.y*31.9,1))*4e5);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mlsyz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 35, 35, 230]]}
{"id": "MlXcR8", "name": "andreavalente_test3", "author": "andreavalente", "description": "distance functions", "tags": ["distances"], "likes": 0, "viewed": 54, "date": "1503342274", "time_retrieved": "2024-06-20T18:59:59.533728", "image_code": "\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4( \n        \t\t\t// union\n        \t\t\tvec3( 255.0,255.0, 0.0 )*(\n        \t\t\t1.0-(min(\n                        // sphere, center 150,200 with radius 40\n                        (sdSphere( vec3( fragCoord.x-150.0 , fragCoord.y-200.0 , 1.0), 40.0 )) ,\n                        \n                        // sphere, center 170,180 with radius 30\n        \t\t\t\t(sdSphere( vec3( (fragCoord.x- (iTime*10.0) ) -50.0 , fragCoord.y-180.0 , 1.0), 30.0 ))\n                        ))\n                        ),\n        \t\t\t1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXcR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 36, 36, 60], [62, 62, 119, 119, 643]]}
{"id": "MlXyRr", "name": "Fractal Phoenix", "author": "hhhzzzsss", "description": "This is what happens when you take the absolute value after each iteration of the Mandelbrot. In this case, I used a third power Mandelbrot, but I guess it isn't really a Mandelbrot set anymore.", "tags": ["2d", "fractal", "mandelbrot", "zoom", "phoenix"], "likes": 1, "viewed": 191, "date": "1503073397", "time_retrieved": "2024-06-20T18:59:59.533728", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid iterate(inout vec2 z, vec2 c) {\n\tz = vec2( z.x*z.x*z.x - 3.0*z.x*z.y*z.y, 3.0*z.x*z.x*z.y - z.y*z.y*z.y) + c;\n    z = abs(z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    \n    float scale = max(pow(0.9, iTime), 0.003);\n    vec2 center = vec2(0.645, 0.417);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= scale;\n    uv.y = - uv.y;\n    uv += center;\n    //float theta = iTime*10.0;\n    //mat2 rot = mat2 (cos(theta), sin(theta), -sin(theta), cos(theta));\n    //uv *= rot;\n    \n    vec2 z = uv;\n    vec2 c = uv;\n    \n    float iterations = -1.0;;\n    for (float i = 0.0; i < 1000.0; i++) {\n        iterate(z,c);\n        if (dot(z,z) > 64.0) {\n            iterations = i;\n            break;\n        }\n    }\n    \n    if (iterations >= 0.0) {\n        iterations = iterations + 2.0 - log(log(length(z)))/log(3.0);\n    \n    \tfloat hue = pow(iterations/50.0,0.2);\n    \thue += 0.2;\n    \n\t\tfragColor = vec4(hsv2rgb(vec3(hue,1.0,1.0)) ,1.0);\n    }\n    else fragColor = vec4(vec3(0.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXyRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 191], [193, 193, 229, 229, 325], [327, 327, 384, 384, 1274]]}
{"id": "Ms2BDK", "name": "shapingFunc", "author": "gandoula", "description": "shaping karate", "tags": ["shaping"], "likes": 6, "viewed": 167, "date": "1502310659", "time_retrieved": "2024-06-20T18:59:59.533728", "image_code": "#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2BDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[42, 42, 98, 98, 342]]}
{"id": "Ms2BWc", "name": "Spirello", "author": "rubelson", "description": "The ported demo the taken 1nd place of the competition tiny intro on demoparty Chaos Constructions 2014", "tags": ["3d", "wave", "spiral", "color", "isosurface"], "likes": 14, "viewed": 643, "date": "1502576191", "time_retrieved": "2024-06-20T18:59:59.533728", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat f,z,z0;\nconst float n = 40.;\n\nvec2 xy0 = iResolution.xy/2.;\nfloat time = iTime*0.25;\nfloat h = iResolution.x/32.;\nfloat r0 = iResolution.x/5.5;\t// Step of waves\nfloat r1 = iResolution.x/10.5;\t// Height of waves\nfloat phi = 35.;\n\nif (iMouse.z > 0.) phi+=(1.-2.*iMouse.y/iResolution.y)*45.;\n\nfloat pi = 3.14159265;\nfloat p180 = pi / 180.;\n\nfloat sf = sin(phi * p180);\nfloat cf = cos(phi * p180);\n\nmat2 trot = mat2(cos(time),sin(time),-sin(time),cos(time));\n\nvec2 xy = vec2(0.);\nvec2 r = vec2(0.);\nvec3 col = vec3(0.);\n\nxy.x = fragCoord.x - xy0.x;  \t\n\nz0 = -10000.;\n\nfor(float j=0.; j<=n; j++)\n  {\n  xy.y = abs(xy.x) - n * h + 2. * h * j;\n  for(int i=0; i<=1; i++)\n\t{\n\tr = xy * trot;\n\tr.y += sign(r.x) * r0;\n\tf = cos(pi * length(r) / r0);\n\n\tz = xy.y * sf + f * r1 * cf;\n\tif(z > z0)\n\t\t{\n\t\tif( abs(xy0.y+z-fragCoord.y) < 2.-.5*abs(f) )\n\t\tcol = smoothstep(.33, .66, abs(mod(vec3(f+.33,f-.33,f+1.),2.)-1.));\n\t\tz0 = z + 1.;\n\t\t}\n\txy.y += mod(n * h - abs(xy.x), h) * 2.;\t\n\t}\n  if(j > n - abs(xy.x) / h) break;\n  }\nfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2BWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1095]]}
{"id": "Ms2fDt", "name": "AlexM Cloud Test 1", "author": "AlexM", "description": "Attempting to implement clouds as described in \"Real-Time Cloud Rendering\"  paper by Mark Harris and Anselmo Lastra, 2001. I may or may have not implemented it correctly.... though clouds look plausible imho.  It is also rather slow.", "tags": ["clouds"], "likes": 5, "viewed": 652, "date": "1502900533", "time_retrieved": "2024-06-20T19:00:00.897566", "image_code": "// Attempting to implement clouds as described in \"Real-Time Cloud Rendering\" \n// paper by Mark Harris and Anselmo Lastra, 2001.\n// I may or may have not implemented it correctly.... though clouds plausible imho. \n// It is also rather slow - probably scaling noise in a bad way or something. \n\n#define PI 3.141592653589793 \n\nconst float MAXT = 150.0f;\nconst float FOGHEIGHT = 0.40; // background fog height. \nconst float FOGFADEHEIGHT = 0.60; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.839, 1, 0.980);\nconst float FOGDENSITY = 0.009; \nconst float FOGPOWER = 3.0;\n\nconst vec3  SUNDIRECTION = normalize(vec3(-1.0, -0.6, -0.9)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(0.885, 0.980, 0.980); // sun color? \nconst vec3  SKYCOLOR = vec3(0.513, 0.882, 0.945);\n\n// colors for scene objects...\nconst vec3 TILE1_COLOR  = vec3(0.6);\nconst vec3 TILE2_COLOR  = vec3(0.8);\n\nconst vec3 CLOUD_ALBEDO = vec3(1.0);\nconst float CLOUDTRACE_NUMSTEPS = 20.0; // number of cloud samples. \nconst float CLOUDTRACE_STEPSIZE = 0.1;  // spacing of cloud samples.\n\n\nstruct TraceResult {\n    bool  hit;\n    float rayt;\n    float materialID;\n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n    vec3 u = x*x*(3.0-2.0*x);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(2.0*fg-1.0, -1.0, 1.0);\n}\n\nfloat fbm(vec3 p, int oct) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.5;\n\n    for (int i = 0; i < oct; i++) {\n        value += amplitude * noise(p*frequency);\n        p *= 2.;\n        amplitude *= 0.45;\n        frequency *= 1.2;\n    }\n    return value;\n}\n\n// Some primitives and CSG ops.\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,vec3(0.0)));\n}\nfloat sdPlane(vec3 p, vec4 n) { return dot(p, n.xyz) - n.w; }\nfloat opAdd(float d1, float d2) { return min(d1, d2); }\nfloat opSubtract( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat clouds(vec3 p) {\n    float f;\n    f = (sdBox(p, vec3(9000.0, 1.35, 9000.0)));\n    f -= noise(p * 0.4)*0.5+0.5;\n    f = opSubtract(noise((p+vec3(iTime*0.8, 0.0, 0.0))*0.12+iTime*0.02)*0.8, f);\n    f -= fbm(p*0.7+iTime*0.1, 2) *0.15;\n    return f;\n}\n\nfloat map(vec3 p, out float mattype) {\n    mattype = 1.0;\n    float cl = clouds(p);\n    float pl = sdPlane(p, vec4(0.0, 1.0, 0.0, -20.0));\n    float f = opAdd(cl,pl);\n    if (f == pl) mattype = 2.0;\n    return f;\n}\n\nfloat map(vec3 p) { float unused; return map(p, unused); }\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    TraceResult traceResult = TraceResult(false, 0.0, 0.0);\n    float t = 0.02;\n    float tmax = MAXT; \n    float mattype;\n\n    for (; t < MAXT; ) {\n        vec3 rp = ro + rd * t;\n        float tr = map(rp, mattype);\n        if (tr<0.0001) {\n            traceResult = TraceResult(true, t, mattype);\n            break;\n        }\n        t += tr;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\n//@ro - cloud starting position.\n//@rd - view direction\n//@ld - light direction \nvec3 traceCloud(vec3 ro, vec3 rd, vec3 ld) {\n    float a = 1.118;  // transparency constant - each particle in the cloud will have this transparency.\n    float b = 0.056;  // distance field- dependent transparency.\n    float c = 0.896;  // air transparency;\n\n    vec3 albedo = CLOUD_ALBEDO; \n    // phase functions for forward scattering and eye scattering, respectively\n    float ph1 = 3.0/4.0*(cos(PI)*cos(PI)+1.0);\n    float ph2 = 3.0/4.0*(1.0+dot(ld,rd)*dot(ld,rd));\n\n\n    vec3 Ik = SUNCOLOR; \n    vec3 Ek = vec3(0.0); // eye scattering, initially no light is scattered...\n\n\n    const float numsteps = CLOUDTRACE_NUMSTEPS;\n    const float stepsize = CLOUDTRACE_STEPSIZE;\n\n    for (float i = stepsize; i <= stepsize*numsteps; i+=stepsize) {\n        // forward scattering\n        vec3 rp = ro+(i-stepsize)*ld;\n        float m = clouds(rp);\n        float transparency = (m<0.1) ? 1.0/(a+abs(m)*b) : c;\n        vec3 gk = albedo*transparency*Ik*ph1/(4.0*PI);\n        Ik = gk+Ik*transparency;\n\n        // compute eye scattering \n        rp = ro+stepsize*ld; \n        m = clouds(rp);\n        transparency = (m<0.01) ? 1.0/(a+abs(m)*b) : c;\n        vec3 sk = albedo*transparency*Ik*ph2/(4.0*PI);\n        Ek = sk+transparency*Ek;\n    }\n\n    // not sure if averaging is correct...! \n    return clamp((Ik+Ek)*0.5, 0.0, 1.0); \n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = map(p+eps.xyy)-map(p-eps.xyy);\n    float y = map(p+eps.yxy)-map(p-eps.yxy);\n    float z = map(p+eps.yyx)-map(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\n// softshadow function by iq. \nfloat traceShadow(vec3 ro, vec3 rd) {\n    float numsteps = 30.0;\n    float stepsize = 1.6;\n    float res = 1.0;\n    const float k = 200.0;\n\n    for (float i = 0.0; i < numsteps *stepsize; i+=stepsize) {\n        float d = map(ro+i*rd);\n        if (d < 0.001) { return 0.0; }\n        res = min( res, k*d/i );\n    }\n    return res;\n}\n\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist, float d, float p) {\n    return  1.0 - 1.0/exp(pow(dist*d, p));\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n\n    vec3 ro = vec3(iMouse.x*0.05, -18.0+iMouse.y*0.075, 0.0);\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd=rotateX(0.1)*rd;\n    rd=rotateY(-0.7)*rd;\n    rd = normalize(rd);\n    \n    vec3 color = sky(ro, rd);\n\n    TraceResult traceResult = trace(ro, rd);\n    if (traceResult.hit) {\n        vec3 rp = ro+traceResult.rayt*rd;\n        vec3 n = calcNormal(rp);\n\n        if (traceResult.materialID == 1.0) {\n            // get to cloud's start tracing position.\n            vec3 crp = rp + (-SUNDIRECTION)*CLOUDTRACE_NUMSTEPS*CLOUDTRACE_STEPSIZE*1.001;\n            color = 0.1+traceCloud(crp, rd, SUNDIRECTION);\n        }\n\n        if (traceResult.materialID == 2.0) {\n            vec3 tiles = (sin(rp.z) + sin(rp.x) <= 0.0) ? TILE1_COLOR : TILE2_COLOR;\n            vec3 sp = rp + 0.1*n;\n            float ph = phongDiffuseFactor(-SUNDIRECTION, n) \n                     + phongSpecularFactor(-SUNDIRECTION, n, rd, 10.0);\n            color = 0.5*SUNCOLOR + ph * traceShadow(sp, -SUNDIRECTION);\n            color = tiles * color;\n        }\n\n        float fg = fog(traceResult.rayt, FOGDENSITY, FOGPOWER);\n        vec3 fc = FOGCOLOR;\n        color = mix(color, fc, fg);\n    }\n\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2fDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1187, 1211, 1234, 1234, 1337], [1339, 1339, 1362, 1362, 1465], [1467, 1467, 1490, 1490, 1591], [1593, 1612, 1638, 1638, 1712], [1714, 1714, 1739, 1739, 2438], [2440, 2440, 2468, 2468, 2727], [2729, 2761, 2790, 2790, 2887], [2888, 2888, 2919, 2919, 2949], [2950, 2950, 2983, 2983, 3005], [3006, 3006, 3046, 3046, 3068], [3070, 3070, 3092, 3092, 3323], [3325, 3325, 3363, 3363, 3539], [3541, 3541, 3560, 3560, 3599], [3601, 3601, 3638, 3638, 4041], [4043, 4124, 4168, 4168, 5444], [5446, 5446, 5471, 5471, 5675], [5677, 5708, 5745, 5745, 6038], [6040, 6040, 6082, 6082, 6115], [6117, 6117, 6177, 6177, 6258], [6260, 6260, 6301, 6301, 6346], [6348, 6348, 6376, 6376, 6739], [6741, 6741, 6798, 6798, 8259]]}
{"id": "Ms2fDy", "name": "2D shadows", "author": "bytearray", "description": "test", "tags": ["test"], "likes": 8, "viewed": 312, "date": "1502918635", "time_retrieved": "2024-06-20T19:00:00.897566", "image_code": "#define epsilon 1e-4\n#define mint .001\n\n#define sphere( p,r)  ( length(p) - r )\n\nfloat box( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdf(vec2 pos)\n{\n    return min(\n        box(   pos,vec2( .1,  .2 ) ),\n    min(\n        sphere(pos-vec2( .5,  0.), .1),\n        sphere(pos-vec2(-.3, -.3), .1)\n    ));\n}\n\nfloat shadow(vec2 light, vec2 pos, float hard)\n{\n    vec2  d = light - pos;\n\tfloat l = length(d),\n        res = 1.;\n    \n    for( float t=mint, h; t < l; t+= h)\n    {\n        h = sdf(pos + d/l*t);\n        if( h < epsilon ) return 0.;\n        res = min( res, hard*h/t );\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2  R = iResolution.xy,\n         uv = (    U      -.5* R ) / R.y,\n       mpos = ( iMouse.xy -.5* R ) / R.y;\n\t\n    O = sdf(uv) > 0. ? vec4(0) : vec4(1, 0, 0, 1);\n    \n    float shad1 = shadow(vec2(3.*sin(iTime), -4.), uv, 30.),\n          shad2 = shadow(mpos, uv, 30.);\n  \n    O += (shad1+shad2)/2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2fDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[81, 81, 110, 110, 186], [188, 188, 209, 209, 361], [363, 363, 411, 411, 656], [658, 658, 696, 696, 1002]]}
{"id": "MsBBWK", "name": "Marble Balls", "author": "yumcyawiz", "description": "marble texture generated by fbm noise + domain warping\nhttp://iquilezles.org/www/articles/warp/warp.htm", "tags": ["raymarch"], "likes": 5, "viewed": 188, "date": "1502215233", "time_retrieved": "2024-06-20T19:00:00.897566", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat fbm2(vec2 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return r;\n}\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\nfloat fbm3(vec3 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return r;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\n\nvec2 dmin(vec2 d1, vec2 d2) {\n    if(d1.x < d2.x) {\n        return d1;\n    }\n    else {\n        return d2;\n    }\n}\n\n\nvec2 DF(vec3 p) {\n    vec3 q = p;\n    q.xz = mod(q.xz, 4.0) - 2.0;\n    vec2 s1 = vec2(sdSphere(q, 1.0), 1);\n    vec2 s2 = vec2(sdPlane(p, vec4(0, 1, 0, 1)), 2);\n    return dmin(s1, s2);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        DF(p + vec3(eps, 0, 0)).x - DF(p + vec3(-eps, 0, 0)).x,\n        DF(p + vec3(0, eps, 0)).x - DF(p + vec3(0, -eps, 0)).x,\n        DF(p + vec3(0, 0, eps)).x - DF(p + vec3(0, 0, -eps)).x\n    ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n    int hitObj;\n};\nconst int maxSteps = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    int hitObj = 0;\n    for(int i = 0; i < maxSteps; i++) {\n        vec3 p = from + t*rayDir;\n        float d = DF(p).x;\n        if(d < 0.001) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            hitObj = int(DF(p).y);\n            break;\n        }\n        t += d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t, hitObj);\n}\n\n\nfloat detailedAO(vec3 hitPos, vec3 hitNormal, float k) {\n    float ao = 0.0;\n    for(int i = 1; i <= 5; i++) {\n        float d1 = float(i)/float(5) * k;\n        vec3 p = hitPos + d1*hitNormal;\n        ao += 1.0/pow(2.0, float(i)) * (d1 - DF(p).x);\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\n\n\nfloat softShadow(vec3 hitPos, vec3 lightPos, float k) {\n    vec3 lightDir = normalize(lightPos - hitPos);\n    float ss = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = hitPos + lightDir*t;\n        float d = DF(p).x;\n        if(d < 0.001) {\n            return 0.0;\n        }\n        ss = min(ss, k * d/t);\n        t += d;\n    }\n    return ss;\n}\n\n\n\nvec3 phong(vec3 hitPos, vec3 hitNormal, vec3 rayDir, vec3 lightPos, vec3 dc, vec3 sc) {\n    vec3 lightDir = normalize(lightPos - hitPos);\n    float diffuse = max(dot(lightDir, hitNormal), 0.0);\n    float specular = pow(max(dot(reflect(-lightDir, hitNormal), -rayDir), 0.0), 8.0);\n    return 0.5*diffuse*dc + 0.5*specular*sc;\n}\n\n\nvec3 marble(float u, float v) {\n    vec2 p = vec2(u, v);\n    vec2 q = vec2(0);\n    vec2 r = vec2(0);\n    q.x = fbm2(p + vec2(1, 1));\n    q.y = fbm2(p + vec2(2, 2));\n    r.x = fbm2(p + 2.0*q + vec2(1, 1));\n    r.y = fbm2(p + 2.0*q + vec2(2, 2));\n    return fbm2(p + 4.0*r) * vec3(0, q.x + r.x, q.y + r.y);\n}\nvec3 checkerboard(float u, float v, float interval) {\n    u = floor(u/interval*2.0);\n    v = floor(v/interval*2.0);\n    float p = mod(u + v, 2.0);\n    return vec3(0.1 + 0.9*p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    float t = 0.4*iTime;\n    vec3 camPos = 3.0 * vec3(sin(t), 0.5, cos(t));\n    vec3 camFront = -normalize(camPos);\n    vec3 camRight = cross(camFront, vec3(0, 1, 0));\n    vec3 camUp = cross(camRight, camFront);\n    vec3 rayDir = normalize(1.5*camFront + uv.x*camRight + uv.y*camUp);\n    \n    vec3 lightPos = vec3(2, 5, 0);\n    \n    Ray tr = trace(camPos, rayDir);\n    vec3 color = vec3(0);\n    if(tr.hit) {\n        float sAO = 1.0 - float(tr.steps)/float(maxSteps);\n        float dAO = detailedAO(tr.hitPos, tr.hitNormal, 1.2);\n        float fog = exp(-0.2*tr.t);\n        \n        float ss = softShadow(tr.hitPos, lightPos, 12.0);\n        \n        vec3 mat = vec3(1);\n        vec3 brdf = vec3(1);\n        if(tr.hitObj == 1) {\n        \tfloat u = atan(tr.hitNormal.y, length(tr.hitNormal.xz)) + 3.14;\n        \tfloat v = atan(tr.hitNormal.z, tr.hitNormal.x) + 3.14;\n            mat = marble(u, v);\n            brdf = phong(tr.hitPos, tr.hitNormal, rayDir, lightPos, mat, vec3(1));\n        }\n        else if(tr.hitObj == 2) {\n            mat = checkerboard(tr.hitPos.x, tr.hitPos.z, 1.0);\n            brdf = phong(tr.hitPos, tr.hitNormal, rayDir, lightPos, mat, vec3(1));\n        }\n        \n        float geo = 100.0/pow(distance(tr.hitPos, lightPos), 2.0);\n        \n        color = 0.7 * ss * geo * brdf + 0.3*dAO*mat;\n        color *= fog;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBBWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 87], [88, 88, 108, 108, 317], [318, 318, 338, 338, 530], [533, 533, 555, 555, 600], [601, 601, 621, 621, 666], [667, 667, 685, 685, 724], [725, 725, 745, 745, 1236], [1237, 1237, 1257, 1257, 1449], [1452, 1452, 1485, 1485, 1513], [1514, 1514, 1545, 1545, 1579], [1582, 1582, 1611, 1611, 1696], [1699, 1699, 1716, 1716, 1886], [1889, 1889, 1914, 1914, 2165], [2305, 2305, 2340, 2340, 2858], [2861, 2861, 2917, 2917, 3154], [3157, 3157, 3212, 3212, 3529], [3533, 3533, 3620, 3620, 3859], [3862, 3862, 3893, 3893, 4168], [4169, 4169, 4222, 4222, 4347], [4350, 4350, 4407, 4407, 5863]]}
{"id": "MsBBWt", "name": "Spooky Cave", "author": "slerpy", "description": "Can you see the light at the end of the tunnel?", "tags": ["raytracing", "simple", "tunnel", "fog", "map", "aa", "cave"], "likes": 16, "viewed": 356, "date": "1502704990", "time_retrieved": "2024-06-20T19:00:00.897566", "image_code": "#define TAU 6.28318530718\n\nmat3 rz(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat3(c,s,0,-s,c,0,0,0,1);\n}\n\nvec3 t(vec3 p){ return abs(p-floor(p)-.5); }\nvec3 s(vec3 p){ return t(p+t(p/4.).zxy).zxy; }\nfloat b(vec3 p){ p.z-=round(p.z); return length(p.xz-.5); }\n\nfloat map(vec3 p)\n{\n\treturn min(.4-length(p.xy)+dot(s(p*rz(p.z/4.)),\n    \tvec3(.6)),b(p*rz(round(p.z)*1.5))-.06);\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{\n\tfloat t=.0, m;\n\tfor(int i=0; i<56; i++){\n\t\tt += .9 * (m = map(ro+rd*t));\n\t\tif(m<t*1e-3||t>12.)break;\n\t}\n\treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = .0;\n    for(int i=0; i<4; i++)\n   \t\tt += tracer(vec3(0, 0, iTime-5.),normalize(\n        \tvec3(2.*fragCoord.xy+vec2(i&1,i>>1)-iResolution.xy,\n            \t3.*iResolution.y))*rz(cos(iTime/16.)));\n    \n\tfragColor = vec4(t*t/2304.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBBWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[27, 27, 45, 45, 113], [115, 115, 130, 130, 159], [160, 160, 175, 175, 206], [207, 207, 223, 223, 266], [268, 268, 287, 287, 383], [385, 385, 417, 417, 535], [537, 537, 592, 592, 837]]}
{"id": "MsBBWV", "name": "36.0284", "author": "etrepum", "description": "antialiased circles using a distance field drawing method", "tags": ["circles"], "likes": 1, "viewed": 110, "date": "1502322151", "time_retrieved": "2024-06-20T19:00:00.897566", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat sdCircle( vec2 p, vec2 c, float r )\n{\n    return length(p - c) - r;\n}\n\nfloat sdCircleStroke( vec2 p, vec2 c, float r, float w )\n{\n    return opS(\n        sdCircle(p, c, r - w * 0.5),\n        sdCircle(p, c, r + w * 0.5)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0 / min(iResolution.x, iResolution.y);\n    vec2 uv = scale * fragCoord;\n    vec2 c = scale * 0.5 * iResolution.xy;\n    vec4 bg = vec4(1.0);\n    vec4 fg = vec4(132.0/255.0, 80.0/255.0, 224.0/255.0, 1.0);\n    float t = iTime;\n    float blur = scale * 0.5 * M_PI;\n    float ud = 1.0;\n    float numCircles = 10.0;\n    for (float i = 0.0; i < numCircles; i += 1.0) {\n        ud = opU(\n            ud,\n            sdCircleStroke(\n                uv,\n                c + mix(0.0, 0.3, i / numCircles) * vec2(cos(t), sin(t)) * sin(t * 0.1234),\n                mix(0.45, 0.01, i / numCircles),\n                2.0 * scale\n            )\n        );\n    }\n\tfragColor = mix(\n        fg,\n        bg,\n        smoothstep(0.0, blur, ud)\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBBWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[48, 122, 155, 155, 182], [183, 183, 216, 216, 241], [243, 243, 286, 286, 318], [320, 320, 378, 378, 476], [478, 478, 535, 535, 1284]]}
{"id": "MsBBzt", "name": "36.0109", "author": "etrepum", "description": "Hello, color. P.1.0 Generative Design", "tags": ["rect"], "likes": 0, "viewed": 80, "date": "1501656031", "time_retrieved": "2024-06-20T19:00:00.897566", "image_code": "// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rect( in vec2 uv, in vec2 center, in vec2 widthHeight )\n{\n    vec2 dist = floor(abs((center - uv) / widthHeight));\n    return sign(dist.x + dist.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = 0.5 + 0.5 * vec2(sin(iTime), cos(iTime * pow(2.0, 0.5)));\n    float epsilon = 1.0 / iResolution.x;\n    if (iMouse.z > 0.0) {\n        mouse = iMouse.xy / iResolution.xy;\n    }\n\tfragColor = mix(\n        vec4(hsv2rgb(vec3(1.0 - 0.5 * mouse.y, 1.0, 1.0)), 1.0),\n        vec4(hsv2rgb(vec3(0.5 * mouse.y, 1.0, 1.0)), 1.0),\n        rect(\n            uv,\n            vec2(0.5),\n            mouse.xx * 0.5 + epsilon\n        )\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBBzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 59, 81, 81, 250], [252, 252, 315, 315, 408], [410, 410, 467, 467, 952]]}
{"id": "MsBfDG", "name": "The walking polygons", "author": "rubelson", "description": "Test of rotation of polygons", "tags": ["rotation", "polygon", "df"], "likes": 11, "viewed": 135, "date": "1501888251", "time_retrieved": "2024-06-20T19:00:01.182305", "image_code": "float regularPolygon(float parts, float radius, float blur, vec2 pos, float rotate, vec2 p)\n{\nfloat pi = 3.14159265;\nfloat a = 2.0 * pi * (1.0 / parts);\nfloat size = radius * cos(a /2.0);\nfloat ca = cos(a);\nfloat sa = sin(a);\nmat2 rmat = mat2(ca, -sa, sa, ca);\nca = pi + rotate -a;\nvec2 lp = vec2(sin(ca), cos(ca));\nvec2 addv = lp;\nfloat r = 0.0;\n\nfor(float i=0.; i<=100.; i++)\n\t{\n\taddv = rmat * addv;\n\tr = max(r, smoothstep(size, size+blur, dot(p - pos, normalize(addv))));\n    if(i>parts) break; //and how differently?    \n\t}\nreturn 1. - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nconst float n = 10.;\nfloat a = 0.14;\nvec2 p = fragCoord.xy / iResolution.x; \nfloat t = fract(iTime/2.);\nfloat pi = 3.14159265;\nfloat p2 = pi*2.;\nvec3 color[6];\ncolor[0]=vec3(1.,0.,0.);color[1]=vec3(0.,1.,1.);color[2]=vec3(0.,0.,1.);\ncolor[3]=vec3(1.,0.,1.);color[4]=vec3(0.,1.,0.);color[5]=vec3(1.,1.,0.);\nfloat blur = 0.0;\nvec3 col = vec3(0.);\n\nfor(float i=n-1.; i>=0.; i--)\n  {\n  float r = a / (2.*sin(pi/(i+3.)));\n  float alf = p2 * (t-.5)/(i+3.);\n  float rad = p2 * t/(i+3.);\n  vec2 pos = vec2(.5 + a*(.5-t) + r*sin(alf), .01 + r*cos(alf));\n  col = mix(col,color[int(mod(i,6.))],regularPolygon(i+3., r, blur, pos, rad, p));\n  }\nfragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 93, 93, 544], [546, 546, 603, 603, 1263]]}
{"id": "MsBfDt", "name": "Movement Illusion", "author": "DJDoomz", "description": "Based off of a gif I saw on twitter. Do the balls look like they're moving in a straight line between the spinny things? Click and find out", "tags": ["2d", "illusion"], "likes": 3, "viewed": 516, "date": "1502739964", "time_retrieved": "2024-06-20T19:00:01.182305", "image_code": "#define PI 3.14159\n#define SPEED .5\n#define SCALE (4.)\n\n#define atan2(a) atan(a.x,a.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime*SPEED*4./(2.*PI))*2.*PI;\n\tvec2 uv = fragCoord.xy / iResolution.xy, muv = uv;\n    uv *= SCALE;\n    uv.y/=iResolution.x/iResolution.y;\n    uv = fract(uv);\n    uv -= .5;\n    uv *= 3.;\n    float s = sin(t), c = cos(t);\n    vec2 cpos = vec2(s,c)*1.4;\n    float color = length(uv-cpos) < .12 || length(uv+cpos) < .12 ? 1. : 0.;\n    \n    muv.y/=iResolution.x/iResolution.y;\n    muv *= SCALE;\n    muv +=.5;\n    muv = fract(muv);\n    muv -=.5;\n    \n    float ang = t+.2*cos(t*4.+1.7);\n    \n    s = sin(ang), c = cos(ang);\n    \n    muv *= mat2(c,s,-s,c);\n    float color2 = 0.;\n    if(iMouse.w < 0.1)\n    color2 = length(muv) < .45 ?\n        \t\t   pow(abs(sin(atan2(muv)*2.)),.1) > .9 ? 1.: 0. : 0.;\n    fragColor = vec4(color,0,0,1)+color2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBfDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[88, 88, 145, 145, 904]]}
{"id": "MsjBDt", "name": "Brit Electric Flower", "author": "nightfox", "description": "My second shader modified taking microphone input with video", "tags": ["2d", "audio"], "likes": 1, "viewed": 468, "date": "1502892903", "time_retrieved": "2024-06-20T19:00:01.182305", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \tfloat d = distance(abs(uv),vec2(0.5*cos(2.7*iTime),sin(iTime)));\n\n  \tfloat d2 = distance(abs(uv),vec2(0.5*sin(4.7*iTime),cos(3.0*iTime)));\n\n  \td = max(d,d2);\n\n  \tfloat f2 = texture( iChannel0, vec2(20.0)).r * 1.0;\n\n  \tvec3 color = vec3(0.0);\n\n  \tvec2 pos = vec2(0.5)-uv;\n\n  \tfloat r = length(pos)*2.0+sin(iTime);\n  \tfloat a = atan(pos.y,pos.x);\n\n  \tfloat f = abs(cos(20.0*iTime+a*3.+.1*iTime*f2))*sin(iTime)+0.4*sin(d);\n\n  \tcolor = vec3( f*sin(iTime)+uv.x-r-smoothstep(f,f+0.02,r) );\n  \tcolor = mix(color,vec3(f/2.0,tan(pow(d,4.0)),1.0),f);\n    \n    vec2 brituv = uv;\n    \n    brituv.x /= 2.0*abs(sin(iTime))+0.5;\n \tvec4 vid = texture(iChannel0,brituv);\n    vid.r += sin(iTime);\n  \tcolor = mix(color, vid.rgb, abs(sin(iTime)));\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjBDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 924]]}
{"id": "MsjfDc", "name": "Orthographic Tesseract", "author": "rory618", "description": "Use mouse to change what dimensions are visible. Now animated!", "tags": ["tesseract"], "likes": 3, "viewed": 235, "date": "1502609529", "time_retrieved": "2024-06-20T19:00:01.182305", "image_code": "vec3 h2rgb(float h)\n{\n    return clamp(2.0-abs(mod(h*3.0+vec3(0.0,0.0,2.0),3.0)-vec3(2.0,1.0,2.0))*2.0,0.0,1.0);\n}\n\n\n#define pi asin(1.)*2.\nvoid lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P \n\n    \n    fragColor += vec4(c.xyz,1) * c.w*clamp(w-length( z - b),0.,1.);\n}\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o-=o;\n    float s = iResolution.y / 10.;\n    vec2 ii = i-iResolution.xy/2.;\n    \n    vec2[8] units;\n    \n    \n    for(float dims = floor((1.-iMouse.x/iResolution.x)*6.9); dims >= floor((iMouse.y/iResolution.y)*6.9); dims--){\n        float radius = s * dims + 10.;\n        \n        if(length(ii)<radius){\n            for(float d = 0.; d < dims; d++){\n                \n                \n                units[int(d)] = sin((d+.5)/dims*pi+.00001*vec2(iTime*(47.*d*d-1701.*d+10181.),iTime*(103.*d*d-4707.*d+50383.))+vec2(0,pi/2.));\n                \n            }\n            float verts = pow(2.,dims);\n            for(float v = 0.; v < verts; v++){\n                vec2 p = vec2(0);\n                for(float d = 0.; d < dims; d++){\n                    p += units[int(d)]*(bool((int(v) & int(pow(2.,d))))?1.:-1.);\n\n                }\n\n                for(float d = 0.; d < dims; d++){\n                    vec2 pp = p - 2.*units[int(d)]*(bool((int(v) & int(pow(2.,float(d)))))?1.:-1.);\n                    lineSegment(o,ii,p*s, pp*s,vec4(h2rgb(1.-dims/6.),.25),1.3);\n                }\n            }\n        }\n    }\n    \n    \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 114], [140, 140, 221, 221, 542], [544, 544, 585, 585, 1725]]}
{"id": "MsjfDK", "name": "Sponges 106 chars one tweet", "author": "benoitM", "description": "First attempt to make a short shader. Can you help to reduce?", "tags": ["2d", "fractal", "short", "tweet"], "likes": 27, "viewed": 838, "date": "1502313594", "time_retrieved": "2024-06-20T19:00:01.503572", "image_code": "// Created by Benoit Marini - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// not resolution independant but 11 chars less\nvoid mainImage(out vec4 o, vec2 u){\n    o = vec4(u, iTime*4e1,0)/7.;\n    for (int i=0 ; i++ < 99;)\n        o.xzyw = abs( o/dot(o,o)- vec4(1,.9,.1,0) );}\n\n\n// Thanks Fabrice!\n// 117 chars\n/*\n#define mainImage( o, u )                   \\\n    o = vec4(u/iResolution.x, iTime*.02,0); \\\n    for (int i=0 ; i++ < 99;)               \\\n        o.xzyw = abs( o/dot(o,o)- vec4(1,.9,.1,0) )\n*/\n\n// Thanks Coyote!\n// 130 chars\n/*void mainImage( out vec4 o, vec2 u )\n{\n    o = vec4(u/iResolution.x,iTime*.02,0);\n    for (int i=0 ; i++ < 99;) o.xzyw = abs( o/dot(o,o)- vec4(1,.9,.1,0) );\n}*/\n\n// 139 chars, browser compatible\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    vec3 p = vec3(u/iResolution.x,iTime*.02);\n \tfor (int i=0 ; i < 99;i++) p.xzy = abs( p/dot(p,p)- vec3(1,.9,.1) );\n\to = p.xyzx;    \n}\n*/\n\n// 137 chars, not compatible with all browser and shadertoy app because i is not initialized\n/*void mainImage( out vec4 o, vec2 u )\n{\n    vec3 p = vec3(u/iResolution.x,iTime*.1);\n \tfor (int i ; i < 99;i++) p.xzy = abs( p/dot(p,p)- vec3(1,.9,.1) );\n\to = p.xyzx;    \n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[123, 171, 206, 206, 323]]}
{"id": "MsjfRd", "name": "Dr. Krömtgen's cell (music vis)", "author": "vapoi", "description": "This shader is part of my latest music visualization video:\nwww.youtube.com/watch?v=KKDOUHB9ovA\n\nYou can create your own styles using your shaders, i released Soundbild2 as freeware :)\nwww.weltfalt.de/soundbild2\n", "tags": ["2d", "simple", "video", "musicvisualization", "luminescent"], "likes": 1, "viewed": 511, "date": "1501786310", "time_retrieved": "2024-06-20T19:00:02.891693", "image_code": "const float fPi = 3.14159;\nconst float fEu = 2.71828;\n\nconst vec3 colMain1 = vec3(1.2, 1.1, 0.15);\nconst vec3 colMain2 = vec3(0.1, 1.3, 1.2);\nconst vec3 colDetail1 = vec3(0.2, 0.05, 0.04);\nconst vec3 colDetail2 = vec3(0.2, 0.05, 0.04);\n\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Noise-Functions, https://github.com/ashima/webgl-noise\n// \n// Copyright (C) 2011 by Ashima Arts (Simplex noise)\n// Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat heightNoise(vec2 poi)\n{\n\treturn \t  cnoise(poi) * 0.633\n\t\t\t+ cnoise(poi + vec2(4.7)) * 0.333\n\t\t\t+ cnoise(poi + vec2(9.4)) * 0.133;\n}\nfloat sNoise(vec2 poi)\n{\n\treturn \t  cnoise(poi) * 0.633\n\t\t\t+ cnoise(poi * vec2(2.2)) * 0.333\n\t\t\t+ cnoise(poi * vec2(4.7)) * 0.133;\n}\n\nfloat DistanceP(vec2 p, vec2 segA, vec2 segB)\n{\n    \tvec2 p2 = vec2(segB.x - segA.x,segB.y - segA.y);\n    \tfloat num = p2.x * p2.x + p2.y * p2.y;\n    \tfloat u = ((p.x - segA.x) * p2.x + (p.y - segA.y) * p2.y) / num;\n\n    \tif (u > 1.0 ) {\n    \t\tu = 1.0;\n    \t}\n    \telse if (u < 0.0) {\n    \t\tu = 0.0;\n    \t}\n\n    \tfloat x = segA.x + u * p2.x;\n    \tfloat y = segA.y + u * p2.y;\n\n    \tfloat dx = x - p.x;\n    \tfloat dy = y - p.y;\n\n    \treturn sqrt(dx*dx + dy*dy);\n}\n\n\nfloat GetNoiseP(vec2 poi, vec2 per)\n{\n\treturn \t1.5 + pnoise(poi, per) \n\t\t\t+ pnoise(poi * vec2(0.50), per)\n\t\t\t;\n}\nfloat GetNoiseD(vec2 poi, vec2 per)\n{\n\treturn \t0.7 * pnoise(poi, per) +\n\t\t\t0.3 * pnoise(poi + vec2(0.5, 3.0), per) +\n\t\t\t0.1 * pnoise(poi + vec2(1.0, 6.0), per)\n\t\t\t;\n}\n\nfloat GetNoise(vec2 poi)\n{\n\treturn \t0.7 * cnoise(poi) +\n\t\t\t0.3 * cnoise(poi * vec2(2.17))\n\t\t\t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pMid = vec2(-1.0, -1.0) + 2.0 * uv;\n\t\n\tpMid.x *= iResolution.x / iResolution.y;\n\t\n    float fNumber = 5.0;\n    float vTime = iTime * 1.0;\n    float fSecondCore = clamp(sin(vTime * 1.3) + cos(vTime * 0.95), 0.0, 1.0);\n    float fSpec = clamp(sin(vTime * 0.93) + cos(vTime * 1.35), 0.0, 1.0);\n\t\n\tfloat distanceToMid = length(pMid);\n\tfloat fAngle = atan(pMid.y, pMid.x);\n\tfloat fGrain = 0.0 + GetNoise(pMid * 14.0 + vec2(fNumber * 4.0, fNumber * 3.0));\n\n\tfloat someNoise = GetNoiseD(vec2(((fAngle / fPi) + 0.5) * 7.0 + fNumber * 13.0,\n\t\t\t\t\t\t\t\t\t distanceToMid * 7.30 + fNumber * 3.1 - vTime * 0.93),\n\t\t\t\t\t\t\t\tvec2(7.0, 35.0));\n\tsomeNoise *= clamp((distanceToMid - 0.1) * 4.0, 0.0, 1.0);\n\tfloat modifyBorder = someNoise * (0.025 + fSpec * 0.025);\n\t\t\t\t\t\n\t// Cell-Core \n\tfloat rotateOnAction = sin(vTime * 0.61 + fNumber * 0.92);\n\tfloat rotateOnAction2 = sin(vTime * 0.41 + fNumber * 0.52);\n\tvec2 corePos = vec2(sin(vTime * 0.64 + fNumber * 0.71 + fSpec * rotateOnAction), \n\t\t\t\t\t    cos(vTime * 0.73 + fNumber * 1.2 + fSpec * rotateOnAction2)) * (0.2 + 0.8 * fSpec) * 0.18;\n\t\n\tfloat fCore = smoothstep(-0.1, -0.04, -length(pMid + corePos));\n\t\n\t\n\tvec2 corePos2 = corePos;\n\tfloat fSecCore = fSecondCore * 0.5 * (1.0 + cos(vTime * 0.43 + sin(vTime * 0.46 + fNumber * 0.42) + fNumber * 0.35));\n\t\n\tif (fSecCore > 0.0)\n\t{\n\t\tfloat secCoreDif1 = -0.6 * (1.0 + sin(vTime * 0.5 + sin(vTime * 0.6 + fSpec + fNumber * 0.3) + fNumber * 0.45));\n\t\tfloat secCoreDif2 = 0.7 * (1.0 + sin(vTime * 0.6 + sin(vTime * 0.4 + fSpec + fNumber * 0.35) + fNumber * 0.4));\n\t\tcorePos2 = mix(corePos, vec2(sin(secCoreDif1 + vTime * 0.64 + fNumber * 0.71 + fSpec * rotateOnAction), \n\t\t\t\t\t\t\t\t\t cos(secCoreDif2 + vTime * 0.73 + fNumber * 1.2 + fSpec * rotateOnAction2)) \n\t\t\t\t\t\t\t\t\t * (0.2 + 0.8 * fSpec) * 0.18 * clamp(secCoreDif1 + secCoreDif2, -0.5, 1.0),\n\t\t\t\t\t  0.5 * (1.0 + cos(fPi + fPi * fSecCore)));\n\t\tfCore = max(fCore, smoothstep(-0.1, -0.04, -length(pMid + corePos2)));\n\t\tcorePos = (corePos + corePos2) * 0.5;\n\t}\n\t\n\tfloat fOuterCore = smoothstep(-0.2, -0.05, -length(pMid + corePos * 0.75) + 2.0 * modifyBorder * fGrain);\n\t\n\t\n\t\n\t// Cell\n\tfloat fShapeVisible = 0.0;\n\tfShapeVisible = (0.6 + 0.45 * fSpec ) * (1.0 - 0.05 * someNoise - fGrain * 0.1)\n\t\t\t\t\t\t * smoothstep(-0.42, -0.30 - fSpec * 0.05, -distanceToMid + modifyBorder - min(0.0, fGrain * 0.05))\n\t\t\t\t\t\t * (1.0 - 0.35 * smoothstep(0.20 - fSpec * 0.0, 0.38, distanceToMid + modifyBorder - min(0.0, fGrain * 0.1))) ;\n\n\tfloat fModifiedDist = distanceToMid * (1.0 - 0.7 * modifyBorder);\n\tfShapeVisible += fOuterCore * (0.15 - fSpec * 0.45);\n\t\n\n\t// cell core structure\n\tif (fCore > 0.0)\n\t{\n\t\tfCore += 0.5 * fGrain;\n\t}\n\t\n\t// coloring\n\tvec3 colSpec = mix(vec3(0.45), mix(colMain1, colMain2, fNumber / 40.0), fSpec * 1.0);\n\t\n\tvec3 colSpec2 = mix(vec3(0.25), mix(colDetail1, colDetail2, fNumber / 40.0), fSpec * 1.1);\n\tcolSpec = mix(colSpec, colSpec2, min(1.0, max(0.0, -someNoise * 1.0) * fSpec * fShapeVisible * 1.5));\n\t\n\t// cell core is fading to grey on amplitude\n\tcolSpec = mix(colSpec, vec3(0.1) + vec3(0.25) * fSpec, fCore);\n\t\n\t\n\t\n\tvec3 colBorder = mix(colSpec * 0.5, vec3(0.2) + vec3(0.1) * fSpec, smoothstep(0.3, 0.6, fModifiedDist))\n\t\t\t\t\t* (0.2 + 0.2 * fSpec)\n\t\t\t\t\t* smoothstep(-0.9, -0.4, -fModifiedDist)\n\t\t\t\t\t* smoothstep(0.3, 0.4, fModifiedDist);\n\tvec3 colDot = mix(colBorder, colSpec * fShapeVisible, fShapeVisible);\n\t\n\t\n\t\n\t\n\t// 3D Light Effect Test\n\tfAngle = ((fAngle / fPi) + 0.5) * 3.0 - 0.25 * fSpec * (1.0 + rotateOnAction);\n\t\n\tfAngle *= 1.0 - fSpec * 0.3;\n\tfloat fLight = smoothstep(0.0, 1.0, fAngle)\n\t\t\t\t * smoothstep(-2.0, -1.0, -fAngle);\n\tfloat moveIn = 0.025 * fSpec;\n\tfLight *= smoothstep(-0.3 - moveIn, -0.2 - moveIn, -fModifiedDist)\n\t\t\t* smoothstep(0.1 + moveIn, 0.2 + moveIn, fModifiedDist);\n\tcolDot += vec3(0.3) * (1.0 - 2.0 * fSpec) * (1.0 - 2.0 * modifyBorder) * fLight;\n\t\n\n\t\n\tfragColor = vec4(colDot, smoothstep(-0.9, -0.38, -fModifiedDist));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[238, 238, 259, 259, 308], [310, 310, 332, 332, 369], [371, 371, 399, 399, 451], [453, 453, 472, 472, 512], [1783, 1807, 1829, 1829, 2871], [2873, 2915, 2947, 2947, 4062], [4064, 4064, 4093, 4093, 4201], [4202, 4202, 4226, 4226, 4334], [4336, 4336, 4383, 4383, 4798], [4801, 4801, 4838, 4838, 4913], [4914, 4914, 4951, 4951, 5080], [5082, 5082, 5108, 5108, 5178], [5181, 5181, 5238, 5238, 9185]]}
{"id": "MsjfWK", "name": "Squaring the Circle", "author": "rwvens", "description": "Little test shader I used to find the formula I need in order to \"push\" radial samples into a box shape. Formula is used in calculating sample positions for plan/profile curvature estimation in my terrain engine.", "tags": ["pixel", "circle", "square", "shapes", "raster"], "likes": 0, "viewed": 145, "date": "1502301020", "time_retrieved": "2024-06-20T19:00:03.049258", "image_code": "// Draw a square using polar coordinates\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fit UV to view height and translate to center\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(.5,.5);\n    \n    // Convert UV into polar coordinates\n    float phi = atan(uv.y,uv.x);\n    \n    // Find distance scaling factor for angle - I call it the squarify formula\n    float sq = 1.0/cos(mod(phi + 0.785398,1.5708)-0.785398);\n    \n    // Scale UV, pushing corners out to form a square\n    // Animated using Fabrice Neyret's excellent suggestion\n    uv /= mix( 1., sq, .5+.5*sin(iTime));\n    \n    // Give us a nice anti-aliased fill\n    float val = smoothstep(0.30,0.305,length(uv));\n    \n\tfragColor = vec4(val,val,val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjfWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 41, 98, 151, 730]]}
{"id": "MsSBDK", "name": "Too many reflections", "author": "slerpy", "description": "A rotating cube inside a sphere", "tags": ["reflection", "simple", "raytracer"], "likes": 1, "viewed": 132, "date": "1502192582", "time_retrieved": "2024-06-20T19:00:03.049258", "image_code": "#define TAU 6.28318530718\n\n#define FAR 50.\n#define ITER 80\n#define QUA .001\n#define NORK 5e-3\n\n#define REF 0.8\n#define RITER 32\n#define RRFB .05\n\n#define BRG .4\n\nmat3 rx(float a){ float sa=sin(a), ca=cos(a); return mat3(1.,0.,0.,0.,ca,sa,0.,-sa,ca); }\nmat3 ry(float a){ float sa=sin(a), ca=cos(a); return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca); }\nmat3 rz(float a){ float sa=sin(a), ca=cos(a); return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.); }\n\nfloat box(vec3 p){ p=abs(p); return max(max(p.x,p.y),p.z); }\n\nfloat map(vec3 p)\n{\n    //float s = 10. - box(p);\n    float s = 10. - length(p);\n    float c = box(p) - 1.;\n    return min(s, c);\n}\n\nvec3 normal(vec3 p, float k)\n{\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tmap(p) - map(p - e.yxx),\n\t\tmap(p) - map(p - e.xyx),\n\t\tmap(p) - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t || t > FAR) break;\n        t += d;\n    } \n    return t;\n}\n\nfloat hard_shadow(vec3 sp, vec3 lp, int iter)\n{   \n\tvec3 p, ld = normalize(sp - lp);\n\n\tfloat t = .0;\n\tfor(int i = 0; i < iter; i++)\n\t{\n\t\tp = lp + ld * t;\n\t\tfloat m = map(p);\n\t\tif (m < .0 || t > FAR) break;\n\t\tt += m;\n\t}\n\n\treturn max(1. - distance(p, sp), 0.);\n}\n\nvec3 color(vec3 sp, vec3 sn)\n{   \n    vec3 lp = vec3(-3, 2, -4);\n\tvec3 ld = normalize(lp - sp);\n    \n    float diff = max(dot(sn,ld),0.);\n    float shd = hard_shadow(sp, lp, 30);\n    \n    vec3 col = (sn.xyz+1.)/2.;\n    return col * diff * shd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    mat3 rm = ry(iTime/3.) * rx(iTime/4.);\n    \n\tvec3 ro = rm * vec3(vec2(.0), -5.);\n    vec3 rd = rm * normalize(vec3(uv,2.));\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n\tvec3 sn = normal(sp,NORK);\n    \n    vec3 col = color(sp, sn);\n    \n    for(int i=0; i<RITER; i++)\n    {\n        if(t > FAR) break;\n            \n        rd = normalize(reflect(rd, sn));\n        ro = sp + rd * RRFB;\n        \n        t = tracer(ro, rd) - RRFB;\n        \n        sp = ro + rd * t;\n\t\tsn = normal(sp,NORK);\n    \n        col += color(sp, sn) * pow(REF, float(i) + 1.);\n    }\n    \n\tfragColor = BRG * vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[162, 162, 179, 179, 251], [252, 252, 269, 269, 341], [342, 342, 359, 359, 431], [433, 433, 451, 451, 493], [495, 495, 514, 544, 626], [628, 628, 658, 658, 791], [793, 793, 825, 825, 999], [1001, 1001, 1048, 1048, 1261], [1263, 1263, 1293, 1293, 1508], [1510, 1510, 1567, 1567, 2246]]}
{"id": "MsSBWG", "name": "20170804", "author": "RitonAndRoll", "description": "Ascenseur émotionnel", "tags": ["ascenseurmotionnel"], "likes": 0, "viewed": 59, "date": "1501860603", "time_retrieved": "2024-06-20T19:00:03.049258", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\n\t\n\tvec4 color1 = vec4(sin(iTime)*sin(iTime)/2.0*0.855+0.4, sin(iTime)*sin(iTime)*0.0234, sin(iTime)*sin(iTime)*0.222,0.1);\n\tvec4 color2 = vec4(sin(iTime)*sin(iTime)*0.884, sin(iTime)*sin(iTime)/2.0*0.850+0.5, sin(iTime)*sin(iTime)*0.648,0.1);\n\tvec4 color3 = vec4(sin(iTime)*sin(iTime)*0.348, sin(iTime)*sin(iTime)*0.555, sin(iTime)*sin(iTime)/2.*0.641+0.6,0.1);\n\tvec4 pixel;\n\t\n\tif ( r.y*cos(2.5*iTime) < 1.0/3.0) {\n\t\tpixel = color1\n            // Bleu\n            ;\n\t} else if( r.y*cos(2.5*iTime) < 2.0/3.0 ) {\n\t\tpixel = color2;\n        // Vert\n\t} else {\n\t\tpixel = color3;\n        // Rouge\n\t}\n\n\n\tfragColor = vec4(pixel);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 761]]}
{"id": "MsSBWy", "name": "lerpSnake() tangent", "author": "ollj", "description": "grey box constrains mouse\nmouse.x sets left    green radius\nmouse.y sets right  green radius (gets pushed)\n\nc.b=blue distance.y , connects (0,0) and (1.1), is smoothstep()-like.\nred circles show where tangent touches circles.\nParametric Lipschitz !!!", "tags": ["smoothstep", "lipschitz", "sawcos", "bisymmetry", "lerpsnake"], "likes": 4, "viewed": 564, "date": "1501916861", "time_retrieved": "2024-06-20T19:00:03.788559", "image_code": "/*\nmouse.x sets left  green radius\nmouse.y sets right green radius (gets pushed by mous.x)\n\nc.b=blue distance.y , connects (0,0) and (1.1), is smoothstep()-like.\n\nred circles show where tangent touches circles.\nmax derivative ==lipschitz constant IS A PARAMETER\nc.b=blue distance.y , connects (0,0) and (1.1), is smoothstep()-like.\n\nred circles show where tangent touches circles.\n\nthis is a general case of snake-shaped curves (there the circles always touch,no tangent)\nhttps://www.shadertoy.com/view/ldSBR3\nand \nhttps://www.shadertoy.com/view/lsSfRc\nwhile here a parameter ensures that there is always a tangent.\nthe inverse of that parameter is its max first derivative\n... == its lipschits constant:\n*/\n//maximum derivative should be range [2...1000],\n//sets an upper minimum distance.xy between the 2 red dots.\n#define LipschitzConstant 500.\nconst float inverseLipschitz=1./LipschitzConstant;//used for multiple calculations\n//smallet radius that both circles can have, to avoid a discontinuity at x=0 otr x=1.;\n#define smallestR 0.1\n\n#define ViewZoom 3.\n\n/*\nI think lerpSnake() is smoother than sawCos()\nhttps://www.shadertoy.com/results?query=sawcos\nbut lerpSnake has a few more length()\nbut i have no comparison done yet.\n*/\n\n\n//I ran out of time to optimize this, functions may be a bit messy, not too user friendly.\nfloat Plane(vec2 u, vec3 plane){float d=abs(dot(plane,vec3(u, 1.0))); \n //return fract(d);\n return 1.2 * smoothstep(0.01, .1, d);}\n\n//return Outer tangent lines for two circles , return format is \"tricky\" .z is scalar.\n//inner tangent lines are gotten by negating ONE of the radii.\nvec3 CircleOuterTangents(vec2 pix, vec3 C1, vec3 C2){\n vec3 dx=(C1 - C2)/length(C1.xy-C2.xy);   \n const float s=1.;//sign switches between 2 tangents.\n float r=sqrt(1.-dx.z*dx.z),\n       d=dx.z*dx.x+s*dx.y*r,\n       e=dx.z*dx.y-s*dx.x*r;return vec3(d,e,C1.z-(d*C1.x+e*C1.y));}\n\n#define plot( d) smoothstep(5./iResolution.y,0.,abs(d))\n/*\n//common line segment, always handy to debug\nfloat segment(vec2 p, vec2 a, vec2 b){\n if(a==b)return length(p-a);\n vec2 c=b-a,d=p-a;float e=dot(c,d)/dot(c,c);\n //e=min(e,1.);//makes it an ils.\n //e=max(e,0.);//ils other way around\n e=clamp(e,0.,1.);//makes it a line segment\n return length(d-c*e);}*/\n\n//return distance.y of [u] to line with derivative [d] you do the offset around this function.\nfloat lineY(vec2 u,float d){return u.x*d-u.y;}\n//return distance.y of [u] to unit circle.\nfloat circleY(vec2 u){return sqrt(1.-(u.x*u.x))-u.y-1.;}\n\n\n#define frame(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nvoid mainImage( out vec4 O, in vec2 U ) {\nvec2 u=frame(U),m=frame(iMouse.xy),n=frame(iMouse.zw);\n if(iMouse.z<=0.){m=vec2(.5)+.4*vec2(sin(iTime),sin(iTime)+cos(iTime*.61));}//idle mouse override\n vec3 c=vec3(1);//color accumulator\n vec2 v=abs(u-.5);\n u.x=fract(u.x);\n //2 circle parameters  .z=radius; .xy=centerPos. set by m:\n vec3 c1=vec3(0,0,m.x);//.xy must be ==0., so the whole thing must be shoifted. otherwise too complex?\n vec3 c2=vec3(1,1,1.-m.y);//cicle.xyz .z=radius\n\n //constraining circles so they are smoothstep-like\n const float maxT=inverseLipschitz;//this also sets the max lipschitz constant.   \n c1.z=clamp(c1.z,smallestR,1.-smallestR-maxT);//enforce a minimum radius so the left  border is continuous\n c2.z=clamp(c2.z,maxT,1.-c1.z-maxT);//right circle gets pushed small by left circle\n  //...with derivative==lipschitzConstant=1./maxT\n \n  float grid=(min(fract(u.x),fract(u.y))*.1);//lazy grid\n\n vec2 o1=vec2(0,c1.z);//an offset for the whole thing\n vec2 o2=vec2(0,c2.z);//an offset for the whole thing\n   \n \n //if(c1.z+c2.z<1.){//if there is a tangent to calculate\n  u.x=clamp(u.x,0.,c2.x);//this clamp makes the error cathhing branches obsolete.\n    \n  c.g=min(length(u-c1.xy-o1)-c1.z,length(u-c2.xy+o2)-c2.z);\n  float dd=length(c1.xy-c2.xy);\n  float x=(dd*dd-c1.z*c1.z+c2.z*c2.z)*.5/dd;\n  c.b=length(u)-c1.z+c2.z;\n  c2.z=-c2.z;//toggle to inner crossing tancents by negating second radius.\n  c2.xy-=o1+o2;\n  vec3 ccc=   CircleOuterTangents(u,c1,c2);\n    \n  //2 tangentToCircle Intersections. (tangents only touch, duh!)\n  vec2 i1=-vec2(ccc.x,ccc.y)*ccc.z;                //left  tangent point\n  vec2 i2=-vec2(ccc.x,ccc.y)*ccc.z*c2.z/c1.z+c2.xy;//right tangent point\n //show the 2 points where tangent touches 2 circles in red:\n  c.r=        length(u-i1-o1)-.03;\n  c.r=min(c.r,length(u-i2-o1)-.03);\n  vec2 d=i2-i1;//derivative of tangent\n  c.b=-lineY(u-vec2(i1),d.y/d.x);//distance.y to tangent\n       if(u.x<i1.x)c.b=circleY(-vec2(u.x,u.y)/c1.z)*c1.z+c1.z;  //left of left red circle\n  else if(u.x>i2.x)c.b=circleY(vec2(u.x-c2.x,-u.y+c2.y)/c2.z)*c2.z+c2.z;//right of right red ciecle\n// }\n c.b-=o1.y;\n //if(c.b!=0.)c.b=fract(c.b)/(abs(floor(c.b)-fract(c.b)));\n c.b=fract(c.b);\n //here c.b is a smooth alternative to smoothste(), smoothCos() or sawCos()   \n c.rg=plot(c.rg);\n c.b*=.9;\n u=fract(u);\n float box=smoothstep(.1,-.1,abs(max(v.x,v.y)-.5)); \n c.rg+=vec2(box)*.5;\n c+=vec3(grid)*.1;\n O=vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSBWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1236, 1327, 1359, 1359, 1457], [1459, 1609, 1662, 1662, 1885], [2247, 2342, 2370, 2370, 2388], [2389, 2432, 2454, 2454, 2488], [2553, 2553, 2594, 2594, 4982]]}
{"id": "MsSfD3", "name": "uneven T L corner, laplachian", "author": "ollj", "description": "mouse.xy does things.\n\ni know there are reasonable specializations here, but i do not care, for now.", "tags": ["t", "bisymmetry", "laplachian"], "likes": 4, "viewed": 750, "date": "1502438870", "time_retrieved": "2024-06-20T19:00:04.922583", "image_code": "//only one domain stretches, more values cancel out.\n#define mode 3\n\n//mode==0 iMouse.xy sets 2 straight lengths, distance to vec2(0)==1\n//mode==1 iMouse.y  sets 1 straight length , distance to vec2(0)==1\n//mode==2 iMouse.y  sets 1 straight length , distance to vec2(0)==mouse.y\n//mode==3 iMouse.y  sets 1 straight length , distance to vec2(0)==mouse.y\n\n//difference between mode2 and mode 3 is \n//the end end of the cane is at mouse position\n//mode2 is simpler, mode 3 is more intuitive\n\n/*\nAfter days of silly i learned a new trick:\n\nif(you have a min() somewhere:\n- that means there is a \"green line\"\n- ...where the distance to 2 impicit shapes is (almost) equal.\n- splitline() caculates that green line, it is a differential; a-b;\n- This differential can be used as a branch condiion. if(a-b>0.)\n- ... or with heuristics: if(abs(a-b)<epsilon)\n- This branch can be made branchless.\n- This usually does not reduce much, but it DOES reduce a little bit, \n- ...utilizing a bit more symmetry in jj()\n\n- It sure looks a lot more impressive than it really is.\n- but really, this has applications in trickier shapes\n- and shapes that are min() of more shared factors.\n\n- This goes towards an approach that might use more memory,\n- ... and that likely performs faster on newer hardware.\n*/\n\n\n#define frame(u) (u-.5*iResolution.xy)*25./iResolution.y\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//above is special case that can include the sat() generalization below +u.x;\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nfloat sat(float a,vec2 m){    \n a=.5*(sign(a)+m.x)*a+m.y;\n a=(sign(2.-a)+1.)*(a-2.)+2.; \n return a*.5;}\nfloat sat(float a){return sat(a,vec2(1));}//return clamp(a,0.,1.); \n\n\n#define dd(a) dot(a,a)\n/*\nfloat jj(vec2 u,vec4 m){\n if(u.x>0.&&u.y<0.)return abs(length(u)-1.);\n //lower right quadrant is much simpler, varrants the above shortcut\n //above length() is wrapped by abs(), can not simplify anyways.\n float a=mStretch((u.y*2.-m.y),m.y)*.5,//one     relevant shape remains\n b=mStretch((u.x*2.+m.x),m.x)*.5,      //another relevant shape remains\n s=sign(b*b+u.y*(u.y+2.)-a*a-u.x*(u.x-2.))+1.;//see splitline()\n //s==sign(difference between 2 squared distances to 2 shapes)+1.\n vec2 c=vec2(u.x-1.,a),d=vec2(b,u.y+1.);//2* shape distances.xy\n return length(d+.5*s*(c-d));} //length() is delayed till the end.\n//see https://www.shadertoy.com/view/XsSBDc\n//special case of jj() where m.x=0.;\nfloat jj1(vec2 u,vec4 m){\n if(u.x>0.&&u.y<0.)return abs(length(u)-1.);\n //lower right quadrant is much simpler, varrants the above shortcut\n //above length() is wrapped by abs(), can not simplify anyways.\n float a=mStretch((u.y*2.-m.y),m.y)*.5,//one     relevant shape remains    \n s=sign(u.y*(u.y+2.)-a*a+2.*u.x)+1.;//see splitline()\n vec2 c=vec2(u.x-1.,a),d=vec2(u.x,u.y+1.);//2* shape distances.xy\n return length(d+.5*s*(c-d));} //length() is delayed till the end.\n//m.x sets distance to vec2(0); m.y sets height;\nfloat jj2(vec2 u,vec4 m){\n if(u.x>0.&&u.y<0.)return abs(length(u)-m.x);\n float i=mStretch((u.y*2.-m.y),m.y)*.5;\n float a=dd(vec2(u.x-m.x,i)),b=dd(vec2(u.x,u.y+m.x));\n a-=b;return sqrt(b+.5*(1.-sign(a))*a);}//return sqrt(min(a,b))\n////see https://www.shadertoy.com/view/XsSBDc\n\n\n//splitline() visualizes a gree line \n//...where distances to 2 shapes is roughlty equal.\nfloat splitline(vec2 u,vec4 m){\n float a=dd(vec2(u.x-1.,mStretchP(u.y,m.y)));//one shape\n float b=dd(vec2(mStretchM(u.x,m.x),u.y+1.));//another shape\n return mStretchM(u.x,m.x)*mStretchM(u.x,m.x)+u.y*(u.y+2.) //squared distance\n       -mStretchP(u.y,m.y)*mStretchP(u.y,m.y)-u.x*(u.x-2.);}//minus squared distance\n\n//splitline1() is , splitline() special case where m.x=0;\n//...where distances to 2 shapes is roughlty equal.\nfloat splitline1(vec2 u,vec4 m){m=abs(m);//m.x=0.;\n float a=mStretch((u.y*2.-m.y),m.y)*.5;;//one shape\n return 2.*(u.y+u.x)+u.y*u.y-a*a;}\n*/\n\n#define modeT\n\nfloat TT(vec2 u,vec4 m){\n #ifdef modeT\n float a=dd(vec2(mStretch (u.x,m.x),u.y));\n #else\n float a=dd(vec2(mStretchM(u.x,m.x),u.y));\n #endif\n float b=dd(vec2(u.x,mStretchM(u.y,m.y)));\n //return sqrt(min(a,b));}\n a-=b;return sqrt(+b+.5*a*(1.-sign(a)));}\n\nfloat TTb(vec2 u,vec4 m){\n #ifdef modeT\n float a=dd(vec2(mStretch (u.x,m.x),u.y));\n #else\n float a=dd(vec2(mStretchM(u.x,m.x),u.y));\n #endif\n float b=dd(vec2(u.x,mStretchM(u.y,m.y)));\n float z=5.;\n return 1.-(abs(a-b))/length(m.xy);\n //if(abs(a-b)>1.) return 1.; return 0.;\n}\n\nfloat TT1(vec2 u,vec4 m){\n m.y=m.x;\n #ifdef modeT\n float a=dd(vec2(mStretch (u.x,m.x),u.y));\n #else\n float a=dd(vec2(mStretchM(u.x,m.x),u.y));\n #endif\n float b=dd(vec2(u.x,mStretchM(u.y,m.x)));\n //return sqrt(min(a,b));}\n a-=b;return sqrt(+b+.5*a*(1.-sign(a)));}\n\n\nvoid mainImage(out vec4 O,in vec2 U){\n vec2 u=frame(U); \n vec4 m=vec4(frame(iMouse.xy),frame(iMouse.zw));\n if(iMouse.z<0.)m.xy=(vec2(sin(iTime),cos(iTime*1.61))*.5+.5)*9.;\n u.y-=9.;\n m.y-=9.;\n m=abs(m);\n float r=TT(u,m);\n float g=TTb(u,m);//abs(splitline1(u,m));\n\n r=fract(r-.2);\n u.x=fract(u.x)*.3;\n g*=(sin(iTime*3.)*.5+.5);\n vec3 c=vec3(r,g,u.x);\n  \n O= vec4(c,1);\n}\n\n\n/*\nthe BISYMETRY PRINCIPLE: v2\n- In a quest to increase symmetry for performance and modular shaders. (in contextual biases)\n- - utilize  https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - utilize linear-algebra-deformed mirror borders that define branches.\n- - Only write atomic special cases and transformations, \n- - ...to construct general functions from.\n- - Instead of writing a general function, \n- - ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- - this way general functions can be made into special \"shortcut\" functions more easily.\n- - this way special functions can more easily be extended, generalized.\n...\n- it appears the \"ideal bisymmetrically optimized function looks something like this:\nfloat demo(vec2 u,vec4 m){//u= uv fragment position; m=iMouse.xyzw both likely transformed\n u.x=abs(u.x-1.); u.y=-u.y*.5; //symmetry modifiers are likely \"outsourced\"\n float a=sign(m.x-1.)+1.;\n float b=sign(m.y+1.)+u.x;\n float c=sign(m.z+m.x)-m.y;\n float c=-sign(m.z-u.x);\n //above are all sign-factors, below is the final binomial, both rarely are shared subroutines.\n return u.x*(a+b)*(c+2.)*d*0.5-u.y//the *.5 and -u-y can likely be \"outsourced\"\n}\n- how you transform binomials and branches depends on the bias from your context.\n- in general, it makes sense to delay sqrt() or length() as much as possible.\n- ... while also keeping brnches that are shortcuts \n- ... eg: usually abs(length()) begs to be a shortcut.\n...\n- this whole PRINCIPLE screams FRACTAL and SUPERPRIM ! \n- - https://www.shadertoy.com/results?query=superprim\n- this PRINCIPLE more easily delays sqrt() or length() till the end of a function, \"outsource\"able\n\nHOW TO\n- rearrange your branches so that sqrt() or length() is delayed as much as possible.\n- abs(length()) can not be delayed, therefore it may as well be treated as a shortcut.\n- ... meaning, if(your shape contains abs(length())) that branch stays as if() branch!\n- all other brahcnes usually end up being equally omplex trees of equally complex branches.\n- in that case, an openCL coders eyes open to reveal how to make long pipelines:\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- transform the sum into binominals of precalculated variabls, that make sense in the context.\n- - this is \"ultimate code golf\", as the best soluion depends on the functions context.\n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n...\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to sign(a)*sign(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSfD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1795, 2016, 2042, 2042, 2119], [2120, 2120, 2139, 2139, 2162], [2213, 4372, 4396, 4396, 4623], [4625, 4625, 4650, 4650, 4900], [4902, 4902, 4927, 4927, 5164], [5167, 5167, 5204, 5204, 5536]]}
{"id": "MtscRM", "name": "euclidean cubic bezier", "author": "ollj", "description": "mouse.xy visualizes a point and nearest points on the quadratic spline.\nsegments of different  background colors tell which one of the 3 points is closest.\n\nmy take on \"distance to cubic spline/bezier\"\nhttps://www.shadertoy.com/view/MdXBzB", "tags": ["bezier", "spline", "cubic", "euclidean", "fwidth", "analysis"], "likes": 2, "viewed": 791, "date": "1504144999", "time_retrieved": "2024-06-20T19:00:05.934287", "image_code": "//grandparent: https://www.shadertoy.com/view/ltXSDB \n// by Adam Simmons, T21 and others\n//parent:      https://www.shadertoy.com/view/MdXBzB\n// by Tom'2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nMouse.xy visualizes a point and nearest points on the quadratic spline.\nThe Segments of different  background colors tell which one of the 3 points is closest.\nThe Polynomial on the left shows root solving, \n which has 3 local extrema, one for each background-segment.\n 2 local minima define nearest points on the bezier.\nThe 3rd root is a local maxima (an antiderivative is displayed), it can be ignored.\n due to getting the SHORTEST EUCLIDEAN LENGTH to a spline. \n The required root solving simplifies to a polinimial of -1 degree less.\nThe segment-border-cases are also nice 2nd derivative border cases.\nBut we do not care for the 2nd derivative here. \n This could nicely turn the borders into isolines|splines.\n*/\n\n//1 <- draw lines for visualization\n//2 <- do a 2nd pass for \"better\" visualisation lines\"\n#define LinesToNearest 1\n\n//show local minima of cubic solver\n#define PlotPolinomial 1\n\n//Define background colors of 3 segments, showing nearest. \nconst vec3 rcol0 = vec3(1,1,0);\nconst vec3 rcol1 = vec3(0,1,1);//3rd color is differential of the other 2\n\n/*\nmy take on \"distance to cubic spline/bezier\"\n\nbetter compatibility, no longer using arrays.\nfixed some silly parts,removed stuff that was not going anywhere any day soon.\n\nIhis is me than code golfing and namespace changing. \nIt is utilizing \"bisymmetry\" principle mostly for performance.\n\nWhere https://www.shadertoy.com/view/MdXBzB is hunting ghosts\n...in an attempt to prove that ghosts do not exist which is NOT how analysis works!\nMy bisymmetry approach simply does not care for nonexisting cases or unused values.\nMy bisymmetery principle is concerned with undefined,arbitiary, cases.\n\nlogical extension is to split any more complex spline into quadradic beziers, \nto calculate a min() distance to them.\n2 bezier ControlVectors are where the 2ndDerivative =0\n3rd ControlVectors is line_line_intersection of the tangents at other 2 CV.\nif(point is [outside of the triangle of the ControlVectors])Distance==spheres at the 2CV.\n*/\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\nfloat sumv(vec2 a){return a.x+a.y;}\nfloat sumv(vec3 a){return dot(vec3(1),a);}\n#define miv(a) -mav(-(a))\n//#define u2(a) ((a)*2.-1.)\n//#define u5(a) ((a)*.5+.5)\n//seesaw wave\n//#define saw(a) a=abs(u2(fract(a)))\n#define dd(a) dot(a,a)\n//perpendicular ==90deg rotation, relevant for distance to line\nvec2 perp(vec2 a){return vec2(-a.y,a.x);}\n//return [perpendicular dot product], relevant for distance to line\nfloat dotp(vec2 a,vec2 b){return dot(perp(a),b);}\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n//#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define sat(a) clamp(a,0.,1.)\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\n//v0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//return squared distance of [u] to line_segment, from [a] to [b]\nv0 segment(v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}\n/*\n#define grid(u) mav(abs(u2(fract(u))))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n/**/\n//return distance of p to line segment from a to b\n\n//draw dual-domain-cubic y=f(x) function for visualisation; u=fragment; m=mouse.xy\nfloat plotDistance(vec2 U,vec2 m,vec2 a,vec2 b,vec2 c){\n vec2 p=U/iResolution.x;p=vec2(p.x*8.-1.,p.y*32.-2.);\n float w=p.y-dd(a-m+(2.*(b-a)+(a-b*2.+c)*p.x)*p.x);\n return smoothstep(fwidth(w),.0,abs(w));}//here fwidth() is good enough estimation.\n\n//special cubic solver, skips 3rd solution==n-m;\nvec2 solveCubic2(vec3 a){float p=a.y-a.x*a.x/3.,p3=p*p*p,q=a.x*(2.*a.x*a.x-9.*a.y)/27.\n +a.z,d=q*q+4.*p3/27.;if(d>.0){vec2 x=(vec2(1,-1)*sqrt(d)-q)/2.;\n  return vec2(sumv(sign(x)*pow(abs(x),vec2(1./3.)))-a.x/3.);}\n float v=acos(-sqrt(-27./p3)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);\n return vec2(m+m,-n-m)*sqrt(-p/3.)-a.x/3.;}//3rd solution would be= vec2(...,n-m)*...\n\n//return distance to cubic bezier; l=matrix of 1 or 2 nearest points on bezier.\n//r=local minima of solveCubic2(), to select the correct l.\nfloat Bezier2(vec2 A,vec2 B,vec2 C,vec2 p,out mat2 l,out vec3 r){  \n //B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)));//catch 3 colinear control vectors\n vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p,\n t=solveCubic2(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b)),\n s=vec2(dd(d+(c+b*t.x)*t.x),dd(d+(c+b*t.y)*t.y));r=sqrt(s.xyx);r-=miv(r);\n l=mat2(vec2((c+b*t.x)*t.x+A),vec2((c+b*t.y)*t.y+A));return sqrt(miv(s));}\n\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 p=(2.*U.xy-iResolution.xy)/iResolution.y;\n vec2 m=mix((2.*iMouse.xy-iResolution.xy)/iResolution.y,\n vec2(cos(iTime),0),step(iMouse.z,.0));\n float fsaa=2./iResolution.y;//2 pixel wide AntiAliasing/Blur.\n    \n //set bezier-quadratic control_vector inputs\n vec2 A=vec2(.3,-.9),C=-A,B=vec2(-1);\n //Get signed distance to bezier curve and some other visualisation stuff.\n vec3 rf;mat2 rt;float bez=Bezier2(A,B,C,p,rt,rf);\n     \n //O distance isolines\n rf=sat((1.-rf*.5/fsaa));\n vec3 c=(rcol0*rf.y+rcol1*rf.x)/sumv(rf);\n O=vec4(c*.6,1);//distance field all color background    \n //O distance isolines\n O*=1.+smoothstep(.02+fsaa*28.,.02,abs(fract(22.*bez+.5)-.5))*.5;\n //bezier curve\n O=mix(vec4(1),O,smoothstep(-.01,.01,bez-.02) ); \n //O cubic polynomial:\n #if PlotPolinomial>0\n  O=max(O,plotDistance(U,m,A,B,C));   \n #endif\n    \n #if LinesToNearest>0\n   //2nd pass on the hardest function for slighly better lines, not worth it.\n  #if LinesToNearest>1\n   Bezier2(A,B,C,m,rt,rf);\n  #endif\n  //root points to mouse cursor:\n  float pd=min(segment(p,m,rt[0]),segment(p,m,rt[1]));    \n  O=mix(O,vec4(1),(1.-smoothstep(.002,.002+fsaa,sqrt(pd)))*.5);\n #endif\n //O gamma correct\n O=sqrt(O);\n}\n\n/*\n// Find the signed distance from a point to a bezier curve without clamping\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out vec3 r){\n //B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)));//prevent 3 colinear points\n vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p;\n vec3 t=solveCubic(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b));\n vec2 tt=vec2(dd(d+(c+b*t.x)*t.x),dd(d+(c+b*t.y)*t.y));\n vec3 rd=sqrt(vec3(tt            ,dd(d+(c+b*t.x)*t.x)));\n r=rd-miv(rd);return sqrt(miv(tt));\n}\n //O Make negative sign slightly lighter\n //O=mix(O,vec4(1),(-s+1.)*.05);//broken\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtscRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1312, 2375, 2388, 2388, 2409], [2410, 2410, 2423, 2423, 2450], [2451, 2451, 2464, 2464, 2497], [2498, 2498, 2517, 2517, 2533], [2534, 2534, 2553, 2553, 2576], [2733, 2797, 2815, 2815, 2838], [2839, 2907, 2933, 2933, 2956], [3101, 3307, 3334, 3334, 3380], [4022, 4105, 4160, 4160, 4308], [4352, 4401, 4426, 4426, 4724], [4768, 4908, 4973, 5055, 5309], [5312, 5312, 5350, 5350, 6536]]}
{"id": "MtscRn", "name": "Good Morning, good nightv2", "author": "edapx", "description": "the sun goes up and down", "tags": ["distancefield"], "likes": 3, "viewed": 81, "date": "1503224995", "time_retrieved": "2024-06-20T19:00:05.934287", "image_code": "float circleSmooth(in vec2 st, in vec2 pos, in float begin, in float end) {\n    float pct = 0.0;\n    pct = 1. - smoothstep(begin, end, distance(st, pos));\n    return pct;\n}\n\nfloat rectangleGradientBottom(in vec2 st, in vec2 origin, in vec2 dimensions, float smoothness) {\n    vec2 center = step(origin, st); // it is actually the bottom left cornter\n    float pct = center.x * center.y;\n    vec2 full = step(1.0 - origin - dimensions, 1.0 - st);\n    float height = origin.y+dimensions.y;\n    pct *= full.x * full.y;\n    pct *= smoothstep(height, origin.y+smoothness,st.y);\n    return pct;\n}\n\n//  Function from Iñigo Quiles \n//  www.iquilezles.org/www/articles/functions/functions.htm\nfloat parabola( float x, float k ){\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse / iResolution.xyzz;\n    vec2 fakeMovent = vec2(1.0-abs(sin(iTime*0.2)), parabola(abs(sin(iTime*0.2)),0.6));\n    m.xy = fakeMovent;\n    vec3 color = vec3(0.1, 0.4, 0.9);\n    color += vec3(0.9-m.y,0.6-uv.y, -(1.0-m.y));\n    \n    uv.x *= iResolution.x / iResolution.y;\n    m.x *= iResolution.x / iResolution.y;\n    vec2 recPos = vec2(0.0, 0.0);\n        \n    // kind of sun, with a lot of imagination\n    color.rg += circleSmooth(uv, vec2(m), 0.05, 0.15);\n    float turnOffSky = smoothstep(0.25, 0.27,m.y);\n    color*= turnOffSky;\n    // earth\n    vec3 earth = vec3(vec2(rectangleGradientBottom(uv, recPos, vec2(2.0, 0.3), 0.16)), 0.0);\n    earth.r += 1.0 -m.y;\n    color += earth;\n    float turnOffEarth = smoothstep(0.09, 0.25,m.y);\n    color*= turnOffEarth;\n    \n  \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtscRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 75, 75, 172], [174, 174, 271, 271, 590], [592, 685, 720, 720, 758], [760, 760, 817, 817, 1680]]}
{"id": "MtXyzn", "name": "Noisy Sphere Distortion", "author": "dust", "description": "More fun with the noise function shared in https://www.shadertoy.com/view/XsSBDt\nClick and drag to explore different noise configurations.", "tags": ["procedural", "3d", "raymarching", "noise"], "likes": 0, "viewed": 113, "date": "1503554904", "time_retrieved": "2024-06-20T19:00:06.400826", "image_code": "// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\nfloat BaseSphereDF(vec3 coord, float r)\n{\n    return length(coord) - r;\n}\n\nfloat SphereDF(vec3 coord, float r, vec3 sphPos)\n{\n    coord -= sphPos;\n    coord = QtnRotate(coord, normalize(vec4(normalize(vec3(0.0, 1.0, 1.0)) * sin(iTime) * 4.0, cos(iTime) * 4.0)));\n    float noise = fract(length(coord / cos(1e4)) * sin(sin((length(iMouse) + 0.01) * 0.01)));\n    float noise2 = fract(length(coord / cos(2e4)) * sin(sin((length(iMouse) + 0.02) * 0.03)));\n    float noise3 = fract(length(coord / cos(3e4)) * sin(sin((length(iMouse) + 0.01) * 0.06)));\n    return max(length(coord * vec3(noise / noise2, noise2, noise3 / noise2)) - r, BaseSphereDF(coord, r * 1.2));\n}\n\nvec3 GetNormal(vec3 samplePoint, float eps, vec3 sphPos, float r)\n{\n    float normXA = SphereDF(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z), r, sphPos);\n    float normXB = SphereDF(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z), r, sphPos);\n\n    float normYA = SphereDF(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z), r, sphPos);\n    float normYB = SphereDF(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z), r, sphPos);\n\n    float normZA = SphereDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps), r, sphPos);\n    float normZB = SphereDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps), r, sphPos);\n\n    return normalize(vec3(normXA - normXB,\n                          normYA - normYB,\n                          normZA - normZB));\n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float eps = 0.0001;\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 sphPos = vec3(0.0, 0.0, 4.0);\n    for (int i = 0; i < 255; i += 1)\n    {\n        vec3 eyePos = vec3(0.0, 0.0, -3.0);\n    \tvec3 rayVec = eyePos + (rayDir * currRayDist);\n        float sphDist = SphereDF(rayVec, 2.0, sphPos);\n        if (sphDist < eps)\n        {   \n            float nDL = dot(GetNormal(rayVec, eps, sphPos, 2.0), \n                            normalize(vec3(1.0, 1.0, -1.0)));\n            fragColor = vec4(cos(sin(sin(iTime))), sin(cos(sin(iTime))), nDL, 1.0) * nDL;\n            fragColor.w = 1.0;\n            return;\n        }\n        \n        currRayDist += sphDist;\n    }\n    \n\tfragColor = vec4(0.8, 0.8, 0.8, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXyzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 46, 73, 73, 115], [117, 159, 198, 198, 421], [423, 499, 535, 535, 632], [634, 634, 675, 675, 707], [709, 709, 759, 759, 1295], [1297, 1297, 1364, 1364, 2082], [2084, 2084, 2140, 2140, 2266], [2268, 2268, 2325, 2325, 3089]]}
{"id": "XdBBzd", "name": "V - Overlapping Triangle Shutter", "author": "isak", "description": "Overlapping triangle shutter. Animated repeated opening and closing of blades ", "tags": ["triangle", "shutter", "overlapping"], "likes": 5, "viewed": 155, "date": "1501611722", "time_retrieved": "2024-06-20T19:00:06.916093", "image_code": "#define PI 3.1415926535\n\nvec2 orto(vec2 pv)\n{\n    return normalize(vec2(-pv.y, pv.x));\n}\n\nvec2 rot(vec2 p, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec2(ca*p.x - sa*p.y, ca*p.y + sa*p.x);\n}\n\nfloat sCircle(vec2 p, float r)\n{\n    float ds = 0.01*r;\n    return smoothstep(-ds, ds , r*r - dot(p,p));\n}\n\n\nfloat sTriangle(vec2 p, vec2 p1, vec2 p2, vec2 p3)\n{\n    float ds = 0.005;\n    vec3 dsv = vec3(ds, ds, ds);\n    vec3 pev = vec3(dot( orto(p2 - p1), p - 0.5*(p1 + p2)), \n                   \tdot( orto(p3 - p2), p - 0.5*(p2 + p3)),\n        \t\t\tdot( orto(p1 - p3), p - 0.5*(p3 + p1)));\n    vec3 S = smoothstep(dsv, -dsv, pev);\n    return S.x*S.y*S.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.2;\n  \n    // Colors\n\tvec3 blue  = vec3(65.0, 105.0, 225.0)/255.0;\n    vec3 white = vec3(1.0, 1.0, 1.0); \n    vec3 gray = 0.8*vec3(0.1, 0.1, 0.1);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 brown = 0.1*vec3(255.0, 128.0, 0.0)/255.0 + 0.05*white;\n    \n    // Parameters\n\tint N = 27;  \t\t// Change this to for example 100 ;)    \n    float L = 1.0;\n    float sft = 0.1;\n    \n    // Derived Parameters\n    float alpha = PI/float(N);\n    float dw = L*tan(alpha);\n    float R = L - sft;\n    vec2 shift = vec2(0.0, sft);\n    \n    // Blade reference vertices (triangle)\n    vec2 p1 = vec2(0.0, L) - shift;\n    vec2 p2 = vec2( dw, 0.0) - shift;\n    vec2 p3 = vec2(-dw, 0.0) - shift;\n  \n    // Parameterization for the animation\n    float A = 0.9;\n    float B = 1.5;\n    float st = 0.5*(A + B) + 0.5*(B-A)*tanh(4.0*sin(1.5*iTime));\n\n\n    // Shading\n    float blades = 0.0; \n    float nails = 0.0;\n    \n   \tfor (int i = 0; i < N; i++)\n    {\n        float a = 2.0*PI*float(i)/float(N);\n       \t\n        vec2 p = R*vec2(cos(a), sin(a));\n        \n        blades += sTriangle(uv, \n                            rot(p1, a + st) + p, \n                            rot(p2, a + st) + p, \n                            rot(p3, a + st) + p);\n        \n    \tnails += sCircle(uv - p, 0.025);   \n    }\n    \n    float dR = 0.1;\n    float sRing = sCircle(uv, R + dR) - sCircle(uv, R - dR);\n    //sRing = 0.0;  //uncomment to remove ring\n    \n    vec3 c = gray;\n    c += (blue - gray)*(blades - sRing*blades) + (brown)*(sRing-nails) + blue*nails  ;\n    c += 0.2*blue*(1.0 - smoothstep(+2.0, -2.0, 2.0 - dot(uv,uv)));\n    c += 0.2*blue*(1.0 - smoothstep(+0.5, -0.5, 0.5 - dot(uv,uv)));\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[25, 25, 45, 45, 88], [90, 90, 117, 117, 216], [218, 218, 250, 250, 324], [327, 327, 379, 379, 674], [677, 677, 734, 734, 2533]]}
{"id": "XdBfWc", "name": "ESM", "author": "steverock", "description": "fdsa", "tags": ["shadow"], "likes": 0, "viewed": 129, "date": "1502392744", "time_retrieved": "2024-06-20T19:00:06.916093", "image_code": "// Trying out ESM using float->vec4 encoding:\n// https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float/7237286#7237286\n\nvec4 encode32(float f) {\n    float e =5.0;\n\n    float F = abs(f); \n    float Sign = step(0.0,-f);\n    float Exponent = floor(log2(F)); \n    float Mantissa = (exp2(- Exponent) * F);\n    Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n    vec4 rgba;\n    rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n    rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);  \n    rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n    rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n    return rgba / 255.0;\n}\n\nfloat decode32(vec4 rgba) {\n    rgba *= 255.0;\n    float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0; \n    float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 )); \n    return Result;\n}\n\nfloat C = 70.0;\n\nfloat sat(float x) {\n    return min(1.0, max(0.0, x));\n}\nvec4 sat4(vec4 v) {\n    return vec4(sat(v.r), sat(v.g), sat(v.b), sat(v.a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float z = uv.y + sin(uv.x*iTime*6.2/10.0 + iTime*10.0)*0.005;\n    float d = uv.x;\n    float blockerExp = exp(C*z);\n    \n    // simulate being written to RGBA and back.\n    blockerExp = decode32(sat4(encode32(blockerExp)));\n    \n    float fragExp = exp(-C*d);\n    float r = blockerExp * fragExp;\n\tfragColor = vec4(r, r, r, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdBfWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 156, 180, 180, 705], [707, 707, 734, 734, 1064], [1083, 1083, 1103, 1103, 1139], [1140, 1140, 1159, 1159, 1218], [1220, 1220, 1277, 1277, 1653]]}
{"id": "XdjBWt", "name": "Spiral Circles redux", "author": "ajbeach2", "description": "Fork of https://www.shadertoy.com/view/ls2fDc", "tags": ["music2dcirclesspiral"], "likes": 10, "viewed": 841, "date": "1502763281", "time_retrieved": "2024-06-20T19:00:07.176498", "image_code": "#define c30 0.86602540378\n#define hm  1.33333333333\n#define grid 16.0\n#define smooth 0.02\n#define timeScale 0.2\n\n\nvec2 hex(vec2 v){\n\tfloat yc = abs(mod(v.x + floor((v.y*hm + 0.5))*(c30 / 2.0),c30) / c30 - 0.5);\n\tfloat y = floor(v.y*hm + yc);\n\tfloat x = floor(v.x/c30 + 0.5 + fract(y /  2.0))- fract(y / 2.0);\n\treturn vec2(x*c30,y /hm + 1.0/(hm * 4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wave =  texture( iChannel0, vec2(0.0,1.0)).x;\n\tfloat wave2 = texture( iChannel0, vec2(0.0,.1)).x;\n    \n\tvec2 uv = fragCoord.xy  / vec2(iResolution.y,iResolution.y);\n  \tuv.x -= .5;\n    float rt = iTime * timeScale;\n    vec2 gv = hex(uv*grid)/grid;\n    vec2 mv = gv - 0.5;\n    vec2 rv = vec2(((atan(mv.x,mv.y)/3.141526) + cos(iTime + wave2)) / 2.0, length(mv * sin(iTime + wave2)));\n    float fv = fract((rv.x- rt) * cos(gv.x /20.0) * 2.0 + rv.y * 2.0);\n    \n    float dist = length(uv - gv) * grid;\n    float dist2 = 1.0 - smoothstep(-smooth,0.0,dist - c30/2.);\n    dist += fv + wave2;\n    dist += cos(wave / 2.);\n    dist = smoothstep(0.5,0.5 + smooth,fract(dist));\n    float finCol = float(0.5);\n    finCol = mix(finCol, dist, dist2);\n\tfragColor = vec4(finCol) + vec4(cos(iTime + dist2 + wave2) + wave2, sin(fv * wave) * .5, sin(uv.x * 3.),  1.0);\n}", "image_inputs": [{"id": "XdsSDj", "previewfilepath": "https://soundcloud.com/cosmicbeats/backlash-w-retnik", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cosmicbeats/backlash-w-retnik", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjBWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[114, 114, 131, 131, 354], [356, 356, 413, 413, 1274]]}
{"id": "XdjBWV", "name": "Sugar3000", "author": "bru", "description": "A vortex of squishy, rainbow-colored blobs.", "tags": ["2d"], "likes": 9, "viewed": 173, "date": "1502249763", "time_retrieved": "2024-06-20T19:00:07.176737", "image_code": "#define PI 3.14159265358979323\n#define RAYS 11.0\n#define PROB 0.75\n#define SIZE 0.45\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st, vec2(12.5629849,78.1384))) * 41631.4232);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = fragCoord.xy / iResolution.xy - vec2(0.5, 0.5);\n\tp.x *= iResolution.x / iResolution.y;\n    float t = iTime - 10.0;\n    \n    float dist = length(p);\n    float angle = atan(p.y, p.x) + PI;\n  \n    // create, subdivide vortex\n    float angle_2 = angle * RAYS / PI + cos(dist * 15.0) * cos(t * 0.5) * (0.5 / (dist + 0.1));\n    \n    float cell_angle = mod(floor(angle_2), RAYS * 2.0);\n    float cell_dist = pow(dist, 0.6) * 10.0 - (t + 0.5) * (mod(cell_angle, 2.0) - 0.5) * (0.4 + 0.6 * random(vec2(cell_angle + 0.1)));\n\n    float s = abs(floor(cell_dist));\n    float c = length(vec2(abs(fract(angle_2) - 0.5),\n                          abs(fract(cell_dist)) - 0.5));\n    // anti-aliasing\n    float eps = 10.0 / (dist * PI * iResolution.y);\n    \n    float mask = 1.0 - smoothstep(SIZE - eps, SIZE + eps, c);\n    mask *= step(random(vec2(s, cell_angle)), PROB);\n    \n    // rainbow\n    float col_ang = cell_angle * PI / RAYS;\n\tvec3 col = cos(vec3(col_ang) + vec3(0.0, 2.0/3.0, 4.0/3.0) * PI) * 0.5 + 0.5;\n\n    // normal\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 n2 = rot * vec2(fract(angle_2) - 0.5, fract(cell_dist) - 0.5);\n    vec3 norm = normalize(vec3(n2, cos(c / SIZE * 0.5 * PI)));\n    \n    // lights\n    vec3 l1 = clamp(dot(normalize(vec3(-1.0, 0.0, 0.0)), norm), 0.0, 1.0) * vec3(0.6, 0.9, 0.95);\n    vec3 l2 = pow(clamp(dot(normalize(vec3(0.0, -1.0, 1.0)), norm), 0.0, 1.0), 16.0) * vec3(0.95, 0.9, 0.6);\n    \n\tfragColor = vec4(mix(vec3(1.0), col + 0.5 * l1 + l2, mask), 1.0);\n\n    // gamma correction\n    fragColor.xyz = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjBWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[87, 87, 111, 111, 184], [186, 186, 241, 241, 1849]]}
{"id": "XdSBDd", "name": "Beginner raymarching", "author": "ashkitten", "description": "This is my first attempt to understand raymarching. Feedback would be welcome! I'm absolutely certain I've implemented a lot of things wrongly, so feel free to point that out!", "tags": ["reflection", "raymarch", "beginner"], "likes": 4, "viewed": 610, "date": "1502675755", "time_retrieved": "2024-06-20T19:00:08.589093", "image_code": "//// Definitions\n\n#define CAMERA_SPEED 0.5\n\n#define MAX_DIST 50.0\n#define EPSILON 0.0001\n\n#define SHADOWS\n#define SHADOW_THRESHOLD 0.01\n#define SOFT_SHADOWS\n#define SHADOW_HARDNESS 50.0\n\n#define LIGHT_INTENSITY 25.0\n#define AMBIENT_LIGHT 0.05\n\n#define MAX_REFLECTIONS 5\n#define REFLECTION_THRESHOLD 0.01\n\n#define FOG\n#define FOG_DISTANCE 25.0\n#define FOG_COLOR vec3(0.2, 0.25, 0.3)\n\n#define MATERIAL_LIGHTGRAY Material(vec3(0.9, 0.9, 0.9), 0.5, 8.0, 0.4)\n#define MATERIAL_GREEN Material(vec3(0.258824, 0.956863, 0.607843), 0.8, 8.0, 0.7)\n#define MATERIAL_BLUE Material(vec3(0.258824, 0.52549, 0.956863), 0.8, 4.0, 0.4)\n#define MATERIAL_PURPLE Material(vec3(0.878431, 0.4, 1.0), 1.0, 8.0, 0.0)\n#define MATERIAL_YELLOW Material(vec3(1.0, 0.843137, 0.0), 1.0, 8.0, 0.2)\n\n//// Structs\n\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n    float reflectivity;\n};\n\nstruct MapInfo {\n    Material material;\n    // Distance of the point we got info from to the map\n    float hit;\n};\n\nstruct Ray {\n    // Origin of the ray\n    vec3 origin;\n    // Ray's direction\n    vec3 direction;\n\n    // Where the ray is aiming at\n    vec3 target;\n\n    // Current position along the ray\n    float length;\n    // Just so we don't have to calculate it multiple times ¯\\_(ツ)_/¯\n    vec3 position;\n};\n\n//// Ray initializer\n\nRay initRayToTarget(vec3 origin, vec3 target) {\n    Ray ray;\n\n    // Init ray values\n    // Calculate ray direction\n    ray.direction = normalize(target - origin);\n\n    // Start a bit away from the origin so we don't hit whatever is at the start\n    ray.origin = origin + ray.direction * EPSILON;\n\n    ray.target = target;\n    ray.position = origin;\n\n    return ray;\n}\n\nRay initRayToDirection(vec3 origin, vec3 direction) {\n    Ray ray;\n\n    // Init ray values\n    ray.direction = direction;\n\n    ray.origin = origin + ray.direction * EPSILON;\n    ray.position = origin;\n\n    return ray;\n}\n\n//// Distance functions\n\nMapInfo plane(vec3 origin, Material material) {\n    return MapInfo(material, -origin.y);\n}\n\nMapInfo sphere(vec3 origin, float rad, Material material) {\n    return MapInfo(material, length(origin) - rad);\n}\n\nMapInfo box(vec3 origin, vec3 size, Material material) {\n    return MapInfo(material, length(max(abs(origin) - size, 0.0)));\n}\n\n//// Distance operations\n\nMapInfo opUnion(MapInfo o1, MapInfo o2) {\n    // min(o1, o2)\n    if (o1.hit < o2.hit) return o1;\n    return o2;\n}\n\nMapInfo opSubtract(MapInfo o1, MapInfo o2) {\n    // max(-o1, o2)\n    if (-o1.hit > o2.hit) return MapInfo(o1.material, -o1.hit);\n    return o2;\n}\n\nMapInfo opIntersect(MapInfo o1, MapInfo o2) {\n    // max(o1, o2)\n    if (o1.hit > o2.hit) return o1;\n    return o2;\n}\n\n//// The main mapping function\n\nMapInfo map(vec3 origin) {\n    // red plane at origin\n    MapInfo mapInfo = plane(origin, MATERIAL_LIGHTGRAY);\n    // blue sphere at 1.5, 1.0, 1.5 with radius 1.0\n    mapInfo = opUnion(mapInfo, sphere(origin + vec3(1.5, 1.0, 1.5), 1.0, MATERIAL_BLUE));\n    // green box at -1.5, 1.0, 1.5 with size 1.0 x 1.0 x 1.0\n    mapInfo = opUnion(mapInfo, box(origin + vec3(-1.5, 1.0, 1.5), vec3(1.0), MATERIAL_GREEN));\n    mapInfo = opUnion(mapInfo, opSubtract( // subtract sphere from box\n        sphere(origin + vec3(-1.5, 1.0, -1.5), 1.2, MATERIAL_PURPLE),  // purple sphere at -1.5, 1.0, -1.5 with radius 1.2\n        // purple box at -1.5, 1.0, -1.5 with size 1.0 x 1.0 x 1.0\n        box(origin + vec3(-1.5, 1.0, -1.5), vec3(1.0), MATERIAL_PURPLE))\n    );\n    mapInfo = opUnion(mapInfo, opIntersect( // intersect sphere with box\n        box(origin + vec3(1.5, 1.0, -1.5), vec3(1.0), MATERIAL_YELLOW), // yellow box at 1.5, 1.0, -1.5 with size 1.0 x 1.0 x 1.0\n        // yellow sphere at 1.5, 1.0, -1.5 with radius 1.2\n        sphere(origin + vec3(1.5, 1.0, -1.5), 1.2, MATERIAL_YELLOW))\n    );\n    return mapInfo;\n}\n\n//// Raymarching functions\n\nvec3 calcNormal(vec3 position) {\n    // Step around the point and see how far we are from the map at each position\n    // and do some math to figure out what the normal is\n    // I use a value of 0.02 because I find that's the best balance between accuracy and\n    // avoiding those nasty rings on some objects\n    vec2 eps = vec2(0.0, 0.005);\n    return normalize(vec3(\n        map(position + eps.yxx).hit - map(position - eps.yxx).hit,\n        map(position + eps.xyx).hit - map(position - eps.xyx).hit,\n        map(position + eps.xxy).hit - map(position - eps.xxy).hit\n    ));\n}\n\nMapInfo trace(inout Ray ray) {\n    while(distance(ray.position, ray.origin) < MAX_DIST) {\n        // Get info about our position in relation to the map\n        MapInfo mapInfo = map(ray.position);\n        // If we hit something, return the info about our position on the map\n        if(mapInfo.hit < EPSILON) return mapInfo;\n\n        // Step forward along the ray, as far as our distance to the map\n        ray.position += ray.direction * mapInfo.hit;\n    }\n    // Return fog if we didn't hit anything\n    return MapInfo(Material(FOG_COLOR, 0.0, 0.0, 0.0), 1.0);\n}\n\nfloat softshadow(inout Ray ray, float softness) {\n    // While we're not past the target, do the stuff\n    // Subtract EPSILON * 2 so we don't get close enough to the original object to trigger the shadow\n    float penumbra = 1.0;\n    while(distance(ray.origin, ray.position) < distance(ray.origin, ray.target) - EPSILON * 2.0) {\n        // Get info about our position in relation to the map\n        MapInfo mapInfo = map(ray.position);\n        // If we hit something, make the color black (shadow)\n        if(mapInfo.hit < EPSILON) return 0.0;\n\n        #ifdef SOFT_SHADOWS\n            penumbra = min(penumbra, softness * mapInfo.hit / distance(ray.position, ray.target));\n        #endif\n\n        if(mapInfo.hit > SHADOW_THRESHOLD) ray.position += ray.direction * mapInfo.hit;\n        // Move a bit closer to the target\n        else ray.position += ray.direction * SHADOW_THRESHOLD;\n    }\n    // If we don't hit anything, the point is not in shadow so the shadow multiplier is 1.0\n    return penumbra;\n}\n\n//// Main function\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //// Setup the viewport\n    // Screen coords go from -1.0 to 1.0\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    // Account for screen ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    //// Setup the camera\n    // Init camera 5.0 up, rotating in a circle, looking at 0.0, 0.0, 0.0\n    // Axes are flipped here I guess? Note the -vec3s\n    Ray cameraRay = initRayToTarget(-vec3(\n        sin(iTime * CAMERA_SPEED) * 5.0,\n        5.0,\n        cos(iResolution * CAMERA_SPEED) * 5.0), -vec3(0.0, 0.0, 0.0)\n    );\n    // Convert to screen coords\n    // Global up direction\n    vec3 globalUp = vec3(0.0, 1.0, 0.0);\n    // Right direction in relation to the camera\n    vec3 cameraRight = normalize(cross(globalUp, cameraRay.origin));\n    // Up direction in relation to the camera\n    vec3 cameraUp = cross(cameraRay.direction, cameraRight);\n    // Set the camera ray direction to point from the screen coordinate to our target\n    cameraRay.direction = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraRay.direction);\n\n    vec4 reflections[MAX_REFLECTIONS + 1];\n\n    // Background color\n    float reflectivity = 1.0;\n    for(int i = 0; i <= MAX_REFLECTIONS; i++) {\n        // Trace the ray's path\n        MapInfo mapInfo = trace(cameraRay);\n\n        // If the camera ray hit something\n        if(mapInfo.hit < EPSILON) {\n            //// Lighting\n\n            // Setup the light source\n            // Init light source at 5.0, 5.0, 5.0\n            // Again, axes need to be flipped, note the -vec3\n            Ray lightRay = initRayToTarget(-vec3(5.0, 5.0, 5.0), cameraRay.position);\n\n            #ifdef SHADOWS\n                // Trace shadows\n                float shadow = softshadow(lightRay, SHADOW_HARDNESS);\n            #else\n                float shadow = 1.0;\n            #endif\n\n            // Light stuff\n            // Calculate the normal of the position on the map\n            vec3 normal = calcNormal(cameraRay.position);\n            // Light fades by the inverse square of distance\n            float distanceFade =  LIGHT_INTENSITY / pow(distance(lightRay.origin, lightRay.target), 2.0);\n            // Multiply diffuse by shadow and distance fade\n            float diffuse = max(0.0, dot(-lightRay.direction, normal))\n                * mapInfo.material.diffuse * shadow * distanceFade;\n            // Specular lighting factor\n            float specular = pow(diffuse, mapInfo.material.specular);\n\n            // Get color from map info\n            vec3 hitColor = mapInfo.material.color;\n\n            // Add lighting values\n            hitColor *= diffuse + specular + AMBIENT_LIGHT;\n\n            #ifdef FOG\n                // Add fog\n                float fogAmount = 1.0 - exp(-max(distance(cameraRay.origin, cameraRay.position) - FOG_DISTANCE, 0.0) * 0.15);\n                hitColor = mix(hitColor, FOG_COLOR, fogAmount);\n            #endif\n\n            reflections[i] = vec4(hitColor, mapInfo.material.reflectivity);\n\n            // Set the camera ray to the reflection off the surface, and repeat\n            cameraRay = initRayToDirection(\n                cameraRay.position + normalize(reflect(cameraRay.direction, normal)) * EPSILON,\n                normalize(reflect(cameraRay.direction, normal))\n            );\n        } else {\n            reflections[i] = vec4(mapInfo.material.color, 0.0);\n            break;\n        }\n    }\n\n    fragColor = vec4(reflections[MAX_REFLECTIONS].rgb, 1.0);\n\n    for(int i = MAX_REFLECTIONS - 1; i >= 0; i--) {\n        fragColor = mix(vec4(reflections[i].rgb, 1.0), fragColor, reflections[i].a);\n    }\n\n    // Gamma correction\n    fragColor = vec4(pow(clamp(fragColor.xyz, 0.0, 1.0), vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSBDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1303, 1325, 1372, 1372, 1693], [1695, 1695, 1748, 1748, 1914], [1916, 1941, 1988, 1988, 2031], [2033, 2033, 2092, 2092, 2146], [2148, 2148, 2204, 2204, 2274], [2276, 2302, 2343, 2362, 2415], [2417, 2417, 2461, 2481, 2562], [2564, 2564, 2609, 2628, 2681], [2683, 2715, 2741, 2768, 3824], [3826, 3854, 3886, 4164, 4434], [4436, 4436, 4466, 4466, 5000], [5002, 5002, 5051, 5206, 6005], [6007, 6027, 6082, 6151, 9766]]}
{"id": "XdSfDc", "name": "Book of Shaders chapter 10", "author": "jope246", "description": "Experiments with random. Based on examples from here: http://thebookofshaders.com/10/", "tags": ["2d", "random", "stripes"], "likes": 3, "viewed": 205, "date": "1502398592", "time_retrieved": "2024-06-20T19:00:08.589093", "image_code": "#define PI 3.14159265359\n\nfloat random(vec2 uv) {\n return fract(sin(dot(uv,\n                         vec2(12.9898,78.233)))*\n        49958.5453123);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float val = cos(.78539816339*iTime)*8. + 20.;\n    uv*= vec2(val);\n    \n    vec2 fraction = fract(uv);\n    vec2 position = floor(uv);\n\n    float myTime = clamp(cos(.78539816339*iTime)*2.+1.75, 0.0,4.0);\n    \n    float velocity = 5.0 * myTime * (random(vec2(floor(uv.y),10.0)) - 0.5);\n    \n\tposition = floor(vec2(uv.x + velocity,uv.y));\n    \n    vec3 color = vec3(1.0);\n    color.r = random(position.xx);\n    color.g = random(position.xx);\n    color.b = random(position.xx);\n    \n    color *= smoothstep(0.0,myTime/8.,fraction.y);\n    \n\tfragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 49, 49, 153], [155, 155, 212, 212, 834]]}
{"id": "XdSfWV", "name": "VikingSnow", "author": "Coolok", "description": "VikingSnow", "tags": ["vikingsnow"], "likes": 2, "viewed": 163, "date": "1502140741", "time_retrieved": "2024-06-20T19:00:08.589093", "image_code": "#define _SnowflakeAmount 100\t// Number of snowflakes\n#define _BlizardFactor 0.2\t\t// Fury of the storm !\n\nvec2 uv;\n\nfloat rnd(float x)\n{\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));\n}\n\nfloat drawCircle(vec2 center, float radius)\n{\n    return 1.0 - smoothstep(0.0, radius, length(uv - center));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.x;\n    \n    fragColor = vec4(0.808, 0.89, 0.918, 1.0);\n    float j;\n    \n    for(int i=0; i<_SnowflakeAmount; i++)\n    {\n        j = float(i);\n        float speed = 0.3+rnd(cos(j))*(0.7+0.5*cos(j/(float(_SnowflakeAmount)*0.25)));\n        vec2 center = vec2((0.25-uv.y)*_BlizardFactor+rnd(j)+0.05*cos(iTime+sin(j)), mod(sin(j)-speed*(iTime*0.5*(0.1+_BlizardFactor)), 0.65));\n        fragColor += vec4(0.09*drawCircle(center, 0.001+speed*0.012));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSfWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[115, 115, 135, 135, 233], [235, 235, 280, 280, 345], [348, 348, 405, 405, 894]]}
{"id": "XlfyR4", "name": "creepy cylinders", "author": "serge_rgb", "description": "playing with shadertoy", "tags": ["procedural", "cylinder", "repeat"], "likes": 4, "viewed": 140, "date": "1503535602", "time_retrieved": "2024-06-20T19:00:08.589093", "image_code": "float sphere(vec3 p, vec3 c, float r) {\n   return length(p-c) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c, float r, float h) {\n   vec3 d = p-c;\n   return max(length(d.xz - c.xz) - r, abs(d.y) - h);\n}\n\nfloat box(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat plane(vec3 p, vec3 c, vec3 n) {\n   return dot(p-c, n);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdf(vec3 p) {\n   return smin(cylinder(vec3(mod(p.x, 1.1)-0.5*1.1,\n                             p.y,\n                             mod(p.z, 1.1)-1.1/2.0), vec3(0), 0.17, .3),\n               plane(p, vec3(0,-0.2,0), vec3(0.0,1.0,0.0)), 0.4);\n}\n\n\n#define MAXSTEP 300\n#define EPSILON 0.001f\n\nfloat march(vec3 eye, vec3 dir) {\n   float depth = 0.0f;\n   for (int s = 0; s < MAXSTEP; ++s) {\n      float dist = sdf(eye + depth * dir);\n      if (dist < EPSILON) {\n         return depth;\n      }\n      depth += dist;\n   }\n   return 0.0;\n}\n\nvec3 normal(vec3 p) {\n   vec3 normal = vec3(sdf(p + vec3(EPSILON,0.0,0.0)) - sdf(p - vec3(EPSILON,0.0,0.0)),\n                      sdf(p + vec3(0.0,EPSILON,0.0)) - sdf(p - vec3(0.0,EPSILON,0.0)),\n                      sdf(p + vec3(0.0,0.0,EPSILON)) - sdf(p - vec3(0.0,0.0,EPSILON)));\n   return normalize(normal);\n}\n\nfloat phong(vec3 eye, vec3 p, vec3 n, vec3 l) {\n   vec3 ld = normalize(l-p);\n   vec3 cd = normalize(eye-p);\n\n   float ka = 0.3;\n   float kd = 3.0;\n   float ks = 1.0;\n   vec3 r = 2.0*dot(ld,n)*n - ld;\n   r = normalize(r);\n   float ds = dot(r, cd);\n   float res = ka + kd*dot(ld, n);\n   return res + ks*pow(clamp(dot(r, cd),0.0,1.0), 50.0);\n}\n\nmat3 view(vec3 eye, vec3 c, vec3 up) {\n   vec3 f = normalize(c - eye);\n   vec3 s = normalize(cross(f, up));\n   vec3 u = cross(s, f);\n   return mat3(s,u,f);\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n   float w = iResolution.x;\n   float h = iResolution.y;\n   float x = fragcoord.x / w;\n   float y = fragcoord.y / h;\n\n   float ar = float(w)/h;\n   x *= ar;\n\n   x = -ar + x*2.0;\n   y = -1.0 + y*2.0;\n\n   vec3 eye = vec3(0,0,-3);\n   vec3 px = vec3(x, y, -0.2);\n   vec3 dir = normalize( px - eye );\n\n   float t = iTime * 0.3;\n\n   vec3 cam = vec3(0,0.3,0) + vec3(cos(t),0.1*sin(iTime), sin(t));\n   mat3 v = view(cam, vec3(0), vec3(0,1,0));\n   eye = v * eye;\n   dir = v * dir;\n\n   vec3 l = vec3(-1,2,-3);\n\n   fragcolor = y*vec4(0.03,0.08,0.08,1);\n   float d = march(eye, dir);\n   vec3 p = eye + dir*d;\n   vec3 n = normal(p);\n   if (d > 0.0f) {\n      fragcolor = 0.5*vec4(0.1+0.1*pow(cos(1.3*iTime), 3.0),0.1,0.2, 1);\n      fragcolor *=  phong(eye, p, normal(p), l);\n      fragcolor *= 5.0/d;\n      if (march(p + n*EPSILON, normalize(l-p)) > 0.0f) {\n         fragcolor *= 0.3;\n      }\n   }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfyR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 39, 39, 68], [70, 70, 120, 120, 193], [195, 195, 222, 222, 315], [317, 317, 354, 354, 379], [381, 381, 420, 420, 513], [515, 515, 534, 534, 761], [808, 808, 841, 841, 1048], [1050, 1050, 1071, 1071, 1364], [1366, 1366, 1413, 1413, 1706], [1708, 1708, 1746, 1746, 1865], [1867, 1867, 1922, 1922, 2806]]}
{"id": "XlfyRM", "name": "Ray marching practice", "author": "balintfodor", "description": "A basic code for getting familiar with ray marching and signed distance functions. Added some fun coloring. Suggestions and improvements are welcome.", "tags": ["raymarching"], "likes": 1, "viewed": 109, "date": "1503914516", "time_retrieved": "2024-06-20T19:00:08.946503", "image_code": "#define EPS 0.001\n#define CAM_NEAR 0.1\n#define CAM_FAR 10.\n\nfloat dSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec3 distort(vec3 p)\n{\n    return p + 0.253 * sin(p * 3.827 + iTime);\n}\n\nfloat dScene(vec3 p)\n{\n    vec3 offset = vec3(0., 0., 4.);\n    float sp = dSphere(distort(p) + offset, 1.);\n    return sp;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    vec3 e = vec3(EPS, 0., 0.);\n    return normalize(vec3(\n        dScene(p + e.xyy) - dScene(p - e.xyy),\n        dScene(p + e.yxy) - dScene(p - e.yxy),\n        dScene(p + e.yyx) - dScene(p - e.yyx)));\n}\n\nvec4 custom_lighting(vec3 n, vec3 ld, vec3 v)\n{\n    float li = max(dot(n, ld), 0.);\n    float vi = max(dot(n, v), 0.);\n    vec3 x = vi * vec3(11., 13., 17.);\n    vec3 c = sin(x);\n    return vec4(li * (0.5 * c + 0.5), 1.);\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    float t = CAM_NEAR;\n    vec4 color = vec4(0.);\n    vec3 light = vec3(-1., 1.5, -2.0);\n    for (int i = 0; i < 256; ++i) {\n        vec3 p = ro + rd * t;\n        float d = dScene(p);\n        if (d <= EPS) {\n            vec3 n = estimateNormal(p);\n            color = custom_lighting(n, normalize(light - p), -rd);\n            break;\n        }\n        if (d > CAM_FAR) {\n            break;\n        }\n        t += d;\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5* iResolution.xy) / iResolution.x;\n    vec3 ro = vec3(0., 0., 1.);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    fragColor = render(ro, rd);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfyRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[60, 60, 92, 92, 120], [122, 122, 144, 144, 193], [195, 195, 217, 217, 319], [321, 321, 350, 350, 554], [556, 556, 603, 603, 779], [781, 781, 812, 812, 1255], [1257, 1257, 1312, 1312, 1486]]}
{"id": "XllcRH", "name": "Raymarching noob", "author": "Prototonca", "description": "First try with raymarching", "tags": ["raymarching"], "likes": 0, "viewed": 93, "date": "1503613342", "time_retrieved": "2024-06-20T19:00:08.946503", "image_code": "#define VIEW_WIDTH 6.0\n#define CAM_DIST 6.0\n#define EPSILON 0.001\n#define MAX_MARCH_LENGTH 256\n#define SHAPE_N 2\n\nstruct RayState {\n    float d;\n    vec3 base_col;    \n};\n    \n    \n// ---- SHAPES ----\n    \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udPlane(vec3 p) \n{\n    return abs(p.y);\n}\n\nfloat udWaves(vec3 p)\n{\n    return abs(p.y-(cos(length(p.xz-vec2(1.0))*20.0+iTime))*0.01);\n}\n// ---- OPERATIONS ----\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 opTrans( vec3 p, vec3 t)\n{\n    return p - t;\n}\n\nRayState opUrs(RayState o1, RayState o2)\n{\n    if (o1.d <= o2.d) return o1;\n    else return o2;\n}\n\n\n// ---- MAP SCENE ----\nRayState map(vec3 p)\n{\n    \n    if (SHAPE_N == 0)\n    {\n        vec3 q = fract(p) * 3.0 - 1.0;\n        q = abs(q);\n        return RayState(\n            q.x + q.y + q.z - 0.35,\n            vec3(0.3)\n        );\n    }\n    if (SHAPE_N == 1)\n    {\n        return RayState(\n            sdSphere(p, 0.25),\n            vec3(0.2)\n        );\n    }\n    if (SHAPE_N == 2)\n    {\n        RayState box = RayState(\n            udRoundBox(opTrans(p,vec3(-cos(iTime*1.4)*0.5,0.2,sin(iTime*1.4))), vec3(0.1, 0.1, 0.1), 0.05),\n            vec3(0.3, 0.2, 0.6)\n        );\n        \n        RayState plane = RayState(\n            udWaves(p),\n            vec3(0.0,0.0,0.0)\n        );\n        \n        RayState sphere = RayState(\n            sdSphere(opTrans(p,vec3(0.0,cos(iTime*1.2),sin(iTime*1.2)*0.5)),0.1),\n            vec3(0.1,0.5,0.1)\n        );\n        \n        RayState sphere2 = RayState(\n            sdSphere(opTrans(p,vec3(sin(iTime*1.2)*0.5,-cos(iTime*1.2),0.0)),0.1),\n            vec3(0.7,0.5,0.2)\n        );\n        \n        return opUrs(opUrs(opUrs(box, plane),sphere), sphere2);   \n    } \n}\n\n\nvec3 computeNormal(vec3 p) \n{\n    \n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + eps.xyz).d - map(p - eps.xyz).d,\n        map(p + eps.zxy).d - map(p - eps.zxy).d,\n        map(p + eps.yzx).d - map(p - eps.yzx).d\n    );\n    return normalize(nor);\n}\n\n\n\n// ---- LIGHTS ----\n\nvec3 dir_shadow(vec3 origin, vec3 light_dir)\n{\n    float t = 0.01;\n    \n    if(dot(-light_dir,computeNormal(origin))<0.01) {\n    \treturn vec3(0.0);\n    }\n    \n    for(int i=0; i<16; i++)\n    {\n        vec3 pos = origin - light_dir * t;\n        RayState rs = map(pos);\n\n        if(rs.d < EPSILON) \n        {\n            return vec3(-0.1/t);   \n        }\n\t\tif(rs.d < 0.0)\n        {\n            return vec3(0.0);\n        }\n        \n        t += rs.d * 0.8;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 dir_light(vec3 normal, vec3 light_dir) \n{  \n    return vec3(-dot(normal,light_dir));\n}\n\nvec3 ambient_light(vec3 base_col)\n{\n    return base_col;\n}\n\nvec3 black_fog(float depth)\n{\n    return vec3(-depth/(float(MAX_MARCH_LENGTH/3)));\n}\n\nvec3 light(RayState rs, vec3 p, vec3 normal, float depth)\n{\n    vec3 light_dir = vec3(cos(iTime), -1.0, sin(iTime));\n    return dir_light(normal, light_dir)*0.4 + ambient_light(rs.base_col) + black_fog(depth)*0.0 + dir_shadow(p, light_dir);\n}\n\n\n// ---- RAYMARCH ----\n\n\n\n\nvec3 trace(vec3 origin, vec3 rayDir)\n{\n    float t = 0.0;\n    for(int i=0; i<MAX_MARCH_LENGTH; i++)\n    {\n        vec3 pos = origin + rayDir * t;\n        RayState rs = map(pos);\n\n        if(rs.d < EPSILON) \n        {\n            vec3 normal = computeNormal(pos);\n\n            return light(rs, pos, normal, t);\n                \n        }\n\n        t += rs.d * 0.8;\n    }\n\n    return vec3(0.0); \n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 target = vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.2;\n    vec3 cameraPos = (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd = normalize(target - cameraPos);\n    vec3 worldUp = vec3(0.0,sign(cos(angleY)),0.0);\n    vec3 cameraLeft = normalize(cross(cameraFwd, worldUp));\n    vec3 cameraUp = normalize(cross(cameraLeft, cameraFwd));\n\n    float viewHeight = VIEW_WIDTH * iResolution.y / iResolution.x;\n    \n    // Ray\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(CAM_DIST,CAM_DIST,CAM_DIST))\n        - (cameraLeft * percent.x * VIEW_WIDTH)\n        + (cameraUp * percent.y * viewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n    \n    \n    fragColor = vec4(trace(cameraPos, rayDir), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllcRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[181, 206, 237, 237, 324], [326, 326, 357, 357, 395], [397, 397, 430, 430, 495], [497, 497, 532, 532, 556], [558, 558, 603, 603, 643], [645, 645, 669, 669, 692], [694, 694, 717, 717, 786], [787, 812, 845, 845, 870], [872, 872, 903, 903, 923], [925, 925, 967, 967, 1022], [1025, 1048, 1070, 1070, 2129], [2132, 2132, 2161, 2161, 2407], [2411, 2432, 2478, 2478, 2920], [2922, 2922, 2968, 2968, 3013], [3015, 3015, 3050, 3050, 3073], [3075, 3075, 3104, 3104, 3159], [3161, 3161, 3220, 3220, 3403], [3406, 3432, 3470, 3470, 3826], [3828, 3847, 3904, 3918, 4922]]}
{"id": "Xllcz7", "name": "Random Dot Mask", "author": "aferriss", "description": "Simple Mask of Dots", "tags": ["grid", "random", "dots", "mask"], "likes": 11, "viewed": 779, "date": "1504116958", "time_retrieved": "2024-06-20T19:00:08.946503", "image_code": "#define rand(p)  fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453)\n\nfloat num = 50.;\n\nvoid mainImage( out vec4 O, in vec2 t )\n{\n\tt /= iResolution.x;\n    t.y += iTime *0.05;\n    t *= num;\n\n    float r = rand(floor(t*num)/num);\n    O = vec4( smoothstep(.5,.6, 1. -length(fract(t) - .5)) * rand(floor(t)/num) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xllcz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[90, 90, 131, 131, 314]]}
{"id": "XlsyRM", "name": "counting", "author": "jasonaugur", "description": "scaling radians", "tags": ["2d", "sdf", "timecurve"], "likes": 3, "viewed": 151, "date": "1504069544", "time_retrieved": "2024-06-20T19:00:08.946503", "image_code": "float tCurve()\n{\n    float t = iTime*.3 * 4.;\n\tt = floor(t) +  smoothstep(0., 1., fract(t));\n\tt = mod(t/4., 3.5);\n  \n    return t + 2. * (1.75-max(1.75,t));\n}\n\nvoid mainImage( out vec4 O, vec2 p )\n{\n\tp = ( p+p - iResolution.xy ) / iResolution.y;\n    \n\tfloat a = atan(p.x,p.y) * ( -1. + tCurve() );\n\n    p *= mat2(cos(a),sin(a),-sin(a), cos(a));\n\t\n    p = abs(p) - .5;\n    \n\tO = vec4( smoothstep( .0, .01, abs(max(p.x, p.y)) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsyRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 16, 16, 158], [160, 160, 198, 198, 430]]}
{"id": "XlsyRr", "name": "Circlesception", "author": "Vovosunt", "description": "Doodle", "tags": ["2d", "circle", "polar"], "likes": 8, "viewed": 187, "date": "1503166655", "time_retrieved": "2024-06-20T19:00:09.189001", "image_code": "#define c30 0.86602540378\n#define grid 150.0\n#define smooth (50. / iResolution.x)\n#define timeScale 4.\n#define rt      ((iTime+400.0) * timeScale)\n#define PI      3.14159265359\n\nvec3 getCol(float v){\n    float r = sin(v);\n    float g = sin(v + 0.66);\n    float b = sin(v + 2.);\n \treturn vec3(r,g,b); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (fragCoord.xy -0.5 * iResolution.xy)/ iResolution.x;\n    \n    float lf = floor(length(st) * grid + 0.5);\n    float lfff = floor(lf *PI * 2.0);\n    \n    float ft = rt * mix(1.0,lfff /grid / 8.0,0.8);\n    float cT = cos(ft);\n    float sT = sin(ft);\n    st = mat2(cT,-sT,sT,cT) * st;\n    \n    float a = atan(st.x,st.y) + PI;    \n    vec3 acol = getCol(a);\n    a /= PI * 2.0;\n    \n    float af = floor(a * lfff + 0.5)/lfff * 2.0 * PI - PI;\n    \n    \n    vec2 nst = lf / grid * vec2(sin(af),cos(af));\n    float dist = length(st - nst) * grid;\n   \tfloat col = smoothstep(smooth,-smooth,dist - 0.4);\n\n    \n    \n\tfragColor = vec4(mix(acol * 0.5,acol,col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsyRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[178, 178, 199, 199, 302], [304, 304, 361, 361, 1027]]}
{"id": "XlXczr", "name": "Fractal Thingy #3", "author": "Klems", "description": "fractal stuff", "tags": ["2d", "fractal"], "likes": 7, "viewed": 547, "date": "1503017067", "time_retrieved": "2024-06-20T19:00:09.189001", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n\n#define SIDES 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy * 0.5;\n    uv /= iResolution.y;\n\t\n    if (iMouse.z > 0.5) {\n        uv -= (iMouse.zw-iMouse.xy) / iResolution.y;\n    }\n    \n    uv *= 3.0;\n    \n    fragColor.rgb = vec3(0);\n    \n    for (int i = 0 ; i < 7 ; i++) {\n        \n        float scaleFactor = float(i)+2.0;\n        \n        // rotation\n        uv *= rot(iTime * scaleFactor * 0.01);\n        \n        // polar transform\n        const float scale = 2.0*PI/float(SIDES);\n        float theta = atan(uv.x, uv.y)+PI;\n        theta = (floor(theta/scale)+0.5)*scale;\n        vec2 dir = vec2(sin(theta), cos(theta));\n        vec2 codir = dir.yx * vec2(-1, 1);\n        uv = vec2(dot(dir, uv), dot(codir, uv));\n        \n        // translation\n        uv.x -= iTime * scaleFactor * 0.01;\n        \n        // repetition\n        uv = abs(fract(uv+0.5)*2.0-1.0)*0.7;\n        \n        // coloration\n        fragColor.rgb += exp(-min(uv.x, uv.y)*10.) * (cos(vec3(2,3,1)*float(i)+iTime*0.5)*.5+.5);\n        \n    }\n    \n    fragColor.rgb *= 0.4;\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXczr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[95, 95, 152, 152, 1200]]}
{"id": "Xs2BRd", "name": "Fractal simplex terrain", "author": "tiusic", "description": "Derpy terrain generation using fractal simplex noise.", "tags": ["procedural", "simplex"], "likes": 3, "viewed": 170, "date": "1501723507", "time_retrieved": "2024-06-20T19:00:09.189001", "image_code": "float F = 0.36602540378;\nfloat G = 0.21132486540;\nfloat R2 = 0.5;\nfloat TAU = 6.28318530718;\nfloat L = 10.0;\n\nvec2 hash(vec2 p, float z) {\n    vec3 p3 = vec3(p, z);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    float t = TAU * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(t), sin(t));\n}\n\nvec2 skew(vec2 p) {\n   \tfloat f = (p.x + p.y) * F;\n    return p + vec2(f, f);\n}\n\nvec2 unskew(vec2 q) {\n   \tfloat g = (q.x + q.y) * G;\n    return q - vec2(g, g);\n}\n\nfloat noise(vec2 q, vec2 p, float z) {\n    vec2 h = hash(q, z);\n    vec2 d = unskew(q) - p;\n    float d2 = d.x * d.x + d.y * d.y;\n    return pow(max(0.0, R2 - d2), 4.0) * dot(d, h);\n}\n\nfloat noise(vec2 p, float z) {\n    vec2 q = skew(p);\n    vec2 qa = floor(q);\n    vec2 qi = q - qa;\n    vec2 qb = qa + vec2(1.0, 1.0);\n    vec2 qc;\n    \n    if (qi.x < qi.y) {\n\t\tqc = qa + vec2(0.0, 1.0);\n    } else {\n\t\tqc = qa + vec2(1.0, 0.0);\n    }\n    \n    float ka = noise(qa, p, z);\n    float kb = noise(qb, p, z);\n    float kc = noise(qc, p, z);\n    return ka + kb + kc;\n}\n\nfloat noise(vec2 p) {\n    float k = 0.0;\n    float o = 1.0;\n    for (float z = 0.0; z < L; ++z) {\n        k += noise(p / o, z) * o;\n        o *= 2.0;\n    }\n    return k;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord + vec2(0, iTime * 100.0);\n    \n    float k = noise(p);\n    k = max(0.0, min(1.0, 0.5 + 0.1 * k));\n    if (k < 0.5) {\n        fragColor = vec4(0.0, k, 0.7 + 0.6 * k, 1.0);\n    } else if (k < 0.55) {\n        fragColor = vec4(1.0, 4.0 * (k - 0.5) + 0.8, 0.6, 1.0);\n    } else if (k < 0.8) {\n        fragColor = vec4(0, 0.5 * k + 0.5, 0.0, 0.0);\n    } else if (k < 0.85) {\n        fragColor = vec4(0, -9.1 * k + 8.18, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0, (1.0 - k) * 0.3 + 0.4, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2BRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[110, 110, 138, 138, 309], [311, 311, 330, 330, 390], [392, 392, 413, 413, 473], [475, 475, 513, 513, 658], [660, 660, 690, 690, 1037], [1039, 1039, 1060, 1060, 1210], [1212, 1212, 1267, 1267, 1798]]}
{"id": "Xs2fRd", "name": "How simplex noise works", "author": "tiusic", "description": "Demonstrates the steps involved in generating fractal simplex noise.", "tags": ["procedural", "tutorial", "simplex"], "likes": 14, "viewed": 284, "date": "1501743200", "time_retrieved": "2024-06-20T19:00:09.189001", "image_code": "float F = 0.36602540378;\nfloat G = 0.21132486540;\nfloat TAU = 6.28318530718;\nfloat L = 10.0;\n\nvec2 hash(vec2 p, float z) {\n    vec3 p3 = vec3(p, z + 10.0 * floor(iTime / 40.0));\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    float t = TAU * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(t), sin(t));\n}\n\nvec2 skew(vec2 p) {\n   \tfloat f = (p.x + p.y) * F;\n    return p + vec2(f, f);\n}\n\nvec2 unskew(vec2 q) {\n   \tfloat g = (q.x + q.y) * G;\n    return q - vec2(g, g);\n}\n\nfloat noise(vec2 q, vec2 p, float r2, float z) {\n    vec2 h = hash(q, z);\n    vec2 d = unskew(q) - p;\n    float d2 = d.x * d.x + d.y * d.y;\n    return pow(max(0.0, r2 - d2), 4.0) * dot(d, h);\n}\n\nfloat noise(vec2 p, float r2, float z) {\n    vec2 q = skew(p);\n    vec2 qa = floor(q);\n    vec2 qi = q - qa;\n    vec2 qb = qa + vec2(1.0, 1.0);\n    vec2 qc;\n    \n    if (qi.x < qi.y) {\n\t\tqc = qa + vec2(0.0, 1.0);\n    } else {\n\t\tqc = qa + vec2(1.0, 0.0);\n    }\n    \n    float ka = noise(qa, p, r2, z);\n    float kb = noise(qb, p, r2, z);\n    float kc = noise(qc, p, r2, z);\n    return ka + kb + kc;\n}\n\nfloat noise(vec2 p, float r2) {\n    float k = 0.0;\n    float o = 1.0;\n    for (float z = 0.0; z < L; ++z) {\n        k += noise(p / o, r2, z) * o;\n        o *= 2.0;\n    }\n    return k;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5 * iResolution.xy;\n    \n    float T = mod(iTime, 40.0);\n    \n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n    if (T < 5.0) {\n        T /= 5.0;\n        p /= 100.0;\n        p = T * skew(p) + (1.0 - T) * p;\n        p = p - floor(p + vec2(0.5, 0.5));\n        if (length(p) < 0.03) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    } else if (T < 10.0) {\n        T = (T - 5.0) / 5.0;\n        p /= 100.0;\n        float k = 0.5 + 50.0 * pow(100000.0, 1.0 - sqrt(T)) * noise(p, 0.5 * T, 0.0);\n        fragColor = vec4(k, k, k, 1.0);\n    } else if (T < 30.0) {\n        T = (T - 10.0) / 2.0;\n        float N = floor(T);\n        float pT = T / 10.0;\n        p /= pow(2.0, 6.64385618977 * (1.0 - pT));\n        T -= floor(T);\n        float k = 0.0;\n        float o = 1.0;\n        for (float z = 0.0; z < N; ++z) {\n            k += noise(p / o, 0.5, z) * o;\n            o *= 2.0;\n        }\n        float m = T;\n        if (N < 1.0) m = 1.0;\n        k += m * noise(p / o, 0.5, N) * o;\n        k = 0.5 + pow(2.0, (1.0 - pT) * 8.96578428466) * 0.1 * k;\n        fragColor = vec4(k, k, k, 1.0);\n    } else {\n        T = min(1.0, (T - 30.0) / 3.0);\n        float k = noise(p, 0.5);\n        k = max(0.0, min(1.0, 0.5 + 0.1 * k));\n        if (k < 0.5) {\n            fragColor = vec4(0.0, k, 0.7 + 0.6 * k, 1.0);\n        } else if (k < 0.55) {\n            fragColor = vec4(1.0, 4.0 * (k - 0.5) + 0.8, 0.6, 1.0);\n        } else if (k < 0.8) {\n            fragColor = vec4(0, 0.5 * k + 0.5, 0.0, 0.0);\n        } else if (k < 0.85) {\n            fragColor = vec4(0, -9.1 * k + 8.18, 0.0, 1.0);\n        } else {\n            fragColor = vec4(0, (1.0 - k) * 0.3 + 0.4, 0.0, 1.0);\n        }\n        \n        fragColor = (1.0 - T) * vec4(k, k, k, 1.0) + T * fragColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2fRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[94, 94, 122, 122, 322], [324, 324, 343, 343, 403], [405, 405, 426, 426, 486], [488, 488, 536, 536, 681], [683, 683, 723, 723, 1082], [1084, 1084, 1115, 1115, 1269], [1271, 1271, 1326, 1326, 3113]]}
{"id": "Xs2fWG", "name": "blurry worry", "author": "michaelakelley", "description": "dancing, blurry circle of worry", "tags": ["music"], "likes": 2, "viewed": 110, "date": "1501958952", "time_retrieved": "2024-06-20T19:00:09.189001", "image_code": "// derived from: https://www.shadertoy.com/view/MdBBWG\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bass = texture(iChannel0,vec2(0,0)).r;\n    float value = texture(iChannel0,vec2( 0.1*bass*fragCoord.x/iResolution.x,0)).r;\n    float radius = 0.9 * min(iResolution.x*1., iResolution.y*1.) * sin(value);\n    vec3 blur = 30.0 + 28.0 * sin(iTime * vec3(1, 1.1, 1.2)) * sin(value);\n    vec2 c =( 0.5 + 0.01*sin(iTime)) * iResolution.xy;\n    vec3 dist = smoothstep(-blur*5.0, blur*5.0, vec3(abs(distance(fragCoord, c) - radius)));\n\tfragColor = vec4(\n        dist,\n        1.0\n    );\n}", "image_inputs": [{"id": "MsXXWj", "previewfilepath": "https://soundcloud.com/michael-andrew-kelley/officer-i-was-dancing", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/michael-andrew-kelley/officer-i-was-dancing", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2fWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 55, 112, 112, 601]]}
{"id": "Xs2fWK", "name": "Circle Limit IV", "author": "rubelson", "description": "M. C. Escher's \"Circle Limit IV\" in the movement\nMove the pressed mouse for zooming", "tags": ["escher", "tiling", "hyperbolic", "poincare", "reproduction"], "likes": 39, "viewed": 522, "date": "1502231960", "time_retrieved": "2024-06-20T19:00:09.195102", "image_code": "\nvec4 getPix(float tex_x, mat4 d)\n{\nfloat x_=0.;\n\nif(tex_x<4.)\t\tx_=d[0][0];\nelse if(tex_x<8.)\tx_=d[0][1];\nelse if(tex_x<12.)\tx_=d[0][2];\nelse if(tex_x<16.)\tx_=d[0][3];\nelse if(tex_x<20.)\tx_=d[1][0];\nelse if(tex_x<24.)\tx_=d[1][1];\nelse if(tex_x<28.)\tx_=d[1][2];\nelse if(tex_x<32.)\tx_=d[1][3];\nelse if(tex_x<36.)\tx_=d[2][0];\nelse if(tex_x<40.)\tx_=d[2][1];\nelse if(tex_x<44.)\tx_=d[2][2];\nelse if(tex_x<48.)\tx_=d[2][3];\nelse if(tex_x<52.)\tx_=d[3][0];\nelse if(tex_x<56.)\tx_=d[3][1];\nelse if(tex_x<60.)\tx_=d[3][2];\nelse if(tex_x<64.)\tx_=d[3][3];\n\nfloat mask = mod(tex_x, 4.);\nfloat tmp = 0.;\nif(mask==0.)\t\ttmp=mod(x_,16.)/16.;\nelse if(mask==1.)\ttmp=mod(floor(x_/16.),16.)/16.;\nelse if(mask==2.)\ttmp=mod(floor(x_/256.),16.)/16.;\nelse\t\t\ttmp=mod(floor(x_/4096.),16.)/16.;\nvec4 col=vec4(tmp,tmp,tmp,1.);\nreturn col;\n}\n\n\n\nvec4 getColor(float tex_x, float tex_y)\n{\nvec4 col=vec4(0.,0.,0.,1.);\nif(tex_y<10.){\nif(tex_y==0.)col=getPix(tex_x,mat4(61436.,65519.,34617.,5240.,52412.,56525.,61149.,65534.,6655.,16704.,13396.,47201.,34953.,22390.,26230.,20789.));\nif(tex_y==1.)col=getPix(tex_x,mat4(65019.,65535.,8639.,919.,52146.,52460.,60892.,65518.,7935.,4864.,8226.,35187.,22135.,30035.,8754.,24897.));\nif(tex_y==2.)col=getPix(tex_x,mat4(61433.,65534.,2303.,9521.,64544.,60911.,60875.,64989.,32767.,512.,8226.,22421.,17543.,9011.,4113.,4112.));\nif(tex_y==3.)col=getPix(tex_x,mat4(65524.,65263.,28671.,12288.,58688.,64476.,56254.,64989.,61439.,4096.,20497.,26216.,4422.,291.,0.,0.));\nif(tex_y==4.)col=getPix(tex_x,mat4(65474.,57343.,65534.,345.,49712.,64700.,51935.,61149.,65535.,4100.,21504.,25975.,8452.,12289.,52119.,48077.));\nif(tex_y==5.)col=getPix(tex_x,mat4(65077.,65535.,65518.,49151.,45094.,65467.,48639.,61147.,65535.,10.,34304.,17751.,36.,64914.,60927.,65535.));\nif(tex_y==6.)col=getPix(tex_x,mat4(45591.,65535.,61183.,61439.,56014.,65533.,57343.,60875.,65533.,46.,34832.,13143.,37378.,65535.,44287.,65534.));\nif(tex_y==7.)col=getPix(tex_x,mat4(88.,30803.,65533.,57069.,65484.,65535.,65535.,56508.,65533.,143.,26944.,4949.,65376.,65199.,44799.,65534.));\nif(tex_y==8.)col=getPix(tex_x,mat4(13942.,16.,65408.,52719.,61163.,65263.,65535.,56271.,65517.,223.,25920.,19.,65529.,60111.,45055.,65517.));\nif(tex_y==9.)col=getPix(tex_x,mat4(1401.,4978.,63232.,44511.,56814.,61150.,65534.,48383.,65229.,1535.,13632.,40962.,65247.,52223.,49151.,65500.));\n}\nelse if(tex_y<20.){\nif(tex_y==10.)col=getPix(tex_x,mat4(1384.,26244.,28673.,52191.,56798.,56781.,65519.,48895.,60892.,3327.,5168.,63745.,59823.,48639.,53245.,65499.));\nif(tex_y==11.)col=getPix(tex_x,mat4(5223.,18311.,4.,56296.,56798.,56780.,65262.,61439.,56779.,24574.,4928.,65345.,51967.,49150.,61420.,65499.));\nif(tex_y==12.)col=getPix(tex_x,mat4(13687.,1128.,16384.,60545.,52702.,56796.,60893.,65534.,52654.,53213.,288.,48593.,48636.,53229.,65515.,65243.));\nif(tex_y==13.)col=getPix(tex_x,mat4(25447.,40.,16707.,64004.,56815.,56524.,56780.,65517.,47839.,65228.,803.,43767.,52956.,65500.,65227.,65212.));\nif(tex_y==14.)col=getPix(tex_x,mat4(33366.,24580.,39631.,60533.,57071.,60893.,56796.,60893.,44543.,64972.,4106.,48894.,57308.,64971.,64973.,64957.));\nif(tex_y==15.)col=getPix(tex_x,mat4(33317.,49152.,60365.,56047.,61183.,52974.,52413.,52701.,57342.,56521.,20527.,60351.,61183.,60619.,64975.,64975.));\nif(tex_y==16.)col=getPix(tex_x,mat4(26149.,53249.,56268.,52462.,65535.,57071.,52429.,56540.,65245.,56237.,37022.,61390.,52221.,60862.,56527.,56543.));\nif(tex_y==17.)col=getPix(tex_x,mat4(22532.,53504.,48093.,60399.,65535.,61183.,56798.,52428.,56796.,48095.,51421.,56814.,56303.,56526.,60927.,52479.));\nif(tex_y==18.)col=getPix(tex_x,mat4(22804.,49152.,48350.,65005.,65535.,65535.,57070.,52685.,56780.,44781.,61130.,56782.,56255.,52222.,56830.,60653.));\nif(tex_y==19.)col=getPix(tex_x,mat4(22578.,40960.,52702.,65211.,65535.,65535.,61439.,56798.,52444.,61148.,57066.,64733.,56765.,48620.,53245.,65533.));\n}\nelse if(tex_y<30.){\nif(tex_y==20.)col=getPix(tex_x,mat4(14385.,20480.,52703.,43725.,65227.,65535.,65535.,56815.,52445.,60620.,56780.,65517.,64715.,49102.,61405.,65535.));\nif(tex_y==21.)col=getPix(tex_x,mat4(18978.,0.,52989.,52445.,43436.,65227.,65535.,61439.,56798.,48604.,48093.,53245.,47819.,57055.,65516.,65535.));\nif(tex_y==22.)col=getPix(tex_x,mat4(22530.,1.,57079.,52700.,52429.,43691.,60841.,65535.,61183.,48589.,61163.,48366.,48588.,65259.,22171.,51029.));\nif(tex_y==23.)col=getPix(tex_x,mat4(37889.,37.,57024.,56813.,56781.,48332.,39612.,56235.,61439.,52446.,64683.,52159.,52443.,64717.,5.,0.));\nif(tex_y==24.)col=getPix(tex_x,mat4(32769.,5.,61296.,57070.,60893.,56797.,56542.,43708.,56490.,48334.,64187.,56271.,60876.,64989.,11.,4352.));\nif(tex_y==25.)col=getPix(tex_x,mat4(29441.,2.,65492.,65535.,61167.,65262.,60910.,56797.,44236.,64714.,60877.,48382.,56797.,61165.,141.,28928.));\nif(tex_y==26.)col=getPix(tex_x,mat4(26113.,1.,64507.,65535.,65535.,65535.,65535.,65535.,56830.,48092.,65533.,52974.,60875.,65518.,1790.,25600.));\nif(tex_y==27.)col=getPix(tex_x,mat4(22544.,0.,55530.,65535.,65535.,65535.,65535.,61183.,61166.,48878.,61419.,61166.,60876.,57070.,28652.,33792.));\nif(tex_y==28.)col=getPix(tex_x,mat4(14129.,0.,64403.,65535.,65535.,43727.,13415.,4370.,8464.,52987.,40412.,60602.,56798.,65518.,64971.,8234.));\nif(tex_y==29.)col=getPix(tex_x,mat4(1089.,0.,25344.,35207.,9320.,1.,0.,0.,20480.,52719.,48364.,48093.,56798.,65534.,60620.,1775.));\n}\nelse if(tex_y<40.){\nif(tex_y==30.)col=getPix(tex_x,mat4(864.,4096.,3.,0.,0.,0.,272.,8448.,57859.,52972.,48125.,60620.,61166.,65535.,48335.,53229.));\nif(tex_y==31.)col=getPix(tex_x,mat4(897.,8192.,8195.,1.,8448.,4625.,578.,8721.,64002.,52714.,51949.,60876.,61166.,65535.,56559.,60604.));\nif(tex_y==32.)col=getPix(tex_x,mat4(114.,16384.,4099.,257.,13089.,258.,8192.,324.,65344.,56812.,51918.,56795.,65261.,65535.,65518.,48895.));\nif(tex_y==33.)col=getPix(tex_x,mat4(9.,28672.,4.,13108.,8739.,529.,17152.,1092.,57248.,56828.,48078.,56780.,60910.,65535.,61438.,65535.));\nif(tex_y==34.)col=getPix(tex_x,mat4(38.,29440.,12291.,13364.,8740.,528.,21808.,852.,40163.,65003.,57036.,56524.,57086.,61150.,61182.,53230.));\nif(tex_y==35.)col=getPix(tex_x,mat4(68.,37904.,12546.,21573.,17459.,290.,22097.,306.,52984.,57068.,60602.,56542.,52462.,48060.,61437.,53213.));\nif(tex_y==36.)col=getPix(tex_x,mat4(594.,34368.,17153.,22100.,13397.,35.,26469.,35.,57340.,52956.,56812.,57069.,61167.,52718.,65499.,65535.));\nif(tex_y==37.)col=getPix(tex_x,mat4(9541.,34385.,16672.,30548.,18023.,8210.,17237.,307.,65533.,61134.,61439.,65519.,33849.,61437.,65228.,65263.));\nif(tex_y==38.)col=getPix(tex_x,mat4(20737.,26471.,25616.,26470.,9574.,16386.,13684.,8209.,43743.,43691.,52683.,43963.,1.,59152.,64479.,56799.));\nif(tex_y==39.)col=getPix(tex_x,mat4(0.,14723.,25137.,26214.,4933.,20738.,17767.,12307.,52479.,52427.,56524.,52444.,2.,86.,48632.,61438.));\n}\nelse if(tex_y<50.){\nif(tex_y==40.)col=getPix(tex_x,mat4(1.,2384.,25616.,25958.,13126.,25089.,13926.,16404.,61439.,65262.,65262.,65006.,16649.,22373.,64560.,65243.));\nif(tex_y==41.)col=getPix(tex_x,mat4(3.,5952.,25104.,17765.,16949.,25347.,9320.,16405.,65535.,65535.,65535.,65279.,24623.,38518.,24618.,52445.));\nif(tex_y==42.)col=getPix(tex_x,mat4(70.,26144.,20992.,25956.,9542.,25089.,21864.,16421.,65535.,52446.,48332.,64972.,4271.,30549.,647.,22096.));\nif(tex_y==43.)col=getPix(tex_x,mat4(87.,38448.,16384.,30053.,12614.,33538.,22376.,17188.,43983.,52154.,56797.,65262.,1535.,21841.,14741.,8466.));\nif(tex_y==44.)col=getPix(tex_x,mat4(3.,42304.,17409.,30308.,9303.,33536.,30311.,12596.,56799.,60893.,65518.,65535.,24575.,25088.,34645.,30838.));\nif(tex_y==45.)col=getPix(tex_x,mat4(1.,38480.,8195.,21844.,9541.,25346.,26470.,4132.,61438.,65534.,61439.,56798.,65535.,4119.,33826.,30777.));\nif(tex_y==46.)col=getPix(tex_x,mat4(0.,33824.,8196.,26196.,9285.,33537.,22153.,323.,65531.,61439.,52172.,56797.,65534.,14559.,12561.,257.));\nif(tex_y==47.)col=getPix(tex_x,mat4(4097.,21025.,8196.,30291.,17750.,29203.,26489.,308.,65528.,43981.,60620.,65262.,61183.,65535.,52463.,52428.));\nif(tex_y==48.)col=getPix(tex_x,mat4(4096.,29489.,72.,26450.,13687.,16404.,26745.,36.,44786.,52667.,65245.,61183.,61436.,65534.,65535.,65535.));\nif(tex_y==49.)col=getPix(tex_x,mat4(3.,16914.,5492.,34644.,18022.,16386.,26503.,565.,61328.,61166.,61438.,52429.,65501.,60894.,61165.,65278.));\n}\nelse if(tex_y<60.){\nif(tex_y==50.)col=getPix(tex_x,mat4(5.,17425.,5735.,30256.,26231.,12306.,30599.,4932.,65312.,65535.,48351.,56796.,65518.,52447.,56797.,56797.));\nif(tex_y==51.)col=getPix(tex_x,mat4(8214.,21554.,14388.,25650.,39063.,8740.,25975.,13413.,63232.,57343.,52411.,61150.,65263.,56831.,56524.,52684.));\nif(tex_y==52.)col=getPix(tex_x,mat4(4407.,8465.,25735.,38689.,29560.,313.,22421.,5238.,40960.,43727.,56780.,65534.,60894.,61183.,52429.,56780.));\nif(tex_y==53.)col=getPix(tex_x,mat4(26487.,599.,31024.,6242.,4096.,825.,30818.,4660.,16384.,56527.,61149.,52991.,60892.,61439.,56798.,65245.));\nif(tex_y==54.)col=getPix(tex_x,mat4(21880.,18054.,41984.,52.,32.,599.,30529.,294.,16400.,61439.,65535.,52446.,65261.,65535.,56815.,65518.));\nif(tex_y==55.)col=getPix(tex_x,mat4(25362.,30563.,28691.,4.,99.,9109.,22352.,278.,8242.,65535.,53247.,60875.,65518.,65500.,61183.,20222.));\nif(tex_y==56.)col=getPix(tex_x,mat4(57288.,35164.,22.,4151.,871.,9633.,29744.,53.,12579.,65535.,44015.,65245.,56831.,65245.,65535.,975.));\nif(tex_y==57.)col=getPix(tex_x,mat4(25975.,39501.,4.,12561.,5786.,1424.,37648.,8261.,4404.,65535.,56476.,65533.,56527.,61421.,53247.,8453.));\nif(tex_y==58.)col=getPix(tex_x,mat4(323.,25169.,4.,29952.,5785.,10080.,33552.,20517.,4117.,48638.,56538.,65535.,60859.,52991.,1503.,8704.));\nif(tex_y==59.)col=getPix(tex_x,mat4(1718.,8836.,4.,18224.,9874.,14384.,29200.,21253.,37.,51692.,65499.,48895.,65259.,60639.,28.,8704.));\n}\nelse if(tex_y<70.){\nif(tex_y==60.)col=getPix(tex_x,mat4(17745.,13912.,2.,1104.,14208.,23072.,29472.,25349.,21.,61178.,65533.,52207.,65261.,60879.,2.,17456.));\nif(tex_y==61.)col=getPix(tex_x,mat4(25395.,14248.,0.,0.,23088.,22545.,37697.,29717.,309.,65526.,65535.,56509.,61422.,28652.,26928.,8480.));\nif(tex_y==62.)col=getPix(tex_x,mat4(26420.,10273.,0.,0.,22272.,22528.,41808.,29956.,4407.,65523.,57343.,60875.,52991.,2812.,22948.,8770.));\nif(tex_y==63.)col=getPix(tex_x,mat4(9266.,13317.,0.,0.,29440.,14081.,29986.,25363.,615.,65505.,44543.,65244.,52223.,13038.,18568.,22561.));\nif(tex_y==64.)col=getPix(tex_x,mat4(19233.,12437.,39520.,344.,16384.,5380.,18452.,34113.,854.,65456.,51919.,65500.,56527.,37247.,26729.,33298.));\nif(tex_y==65.)col=getPix(tex_x,mat4(52289.,9471.,65456.,48895.,4.,13316.,5906.,26144.,9334.,65392.,56493.,65517.,61118.,30748.,38776.,12836.));\nif(tex_y==66.)col=getPix(tex_x,mat4(8736.,3013.,65440.,65517.,959.,16419.,8770.,35393.,13159.,60960.,64986.,65535.,64987.,34629.,34153.,4937.));\nif(tex_y==67.)col=getPix(tex_x,mat4(43922.,10004.,65440.,60621.,28671.,0.,4624.,34947.,4936.,64256.,65534.,53247.,49131.,34163.,26215.,22135.));\nif(tex_y==68.)col=getPix(tex_x,mat4(29457.,5002.,65408.,56797.,65517.,7.,30032.,25992.,13638.,62723.,65535.,48639.,24557.,25942.,30054.,34679.));\nif(tex_y==69.)col=getPix(tex_x,mat4(4166.,23138.,65376.,52446.,65262.,127.,31168.,25975.,17494.,49169.,65535.,56047.,18941.,21335.,21588.,17783.));\n}\nelse if(tex_y<80.){\nif(tex_y==70.)col=getPix(tex_x,mat4(31948.,34592.,65333.,52463.,64988.,2047.,39216.,30855.,17238.,20497.,65535.,56783.,26623.,17238.,12852.,548.));\nif(tex_y==71.)col=getPix(tex_x,mat4(60911.,29703.,64774.,52719.,57053.,32767.,28928.,30873.,17495.,19.,65534.,61116.,18127.,4660.,4656.,0.));\nif(tex_y==72.)col=getPix(tex_x,mat4(61439.,24893.,62996.,56815.,61132.,65535.,636.,27011.,17493.,19.,61430.,65243.,9119.,292.,0.,29762.));\nif(tex_y==73.)col=getPix(tex_x,mat4(65263.,16525.,54168.,52719.,65244.,52991.,49134.,29461.,21862.,580.,57280.,65517.,4685.,1.,55906.,65535.));\nif(tex_y==74.)col=getPix(tex_x,mat4(64991.,8668.,33401.,52991.,65244.,61439.,65229.,14831.,26211.,12613.,65328.,65535.,41.,46592.,65535.,65535.));\nif(tex_y==75.)col=getPix(tex_x,mat4(64991.,4828.,13418.,57087.,65500.,61167.,56799.,61421.,22171.,4404.,63488.,65535.,6.,65493.,48639.,65534.));\nif(tex_y==76.)col=getPix(tex_x,mat4(65534.,16859.,9591.,57340.,65516.,60879.,53247.,60875.,48894.,9321.,49152.,57343.,45824.,65535.,48895.,65531.));\nif(tex_y==77.)col=getPix(tex_x,mat4(61437.,24811.,1639.,57336.,65533.,56799.,65518.,52175.,65246.,27887.,8212.,28670.,65408.,65517.,57343.,65483.));\nif(tex_y==78.)col=getPix(tex_x,mat4(53246.,28893.,1094.,57335.,61439.,52991.,61149.,53247.,56523.,65534.,925.,7923.,65531.,65213.,61439.,64956.));\nif(tex_y==79.)col=getPix(tex_x,mat4(53246.,24766.,599.,61176.,57087.,61438.,56779.,65535.,52174.,65261.,53247.,52118.,65535.,52191.,61439.,60365.));\n}\nreturn col;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nconst float n=6.; \nconst float v=4.;\n\nfloat pattern_width = 64.;\nfloat pattern_height = 80.;\n\nfloat r = iResolution.y / 2. - 10.;\nfloat mas = pattern_height / (sqrt(2.-sqrt(3.))*sqrt(3.)/2.);\n\nbool vert_move = true;\n\nvec4 col = vec4(.3, .5, .7, 1.);\n\nfloat tex_x,tex_y;\nfloat u1=0.,u2=0.;\nfloat rrk,rr,d,dk,c,s,u,uu;\nfloat ca,sa,k_1,k_2,rk5;\nfloat rxyk,rk,rk2,rmk,rmk0,xm,ym;\nfloat tt,tf,pn,r1k,r1,h,rnk1,rnk2,rn1,count,tmp,fz;\n\nfloat euc0,euc1,euc2,hyp0,hyp1,hyp2;\nvec2 kn,kn2,k0,k1,k2,k5,km,kk;\n\nfloat pi = 3.14159265;\n\nfloat per=10.;\nfloat kseq = 2. * mod(iTime,per)/per - 1.;\n\nk0 = iResolution.xy/2.;\n\nif (iMouse.z > 0.){\nfloat r_old=r;\nfloat iry=iResolution.y;\nr*=(iry+5.)/(iry+5.-abs(iMouse.y*2.-iry));\nk0.y+=(r-r_old)*sign(iry/2.-iMouse.y);\nmas = pattern_height / (sqrt(2.-sqrt(3.))*sqrt(3.)/2.);\n}\n\ntt=tan(pi/n);\ntf=tan(pi/v);\n\neuc0 = vert_move ? 0. : sqrt(1.-tf*tf*tt*tt);\nhyp0 = (1. - euc0) / (1. + euc0);\neuc1 = (1. - hyp0) / (1. + hyp0);\nu = pow((1. - euc1) / (1. + euc1), kseq);\nkn.x = (1. - u) / (1. + u);\n\neuc0 = vert_move ? sqrt((1.-tf*tf*tt*tt)/(tf*tf*(1.+tt*tt))) : 0.;\nhyp0 = (1. - euc0) / (1. + euc0);\neuc2 = (1. - hyp0) / (1. + hyp0);\nu = pow((1. - euc2) / (1. + euc2), kseq);\nkn.y = (1. - u) / (1. + u);\n\n\npn=2.*pi/n;\nr1k=tt*tt*(1.+tf*tf)/(1.-tt*tt*tf*tf);\nr1=sqrt(r1k);\nh=sqrt(r1k+1.);\nrnk1=dot(kn,kn);\nrn1=sqrt(rnk1);\nkn2=kn*2./(1.+rnk1);\nrnk2=dot(kn2,kn2);\nrk=1.;\nkk=(fragCoord.xy-k0)/r;\n\nrrk=dot(kk,kk);\n\nif(rrk<rk){\n\nrr=sqrt(rrk);\nd=(1.-rr)/(1.+rr);\ndk=d*d;\nif(rr!=0.) {c=kk.x/rr; s=kk.y/rr;}\nelse {c=1.; s=0.;}\nu=sqrt((rk-rnk1)*(rk-rnk1)+4.*rk*(kn.y*c-kn.x*s)*(kn.y*c-kn.x*s));\nca=(c*(rk-kn.x*kn.x+kn.y*kn.y)-2.*s*kn.x*kn.y)/u;\nsa=(s*(rk+kn.x*kn.x-kn.y*kn.y)-2.*c*kn.x*kn.y)/u;\ntmp=kn2.x*ca+kn2.y*sa;\nk_1=-tmp+sqrt(tmp*tmp-rnk2+rk);\nk_2=-tmp-sqrt(tmp*tmp-rnk2+rk);\nu=k_1*k_2*(dk-1.)/(dk*k_1-k_2);\nk5.x=kn2.x+u*ca; \nk5.y=kn2.y+u*sa; \nrk5=dot(k5,k5);\nif(rk5>rk) rk5=rk;\nuu=1./(1.+sqrt(rk-rk5));\nk1=k5*uu;\nrxyk=dot(k1,k1);\n\nrmk=rxyk;\nfor(float count_=0.; count_<20.; count_++)\n {\n count=count_;\n rmk0=rk;km=k1;\n for(float i=0.; i<n; i++)\n  {\n  float si = sin(2.*pi*i/n);\n  float ci = cos(2.*pi*i/n);\n  k2 = k1*mat2(ci,-si,si,ci);\n  float k_ = r1k / (k2.x*k2.x+(k2.y-h)*(k2.y-h));\n  k2.x *= k_;\n  k2.y = k_*(k2.y-h)+h;\n  rk2 = dot(k2,k2);\n  if(rk2<rmk0) {rmk0=rk2; km=k2*mat2(ci,si,-si,ci);}\n  }\n if(rmk0>rmk) break;\n rmk = rmk0; \n k1 = km;\n } \t\n\nu1 = sqrt(rmk);\nu2 = atan(k1.y,k1.x);\nif(u2<0.) u2 += 2.*pi;\n\nif(mod(count,2.)==0.) u2 += pn*0.5; \nelse u2 += pn*1.5;\t\t\n\nu2 -= 2. * pn * floor(u2 / (2. * pn)); \nif(u2 > pn) u2 = 2. * pn - u2;\n\ntex_x = mod(floor(u1*mas*sin(u2)),pattern_width);\ntex_y = mod(floor(u1*mas*cos(u2)),pattern_height);\n\ncol = getColor(tex_x,tex_y);\n}\n\nfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2fWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 35, 35, 807], [811, 811, 852, 852, 12610], [12614, 12614, 12671, 12671, 15388]]}
{"id": "XsBfDt", "name": "Watercolor 83 chars", "author": "benoitM", "description": "Second try for short shader, same technique as https://www.shadertoy.com/view/MsjfDK", "tags": ["fractal", "recursive", "inversion", "onetweet", "onetweet", "symmetries"], "likes": 25, "viewed": 1120, "date": "1502664361", "time_retrieved": "2024-06-20T19:00:09.195102", "image_code": "// Created by Benoit Marini - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 o, vec2 u){\n    o = vec4(u,iTime*9.,0);\n    for (int i=0; i++<96;)\n    o = abs( o/dot(o,o)-.9 );}", "image_inputs": [{"id": "4dlXWj", "previewfilepath": "https://soundcloud.com/cormac_carroll/heartbeats-jose-gonzales-the", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cormac_carroll/heartbeats-jose-gonzales-the", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBfDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 123, 158, 158, 244]]}
{"id": "XsBfWy", "name": "Chessboard texture - 137 chars", "author": "paulo69", "description": "Chessboard texture - 137 char", "tags": ["procedural", "2d", "texture", "animated"], "likes": 1, "viewed": 103, "date": "1501850759", "time_retrieved": "2024-06-20T19:00:09.195102", "image_code": "void mainImage(out vec4 i, in vec2 c )\n{\n\tvec2 p = c.xy / iResolution.x;\n    i = vec4 (vec3(mod(floor(p.x*iTime)+floor(p.y*iTime),2.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 40, 40, 143]]}
{"id": "XsjBRt", "name": "Mystic Flower", "author": "rigel", "description": "Just a study on color", "tags": ["2d", "noise", "color", "palette"], "likes": 25, "viewed": 962, "date": "1501694306", "time_retrieved": "2024-06-20T19:00:09.643684", "image_code": "// Author: Rigel\n// Shader: Mystic Flower\n// licence: https://creativecommons.org/licenses/by/4.0/\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n\n// radom number in 2d\nfloat hash(vec2 p) {\n  return fract(sin(dot(p,vec2(12.9898,78.2333)))*43758.5453123);\n}\n\n// noise in 2d\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// fractal noise in 2d\nfloat fbm ( vec2 p ) {\n    const mat2 m = mat2(0.8,0.6,-0.6,0.8);\n    float f = 0.0;\n    f += 0.5000*noise ( p ); p*=m*2.02;\n    f += 0.2500*noise ( p ); p*=m*2.04;\n    f += 0.1250*noise ( p ); p*=m*2.03;\n    f += 0.0650*noise ( p ); p*=m*2.01;\n\n    // normalize f;\n    f /= 0.9375;\n    return f;\n}\n\n// generates a palette with a cosine\n// from https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float domain, vec3 frequency, vec3 phase) {\n  return vec3(0.5) + vec3(0.5) * cos(TWO_PI*(frequency*domain+phase));\n}\n\nvoid mainImage(out vec4 light, in vec2 space)\t{\n  // cordinate system from -2 to 2\n  vec2 p = (-0.5 + (space.xy / iResolution.xy)) * vec2(4.0);\n  // aspect ratio\n  p.x *= iResolution.x / iResolution.y;\n\n  // angle and radius to center 0,0\n  float a = atan( p.y, abs(p.x) );\n  float r = length(p);\n\n  // space distortion\n  p += vec2(fbm(vec2(a*2.+iTime*.1,r*.4-iTime*.3)))*5.0;\n  // divide the space into cells and get cell index to seed the palette\n  float cidx = (floor(p.x+2.0) + (floor(p.y+2.0)*4.0)) / 16.0;\n  // color is from palette with cell index\n  vec3 color = pal(fbm(p*.5), vec3(1.0), vec3(0.4+cidx,0.2+cidx,0.0));\n\n  // draw a grid for the cells\n  color *= smoothstep(0.49,0.44, abs(fract(p.x)-0.5));\n  color *= smoothstep(0.49,0.44, abs(fract(p.y)-0.5));\n\n  // angular distortion\n  a += fbm(p*0.05);\n  // flower white petals\n  float f = abs(cos(a*9.)*sin(a*6.))*.7+.1;\n  float ff = smoothstep(f,f+0.05,r);\n  color = ff * color + (1.0-ff) * vec3(0.9,0.9,0.7) * (1.8-r);\n\n  // flower center\n  color = mix(color,vec3(1.,1.-r*3.,0.0),smoothstep(0.26,0.1+fbm(vec2(r+iTime,a-iTime))*0.06 ,r));\n\n  light = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[163, 185, 205, 205, 272], [274, 289, 310, 310, 556], [558, 581, 603, 603, 879], [881, 964, 1016, 1016, 1089], [1091, 1091, 1138, 1173, 2221]]}
{"id": "XsjBWc", "name": "archibate's Mandelbrot & Juila", "author": "archibate", "description": "a Mandelbrot & Juila render\nmove the mouse to the center to have a look of Mandelbrot Set.\nmove the mouse somewhere else, you'll see the Juila Set with c is the mouse position.\nthe Mandelbrot image is a bird view for so much Juila Set(s).", "tags": ["2d", "fractial"], "likes": 1, "viewed": 78, "date": "1502512431", "time_retrieved": "2024-06-20T19:00:09.643684", "image_code": "//\n// Copyfuck by (C) archibate <207773419@qq.com>\n//\n// All Fuck Reserved\n//\n// @TAG(GD_FPL)\n//\n\n#define KMAX 512\n\nvec2 csqr(vec2 z)\n{\n    return vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y);\n}\n\nint mandelblub(vec2 z, vec2 c)\n{\n    int k;\n    for (k = 0; k < KMAX; k++) {\n        if (dot(z, z) > 4.)\n            break;\n        z = csqr(z) + c;\n    }\n    return k;\n}\n\nvec4 colorOf(int k)\n{\n    float l = 1. - 0.17 * log(float(k + 1));\n    return vec4(l, l, l, 1.);\n}\n\nvec2 getXY(vec2 coord)\n{\n\tvec2 xy = coord.xy / vec2(iResolution.y);\n    xy -= vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    return 4.0 * xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 xy = getXY(fragCoord), uv = getXY(iMouse.xy);\n    vec2 z, c;\n    if (iTime != 0.) {\n        float th = iTime + 0.3;\n        float r = cos(0.4 * th);\n        c = r * vec2(cos(th), sin(th));\n        z = xy;\n    } else if (dot(uv, uv) < .01) {\n        z = vec2(0.0);\n        c = xy;\n    } else {\n        z = xy;\n        c = uv;\n    }\n    fragColor = colorOf(mandelblub(z, c));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 116, 135, 135, 193], [195, 195, 227, 227, 365], [367, 367, 388, 388, 465], [467, 467, 491, 491, 615], [617, 617, 672, 672, 1057]]}
{"id": "XsjBWV", "name": "Under the Arctic Sea", "author": "somesuch", "description": "Minor modification of shader by revers - \"Noise 3D Fly Through\" https://www.shadertoy.com/view/4ddXW4", "tags": ["tunnel"], "likes": 6, "viewed": 164, "date": "1502251514", "time_retrieved": "2024-06-20T19:00:10.862073", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader, as always, uses a lot of code (raymarching, noise and lighting) credited to iq \n * [ https://www.shadertoy.com/view/Xds3zN ]. \n * Camera path is based on Shane's \"Subterranean Fly-Through\" [ https://www.shadertoy.com/view/XlXXWj ].\n * Additional specular lighting trick is based on \"Wet stone\" by TDM [ https://www.shadertoy.com/view/ldSSzV ].\n * Thanks for sharing great code guys!\n * \n * The shader was created and exported from Synthclipse [ http://synthclipse.sourceforge.net/ ].\n */\nconst float FOV = 1.5;\nconst float MarchDumping = 0.7579;\nconst float Far = 38.925;\nconst int MaxSteps = 128;\nconst float CameraSpeed = 2.5099998;\nconst float TunnelSmoothFactor = .5;\nconst float TunnelRadius = 2.85660005;\nconst float TunnelFreqA = 0.18003;\nconst float TunnelFreqB = 0.25;\nconst float TunnelAmpA = 3.6230998;\nconst float TunnelAmpB = 2.4324;\nconst float NoiseIsoline = 0.319;\nconst float NoiseScale = 2.9980001;\nconst vec3 Color = vec3(0.085, 0.658, 1.0);\n\n#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise(p);\n\n\treturn f;\n}\n\n// by iq. http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// From \"Subterranean Fly-Through\" by Shane https://www.shadertoy.com/view/XlXXWj\nvec2 path(float z) {\n\treturn vec2(TunnelAmpA * sin(z * TunnelFreqA), TunnelAmpB * cos(z * TunnelFreqB));\n}\n\nfloat noiseDist(vec3 p) {\n\tp = p / NoiseScale;\n\treturn (fbm(p) - NoiseIsoline) * NoiseScale;\n}\n\nvec2 map(vec3 p) {\n\tfloat d = noiseDist(p);\n\tfloat d2 = length(p.xy - path(p.z)) - TunnelRadius;\n\td = smax(d, -d2, TunnelSmoothFactor);\n\n\tvec2 res = vec2(d, M_NOISE);\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = M_NONE;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = M_NONE;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 10.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\t// material\n\t\tcol = Color + sin(t * 0.1) * 0.2;\n\t\tcol += 0.3 * sin(vec3(0.15, 0.02, 0.10) * iTime * 6.0);\n\n\t\t// lighitng\n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = -rd;\n\t\tfloat amb = clamp(0.5 + 0.005 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);\n\t\tbrdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\t// Additional specular lighting trick,\n\t\t// taken from \"Wet stone\" by TDM\n\t\t// https://www.shadertoy.com/view/ldSSzV\n\t\tnor = normalize(nor - normalize(pos) * 0.2);\n\t\tref = reflect(rd, nor);\n\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\t\tbrdf += 2.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\tbrdf += 0.40 * amb * vec3(0.00, 0.70, 1.00) * occ;\n\t\tbrdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n\t\tcol = col * brdf;\n\n\t\tcol = mix(col, vec3(0.0), 1.0 - exp(-0.005 * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 rotationZ(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\n\treturn mat3(ca, sa, 0.0, -sa, ca, 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tcoord *= FOV;\n\n    float t = iTime * CameraSpeed + 4.0 * 60.0;\n    vec3 ro = vec3(path(t), t);\n\n    t += 0.5;\n    vec3 target = vec3(path(t), t);\n    vec3 dir = normalize(target - ro);\n    vec3 up = vec3(-0.9309864, -0.33987653, 0.1332234) * rotationZ(iTime * 0.05);\n    vec3 upOrtho = normalize(up - dot(dir, up) * dir);\n    vec3 right = normalize(cross(dir, upOrtho));\n\n    vec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjBWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1171, 1192, 1192, 1233], [1235, 1235, 1256, 1256, 1600], [1602, 1602, 1621, 1621, 1749], [1751, 1810, 1849, 1849, 1946], [1948, 2030, 2050, 2050, 2136], [2138, 2138, 2163, 2163, 2232], [2234, 2234, 2252, 2252, 2415], [2417, 2417, 2449, 2449, 2768], [2770, 2770, 2830, 2830, 3073], [3075, 3075, 3102, 3102, 3318], [3320, 3320, 3354, 3354, 3613], [3615, 3615, 3646, 3646, 4925], [4927, 4927, 4952, 4952, 5051], [5053, 5053, 5108, 5108, 5761]]}
{"id": "XsjfDG", "name": "Plant or Starfish?", "author": "rms80", "description": "demo made for GenArtHackParty4: http://art4.genarthackparty.com/\n\nYou can click-drag left/right on the scene to change the viewpoint (ish)\n\nBased on Inigo Quilez's Raymarching Primitives demo:\nhttps://www.shadertoy.com/view/Xds3zN ", "tags": ["procedural", "3d", "distancefield", "implicitsurface"], "likes": 16, "viewed": 922, "date": "1501986695", "time_retrieved": "2024-06-20T19:00:13.625660", "image_code": "// Derivative of Inigo Quilez's Raymarching - Primitives:\n//    https://www.shadertoy.com/view/Xds3zN\n// Edits Copyright (c) 2017 Ryan Schmidt\n// Edits released under MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Original License follows\n\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 smin2( vec2 va, vec2 vb, float k )\n{\n    float a = va.x; float b = vb.x; \n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    float f = mix( b, a, h ) - k*h*(1.0-h);\n    float c = mix( vb.y, va.y, h);\n    return vec2(f,c);\n}\nvec2 opBlend(vec2 d1, vec2 d2, float power) \n{\n    return smin2(d1,d2,power);\n}\n\n\n//------------------------------------------------------------------\n\nvec4 quat_identity() {\n    return vec4(0,0,0,1);\n}\n\n\nvec4 quat_from_to(vec3 from, vec3 to) {\n    vec4 result;\n    from = normalize(from);\n    to = normalize(to);\n    vec3 bisector = normalize(from + to);\n    float w = dot(from, bisector);\n    if (w != 0.0) {\n        result = vec4(cross(from,bisector), w);\n    } else {\n        if (abs(from.x) >= abs(from.y)) {\n            // V1.x or V1.z is the largest magnitude component.\n            float invLength = 1.0 / sqrt(from.x * from.x + from.z * from.z);\n            result = vec4(-from.z * invLength, 0.0, from.x * invLength, w);\n        } else {\n            // V1.y or V1.z is the largest magnitude component.\n            float invLength = 1.0 / sqrt(from.y * from.y + from.z * from.z);\n            result = vec4(0.0, from.z * invLength, -from.y * invLength, w);\n        }\n    }\n    //Normalize();   // aaahhh just to be safe...  \n    return result;  \n}\n\nvec4 quat_from_axis_angle(vec3 axis, float angle) \n{\n    float halfAngle = 0.5 * angle;\n    float sn = sin(halfAngle);\n    return vec4(sn*axis.x, sn*axis.y, sn*axis.z, cos(halfAngle));\n}\n\nvec3 quat_x(vec4 q) {\n    float twoY = 2.0 * q.y; float twoZ = 2.0 * q.z;\n    float twoWY = twoY * q.w; float twoWZ = twoZ * q.w;\n    float twoXY = twoY * q.x; float twoXZ = twoZ * q.x;\n    float twoYY = twoY * q.y; float twoZZ = twoZ * q.z;\n    return vec3(1.0 - (twoYY + twoZZ), twoXY + twoWZ, twoXZ - twoWY);    \n}\nvec3 quat_y(vec4 q) {\n    float twoX = 2.0 * q.x; float twoY = 2.0 * q.y; float twoZ = 2.0 * q.z;\n    float twoWX = twoX * q.w; float twoWZ = twoZ * q.w; float twoXX = twoX * q.x;\n    float twoXY = twoY * q.x; float twoYZ = twoZ * q.y; float twoZZ = twoZ * q.z;\n    return vec3(twoXY - twoWZ, 1.0 - (twoXX + twoZZ), twoYZ + twoWX);    \n}\nvec3 quat_z(vec4 q) {\n    float twoX = 2.0 * q.x; float twoY = 2.0 * q.y; float twoZ = 2.0 * q.z;\n    float twoWX = twoX * q.w; float twoWY = twoY * q.w; float twoXX = twoX * q.x;\n    float twoXZ = twoZ * q.x; float twoYY = twoY * q.y; float twoYZ = twoZ * q.y;\n    return vec3(twoXZ + twoWY, twoYZ - twoWX, 1.0 - (twoXX + twoYY));\n}\nvec3 quat_mul(vec4 q, vec3 v) {\n    float twoX = 2.0 * q.x; float twoY = 2.0 * q.y; float twoZ = 2.0 * q.z;\n    float twoWX = twoX * q.w; float twoWY = twoY * q.w; float twoWZ = twoZ * q.w;\n    float twoXX = twoX * q.x; float twoXY = twoY * q.x; float twoXZ = twoZ * q.x;\n    float twoYY = twoY * q.y; float twoYZ = twoZ * q.y; float twoZZ = twoZ * q.z;\n    return vec3(\n        v.x * (1.0 - (twoYY + twoZZ)) + v.y * (twoXY - twoWZ) + v.z * (twoXZ + twoWY),\n        v.x * (twoXY + twoWZ) + v.y * (1.0 - (twoXX + twoZZ)) + v.z * (twoYZ - twoWX),\n        v.x * (twoXZ - twoWY) + v.y * (twoYZ + twoWX) + v.z * (1.0 - (twoXX + twoYY))); ;    \n}\n\nvec4 quat_mul(vec4 a, vec4 b) {\n    float w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n    float x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;\n    float y = a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z;\n    float z = a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x;\n    return vec4(x, y, z, w);    \n}\n\n\nstruct frame3f {\n    vec3 origin;\n    vec4 rotation;\n};\n\nframe3f make_frame(vec3 o, vec3 z) {\n    frame3f f;\n    f.origin = o;\n    f.rotation = quat_from_to(vec3(0,0,1), z);\n    return f;\n}\nframe3f set_frame(vec3 o, vec4 rot) {\n    frame3f f;\n    f.origin = o;\n    f.rotation = rot;\n    return f;\n}\n\nvec3 from_frame_p(frame3f f, vec3 p) {\n    return quat_mul(f.rotation, p) + f.origin;\n}\nvec3 from_frame_v(frame3f f, vec3 v) {\n    return quat_mul(f.rotation, v);\n}\n\n\nvec3 circlePath(float rad, float height, float revPerS, float time) {\n    float a = revPerS * time * 6.28318531;\n    return vec3( rad * cos(a), height, rad * sin(a) );\n}\nvec3 circlePath(frame3f frame, float rad, float revPerS, float time) {\n    float a = revPerS * time * 6.28318531;\n    float x = rad * cos(a); float y = rad * sin(a);\n    return frame.origin + x*quat_x(frame.rotation) + y*quat_y(frame.rotation);\n}\n\n\nvec2 map( in vec3 pos )\n{\n    float groundMat = 1.0;\n    vec2 groundPlane = vec2(sdPlane(pos), groundMat);\n\n    float sphereR = 0.2;\n    float pathRMin = 0.0;\n    float pathRMax = 0.5;\n    float blendmin = 0.7;\n    float blendmax = 0.2;\n\n    vec2 shapes = vec2(0,0);\n    int shape_i = 0;\n    int N = 10;\n    for ( int kk = 0; kk < 5; ++kk ) {\n        float tk = float(kk)/5.0;\n        tk += iTime/20.0;\n        vec4 rotAround = quat_from_axis_angle(vec3(0,1,0), tk*2.0*M_PI);\n        frame3f arcFrame = set_frame(vec3(0,0,0), rotAround);\n\n        for ( int i = 0; i < 10; ++i ) {\n            float t = float(i) / 10.0;\n\n            float cr = 2.0;\n            float ca = 2.5*t;\n            float cx = cr*cos(ca);\n            float cy = cr*sin(ca);\n            vec3 ct = vec3(cr,0,0);\n            vec2 n = normalize(vec2(-cy,cx));\n\n            float h = float(i) * 2.0 * sphereR;\n\n            float useR = sphereR + 0.05*(1.0+cos(t));\n\n            vec3 arcpos = vec3(cx,cy,0) - ct;\n            vec3 arcdir = vec3(n.x, n.y, 0);\n            arcpos = from_frame_p(arcFrame, arcpos);\n            arcdir = from_frame_v(arcFrame, arcdir);\n            frame3f f = make_frame(arcpos, arcdir);\n\n            vec3 spherePos = circlePath(f, mix(pathRMin,pathRMax,t), 0.5, iTime + t );\n            float sphereMat = float(i+1) * 10.0;\n\n            vec3 dv = pos - spherePos;\n            vec2 sphereF = vec2( sdSphere(dv, useR), sphereMat);\n            \n            if ( shape_i == 0 ) {\n                shapes = sphereF;\n            } else {\n                shapes = opBlend(sphereF, shapes, mix(blendmin,blendmax,t)); \n                //shapes = opU(sphereF, shapes); \n            }\n            shape_i++;\n\n        }\n    }\n\n\n    //vec2 final = opU(groundPlane, shapes);\n    vec2 final = shapes;\n    //vec2 final = groundPlane;\n        \n    return final;\n}\n\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 3.0;\n    float tmax = 15.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (-2.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (3.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>3.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<10; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = vec3(0,0,0);\n        //ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = 1.0;//calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        //dif *= softshadow( pos, lig, 0.02, 2.5 );\n        //dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        float camH = 6.0;\n        float camD = 4.5;\n        float camTime = 0.0;//time;\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*camTime + 6.0*mo.x), camH + 2.0*mo.y, camD + 4.0*sin(0.1*camTime + 6.0*mo.x) );\n        vec3 ta = vec3( 0, 1.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2630, 2748, 2773, 2773, 2788], [2790, 2790, 2825, 2825, 2851], [2853, 2853, 2884, 2884, 2975], [2977, 2977, 3020, 3020, 3080], [3082, 3082, 3127, 3127, 3169], [3171, 3171, 3204, 3204, 3259], [3261, 3261, 3297, 3297, 3539], [3541, 3541, 3593, 3593, 3707], [3709, 3709, 3745, 3745, 3993], [3995, 3995, 4031, 4031, 4130], [4132, 4132, 4170, 4170, 4339], [4341, 4341, 4413, 4413, 4628], [4630, 4630, 4697, 4736, 5108], [5110, 5110, 5135, 5135, 5172], [5174, 5174, 5199, 5199, 5257], [5259, 5259, 5284, 5284, 5349], [5351, 5351, 5386, 5386, 5457], [5459, 5459, 5494, 5494, 5565], [5567, 5567, 5604, 5604, 5657], [5659, 5729, 5762, 5762, 5788], [5790, 5790, 5820, 5820, 5853], [5855, 5855, 5885, 5885, 5914], [5916, 5916, 5940, 5940, 6072], [6074, 6074, 6115, 6115, 6208], [6209, 6209, 6250, 6250, 6440], [6441, 6441, 6487, 6487, 6520], [6523, 6593, 6615, 6615, 6643], [6646, 6646, 6685, 6685, 7496], [7498, 7498, 7550, 7550, 7684], [7686, 7686, 7707, 7707, 8003], [8004, 8004, 8025, 8025, 8341], [8342, 8342, 8363, 8363, 8675], [8676, 8676, 8707, 8707, 9316], [9318, 9318, 9349, 9349, 9628], [9688, 9688, 9724, 9724, 9820], [9821, 9821, 9858, 9858, 9929], [9931, 9931, 9969, 9969, 10018], [10019, 10019, 10057, 10057, 10095], [10098, 10098, 10167, 10167, 10267], [10268, 10268, 10338, 10338, 10514], [10517, 10517, 10542, 10542, 12359], [12365, 12365, 12405, 12405, 13025], [13029, 13029, 13103, 13103, 13363], [13365, 13365, 13397, 13397, 13836], [13838, 13838, 13880, 13880, 14179], [14181, 14181, 14220, 14220, 15830], [15832, 15832, 15884, 15884, 16061], [16063, 16063, 16120, 16120, 17181]]}
{"id": "Xsjfzt", "name": "Колесюга", "author": "nolibab", "description": "super wheel!", "tags": ["rotation", "whell"], "likes": 0, "viewed": 119, "date": "1501709922", "time_retrieved": "2024-06-20T19:00:13.625907", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat u;\nvec4 col;\nfloat r0 = iResolution.y / 2.  - (1.2+cos(iTime))*50.;\nvec2 d = fragCoord.xy - iResolution.xy / 2.;\nfloat r = length(d);\nif(r<r0)\n{\nu = atan(d.y,d.x) * 15./3.14159 + iTime*4.;\ncol=vec4(vec3(step(.5,fract(u))),1.);\n}\nfragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xsjfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 311]]}
{"id": "XsSBRd", "name": "Circles from mouse", "author": "kig", "description": "2D UI effects", "tags": ["2d"], "likes": 1, "viewed": 74, "date": "1501595428", "time_retrieved": "2024-06-20T19:00:13.625907", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(cos(max(length(fragCoord.xy - iMouse.xy), 7.0)*(0.8+0.2*sin(2.0*iTime+0.003*pow(length(fragCoord.xy - iMouse.xy), 0.1)))));\n    fragColor *= 0.3;\n    fragColor.r *= min(1.0, length(fragCoord.xy - iMouse.xy)/60.0);\n    fragColor.gb *= 1.0+3.0*(1.0-min(1.0, length(fragCoord.xy - iMouse.xy)/60.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSBRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 374]]}
{"id": "XsSfWV", "name": "Bat Signal", "author": "k_kondrak", "description": "Tim Burton's 1989 Batman signal in the night sky.", "tags": ["procedural", "2d", "sdf", "batman"], "likes": 4, "viewed": 613, "date": "1502141666", "time_retrieved": "2024-06-20T19:00:14.274477", "image_code": "// ----------------------------------------------------\n//  \"Bat Signal\" by Krzysztof Kondrak @k_kondrak\n// ----------------------------------------------------\n\n// ----------------------------------------------------------------\n//  modified \"Batman Logo\" - https://www.shadertoy.com/view/ldXSDB\n// ----------------------------------------------------------------\nfloat ellipse(in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady)\n{\n\tvec2  q = p - vec2(x, y);\n\tfloat u = dot( q, vec2(dirx, diry));\n\tfloat v = dot( q, vec2(diry, dirx) * vec2(-1.0, 1.0));\n\treturn dot(vec2(u*u, v*v),vec2(1.0/(radx*radx), 1.0/(rady*rady))) - 1.0;\n}\n\nfloat box(in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady)\n{\n\tvec2  q = p - vec2(x, y);\n\tfloat u = dot( q, vec2(dirx, diry));\n\tfloat v = dot( q, vec2(diry, dirx) * vec2(-1.0, 1.0));\n\tvec2  d = abs(vec2(u, v)) - vec2(radx, rady);\n\treturn max(d.x, d.y);\n}\n\nfloat fillEllipse(in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady)\n{\n\tfloat d = ellipse(p, x, y ,dirx, diry, radx, rady);\n    float w = fwidth(d);\n\treturn 1.0 - smoothstep( -w, w, d);\n}\n\nfloat fillRectangle(in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady)\n{\n\tfloat d = box(p, x, y, dirx, diry, radx, rady);\n    float w = fwidth(d);\n\treturn 1.0 - smoothstep( -w, w, d);\n}\n\nfloat BatLogo(in vec2 p)\n{\n\tp.x = abs(p.x);\n    p.x *= 1.0 + 0.05 * p.x * sin(2.0 * iTime + 0.0);\n    p.y *= 1.0 + 0.05 * p.x * sin(2.0 * iTime + 1.3);\t\n\t\n\tfloat f = 1.0;\n\t\n\tf = mix( f, 0.0,     fillEllipse(   p, 0.000, 0.000,  1.0, 0.0, 0.500, 0.488) );\n\tf = mix( f, 1.0,     fillEllipse(   p, 0.188, 0.300,  1.0, 0.0, 0.089, 0.167) );\n\tf = mix( f, 1.0,     fillRectangle( p, 0.170, 0.400,  1.0, 0.0, 0.070, 0.100) );\n\tf = mix( f, 1.0,     fillRectangle( p, 0.000, 0.460,  1.0, 0.0, 0.040, 0.100) );\n\tf = mix( f, 1.0,     fillRectangle( p, 0.036, 0.448,  0.6, 0.8, 0.065, 0.057) );\n\tf = mix( f, 1.0,     fillEllipse(   p, 0.095,-0.450,  1.0, 0.0, 0.097, 0.333) );\n\tf = mix( f, 1.0,     fillEllipse(   p, 0.180,-0.350, -1.0, 0.5, 0.100, 0.278) );\n    f = mix( f, 0.0, 1.0-fillEllipse(   p, 0.000, 0.000,  1.0, 0.0, 0.550, 0.550) );\n\n\treturn f;\n}\n\n// --------------------\n//  sold spotlight ray\n// --------------------\nfloat Spotlight(in vec2 p)\n{\n    vec2 q = p;\n    q.x = abs(q.x);\n    q.x *= 1.0 + 0.05 * q.x * sin(2.0 * iTime + 0.0);\n    q.y *= 1.0 + 0.05 * q.x * sin(2.0 * iTime + 1.3);\n    float r = mix( 1.0, 0.0, 1.0-fillEllipse(q, 0.000, 0.000,  1.0, 0.0, 0.550, 0.550) );\n\tfloat f = 1.0;\n\t\n\tf = mix(f, 0.0, 1.0-fillRectangle( p, 0.75, -0.5,  -0.015, 0.01, 0.045, 0.00975) );\n    f = mix(f, 0.0, r);\n    f = mix(f, 0.0, fillRectangle( p, -0.75, 0.5,  -0.015, 0.01, 0.0175, 0.00995) );\n    f = mix(f, 1.0, r);\n    f = mix(f, 0.0, fillRectangle( p, 1.335, 0.05,  -0.013, 0.015, 0.07, 0.00975) );\n\n\treturn f;\n}\n\n// ----------------------\n//  spotlight \"god rays\"\n// ----------------------\nfloat SpotRays(in vec2 raySrc, in vec2 rayDir, in vec2 pos, in float speed)\n{\n\tfloat cosAngle = dot(normalize(pos - raySrc), rayDir);\n\t\n\treturn clamp(0.75 + 0.2  * sin( cosAngle * 66.22 + iTime * speed) +\n\t\t\t \t      + 0.15 * cos(-cosAngle * 43.11 + iTime * speed), 0.0, 1.0) *\n\t\t\t \t clamp((pos.x - length(pos - raySrc)) / pos.x, 0.5, 1.0);\n}\n\n// -----------\n//  night sky\n// -----------\nvec3 Sky(in vec2 pos)\n{\n    vec2 offset = vec2(0.004*iTime,0.0);\n    vec3 color  = vec3(1.0);\n\n    for(int i = 0; i < 3; i++) \n    {\n        color += mix(texture(iChannel0, pos - 0.25 * offset + 0.5),\n                     texture(iChannel0, pos - offset), \n                     abs(mod(float(i) * 0.666, 2.0) - 1.0)).xyz * color * color;\n    }\n\n    return color * vec3(.0111, 0.0111, .06);\n}\n\n\n// --------------------------\n//  Bat Signal - ray + symbol\n// --------------------------\nvec3 BatSignal(in vec2 uv, in vec2 pos, in float scale, in vec3 bgColor)\n{\n    vec2 rayOffset = vec2(2.6, -2.3);\n    vec2 p  = (uv + pos) * scale;\n\tfloat f = 0.5 * BatLogo(p) + 0.2 * Spotlight(p);\n    f *= bgColor.x + bgColor.y + bgColor.z;\n\t\t\n    return vec3(f) * SpotRays(pos, normalize(vec2(1.0, -0.11)), -uv + rayOffset/scale, 1.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy)/iResolution.y;\n    vec3 color = Sky(p * 0.0322);\n\n    color += BatSignal(p, vec2(0.55, -0.35), 1.1, color) * 3.5;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsSfWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[162, 365, 475, 475, 672], [674, 674, 780, 780, 973], [975, 975, 1089, 1089, 1206], [1208, 1208, 1324, 1324, 1437], [1439, 1439, 1465, 1465, 2284], [2286, 2357, 2385, 2385, 2954], [2956, 3033, 3110, 3110, 3374], [3376, 3420, 3443, 3443, 3811], [3814, 3904, 3978, 3978, 4242], [4245, 4245, 4302, 4302, 4502]]}
{"id": "XtfczN", "name": "Alphaville", "author": "dr2", "description": "An alphabetic version of \"Urban Growth\" (look around using mouse)", "tags": ["font", "architecture", "cityscape", "cellmarch"], "likes": 51, "viewed": 2928, "date": "1503597997", "time_retrieved": "2024-06-20T19:00:14.298617", "image_code": "// \"Alphaville\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txFnt iChannel0\n\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat IFbm1 (float p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat PrOBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nmat3 vuMat;\nvec3 vuPos, qHit, sunDir;\nvec2 iqBlk, cTimeV, qnTex;\nfloat dstFar, tCur, qcCar, cDir, flrHt;\nint idObj;\nconst float pi = 3.14159;\nconst int idBldg = 1, idBldgRf = 2, idRoad = 3, idSWalk = 4, idCarWhl = 5,\n   idCarBdy = 6, idTrLight = 7;\n\nfloat TrLightDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xz = abs (fract (q.xz) - vec2 (0.5)) - vec2 (0.345);\n  q.y -= 0.023;\n  d = PrCylDf (q.xzy, 0.002, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idTrLight;  qHit = q; }\n  return dMin;\n}\n\nfloat FontTexDf (vec2 p, int ic)\n{\n  vec3 tx;\n  float d;\n  tx = texture (txFnt, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + p) * (1. / 16.), 1.)).gba - 0.5;\n  qnTex = vec2 (tx.r, - tx.g);\n  d = tx.b + 1. / 256.;\n  return d;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 ip;\n  float d, df, bHt, bHtFac;\n  ip = floor (p.xz);\n  bHtFac = 0.01 + 0.99 * SmoothBump (0.15, 0.85, 0.1, \n     mod (0.03 * tCur + 0.2 * length (floor ((ip + 8.) / 16.)), 1.));\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = idRoad;  qHit = p;  iqBlk = ip; }\n  q = p;\n  q.xz = fract (q.xz) - vec2 (0.5);\n  bHt = (0.5 * Hashfv2 (13. * ip) + 0.05) * (1. + 0.15 / flrHt) + 0.1;\n  bHt = (floor (bHt * bHtFac / flrHt) + 0.2) * flrHt;\n  q.y -= 0.0015;\n  d = PrOBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  if (d < dMin) { dMin = d;  idObj = idSWalk;  qHit = p; }\n  q.y -= 0.0015;\n  q.y -= bHt - 0.2 * flrHt - 0.001;\n  int ic = int (Hashfv2 (17. * floor (p.xz)) * 26.);\n  if (ic == 16) ++ ic;\n  df = FontTexDf (fract (p.xz), 0x41 + ic);\n  d = max (df, abs (q.y) - bHt);\n  if (d < dMin) {\n    dMin = d;\n    idObj = (d == df) ? idBldg : idBldgRf;\n    qHit = q;\n    iqBlk = ip;\n  }\n  if (bHtFac > 0.1) dMin = TrLightDf (p, dMin);\n  return dMin;\n}\n\nvec4 CarPos (vec3 p)\n{\n  vec3 q;\n  float vDir, cCar;\n  if (cDir == 0. && abs (fract (p.z) - 0.5) > 0.35 ||\n     cDir == 1. && abs (fract (p.x) - 0.5) < 0.35) {\n    p.xz = vec2 (- p.z, p.x);\n    vDir = 0.;\n  } else {\n    vDir = 1.;\n  }\n  q = p;\n  q.y -= -0.003;\n  q.z += 3. * floor (q.x);\n  q.x = fract (q.x) - 0.5;\n  q.z *= 2. * step (0., q.x) - 1.;\n  q.z -= cTimeV.x + ((cDir == vDir) ? vDir + cTimeV.y : 1.);\n  cCar = floor (20. * q.z);\n  q.z = fract (q.z) - 0.5;\n  q.x = abs (q.x) - 0.395 - 0.06 * step (0.7, Hashff (11. * cCar)) -\n     0.03 * Hashff (13. * cCar);\n  return vec4 (q, cCar);\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec4 q4;\n  vec3 q;\n  float d, bf;\n  q4 = CarPos (p);\n  q = q4.xyz;\n  bf = PrOBoxDf (q + vec3 (0., 0., -0.1), vec3 (0.015, 0.05, 0.2));\n  q.z = mod (q.z, 0.05) - 0.025;\n  d = SmoothMin (PrOBoxDf (q + vec3 (0., -0.008, 0.), vec3 (0.007, 0.002, 0.015)),\n     PrOBoxDf (q + vec3 (0., -0.015, 0.003), vec3 (0.0035, 0.0003, 0.005)), 0.02);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObj = idCarBdy;  qHit = q;  qcCar = q4.w; }\n  q.xz = abs (q.xz) - vec2 (0.0085, 0.01);\n  q.y -= 0.006;\n  d = max (PrCylDf (q.yzx, 0.003, 0.0012), bf);\n  if (d < dMin) { dMin = d;  idObj = idCarWhl;  qHit = q; }\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = CarDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = 1. - 2. * step (0., rd.xz);\n  dda = - srd / (rd.xz + 0.0001);\n  dHit = 0.;\n  for (int j = 0; j < 240; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = ObjDf (p);\n    dHit += min (d, 0.02 + max (0., min (h.x, h.y)));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 40; j ++) {\n    h = BldgDf (ro + rd * d, dstFar);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, sd;\n  rd.y = (rd.y + 0.1) / 1.1;\n  rd = normalize (rd);\n  if (rd.y >= 0.) {\n    p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;\n    p.xz += 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    d = fd;\n    ds *= fd;\n    for (int j = 0; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n    sunCol = vec3 (1., 0.8, 0.7) * pow (sd, 1024.) +\n       vec3 (1., 0.4, 0.2) * pow (sd, 256.);\n    col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) *\n       max (rd.y - 0.1, 0.))) + 0.3 * sunCol;\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  } else col = vec3 (0.6);\n  return col;\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec3 col;\n  vec2 g, b;\n  float wFac, f, ff, spec;\n  wFac = 1.;\n  col = vec3 (0.);\n  spec = 0.;\n  if (idObj == idBldg || idObj == idBldgRf) {\n    col = HsvToRgb (vec3 (0.7 * Hashfv2 (19. * iqBlk), 0.2,\n       0.4 + 0.2 * Hashfv2 (21. * iqBlk)));\n    if (idObj == idBldg) {\n      f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n      wFac = 1. - (step (0., f) - 0.5) * step (abs (abs (f) - 0.24), 0.02) -\n         0.801 * step (abs (f), 0.22);\n      if (wFac < 0.2) {\n        f = 1.5 * dot (qHit.xz, normalize (vn.zx));\n        wFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n           (1. + Hashfv2 (51. * iqBlk))), 1.);\n      }\n      col *= wFac;\n      if (wFac > 0.5) col *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n      spec = 0.3;\n    } else {\n      g = step (0.05, fract (qHit.xz * 70.));\n      col *= mix (0.8, 1., g.x * g.y);\n    }\n  } else if (idObj == idSWalk) {\n    g = step (0.05, fract (qHit.xz * 35.));\n    col = vec3 (0.2) * mix (0.7, 1., g.x * g.y);\n  } else if (idObj == idTrLight) {\n    f = 2. * (atan (qHit.z, qHit.x) / pi + 1.) + 0.5;\n    ff = floor (f);\n    if (abs (qHit.y - 0.014) < 0.004 && abs (f - ff) > 0.3) {\n      col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n         (mod (ff, 2.) == 0.) ? cDir : 1. - cDir);\n      spec = -2.;\n    } else {\n      col = vec3 (0.4, 0.2, 0.1);\n      spec = 0.5;\n    }\n  } else if (idObj == idCarBdy) {\n    col = HsvToRgb (vec3 (Hashff (qcCar * 37.), 0.9,\n       0.4 + 0.6 * vec3 (Hashff (qcCar * 47.))));\n    f = abs (qHit.z + 0.003);\n    wFac = max (max (step (0.001, f - 0.005) * step (0.001, abs (qHit.x) - 0.0055),\n       step (f, 0.001)), step (0.0015, abs (qHit.y - 0.0145)));\n    col *= wFac;\n    spec = 0.5;\n    if (abs (qHit.z) > 0.015) {\n      g = vec2 (qHit.x, 3. * (qHit.y - 0.008));\n      if (qHit.z > 0. && dot (g, g) < 3.6e-5) col *= 0.3;\n      g = vec2 (abs (qHit.x) - 0.005, qHit.y - 0.008);\n      f = dot (g, g);\n      if (qHit.z > 0. && f < 2.2e-6) {\n        col = vec3 (1., 1., 0.3);\n        spec = -2.;\n      } else if (qHit.z < 0. && f < 1.1e-6) {\n        col = vec3 (1., 0., 0.);\n        spec = -2.;\n      }\n    }\n  } else if (idObj == idCarWhl) {\n    if (length (qHit.yz) < 0.0015) {\n      col = vec3 (0.7);\n      spec = 0.8;\n    } else {\n      col = vec3 (0.03);\n    } \n  } else if (idObj == idRoad) {\n    g = abs (fract (qHit.xz) - 0.5);\n    if (g.x < g.y) g = g.yx;\n    col = mix (vec3 (0.05), vec3 (0.08), step (g.x, 0.355));\n    f = ((step (abs (g.x - 0.495), 0.002) + step (abs (g.x - 0.365), 0.002)) +\n       step (abs (g.x - 0.44), 0.0015) * step (fract (g.y * 18. + 0.25), 0.7)) *\n       step (g.y, 0.29);\n    col = mix (col, vec3 (0.5, 0.4, 0.1), f);\n    f = step (0.6, fract (g.x * 30. + 0.25)) * step (0.36, g.x) *\n       step (abs (g.y - 0.32), 0.02);\n    col = mix (col, vec3 (0.6), f);\n    b = CarPos (ro).xz;\n    g = abs (b + vec2 (0., -0.1)) - vec2 (0.015, 0.2);\n    b.y = mod (b.y, 0.05) - 0.025;\n    b = abs (b) * vec2 (1.55, 1.);\n    if (max (g.x, g.y) < 0. && max (b.x, b.y) < 0.016) col *= 0.6;\n  }\n  if (wFac < 0.5) {\n    rd = reflect (rd, vn);\n    g = Rot2D (rd.xz, 5.1 * atan (20. + iqBlk.y, 20. + iqBlk.x));\n    f = step (1., 0.5 * ro.y + 3. * rd.y -\n       0.1 * floor (5. * IFbm1 (0.4 * atan (g.y, g.x) + pi) + 0.05));\n    if (f == 1.) col = 0.8 * BgCol (ro, rd);\n    else col = vec3 (0.1, 0.05, 0.);\n    spec = -1.;\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn;\n  float dstHit, sh;\n  int idObjT;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    if (idObj == idBldg) vn = normalize (vec3 (qnTex.x, 0.00001, qnTex.y));\n    else vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, rd, vn);\n    col = objCol.rgb;\n    if (objCol.a >= 0.) {\n      if (idObj == idRoad) vn = VaryNf (500. * qHit, vn, 2.);\n      else if (idObj == idBldg || idObj == idBldgRf)\n         vn = VaryNf (500. * qHit, vn, 0.5);\n      sh = 0.2 + 0.8 * ObjSShadow (ro, sunDir);\n      col = col * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.) +\n         sh * objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.));\n      col *= vec3 (1., 0.8, 0.6);\n    } else if (objCol.a == -1.) {\n      if (idObj == idBldg || idObj == idBldgRf) col *= 0.6;\n    }\n    col = mix (col, BgCol (ro, rd), smoothstep (0.4, 1., dstHit / dstFar));\n  } else col = BgCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.6));\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float pLen, s, cCount;\n  pLen = 2.;\n  t *= 10.;\n  p.y = 0.2 + 1.7 * SmoothBump (0.2, 0.8, 0.1, mod (0.08 * t, 1.));\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= pLen;\n  return p;\n}\n\nvec4 FlyPR (float s)\n{\n  vec3 fpF, fpB, vd;\n  float ds;\n  ds = 0.02;\n  fpF = TrackPath (s + ds);\n  fpB = TrackPath (s - ds);\n  vd = fpF - fpB;\n  return vec4 (0.5 * (fpF + fpB), - (atan (vd.z, vd.x) - 0.5 * pi));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, flDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, cTime;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.02 * pi;\n  az = 0.02 * pi;\n  if (mPtr.z > 0.) {\n    el += clamp (pi * mPtr.y, -0.4 * pi, 0.35 * pi);\n    az += clamp (2. * pi * mPtr.x, - pi, pi);\n  }\n  flDat = FlyPR (0.015 * tCur);\n  ro = flDat.xyz;\n  ro.xz += 0.01;\n  ori = vec2 (el, az + flDat.w);\n  dstFar = 50.;\n  flrHt = 0.07;\n  sunDir = normalize (vec3 (1., 0.5, -1.));\n  cTime = 0.15 * mod (tCur, 80.);\n  cDir = mod (floor (cTime), 2.);\n  cTimeV = vec2 (floor (0.5 * floor (cTime)), mod (cTime, 1.));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  col = ShowScene (ro, rd);\n  if (mPtr.z > 0. && max (abs (uv.x), abs (uv.y)) < 0.05 &&\n     min (abs (uv.x), abs (uv.y)) < 0.003) col = mix (col, vec3 (0.1, 1., 0.1), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfczN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 781, 819, 819, 1036], [1038, 1038, 1072, 1072, 1293], [1295, 1295, 1330, 1330, 2280], [2282, 2282, 2304, 2304, 2876], [2878, 2878, 2912, 2912, 3532], [3534, 3534, 3556, 3556, 3657], [3659, 3659, 3692, 3692, 4061], [4063, 4063, 4084, 4084, 4299], [4301, 4301, 4338, 4338, 4588], [4590, 4590, 4621, 4621, 5733], [5735, 5735, 5776, 5776, 9171], [9173, 9173, 9208, 9208, 10283], [10285, 10285, 10311, 10311, 10731], [10733, 10733, 10755, 10755, 10946], [10948, 10948, 11004, 11004, 12141], [12264, 12264, 12288, 12288, 12325], [12327, 12327, 12351, 12351, 12406], [12408, 12408, 12432, 12432, 12482], [12484, 12484, 12508, 12508, 12555], [12557, 12557, 12582, 12582, 12728], [12730, 12730, 12755, 12755, 12954], [12956, 12956, 12977, 12977, 13116], [13118, 13118, 13141, 13141, 13305], [13307, 13307, 13336, 13336, 13548], [13550, 13550, 13589, 13589, 13806], [13808, 13808, 13841, 13841, 13884], [13886, 13886, 13928, 13928, 13979], [13981, 13981, 14026, 14026, 14124], [14126, 14126, 14183, 14183, 14266], [14268, 14268, 14298, 14298, 14372], [14374, 14374, 14398, 14398, 14529]]}
{"id": "Xtscz7", "name": "Curve fitting 2", "author": "ollj", "description": "Minor improvements on \nhttps://www.shadertoy.com/view/MsXGDj\nsimple cubic interpolating splines, Hermite, or special cases of Hermite.\nsmoothstep, or the cos() that is close to smoothstep.\n\nchose a more constrained function, for performance over quality\n", "tags": ["noise", "spline", "smoothstep", "cubic", "fract", "hash", "catmullrom", "catmull", "hermite", "crom"], "likes": 14, "viewed": 1242, "date": "1504119877", "time_retrieved": "2024-06-20T19:00:15.534997", "image_code": "//2d spline cubic hermite curve fitting 2 mod()\n\n//default zoom level of the whole view\n#define ViewZoom 1.5\n//scale.y of the spline\n#define scaleY 4.\n\n//modify zoom with mouse.x\n//#define ZoomByX\n//modify offset by mouse.y\n//#define OffsetByY\n\n/*\nFitting a curve trough points = control_vectors \n... is a lazy and user friendly way to define curves=splines.\nTo interpolate between 2 given vectors, giving +2 further away vectors (\n... to have enough parameters for a cubic function.\nFor flexibility, spline functions are n-dimensional #define's\n\nBEWARE that you may need to add extra round brackets; ();\n... Due to how #define's copy paste labels, \n... instead of substituting parameters of higher degree functions,\n... which often messes up orders of operations, unless you explicitly add enough \"()\"\n\nThis is for performance over quality:\ntherefore you chose a more specialized function, \n... which likely does not look as good as a (slower) more general function \n... that would allow more tweaking.\nfor performance and simplicity, this adds the constrain that .x are of even distance\n...meant for fract() tesselation/tiling.\n\nfor performance, only cubic Hermite splines and single cosines are used. \nfor performance, splines are uniform, \n... non uniform splines are \"weighted\", which adds a loop that averages a sum.\nfor performance, splines are not rationalized, \n... rationalized splines (can) recursively blend with neighbors to get smoother.\neg [NURBS] = [Non-Uniform-Rational(ized)-Basis-Spline] could do more, but would be slower.\n*/\n\n//#define Use_Linear\n//#define Use_Cosine\n//#define Use_Smoothstep\n//#define Use_Hermite\n//#define Use_Catmull_Rom\n//#define Use_Cubic\n\n// The functions use the following iterpolation format to interpolate y=f(x)\n\n// a----b-x--c----d\n// Where 'x' is the fractional diff betweeen b and c.\n// a.x,b.x,c.x,d.x  are evenly spaced via fract(), and .y is set by a hash.\n//this constrain makes sense to tesselate terrain.\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n//hash11 fast mediocre, better for mobile gpu.\nfloat h11(float p){vec3 f=fract(vec3(p)*.1031);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\n//disadvantages: diagonal patterns, bad derivatives.\n//advantages: good performance, even distribution. (for better distribution, include phi) \n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a) -mav(-a)\n#define dd(a) dot(a,a)\n#define u2(a) (a*2.-1.)\n#define u5(a) (a*.5+.5)\n//seesaw wave\n#define ss2t(a) a=abs(fract(a)*2.-1.)\n//mirror p at half rotated axis == cheap SINGLE 2d rotation.\n#define rs(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n#define sat(a) clamp(a,0.,1.)\n//a generalization of clamp(a,0.,1.); for m=vec2(1)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//return distance of [u] from segment, from [a] to [b]\nv0 segment(v1 p,v1 a,v1 b){p-=a;b-=a;return length(p-b*sat(dot(p,b)/dd(b)));}\n#define grid(u) mav(abs(u2(fract(u))))\n//#define mStretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n#define  fsaa 2./min(iResolution.x,iResolution.y)\nv3 rg(vec4 c){\n return mix(fract(c*4.),smoothstep(fsaa,-fsaa,c),.5+(atan(c))/acos(-1.));}\n\n\n//float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}//doesnt look too good.\n#define Linear(x,a,b) a*(x*(b/a-1.)+1.)\n//float Cosine(float x, float a, float b){return (b-a)*(1.-cos(x*acos(-1.)))*.5 + a;}\n#define Cosine(x,a,b) ((b-a)*(1.-cos(x*acos(-1.)))*.5 + a)\n//float Smoothstep(float x, float a, float b){return (b-a)*x*x*(3.-2.*x)+a;}\n#define Smoothstep(x,a,b) ((b-a)*x*x*(3.-2.*x)+a)\n//lower lipschitz == less likely spheretracking overestimation.\n//most general, smoothest most excessive, most zigzag, lowest lipschitz\n#define HermiteD(x,a,b,e,f) (b+.5*x*(e+b-a+x*(a-b+e+x*3.*(e*3.+f+x*5./3.*(-e*3.-f+x*.4*(e*3.+f))))))\n#define Hermite(x,a,b,c,d) HermiteD(x,a,b,(c-b),(a-d))\n//special case of Hermite(), with a smooth .5 average. medium zigzag\n#define Catmull_Rom(x,a,b,c,d) ((((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b)\n//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n#define Cubic(x,a,b,c,d) ((((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b)\n//Cosine() is smoother than Cubic()\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u =fra(U),m=fra(iMouse.xy);  \n \n #ifdef ZoomByX\n u*=m.x;m*=m.x;//mouse.x zooms in\n #endif\n u.y+=.5;\n\n float p=(iTime*.5+u.x)*scaleY,\n x=fract(p);p=floor(p);\n float a=h11(p),\n       b=h11(p+1.),\n       c=h11(p+2.),\n       d=h11(p+3.);//theese 4 could be vec4, using hash44\n vec4 r=vec4(0);\n\t\n    /*\n#ifdef Use_Linear\n\tf = Linear(x, b, c);\n#elif defined Use_Cosine\n\tf = Cosine(x, b, c);//has more good derivatives than smoothstep()\n#elif defined Use_Smoothstep\n\tf = Smoothstep(x, b, c);\n#elif defined Use_Cubic\n    f =  Cubic(x, a, b, c, d);\n#elif defined Use_Catmull_Rom\n\tf = Catmull_Rom(x, a, b, c, d);\n#elif defined Use_Hermite\n\tf = Hermite(x, a, b, c, d);\n#endif\n*/\n //above is a buffet of function to apply to 4 colors .rgba below,.a<-yellow\n r.g=Catmull_Rom(x,a,b,c,d);//special case of ThirdOrderSpline(), with a smooth .5 average. medium zigzag\n r.a=Cubic(x,a,b,c,d);//efficient and smooth 2nd derivative, least zigzag, highest lipschitz \n r.b=Cosine(x,b,c);//smoothest derivatives, most sizzag\n r.r=Hermite(x,a,b,c,d);//slowest, most general,smoothest, high zigzags, lowest lipschitz\n //r.b=Linear(x,b,c);\n    \n r-=u.y;//display distance.y, no fancy differential estimation here.\n \n #ifdef OffsetByY\n r+=vec4(-1.5,-.5,.5,1.5)*(m.y-1.);//offset.y\n #endif\n    \n //to overwrite all with one\n //r=vec4(r.a);\n \n //to set some to 0;\n //r.r=0.;  \n //r.g=0.; \n //r.b=0.; \n //r.a=0.;\n    \n r*=.1;//scaling the distance field here makes it more elegant, less cognitive load.\n \n r=1.-rg(r);//turn into distance field visualisation negative distace is brighter\n    //this visualization mixes fract(r) with smoothstep(r) by atan(r)/acos(-1.)\n    \n r.rg=mix(r.rg,r.aa,.5);//mix yellow into .gr\n \n //add some dots as markers. they are visible by inverting colors on their inside\n //f is distance to control vectors (split in 2, within mod())\n float f=dd((vec2(x   ,(u.y-b)*scaleY)));\n f=min(f,dd((vec2(x-1.,(u.y-c)*scaleY))));\n //f=sqrt(f);//skippable, squared distance is just fine, scales dorse though\n f=smoothstep(fsaa,-fsaa,f-.005);\n //f=fract(f);//to defug f.\n r=mix(r,1.-r,f);//invert colors inside a Dot\n O=vec4(r.xyz,1);}\n/*\n\n//--------------------------------------------------------------------------------\n//in memoriam, refference backup from https://www.shadertoy.com/view/MsXGDj\n/*\nfloat Cubic(float x, float a,float b, float c,float d) \n{\n\tfloat p =d-c-a+b;\n\treturn p*(x*x*x)\n        +(a-b-p)*(x*x)\n        +(c-a)*x\n        +b;\n}*/\n/*\n//return distance.y of [x], where a,b,c,d are the .y values to control points.\n//a,b,c,d are evenly spaced, using fract(), usually a hash.\nfloat Cubic(float x, float a,float b, float c,float d){\n\treturn (((d-c-a+b)*(x-1.)+a-b)*x+(c-a))*x+b;\n}//2nd derivative is smooth, 3rd derivatuce sucks, such is the life of cubics.\n*/\n\n//--------------------------------------------------------------------------------\n/*float Catmull_Rom(float x, float a,float b, float c,float d){\n    //vec3 v=vec3(c-a,2.*(a+c+c)-d-5.*b,(d-a+3.*(b-c)));\n\t//return ((v.z*x+v.y)*x+v.x)*.5*x+b;\n\treturn (((d-a+3.*(b-c))*x+(2.*(a+c+c)-d-5.*b))*x+(c-a))*.5*x+b;\n//\tOr, the same result with...\n//\tfloat x2 = x  * x;\n//\tfloat x3 = x2 * x;\n//\treturn 0.5 * ( ( 2.0 * v1) + (-v0 + v2) * x +\n//                  (2.0 * v0 - 5.0 *v1 + 4.0 * v2 - v3) * x2 +\n//                  (-v0 + 3.0*v1 - 3.0 *v2 + v3) * x3);\n}\n/**/\n\n//--------------------------------------------------------------------------------\n\n/*\nfloat ThirdOrderSpline(float x, float a,float b, float c,float d){\n float cb=c-b; //c=cb+b\n float ad=a-d;\n return (b+.5*x*(cb+b-a+x*(a-b+cb+x*3.*(cb*3.+ad+x*5./3.*(-cb*3.-ad+x*.4*(cb*3.+ad))))));\n}*/\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtscz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1963, 2112, 2131, 2131, 2212], [2213, 2483, 2496, 2496, 2517], [2518, 2518, 2531, 2531, 2558], [2559, 2559, 2572, 2572, 2605], [2895, 2947, 2966, 2966, 3032], [3033, 3088, 3115, 3115, 3165], [3656, 3797, 3811, 3811, 3886], [4880, 4917, 4955, 4955, 7084]]}
{"id": "XtsczM", "name": "Antialiased grid of dots", "author": "etale_cohomology", "description": "Fork of cacheflowe's https://www.shadertoy.com/view/MdBfzm\n\nThe dot radius is constant, regardless of how many dots per `uv` unit there are.", "tags": ["2d", "simple", "grid", "zoom", "antialias", "dots", "scale", "scaling"], "likes": 4, "viewed": 179, "date": "1504068992", "time_retrieved": "2024-06-20T19:00:15.534997", "image_code": "// Fork of cacheflowe's https://www.shadertoy.com/view/MdBfzm\n\n#define SCALE       1. * ((1.01 + sin(.5 * iTime)) * 6.)\n#define DOT_FREQ    .5\n#define DOT_RADIUS .1\n\nfloat sdf_disk(vec2 uv, float radius, vec2 center){\n    return distance(uv, center) - radius;\n}\n\n// @scale is a number that aids antialiasing!\nfloat draw_dotgrid(vec2 uv, float scale){\n    vec2 uv_repeat  = mod(uv - .5 * DOT_FREQ, DOT_FREQ) - .5 * DOT_FREQ;\n    //vec2 uv_repeat = fract(uv * N_DOTS - .5) - .5;\n\n    float dot_aa     = 4. * scale / iResolution.y;  // Scale-sensitive antialiasing!\n    float dot_radius = DOT_RADIUS;  // Keep radius constant, shrink spacing between dots!\n    return smoothstep(dot_aa, .0, sdf_disk(uv_repeat, dot_radius, vec2(0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n\tfloat dotgrid = draw_dotgrid(uv, SCALE);\n    fragColor.rgb = vec3(dotgrid);\n}\n\n/*\n// GregRostami's golfed version! (144 chars)\n\n#define mainImage(o,U)\t\t\t\t\t\t\t\t\t\t\t\t\\\nvec2 R = iResolution.xy,\t\t\t\t\t\t\t\t\t\t\t\\\n    u = ( o.a = (1.02 + sin(.5*iTime)) * 6.) * (U+U - R) / R.y;\t\t\\\n\to += smoothstep(8. * o.a / R.y, .0, length(fract(u+u-.5)-.5) - .2)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsczM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 166, 217, 217, 261], [263, 309, 350, 350, 731], [733, 733, 787, 787, 960]]}
{"id": "Xtsczn", "name": "More Distance", "author": "TimoKinnunen", "description": "Distance function comparison over full floating point range. Use mouse to move the target point. ", "tags": ["distance", "function", "accuracy", "improve"], "likes": 0, "viewed": 353, "date": "1503157389", "time_retrieved": "2024-06-20T19:00:15.953218", "image_code": "////////////////////////////////////////\n//\n// More Distance  by Timo Kinnunen 2017\n//\n// Comparison of two alternative distance functions\n// and the builtin function over the whole 32bit\n// floating point range, around 2^-128 to 2^+128.\n//\n// Use mouse to move the target point around.\n//\n// Default function is in red. On my computer it\n// only produces usable results for about half of\n// the available value range. Disappointing.\n//\n// The current and future exponents is plotted in black.\n// White color indicates large or infinite values.\n// Fully saturated R,G,B colors indicate zeros.\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n//////////////////////////////////////////////////////////////////////////////\n\nfloat distanceApprox(vec2 a, vec2 b) {\n    vec4 t = vec4(abs(a- .5* (b+ a)),0,0);\n    t.xy = vec2(t.y >= t.x ? t.x : t.y,t.y >= t.x ? t.y : t.x);\n    t = t.x* vec4(1.0234375,0.5546875,1.296875, 0.1796875)+\n        t.y* vec4(1.71875,  1.921875, 1.5234375,1.9921875);\n    t.xy = vec2(t.x >= t.z ? t.x : t.z,t.y >= t.w ? t.y : t.w);\n    return t.x >= t.y ? t.x : t.y;\n}\n// By TechEpic @ https://www.shadertoy.com/view/ldfBz2\nfloat distanceArctan(vec2 a, vec2 b) {\n    return abs(a.x- b.x)/ abs(sin(atan(a.x- b.x,a.y- b.y)));\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int band = int(fragCoord.y* 3./ iResolution.y);\n\tvec2 uv = mod(fragCoord.xy,iResolution.xy/ vec2(1,3))/ iResolution.x;\n    vec2 mo = mod(iMouse.xy,iResolution.xy/ vec2(1,3))/ iResolution.x;\n    vec2 ex = vec2(129,1)* sin((iTime+ fragCoord.x/ 60.)* 0.125);\n    float mult = exp2(ex.x);\n    uv *= mult;\n    mo *= mult;\n    float d3 = distanceApprox(uv, mo);\n    float d2 = distanceArctan(uv, mo);\n    float d1 = distance(uv, mo);\n    float d = band == 0 ? d1 : band == 1 ? d2 : d3;\n    d3 /= mult;\n    d2 /= mult;\n    d1 /= mult;\n    d /= mult;\n    vec3 colors = band == 0 ? vec3(1,d,d) : band == 1 ? vec3(d,1,d) : vec3(d,d,1);\n    //colors = clamp(colors*(2.0+ex.y),0.,1.);\n    colors *= smoothstep(1.,3.,abs(fragCoord.y- iResolution.y* 0.45* (1.125+ ex.y)));\n    colors *= 0.5+0.5*smoothstep(-0.99,-0.98,cos(d*32.*ex.y*radians(180.)));\n\tfragColor = vec4(colors,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtsczn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 757, 795, 795, 1123], [1124, 1179, 1217, 1217, 1280], [1281, 1281, 1333, 1333, 2204]]}
{"id": "XtXyzM", "name": "Circle of dots", "author": "csaez", "description": "A circle of dots, but every dot alone is just moving in a straight line.\n\nBased on https://twitter.com/scienmag/status/901630859802968064", "tags": ["circles", "math", "optical", "illusion", "trigonometry"], "likes": 7, "viewed": 577, "date": "1503923926", "time_retrieved": "2024-06-20T19:00:15.953218", "image_code": "#define S(x) smoothstep(2.0/iResolution.y, 0.0, x)\n#define circle(uv, p, r) S(length(uv - p) - r)\n#define rotate2d(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle))\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const int items = 8;\n    const float speed = 2.0;\n    const float fraction = 3.14 / float(items);\n    const float diameter = 0.4;\n    const float radius = 0.03;\n\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float circles = 0.0;\n    float lines = 0.0;\n    float mask = S((diameter + radius) - length(uv));\n    \n    for (int i=0; i<items; i++) {\n        float phase = fraction * float(i);\n        vec2 coord = uv * rotate2d(phase);\n        \n        float angle = (iTime * speed) + phase;\n\t\tvec2 pos = vec2(cos(angle), 0.0) * diameter;\n        circles += circle(coord, pos, radius);\n        lines += S(abs(coord.y));\n    }\n    fragColor = vec4(circles + 0.5*lines + mask);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXyzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[178, 178, 233, 233, 963]]}
