{"id": "3dKfDh", "name": "Raymarched Astronaut", "author": "qw", "description": "just chilling in space", "tags": ["raymarching", "sdf", "astronaut"], "likes": 3, "viewed": 54, "published": "Public", "date": "1615820956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n \n\nfloat opRound( float inShape, float rad )\n{\n    return inShape - rad;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec3 opRotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 opRotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 opRotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\nfloat opBlend(float d1, float d2, float t)\n{\n    float k = 5.0 * t;\n    float d = sminCubic(d1, d2, k);\n    return d;\n}\n\nfloat opUnion(float a, float b)\n{\n    if( a < b)\n    {\n        return a;\n    }\n    return b;\n}\n\nvec2 opUnionMat(float a, float b, float matA, float matB )\n{\n    if( a < b)\n    {\n        return vec2(a,matA);\n    }\n    return vec2(b,matB);\n}\n\n\nfloat opCut(float a, float b)\n{\n    return max(-a,b);\n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 position, vec3 capAPos, vec3 capBPos, float radius)\n{\n    vec3 ab = capBPos-capAPos;\n    vec3 ap = position - capAPos;\n    \n    // projecting ab on ap and normalizing by length of a<->b, ie: dot product ab.ab\n    float t = dot(ab, ap) / dot(ab,ab);\n\t//clamp value to stay between a & b\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 closestPoint = capAPos + ab * t;\n    float distance = length(position - closestPoint) - radius;\n    return distance;\n}\n\nfloat sdTorus( vec3 position, vec3 torusOrigin, float torusRadius, float width )\n{\n    vec3 posToTorus = torusOrigin - position;\n    float x = length( posToTorus.xz) - torusRadius;\n    float y = posToTorus.y;\n    return length(vec2(x,y)) - width;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat sdBox(vec3 position, vec3 origin, vec3 size)\n{\n    vec3 boxPos = position - origin;\n    return length( max(abs( boxPos ) - size, 0.0) );\n}\n               \n\nfloat sdCylinder(vec3 position, vec3 capAPos, vec3 capBPos, float radius)\n{\n    vec3 ab = capBPos-capAPos;\n    vec3 ap = position - capAPos;\n    \n    // projecting ab on ap and normalizing by length of a<->b, ie: dot product ab.ab\n    float t = dot(ab, ap) / dot(ab,ab);\n\t//clamp value to stay between a & b\n    //t = clamp(t, 0.0, 1.0);\n    \n    vec3 closestPoint = capAPos + ab * t;\n    \n    float x = length(position - closestPoint) - radius;\n    float y = (abs(t- 0.5) - 0.5) * length(ab);\n    float exteriorDist = length( max( vec2(x,y), 0.0) );\n    \n    //fix for inaccuracy distance estimation\n    float interriorDist = min( max(x,y),0.0);\n    float distance = exteriorDist + interriorDist; \n    \n    return distance;\n}\n\nfloat GetDistanceToScene(vec3 position, out float matID)\n{\n\t//Helmet\n    //Sphere (pos.xyz, radius)\n    vec3 modelPos =  vec3(-1.0,2.0, -0.0);\n    vec3 helmetPos = modelPos+vec3(0.0,0.0, 0.0);\n    \n    //position = opRotateY(position,sin(iTime)*3.14);\n    \n    vec4 helmetOuterSphere = vec4(helmetPos, 1.0);\n    vec4 helmetLowerOuterSphere = vec4(helmetPos+vec3(0,0,-0.0), 1.04);\n    vec4 helmetUpperOuterSphere = vec4(helmetPos+vec3(0,0,-0.0), 1.04);\n    vec4 helmetInnerSphere = vec4(helmetPos+vec3(0,0.1,-.3), 0.8);\n    float helmetOuterSphereDistance = length( helmetOuterSphere.xyz - position) - helmetOuterSphere.w; \n    float helmetLowerOuterSphereDistance = length( helmetLowerOuterSphere.xyz - position) - helmetLowerOuterSphere.w; \n    float helmetUpperOuterSphereDistance = length( helmetUpperOuterSphere.xyz - position) - helmetUpperOuterSphere.w; \n    float helmetInnerSphereDistance = length( helmetInnerSphere.xyz - position) - helmetInnerSphere.w; \n    \n    \n    //Base\n    //float torusDistance = sdTorus(position, helmetPos+vec3(0,-0.6,0), 1.0, 0.2);\n    vec3 helmetBasePos = helmetPos - position + vec3(0,-0.9,0);\n    float helmetBaseDist = sdCappedCylinder(helmetBasePos, 0.8 ,0.15);\n    float helmetBaseCutoutOuterDist = sdCappedCylinder(helmetBasePos, 0.85 , 0.05);\n    float helmetBaseCutoutInnerDist = sdCappedCylinder(helmetBasePos, 0.75 , 1.0);\n    \n    vec3 helmetTopNudgePos = helmetBasePos+vec3(0,0.4,0);\n    helmetTopNudgePos = opRotateZ(opRotateX(opRotateY(helmetTopNudgePos, 3.14*0.5 ), 3.14 ), 3.14*0.35);\n    //float helmetTopNudgeDist = sdCappedCylinder( helmetTopNudgePos, 0.2 , 0.5);\n    float helmetTopNudgeDist = sdCappedTorus(helmetTopNudgePos, vec2(1.0, 0.01), 1.5, 0.2);\n\n    //Side nobs\n    vec3 helmetSideNobPos = helmetBasePos+vec3(0,0.9,-0.3);\n\tfloat helmetSideNobDist = sdCappedCylinder( opRotateZ(helmetSideNobPos,3.14*0.5), 0.15 , 1.1);\n    \n    \n    \n    //Plane (plane is flat at height 0, which means it's at \"y\" distance from camera\n    float planeDistance = position.y;\n    /*\n    float capsuleDistance = sdCapsule(position, vec3(-3.0,2,2), vec3(-2.0,1,2), 0.20);\n    float torusDistance = sdTorus(position, vec3(0,1.2,4), 2.0, 0.2);\n    vec3 repeatedPos = position;\n    float boxDistance = sdBox(position, vec3(0.0, 1, 4.0), vec3(0.9) );\n    float cylinderDistance = sdCylinder(position, vec3(-4.0,0.4,2.5), vec3(-1.0,0.4,1.5), 0.30);\n    \n    //Box 2\n    float box2IntersectionPlane = dot(position + vec3(0,0, 1.5*( sin(iTime) *0.5)+0.5 ), normalize(vec3(-1,1,-1)) )+1.1; \n    float box2Distance = sdBox(position, vec3(3.0, 0.6, 0.5), vec3(0.5) );\n    box2Distance = max( box2IntersectionPlane, box2Distance);\n    box2Distance = abs(box2Distance) - 0.3;\n    */\n    \n    // find closest object('s distance)\n\t//Main helmet sphere shape\n    \n    //Lower helmet\n    float helmetLowerOuterIntersectionPlane = dot(position + vec3(0,3.5, 5.8 ), normalize(vec3(0,1,-1)) ); \n    helmetLowerOuterSphereDistance = opIntersection(helmetLowerOuterIntersectionPlane, helmetLowerOuterSphereDistance );\n    float helmetDistance = helmetLowerOuterSphereDistance;\n    \n\t//Upper helmet\n    float helmetUpperOuterIntersectionPlane = dot(position + vec3(0,-0.7, -1.1), normalize(vec3(0,-1,-1)) ); \n    helmetUpperOuterSphereDistance = opIntersection(helmetUpperOuterIntersectionPlane, helmetUpperOuterSphereDistance );\n   \thelmetDistance = opUnion(helmetUpperOuterSphereDistance, helmetDistance);\n    \n    //Top Nudge\n    helmetTopNudgeDist = opIntersection(-1.0*helmetLowerOuterIntersectionPlane,helmetTopNudgeDist);\n    helmetDistance = opUnion(helmetTopNudgeDist,helmetDistance);\n    \n    //Side nobs\n    helmetDistance = opUnion(helmetSideNobDist,helmetDistance);\n    \n    \n    //cut out inside\n    helmetDistance = opCut(helmetOuterSphereDistance, helmetDistance);\n    \n    \n    //helmet Base (with cut)\n    helmetBaseCutoutOuterDist = opCut(helmetBaseCutoutInnerDist , helmetBaseCutoutOuterDist);\n    helmetDistance = opUnion(helmetBaseDist, helmetDistance);\n    helmetDistance = opCut(helmetBaseCutoutOuterDist, helmetDistance);\n    \n    \n    //Face \n    vec3 facePos = modelPos - (position-vec3(0.0,1.495,1.55));\n    //3 Eyes\n    float eyesDistance = length(facePos-vec3(0.0,1.2,1.9))-.25;\n    eyesDistance = opUnion( length(facePos-vec3(0.5,1.3,1.9))-.25, eyesDistance);\n    eyesDistance = opUnion( length(facePos-vec3(-0.5,1.3,1.9))-.25, eyesDistance);\n    //pupils\n    float eyePupilDistance = length(facePos-vec3(0.0,1.16,2.09))-.08;\n    eyePupilDistance = opUnion( length(facePos-vec3(0.5,1.3,2.1))-.08, eyePupilDistance);\n    eyePupilDistance = opUnion( length(facePos-vec3(-0.5,1.3,2.1))-.08, eyePupilDistance);\n    \n    \n    //Head\n    float faceDistanceR =  length(facePos-vec3(0.2,1.7,1.5))-0.75;\n    float faceDistanceL =  length(facePos-vec3(-0.2,1.7,1.5))-0.75;\n    \n    float faceDistance = sminCubic(faceDistanceR, faceDistanceL, 0.1);\n    faceDistance = opUnion(eyesDistance, faceDistance);\n    faceDistance = opUnion(eyePupilDistance, faceDistance);\n    \n    \n    //Mouth\n    vec3 mouthPos = opRotateX( facePos-vec3(0.0,1.54,2.18), 3.14) ;\n    mouthPos.x = abs(mouthPos.x) - 0.2;\n    mouthPos = opRotateZ(mouthPos,3.14*0.95);\n    float mouthDist = sdCappedTorus(mouthPos, vec2(1.0, 0.01), 0.2, 0.1);\n\tfaceDistance = opUnion(mouthDist, faceDistance);\n    \n    \n    \n    vec2 distanceData = opUnionMat(helmetDistance, planeDistance, 1.0, 0.0);\n    //float distance = opUnion(faceDistance, planeDistance);\n    distanceData = opUnionMat(faceDistance, distanceData.x, 2.0, distanceData.y );\n    float distance = distanceData.x;\n    matID = distanceData.y;\n    \n    return distance;\n}\n\n\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir, out float matID )\n{\n    //Vec2 (X = distanceToScene, Y = object ID - used for differentiation like different textures)\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + rayDir*distanceFromOrigin;\n        float distanceToScene = GetDistanceToScene(pos, matID);\n        distanceFromOrigin += distanceToScene;\n        if(distanceFromOrigin > MAX_DISTANCE || distanceToScene < SURFACE_DISTANCE)\n        {\n        \tbreak;\n        }    \n        \n    }\n    \n    \n    return distanceFromOrigin;\n}\n\n\nvec3 GetNormal(vec3 scenePos)\n{\n    float matID;\n    float distance = GetDistanceToScene(scenePos, matID);\n    \n    //We use derivatives to calculate normal of a position\n    vec2 smallDiff = vec2(0.01, 0);\n    \n    vec3 normal = distance - vec3(\n        GetDistanceToScene(scenePos - smallDiff.xyy, matID),\n        GetDistanceToScene(scenePos - smallDiff.yxy, matID),\n        GetDistanceToScene(scenePos - smallDiff.yyx, matID)\n        );\n\n\treturn normalize(normal);\n    \n}\n\nfloat GetLight( vec3 scenePos , vec3 normal)\n{\n    //Light position in world\n    vec3 lightPos = vec3(0, 4.0, -3);\n    //make light move in circle\n    //lightPos.xz += vec2(cos(iTime), -sin(iTime) ) * 2.0;\n    lightPos.y += sin(iTime) * 1.5;\n    \n    \n    vec3 lightDir = normalize( lightPos-scenePos);\n\n    float diffuse = dot(normal, lightDir);\n    //Clamp diffuse\n    diffuse = clamp(diffuse,0.0,1.0);\n    \n    //Shadow ((normal*SURFACE_DISTANCE*2.0) -> offset shading point a little bit away of surface to not intersect with it again,\n    //*2 is to avoid artefacts\n    float matID;\n    float distanceToLightRayMarch = RayMarch(scenePos + (normal*SURFACE_DISTANCE*2.0), lightDir, matID);\n    if( distanceToLightRayMarch < length( scenePos - lightPos) )\n    {\n        //something is in between the point in the world and the light, ie: we're in shadow\n        diffuse *= 0.1;\n    }\n    \n    return diffuse;\n}\n\n\nvec3 GetAlbedo( vec3 scenePos, vec3 normal, float matID)\n{\n    // apply tri-planar mapping\n    mat3 triMapSamples; \n    vec3 color;\n\t//first we calculate planar mapping for each 3 directions\n    //Support multiple textures based on objectID\t\n    if( matID == 0.0){\n        \n    \ttriMapSamples = mat3(\n                texture(iChannel0, scenePos.yz).rgb,\n                texture(iChannel0, scenePos.xz).rgb,\n                texture(iChannel0, scenePos.xy).rgb\n        \t);\n        color = triMapSamples * abs(normal);\n    }else if(matID == 1.0){\n    \ttriMapSamples = mat3(\n                texture(iChannel1, scenePos.yz).rgb,\n                texture(iChannel1, scenePos.xz).rgb,\n                texture(iChannel1, scenePos.xy).rgb\n        \t);\n        color = triMapSamples * abs(normal);\n        \n    }else{\n    \tcolor = vec3(0.898,0.941,0.394);\n    }\n    \n    //Then we \"weigh\" this 3x3 matrix by the normal, this is our result\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  \t//Change to square aspect ratio & center in middle of viewport\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    vec3 cameraPos = vec3(0,3,-4);\n    vec3 cameraLookDir = normalize( vec3(0.0,-0.3,1.0));\n    vec3 rayDir = normalize(vec3(uv.xy+cameraLookDir.xy, cameraLookDir.z));\n        \n    \n    //Vec2 (X = distanceToScene, Y = object ID - used for differentiation like different textures)\n    float matID;\n    float rayMarchDistance = RayMarch(cameraPos, rayDir, matID);\n    vec3 scenePos = cameraPos + rayDir * rayMarchDistance;\n    \n    vec3 normal = GetNormal(scenePos);\n    \n    vec3 albedo = GetAlbedo(scenePos, normal, matID); \n\tfloat diffuseLighting = GetLight(scenePos, normal);\n    \n    vec3 lightColor = vec3(0.8,0.8,0.8);\n       \n\tvec3 col = albedo * vec3(lightColor*diffuseLighting);\n    \n    vec3 ambientColor = vec3(0.2,0.2,0.2);\n    col += ambientColor;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 116, 160, 160, 238], [242, 242, 285, 285, 313], [315, 315, 385, 385, 519], [522, 522, 559, 559, 642], [644, 644, 682, 682, 780], [782, 782, 820, 820, 918], [920, 920, 958, 958, 1056], [1059, 1059, 1103, 1103, 1178], [1180, 1180, 1213, 1213, 1274], [1276, 1276, 1336, 1336, 1419], [1422, 1422, 1453, 1453, 1477], [1479, 1479, 1523, 1523, 1544], [1546, 1546, 1598, 1598, 1705], [1707, 1707, 1781, 1781, 2174], [2176, 2176, 2258, 2258, 2424], [2426, 2426, 2490, 2490, 2607], [2610, 2610, 2662, 2662, 2754], [2772, 2772, 2847, 2847, 3498], [3500, 3500, 3558, 3599, 9138], [9142, 9142, 9205, 9304, 9741], [9744, 9744, 9775, 9775, 10218], [10220, 10220, 10266, 10296, 11131], [11134, 11134, 11192, 11224, 12080], [12083, 12083, 12140, 12256, 13148]], "test": "error"}
{"id": "3dy3zm", "name": "Block streams", "author": "Plento", "description": "Quick god rayzz", "tags": ["2d", "blur", "godrays"], "likes": 16, "viewed": 232, "published": "Public API", "date": "1614669052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 color(vec2 uv){\n    float m = exp((sin(uv.y*3. - iTime)))+0.8;\n    uv.x *= m * 2.2;\n    uv.x += iTime;\n    \n\tvec2 fuv = fract(uv*7.);\n    uv.y += .9*iTime*sin(floor(uv*7.).x*0.4)+0.7;\n    vec2 id = floor(uv*7.);\n   \n    return vec3(smoothstep(.7, .27,fuv.x-0.5)*mod(id.y+id.x,2.0)*(hsh(id*999.)-.2));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    uv*=rot(1.6);\n    \n    vec3 col = color(uv);\n\tvec3 acc = vec3(0);\n    \n    float m = 0., c = 0.;\n    for(float i = 1.0; i >0.0; i-=0.02){\n        vec2 nc = uv*(i+hsh(u)*0.15);\n        m = step(1.1, length(color(nc)));\n        acc += vec3(m) * vec3(0.97, 0.94, 0.9);\n        c++;\n    }\n    acc /= c;\n    col += acc*1.3;\n    f = vec4(col * .55, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dy3zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 96, 114, 114, 231], [233, 233, 253, 253, 540], [542, 542, 582, 582, 978]], "test": "valid"}
{"id": "3lGfzc", "name": "Ultraviolet Fractal", "author": "oneshade", "description": "Inspired by gaz's amazing fractals.", "tags": ["3d", "fractal", "colors", "neon", "cool", "ultraviolet"], "likes": 4, "viewed": 73, "published": "Public", "date": "1614749509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, in vec2 C) {\n    O = vec4(0.0);\n    vec3 p, r = iResolution;\n    vec3 d = normalize(vec3((C - 0.5 * r.xy) / r.y, 1.0));  \n    for (float i=0.0, g=0.0, e, s; ++i < 100.0; e < 0.002 ? O += 5.0 * (cos(vec4(2.0, 4.0, 1.0, 0.0) - log(s * s) * 0.5) + 0.5) / dot(p, p) / i * 2.0 : O) {\n        p = g * d;\n        p -= vec3(0.0, -1.7, 2.0);\n        s = iTime * 0.1;\n        vec2 cs = sin(s + vec2(1.57, 0.0));\n        p.xz *= mat2(cs.x, -cs.y, cs.yx);\n        p = abs(p);\n        p.xz = vec2(atan(p.z, p.x), length(p.xz));\n        p.yz = vec2(atan(p.z, p.y), length(p.yz) - 3.0);\n        s = 2.0;\n        s *= e = 3.0 / min(dot(p, p), 1.5);\n        p = abs(p) * e;\n        for(int i=0; i < 8; i++) {\n            p = vec3(2.0, 4.0, 2.0) - abs(p - vec3(4.25, 4.625, 2.0));\n            s *= e = 7.25 / clamp(dot(p, p), 0.0, 5.2);\n            p = abs(p) * e;\n            p.y = abs(p.y) - 0.15;\n        }\n\n        g += e = min(length(p.xz) * 1.125 - 0.5, p.y) / s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 986]], "test": "valid"}
{"id": "3lKBD3", "name": "4D Lava Lamp", "author": "alalalat", "description": "endless fun", "tags": ["fractal", "perlinnoise", "perlin", "green", "blue", "screensaver", "multidimensional"], "likes": 2, "viewed": 123, "published": "Public", "date": "1615275078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez \n// substantial refactoring by 2021 Alalalat\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat maximum(vec3 p)\n{\n    float max = p.x;\n    if (p.y > max)\n    max = p.y;\n    if (p.z > max)\n    max = p.z;\n    return max;\n    \n    \n}\nfloat minimum(vec3 p)\n{\n    float min = p.x;\n    if (p.y < min)\n    min = p.y;\n    if (p.z < min)\n    min = p.z;\n    return min;\n    \n    \n}\nvec3 normalize2 (vec3 grosscolor)\n{\n    grosscolor = (grosscolor*grosscolor*grosscolor);\n    float max = maximum(grosscolor);\n    float min = minimum(grosscolor);\n    return (grosscolor.xyz/(max+min));\n\n}\n\n\nvec2 rotate (vec2 oldpoint, float angle)\n{\n    float left, right;\n    \n    left = cos(angle)*oldpoint.x;\n    left -= sin(angle)*oldpoint.y;\n    right = sin(angle)*oldpoint.x;  \n    right += cos(angle)*oldpoint.y;\n    \n    return vec2(left,right);\n}\n\nfloat noise4( vec2 uv )\n{\n    float f = 0.5;\n    float frequency = 1.75;\n    float amplitude = 0.5;\n    //for(int i = 0; i <int(floor(log(iTime*iTime))); i++){\n    for(int i = 0; i <7; i++){\n        f += amplitude*noise( frequency*uv - rotate(vec2(log(iTime+3.0),log(iTime+3.0)/999.0),iTime/9999.0) );\n        frequency *= 2.0;                                                                                             //helper\n        amplitude *= 0.5;\n    }\n    return f;\n}\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,0.8);\n    uv = rotate(uv,log(iTime)/-7.0);\n    \n    //uv -= 2.0*vec2(iResolution.x/2.0, iResolution.y/2.0);\n    \n    float interval = 10.0;\n    vec3 dblue = interval*vec3(1.8,2.6,2.6);\n    vec3 cyan = interval*vec3(0,2.1,2);\n    vec3 magenta = interval*vec3(1.8,1.0,1.8);\n   \n \n    \n\t\n    float f = 0.0\t;\n    \n    vec3 color = vec3(0.75,0.75,0.75);   \n\tf = noise4( uv + noise4(uv)*((log(iTime+1.0)+(iTime/60.0))) );\n    color += f*normalize2(dblue);\n    \n    f = noise4( f*rotate(uv,sin(iTime/11.0)) + f*noise4(f*uv));\n    color += f*normalize2(cyan);\n    \n    f = noise4( f*rotate(uv,iTime/7.0) + f*noise4(uv)*noise4(uv));\n    color += f*normalize2(magenta);\n    \n    color = normalize2(color);\n  \n    \n \n\n\t\n\t\n   \t\n\t\n\tfragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKBD3.jpg", "access": "shaders20k", "license": "mit", "functions": [[1335, 2067, 2124, 2124, 2239], [2241, 2241, 2267, 2267, 2746], [2748, 2748, 2771, 2771, 2888], [2889, 2889, 2912, 2912, 3029], [3030, 3030, 3065, 3065, 3234], [3237, 3237, 3279, 3279, 3485], [3487, 3487, 3512, 3512, 3963], [3964, 4016, 4073, 4073, 4914]], "test": "valid"}
{"id": "3lKBDd", "name": "Sunset wire", "author": "gyabo", "description": "Wire illuminated by the sunset.", "tags": ["2d"], "likes": 4, "viewed": 107, "published": "Public", "date": "1615302252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int SAMPLES = 24;\n\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 4.1414)) * 41253.12356)) * 2.0 - 1.0;\n}\n\nvec3 rand3(vec2 p) {\n\treturn normalize(vec3(rand(p + 0.0), rand(p + 1.0), rand(p + 2.0))) * rand(p + 4.0);\n}\n\nvec4 getrect(vec2 pos, vec3 alb) {\n\tfloat s = 0.0125;\n\tvec4 col = vec4(1.0);\n\tfloat tm = 1.14 + iTime * 0.01;\n\tfor(int i = 0 ; i < 64; i++) {\n\t\tfloat k = float(i + 123);\n\t\tvec2 p = vec2(cos(k * 1.4 + tm), sin(2.4 * k + tm)) * vec2(1.717, 1.0);\n\t\tp -= pos;\n\t\tp *= (1.0 - dot(p * 0.18, p));\n\t\tif(abs(p.x) < s && abs(p.y) < s) {\n\t\t\tcol *= vec4(alb, 0.0);\n\t\t\tbreak;\n\t\t}\n\t\tpos = pos.yx;\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( 2.0 * fragCoord - iResolution.xy ) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.0);\n    float v = 1.0 - abs(uv.x) * 0.125;\n    float H = 0.03;\n\tfor(int i = 0 ; i < SAMPLES; i++) {\n\t\tfloat k = (float(i) / float(SAMPLES)) * 3.141592 * 2.0;\n\t\tvec2 dir = vec2(cos(k), sin(k));\n\t\tvec2 uvs = uv + dir * 0.0075;\n\t\tvec2 uvc = uv + dir * 0.001;\n\t\tvec4 s = getrect(uvs + H * vec2(-1,1), vec3(0.0));\n\t\tvec4 c = getrect(uvc, vec3(1,2,3) * 0.3);\n\t\tif(s.w == 0.0 && c.w == 1.0)\n\t\t\tc.xyz *= 0.025;\n        col += c.xyz;\n\t}\n\tcol /= float(SAMPLES);\n\tcol *= vec3(3,2,1) * v * v * 0.5;\n    col = pow(col, vec3(1.7));\n    fragColor = vec4(col + abs(rand3(uv)) * 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 124], [126, 126, 146, 146, 234], [236, 236, 270, 270, 635], [637, 637, 694, 694, 1373]], "test": "valid"}
{"id": "3lKfDc", "name": "Fish Eye Camera", "author": "kithy", "description": "raymarching,fish eye camera,rotate", "tags": ["raymarching", "rotate", "fisheyecamera"], "likes": 2, "viewed": 78, "published": "Public", "date": "1615220319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPS 1e-5\n#define PI 3.141592\n\nvec3 rotate(vec3 p,float angle,vec3 axis){\n\tvec3 a=normalize(axis);\n\tfloat s=sin(angle);\n\tfloat c=cos(angle);\n\tfloat r=1.0-c;\n\tmat3 m=mat3(\n\t\ta.x*a.x*r+c,\n\t\ta.y*a.x*r+a.z*s,\n\t\ta.z*a.x*r-a.y*s,\n\t\ta.x*a.y*r-a.z*s,\n\t\ta.y*a.y*r+c,\n\t\ta.z*a.y*r+a.x*s,\n\t\ta.x*a.z*r+a.y*s,\n\t\ta.y*a.z*r-a.x*s,\n\t\ta.z*a.z*r+c\n\t\t);\n\treturn m*p;\n}\n\n\n\nfloat sphere(vec3 p){\n\treturn length(p)-0.3;\n}\n\nfloat cube(vec3 p){\n\tvec3 q=abs(p);\n\treturn length(max(q-0.23,0.0));\n}\n\nfloat map(vec3 p){\n\tvec3 q=rotate(p,radians(PI+iTime)*10.0,vec3(0.0,1.0,1.0));\n\tq=mod(q,0.8)-0.4;\n\tfloat s1=sphere(q);\n\tfloat c1=cube(q);\n\treturn max(c1,-s1);\n}\n\nvec3 calcNormal(in vec3 p,float d){\n\tconst vec2 e=vec2(0.01,0.0);\n\treturn normalize(vec3(d-map(p-e.xyy),d-map(p-e.yxy),d-map(p-e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n\n\t\n\tvec3 ro=vec3(0.0,0.0,2.0+(iTime)*0.5);\n\t//vec3 rd=normalize(vec3(uv,1.0));//normal camera\n\tvec3 rd=normalize(vec3(uv,(1.0-dot(uv,uv)*0.5)*0.5));//fish eye\n\tvec3 col=vec3(0.0);\n\tfloat t,d;\n\tvec3 rp;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\trp=ro+rd*t;\n\t\td=map(rp);\n\t\tif(d<EPS)break;\n\t\tt+=d;\n\t}\n\n\t//col=calcNormal(rp,EPS);\n\tcol=vec3(exp(-0.4*t));\n\tfragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 101, 101, 376], [380, 380, 401, 401, 426], [428, 428, 447, 447, 498], [500, 500, 518, 518, 660], [662, 662, 697, 697, 800], [802, 802, 855, 855, 1283]], "test": "valid"}
{"id": "3ltBWS", "name": "Movementssssss", "author": "elindie", "description": "Waves in one direction rings on rings in the other.", "tags": ["ringswaves"], "likes": 2, "viewed": 63, "published": "Public", "date": "1615356999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat sampleWave(in float x, in float time)\n{\n    float t = sin(x / 50.0 + time) + 1.0;\n    return t;\n}\n\nvec3 paintWave (in vec3 fragColor, in vec2 fragCoord, in float scale, in float height, in float frequency, in vec3 col)\n{\n    float w = sampleWave(fragCoord.x / frequency, iTime) * scale + height;\n    return fragCoord.y < w ? col : fragColor.xyz;\n}\n\nvec3 paintCircle(in vec2 center, in float radius, in vec2 samplePos, in vec3 col, in vec3 bCol) \n{\n    vec2 sphereLocation = vec2(0.34 * iResolution.xy);\n    sphereLocation.y = sampleWave(sphereLocation.x, iTime) * 50.0;\n    \n    float distance = length(samplePos.xy - center.xy);\n    \n    return distance < radius && distance > radius * 0.8 ? bCol : col;\n}\n\nvec3 paintRings (in vec3 col, in vec2 pos, in vec2 fragCoord, in vec3 bCol, in float baseSize)\n{\n  col = paintCircle(pos, baseSize, fragCoord, col, bCol);\n  col = paintCircle(pos, baseSize * 0.7, fragCoord, col, bCol);\n  col = paintCircle(pos, baseSize * 0.5, fragCoord, col, bCol);\n  col = paintCircle(pos, baseSize * 0.3, fragCoord, col, bCol);\n  col = paintCircle(pos, baseSize * 0.1, fragCoord, col, bCol);\n  \n  return col;\n}\n\nvec3 paintRingRow (in vec2 fragCoord, in vec3 col, in vec3 bCol, in float offset, in float timeOffset)\n{\n    float loopTime = 12.0;\n    float loopedScale = mod(iTime, loopTime) / loopTime;\n    \n    vec2 pos = vec2(0.0, 0.0);\n    \n    float iterations = 9.0;\n    for(float i = 0.0; i < iterations; i += 1.0)\n    {\n        float inv = abs(i - iterations);\n        float invScalar = inv / iterations;\n        \n        loopedScale = (mod(iTime + i * 1.333 + timeOffset + offset, loopTime) / loopTime) * 1.2 - 0.1;\n        \n        pos = vec2(loopedScale * iResolution.x, (0.1 + offset) * iResolution.y);\n        pos.y += sampleWave(pos.x / 2.0, iTime) * 30.0 + 0.2 * iResolution.y - 100.0;\n        \n        col = paintRings(col, pos, fragCoord, bCol, 0.098 * iResolution.y);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(uv.y, uv.x, 0.0);\n        \n    float iterations = 5.0;\n    for(float i = 0.0; i < iterations; i += 1.0)\n    {\n        float inv = abs(i - iterations);\n        float invScalar = inv / iterations;\n        \n        col = paintWave(col, fragCoord, 30.0, invScalar * iResolution.y - 100.0, 2.0, col * invScalar);\n    }\n    \n\n    col = paintRingRow(fragCoord, col, vec3(uv.x,uv.y, 0.0), 0.0, 0.5);\n    col = paintRingRow(fragCoord, col, vec3(uv.y, 0.0, uv.x), 0.2, 0.9);\n    col = paintRingRow(fragCoord, col, vec3(0.0,uv.x, uv.y), 0.4, 0.1);\n    \n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 48, 48, 106], [108, 108, 229, 229, 356], [358, 358, 456, 456, 715], [717, 717, 813, 813, 1146], [1148, 1148, 1252, 1252, 1947], [1950, 1950, 2007, 2057, 2726]], "test": "valid"}
{"id": "3lVfRy", "name": "Naive Shaded Helix", "author": "sylvain69780", "description": "I can't stop watching at it.\nMay be because there is still so much artifacts :-)", "tags": ["helix", "coil"], "likes": 21, "viewed": 177, "published": "Public", "date": "1614598441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Naive Shaded Helix\n    ------------------\n    \n    A try to get a decent SDF and domain repetition for an helix.\n    And very cool paradoxical speed effect (Thanks Fabrice)\n    \n    Related references\n    \n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n\n    Quick Lighting Tech - blackle \n    https://www.shadertoy.com/view/ttGfz1\n    \n    soft shadows in raymarched SDFs - IQ\n    http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n*/\n\n\n#define MAX_STEPS 200\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define S smoothstep\n#define T iTime*.3\n#define TAU 6.283185\n \n// a flat band of 1 unit wide, wound around an infinite cylinder of radius r\n// with UV parameters\nvec3 wrappedCylinder(vec3 p, float r) \n{\n    p.y-=-.5; // center the starting point at y=zero\n    float tpr = atan(p.z, p.x);\n    float tp = tpr/TAU;\n    float turn = p.y-tp;      // counting the turns\n    float count=floor(turn);\n    float delta=fract(turn);\n    float ts=tp+count;\n    float u=ts*r*TAU;\n    float v=delta-.5; // from -.5 to .5\n    // fix orientation regarding the slope\n     float slope = 1.0/(TAU*r);\n     u+=v*slope/sqrt(1.0+slope*slope); // sin(atan(x)) = x/sqrt(x2+1)\n     // distance calculation\n    float d = length(p.xz) - r;\n    return vec3(d,u,v);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 ribbon(vec3 p, float r, float spacing, vec2 thickness)\n{\n    float scale=spacing+1.0;\n    vec3 duv = scale*wrappedCylinder(p/scale,r/scale); // I wonder if distances may be preserved\n    float w=duv.x;\n    vec2 uv=duv.yz;\n    vec2 q=duv.xz;\n    float d=sdBox(q,thickness*.5);\n    return vec4(d,uv,w);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {  \t\n    vec4 duvw =  ribbon(p,1.9854+sin(T),0.3643,vec2(.2));\n    vec3 p2=duvw.zyw;\n    p2.y+=T*3.14;\n    vec4 duvw2 = ribbon(p2,.3,0.0,vec2(.1,.5));\n    float d=min(duvw.x,duvw2.x);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p), // forward vector\n        r = normalize(cross(f,vec3(0,1,0) )),   // right vector\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// Inigo\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.33*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = vec2(0);\n    \n    vec3 ro = vec3(0, 1, 5);\n    vec3 ta = vec3(0,0,0);\n    if ( iMouse.x > 0.0 ) {\n        m=2.0*iMouse.xy/iResolution.xy-1.0;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    vec3 rd = GetRayDir(uv, ro, ta, 1.);\n    float d = RayMarch(ro, rd);\n    \n    vec3 col = vec3(.1)/(1.0+3.0*abs(rd.y)); \n    if(d<MAX_DIST) {\n        col = vec3(1);\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        float occ = calcOcclusion(p,n);\n        // Blackle https://www.shadertoy.com/view/ttGfz1\n        float dif= pow(length(sin(n*3.)*.5+.5)/sqrt(3.), 4.);\n    \tfloat lin = dif*occ;\n        col = vec3(1) * lin;\n        // fog\n        float fog=S(9.0,6.0,d);\n        col = mix(vec3(0), col, fog);\n    }\n    col = sqrt(col);\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n// disabled because it impacts the performances more than expected\n// Please enable by renaming mainImage to mainImage0 and mainImagne0 to mainImage\n// to test the improvement \n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage0(out vec4 O, vec2 U) {\n    mainImage(O,U);\n    if ( fwidth(length(O)) > .04 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[615, 714, 754, 754, 1290], [1292, 1292, 1329, 1329, 1409], [1411, 1411, 1472, 1472, 1718], [1720, 1720, 1739, 1739, 1801], [1803, 1803, 1826, 1826, 2024], [2026, 2026, 2060, 2060, 2266], [2268, 2268, 2292, 2292, 2471], [2473, 2473, 2523, 2523, 2750], [2752, 2762, 2811, 2811, 3097], [3100, 3100, 3157, 3157, 4044], [4045, 4425, 4462, 4462, 4801]], "test": "valid"}
{"id": "3lVfW3", "name": "Heart star", "author": "ddpms", "description": "reference : https://www.youtube.com/watch?v=dXyPOLf2MbU", "tags": ["star", "galaxy", "heart"], "likes": 14, "viewed": 320, "published": "Public", "date": "1615191111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_EXPLOSIONS 20.\n#define NUM_HEART_PARTICLES 40.\n#define PI 3.14159265\n#define HEART_COLOR vec3(1., .015, .012)\n\nfloat smoothmax(float a, float b, float k){\n    float h = clamp((b-a)/k+.5, 0., 1.);\n    return mix(a,b,h)+h*(1.-h)*k*.5;\n}\n\nvec2 random12(float t){ \n    float x = fract(sin(t*674.556)*453.2); \n    float y = fract(sin((t+x)*714.3)*263.2); \n    \n    return vec2(x, y);\n}\n\nfloat random21(vec2 i){\n    return fract(sin(dot(i, vec2(321.590,221.630)))*12431.1235);\n}\n\nfloat random11(float t){\n    return fract(sin(t*451252.125)*123124.2525);\n}\n\nvec2 random_polar12(float t){ \n    // polar coordinate\n    float angle = fract(sin(t*674.3)*453.2)*2.*PI; // 0 ~ 2PI \n    float radius = fract(sin((t+angle)*714.3)*263.2);\n    \n    return vec2(sin(angle), cos(angle)) * radius;\n}\n\nfloat Heart(vec2 uv, float blur, float size){\n    float radius = 0.15;\n    blur *= radius;\n    \n    uv*=size*.35;\n    uv.x*=.7; \n    uv.y -= smoothmax(sqrt(abs(uv.x))*0.452, blur, 0.116); \n    float dist= length(uv);\n    \n    return smoothstep(radius+blur, radius-blur,dist);\n}\n\nmat2 rotated2d(float a){\n    return mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\nfloat HeartExplosion(vec2 uv, float speed){\n    float heart_brightness = -1.05; // total heart brightness\n    vec2 dir = random_polar12(1.)*speed;\n    float dist = length(uv-dir*speed);\n    float brightness = mix(0.07,0.146,smoothstep(.05,0.,speed));\n    brightness *= sin(speed*20.)*.25+.75;  // 0~1\n    heart_brightness += brightness/dist;\n\n    for(float i=0.; i<NUM_HEART_PARTICLES; i++){\n        dir = random_polar12(i+1.)*speed;\n        vec2 qt_dir = floor(dir);\n        \n        dist = Heart(uv-dir*speed, 0.212, i);\n        brightness = smoothstep(1.512,1.120, smoothstep(.05,0.,dist));\n        dist *= brightness;\n        \n        heart_brightness += dist;\n    }\n    return heart_brightness*1.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n    float colorbrightness = 0.344;\n    \n    for(float i=0.; i<NUM_EXPLOSIONS; i++){\n        float t = iTime+i/NUM_EXPLOSIONS; \n        float qt_t = floor(t);\n        \n        vec3 color = sin(10.*vec3(0.980,0.542,0.390)*qt_t)*.35+.65; // 0.3 ~ 1\n        // vec3 color = HEART_COLOR;\n        \n        vec2 offset = random12(i+1.+ qt_t)-0.5;\n        offset *= random21(vec2(0.230,0.35));\n        offset *= rotated2d(iTime*0.85+qt_t)*1.6;\n        \n        col += HeartExplosion(uv-offset, fract(t)) * color * colorbrightness;\n    }\n    \n    col *=.09;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 166, 166, 246], [248, 248, 271, 271, 392], [394, 394, 417, 417, 484], [486, 486, 510, 510, 561], [563, 563, 592, 617, 791], [793, 793, 838, 838, 1070], [1072, 1072, 1096, 1096, 1163], [1165, 1165, 1208, 1208, 1870], [1873, 1873, 1930, 1930, 2644]], "test": "valid"}
{"id": "3lVfWt", "name": "Color Ramp, Linear, B-Spline ...", "author": "RV", "description": "Color Ramps\n\n1 - Constant Color\n2 - Linear interpolation between 2 direct colors\n3 - Smoothstep interpolation between 2 direct colors\n4 - BSpline with 4 CatmulRom interpolation on each 4 colors\n\nBy Hervé Bonafos", "tags": ["colorsrampbspline"], "likes": 4, "viewed": 69, "published": "Public", "date": "1615298011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Par Hervé Bonafos\n// 1.0 : 2021, 9 mars\n\n#define CLAMP01(T) clamp((T), 0.0, 1.0)\n#define EASE(T) smoothstep(0.0, 1.0, (T))\n\nvec3 CouleurRVB(in int Hex)\n{\n    // 0xABCDEF\n    int AB = (Hex & 0x00FF0000) >> 16;\n    int CD = (Hex & 0x0000FF00) >> 8;\n    int EF = Hex & 0x000000FF;\n    return pow(vec3(AB, CD, EF)/255.0, vec3(2.2));\n}\n\nvec3 CatmulRom(in float T, vec3 D, vec3 C, vec3 B, vec3 A)\n{\n    return 0.5 * ((2.0 * B) + (-A + C) * T + (2.0 * A - 5.0 * B + 4.0 * C - D) * T*T + (-A + 3.0 * B - 3.0 * C + D) *T*T*T);\n}\n\nvec3 ColorRamp_Constant(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    if(T < B.w) return A.xyz;\n    if(T < C.w) return B.xyz;\n    if(T < D.w) return C.xyz;\n    return D.xyz;\n}\n\nvec3 ColorRamp_Linear(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    // Distances = \n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervales :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Pondérations :\n    float pA = 1.0-iAB;\n    float pB = iAB-iBC;\n    float pC = iBC-iCD;\n    float pD = iCD;\n    \n    return pA*A.xyz + pB*B.xyz + pC*C.xyz + pD*D.xyz;\n}\n\nvec3 ColorRamp_Smoothstep(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    // Distances = \n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervales :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Pondérations :\n    vec4 p = vec4(1.0-iAB, iAB-iBC, iBC-iCD, iCD);\n    p = EASE(p);\n    return p.x*A.xyz + p.y*B.xyz + p.z*C.xyz + p.w*D.xyz;\n}\n\nvec3 ColorRamp_BSpline(in float T, vec4 A, in vec4 B, in vec4 C, in vec4 D)\n{\n    // Distances = \n    float AB = B.w-A.w;\n    float BC = C.w-B.w;\n    float CD = D.w-C.w;\n \n    // Intervales :\n    float iAB = CLAMP01((T-A.w)/AB);\n    float iBC = CLAMP01((T-B.w)/BC);\n    float iCD = CLAMP01((T-C.w)/CD);\n    \n    // Pondérations :\n    vec4 p = vec4(1.0-iAB, iAB-iBC, iBC-iCD, iCD);\n    vec3 cA = CatmulRom(p.x, A.xyz, A.xyz, B.xyz, C.xyz);\n    vec3 cB = CatmulRom(p.y, A.xyz, B.xyz, C.xyz, D.xyz);\n    vec3 cC = CatmulRom(p.z, B.xyz, C.xyz, D.xyz, D.xyz);\n    vec3 cD = D.xyz;\n\n    if(T < B.w) return cA.xyz;\n    if(T < C.w) return cB.xyz;\n    if(T < D.w) return cC.xyz;\n    return cD.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float T = uv.x * 1.1 - 0.05; // plus d'amplitude de fenêtre d'observation\n    if(uv.y < 0.04 || uv.y > 0.96)\n    {\n        if(T >= 0.0 && T <= 1.0)\n        {\n            fragColor = vec4(T); return;\n        }\n        else\n        {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0); return;\n        }       \n    }\n\n#if 0\n    vec4 A = vec4(0,0,0, 0.086);\n    vec4 B = vec4(0.166239, 0.038374, 0.005713, 0.26);\n    vec4 C = vec4(1, 1, 1, 0.527273);\n    vec4 D = vec4(0.601909, 0.678011, 1, 1.0);\n#elif 0\n    // Couleurs trouvées ici : https://colorhunt.co/palette/252860\n    vec4 A = vec4(CouleurRVB(0x75cfb8), 0.08);\n    vec4 B = vec4(CouleurRVB(0xbbdfc8), 0.26);\n    vec4 C = vec4(CouleurRVB(0xf0e5d8), 0.57);\n    vec4 D = vec4(CouleurRVB(0xffc478), 0.95);\n#elif 0\n    // Couleurs trouvées ici : https://colorhunt.co/palette/252863\n    vec4 A = vec4(CouleurRVB(0x94b5c0), 0.08);\n    vec4 B = vec4(CouleurRVB(0x350b40), 0.26);\n    vec4 C = vec4(CouleurRVB(0xad6c80), 0.57);\n    vec4 D = vec4(CouleurRVB(0xee99a0), 0.95);\n#elif 01\n    // Couleurs trouvées ici : https://colorhunt.co/palette/361\n    vec4 A = vec4(CouleurRVB(0x6a2c70), 0.05 + sin(iTime*0.8)*0.05);\n    vec4 B = vec4(CouleurRVB(0xb83b5e), 0.22 + sin(iTime*1.3 + 2.0)*0.1);\n    vec4 C = vec4(CouleurRVB(0xf08a5d), 0.5 + sin(iTime*1.12 + 4.0)*0.15);\n    vec4 D = vec4(CouleurRVB(0xf9ed69), 0.9 + sin(iTime*2.1 + 5.0)*0.2);\n#endif\n \n \n \n    vec3 Couleur = vec3(1,0,1);\n    if(uv.y > 0.04) Couleur = ColorRamp_BSpline(T, A,B,C,D);      // Ligne 4\n    if(uv.y > 0.27) Couleur = ColorRamp_Smoothstep(T, A,B,C,D);   // Ligne 3\n    if(uv.y > 0.5) Couleur = ColorRamp_Linear(T, A,B,C,D);        // Ligne 2\n    if(uv.y > 0.73) Couleur = ColorRamp_Constant(T, A,B,C,D);     // Ligne 1\n\n//Couleur = ColorRamp_BSpline(uv.x, A,B,C,D);\n    fragColor = vec4(pow(Couleur.xyz, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 157, 173, 334], [336, 336, 396, 396, 523], [525, 525, 603, 603, 713], [715, 715, 791, 811, 1197], [1199, 1199, 1279, 1299, 1660], [1662, 1662, 1739, 1759, 2353], [2355, 2355, 2412, 2462, 4355]], "test": "valid"}
{"id": "3lVfWV", "name": "Dendrite-Biased Julia Rotation", "author": "jdc", "description": "Dendrite-Biased Julia Set\n\nc_i loiters near zero\nc_j loiters near one and negative one", "tags": ["fractal", "julia", "dendrite"], "likes": 1, "viewed": 161, "published": "Public API", "date": "1615086254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    The Julia set is the subset of the complex plane given by the points \n    whose nth iteration of the function f_c (z) = z * z + c has a modulus \n    of at most two for all natural n.\n*/\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n// Pi divided by two (pi/2)\nconst float M_PI_2 = 1.57079632679489661923132169163975144;\n\nvec2 multiply(vec2 x,vec2 y){\n    return vec2(x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 5.*(fragCoord/iResolution.x-vec2(.5,.27));\n    vec3 col;\n\n    float a = M_PI_2 * sin(M_PI_2 * sin(M_PI_2 * sin(M_PI_2 * sin(M_PI_2 * sin(iTime / 2.)))));\n    float noise = sin(M_PI * sin(9.*iTime)) / 600.;\n    vec2 c = vec2(sin(a + M_PI_2) + noise, sin(a) + noise);\n\n    for(int i = 0; i < 500;i++){\n\n        vec2 z = multiply(z0,z0)+c;\n        float mq = dot(z,z);\n        if( mq > 4.){\n\n            col = vec3(float(i)/20.,0.,float(i)/4.);\n            break;\n        } else {\n            z0 = z;\n        }\n        col = vec3(mq/2.,0.,(mq * float(i))/4.);\n    }\n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 403, 432, 432, 484], [485, 485, 542, 542, 1151]], "test": "valid"}
{"id": "3lyBRt", "name": "Tribute to my old Atari", "author": "mrange", "description": "License CC0: Tribute to my old Atari\nThat's where it started for me\nMusic: Rob Hubbard - Goldrunner - Piano performed by LightSide", "tags": ["2d", "fbm", "atari"], "likes": 10, "viewed": 443, "published": "Public API", "date": "1614814743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Tribute to my old Atari\n//  That's where it started for me\n//  Music: Rob Hubbard - Goldrunner - Piano performed by LightSide\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define PSIN(x)     (0.5+0.5*sin(x))\n\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n  \n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynomial min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// IQ's box\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's isosceles triangle\nfloat isosceles(vec2 p, vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// IQ's horseshoe\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, \n            c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n           (p.x>0.0)?p.y:l );\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// IQ's segment\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n// IQ's segment\nfloat parabola(vec2 pos, float k) {\n  pos.x = abs(pos.x);\n  float ik = 1.0/k;\n  float p = ik*(pos.y - 0.5*ik)/3.0;\n  float q = 0.25*ik*ik*pos.x;\n  float h = q*q - p*p*p;\n  float r = sqrt(abs(h));\n  float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n  return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat atari(vec2 p) {\n  p.x = abs(p.x);\n  float db = box(p, vec2(0.36, 0.32));\n\n  float dp0 = -parabola(p-vec2(0.4, -0.235), 4.0);\n  float dy0 = p.x-0.115;\n  float d0 = mix(dp0, dy0, smoothstep(-0.25, 0.125, p.y)); // Very hacky\n\n  float dp1 = -parabola(p-vec2(0.4, -0.32), 3.0);\n  float dy1 = p.x-0.07;\n  float d1 = mix(dp1, dy1, smoothstep(-0.39, 0.085, p.y)); // Very hacky\n\n  float d2 = p.x-0.035;\n  const float sm = 0.025;\n  float d = 1E6;\n  d = min(d, max(d0, -d1));;\n  d = pmin(d, d2, sm);\n  d = pmax(d, db, sm);\n  \n  return d;\n}\n\nfloat atari_a(inout vec2 p, vec2 off) {\n  p -= vec2(0.275, 0.0);\n\n  float d0 = isosceles(p*vec2(1.0, -1.0)-vec2(0.0, -0.225), vec2(0.20, 0.65))-0.1;\n  float d1 = isosceles(p*vec2(1.0, -1.0)-vec2(0.0, -0.18), vec2(0.13, 0.55))-0.005;\n  float d2 = box(p-vec2(0.0, -0.135), vec2(0.15, 0.06));\n  float d3 = p.y+0.325;\n\n  float d = d0;\n  d = max(d, -d1);\n  d = pmin(d, d2, 0.0125);\n  d = pmax(d, -d3, 0.0125);\n\n  p -= vec2(0.275, 0.0) + off;\n\n  return d;\n}\n\nfloat atari_i(inout vec2 p, vec2 off) {\n  p -= vec2(0.07, 0.0);\n\n  float d0 = box(p, vec2(0.07, 0.325)-0.0125)-0.0125;\n\n  float d = d0;\n\n  p -= vec2(0.07, 0.0) + off;\n  return d;\n}\n\nfloat atari_r(inout vec2 p, vec2 off) {\n  p -= vec2(0.22, 0.0);\n\n  float d0 = p.y+0.325;\n  float d1 = circle(p - vec2(-0.12, 0.225), 0.1);\n  const float a = PI/2.0;\n  const vec2 c = vec2(cos(a), sin(a));\n  vec2 hp = p;\n  hp -= vec2(0.0, 0.14);\n  hp.xy = -hp.yx;\n  float d2 = horseshoe(hp, c, 0.125, 0.2175*vec2(0.12,0.275));\n  float d3 = segment(p-vec2(-0.015, 0.005), vec2(0.0), vec2(0.22, -0.4))-0.07;\n  float d5 = p.y - 0.205;\n  float d6 = box(p - vec2(-0.155, -0.075), vec2(0.065, 0.30));\n  float d7 = box(p - vec2(-0.055, 0.225), vec2(0.06, 0.1));\n  \n  float d = d1;\n  d = min(d, d7);\n  d = max(d, -d5);\n  d = min(d, d2);\n  d = min(d, d6);\n  d = min(d, d3);\n  d = pmax(d, -d0, 0.0125);\n  p -= vec2(0.25, 0.0)+off;\n  \n  return d;\n}\n\nfloat atari_t(inout vec2 p, vec2 off) {\n  p -= vec2(0.195, 0.0);\n\n  float d0 = box(p - vec2(0.0, 0.265), vec2(0.195, 0.06)-0.0125)-0.0125;\n  float d1 = box(p - vec2(0.0, -0.03), vec2(0.07, 0.295)-0.0125)-0.0125;\n  \n  float d = d0;\n  d = pmin(d, d1, 0.0125);\n  \n  p -= vec2(0.195, 0.0) + off;\n  \n  return d;\n}\n\nfloat atari_text(vec2 p) {\n  p -= vec2(-0.33, 0.0);\n  float d = 1E6;\n  vec2 rp = p;\n  rp.x = abs(rp.x);\n  rp.x -= -0.195;\n  d = min(d, atari_t(rp, vec2(-0.055, 0.0)));\n  d = min(d, atari_a(rp, vec2(-0.055, 0.0)));\n  p.x -= 0.72;\n  d = min(d, atari_r(p, vec2(0.02, 0.0)));\n  d = min(d, atari_i(p, vec2(0.0, 0.0)));\n  return d;\n}\n\nfloat height_(vec2 p) {  \n  p *= 0.2;\n  vec2 p0 = p;\n  vec2 n0 = hextile(p0);\n  p0 *= ROT(TAU*hash(n0));\n  const float ss = 0.95;\n  float d0 = atari(p0/ss)*ss;\n  float d = d0;\n  return 0.25*tanh_approx(smoothstep(0.0125, -0.0125, d)*exp(2.0*-d));\n//  return 0.25*smoothstep(0.0125, -0.0125, d);\n}\n\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.23);\n  float tm = 123.0+TTIME/320.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 6; ++i) {\n    h += a*height_(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat synth(vec2 p) {\n  const float z = 4.0;\n  const float st = 0.02;\n  float dob = box(p, vec2(1.4, 0.5));\n  p.x = abs(p.x);\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 1;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x; \n    fft = sqrt(fft);\n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\n    dib = min(dib, dibb);\n  }\n  \n  float dl = p.y;\n  dl = abs(dl) - 0.005;\n  dl = abs(dl) - 0.0025;\n  dl = abs(dl) - 0.00125;\n  float d = dib;\n  d = max(d, -dl);\n  d = pmax(d, dob, 0.025);\n  return d*z;\n}\n\nvec3 color(vec2 p) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.25, 1.35, 2.0);\n  vec3 lcol2 = vec3(2.0, 1.55, 1.25);\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.25*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 20.0)*lcol1;\n  col += rm*pow(ref2, 20.0)*lcol2;\n\n  float ds = synth(ppp-vec2(0.0, -0.75));\n\n  const float zp = 1.35;\n  float di = atari_text(ppp/zp)*zp;\n  float dio = di;\n  dio = abs(dio-0.015) - 0.0075;\n  \n  di = min(di, dio);\n  float dg = di;\n  di = min(di, ds);\n\n  col += -lcol2*0.125*(exp(-5.0*max(di, 0.0)));\n \n  col = mix(col, vec3(0.85), smoothstep(-aa, aa, -di));\n  dg = abs(dg-0.025);\n  dg = abs(dg-0.0125);\n  float glow = exp(-20.0*max(dg+0., 0.0));\n  vec3 glowCol = mix(lcol2.zyx*lcol2.zyx/6.0, lcol2.zyx, glow*glow);\n  col += glowCol*glow*pow(PSIN(-0.8+0.5*p.x-p.y-TTIME/16.0), 14.0);\n\n  return col;\n}\n\n// Post processing I found somewhere on shadertoy years ago\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);  \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 8.0, TIME);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "MlfXD8", "previewfilepath": "https://soundcloud.com/lightside-piano/goldrunner", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lightside-piano/goldrunner", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBRt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 419, 440, 440, 507], [509, 509, 537, 636, 957], [959, 959, 987, 1007, 1083], [1085, 1108, 1147, 1147, 1232], [1234, 1234, 1273, 1273, 1302], [1304, 1304, 1334, 1334, 1361], [1363, 1375, 1402, 1402, 1478], [1480, 1480, 1511, 1511, 1537], [1539, 1566, 1599, 1599, 1893], [1895, 1913, 1963, 1963, 2206], [2208, 2224, 2263, 2263, 2376], [2378, 2394, 2429, 2429, 2767], [2769, 2769, 2790, 2790, 3305], [3307, 3307, 3346, 3346, 3758], [3760, 3760, 3799, 3799, 3940], [3942, 3942, 3981, 3981, 4677], [4679, 4679, 4718, 4718, 4987], [4989, 4989, 5015, 5015, 5316], [5318, 5318, 5341, 5341, 5614], [5617, 5617, 5639, 5639, 6008], [6010, 6010, 6031, 6031, 6237], [6239, 6239, 6278, 6278, 6403], [6405, 6405, 6426, 6426, 7044], [7046, 7046, 7066, 7066, 8706], [8708, 8768, 8804, 8804, 9037], [9039, 9039, 9094, 9094, 9347]], "test": "error"}
{"id": "3lyBWV", "name": "Nonlinear Repetition", "author": "oneshade", "description": "Repetition with a twist.", "tags": ["repetition", "nonlinear", "pseudoexact"], "likes": 11, "viewed": 135, "published": "Public", "date": "1615031931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define distrib(x) x * x * sign(x)\n#define distribInv(x) sqrt(abs(x)) * sign(x)\n\nvec2 nonlinearRepeat(in float x, in float interv) {\n    float cell = distribInv(round(distrib(x) / interv) * interv);\n    return vec2(x - cell, cell);\n}\n\nfloat sdBox(in vec2 p, in vec2 s) {\n    return length(p - clamp(p, -s, s)) + min(0.0, max(abs(p.x) - s.x, abs(p.y) - s.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float a = sin(iTime) * 1.57;\n    float c = cos(a), s = sin(a);\n    uv *= mat2(c, -s, s, c);\n\n    vec2 rep = nonlinearRepeat(atan(uv.y, uv.x), 1.0);\n    uv = sin(rep.x + vec2(1.57, 0.0)) * length(uv);\n    uv.x -= 0.25;\n\n    float d = sdBox(uv, vec2(0.05 / (abs(rep.y) + 1.0)));\n    color += 0.125 + 0.125 * sin(d * 200.0);\n    color = mix(color, mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), abs(rep.y / 3.14)), smoothstep(unit, 0.0, d));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 132, 132, 233], [235, 235, 270, 270, 360], [362, 362, 417, 417, 1029]], "test": "valid"}
{"id": "3lyBzc", "name": "raymarchin2 McDonalds McMilitia", "author": "bradseeker", "description": "raymarching w shading\ngot my ants in [a] row(s)", "tags": ["raymarchin"], "likes": 0, "viewed": 24, "published": "Public", "date": "1614808762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MIN_DISTANCE 5.0\n#define MAX_DISTANCE 200.0\n\n#define MAX_STEPS 100\n#define THRESHOLD 0.001\n\nvec4 sphere = vec4(0.,2.5,0.,2.);\nvec4 head   = vec4(0.,5.7,0.,1.6);\nvec3 camera = vec3(0.,2.,-12.);\nvec3 light  = vec3(8., 32., 16.);\nvec3 cameraAngle1 = - vec3(0,-0.2,0);\n\nvec2 spoints = vec2(0.01, 0.0);\n\nvec3 repPeriod = vec3(8.,0.,8.);\nfloat tmod = 60.0/97.0 * 2.0;\n\nfloat getDistance(vec3 p) {\n    vec3 moff = mod(p- sphere.xyz+repPeriod/2.,repPeriod)+repPeriod/-2.; // uncomment to enable infinite repetition\n    //vec3 moff = p - sphere.xyz; // uncomment to bypass infinite repetition\n    moff.y += cos(p.y/sphere.w);\n    \n    vec3 h = mod(p- head.xyz+repPeriod/2.,repPeriod)+repPeriod/-2.; // uncomment to enable infinite repetition\n    return min(p.y, min(length(moff)-sphere.w, length(h)-head.w));\n    //return length(moff)-sphere.w;\n}\n\nfloat getDistanceMarch(vec3 p, float travelled, float cutoff) {\n    if(travelled > cutoff) {\n        return getDistance(p);\n    }\n    return cutoff*2.;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n   \n    vec3 n = d - vec3(\n        getDistance(p-spoints.xyy),\n        getDistance(p-spoints.yxy),\n        getDistance(p-spoints.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getNearestColor(vec3 p) {\n    //return vec3(1.,1.,1.);\n    vec3 moff = mod(p- sphere.xyz+repPeriod/2.,repPeriod)+repPeriod/-2.;\n    vec3 h = mod(p- head.xyz+repPeriod/2.,repPeriod)+repPeriod/-2.;\n    moff.y += cos(p.y);\n    if (length(moff)-sphere.w < p.y) {\n        if (length(h)-head.w < length(moff)-sphere.w) return vec3(1.,0.85,0.46);\n        return vec3(0.8,0.,0.2);\n    }\n    else return vec3(1.,1.,1.);\n}\n\nfloat marchRay(vec3 dir) {\n    float dist = 0.0;\n    vec3 dir2 = dir;\n    for (int i = 0; i<MAX_STEPS; i++) {\n        //dir2.xy += dir.xy/wiggle;\n\n        vec3 spot = camera + dist * ( normalize( dir2 ) );\n        float last = getDistanceMarch(spot, dist, MIN_DISTANCE);\n        \n        dist += last;\n        if (dist > MAX_DISTANCE || last < THRESHOLD) {\n           break;\n        }\n    }\n    return dist;\n}\n\nfloat marchRay2(vec3 dir, vec3 p) {\n    float dist;\n    for (dist = THRESHOLD; dist<MAX_DISTANCE;) {\n        float last = getDistanceMarch(p + dist * dir , dist, 0.05);\n        //float last = getDistance(p + dist * normalize( dir ));\n        if (last < THRESHOLD) {\n           return 0.0;\n           //break;\n        }\n        dist += last;\n        \n    }\n    return dist;\n}\n\nfloat softshadow2( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=THRESHOLD+0.1; t<MAX_DISTANCE; )\n    {\n        float h = getDistance(ro + rd*t);\n        if( h<THRESHOLD )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = MAX_DISTANCE;\n    for( float t=THRESHOLD+0.1; t<MAX_DISTANCE; )\n    {\n        float h = getDistance(ro + rd*t);\n        if( h<THRESHOLD )\n            return 0.0;\n        res = min( res, h );\n        t += h;\n    }\n    return res;\n}\n\nfloat getLight(vec3 p) {\n    vec3 l = normalize(light-p);\n    vec3 n = getNormal(p);\n\n    float d = marchRay2(l, p);\n    float dif = clamp(dot(n, l),0., 1.);\n    //dif *= softshadow(p, l, 64.0);\n    //dif *= d/MAX_DISTANCE;\n    if (d<length(light-p)) dif *= 0.1;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mTime = iTime * tmod;\n    //camera.x = cos(mTime/8.0)*16.0;\n    //sphere.w = cos(mTime/8.0)*2.0;\n    camera.y = (sin(mTime/4.0)*2.0)+16.;\n    camera.z = mTime*4.;\n    //camera.z = cos(mTime/4.0)*16.0;\n    \n    light.x = camera.x;\n    light.y = camera.y+2.;\n    light.z = camera.z+16.;\n    cameraAngle1.x += cos(mTime/3.0)*0.3;\n\n    sphere.x += (tan(mTime/8.0))*4.;\n    head.x += (tan(mTime/8.0))*4.;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord+(iResolution.xy/-2.0))/iResolution.y;\n    \n    \n    vec3 fire = normalize(vec3(uv.x, uv.y, 1.0 )- cameraAngle1);\n    //float wiggle = 600.0-(sin(mTime*2.0)+1.0)*275.0;\n    \n    float dist = marchRay(fire.xyz);\n    vec3 dif = vec3(0.);\n    if (dist<MAX_DISTANCE){\n        dif = getLight(camera + fire*dist) * getNearestColor(camera + fire*dist);\n    }\n    vec3 col = vec3(dif* (1.-length(light-camera + fire*dist)/MAX_DISTANCE));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 399, 399, 846], [848, 848, 911, 911, 1001], [1003, 1003, 1027, 1027, 1225], [1227, 1227, 1257, 1286, 1644], [1646, 1646, 1672, 1672, 2055], [2057, 2057, 2092, 2092, 2431], [2433, 2433, 2487, 2487, 2842], [2844, 2844, 2897, 2897, 3144], [3146, 3146, 3170, 3170, 3426], [3429, 3429, 3486, 3486, 4460]], "test": "valid"}
{"id": "3lyfDd", "name": "rayTracingTesting1", "author": "CoderHusk", "description": "raytracing", "tags": ["raytracing"], "likes": 0, "viewed": 346, "published": "Public", "date": "1615260799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float bound(float minv, float maxv, float v) {\n  return (-minv+v)/(-minv+maxv);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    vec3 col = vec3(0);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 cameraPosition = vec3(cos(iTime),sin(iTime),0);\n    vec3 pixelToCameraDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 p = vec3(0.0,0.0,4.0);\n    float r = 1.0f;\n    float t = dot(p-cameraPosition, pixelToCameraDirection);\n    vec3 pEqu = cameraPosition + pixelToCameraDirection*t;\n    \n    float y = length(p-pEqu);\n    if (y<r) {\n        float x = sqrt(r*r - y*y);\n        float t1 = t-x;\n        float c = bound(p.z, p.z-r, t1);\n        col = vec3(c);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 81], [82, 82, 139, 139, 772]], "test": "valid"}
{"id": "3lyfDm", "name": "Tessellation from @kamoshika_vrc", "author": "jstrom2002", "description": "Procedurally generated tessellation from @kamoshika_vrc from the following tweet: https://twitter.com/kamoshika_vrc/status/1365546685636636673?s=20. Re-posted here to examine the code in depth.", "tags": ["test"], "likes": 1, "viewed": 154, "published": "Public API", "date": "1614809505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfloat fsnoise(vec2 c){\n    return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;// [0,iResolution] coords\n    uv *= 2.0;// zoom out.\n\n    // Pattern generation.\n    vec2 p=uv.xy/iResolution.y*4. + iTime;\n    vec2 I=floor(p/4.);\n    p = mod(p,4.) - 2.0;\n    float i;\n    for(;i++<9.;){\n        p=abs(p)-1.;\n        p/=dot(p,p);\n        if(length(p)<1.)\n        break;\n    }    \n    vec4 o;\n    o.rgb = rgb2hsv(vec3(fsnoise(I+i*.1),1.,1.))/abs(sin(max(p.x,p.y)*5.))/i;\n\n    // Output to screen\n    fragColor = vec4(o.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 81, 81, 412], [414, 414, 436, 436, 505], [508, 508, 565, 565, 1036]], "test": "valid"}
{"id": "3lyfDt", "name": "Ray Marching Triangle Primitive", "author": "kovacjosh", "description": "some sdfs for ray marching primitives", "tags": ["raymarching"], "likes": 0, "viewed": 68, "published": "Public", "date": "1615266707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Global constants for rendering\nconst float maxSteps = 150.;\nconst float hitThreshold = .00001;\nconst float maxDistance = 1000.;\nconst float specExp = 6.;\n\n// Useful general purpose functions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nmat3 rotMat(vec3 u, float t)\n{\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\n// Primitive Structs\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\nstruct Triangle\n{\n  vec3 a;\n  vec3 b;\n  vec3 c;\n  vec3 color;\n};\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\n// General Stucts and their functions\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n// Signed distance functions for primitives\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p-s.center)-s.radius, s.color);\n}\nHit boxSDF(vec3 p, Box b)\n{\n    vec3 q = abs(p - b.center) - (b.size);\n    float radius = 0.02;\n    return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\nHit triangleSDF(vec3 p, Triangle tri)\n{\n    vec3 ba = tri.b - tri.a; vec3 pa = p - tri.a;\n    vec3 cb = tri.c - tri.b; vec3 pb = p - tri.b;\n    vec3 ac = tri.a - tri.c; vec3 pc = p - tri.c;\n    vec3 nor = cross( ba, ac );\n\n    float dist = sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(ac,nor),pc))<2.0)\n         ?\n         min( min(\n         dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n         dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n         dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n         :\n         dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    return Hit(dist, tri.color);\n}\n\n// Where the scene is defined\nHit map(vec3 p)\n{\n    mat3 rot = rotMat(vec3(0.,1.,0.), iTime/5.);\n    vec3 rp = rot*p;\n    Hit hit1 = triangleSDF(rp, Triangle(\n        vec3(-1.0, -1.0, 1.0), \n        vec3(1.0, -1.0, 1.0), \n        vec3(0.0, 1.0, 0.0),\n        vec3(2.0, 0., 0.)\n    ));\n    Hit hit2 = triangleSDF(rp, Triangle(\n        vec3(1.0, -1.0, 1.0),\n        vec3(0.0, -1.0, -1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0., 2.0, 0.)\n    ));\n    Hit hit3 = triangleSDF(rp, Triangle(\n        vec3(0.0, -1.0, -1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0., 0., 2.0)\n    ));\n    \n    return hitMin(hit3, hitMin(hit1, hit2));\n}\n\n// Approximate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec2 eps = vec2(0.001, 0);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(0., 6., 5.), 20., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., -5., 5.), 2., vec3(1., .5, .1), 8.),\n        Light(vec3(5., 0., 5.), 6., vec3(1., 0., 1.), 1.)\n    );\n    vec3 ambient = vec3(0.8,0.63,0.50) * .05;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness);\n        \n        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glow = vec3(1., .5, 1.) * .1;\n    float t = 0.;\n    float i = 0.;\n    while (i < maxSteps && t <= maxDistance)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color + glow * i/maxSteps;\n        }\n        t += closestHit.t;\n        i += 1.;\n    }\n    //\n    // Calculate skybox, change the vec3 below\n    //\n    return vec3(0.01, 0.02, 0.03) + glow * smoothstep(0., 1.5, i/maxSteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to uv coordinates\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    vec3 e = vec3(0., 0., 1.7);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    fragColor = vec4(raymarch(viewRay) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 194, 219, 219, 238], [239, 239, 264, 264, 283], [284, 284, 314, 314, 628], [898, 1073, 1106, 1106, 1145], [1146, 1146, 1172, 1172, 1254], [1256, 1300, 1333, 1333, 1389], [1390, 1390, 1417, 1417, 1574], [1575, 1575, 1614, 1614, 2236], [2238, 2268, 2285, 2285, 2905], [2907, 2959, 2984, 2984, 3265], [3267, 3305, 3353, 3353, 3783], [3785, 3841, 3881, 3881, 4784], [4786, 4818, 4842, 4842, 5493], [5495, 5495, 5552, 5603, 6257]], "test": "error"}
{"id": "3tcfDf", "name": "Realistic Flag", "author": "TekF", "description": "March 31st is Transgender Day of Visibility, so I thought it was a good time to revisit the [url=https://www.shadertoy.com/view/ldX3DX]flag shader[/url] I made 8 years ago (before I came out as trans!).\n", "tags": ["raymarching", "uvmapping"], "likes": 34, "viewed": 443, "published": "Public API", "date": "1617107041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// Trans day of visibility is March 31st.\n\n\nconst float tau = 6.28318530717958647692;\n\nvec2 gFragCoord;\n\n\n// Tone Mapping\n\nconst float exposure = .75;\n\n// Exposure curve parameters\n//#define SHOW_CURVE 1\nconst vec3 gradient = vec3(1.4,1.5,1.6);\nconst vec3 whiteSoftness = vec3(.1);\nconst vec3 blackClip = vec3(.0);\nconst vec3 blackSoftness = vec3(.05);\n\nvec3 LinearToSRGB ( vec3 col )\n{\n    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );\n}\n\nvec3 SRGBToLinear ( vec3 col )\n{\n    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );\n}\n\nvec3 HDRtoLDR( vec3 col )\n{\n    col *= exposure;\n\n#if (1)\n    // soft cut off near black to enhance contrast\n   \t// this is good for correcting for atmospheric fog\n\tcol = max(col-blackClip,0.); \n    col = sqrt(col*col+blackSoftness*blackSoftness)-blackSoftness;\n\n    col *= gradient;\n    \n    // soft clamp to white (oh this is so good)\n    vec3 w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n#else\n    // skip tone mapping\n\tcol*=.4;\n#endif\n    \n\treturn LinearToSRGB(col);\n}\n\n\nfloat linstep( float a, float b, float c )\n{\n    return clamp((c-a)/(b-a),0.,1.);\n}\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = gFragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec4 Noise( in vec2 x )\n{\n    x = x*sqrt(3./4.) + x.yx*vec2(1,-1)*sqrt(1./4.); // tilt the grid so it's not aligned to the flag to make it less visible\n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec2 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = p + f;\n\n#if (0)\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 fuv = uv - vec2(iuv);\n    \n\tvec4 rg = mix( mix(\n\t\t\t\ttexelFetch( iChannel0, iuv&255, 0 ),\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(1,0))&255, 0 ),\n\t\t\t\tfuv.x ),\n\t\t\t\t  mix(\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(0,1))&255, 0 ),\n\t\t\t\ttexelFetch( iChannel0, (iuv+ivec2(1,1))&255, 0 ),\n\t\t\t\tfuv.x ),\n\t\t\t\tfuv.y );\n#endif\t\t\t  \n\n\treturn rg;\n}\n\n\n// ----------------------\n\nfloat RippleHeight( vec2 pos )\n{\n    float time = iTime*2.;\n\n\tvec2 p = pos+vec2(-2,.2)*time;\n\t\n\tp += vec2(1,0)*Noise(p).y; // more natural looking ripples\n\tfloat f = Noise(p).x-.5;\n\tp *= 2.0;\n\tp += vec2(0,-.5)*time;\n\tf += (Noise(p).x-.5)*.2;\n\tp *= 1.6;\n\tp += vec2(-1,0)*time;\n\tf += (Noise(p).x-.5)*.05;\n\t\n\tf = f*(1.0-exp2(-abs(pos.x)));\n\treturn f*1.2;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn (RippleHeight(pos.xy)-pos.z)*.5;\n}\n\nvec3 Normal( vec3 pos )\n{\n\tvec2 delta = vec2(-1,1)*.01;//*length(fwidth(pos)); // gets moire artefacts if this is too small\n\treturn normalize(\n                DistanceField( pos + delta.xxx )*delta.xxx +\n                DistanceField( pos + delta.yyx )*delta.yyx +\n                DistanceField( pos + delta.yxy )*delta.yxy +\n                DistanceField( pos + delta.xyy )*delta.xyy\n            );\n}\n\n// map a uv space onto a distorted surface\nvec2 UVMapping( vec2 target )\n{\n    // bow the left edge so it's just mounted at 2 points\n    float bow = cos(target.y*6.283185/4.)*.08;\n    target.x -= bow;\n\n    float droop = 2.; // the technique isn't really robust enough for this to look realistic at bigger values\n    target.y += droop;\n    \n\t// need to march vertically to absorb vertical creases, and horizontally for horizontal ones\n\t// cheat, by seperating these two\n\tvec2 uv = vec2(0);\n\t\n    // make flag droop toward the right by offsetting target y\n    // hopefully this means it will droop more the more disruption there is\n//    target.y += target.x*.5;\n    \n    \n\tconst int n = 16;\n\tconst float fudge = 1.0; // use values > 1 to allow for extra ripples we're not measuring\n\tvec2 d = target/float(n);\n\tvec2 l;\n\tl.x = RippleHeight( vec2(0,target.y) );\n\tl.y = RippleHeight( vec2(target.x,0) );\n\tfor ( int i=0; i < n; i++ )\n\t{\n\t\tvec2 s;\n\t\ts.x = RippleHeight( vec2(d.x*float(i),target.y) );\n\t\ts.y = RippleHeight( vec2(target.x,d.y*float(i)) );\n\t\t//uv.x += sign(d.x)*sqrt(pow(fudge*,2.0)+d.x*d.x);\n\t\t//uv.y += sign(d.y)*sqrt(pow(fudge*,2.0)+d.y*d.y);\n        \n\t\tuv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);\n\t\tl = s;\n\t}\n    \n//    uv.y += (uv.x+1.)*uv.x*.05; // droop toward the end\n\t\n    uv.y -= droop;\n    \n\treturn (uv+vec2(0,1))/vec2(3.0,2.0);\n}\n\nvec3 Pattern( vec2 uv )\n{\n    // striped patterns\n\n    // trans flag\n    vec3 colours[] = vec3[]( vec3(.3,.7,1), vec3(1,.2,.4), vec3(1), vec3(1,.2,.4), vec3(.3,.7,1) );\n\n    // lesbian\n    //vec3 colours[] = vec3[]( vec3(.8,.05,.0), vec3(1,.3,.0), vec3(1,.5,.2), vec3(1), vec3(1,.3,.6), vec3(.7,.1,.4), vec3(.5,.0,.2) );\n    \n    float smoothidx = (1.-uv.y)*float(colours.length()) + .5;\n    int idx = int(floor( smoothidx ));\n    float fidx = smoothidx - float(idx);\n    fidx -= .5;\n    \n    return mix(colours[max(0,idx-1)],colours[idx],\n                //step(.0,fidx)); // aliased\n                 smoothstep( -fidx, 1.-fidx, fidx/max(fwidth(smoothidx),.0001) ));// anti-aliased\n\n/*\n    // checker\n    float pattern = (fract(uv.x/.2)-.5)*(fract(uv.y/.3)-.5);\n    return mix( vec3(.03), vec3(1), smoothstep( -fwidth(pattern)*.5, fwidth(pattern)*.5, pattern ) ); // this antialiasing doesn't work\n*/\n}\n\nfloat Mask( vec2 uv )\n{\n    // todo: use fwidth so it is correct for distance\n\n\treturn max(\n            smoothstep(.495,.5,abs(uv.x-.5)),\n            smoothstep(.495,.5,abs(uv.y-.5))\n        );\n}\n\n\nfloat Weave( vec2 uv )\n{\n\tvec2 a = uv*vec2(3.0,2.0)*500.*.85;\n\tfloat f = (sin(a.x)+sin(a.y))*.25+.5;\n\n    f = mix( f, .5, min( 1., .2*max( fwidth(a.x), fwidth(a.y) ) ) ); // prevent moire\n\n    return f;\n}\n\n\nfloat Seam( vec2 uv )\n{\n    return smoothstep( .5, .48, abs(uv.y-.5) )\n          *smoothstep( 1., .985, uv.x )\n          *smoothstep( .02, .03, uv.x );\n}\n\n\nvec3 airColourLog2 = vec3(.1,.3,.6);\n\n// quick and pretty sky colour\nvec3 SkyColour( vec3 ray )\n{\n    vec3 col = exp2(-ray.y/airColourLog2); // blue - from https://www.shadertoy.com/view/4ljBRy\n    \n    // add some clouds\n    vec2 cloudUV = ray.xz/(ray.y+.2) + iTime*vec2(-.03,0);\n    vec4 clouds = (\n          Noise(4.*cloudUV)\n        + Noise(10.*cloudUV)*.4\n        + Noise(25.*cloudUV)*.16\n        + Noise(50.*cloudUV)*.04\n        )/1.6;\n    \n    col = mix( col, clouds.yyy, pow(smoothstep(.05,.6,clouds.x),8.)*1.*max(0.,ray.y) );\n    \n    // horizon\n    float horizonSDF = ray.y - .09 - .04*Noise(ray.xz*9.).x - .03*(.5-abs(Noise(ray.xz*5.).x-.5));\n    col = mix( col, mix( vec3(1), vec3(.1), exp2(-3.*airColourLog2*.01/(.01+max(0.,-horizonSDF))) ), smoothstep(.003, -.003, horizonSDF ) );\n    \n    return col;\n}\n\n\nvec3 Ambient( vec3 normal )\n{\n    return mix( vec3(.1,.07,.05), vec3(.15,.2,.25), normal.y*.3+.7 );\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    gFragCoord = fragCoord;\n\n\n    vec3 camPos, ray;\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    if ( dot(iMouse.xy,vec2(1)) <= 0. ) mousePos = (.5-.5*cos(vec2(1.,.618)*.1*iTime)) * vec2(1,.5);\n    CamPolar( camPos, ray, vec3(1.5,0,0), vec2(-.8,-.5)+vec2(1.2,1.5)*mousePos.yx, 20.0, 5. );\n    \n    if ( dot(iMouse.xy,vec2(1)) <= 0. )\n    {\n        // keep the camera on the ground, so it feels like we're looking up at a flag in a physical space\n        camPos = camPos * (-20.)/(camPos.y);\n        // for some reason this is offsetting the view to the right, so the flag's not at the centre of the frame\n        // this wasn't intentional but I like it!\n    }\n\n    float t = 0.0;\n    float h = 1.0;\n    for ( int i=0; i < 30; i++ ) // this holds up surprisingly well at low counts\n    {\n        if ( h < .01 )\n            break;\n        float h = DistanceField( camPos+t*ray );\n        t += h;\n    }\n\n    vec3 pos = camPos + t*ray;\n\n    vec2 uv = UVMapping( pos.xy );\n\n    vec3 albedo = Pattern( uv );\n\n    float mask = Mask(uv);\n\n    float weave = Weave(uv);\n    float seam = Seam(uv);\n\n    vec3 normal = Normal( pos );\n\n    const vec3 lightCol = vec3(1.8,1.6,1.3);\n    const vec3 lightDir = normalize(vec3(-3,.7,-.6));\n\n    float nl = dot(normal,lightDir);\n    float l = max( nl, .0 );\n//    float bl = max( mix(-nl,1.,.3), .0 ); // back light - including some scatter to prevent dark line where nl=0\n    vec3 scatteredLight = pow(albedo,vec3(2)) * smoothstep( .7, -1., nl ); // scattered light, favouring back-light\n    vec3 ambient = Ambient( normal ) * .3;\n\n    scatteredLight *= mix( .3, .7, weave );\n    ambient *= mix( 1.7, .3, weave );\n    l *= mix( 1.15, .85, weave );\n    \n    scatteredLight *= mix( .5, 1., seam );\n    \n    vec3 col = albedo;\n    col *= (l + scatteredLight)*lightCol + ambient;\n    \n    // todo: do GGX specular\n    col += lightCol * weave * pow(max(0.,dot(normalize(lightDir-ray),normal)),80.)*.2;\n    \n    // rim light - to make it feel a bit fuzzy\n    col += pow( dot(normal,ray)+1., 4. ) * (ambient+lightCol) * albedo *.5;\n\n    // atmospheric fog\n    col = mix( vec3(1), col, exp2( -t * airColourLog2 / 200. ) );\n\n    //if ( uv.x < .0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n    vec4 flagCol = vec4( col, 1. - mask );\n\n\n    fragColour.rgb = SkyColour(ray);\n    \n    // add flagpole\n    const float poleThickness = .05;\n    vec3 polePos = vec3(-poleThickness,1.1,0) - camPos; // centred on sphere at top of pole\n    \n    float distanceOfPoleAlongRay = dot( ray.xz, polePos.xz )/dot(ray.xz,ray.xz);\n    \n    float poleT = 1.;\n    bool intersection = false;\n    \n    // this is hacky and wrong, but it made the maths simpler and the error won't be obvious unless the camera gets close enough for a lot of perspective distortion\n    // basically I'm drawing a slice through the centre of the pole, rather than a 3D pole, for no reason other than I'm too lazy to look up/figure out the correct maths!\n    float poleOutlineSDF = length( vec2( length(ray.xz*distanceOfPoleAlongRay-polePos.xz), max(0.,ray.y*distanceOfPoleAlongRay-polePos.y) ) )  - poleThickness;\n    float halfFWidthPoleSDF = fwidth(poleOutlineSDF)*.5;\n    if ( poleOutlineSDF < halfFWidthPoleSDF )\n    {\n        poleT = distanceOfPoleAlongRay;\n        intersection = true;\n    \n        vec3 polePos = poleT*ray - polePos;\n    \n        vec3 poleNorm = polePos / poleThickness; // this is a hack\n        poleNorm.y = max(poleNorm.y,0.);\n    \n        poleNorm -= ray*sqrt(1.-min(1.,dot(poleNorm,poleNorm)));\n        poleNorm = normalize(poleNorm);\n    \n        vec3 poleCol = vec3(.6) * ( lightCol*max( dot( poleNorm, lightDir ), .0 ) + Ambient(poleNorm)*.5 );\n    \n        poleCol = mix( vec3(1), poleCol, exp2( -poleT * airColourLog2 / 200. ) );\n\n        fragColour.rgb = mix( poleCol, fragColour.rgb, linstep(-halfFWidthPoleSDF,halfFWidthPoleSDF,poleOutlineSDF) );\n        // todo - fake AA with rim-alpha\n    }\n\n    if ( !intersection || poleT > t )\n    {\n        fragColour.rgb = mix( fragColour.rgb, flagCol.rgb, flagCol.a );\n    }\n\n    // fake flat flagpole - I don't like this, I can replace it with a real one easily enough\n//    col = mix( col, vec3(cos(uv.x*50.0)),smoothstep(0.015,0.01,abs(uv.x+.01))*smoothstep(1.01,1.0,uv.y));\n\n    // tone mapping\n    fragColour.rgb = fragColour.rgb;\n\n    fragColour.rgb = HDRtoLDR( fragColour.rgb );\n\n    fragColour.a = 1.;\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfDf.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[320, 522, 554, 554, 639], [641, 641, 673, 673, 755], [757, 757, 784, 784, 1297], [1300, 1300, 1344, 1344, 1383], [1385, 1678, 1791, 1821, 2288], [2291, 2291, 2316, 2316, 3073], [3076, 3103, 3135, 3135, 3456], [3458, 3458, 3491, 3491, 3534], [3536, 3536, 3561, 3561, 3937], [3939, 3982, 4013, 4071, 5295], [5297, 5297, 5322, 5365, 6200], [6202, 6202, 6225, 6279, 6397], [6400, 6400, 6424, 6424, 6604], [6607, 6607, 6630, 6630, 6760], [6801, 6832, 6860, 6860, 7580], [7583, 7583, 7612, 7612, 7684], [7688, 7688, 7746, 7746, 12122]], "test": "error"}
{"id": "3tGBDt", "name": "Rounded-n-gon inscribed in a cir", "author": "skhiat", "description": "Modified n-gon sdf from @iq to have fixed radius", "tags": ["sdf"], "likes": 2, "viewed": 59, "published": "Public", "date": "1615248033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Distance to a regular n-gon with roundness and inscribed in a circle\n\n// Modified from:\n// https://www.shadertoy.com/view/MtKcWW\n\n#define PI 3.141592653589793238462643f\n\n// radius > 0.0f\n// side >= 3.0f\n// 0.0f < roundness <= 1.0f\nfloat sdNGon( in vec2 p, in float radius, in float side, float roundness_ )\n{\n    float roundness = radius * roundness_;;\n\n    float rCos0 = cos(PI/float(side));\n    float roundValue = rCos0 * roundness;\n\n    float r = radius*rCos0 - roundValue;\n\n    // these 2 lines can be precomputed\n    float an = 6.2831853/float(side);\n    float he = r*tan(0.5*an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an*floor((atan(p.y,p.x)+0.5*an)/an);\n    vec2  cs = vec2(cos(bn),sin(bn));\n    p = mat2(cs.x,-cs.y,cs.y,cs.x)*p;\n\n    // side of polygon\n    return length(p-vec2(r,clamp(p.y,-he,he)))*sign(p.x-r) - roundness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= 2.0;\n\n    float radius = 1.0f + 0.5f*abs(cos(0.25f*iTime));\n    float roundness = clamp(cos(0.5f*iTime), 0.0, 1.0);\n    float sideCount = round(4.0f*abs(cos(2.0*iTime)) + 3.0f);\n\n\tfloat d = sdNGon( p, radius, sideCount, roundness );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(60.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n#if 1\n    // Target radius\n    float a = abs(atan(p.y, p.x));\n    col = mix( col, vec3(1.0, 0.0, 0.0),\n                            abs(length(p) - radius) < 0.025f &&\n                            cos(10.0*a) > 0.0f ?\n                                1.0f :\n                                0.0f );\n#endif\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 234, 311, 311, 895], [897, 897, 954, 954, 1767]], "test": "valid"}
{"id": "3tGBDV", "name": " Underground disposal facility", "author": "butadiene", "description": "okota shader 0306", "tags": ["raymarching"], "likes": 7, "viewed": 229, "published": "Public API", "date": "1615040483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\n#define time iTime\nfloat bpm = 140.;\nfloat PI = acos(-1.);\n\nfloat random (in vec2 st) {return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\nst *= 10.;\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value*0.45;\n}\n\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n  \n  vec2 pmod(vec2 p,float n){\n    float np = 2.0*PI/n;\n    float r = atan(p.x,p.y)-0.5*np;\n    r = mod(r,np)-0.5*np;\n    return length(p)*vec2(cos(r),sin(r));\n    }\n\n    float dist(vec3 p){\n      vec3 sp = p;\n      p.xz = mod(p.xz,2.)-1.;\n       p.y = mod(p.y,10.)-5.;\n      p.xz = pmod(p.xz,4.);\n      float scale = 1.0;\n      for(int i = 0;i<10;i++){\n        p = abs(p)-vec3(0.4,2.0,0.);\n        float r2 = dot(p,p);\n        float sc = 2.0/clamp(r2,0.4,1.0);\n        scale *= sc;\n        p *= sc;\n        p -= vec3(0.35,1.0,0.35);\n        p.xz *= rot(0.25*PI);\n        }\n        float ssx = (1.0+0.1*length(p.xz)*pow(abs(sin(sp.y*5.+2.*time)),6.));\n      \n      \n        float d= length(p)/scale-0.002*ssx;\n      return d;\n      } \n    \n      vec3 gn(vec3 p){\n        vec2 e = vec2(0.001,0.);\n        return normalize(vec3(\n        dist(p+e.xyy)-dist(p-e.xyy),\n        dist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n        ));\n        \n        \n        }\n      \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col =vec3(0);\n vec2 p = uv-0.5;\n    p.x *= iResolution.x/iResolution.y;\n  p.y += 0.1*fbm(vec2(0.0,5.*time));\n    vec3 of = vec3(3.0,0.2*time,0.2);\n  vec3 ta =vec3(0)-of;\n  vec3 ro = vec3(1,0,0)-of;\nfloat t  = 0.;\n  float fov = 0.8;\n  float frag = 0.0;\n  float sty = fract(0.125*0.125*time*bpm/60.);\n  if(sty>0.75){\n    fov = 0.4;\n    of = vec3(0.24,-0.2*time,10);\n    ta = vec3(0)-of;\n    float rsa = 0.15;\n    float ksst = 0.2*time;\n    ro = vec3(rsa*cos(ksst),1.,rsa*sin(ksst))-of;\n    t= 0.1;\n    }else\n    if(sty>0.5){\n              \n    of = vec3(0,-3.,0.3*time);\n    ta = vec3(0)-of;\n    float rsa = 0.1;\n    float ksst = 0.;\n    ro = vec3(rsa*cos(ksst),0.,rsa*sin(ksst))-of;\n      t = 0.;\n      }else if(sty>0.25){\n        fov = 1.5;\n        of = vec3(0,0.1*time,0);\n        ta= vec3(0)-of;\n        ro = vec3(1,0,0)-of;\n        frag = 1.0;\n        }\n\n\n  \n  vec3 cdir = normalize(ta-ro);\n  vec3 side = cross(cdir,vec3(0,1,0));\n  vec3 up = cross(side,cdir);\n  \n  vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n  if(frag == 1.0) rd.yz*= rot(0.5*PI);\n  float d;\n  float ac = 0.;\n  float ep = 0.001;\n  for(int i = 0;i<77;i++){\n    d =dist(ro+rd*t);\n    t += d;\n    ac += exp(-3.0*d);\n    if(d<ep)break;\n  }\n\n  if(d<ep){\n    vec3 ld = normalize(vec3(1));\n   vec3 sp = ro+rd*t;\n    vec3 normal = gn(sp);\n    \n    float sca = 10.;\n    float noiy =fbm(sp.xz*sca);\n    float noiz = fbm(sp.xy*sca);\n    float noibound = smoothstep(0.03,0.05,noiy*noiz);\n    \n    float scb = sca*50.;\n    float noix2 = fbm(sp.yz*scb);\n    float noiy2 = fbm(sp.xz*scb);\n    float noiz2 = fbm(sp.xy*scb);\n    \n      if(noibound<0.9)normal = normalize(normal+vec3(noix2,noiy2,noiz2));\n\n    float alp = 0.5;\n    float NdotL = max(dot(normal,ld),0.);\n    vec3 diff = 0.4*vec3(pow(NdotL*alp+1.-alp,2.0));\n    vec3 df = diff;\n    diff = mix(diff*vec3(0.9,0.4,0.1),diff,noibound);\n    if(noibound<1.)diff = mix(df*vec3(0.9,0.2,0.1),diff,smoothstep(0.03,0.05,noiy2*noiz2));\n    if(noiy*noiz>0.03&&noiy*noiz<0.038) diff *= 0.;\n    vec3 R = reflect(rd,normal);\n    float spec = pow(max(dot(ld,R),0.),5.0);\n    if(noibound<0.9)spec *= 0.;\n    col = diff+0.7*spec;\n    }\n  vec3 fogcol = vec3(0.1);\n    float far = 3.0;\n    col = mix(col,fogcol,clamp(t/far,0.0,1.0));\n  float noifog = fbm(uv*0.5-time*vec2(0.05,0.1));\n  float noifog2 = fbm(uv*0.5-time*vec2(-0.05,0.1));\n    col += (noifog+noifog2)*0.5;\n    col = pow(col,vec3(1.0,1.0,1.3));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBDV.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 175, 202, 202, 268], [270, 270, 296, 296, 640], [660, 660, 684, 684, 924], [927, 927, 945, 945, 994], [1000, 1000, 1026, 1026, 1161], [1167, 1167, 1186, 1186, 1729], [1742, 1742, 1758, 1758, 1972], [1981, 1981, 2038, 2088, 4632]], "test": "valid"}
{"id": "3tGfRK", "name": "Feather Feather everywhere", "author": "YitingLiu", "description": "following a tutorial https://youtu.be/hlM940IqpRU\n", "tags": ["smoothstep", "feather", "artofthecode"], "likes": 3, "viewed": 173, "published": "Public API", "date": "1614635182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep \n#define T (iTime*.05)\n\n\nmat2 Rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat Feather(vec2 p ){\n    float d = length(p-vec2(0,clamp(p.y,-.3,.3)));\n    float r = mix(.1,.01,S(-.3,.3,p.y));// feather shape \n    float m = S(.01,.0,d-r);\n    \n    float side = sign(p.x);\n    //strands \n    float x = .9*abs(p.x)/r;// stretch out the corner \n    float wave = (1.-x)*sqrt(x)+x*(1.-sqrt(1.-x));\n    float y = (p.y-wave*.2)*80.+side*56.;// number of strands\n    float id = floor(y+20.);\n    \n    float n=fract(sin(id*564.2)*5623.2);\n    float shade = mix(.5,1.,n);\n    float strandLength = mix(.3,1.,fract(n*n*355.));\n    \n    // gaps in between strand \n    float strand = S(.4,.0,abs(fract(y)-.5)-.35);\n    strand*=S(.1,-.2,x-strandLength);\n    \n    d = length(p-vec2(0,clamp(p.y,-.45,.1)));\n\n    float stem = S(.002,.0,d+p.y*.025);\n    \n    return max(strand*m*shade,stem); \n\n\n}\n\nvec3 Transform(vec3 p, float angle){\n    p.xz*=Rot(angle);\n    p.xy*=Rot(angle*.5);// rotate along z axis as well \n    return p;\n\n}\n\nvec4 FeatherBall(vec3 ro, vec3 rd, vec3 pos,float angle ){\n\n    vec4 col = vec4(0);\n    float t = dot(pos-ro,rd);\n    \n    vec3 p = ro+rd*t;\n    float y = length(pos-p);\n    \n    if(y<1.){\n        float x = sqrt(1.-y);\n        vec3 pF = ro+rd*(t-x)-pos;//front intersection \n        pF = Transform(pF,angle);\n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);//y axis to be the up and down axis\n        uvF*=vec2(.3,.5);\n        \n        // alpha blending \n        \n        float f = Feather(uvF);\n        vec4 front = vec4(vec3(f),S(.0,.1,f));\n\n        vec3 pB = ro+rd*(t+x)-pos;//back intersection \n        pB = Transform(pB,angle);\n\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);//y axis to be the up and down axis\n        uvB*=vec2(.3,.5);\n        \n        float b = Feather(uvB);\n        vec4 back = vec4(vec3(b),S(.0,.1,b));\n        col=mix(back, front, front.a);// alpha blend - see both back and front \n\n   }\n   \n   return col;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float fft  = texelFetch( iChannel0, ivec2(0.,0.), 0 ).x; \n\n    vec4 col = vec4(0);\n    \n    vec3 ro = vec3(0,0,0.+mix(-3.,-1.5*min(fract(T),fft),sin(T*10.)));\n    vec3 rd = normalize(vec3(uv,1));\n \n    // bg\n    vec3 bg = vec3(.2,.5*fft,.9)*(uv.y+.5);\n    bg+=vec3(.9,fft*.8,.1)*(-uv.y+.5);\n    col = vec4(bg,0);\n    \n    \n    for (float i = 0.; i <=1.; i+=1./70.){\n         \n         float x =mix(-15.,15.,fract(i+T));\n         float y =mix(-6.,6.,fract(sin(i*643.2)*8593.1));\n         float z =mix(8.+min(.5,fft),0.,i);\n         float a = max(fract(i+T),fft)+T+i*5643.1;\n         vec4 feather = FeatherBall(ro,rd,vec3(x,y,z),a);\n         feather.rgb = mix(bg,feather.rgb,mix(.3,1.,i));\n         feather.rgb=sqrt(feather.rgb);\n         col = mix(col, feather, max(feather.a,fft)*feather.a);\n\n    \n    }\n \n     col = pow(col, vec4(.4545));//gamma correction\n   \n    \n    // Output to screen\n    fragColor =col;\n}", "image_inputs": [{"id": "MlXSD8", "previewfilepath": "https://soundcloud.com/raveenaloves/honey-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/raveenaloves/honey-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 64, 64, 127], [129, 129, 152, 152, 929], [931, 931, 967, 967, 1062], [1064, 1064, 1122, 1122, 1998], [1999, 1999, 2056, 2056, 3033]], "test": "error"}
{"id": "3tGfzc", "name": "Fractal 33_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 7, "viewed": 221, "published": "Public API", "date": "1614746450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<120.;\n        e<.002?O+=3.*(cos(vec4(3,8,25,0)+log(s)*.5)+3.)/dot(p,p)/i:O\n    )\n    {\n        p=g*d;\n        p-=vec3(0,-1.7,2);\n        r=normalize(vec3(1,3,0));\n        s=iTime*.2;\n        p=mix(r*dot(p,r),p,cos(s))+sin(s)*cross(p,r);\n        p=abs(p);\n        p.xz=vec2(atan(p.z,p.x),length(p.xz));\n        p.yz=vec2(atan(p.z,p.y),length(p.yz)-2.);\n        s=3.;\n        s*=e=3./min(dot(p,p),50.);\n        p=abs(p)*e;\n        for(int i=0;i++<5;)\n            p=vec3(2,4,2)-abs(p-vec3(3.8,4.6,2.)),\n            s*=e=7./clamp(dot(p,p),.2,5.),\n            p=abs(p)*e;\n        g+=e=min(length(p.xz)-.2,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 778]], "test": "valid"}
{"id": "3tGfzw", "name": "lake house", "author": "saranyacodes", "description": "Make a house on a lake", "tags": ["water", "sky", "animation", "stars", "house", "scenery", "signeddistancefunctions"], "likes": 16, "viewed": 124, "published": "Public", "date": "1615238586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//HOUSE ON THE WATER\n \n//can adjust sky clouds by changing iChannel0 to another noise preset\n//can PAN MOUSE to change viewing angle \n\n//comment out to remove\n#define STARS \n#define CLOUDS \n\n//what type of sky do you want? make sure only ONE is uncommented!\n#define BLUE_SKY\n//#define INDIGO_SKY\n//#define PINK_SKY\n//#define PURPLE_SKY\n//#define GREEN_SKY\n//#define ORANGE_SKY\n//#define RED_SKY\n\n//-------------------------------------------------------\n \n//camera values\nvec3 eye = vec3(0.0, 4.0, -20.0); \n//vec3 eye = vec3(30, 4, -50);\nvec3 ref = vec3(0.0, 0.0, 0.0); \nvec3 up = vec3(0.0, 1.0, 0.0); \nconst float FOVY = 45.0; \n\n//light and colors \nconst vec3 lightPos = vec3(10., 5., -10.);\nconst vec3 lightColor = vec3(1.0, 0.9, 0.75);\n\n//constants\nconst int RAY_STEPS = 600; //increase to get rid of white artifacts\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst float AMBIENCE = 0.2;\n\n//ambient occlusion constants\nconst float AO_DIST = 0.3; //the smaller this is, the less its effective \nconst float FIVETAP_K = 2.0;\n\n// intersection object\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 origp;\n    vec3 p;\n    int object; // every object gets a unique int ID\n};\n\n//transform object \nstruct Transform {\n    vec3 trans;\n    vec3 rot;\n    vec3 scale;\n};\n\n//NOISE FUNCTIONS -----------------------------------\n// generates 1D random numbers for noise functions\nfloat random1(vec2 p) {\n    return fract(sin(dot(p,vec2(341.58, 735.42)))\n                 *40323.3851);\n}\n\n// interpolates 2D noise for fractal brownian\nfloat interpNoise2D(float x, float y) {\n    // interpolates 2D based fract (x, y) between curr and next int (x, y)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    float i1 = mix(random1(vec2(intX, intY)), random1(vec2(intX + 1, intY)), fractX);\n    float i2 = mix(random1(vec2(intX, intY + 1)), random1(vec2(intX + 1, intY + 1)), fractX);\n    return mix(i1, i2, fractY);\n    \n}\n\n// calculates 2D fractal brownian w/ octaves input\nfloat FractalBrownian2D(vec2 p, int octaves, bool animate) {\n    // Animate the point\n    vec2 point;\n    if (animate) {\n        point = p + vec2(iTime * 0.22, iTime * 0.53);\n    } else {\n        point = p;\n    }\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise2D(point.x * freq, point.y * freq) * amp;\n    }\n    return total;\n}\n\n\n// calculates 2D fractal brownian\nfloat FractalBrownian2D(vec2 p, bool animate) {\n    return FractalBrownian2D(p, 4, animate);\n}\n\n// generates 1D random numbers for noise functions\nfloat random1vec3(vec3 p) {\n    return fract(sin(dot(p,vec3(341.58, 735.42, 491.34)))\n                 *40323.3851);\n}\n\n// interpolates 3D noise for fractal brownian\nfloat interpNoise3D(float x, float y, float z) {\n    // interpolates 3D based fract (x, y, z) between curr and next int (x, y, z)\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n    int intZ = int(floor(z));\n    float fractZ = fract(z);\n    float i1 = mix(random1vec3(vec3(intX, intY, intZ)), random1vec3(vec3(intX + 1, intY, intZ)), fractX);\n    float i2 = mix(random1vec3(vec3(intX, intY + 1, intZ)), random1vec3(vec3(intX + 1, intY + 1, intZ)), fractX);\n    float i3 = mix(random1vec3(vec3(intX, intY, intZ + 1)), random1vec3(vec3(intX + 1, intY, intZ + 1)), fractX);\n    float i4 = mix(random1vec3(vec3(intX, intY + 1, intZ + 1)), random1vec3(vec3(intX + 1, intY + 1, intZ + 1)), fractX);\n    float j1 = mix(i1, i2, fractY);\n    float j2 = mix(i3, i4, fractY);\n    return mix(j1, j2, fractZ);\n    \n}\n\n// calculates 3D fractal brownian w/ octaves input\nfloat FractalBrownian3D(vec3 point, int octaves, bool animate) {\n    float total = 0.;\n    float persistence = 0.5;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2., float(i));\n        float amp = pow(persistence, float(i));\n        // amplitude decreases as i increases, frequency increases\n        total += interpNoise3D(point.x * freq, point.y * freq, point.z * freq) * amp;\n    }\n    return total;\n}\n\n//---------------------------------------------------\n//functions for shape transformations\n//inputs for rotations are in DEGREES \n//rotate along the X axis \nvec3 rotateX(vec3 p, float a) {\n    a = (PI / 180.0) * a;\n    return vec3(p.x, cos(a) * p.y + -sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\n//rotate along the Y axis\nvec3 rotateY(vec3 p, float a) {\n    a = (PI / 180.0) * a;\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n//rotate along the Z axis\nvec3 rotateZ(vec3 p, float a) {\n    a = (PI / 180.0) * a;\n    return vec3(cos(a) * p.x + -sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n//transforms a point by its inverse\nvec3 transformPoint(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 newPoint = (p - trans);\n    newPoint = rotateX(rotateY(rotateZ(newPoint, -rot.z), -rot.y), -rot.x);\n    return newPoint / scale;\n}\n\n\n//SDFs (all SDFs are taken from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n//box SDFs\nfloat boxSDF( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boxSDF(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    vec3 q = abs(p_transformed) - 0.5;\n    float sdf = length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.);\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n// sphere sdf\nfloat sphereSDF(vec3 p, vec3 trans, vec3 rot, vec3 scale) {\n    vec3 p_transformed = transformPoint(p, trans, rot, scale);\n    float sdf = distance(p_transformed, vec3(0, 0, 0)) - 0.5;\n    return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n//triangular prism\n\nfloat triPrismSDF( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat triPrismSDF( vec3 p, vec3 trans, vec3 rot, vec3 scale )\n{\n  vec3 p_transformed = transformPoint(p, trans, rot, scale);\n  vec2 h = vec2(0.5); \n  vec3 q = abs(p_transformed);\n  float sdf = max(q.z-h.y,max(q.x*0.866025+p_transformed.y*0.5,-p_transformed.y)-h.x*0.5);\n  return sdf * min(scale.x, min(scale.y, scale.z));\n}\n\n\nfloat sphereSDF( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//SDF operations\n\nfloat unionOp( float d1, float d2 ) { return min(d1,d2); }\n\nfloat subtractionOp( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat intersectionOp( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smoothUnionOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubOp( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n//---------------------------------------------------\n//define SDFs\n\n#define WATER_SDF boxSDF(pos, transform.trans, transform.rot, transform.scale)\n\n//multiply by -1 because we are using this as a SKYDOME\n#define SKY_SDF -1. * sphereSDF(pos, transform.trans, transform.rot, transform.scale)\n\n//define colors\n#define SKY_ID -1\n#define SPECULAR_ID 0 \n#define HOUSE_ID 1\n#define OUTLINE_ID 2\n#define WOOD_ID 3\n#define ROOF_ID 4\n#define FENCE_ID 5\n\n//use this function to build the sdf for the house \nvoid houseSDF(vec3 pos, out float house, out float outline, out float wood, out float roof) {\n    //float house; \n    //the position that will be transformed\n    vec3 translate = vec3(0.0); \n    vec3 stored = translate; //use for storing previous translations \n    \n    //transform = translate, rotate, scale \n    Transform transform = Transform(translate, vec3(0), vec3(1));\n    \n    //base of the house \n    translate += vec3(0, 1, 10);\n    vec3 base = translate; //store the base translation \n    float houseBase = boxSDF(pos, translate, vec3(0), vec3(9, 5, 10));\n    \n    //house cap \n    translate += vec3(0, 3.4, 0); \n    float houseCap = triPrismSDF(pos, translate, vec3(0), vec3(10.5, 4, 10));\n    \n    house = unionOp(houseBase, houseCap); \n    \n    //subtract two doors \n    translate += vec3(2, -5, 0);\n    stored = translate; \n    float subLeft = boxSDF(pos, translate, vec3(0), vec3(2, 3, 12)); //left door \n    house = subtractionOp(subLeft, house); \n    \n    translate.x += translate.x * -2.;  \n    float subRight = boxSDF(pos, translate, vec3(0), vec3(2, 3, 12)); //right door \n    house = subtractionOp(subRight, house); \n    \n    translate += vec3(0, .5, -5); \n    float rightDoorOutline = boxSDF(pos, translate, vec3(0), vec3(2., 3, 0.5)); //right door outline \n    float rightDoorSub = boxSDF(pos, translate, vec3(0), vec3(1.0, 2.0, 1)); \n    outline = subtractionOp(rightDoorSub, rightDoorOutline); \n    //outline = rightDoorSub; \n    \n    translate = stored; //reset to left door \n    translate += vec3(0, .5, -5); \n    float leftDoorOutline = boxSDF(pos, translate, vec3(0), vec3(2., 3, 0.5)); //left door outline \n    float leftDoorSub = boxSDF(pos, translate, vec3(0), vec3(1.0, 2.0, 1)); \n    outline = unionOp(outline, subtractionOp(leftDoorSub, leftDoorOutline));\n    \n    //make patio \n    translate += vec3(-2, -1.5, 0); \n    float patio = boxSDF(pos, translate, vec3(0), vec3(9., 0.5, 2)); \n    house = unionOp(house, patio); \n    \n    //make empty window outline\n    translate += vec3(0, 5, 0); \n    float windowOutline = boxSDF(pos, translate, vec3(0), vec3(1.3, 1.5, 0.5)); \n    float windowSub = boxSDF(pos, translate, vec3(0), vec3(1.3 * 0.5, 1.5 * 0.5, 1));\n    outline = unionOp(outline, subtractionOp(windowSub, windowOutline)); \n    \n    //make rest of house outline\n    translate.xy = base.xy; //reset to base\n    translate.x += 4.25; \n    float leftOutline = boxSDF(pos, translate, vec3(0), vec3(0.3, 5, 0.3)); //left outline\n    outline = unionOp(outline, leftOutline); \n    \n    translate.xy = base.xy; //reset to base\n    translate.x -= 4.25; \n    float rightOutline = boxSDF(pos, translate, vec3(0), vec3(0.3, 5, 0.3)); //right outline\n    outline = unionOp(outline, rightOutline); \n    \n    translate.xy = base.xy; //reset to base\n    \n    //diagonal outlines of roof \n    translate += vec3(-2.2, 4.0, 0); \n    float rightDiagOutline = boxSDF(pos, translate, vec3(0, 0, -56), vec3(0.3, 5.2, 0.3)); //right diagonal outline\n    outline = unionOp(outline, rightDiagOutline); \n    \n    translate.xy = base.xy; //reset to base\n    translate += vec3(2.2, 4.0, 0); \n    float leftDiagOutline = boxSDF(pos, translate, vec3(0, 0, 360 + 56), vec3(0.3, 5.2, 0.3)); //left diagonal outline\n    outline = unionOp(outline, leftDiagOutline);\n    \n    //make wooden planks along bottom of house (this will be another material)\n    translate = base; //reset to base\n    translate += vec3(0, -3, -0.5); \n    float woodPlankMiddle = boxSDF(pos, translate, vec3(0), vec3(1, 1, 11)); //middle plank \n    \n    translate.y += -0.8; \n    translate.z += -3.5; \n    float wpm1 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //middle plank: first standing block \n    wood = unionOp(woodPlankMiddle, wpm1); \n    \n    translate.z += 3.5; \n    float wpm2 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //middle plank: second standing block \n    wood = unionOp(wood, wpm2); \n    \n    translate.z += 3.5; \n    float wpm3 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //middle plank: third standing block \n    wood = unionOp(wood, wpm3); \n    \n    translate = base; //reset to base\n    translate += vec3(0, -3, -0.5); \n    translate.x += 3.8; //moving plank to the LEFT \n    float woodPlankLeft = boxSDF(pos, translate, vec3(0), vec3(1, 1, 11)); //left plank \n    wood = unionOp(wood, woodPlankLeft); \n    \n    translate.y += -0.8; \n    translate.z += -3.5; \n    float wpl1 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //left plank: first standing block \n    wood = unionOp(wood, wpl1); \n    \n    translate.z += 3.5; \n    float wpl2 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //left plank: second standing block \n    wood = unionOp(wood, wpl2); \n    \n    translate.z += 3.5; \n    float wpl3 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //left plank: third standing block \n    wood = unionOp(wood, wpl3); \n    \n    translate = base; //reset to base\n    translate += vec3(0, -3, -0.5); \n    translate.x -= 3.8; //moving plank to the RIGHT \n    float woodPlankRight = boxSDF(pos, translate, vec3(0), vec3(1, 1, 11)); //right plank \n    wood = unionOp(wood, woodPlankRight); \n    \n    translate.y += -0.8; \n    translate.z += -3.5; \n    float wpr1 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //right plank: first standing block \n    wood = unionOp(wood, wpr1); \n    \n    translate.z += 3.5; \n    float wpr2 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //right plank: second standing block \n    wood = unionOp(wood, wpr2); \n    \n    translate.z += 3.5; \n    float wpr3 = boxSDF(pos, translate, vec3(0), vec3(1, 1, 1)); //right plank: third standing block \n    wood = unionOp(wood, wpr3); \n    \n    //make roof \n    translate.xy = base.xy; //reset to base\n    translate += vec3(-3, 3.8, -3); \n    float rightRoof = boxSDF(pos, translate, vec3(0, 0, -56), vec3(0.3, 6.8, 10)); //right roof \n    roof = rightRoof; \n    \n    translate.xy = base.xy; //reset to base\n    translate += vec3(3, 3.8, 0); \n    float leftRoof = boxSDF(pos, translate, vec3(0, 0, 360 + 56), vec3(0.3, 6.8, 10)); //left roof \n    roof = unionOp(roof, leftRoof); \n\n}\n\n//sceneMap3D function which actually creates the scene \nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n\n    //the position that will be transformed\n    vec3 translate = vec3(0.0); \n    \n    float house;\n    float outline;\n    float wood;\n    float roof; \n    houseSDF(pos, house, outline, wood, roof); \n    \n    //house \n    Transform transform = Transform(translate, vec3(0), vec3(2));\n    //t = HOUSE;\n    t = house; \n    obj = HOUSE_ID;\n    \n    //float for distance comparison \n    float t2; \n    \n    \n    //test for outline\n    if((t2 = outline) < t) {\n        t = t2;\n        obj = OUTLINE_ID;\n    }\n    \n    //test for wood\n    if((t2 = wood) < t) {\n        t = t2;\n        obj = WOOD_ID;\n    }\n    \n    //test for roof\n    if((t2 = roof) < t) {\n        t = t2;\n        obj = ROOF_ID;\n    }\n    \n    \n    //water and sky below -------------\n    \n    //water\n    transform = Transform(vec3(0, -3, 0), vec3(0, 0, 0), vec3(1000, 0.3, 1000));\n    if((t2 = WATER_SDF) < t) {\n        t = t2;\n        obj = SPECULAR_ID;\n    }\n    \n    // sky (a sphere surrounding the scene) \n    transform = Transform(vec3(0, 0, 0), vec3(0, 0, 0), vec3(170));\n    if((t2 = SKY_SDF) < t) {\n        t = t2;\n        obj = SKY_ID;\n    }\n    \n   \n}\n\n\n//sceneMap3D function which takes in a position and returns the distance hit at\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\n\n//raymarching function returns the distance hit at (t) and the hitobject id (hitObject) \nvoid march(vec3 origin, vec3 dir, out float t, out int hitObject) {\n    t = 0.01;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObject);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObject = -1;\n}\n\n//raycasting function returns the rayDirection based on the uv \nvec3 rayCast(vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, up));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY / 2.0);\n    vec3 H = R * length(F) * tan(FOVY / 2.0) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n//ambient occlusion function referenced from https://www.shadertoy.com/view/3sB3zV\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n//sky colors\n//referenced from here https://www.shadertoy.com/view/MlSSR1\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0, -100. ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0, -100. ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0, -100. ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0, -100. ).x;\n    return f/0.9375;\n}\n\nvec3 skyCol(vec3 ro, vec3 rd, vec3 light) {\n    vec3 col = vec3(0.0); \n    \n    // sky colour        \n    //blue skies\n    vec3 blueSky = vec3(0.3,.55,0.8);\n    vec3 redSky = vec3(0.8,0.8,0.6);\n    \n#ifdef BLUE_SKY\n    //blue skies\n    blueSky = vec3(0.3,.55,0.8);\n     redSky = vec3(0.8,0.8,0.6);\n#endif \n    \n#ifdef INDIGO_SKY\n    //indigo skies \n    blueSky = vec3(76, 76, 204) / 255.; \n    redSky = vec3(0.8,0.8,0.6); \n#endif \n\n#ifdef PINK_SKY    \n    //pink skies \n    blueSky = vec3(204, 76, 140) / 255.; \n    redSky = vec3(76, 76, 204) / 255.; \n#endif\n    \n#ifdef PURPLE_SKY\n    //purple skies \n    blueSky = vec3(140, 76, 204) / 255.; \n    redSky = vec3(0.8,0.8,0.6); \n#endif\n    \n#ifdef GREEN_SKY\n    //green skies \n    blueSky = vec3(28, 126, 15) / 255.; \n    redSky = vec3(105, 204, 76) / 255.; \n#endif\n    \n#ifdef ORANGE_SKY\n    //orange \n    blueSky = vec3(244, 146, 60) / 255.; \n    redSky = vec3(0.8,0.8,0.6);\n#endif \n\n#ifdef RED_SKY\n    blueSky = vec3(222, 78, 71) / 255.; \n    redSky = vec3(0.8,0.8,0.6);\n#endif\n\n    \n    float sundot = clamp(dot(rd,light),0.0,1.0);\n    vec3 sky = mix(blueSky, redSky, 1.5*pow(sundot, 8.));\n\n    col =  sky*(1.0-0.8*rd.y);\n\n#ifdef STARS\n    // stars\n    \n    float s = texture( iChannel0, rd.xz * 1.25, -100. ).x;\n    s += texture( iChannel0, rd.xz* 4., -100. ).x;\n\n    s = pow(s, 17.0) * 0.00005 * max(rd.y, -0.2) * pow((1. - max(sundot, 0.)), 2.); \n    if (s > .0)\n    {\n        vec3 backStars = vec3(s);\n        col += backStars;\n    }\n#endif\n    \n\n    // sun\n    col += 0.1*vec3(0.9, 0.3, 0.9)*pow(sundot, 0.5);\n    col += 0.2*vec3(1., 0.7, 0.7)*pow(sundot, 1.);\n    col += 0.95*vec3(1.)*pow(sundot, 256.);\n\n#ifdef CLOUDS\n    // clouds\n    float cloudSpeed = 0.01;\n    float cloudFlux = 0.5;\n\n    // layer 1\n    vec3 cloudColour = mix(vec3(1.0,0.95,1.0), 0.35*redSky,pow(sundot, 2.));\n\n    vec2 sc = cloudSpeed * 50.*iTime * ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n    col = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n\n    // cloud layer 2\n    sc = cloudSpeed * 30.*iTime * ro.xz + rd.xz*(500.0-ro.y)/rd.y;\n    col = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0002*sc+fbm(0.0005*sc+iTime*cloudFlux))));\n#endif\n\n    // horizon        \n    col = mix( col, 0.9*vec3(0.9,0.75,0.8), pow( 1.-max(rd.y+0.1,0.0), 8.0));\n        \n    // contrast\n    col = clamp(col, 0., 1.);\n    col = col*col*(3.0-2.0*col);\n    \n    \n    // saturation (amplify colour, subtract grayscale)\n    float sat = 0.2;\n    col = col * (1. + sat) - sat*dot(col, vec3(0.33));\n    \n    return col; \n\n\n\n}\n\n//--------------------------------------\n//testing color palettes\n//referenced from https://iquilezles.org/www/articles/palettes/palettes.htm\nconst vec3 a = vec3(100, 23, 250) / 255.;\n//const vec3 a = vec3(48, 7, 93) / 255.;\nconst vec3 b = vec3(0.5, 0.3, 0.);\nconst vec3 c = vec3(0.25, 0.5, 0.0);\nconst vec3 d = vec3(0., 0., 0.);\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//-------------------\n\n//DEFINE COLORS HERE --------\n//water and colors inspired by https://www.shadertoy.com/view/wdXfRH\n//test lambert colors \n#define LAMBERT_RED lightColor * vec3(1.0, 0.0, 0.0) * lambert\n#define LAMBERT_GREEN lightColor *  vec3(0.0, 1.0, 0.0) * lambert\n#define LAMBERT_BLUE lightColor * vec3(0.0, 0.0, 1.0) * lambert\n#define LAMBERT_YELLOW lightColor * vec3(1.0, 1.0, 0.0) * lambert\n\n#define HOUSE_PURPLE lightColor * palette(0.8 - smoothstep(0.15, 0.9, FractalBrownian3D(p/1.5, 4, false)), a, b, c, d)  * lambert \n#define ROOF_COLOR lightColor * vec3(255, 234, 197) / 255. * lambert\n#define WOOD_COLOR lightColor * vec3(172, 114, 14) / 255. * lambert\n\n#define SKY skyCol(p, -view, lightVec) \n//#define SKY vec3(0.85,0.82,0.85) + smoothstep(-0.1, -0.3, view.y)*vec3(-.2, -.07, -.05)\n//#define SKY palette(iTime * 0.1, a, b, c, d) //how would I improve this? \n//#define SKY vec3(0.8,0.5,0.2) + smoothstep(-0.2, -0.3, view.y)*vec3(-0, -.4, 0.5)\n//#define SKY vec3(0.0, 1.0, 0.0) \n//computes the shading \nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    //calculate lambert shading\n    float lambert = clamp(dot(lightVec, n) + AMBIENCE, 0., 1.);\n    vec3 h = normalize((view + lightVec) / 2.);\n    float hdotn = dot(h, n);\n    float specular = 0.;\n    if (hdotn > 0.) {\n        specular = clamp(max(pow(dot(h, n), 15.), 0.), 0., 1.);\n    }\n    \n    switch (hitObj) {\n        case HOUSE_ID:\n        vec3 c = (1. - HOUSE_PURPLE) * 0.4 + HOUSE_PURPLE; //creates lighter tint \n        return c; \n        //return HOUSE_PURPLE;\n        break;\n        case OUTLINE_ID:\n        return ROOF_COLOR;\n        break;\n        case WOOD_ID:\n        return WOOD_COLOR;\n        case ROOF_ID:\n        return ROOF_COLOR; \n        break;\n        case SKY_ID:\n        return SKY; \n        break;\n    \n    }\n    \n    \n    return SKY; \n\n}\n\n// water reflection logic\n// mat2 for waterMap\nconst mat2 m = mat2( 0.60, -0.80, 0.80, 0.60 );\n\n// modified from https://www.shadertoy.com/view/MsB3WR\n// maps water based on x and z of plane\nfloat waterMap( vec2 pos ) {\n    float radius = length(pos - eye.xz);\n\tvec2 posm = pos * m;\n    if (radius > 10. && radius < 50.) {\n        return (1. - smoothstep(30., 50., radius)) * (smoothstep(10., 30., radius)) \n            * abs( FractalBrownian2D(vec2(posm), true) - 0.8 )* 0.05;\n    } else {\n        return 0.;\n    }\n}\n\n\n//function which computes normals based on the sceneMap \nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, EPSILON, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n//sdf3D marches the ray and gets the t and obj hit and computes the isect and gets the material color\nIntersection sdf3D(vec3 dir) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    vec3 origIsect = eye + t * dir; // get the point of intersection on the ray\n    vec3 isect = origIsect; // store this, will need it for specular calculation \n    vec3 nor = computeNormal(isect);\n    vec3 surfaceColor = vec3(1.);\n    \n    \n    //specular logic here\n     while (hitObj == SPECULAR_ID) {\n        // compute normal of waterMap sdf\n        vec2 pos = isect.xz; \n        vec2 epsilon = vec2( EPSILON, 0. );\n        nor = vec3( 0., 1., 0. );\n\t\tnor.x = (waterMap(pos + epsilon.xy) - waterMap(pos - epsilon.xy) ) / (2. * EPSILON);\n\t\tnor.z = (waterMap(pos + epsilon.yx) - waterMap(pos - epsilon.yx) ) / (2. * EPSILON);\n\t\tnor = normalize( nor );\t\n        vec3 rayDir = reflect(dir, normalize(nor));\n        march(isect, rayDir, t, hitObj);\n        // re-compute intersection pt & normal\n        isect = isect + t * rayDir;\n    \tnor = computeNormal(isect);\n        // alter surfaceColor by reflection color\n        surfaceColor *= vec3(0.95, 0.9, 0.85);\n    } \n    \n    vec3 lightDir = normalize(lightPos - isect);\n    //hardcode lightDir\n    lightDir = normalize(vec3(0, -1, -1)); \n    \n    surfaceColor *= computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    // ambient occlusion\n    if (length(isect - vec3(0.)) < 65.) {\n        surfaceColor *= fiveTapAO(isect, nor, FIVETAP_K);\n    }\n    // output origIsect for blur and new isect for fog\n    return Intersection(t, surfaceColor, origIsect, isect, hitObj);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     eye = rotateY(eye, (iMouse.x + 200. - iResolution.x / 2.) / 5.);\n     \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    vec3 rayDir = rayCast(uv); \n\n    // setting the col to the test formula \n    vec3 col = 0.5 * (rayDir + vec3(1.0)); \n    \n    //use the ray direction to get the intersection \n    Intersection isect = sdf3D(rayDir); \n    \n    col = isect.color; \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1387, 1492, 1515, 1515, 1598], [1600, 1646, 1685, 1760, 2097], [2099, 2150, 2210, 2235, 2705], [2708, 2742, 2789, 2789, 2836], [2838, 2889, 2916, 2916, 3007], [3009, 3055, 3103, 3184, 3928], [3930, 3981, 4045, 4045, 4404], [4406, 4564, 4595, 4595, 4704], [4706, 4732, 4763, 4763, 4872], [4874, 4900, 4931, 4931, 5040], [5042, 5078, 5141, 5141, 5281], [5284, 5400, 5432, 5432, 5519], [5521, 5521, 5577, 5577, 5807], [5809, 5823, 5882, 5882, 6063], [6065, 6085, 6122, 6122, 6205], [6207, 6207, 6270, 6270, 6530], [6533, 6533, 6569, 6569, 6593], [6595, 6613, 6650, 6650, 6671], [6673, 6673, 6716, 6716, 6738], [6740, 6740, 6784, 6784, 6805], [6807, 6807, 6860, 6860, 6960], [6962, 6962, 7012, 7012, 7113], [7560, 7612, 7705, 7769, 13695], [13697, 13753, 13806, 13851, 14932], [14935, 15015, 15043, 15043, 15114], [15117, 15206, 15273, 15273, 15529], [15531, 15595, 15619, 15619, 15939], [15941, 16024, 16066, 16066, 16278], [16280, 16396, 16417, 16417, 16728], [16730, 16730, 16773, 16773, 19307], [19493, 19639, 19711, 19711, 19754], [20470, 20779, 20855, 20887, 21622], [21720, 21815, 21843, 21843, 22141], [22144, 22201, 22231, 22231, 22552], [22554, 22656, 22686, 22686, 24197], [24199, 24199, 24256, 24256, 24801]], "test": "error"}
{"id": "3tKBWy", "name": "Fork Halftone W mix  fractal 2", "author": "mrarm84", "description": "I just bought a webcam so I made a simple halftone filter! Mouse controls brightness.", "tags": ["halftone", "webcam"], "likes": 1, "viewed": 198, "published": "Public", "date": "1614976042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// comment these out for different effects\n#define monochrome 1\n//#define nearestDot 1\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nconst float numberOfDots = 377.; // horizontally across screen\n\nvec3 PixelGrid ( vec2 p )\n{\n    float dotSize = iResolution.x/numberOfDots;\n    vec2 tileSize = vec2(.5,sqrt(3./4.)) * dotSize;\n    p /= tileSize;\n    p = fract(p/2.)*2.-1.;\n    vec2 s = sign(p);\n    p = abs(p);\n    p *= tileSize;\n\n    // this is not the best way to do this, but I am lazy (could just mirror it)\n    if ( length(p) > length(p-tileSize) )\n        p = p-tileSize;\n    \n    float value = dot(p,p)*4./dot(tileSize,tileSize); // based on area\n    \n    return vec3( p*s, clamp(1.-value,0.,1.) );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\n  \n   // create pixel coordinates\n // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel1, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel1, ivec2(tx,1), 0 ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( fft, 14.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    // add wave form on top\t\n\tcol += 1.0 -  step( 0.0,  abs(fft - uv.y) );\n\t\n\t// output final color\n\t//fragColor = vec4(col,1.0);\n\n\n        vec3 grid = PixelGrid(fragCoord);\n\n\n    #ifdef nearestDot\n        fragCoord.xy -= grid.xy;\n    #endif\n\n    fragColour = texture(iChannel0,fragCoord.xy/iResolution.xy);\n\n\n  //  fragColour=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((fragCoord-.5*r.xy)/r.y,1));  \n    for(float i=1.,g=0.,e,s,a;\n        ++i<99.;\n        a=cos(i*i/80.),fragColour.rgb+=mix(vec3(1),H(log(s)/5.),.5)*a*a/e/2e4\n    )\n    {\n        p=g*d-vec3(-.8,.2,2);\n        p=R(p,normalize(vec3(10,1,1)),iTime*.1);\n    s=3.;\n    for(int i=0;i++<5;p=abs(p)*e)\n        p=vec3(8,4,2)-abs(p-vec3(fft,4,2)),\n        s*=e=8./clamp(dot(p,p),.1,7.);\n        g+=e=min(length(p.xz),p.y)/s+.001;\n    }\n      \n    fragColour.rgb = pow( fragColour.rgb, vec3(2.2) ); // gamma->linear\n\n    #ifdef monochrome\n        fragColour.rgb = vec3( dot( fragColour.rgb, vec3(.2,.7,.1) ) );\n    #endif\n    \n    float brightness = fft;\n    if ( iMouse.y > 0. ) brightness = iMouse.y/iResolution.y;\n    if ( iMouse.y > 0. ) vec3 grid = PixelGrid(fragCoord);\n\n    fragColour.rgb = (fragColour.rgb-.0)*(1.+20.*brightness*col*10.0);\n\n    // aliased version\n//    float spots = step( .0, monochrome - grid.z );\n    \n    // anti-aliased version\n    vec3 f = fragColour.rgb-grid.z;\n    vec3 spots = smoothstep( -f, 2.-f, f/max(fwidth(fft),.01) );\n\n    fragColour.rgb = spots;\n\n    //if ( fragCoord.x < iMouse.x ) fragColour.rgb = vec3(monochrome);  // test the gamma and dot area maths is correct\n\n    fragColour.rgb = pow( fragColour.rgb, vec3(fft*10.2) ); // linear->gamma\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 258, 285, 285, 766], [768, 768, 826, 891, 3023]], "test": "error"}
{"id": "3tKBz3", "name": "Wave Photo Render in Progress", "author": "vamoss", "description": "Render image with different wave strokes width.\n\nThis application uses PCD Brasil 2021 Identity, available at: https://pcd.encontrosdigitais.com.br", "tags": ["wave", "line", "sine", "photo", "tracer", "render"], "likes": 1, "viewed": 71, "published": "Public", "date": "1614771613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 bgColor = vec3(1.0);\nvec3 color1 = vec3(1.0, 0.4, 0.42);\nvec3 color2 = vec3(0.0, 0.29, 0.63);\n\nfloat wave(vec2 uv, float amp, float freq, float stroke, float threshold){\n    float waveY = mod(uv.y, amp);\n    waveY += (amp * sin(uv.x * freq + iTime ))/3.0 - amp/2.0;\n\tfloat wave = abs(1.0 / (80.0 * waveY)) * stroke;\n    return smoothstep(threshold, 1.0, wave);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 photo = texture(iChannel0, uv).rgb;\n\tfloat photoGrey = 0.21 * photo.r + 0.71 * photo.g + 0.07 * photo.b;\n    \n\tuv  = -1.0 + 2.0 * uv;\n    \n    vec3 finalColor = bgColor;\n    \n    float amp = 0.2;\n    float strokeWidth = 0.15;\n    float frequency = 8.0;\n    float threshold = 0.1;\n    const float repeat1 = 4.0;\n    for(float i = 0.0; i < repeat1; i++){\n        vec2 stepUv = uv + vec2(0., amp/repeat1*i);\n        float w = wave(stepUv, amp, frequency, strokeWidth, threshold);\n        finalColor = mix(finalColor, color1, w);\n    }\n    \n    amp = 0.12;\n    strokeWidth = 1.0-photoGrey;\n    frequency = 4.2;\n    threshold = 0.75;\n    const float repeat2 = 3.0;\n    for(float i = 0.0; i < repeat2; i++){\n        vec2 stepUv = uv + vec2(0., amp/repeat2*i);\n        float w = wave(stepUv, amp, frequency, strokeWidth, threshold);\n        finalColor = mix(finalColor, color2, w);\n    }\n    \n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 174, 174, 367], [369, 369, 425, 425, 1400]], "test": "error"}
{"id": "3tKfDG", "name": "PBR Materials", "author": "MatthieuJacquemet", "description": "Simple test scene for different kind of pbr materials", "tags": ["sdf", "texture", "pbr", "meterial"], "likes": 27, "viewed": 253, "published": "Public", "date": "1614972902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Jacquemet Matthieu\n\n// Contants --------------------------------------------------------------------------------------------\nconst float PI   = 3.141592653589793238462643383279502884197169;\nconst float PI_2 = 1.570796326794896619231321691639751442098585;\n\n\nconst int MAX_STEPS = 200;      // Number of steps\nconst float EPSILON = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct TraceData {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float clearcoat;\n    float metallic;\n};\n\n\n#define TONEMAP_LINEAR 0 \n#define TONEMAP_FILMIC 1\n#define TONEMAP_REINHARD 2\n#define TONEMAP_FILMIC_REINHARD 3\n#define TONEMAP_UNCHARTED2 4\n#define TONEMAP_ACES 5\n\n#define MATERIAL_FLOOR_TILES 0\n#define MATERIAL_CAR_COAT 1\n#define MATERIAL_BURNED_WOOD 2\n#define MATERIAL_SOIL 3\n#define MATERIAL_MARBLE 4\n#define MATERIAL_GRANITE 5\n#define MATERIAL_LAVA  6\n#define MATERIAL_RUSTED_METAL 7\n#define MATERIAL_BRICKS 8\n#define MATERIAL_ASPHALT 9\n#define MATERIAL_GOLD 10\n#define MATERIAL_RUSTY_PAINT 11\n#define MATERIAL_CARBON_FIBER 12\n\n#define SPECULAR_GGX 0\n#define SPECULAR_BLINN 1\n#define SPECULAR_BECKMANN 2\n\n#define SPECULAR_MODE SPECULAR_GGX\n#define TONEMAP_MODE TONEMAP_ACES // Tone mapping mode\n#define _DEBUG 0               // set 1 to enable debuging\n\n\n\n#if _DEBUG\n    vec3 _debug_color;\n    bool _is_debug = false;\n    #define DEBUG(color) if (_is_debug) _debug_color = color; // use this to debug a color\n    #define CATCH_DEBUG(expr) _is_debug = true; expr ; _is_debug = false;\n#else\n    #define DEBUG(color)\n    #define CATCH_DEBUG(expr) expr // any call to DEBUG(color) in this macro will output de color\n#endif\n// Primitive functions -----------------------------------------------------------------------------------\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat Hash3(vec3 p)\n{\n    return fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453);\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u)* vec2(cos(a), sin(a)), u) );\n}\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// based on https://www.shadertoy.com/view/llG3zy\nvec3 VoronoiE( in vec3 x )\n{\n    vec3 n = floor(x);\n    vec3 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec3 mr;\n\n    float md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n        vec3 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n\t\tvec3 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n// Tranforms --------------------------------------------------------------------\n\n// Map value from [Imin, Imax] to [Omin, Omax]\nfloat map(float value, float Imin, float Imax, float Omin, float Omax) \n{  \n  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);\n}\n\n// Translate point p\nvec3 Translate(vec3 pos, vec3 p) {\n\n    return p - pos;\n}\n\n// Scale point p\nvec3 Scale(vec3 scale, vec3 p) {\n\n    return vec3(p.x/scale.x, p.y/scale.y, p.z/scale.z);\n}\n\n// Rotate point p around X axis (radians)\nvec3 RotateX(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Y axis (radians)\nvec3 RotateY(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3( _cos,    0,  -_sin,\n                    0,      1,      0,\n                   _sin,    0,   _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Z axis (radians)\nvec3 RotateZ(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  _cos,  -_sin,   0,\n                    _sin,   _cos,   0,\n                    0,      0,      1);\n\n    return M*p;\n}\n\n// Rotate point p\nvec3 Rotate(vec3 rot, vec3 p)\n{\n    p = RotateX(rot.x, p);\n    p = RotateY(rot.y, p);\n    p = RotateZ(rot.z, p);\n\n    return p;\n}\n\n\n// Create scaling matrix\nmat3 Scaling(vec3 scale) {\n\n    return mat3(1.0/scale.x,0,          0,\n                0,          1.0/scale.y,0,\n                0,          0,          1.0/scale.z);\n}\n\n// Create rotation matrix for theta angle around X axis (radians)\nmat3 RotationX(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(    1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n}\n\n// Create rotation matrix for theta angle around Y axis (radians)\nmat3 RotationY(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3( _cos,     0, -_sin,\n                    0,     1,     0,\n                 _sin,     0,  _cos);\n}\n\n// Create rotation matrix for theta angle around Z axis (radians)\nmat3 RotationZ(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(_cos, -_sin,  0,\n                _sin,  _cos,  0,\n                0,     0,     1);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(float x, float y, float z) \n{\n    return RotationZ(z) * RotationY(y) * RotationX(x);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(vec3 rot)\n{\n    return Rotation(rot.x, rot.y, rot.y);\n}\n\n// Create translation matrix\nmat4 Translation(vec3 trans) {\n\n    mat4 M = mat4(1.0);\n    M[3] = vec4(-trans, 1.0);\n\n    return M;\n}\n\n// Create transform matrix \nmat4 Transform(vec3 scale, vec3 rot, vec3 trans) \n{\n    return mat4(Scaling(scale) * Rotation(rot)) * Translation(trans);\n}\n\n// Transform of point p\nvec3 Transform(vec3 scale, vec3 rot, vec3 trans, vec3 p)\n{\n    p = Scale(scale, p);\n    p = Rotate(rot, p);\n    p = Translate(trans, p);\n\n    return p;\n}\n\n// Camera -----------------------------------------------------------------------\n\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n        // focal length\n   \tfloat le = 2.0;\n    \n    // position camera\n    ro=vec3(-40.0,0.0,0.0);\n    \n    // reset camera position\n    // shadertoy initialize mouse pos at (0,0)\n    if (m == vec2(0))\n        m = vec2(0.9, 0.51);\n    \n    m = (m*2.0 - vec2(1.0))*3.0;\n    m.y = clamp(-m.y, -0.05, PI_2 - 0.1); // clamp camera y rotation\n\n    ro = RotateY(m.y, ro);\n    ro = RotateZ(m.x, ro);\n\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n\n\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nTraceData Sphere(vec3 p, vec3 c,float r,int index)\n{\n    return TraceData(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nTraceData Cube(vec3 p,vec3 c,vec3 r,int index)\n{\n    vec3 q = abs(p-c) - r;\n    return TraceData(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nTraceData Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    return TraceData(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nTraceData Union(TraceData a,TraceData b)\n{\n    if (a.v<b.v)\n        return TraceData(a.v,a.i);\n    else \n    {\n        return TraceData(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nTraceData Intersection(TraceData a,TraceData b)\n{\n    if (a.v>b.v)\n    {\n        return TraceData(a.v,a.i);\n    }\n    else \n    {\n        return TraceData(b.v,a.i);\n    }\n}\n\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.html\n\n// Union with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothUnion( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b.v-a.v)/k, 0.0, 1.0 );\n    return TraceData(mix( b.v, a.v, h ) - k*h*(1.0-h), a.i);\n}\n\n// Difference with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothDiff( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(a.v+b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, -b.v, h ) + k*h*(1.0-h), a.i); \n}\n\n// Intersection with smoothing\n// a : field function of left sub-tree, \n// b : field function of right sub-tree\nTraceData SmoothInter( TraceData a, TraceData b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a.v-b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, b.v, h ) + k*h*(1.0-h), a.i);\n}\n\n\n\n// Dice \n// p : point\n// c : center \n// r : radius\nTraceData Dice(vec3 p,vec3 c,float r,int index)\n{\n    return SmoothInter(Cube(p,c,vec3(r*0.75),index),Sphere(p,c,r,index), 0.05);\n}\n\n// Potential field of the object\n// p : point\nTraceData object(vec3 p)\n{\n    TraceData u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),0);\n    vec3 dp = vec3(mod(p.xy + vec2(5,0), vec2(10.0)) - 5.0, p.z);\n\n    int index = int(p.x * 0.1 + 2.5);\n    index += int(p.y * 0.1 + 2.0)*3;\n\n    // DEBUG(vec3(float(index==5)))\n    TraceData dices = Dice(dp,vec3( 0.0, 0.0, 2.0),4.0, index);\n    dices = Intersection(dices, Cube(p, vec3(0), vec3(15.0,20.0,5.0), 0));\n    u = Union(u, dices);\n\n    return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  TraceData vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n    h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        s=i;\n        vec3 p = o+t*u;\n        float v = object(p).v;\n        // Hit object\n        if (v < 0.0)\n        {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON,v);\n        // Escape marched too far away\n        if (t>e)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n// Lighting ----------------------------------------------------------------------------------------------\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    float energy;\n    float shadow_dist;\n};\n\n// Compute ambient occlusion based on https://www.shadertoy.com/view/3lXyWs\n// p : Point\n// n : Normal at point\nfloat AmbientOcclusion(vec3 p,vec3 n) {\n\n    const int AO_STEPS = 4;\n    const float AO_MAX_DIST = 3.0;\n\n    const float SCALE = AO_MAX_DIST / pow(2.0, float(AO_STEPS))*2.0;\n    float ocl = 0.0;\n\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2.0, float(i)) * SCALE;\n        ocl += 1.0 - (max(0.0, object(p + n * dist).v) / dist);\n    }\n    \n    return min(1.0-(ocl / float(AO_STEPS)),1.0);\n    // return pow(abs(object(p + 2.0 * n)),0.9);\n}\n\n\n// Cast soft shadow based on https://www.shadertoy.com/view/tlBcDK\n// p : Point\n// l : Point to light vector\n// d : Max tracing distance\n// r : Softness radius\nfloat Shadow(vec3 p,vec3 l, float d, float r)\n{\n\n    float res = 1.0;\n    float t = 0.1;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\n        if (res < 0.0 || t > d)\n            break;\n    \n        float h = object(p+t*l).v;\n\n        res = min(res, r * h / t);\n        t += h;    \n    }    \n\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n// Fractal brownian motion\nfloat Fbm(vec3 p, int octave) {\n\n    float v = 0.,  a = .5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octave; ++i, p*=2.0, a/=2.0) \n        p *= R,\n        v += a * Noise(p);\n\n    return v;\n}\n\n// Voronoi fractal brownian motion\nvec3 FbmVoronoi(vec3 p, int octave) {\n\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octave; ++i, p*=2.0, a/=2.0) \n        p *= R,\n        v += a * Voronoi(p);\n\n    return v;\n}\n\n\n// saturate\nfloat sat(float x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// saturate\nvec3 sat(vec3 x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n\nMaterial MixMaterial(Material a, Material b, float t) {\n\n    Material mat;\n\n    mat.albedo = mix(a.albedo, b.albedo, t);\n    mat.roughness = mix(a.roughness, b.roughness, t);\n    mat.emissive = mix(a.emissive, b.emissive, t);\n    mat.clearcoat = mix(a.clearcoat, b.clearcoat, t);\n    mat.metallic = mix(a.metallic, b.metallic, t);\n\n    return mat;\n}\n\n\nMaterial MatFloor(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float checker = mod(dot(ceil(p*0.2), vec3(1)), 2.0);\n\n    vec3 v = Voronoi(p + 2.45 + Fbm(p*1.5, 4)*2.0);\n\n    float fact = sat(pow(v.x*0.9,10.0));\n    float bt = sat(pow(v.z*0.0025, 0.7));\n\n    mat.albedo = vec3(fact);\n\n    vec3 marble = mix(vec3(0.9,0.87,0.85), \n                vec3(0.08,0.07,0.05), abs(fact-checker));\n\n    mat.albedo = marble;\n    mat.roughness = v.x*0.05 + 0.05;\n\n    return mat;\n}\n\n\nMaterial MatCarCoat(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float glitters = Noise(p*25.0);\n\n    mat.albedo = mix(vec3(1,0,0), vec3(0.7,0,0), glitters);\n    mat.metallic = 1.0;\n    mat.roughness = glitters * 0.1 + 0.3;\n    mat.clearcoat = 1.0;\n\n    return mat;\n}\n\n\nMaterial MatAmbers(vec3 p, vec3 n) {\n\n    Material mat;\n\n    vec3 v = FbmVoronoi(p*vec3(3,2.0,2.0), 3);\n\n    float t = pow(1.0-v.y, 2.0);\n    float ef = pow(v.x, 6.0);\n    float bf = Noise(p*2.0 + iTime);\n\n    mat.emissive = mix(vec3(1,0.01,0),\n                        vec3(0.980, 0.321, 0),\n                        sat(pow(ef*pow(bf, 5.0)*4.0,0.2)));\n\n    mat.emissive *= pow(sat(ef*4.0),2.0)*bf*7.0;\n\n    float r = pow(Voronoi(p*2.0 + Fbm(p*2.0, 3)*2.0).x, 10.0);\n    r += Fbm(p, 4)*0.5 + ef;\n\n    mat.roughness = min(r*2.0, 1.0);\n    mat.albedo = vec3((1.0-mat.roughness)*0.01);\n    return mat;\n}\n\n\nMaterial MatWood(vec3 p, vec3 n) {\n\n    Material mat;\n\n    p += Fbm(p*0.9, 3)*1.0;\n    p.x += 1.0;\n\n    mat.roughness = 0.05;\n    vec3 v =  FbmVoronoi(p*vec3(2,0.02,0.0), 3);\n    float t = sat(pow(v.x*2.0 ,3.0));\n    vec3 a = mix(vec3(0.247, 0.105, 0.054), vec3(0.5,0.2,0.1), t);\n\n    mat.albedo = a;\n    mat.roughness = v.x;\n\n    return mat;\n}\n\n\nMaterial MatBurnedWood(vec3 p, vec3 n) {\n\n    Material mat;\n\n    p = RotateZ(-0.2, p);\n\n    float fact = smoothstep(0.5, 0.55, Fbm(p*0.14, 5));\n\n    Material wood = MatWood(p, n);\n    Material ambers = MatAmbers(p, n);\n\n    return MixMaterial(wood, ambers, fact);\n}\n\n\nMaterial MatMoss(vec3 p ,vec3 n) {\n    \n    Material mat;\n\n    float t = Noise(p*15.0);\n\n    mat.albedo = mix(\n                    mix(\n                        vec3(0.125, 0.074, 0.015),\n                        vec3(0.145, 0.105, 0.011),\n                        Fbm(p*3.0, 2)*2.0),\n                    mix(vec3(0.113, 0.2, 0.062),\n                        vec3(0.074, 0.156, 0.023),t),\n                    sat(Noise(p)*1.0)\n                );\n    \n    mat.roughness = min(t*0.3 + 0.5, 1.0);\n    \n    return mat;\n}\n\n\nMaterial MatSoil(vec3 p, vec3 n) {\n\n    Material mat;\n\n    vec3 v = FbmVoronoi(p*0.2, 3);\n    float stone =  max(1.0 - pow(v.y, 3.0)*3.0, 0.0 );\n    stone = max(stone, Fbm(p*0.5, 4));\n\n    stone = pow(sat(stone), 2.0)*0.7;\n\n    Material moss = MatMoss(p, n);\n    float t = min(pow(Voronoi(p*0.75).x + 0.2, 5.0), 1.0);\n    // float fact = \n    mat.albedo = vec3(stone);\n    mat.roughness = Fbm(p, 3);\n\n    return MixMaterial(mat, moss, t);\n}\n\n\nMaterial MatMarble(vec3 p, vec3 n) {\n\n    Material mat;\n\n    vec3 v = Voronoi(p*0.7+ Fbm(p*1.5, 4)*2.0);\n    float fact = sat(pow(v.x*1.1,5.0));\n    float bt = sat(pow(v.z*0.0025, 0.7));\n\n\n    mat.albedo = mix(vec3(0.9,0.87,0.85), \n                vec3(0.17,0.15,0.1), fact);\n\n    mat.roughness = 1.0-v.x;\n    mat.metallic = 0.0;\n    mat.clearcoat = 0.7;\n\n    return mat;\n}\n\n\nMaterial MatGranite(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float fact = pow(sat(Fbm(p*7.0, 3)*2.5),4.0);\n\n    mat.albedo = mix(\n                    vec3(0.019, 0.023, 0.015),\n\n                    mix(vec3(0.596, 0.560, 0.580),\n                        vec3(0.141, 0.137, 0.141),\n                        smoothstep(0.0, 0.7, Fbm(p*7.0,3))),\n                    fact);\n\n    mat.roughness = min(fact + 0.2, 1.0);\n    mat.clearcoat = 1.0;\n\n    return mat;\n}\n\n\nMaterial MatLava(vec3 p, vec3 n) {\n\n    Material mat;\n    float fact = pow(FbmVoronoi(p*0.5 + vec3(0,0,iTime*0.2), 3).x*1.2, 3.0);\n    vec3 em = mix(vec3(1,0.01,0), vec3(1,0.3,0.1), fact);\n    float solid = smoothstep(0.0, 0.5, fact);\n\n    mat.emissive = em*solid*20.0;\n\n    mat.roughness = sat(solid*2.0 + 0.8) ;\n\n    return mat;\n}\n\n\nMaterial MatRust(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float var = min(Noise(p*20.0)*0.3 + 0.3 + Fbm(p, 3)*0.5, 1.0);\n\n    mat.albedo = vec3(0.129, 0.023, 0.007)*var;\n    mat.roughness = var;\n\n    return mat;\n}\n\n\nMaterial MatRustedMetal(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float var = Fbm(p,4);\n\n    mat.albedo = vec3(var*0.1 + 0.2);\n    mat.metallic = 1.0;\n    mat.roughness = var*0.2+0.1;\n\n    Material rust = MatRust(p, n);\n\n    float fact = sat(Fbm(vec3(p.xy*2.0, 0), 3) - p.z*0.2 + 0.3);\n\n    return MixMaterial(rust, mat, fact);\n}\n\n\nMaterial MatBricks(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float var = Fbm(p*2.0, 4)*2.0;\n    mat.roughness = var*0.3 + 0.7;\n    p += var*0.07;\n    p.z += 0.1;\n\n    float fact = smoothstep(0.4, 0.6,abs(fract(p.z) - 0.5));\n    p.xy = p.xy*0.4 + 0.5 + mod(ceil(p.z), 2.0)*0.5;\n\n    vec2 xy = smoothstep(0.45, 0.55, abs(fract(p.xy) - 0.5));\n    fact = max(fact, max(xy.x , xy.y));\n\n    vec3 brick = vec3(ceil(p.z),ceil(p.xy));\n    var += Hash3(brick)-0.5;\n\n    brick = vec3(vec3(0.133, 0.015, 0.007) + var*0.04);\n\n    mat.albedo = mix(brick, vec3(1.0,0.95,0.9), fact);\n\n    return mat;\n}\n\n\nMaterial MatAsphalt(vec3 p, vec3 n) {\n\n    Material mat;\n    float disp = Fbm(p*4.0,4)*0.05;\n\n    vec3 v = Voronoi(p*12.0);\n    vec3 asphalt = vec3(0.05-v.y*0.04);\n    float t = smoothstep(0.27, 0.3, abs(fract((p.x+p.y)*0.35) - 0.5 + disp));\n\n    t *= max((Fbm(p*0.7,4)-0.3)*2.0, 0.0);\n\n    mat.albedo = mix(asphalt,\n                    vec3(0.6,0.2,0), t);\n\n    mat.roughness = min(mix(v.x*5.0 + 0.5, 0.5, t), 1.0);\n\n    return mat;\n}\n\n\nMaterial MatGold(vec3 p, vec3 n) {\n\n    Material mat;\n    \n    mat.albedo = vec3(1, 0.317, 0.039);\n    mat.metallic = 1.0;\n    mat.roughness == 0.0;\n\n    return mat;\n}\n\n\nMaterial  MatRustyPaint(vec3 p, vec3 n) {\n\n    Material mat;\n    p.z += 5.0;\n\n    float fact = 1.0 - smoothstep(0.25, 0.45, Fbm(p*0.5, 4));\n    float paint = 1.0;\n    vec3 pp = p;\n    mat3 R = RotationX(0.37);\n    float a = 0.5;\n\n    for (int i = 0; i < 3; ++i, pp*=2.0) {\n        pp = R*pp;\n        paint -= a*VoronoiE(pp).x;\n    }\n\n    paint = sat(pow(paint*2.0-0.8, 4.0));\n\n    // overlay blending\n    if (fact  < 0.5)\n        fact = 2.0*fact*paint;\n    else\n        fact = 1.0 - 2.0*(1.0-fact)*(1.0-paint);\n    \n    float var = Fbm(p, 4);\n    mat.albedo = vec3(0.074, 0.117, 0.203)*(var*0.3 + 0.5);\n    mat.roughness = 0.3 + var*0.3;\n\n    return MixMaterial(mat, MatRust(p, n), fact);\n}\n\nMaterial PlanarCarbonFiber(vec2 p) {\n\n    Material mat;\n\n    float offset = ceil(p.x*10.0)*0.3;\n    float stride = fract((p.y*2.0)+offset);\n\n    mat.albedo = vec3(ceil(stride-0.5)*0.01);\n    mat.roughness = max(1.0-stride*0.7 + 0.1, 0.0);\n    mat.clearcoat = 1.0;\n\n    return mat;\n}\n\nMaterial MatCarbonFiber(vec3 p, vec3 n) {\n\n    // triplanar projection\n    Material result = \n        MixMaterial(MixMaterial(PlanarCarbonFiber(p.xz),\n                                PlanarCarbonFiber(p.yz),\n                                pow(abs(n.x),5.0)),\n                    PlanarCarbonFiber(p.xy),\n                    pow(abs(n.z),5.0));\n    \n    return result;\n}\n\n\nMaterial MatPlastic(vec3 p, vec3 n) {\n\n    Material mat;\n    mat.albedo = vec3(1);\n    mat.metallic = 0.0;\n    mat.roughness = 0.2;\n    return mat;\n}\n\n\n// Compute texture \n// p : Point\n// n : Normal\nMaterial ComputeMaterial(in vec3 p, in vec3 n)\n{\n    TraceData vp= object(p);\n\n    switch (vp.i) {\n\n        case MATERIAL_FLOOR_TILES: return MatFloor(p, n);\n        case MATERIAL_CAR_COAT: return MatCarCoat(p, n);\n        case MATERIAL_BURNED_WOOD: return MatBurnedWood(p, n);\n        case MATERIAL_SOIL: return MatSoil(p, n);\n        case MATERIAL_MARBLE: return MatMarble(p, n);\n        case MATERIAL_GRANITE: return MatGranite(p, n);\n        case MATERIAL_LAVA: return MatLava(p, n);\n        case MATERIAL_RUSTED_METAL: return MatRustedMetal(p, n);\n        case MATERIAL_BRICKS: return MatBricks(p, n);\n        case MATERIAL_ASPHALT: return MatAsphalt(p, n);\n        case MATERIAL_GOLD: return MatGold(p, n);\n        case MATERIAL_RUSTY_PAINT:return MatRustyPaint(p, n);\n        case MATERIAL_CARBON_FIBER:return MatCarbonFiber(p, n);\n        default: return MatPlastic(p, n);\n    }\n}\n\n// Sky --------------------------------------------------------------------------------\n\n// Atmospheric scattering based on preetham's analytical model\n// https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-sky/index.glsl\n\n\nconst float turbidity = 10.0;\nconst float reileighCoefficient = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.75;\n\n// constants for atmospheric scattering\n\nconst float n = 1.0003; // refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n// 288.15K and 1013mb (sea level -45 celsius)\nconst float pn = 0.035; // depolatization factor for standard air\n\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n// mie stuff\n// K coefficient for the primaries\nconst vec3 K = vec3(0.686, 0.678, 0.666);\nconst float V = 4.0;\n\n// optical length at zenith for molecules\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\n\nconst float EE = 1000.0;\nconst float AngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n// 66 arc seconds -> degrees, and the cosine of that\n\n// earth shadow hack\nconst float cutoffAngle = PI/1.95;\nconst float steepness = 1.5;\n\n\nvec3 totalRayleigh(vec3 lambda)\n{\n    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n    float c = (0.2 * T ) * 10E-18;\n    return 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(V - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g)\n{\n    return (1.0 / (4.0*PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n    return max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\n\n\nvoid AtmosphericScattering(DirectionalLight light, vec3 worldNormal, \n    out float cosTheta, out vec3 Lin, out vec3 Fex) \n{\n\n    vec3 lightDirection = light.direction;\n    float lightEnergy = light.energy;\n\n    float sunfade = 1.0-clamp(1.0- exp(light.direction.z / 450000.0) ,0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // extinction (absorbtion + out scattering)\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    //float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n    float zenithAngle = acos(max(0.0, dot(up, worldNormal)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n\n    // combined extinction factor\n    Fex = exp(-(betaR * sR + betaM * sM));\n\n    // in scattering\n    cosTheta = dot(worldNormal, lightDirection);\n\n    float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n    vec3 betaRTheta = betaR * rPhase;\n\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\n    vec3 betaMTheta = betaM * mPhase;\n\n\n    Lin = pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n    Lin *= mix(vec3(1.0),pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, lightDirection),5.0),0.0,1.0));\n}\n\n\nvec3 AtmosphericScattering(DirectionalLight sun, vec3 viewDir) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, cosTheta, Lin, Fex);\n\n    vec3 texColor = Lin*0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\n// Get sky color\nvec3 Sky(DirectionalLight sun, vec3 viewDir) {\n\n    float CosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, CosTheta, Lin, Fex);\n\n    float sundisk = smoothstep(AngularDiameterCos,AngularDiameterCos+0.00002,CosTheta);\n    vec3 L0 = sun.energy * 19000.0 * sundisk * Fex;\n\n    vec3 texColor = (Lin + L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\nvec3 SkyExtinxtion(DirectionalLight light) \n{\n\n    float sunfade = 1.0-clamp(1.0-exp(light.direction.z),0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // sun optical length\n    float zenithAngle = acos(max(0.0, dot(up, light.direction)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n    // combined extinction factor\n    return exp(-(betaR * sR + betaM * sM));\n}\n\n\n\nvec3 Env(vec3 view, DirectionalLight sun) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, view, cosTheta, Lin, Fex);\n\n    vec3 L0 = Fex * 0.1;\n\n    vec3 texColor = (Lin+L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n// PBR -------------------------------------------------------------------------\n\n//https://gist.github.com/galek/53557375251e1a942dfa\n\n// Get sky ambient color\n// sunDirection : Sun direction\n// worldNormal : Ray direction\nvec3 SkyAmbient(DirectionalLight sun) {\n\n    return Env(normalize(sun.direction*1.8 + vec3(0,0,1)), sun);\n}\n\n\n// phong (lambertian) diffuse term\nfloat phong_diffuse()\n{\n    return (1.0 / PI);\n}\n\n\n// compute fresnel specular factor for given base specular and product\n// product could be NdV or VdH depending on used technique\nvec3 fresnel_factor(in vec3 f0, in float product)\n{\n    return mix(f0, vec3(1.0), pow(1.01 - product, 5.0));\n}\n\n\n// following functions are copies of UE4\n// for computing cook-torrance specular lighting terms\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * PI) * pow(NdH, n);\n}\n\nfloat D_beckmann(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    return exp((NdH2 - 1.0) / (m2 * NdH2)) / (PI * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NdH * m2 - NdH) * NdH + 1.0;\n    return m2 / (PI * d * d);\n}\n\nfloat G_schlick(in float roughness, in float NdV, in float NdL)\n{\n    float k = roughness * roughness * 0.5;\n    float V = NdV * (1.0 - k) + k;\n    float L = NdL * (1.0 - k) + k;\n    return 0.25 / (V * L);\n}\n\n\n// cook-torrance specular calculation                      \nvec3 cooktorrance_specular(in float NdL, in float NdV, in float NdH, in vec3 specular, in float roughness)\n{\n#if SPECULAR_MODE == SPECULAR_BLINN\n    float D = D_blinn(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_BECKMANN\n    float D = D_beckmann(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_GGX\n    float D = D_GGX(roughness, NdH);\n#endif\n\n    float G = G_schlick(roughness, NdV, NdL);\n\n    float rim = mix(1.0 - roughness * 0.9, 1.0, NdV);\n\n    return max((1.0 / rim) * specular * G * D, 0.0);\n}\n\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(MAX_STEPS-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n// Background color\nvec3 background(vec3 r, DirectionalLight sun)\n{\n    return Sky(sun, r);\n    // return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Tone mappin -------------------------------------------------------------------\n\n// based on https://www.shadertoy.com/view/ldcSRN\n\nconst float W =11.2; // white scale\n\n// filmic (John Hable)\n\n\nconst float A = 0.22; // shoulder strength\nconst float B = 0.3; // linear strength\nconst float C = 0.1; // linear angle\nconst float D = 0.20; // toe strength\nconst float E = 0.01; // toe numerator\nconst float F = 0.30; // toe denominator\n\nvec3 LinearToSRGB(vec3 x) \n{\n    vec3 t = step(x,vec3(0.0031308));\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);\n}\n\n\nvec3 Gamma(vec3 color, float gamma) \n{\n    return pow(color, vec3(gamma));\n}\n\n\nvec3 Uncharted2Curve(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2(vec3 color)\n{\n    vec3 white_scale = Uncharted2Curve(vec3(W));\n    return Uncharted2Curve(color) / white_scale;\n}\n\n\nvec3 ReinhardCurve (vec3 x)\n{\n\treturn x / (1.0 + x);\n}\n\nvec3 Reinhard(vec3 color) \n{\n    vec3 white_scale = ReinhardCurve(vec3(W));\n    return ReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicReinhardCurve (vec3 x) \n{\n    const float T = 0.01;\n    vec3 q = (T + 1.0)*x*x;\n\treturn q / (q + x + T);\n}\n\nvec3 FilmicReinhard(vec3 color) \n{\n    vec3 white_scale = FilmicReinhardCurve(vec3(W));\n    return FilmicReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicCurve(vec3 x)\n{\n\treturn ((x*(0.22*x+0.1*0.3)+0.2*0.01)/(x*(0.22*x+0.3)+0.2*0.3))-0.01/0.3;\n}\n\nvec3 Filmic(vec3 color)\n{\n    vec3 white_scale = FilmicCurve(vec3(W));\n    return FilmicCurve(color) / white_scale;\n}\n\n\nvec3 ACESFitted(vec3 color) {\n\n    color = pow(color, vec3(0.833));\n    color *= 1.07;\n\n    const mat3 ACESInput = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n\n    const mat3 ACESOutput = mat3(\n        1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n\n\n    color = color * ACESInput;\n\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.38081;\n    color = a/b;\n\n    return color * ACESOutput;\n}\n\n\nvec3 ToneMapping(vec3 color) {\n\n    color = color*0.2;\n\n    #if TONEMAP_MODE == TONEMAP_FILMIC\n        color = Filmic(color);\n    #elif TONEMAP_MODE == TONEMAP_REINHARD\n        color = Reinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD\n        color = FilmicReinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2\n        color = Uncharted2(color);\n    #elif TONEMAP_MODE == TONEMAP_ACES\n        color = ACESFitted(color);\n    #endif\n\n    color = clamp(LinearToSRGB(color), 0.0, 1.0);\n\n    return color;\n}\n\n// Compute Blinn-Phong specular\n// l : Vector to light\n// n : Normal at point\n// r : View ray direction\n// k : glossyness\nfloat Specular(vec3 l, vec3 n, vec3 r, float k)\n{\n    vec3 half_dir = normalize(l + r);\n    float spec_angle = max(dot(half_dir, n), 0.0);\n    return pow(spec_angle, k);\n\n    // Phong\n//     vec3 ref = reflect(r, n);\n//     float c = max(dot(ref, r), 0.0);\n//     return pow(c, k/4.0);\n}\n\n\n// Compute lighting\n// sun : Sun data\n// mat : Material data\n// p : Point on surface\n// rd : View ray direction\n// n : Normal at Point\n// reflection : Computed reflection\n// clearcoat : Computed clearcoat reflection\n vec3 Shade(DirectionalLight sun, Material mat, vec3 p, vec3 rd, vec3 n, \n    vec3 reflection, vec3 clearcoat) \n{\n\n    // Ambient color\n    vec3 ambient = SkyAmbient(sun) * 0.7;\n\n    // Ambient occlusion\n    ambient *= AmbientOcclusion(p, n);\n\n    // vec3 diffuse = ambient;\n    vec3 specular = mix(vec3(0.02), mat.albedo, mat.metallic);\n\n\n    vec3 L = sun.direction;\n    vec3 N = n;\n    vec3 V = -rd;\n    vec3 H = normalize(V+L);\n\n    float NdL = max(0.000, dot(N, L));\n    float NdV = max(0.001, dot(N, V));\n    float NdH = max(0.001, dot(N, H));\n    float HdV = max(0.001, dot(H, V));\n\n\n    // specular reflectance with COOK-TORRANCE\n    vec3 specfresnel = fresnel_factor(specular, HdV);\n    vec3 specref = cooktorrance_specular(NdL, NdV, NdH, specfresnel, mat.roughness);\n\n    specref *= vec3(NdL);\n\n    // diffuse is common for any model\n    vec3 diffref = (vec3(1.0) - specfresnel) * phong_diffuse() * NdL;\n\n    // visibility\n    float s = Shadow(p+n*0.1, L, sun.shadow_dist, 20.0);\n    \n    // compute lighting\n    vec3 reflected_light = vec3(0);\n    vec3 diffuse_light = vec3(0);\n\n    // point light\n    vec3 light_color = sun.color * sun.energy * 0.01;\n    reflected_light += specref * light_color * s;\n    diffuse_light += diffref * light_color * s;\n\n    reflected_light += min(vec3(0.99), fresnel_factor(specular, NdV)) * reflection;\n    reflected_light += min(vec3(0.99), fresnel_factor(vec3(0.02), NdV)) * clearcoat * 0.2;\n    diffuse_light += ambient * (1.0 / PI);\n\n    // final result\n    vec3 result = diffuse_light * mix(mat.albedo, vec3(0.0), mat.metallic);\n    result += reflected_light;\n    result += mat.emissive;\n\n    return result;\n}\n\n\n\n// Sample color from ray\n// sun : Sun light\n// ro : Ray origin\n// rd : Ray direction\n// steps : Number of trace steps\nvec3 ShadeRay(DirectionalLight sun, vec3 ro, vec3 rd, out int steps) {\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n    \n    // primary ray\n    float t = SphereTrace(ro, rd, 100.0, hit, s);\n    steps += s;\n\n    // Position \n    vec3 pt = ro + t * rd;\n\n    if (!hit)\n        return background(rd, sun);\n\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    Material mat = ComputeMaterial(pt, n);\n    vec3 reflect_dir = reflect(rd, n);\n    vec3 clearcoat = vec3(0);\n    vec3 reflection;\n\n    // reflection\n    if (mat.clearcoat > 0.0 || mat.roughness == 0.0) {\n\n        // secondary ray\n        t = SphereTrace(pt+n*0.01, reflect_dir, 100.0, hit, s);\n        steps += s;\n\n        if (hit) {\n            vec3 rpt = pt + t * reflect_dir;\n            vec3 rn = ObjectNormal(rpt);\n            Material rmat = ComputeMaterial(rpt, rn);\n\n            vec3 sec_reflection = Env(reflect(reflect_dir, rn), sun);\n            clearcoat = Shade(sun, rmat, rpt, reflect_dir, rn, \n                            sec_reflection, sec_reflection*mat.clearcoat);\n        } else\n            clearcoat = Env(reflect_dir, sun);\n    }\n    if (mat.roughness == 0.0)\n        reflection = clearcoat;\n    else {\n        float r = 1.0/max(mat.roughness, 0.00001);\n        float v = Shadow(pt+n*0.1, reflect_dir, 1000.0, r);\n        reflection = mix(SkyAmbient(sun)*0.1, Env(reflect_dir, sun), v);\n    }\n\n\n    clearcoat *= mat.clearcoat;\n\n    return Shade(sun, mat, pt, rd, n, reflection, clearcoat);\n}\n\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n\n    // Pixel\n        vec2 pixel=Pip(pxy, pip);\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n    // Shade background\n    DirectionalLight sun;\n    sun.direction = normalize(vec3(1,0.5,0.7));\n    sun.color = SkyExtinxtion(sun)* 19.0;\n    sun.energy = sunIntensity(sun.direction.z) * EE;\n    sun.shadow_dist = 100.0;\n\n    int s;\n\n    CATCH_DEBUG(vec3 rgb = ShadeRay(sun, ro, rd, s));\n\n    rgb = ToneMapping(rgb);\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n        rgb = ShadeSteps(s); \n\n\n#if _DEBUG\n    rgb = _debug_color;\n#endif\n    color = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1882, 1939, 1963, 1963, 2006], [2008, 2008, 2029, 2029, 2093], [2095, 2155, 2195, 2195, 2466], [2550, 2630, 2655, 2655, 2750], [2752, 2817, 2841, 2841, 3413], [3415, 3530, 3557, 3557, 4137], [4139, 4189, 4217, 4217, 5294], [5379, 5426, 5499, 5499, 5567], [5569, 5590, 5624, 5624, 5647], [5649, 5666, 5698, 5698, 5757], [5759, 5801, 5836, 5836, 6033], [6035, 6077, 6112, 6112, 6315], [6317, 6359, 6394, 6394, 6593], [6595, 6613, 6644, 6644, 6742], [6745, 6770, 6796, 6796, 6939], [6941, 7007, 7036, 7036, 7212], [7214, 7280, 7309, 7309, 7485], [7487, 7553, 7582, 7582, 7746], [7748, 7799, 7842, 7842, 7899], [7901, 7952, 7977, 7977, 8021], [8023, 8052, 8082, 8082, 8154], [8156, 8184, 8235, 8235, 8307], [8309, 8333, 8391, 8391, 8486], [8572, 8673, 8729, 8753, 9298], [9303, 9356, 9408, 9408, 9453], [9455, 9506, 9554, 9554, 9664], [9666, 9734, 9785, 9785, 9829], [9831, 9919, 9961, 9961, 10072], [10074, 10179, 10228, 10228, 10351], [10431, 10536, 10597, 10597, 10716], [10718, 10828, 10888, 10888, 11009], [11011, 11123, 11183, 11183, 11302], [11306, 11357, 11406, 11406, 11488], [11490, 11536, 11562, 11562, 12000], [12110, 12150, 12181, 12181, 12432], [12434, 12564, 12629, 12629, 13092], [13309, 13421, 13460, 13460, 13881], [13884, 14044, 14091, 14091, 14369], [14473, 14500, 14531, 14531, 14703], [14705, 14740, 14777, 14777, 14967], [14970, 14982, 15002, 15002, 15036], [15038, 15050, 15068, 15068, 15102], [15105, 15105, 15160, 15160, 15454], [15457, 15457, 15492, 15492, 15921], [15924, 15924, 15961, 15961, 16188], [16191, 16191, 16227, 16227, 16790], [16793, 16793, 16827, 16827, 17137], [17140, 17140, 17180, 17180, 17405], [17408, 17408, 17442, 17442, 17920], [17923, 17923, 17957, 17957, 18363], [18366, 18366, 18402, 18402, 18739], [18742, 18742, 18779, 18779, 19197], [19200, 19200, 19234, 19234, 19532], [19535, 19535, 19569, 19569, 19749], [19752, 19752, 19793, 19793, 20081], [20084, 20084, 20120, 20120, 20670], [20673, 20673, 20710, 20710, 21108], [21111, 21111, 21145, 21145, 21278], [21281, 21281, 21322, 21322, 21971], [21973, 21973, 22009, 22009, 22255], [22257, 22257, 22298, 22327, 22627], [22630, 22630, 22667, 22667, 22779], [22782, 22829, 22877, 22877, 23717], [24934, 25021, 25054, 25054, 25194], [25196, 25196, 25233, 25233, 25411], [25413, 25413, 25458, 25458, 25568], [25570, 25570, 25610, 25610, 25712], [25714, 25714, 25756, 25756, 25841], [25845, 25845, 25969, 25969, 27484], [27487, 27487, 27551, 27551, 27761], [27764, 27781, 27827, 27827, 28187], [28190, 28190, 28235, 28235, 28939], [28943, 28943, 28986, 28986, 29227], [29365, 29453, 29492, 29492, 29560], [29563, 29598, 29621, 29621, 29646], [29649, 29779, 29830, 29830, 29889], [29892, 29989, 30038, 30038, 30178], [30180, 30180, 30232, 30232, 30391], [30393, 30393, 30440, 30440, 30575], [30577, 30577, 30642, 30642, 30784], [30787, 30847, 30955, 30955, 31351], [31456, 31541, 31565, 31565, 31672], [31674, 31769, 31808, 31833, 32257], [32259, 32279, 32326, 32326, 32433], [32655, 32872, 32900, 32900, 33004], [33007, 33007, 33045, 33045, 33083], [33086, 33086, 33116, 33116, 33291], [33293, 33293, 33322, 33322, 33422], [33425, 33425, 33454, 33454, 33479], [33481, 33481, 33509, 33509, 33605], [33608, 33608, 33644, 33644, 33725], [33727, 33727, 33761, 33761, 33869], [33872, 33872, 33898, 33898, 33975], [33977, 33977, 34002, 34002, 34094], [34097, 34097, 34126, 34126, 34711], [34714, 34714, 34744, 34744, 35241], [35243, 35365, 35414, 35414, 35652], [35655, 35872, 35984, 36006, 37527], [37531, 37649, 37719, 37751, 39165], [39168, 39177, 39223, 39252, 39961]], "test": "error"}
{"id": "3ttcRr", "name": "201219_Raymarch", "author": "Yumuru", "description": "Practice", "tags": ["raymarching"], "likes": 2, "viewed": 76, "published": "Public", "date": "1616914102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference\n// SDF for raymarching by gaz : https://neort.io/product/bvcrf5s3p9f7gigeevf0\n\n#define resolution iResolution.xy\n#define time iTime\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define TAU atan(1.)*8.\n#define sabs(x) sqrt(x*x+1e-2)\n\n\nvec2 fold(vec2 p, vec2 v) {\n    float g = dot(p,v);\n    return (p-(g-abs(g))*v)*vec2(sign(g),1);\n}\n\nvec2 spmod(vec2 p, float n) {\n    float h=floor(log2(n));\n    float a = TAU*exp2(h)/n;\n    for (int i = 0; i < int(h)+2;i++) {\n        vec2 v = vec2(-cos(a),sin(a));\n        float g = dot(p, v);\n        p-=(g-sabs(g))*v;\n        a*=0.5;\n    }\n    return p;\n}\n\nfloat map(vec3 p) {\n    p.z+=time*8.;\n    p.xy*=rot(time*0.2+length(p.xy)*0.2+p.z*0.2);\n    p.xy=spmod(p.xy,3.);\n    p.xz=spmod(p.xz,4.);\n    p = mod(p, 4.)-2.;\n    p=-.7+abs(p);\n    \n    //if(p.x<p.y)p.xy=p.yx;\n    //if(p.x<p.z)p.xz=p.zx;\n    //if(p.y<p.z)p.yz=p.zy;\n    \n    vec2 v = normalize(vec2(2,-1));\n    p.xy=fold(p.xy,v);\n    p.xz=fold(p.xz,v);\n    p.yz=fold(p.yz,v);\n    p.xy*=rot(time*.5);\n    p.xz*=rot(time*.8);\n    \n    return (length(p.xy)-.1)*1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*resolution)/resolution.y;\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 p = vec3(0,0,-3);\n    float d = 1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    vec3 col = vec3(.1,0,.4);\n    if(d<.001)col+=6./i*vec3(0.0,.7,1.);\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttcRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 253, 280, 280, 351], [353, 353, 382, 382, 611], [613, 613, 632, 632, 1078], [1080, 1080, 1137, 1137, 1422]], "test": "valid"}
{"id": "3tVfDm", "name": "Ethereum takes off", "author": "alerado", "description": "eth taking off", "tags": ["eth"], "likes": 1, "viewed": 73, "published": "Public", "date": "1614629589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(0.6,0.4,1.0),vec3(0.28,0.13,0.88),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<2; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy = p.xy*abs(sin(t)+.5);\n        \n        p.xz-=.5;\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<140.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.06){\n          break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 79], [81, 81, 109, 109, 181], [183, 183, 201, 201, 386], [388, 388, 415, 415, 792], [793, 793, 850, 850, 1245]], "test": "valid"}
{"id": "3tyBzt", "name": "perlin swirls", "author": "HaleyHalcyon", "description": "a", "tags": ["perlinnoise"], "likes": 3, "viewed": 84, "published": "Public", "date": "1614828272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n\nfloat posmod(float x, float y) {\n  return x - y * (floor(x / y));\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint shuffle(uint x) {\n    x &= 255u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    x &= 255u;\n    return x;\n}\n// fade function defined by ken perlin\n#define fade(t) (t * t * t * (t * (t * 6. - 15.) + 10.))\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  float n = TAU * float(shuffle(uint(uv.x) + shuffle(uint(uv.y)))) / 256. + time;\n  return vec2(cos(n), sin(n));\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\nfloat valNoise(float x) {\n  uint xi = uint(floor(posmod(x, 256.)));\n  float valL = float(shuffle(xi));\n  float valR = float(shuffle(xi + 1u));\n  return mix(valL, valR, fade(fract(x))) / 255. - 0.5;\n}\nfloat gradNoise(float x) {\n  uint xi = uint(floor(posmod(x, 256.)));\n  float xf = fract(x);\n  float gradL = float(shuffle(xi)) / 255. - 0.5;\n  float gradR = float(shuffle(xi + 1u)) / 255. - 0.5;\n  return mix(gradL * xf, gradR * (xf - 1.), fade(xf));\n}\nvec2 shiftCenter(vec2 uv, float t, float strength) {\n  vec2 d = vec2(\n    valNoise(uv.x + t * 1.41421356) + gradNoise(uv.x - t),\n    valNoise(uv.y - t) + gradNoise(uv.y + t * 1.7320508)\n  );\n  return uv + d * strength;\n}\n\n// stripes of color\nconst vec3[] colors = vec3[](\n  vec3(245./255.,  23./255.,  22./255.),\n  vec3(248./255., 210./255.,  26./255.),\n  vec3( 47./255., 243./255., 224./255.),\n  vec3( 96./255., 192./255.,  83./255.),\n  vec3(250./255.,  38./255., 160./255.),\n  vec3(174./255., 129./255., 255./255.)\n);\nvec3 stripes(float n) {\n  int m = int(floor(n) - 6.0 * floor(n / 6.0));\n  return mix(\n    colors[m % 6],\n    colors[(m + 1) % 6],\n    smoothstep(0.9, 1.0, fract(n))\n  );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  vec2 uvShifted = shiftCenter(uv, iTime, 0.2);\n  \n  const float noisiness = 1.5;\n\n  float value = 6.0 * (atan(uvShifted.y, uvShifted.x) / TAU + iTime / 4.);\n  value += 2.0 * length(uvShifted);\n  value += noisiness * perlin(uv * 2.0, iTime / 32.);\n  value += noisiness * 0.3 * perlin(uv * 8.0, iTime / 16.);\n  value += noisiness * 0.05 * perlin(uv * 45.0, iTime /  8.);\n  // Output to screen\n  fragColor = vec4(\n    stripes(\n      value + (6.0 * fract(iTime / 12.))\n    ), 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 59, 59, 94], [96, 167, 189, 189, 350], [447, 464, 496, 496, 611], [612, 632, 669, 669, 1063], [1064, 1064, 1089, 1089, 1263], [1264, 1264, 1290, 1290, 1515], [1516, 1516, 1568, 1568, 1736], [1738, 2036, 2059, 2059, 2207], [2208, 2208, 2265, 2313, 2911]], "test": "error"}
{"id": "3tyfWc", "name": "NKoin", "author": "inear_sthlm", "description": "Coin test", "tags": ["basic"], "likes": 6, "viewed": 71, "published": "Public", "date": "1615188351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The dX and dY when differentiating height values.\n#define diff .002\n// How fast the light moves.\n#define timeScale 1.5\n// The radius of the light's path.\n#define lightPathRadius .55\n// The center of the light's path.\n#define lightPathCenter vec3(.5, .5, .025)\n// Color of the light.\n#define lightColor vec4(vec3(0.3), 1.0)\n// Light strength multiplier.\n#define lightStrength 2.0\n// The implied Z position of the lit surface.\n#define surfaceZDepth -0.08\n// The light's ambient term.\n#define ambientColor vec4(0.0, 0.0, 0.0, 1.0)\n// The falloff factor of the specular lighting term.\n#define specularFactor 8.0\n// The coefficient to the specular factor when negotiating\n// the brightness of distant, but satisfactorily oriented bumps.\n#define specularRatio 0.25\n// The coefficient of the values given by the specular map.\n#define specularMapRatio 4.0\n// Whether or not to use a texture as the base value.\n// #define useBaseImage\n#define PI 3.1415926538\n#define PI_2 1.57079632679489661923\n#define PI_4 0.785398163397448309616\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m) * vec4(p, 1.0)).xyz;\n    return q;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nmat4 translation(vec3 pos) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, pos.x, pos.y, pos.z, 1.0);\n}\n\nmat4 rotationZ(float ang) {\n\tmat4 m = mat4(1.0);\n\tm[0][0] = cos(ang);\n\tm[1][0] = -sin(ang);\n\tm[0][1] = sin(ang);\n\tm[1][1] = cos(ang);\n\treturn m;\n}\n\nmat4 rotationY(float ang) {\n\tmat4 m = mat4(1.0);\n\tm[0][0] = cos(ang);\n\tm[2][0] = sin(ang);\n\tm[0][2] = -sin(ang);\n\tm[2][2] = cos(ang);\n\treturn m;\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 rotateUV(vec2 uv, float rotation, float mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdStar(vec2 p, float r, int n, float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return smoothstep(0.0,0.01,length(p)*sign(p.x));\n}\n\n\nfloat thinCircle(vec2 p, float radius, float smoothEdge, float edgeDist){\n    float dist = sdCircle( p, radius );\n    return smoothstep(smoothEdge-edgeDist*0.25,smoothEdge+edgeDist*0.25,dist)-smoothstep(smoothEdge+edgeDist*0.5,smoothEdge+edgeDist,dist);\n}\n\nfloat logo(vec2 p) {\n    // inner\n    vec3 pos = vec3(p.x,p.y,0.15);\n    float d = 1e10;\n    {\n    vec3 q = pos;\n    \n    vec4 w = opElongate( opTx(q, rotationX(PI_2)), vec3(0.0,0.0,0.45) );\n    \n    d = min( d, w.w+sdCappedCylinder( w.xyz, vec2(0.24,0.16) ) );\n    }\n    \n    //outer arc\n    {\n    vec3 q = pos - vec3(-0.26 - 0.04,0.002,0.0);\n    vec4 w = opElongate( opTx(q, rotationX(PI_2)), vec3(0.0,0.0,0.45) );\n   \td = opSubtraction(d, w.w+sdCappedCylinder( w.xyz, vec2(0.25,0.15) ));\n    }\n    \n    {\n    //subtract from arc\n   \td = opSubtraction( sdBox(pos + vec3(0.0,1.2,0.0), vec3(1.0)), d);\n    }\n    \n    {\n    //bridge between center and arc\n    d = opUnion( sdBox(pos + vec3(0.1,-0.7+0.06,0.0), vec3(0.15,0.06,0.15)), d);\n    }\n    \n    //long center column\n   \td = opUnion( sdBox(pos + vec3(-0.1,0.10,0.0), vec3(0.15,0.8,0.15)), d);\n    //remove bottom corner\n    {\n    vec3 q = pos + vec3(-0.29,1.1,0.0);\n    d = opSubtraction(sdBox(opTx(q, rotationZ(PI_2*0.5)),vec3(0.3)), d);\n    }\n    \n    {\n    //k center\n    d = opUnion( d, sdBox(pos + vec3(-0.41,-0.21,0.0), vec3(0.37,0.07,0.15)));\n    //k top\n    d = opUnion( d, sdBox(pos + vec3(-0.5,-0.37,0.0), vec3(0.07,0.17,0.15)));\n    //k bottom\n    d = opUnion( d, sdBox(pos + vec3(-0.63,-0.05,0.0), vec3(0.15,0.24,0.15)));\n    }\n    return d;\n}\n   \n\nvec3 getPattern(vec2 p) {\n\n    float starMask = sdStar(p, 0.8, 5,3.2);\n    \n    vec3 col = vec3(0.0);\n    float offsetCenter = 0.5;\n    float rings1 = 40.0;\n    for(float i=0.0;i<rings1;++i)\n    {\n        float fade = 1.0;//sin(PI*2.0/float(rings1)*float(i*5));\n        col += fade * vec3(thinCircle(p + vec2(sin(PI*2.0/rings1*i)*offsetCenter,cos(PI*2.0/rings1*i)*offsetCenter), -0.4, 0.7,0.01)); \n    }\n    \n    col *= 1.7*starMask;\n    \n    float rings2 = 10.0;\n    offsetCenter = 0.35;\n    for(float i=0.0;i<rings2;++i)\n    {\n        float pattern = thinCircle(p + vec2(sin(PI*2.0/rings2*i)*offsetCenter,cos(PI*2.0/rings2*i)*offsetCenter), 0.1, 0.3,0.1);\n        pattern = smoothstep(0.6,1.0,pattern);\n        \n        col *= 1.0 - vec3(pattern); \n        \n        col += 0.5 * vec3(pattern);\n    }\n    \n    \n    col = clamp(col, 0.2,0.8 + starMask);\n    \n    //big star pattern\n    float rings3 = 140.0;\n    float offsetCenter2 = 0.6;\n    for(float i=0.0;i<rings3;++i)\n    {\n        float fade = 1.0;//sin(PI*2.0/float(rings1)*float(i*5));\n        col += (1.0-starMask) * vec3(thinCircle(p + vec2(sin(PI*2.0/rings3*i)*offsetCenter2,cos(PI*2.0/rings3*i)*offsetCenter2), -0.1, 0.3,0.01)); \n    }\n    \n    //small stars\n    float stars3 = 10.0;\n    float offsetCenter3 = 0.92;\n    for(float i=0.0;i<stars3;++i)\n    {\n        vec2 starP = p + vec2(sin(PI*2.0/stars3*i)*offsetCenter3,cos(PI*2.0/float(stars3)*float(i))*offsetCenter3);\n        col += vec3(sdStar(rotateUV(starP,PI*2.0/stars3*i,0.0), 0.07, 5,3.2)); \n    }\n    \n    //col = clamp(col, 0.0,1.0);\n    \n    col *= 1.0 - thinCircle(p, 0.4, 0.4,0.02);    \n    col *= 1.0 - thinCircle(p, 0.93, 0.1,0.02)*0.3;\n    \n    col -= smoothstep(0.2,0.31,sdCircle(p, 0.16)); \n    \n    col *= vec3(smoothstep(0.0,0.01,logo(p*vec2(3.0,3.0)+vec2(0.1,0.0))))*1.0;\n    \n    //col *= 12.0;\n    return col;\n}\n\n/*\n\tGet a false height value of a material.\n*/\nfloat getHeightValue(vec2 coord)\n{\n\treturn getPattern(coord).r;\n}\n\n/*\n\tReturns the local height difference of a bump map in both the X and Y directions.\n*/\nvec2 getLocalDiff(vec2 coord)\n{\n\t// Get the local difference of height along the X axis.\n\tfloat diffX = getHeightValue(vec2(coord.x+diff, coord.y) )\n\t\t-getHeightValue(vec2(coord.x-diff, coord.y) );\n\t\n\t// Do the same along the Y axis.\n\tfloat diffY = getHeightValue(vec2(coord.x, coord.y+diff) )\n\t\t-getHeightValue(vec2(coord.x, coord.y-diff) );\n\t\n\t// Return the two values as a 2D vector.\n\treturn vec2(diffX, diffY);\n}\n\n/*\n\tReturns the surface normal of a height map at a given point.\n*/\nvec3 getSurfaceNormal(vec2 coord)\n{\n\t// Get the local difference in height about the coordinate given.\n\tvec2 localDiff = getLocalDiff(coord);\n\t\n\t// Remember that the surface normal is a negative reciprocal of\n\t// the surface tangent (which is what the local difference really is).\n\t// This step does half that job, negating the local difference.\n\tlocalDiff *= -1.0;\n\t\n\t// Remember that this is to be stored in a pixel, so we have to\n\t// fit it to the range [0..1].\n\tlocalDiff = (localDiff/2.0)+.5;\n\t\n\t// In order to reciprocate the local difference in height--the difference\n\t// in essentially the Z direction of the material--we consider the localDiff\n\t// to be the horizontal terms of the normal vector. This leaves one thing\n\t// left to do.\n\t// We have to scale the Z term based on the magnitude of the height difference.\n\t// To do this we consider the normal vector to be the hypotenuse of a triangle,\n\t// with unit length 1. One side of the triangle is constrained to the XY plane,\n\t// and is the local height difference. This leaves the Z term easy to solve with\n\t// the pytheagorean theorem.\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(1.0-pow(localDiffMag, 2.0));\n\t\n\treturn vec3(localDiff, z);\n}\n\n/*\n\tReturns a hypothetical specular value from an existing texture,\n\tsince we don't have access to an actual specular map. (Similar\n\tto our height map values.)\n*/\nfloat getSpecularity(sampler2D tex, vec2 coords)\n{\n\treturn texture(tex, coords).b*.5;\n}\n\n/*\n\tReturns the position of our light, based on the global time.\n*/\nvec3 genLightCoords()\n{\n\t// Use simple trig to rotate the light position around a point.\n\tvec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), \n\t\t\t\tlightPathCenter.y + (cos(iTime*timeScale)*lightPathRadius),\n\t\t\t\tlightPathCenter.z);\n\treturn lightCoords;\n}\n\n/*\n\tReturns the vector of incidence between a light position and a surface position.\n*/\nvec3 getIncidence(vec3 lightPos, vec2 coord)\n{\n\t// To get the incidence vector we subtract the final position from the original\n\t// position. This gives us a vector pointing into the surface.\n\treturn lightPos - vec3(coord, surfaceZDepth);\n}\n\n/*\n\tReturns the cosine of the angle of incidence of our light and the *flat* surface.\n*/\nfloat getAngle(vec3 lightIncidence, vec3 normal)\n{\n\t// We have to unpack the normal vector.\n\tnormal.xy -= .5;\n\tnormal.xy *= 2.0;\n\t\n\t// Normalize the two participating vectors so we don't get\n\t// strange results.\n\tnormal = normalize(normal);\n\tlightIncidence = normalize(lightIncidence);\n\t\n\t// Return the dot product of the two, which represents the cosine of the angle\n\t// between the two vectors.\n\treturn dot(lightIncidence, normal);\n}\n\n/*\n\tReturns the distance between the light and a given texel.\n*/\nfloat getDist(vec3 light, vec2 coord)\n{\n\treturn distance(light, vec3(coord, 0.0));\n}\n\n/*\n\tReturns the brightness and color of the texel after lighting.\n*/\nvec4 getLighting(vec2 coord)\n{\n\t// Get the current light position.\n\tvec3 lightPos = genLightCoords();\n\t\n\t// Get the vector of incidence the light has with the curren texel.\n\tvec3 lightIncidence = getIncidence(lightPos, coord);\n\t\n\t// Also get the surface normal of the current texel.\n\tvec3 surfaceNormal = getSurfaceNormal(coord);\n\t\n\t// Determine the cosine of the angle between the incident and normal vectors.\n\tfloat cosine = getAngle(lightIncidence, surfaceNormal);\n\t\n\t// Also get the distance from the light to the current texel, for\n\t// distance falloff.\n\tfloat dist = getDist(lightPos, coord);\n\t\n\t// Here's where a bit of wiki comes in. Now we create the three elements of the\n\t// Phong rendering equation: The ambient term, the diffuse term, and the \n\t// specular term.\n\t\n\t// Create the base ambient light term.\n\tvec4 ambient = ambientColor;\n\t\n\t// Create a linear-falloff diffuse light term.\n\tvec4 diffuse = vec4(1.0);\n\tdiffuse *= lightStrength;\n\tdiffuse *=  (1.0-dist);\n\tdiffuse *= cosine;\n\tdiffuse *= lightColor;\n\t\n\t// Get the local specularity (shininess of the material.\n\tfloat spec = getSpecularity(iChannel0, coord);\n\t\n\t// Create a powered-falloff specular term.\n\tvec4 specular = vec4(1.0);\n\tspecular *= lightStrength;\n\t//specular *=  pow((1.0-dist), specularFactor);\n\tspecular *= pow(cosine, specularFactor*specularRatio);\n\tspecular *= lightColor;\n\tspecular *= spec*specularMapRatio;\n\t\n\treturn ambient+diffuse+specular+spec*0.5;\n}\n\n/*\n\tThe main function of the shader.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Get the normalized screen coordinates of the current texel.\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y*1.1;\n\t\n\t// Get the brightness due to lighting.\n\tvec4 lighting = getLighting(p) * (1.0-step(0.55,sdCircle(p,0.49)));\n\t\n    lighting.rgb += mix(vec3(0.3,0.3,0.0), vec3(0.2), smoothstep(0.31,0.32,sdCircle(p,0.5)));\n\n\t// Finally we send the texel out for use.\n\tfragColor = lighting;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[851, 1027, 1056, 1056, 1118], [1120, 1120, 1157, 1157, 1179], [1181, 1181, 1224, 1224, 1246], [1248, 1248, 1292, 1292, 1313], [1315, 1315, 1367, 1367, 1466], [1468, 1468, 1526, 1526, 1626], [1628, 1628, 1687, 1687, 1786], [1789, 1789, 1817, 1817, 1919], [1921, 1921, 1948, 1948, 2067], [2069, 2069, 2096, 2096, 2215], [2217, 2217, 2251, 2251, 2390], [2392, 2392, 2433, 2535, 2628], [2630, 2630, 2672, 2672, 2771], [2773, 2773, 2804, 2804, 2954], [2956, 2956, 3007, 3007, 3178], [3181, 3181, 3216, 3216, 3242], [3244, 3244, 3302, 3360, 3817], [3820, 3820, 3893, 3893, 4075], [4077, 4077, 4097, 4110, 5387], [5393, 5393, 5418, 5418, 7241], [7243, 7290, 7324, 7324, 7355], [7357, 7446, 7477, 7534, 7862], [7864, 7932, 7967, 8034, 9148], [9150, 9313, 9363, 9363, 9400], [9402, 9470, 9493, 9558, 9755], [9757, 9845, 9891, 10036, 10085], [10087, 10176, 10226, 10267, 10611], [10613, 10678, 10717, 10717, 10762], [10764, 10833, 10863, 10899, 12276], [12278, 12318, 12375, 12439, 12779]], "test": "error"}
{"id": "3tyfWy", "name": "Spherify UVs Solar system", "author": "nebbul", "description": "The planets of our solar system orbits the Sun (Ceres included!)\n\nThe orbit speeds should be fairly matching, but the other params are not accurate\n\nThe planets can be seen like sprites that has been \"spherified\". Check the debug render layers!", "tags": ["sun", "uv", "sphere", "solar", "system"], "likes": 7, "viewed": 202, "published": "Public", "date": "1615237470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// spheriphy idea comes from twitter\n// https://twitter.com/bgolus/status/1233279164947451909\n//\n// check my other shader what Spherify actually is\n// TLDR: it's bending a flat plane to a sphere\n// \n// https://www.shadertoy.com/view/3lGfWy\n\n// some global variables\n#define LAYER_DISPLAY 0\n#define GLOBAL_SPEED 0.05\n#define GLOBAL_ORBIT_SPEED 3.\n#define GLOBAL_ROT_SPEED 0.6\n#define GLOBAL_ORBIT_RING 0 // this is quite expensive\n#define GLOBAL_ORBIT_SUBDIVISIONS 300.\n#define GLOBAL_ORBIT_SIZE 0.002\n#define PI     3.14159265f\n\n// global functions\n// rotate a 2d vector\nvec2 Rotate2dVector(vec2 v, vec2 a) {\n\treturn vec2(a.x*v.x - a.y*v.y, a.y*v.x + a.x*v.y);\n}\n\n// remap a range\nfloat remap(float x, float in_min, float in_max, float out_min, float out_max)\n{\n    return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);\n}\n\n// remap from whatever to 0-1\nfloat remap01(float x, float in_min, float in_max)\n{\n    return (x - in_min) / (in_max - in_min);\n}\n\n// \nstruct Layers\n{\n    float mask;\n    float depth;\n    vec2 uv;\n    vec3 normals;\n};\n// stars method from: https://www.shadertoy.com/view/XltSz7\nvec3 star(vec3 star, vec2 coord)\n{\n    vec3 color = fract(star) * .4 + .6;\n    \n    float intensity = star.x * star.y ;\n    intensity = 2. * (fract(intensity) + .1) * (sin(iTime + intensity) + 1. / 2.);\n    \n    float z = pow(star.z, 5.); // z paralax amount\n    \n    star.xy += z * (.5 * iResolution.xy - iMouse.xy);\n    float size = distance(coord, star.xy);\n    size *= 0.2; // max size\n    size /= max(.2, z); // min size\n    size = max(0., 1. - size);\n    \n    return vec3(size * intensity * color);\n}\n\n// colors using IQ method\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n// pick a color based on index\nvec3 getClr(vec2 uv, vec2 clip, int clrIndex) {\n    float p = smoothstep(clip.x, clip.y, texture(iChannel0, uv).x);\n    if(clrIndex == 0) return 1.3 * pal( p, vec3(0.5,0.6585,0.3984),vec3(0.5,0.3384,0.9784),vec3(-0.151,0.3984,.5284),vec3(0.,0.,0.15) );           // sun\n    if(clrIndex == 1) return pal( p, vec3(0.5,0.6,0.6),vec3(0.3,.09,0.03),vec3(0.1,0.36,-0.49),vec3(0.,0.,0.) );                 // ceres\n    if(clrIndex == 2) return pal( p, vec3(0.5,0.4,0.),vec3(0.2,.05,0.),vec3(0.1,0.5,0.),vec3(0.,0.,0.) );                        // mercury\n    if(clrIndex == 3) return pal( p, vec3(0.68,0.96,0.82),vec3(0.5,.09,0.03),vec3(0.1,0.36,-0.49),vec3(0.,0.,0.) );              // venus\n    if(clrIndex == 4) return pal( p, vec3(0.35,0.73,0.5),vec3(.12,.08,0.63),vec3(0.44,0.86,0.35),vec3(0.16,0.03,1.05) );       // earth\n    if(clrIndex == 5) return pal( p, vec3(0.5,0.4,0.),vec3(0.5,.1,0.),vec3(0.1,0.5,0.),vec3(0.,0.,0.) );                         // mars\n    if(clrIndex == 6) return pal( p, vec3(0.82,0.7,0.15),vec3(0.16,0.20,-.4),vec3(0.52,0.27,0.35),vec3(2.97,1.18,4.39) );        // jupiter\n    if(clrIndex == 7) return pal( p, vec3(0.73,0.78,0.35),vec3(0.16,0.20,-.4),vec3(0.52,0.27,0.35),vec3(2.97,1.18,4.39) );       // saturn\n    if(clrIndex == 8) return pal( p, vec3(0.0,0.9,0.9),vec3(0.0,0.1,.1),vec3(0.,0.5,0.33),vec3(0.,0.5,0.66) );                   // uranus\n    if(clrIndex == 9) return pal( p, vec3(0.0,0.55,0.73),vec3(0.0,0.12,.25),vec3(0.,0.5,0.33),vec3(0.,0.5,0.66) );               // neptune\n    if(clrIndex == 10) return pal( p, vec3(0.5,0.6,0.6),vec3(0.3,.09,0.03),vec3(0.1,0.36,-0.49),vec3(0.,0.,0.) );                // pluto\n}\n\n// animate planet UVs\nvec2 planet_uv_scroll(vec2 uv_in, vec2 uv_scale, vec2 uv_scroll_speed, vec2 mouseMovement)\n{\n    vec2 scale = (1. / uv_scale);\n    \n    vec2 uv_mouse = vec2(-mouseMovement.x, -mouseMovement.y) * .1;\n    vec2 uv = (uv_in + uv_mouse) * scale;\n\n    return uv + (24. * iTime * uv_scroll_speed * GLOBAL_SPEED * GLOBAL_ROT_SPEED * scale / PI);\n}\n\n// get coordinates for the planet\nvec3 getPos(float orbitDistance, float orbitSpeed, float timeOffset, vec2 mMovement)\n{\n    float centerx = 0.5 * iResolution.x / iResolution.y;\n    float centery = 0.5 * iResolution.y / iResolution.y;\n    \n    float mOffset = (mMovement.x * 0.5);\n    \n    float x = centerx + sin(iTime * orbitSpeed * GLOBAL_SPEED * GLOBAL_ORBIT_SPEED + mOffset + timeOffset) * orbitDistance;\n    float z = cos(iTime * orbitSpeed * GLOBAL_SPEED * GLOBAL_ORBIT_SPEED + mOffset + timeOffset) * orbitDistance * orbitDistance;\n    float y = centery - ( (z / (orbitDistance * 2.)) * -clamp(mMovement.y, -iResolution.y, 0.) ) - (z / (orbitDistance * 2.))*0.3;\n    return vec3(x,y,z);\n}\n\n// make planet layers\nLayers planet(vec2 in_uv, float rad, vec3 pos, vec2 mask_smoothness) {\n    vec2 uv_pos = vec2(pos.x, pos.y);\n    float depth = pos.z;\n    \n    vec2 uv = (((in_uv - 0.5) * 2.) + uv_pos) * 1. / rad;\n    uv = (in_uv - uv_pos) * 1. / rad;\n\n    float d = sqrt(1.-clamp(dot(uv, uv), 0., 1.));\n    vec3 normals = vec3(uv, d);\n\n    vec2 q = (vec2(d, d) + vec2(1.,1.));\n    \n    uv /= q;\n\n    float mask = smoothstep(mask_smoothness.x, mask_smoothness.y, d);\n\n    return Layers(mask, depth, uv, normals);\n}\n\n// make ring layers - for saturn and uranus\nLayers rings(vec2 in_uv, float rad, vec3 pos, vec3 phases, float opacity, float angle, float squash) {\n    vec2 in_uv_rot = in_uv;\n\n    in_uv_rot = Rotate2dVector(in_uv_rot, vec2(cos(angle),sin(angle)));\n    \n    vec2 uv_pos = vec2(pos.x, pos.y);\n    uv_pos = Rotate2dVector(uv_pos, vec2(cos(angle),sin(angle)));\n    \n    vec2 uv = (((in_uv_rot - 0.5) * 2.) + uv_pos) * 1. / rad;\n    uv = (in_uv_rot - uv_pos) * 1. / rad;\n\n    uv.y *= squash; // squash the ring\n    \n    float depth = pos.z;\n    depth -= uv.y * 0.1;\n    \n    float d = sqrt(1.-clamp(dot(uv, uv), 0., 1.));\n\n    vec3 normals = vec3(Rotate2dVector(uv, vec2(cos(-angle),sin(-angle))), d);\n\n    vec2 q = (vec2(d, d) + vec2(1.,1.));\n    \n    uv /= q;\n    \n    // polar coordinates with an offset to hide seam behind planet\n    uv.y = mod(remap(atan(uv.y, uv.x), -PI, PI, 0., 1.) + 0.25, 1.);\n    uv.x = d;\n\n    float thickness = 0.8;\n    vec2 soft = mix(vec2(0., 0.5), vec2(0.4, 0.5), 0.);\n    float mask = smoothstep(soft.x, soft.y, d) - smoothstep(thickness - 0.05, thickness + 0.05, d);\n    \n    // stack some nice lines on the rings\n    float scroll = iTime * 0.4;\n    float rings = 1.;\n    rings *= smoothstep(0., .5, remap01(sin(d * phases.x + scroll * 0.8), -1., 1.));\n    rings *= smoothstep(0.2, 1., remap01(sin(d * phases.y + scroll), -1., 1.));\n    rings *= smoothstep(0.1, .8, remap01(sin(d * phases.z + scroll * 1.2), -1., 1.));\n    rings = smoothstep(0., 0.2, rings);\n    rings = remap(rings, 0., 1., 0.9, 1.1);\n    \n    mask *= rings;\n    mask *= opacity;\n\n    return Layers(mask, depth, uv, normals);\n}\n\n// draw planet to layers \nvoid MakePlanet(vec2 in_uv, float orbit_speed, float t_offset, float radius, float dist, float rot_speed, vec2 uv_scale, vec2 mMovement, int clrIndex, vec2 clrClip, inout float mask, inout float depth, inout vec3 normals, inout vec3 clr, inout vec2 uv)\n{\n    vec3 myPos = getPos(dist, orbit_speed, t_offset, mMovement);\n    \n    Layers myPlanet = planet(in_uv, radius, myPos, vec2(0., 0.2));\n    float mask_planet = mix(0., 1., depth < myPlanet.depth ? 1. : 0.) * myPlanet.mask;\n    mask = mix(mask, 1., mask_planet);\n    depth = mix(depth, myPlanet.depth, mask_planet);\n    vec2 planet_uv = planet_uv_scroll(myPlanet.uv, uv_scale, vec2(rot_speed, 0.), mMovement);\n    uv = mix(uv, planet_uv, mask_planet);\n    clr = mix(clr, getClr(planet_uv, clrClip, clrIndex), mask_planet);\n    normals = mix(normals, myPlanet.normals, mask_planet);\n    \n    // orbit ring\n    #if GLOBAL_ORBIT_RING\n    float planet_orbit_count = dist * GLOBAL_ORBIT_SUBDIVISIONS;\n    float m = mix(1., 5., remap01(radius, 0.007, 0.07));\n    for(float i = m ; i < planet_orbit_count-m ; i++ )\n    {\n        float angle = t_offset + ((i / planet_orbit_count) * PI * 2.);\n        myPos = getPos(dist, orbit_speed, angle, mMovement);\n\n        Layers planet_orbit = planet(in_uv, GLOBAL_ORBIT_SIZE, myPos, vec2(0., 1.));\n        float mask_planet_orbit = mix(0., 1., depth < planet_orbit.depth ? 1. : 0.) * planet_orbit.mask;\n        mask = mix(mask, 1., mask_planet_orbit);\n        depth = mix(depth, planet_orbit.depth, mask_planet_orbit);\n        uv = mix(uv, planet_orbit.uv, mask_planet_orbit);\n        clr = mix(clr, vec3(1.,1.,1.), mask_planet_orbit);\n        normals = mix(normals, planet_orbit.normals, mask_planet_orbit);\n    }\n    #endif\n}\n\n// draw rings to layers\nvoid MakeRing(vec2 in_uv, float orbit_speed, float t_offset, float radius, float dist, float rot_speed, vec2 uv_scale, vec2 mMovement, int clrIndex, vec2 clrClip, inout float mask, inout float depth, inout vec3 normals, inout vec3 clr, inout vec2 uv, vec3 phases, float opacity, float angle, float squash)\n{\n    vec3 myPos = getPos(dist, orbit_speed, t_offset, mMovement);\n    \n    Layers myRings = rings(in_uv, radius, myPos, phases, opacity, angle, squash);\n    float mask_rings = mix(0., 1., depth < myRings.depth ? 1. : 0.) * myRings.mask;\n    mask = mix(mask, 1., mask_rings);\n    depth = mix(depth, myRings.depth, mask_rings);\n    vec2 uv_rings = planet_uv_scroll(myRings.uv, uv_scale, vec2(0., rot_speed), vec2(0.,0.));\n    uv = mix(uv, uv_rings, mask_rings);\n    clr = mix(clr, getClr(uv_rings, clrClip, clrIndex), mask_rings);\n    normals = mix(normals, myRings.normals, mask_rings);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen uvs 0-1\n    //vec2 uv = fragCoord.xy/iResolution.yy;\n    \n    // tilt and rotate with mouse\n\tvec2 p = fragCoord / iResolution.x;\n    vec4 m = iMouse / iResolution.x;\n    \n    float mSens = 3.;\n    vec2 mFrom = (p - m.xy) * mSens;\n    vec2 mTo = (p-abs(m.zw)) * mSens;\n    vec2 mMovement = mFrom - mTo;\n\n    // init the layers\n    float mask = 0.;\n    float depth = -1.;\n    vec2 uv = fragCoord.xy/iResolution.yy;\n    vec3 clr = vec3(0,0,0);\n    vec3 normals = vec3(.5,.5,1.);\n    \n    float sun_distance = 0.001;\n    float ceres_distance = 0.13;\n    float mercury_distance = 0.17;\n    float venus_distance = 0.22;\n    float earth_distance = 0.28;\n    float mars_distance = 0.34;\n    float jupiter_distance = 0.44;\n    float saturn_distance = 0.57;\n    float uranus_distance = 0.68;\n    float neptune_distance = 0.78;\n    float pluto_distance = 0.88;\n    \n    float sun_radius = 0.1;\n    float ceres_radius = 0.007;\n    float mercury_radius = 0.015;\n    float venus_radius = 0.02;\n    float earth_radius = 0.03;\n    float mars_radius = 0.025;\n    float jupiter_radius = 0.07;\n    float saturn_radius = 0.05;\n    float uranus_radius = 0.03;\n    float neptune_radius = 0.025;\n    float pluto_radius = 0.007;\n    \n    float sun_orbit_speed = 0.001;\n    float ceres_orbit_speed = 0.052318;\n    float mercury_orbit_speed = 1.;\n    float venus_orbit_speed = 0.391633;\n    float earth_orbit_speed = 0.240964;\n    float mars_orbit_speed = 0.128093;\n    float jupiter_orbit_speed = 0.020319;\n    float saturn_orbit_speed = 0.008188;\n    float uranus_orbit_speed = 0.002877;\n    float neptune_orbit_speed = 0.001472;\n    float pluto_orbit_speed = 0.000972;\n    \n    float sun_t_offset = 0.;\n    float ceres_t_offset = 0.4;\n    float mercury_t_offset = 0.;\n    float venus_t_offset = 123.;\n    float earth_t_offset = 233.;\n    float mars_t_offset = 2243.;\n    float jupiter_t_offset = 623.;\n    float saturn_t_offset = 140.5;\n    float uranus_t_offset = 1143.;\n    float neptune_t_offset = 55.f;\n    float pluto_t_offset = 3.4;\n    \n    float sun_rotation_speed = -.2;\n    float ceres_rotation_speed = -2.655;\n    float mercury_rotation_speed = -0.016;\n    float venus_rotation_speed = 0.004;\n    float earth_rotation_speed = -1.;\n    float mars_rotation_speed = -0.9715;\n    float jupiter_rotation_speed = -2.4141;\n    float saturn_rotation_speed = -2.2191;\n    float uranus_rotation_speed = 1.3895;\n    float neptune_rotation_speed = -1.5827;\n    float pluto_rotation_speed = 0.1559;\n    \n    vec2 generic_uv = fragCoord.xy / iResolution.yy;\n    \n    //make the planets\n    MakePlanet(generic_uv, sun_orbit_speed, sun_t_offset, sun_radius, sun_distance, sun_rotation_speed, vec2(.9, .9), mMovement, 0, vec2(0., 0.8), mask, depth, normals, clr, uv);\n    normals = mix(normals, vec3(0.0,0.0,1.0), mask); // remove the normals for the sun\n    MakePlanet(generic_uv, ceres_orbit_speed, ceres_t_offset, ceres_radius, ceres_distance, ceres_rotation_speed, vec2(2., 2.), mMovement, 1, vec2(0., 0.7), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, mercury_orbit_speed, mercury_t_offset, mercury_radius, mercury_distance, mercury_rotation_speed, vec2(2., 2.), mMovement, 2, vec2(0.1, 0.5), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, venus_orbit_speed, venus_t_offset, venus_radius, venus_distance, venus_rotation_speed, vec2(1., 0.6), mMovement, 3, vec2(0.0, 0.4), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, earth_orbit_speed, earth_t_offset, earth_radius, earth_distance, earth_rotation_speed, vec2(4., 4.), mMovement, 4, vec2(0.1, .8), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, mars_orbit_speed, mars_t_offset, mars_radius, mars_distance, mars_rotation_speed, vec2(3., 3.), mMovement, 5, vec2(0.1, .8), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, jupiter_orbit_speed, jupiter_t_offset, jupiter_radius, jupiter_distance, jupiter_rotation_speed, vec2(15., 0.9), mMovement, 6, vec2(0., .9), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, saturn_orbit_speed, saturn_t_offset, saturn_radius, saturn_distance, saturn_rotation_speed, vec2(50., 1.), mMovement, 7, vec2(0., .9), mask, depth, normals, clr, uv);\n    MakeRing(generic_uv, saturn_orbit_speed, saturn_t_offset, saturn_radius + 0.05f, saturn_distance, -.1, vec2(0.3, 3.), mMovement, 7, vec2(0., .9), mask, depth, normals, clr, uv, vec3(23.34, 37.2234, 64.432), 0.9f, -0.3, 3.);\n    MakePlanet(generic_uv, uranus_orbit_speed, uranus_t_offset, uranus_radius, uranus_distance, uranus_rotation_speed, vec2(13., 13.), mMovement, 8, vec2(0., 1.), mask, depth, normals, clr, uv);\n    MakeRing(generic_uv, uranus_orbit_speed, uranus_t_offset, uranus_radius + 0.05f, uranus_distance, -.1, vec2(0.3, 3.), mMovement, 8, vec2(0., .9), mask, depth, normals, clr, uv, vec3(23.34, 37.2234, 64.432), 0.7f, 1.7, 4.);\n    MakePlanet(generic_uv, neptune_orbit_speed, neptune_t_offset, neptune_radius, neptune_distance, neptune_rotation_speed, vec2(12., 4.), mMovement, 9, vec2(0., .7), mask, depth, normals, clr, uv);\n    MakePlanet(generic_uv, pluto_orbit_speed, pluto_t_offset, pluto_radius, pluto_distance, pluto_rotation_speed, vec2(12., 4.), mMovement, 10, vec2(0., .7), mask, depth, normals, clr, uv);\n    \n    // background stars\n    vec3 stars_clr;\n\n    float texStep = 1. / 64.;\n    for (float y = 0.; y < .25; y += texStep) {\n        for (float x = 0.; x < 1.; x += texStep) {\n            vec3 pos = texture(iChannel1, vec2(x, y)).xyz;\n            pos.xy = (pos.xy - .5) * 2. + .5;\n            pos.xy *= iResolution.xy;\n            stars_clr += star(pos, fragCoord);\n        }\n    }\n    vec4 bg = vec4(stars_clr, 1.);\n    \n    // foreground lighting, center of screen is the origin since that's where the sun is\n\tvec2 uv_light = fragCoord.xy/iResolution.xy;\n\tvec2 delta = uv_light - vec2(0.5,0.5);\n    vec3 lightdir = normalize(vec3(-delta, 0.));\n    \n    // shadows from the sun\n    float shadows = mix(1., smoothstep(0., 0.8,(dot(lightdir, normals) + 1.) / 2.), 0.5);\n    \n    // highlight from the sun\n    vec3 highlight = vec3(1., 1., 0.5) * mix(0., smoothstep(0., 1., clamp(dot(lightdir, normals), 0., 1.)), 0.2);\n    \n    // apply shadows and highlight\n    vec3 fg = clr * shadows + highlight;\n    \n    // blend bg with fg by the mask\n    vec4 col = mix(bg, vec4(fg, 1.), mask);\n    \n    // display render layers by using global flag\n#if LAYER_DISPLAY\n    vec2 visuv = fragCoord.xy / iResolution.yy + fragCoord.y/iResolution.y;\n    float sliceCount = 6.;\n    float sliceWidth = 2.;\n    \n    float lineWidth = 0.05;\n    float speed = 0.2;\n    \n    float slice = floor(mod(visuv.x * sliceWidth - iTime * speed, sliceCount)) / sliceCount;\n    float line = 1.-(smoothstep(0., lineWidth, mod((visuv.x - iTime * speed * (1./sliceWidth)) * sliceWidth * sliceCount, sliceCount)) * smoothstep(0., lineWidth, mod((-visuv.x + iTime * speed * (1./sliceWidth)) * sliceWidth * sliceCount, sliceCount)));\n    \n    float sliceStep = 1. / sliceCount;\n    if(slice >= sliceStep && slice <= sliceStep*2.) col = vec4(normals, 1.);\n    if(slice >= sliceStep*2. && slice <= sliceStep*3.) col = vec4(clr, 1.);\n    if(slice >= sliceStep*3. && slice <= sliceStep*4.) col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), remap01(depth, -0.5, 0.5));\n    if(slice >= sliceStep*4. && slice <= sliceStep*5.) col = vec4(mod(uv, 1.), 0., 1.);\n    if(slice >= sliceStep*5. && slice <= sliceStep*6.) col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), mask);\n    \n    col = mix(col, vec4(1.,1.,1.,1.), line);\n#endif\n    \n    // display individual layers\n    //col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), mask);\n    //col = mix(vec4(0.,0.,0.,1.), vec4(1.,1.,1.,1.), remap01(depth, -1.,1.));\n    //col = vec4(mod(uv, 1.), 0., 1.);\n    //col = vec4(clr, 1.);\n    //col = vec4(normals, 1.);\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyfWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[529, 571, 608, 608, 662], [664, 681, 761, 761, 840], [842, 872, 924, 924, 971], [1060, 1120, 1154, 1154, 1626], [1628, 1695, 1763, 1763, 1806], [1807, 1838, 1885, 1885, 3494], [3496, 3518, 3610, 3610, 3857], [3859, 3893, 3979, 3979, 4555], [4557, 4579, 4649, 4649, 5076], [5078, 5122, 5224, 5224, 6702], [6704, 6730, 6984, 6984, 8446], [8448, 8472, 8779, 8779, 9366], [9372, 9372, 9429, 9535, 17265]], "test": "error"}
{"id": "7d2GRh", "name": "Ocean of blood", "author": "Tater", "description": "I was working on something else but I felt this scene was so cool by itself that I would publish it alone. \n", "tags": ["wip"], "likes": 2, "viewed": 117, "published": "Public API", "date": "1616966431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Not the cleanest because I was going to use this code for other stuff.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    uv.y=-uv.y;\n    vec2 uv0 = uv;\n    vec2 uv1 = uv;\n\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i<13; i++){\n        float fi = float(i);\n        uv1.y=uv.y+1.1-0.1*fi;\n        \n        uv1.y+=0.12*sin(5.0*iTime+fi*0.5)*sin(iTime+10.0*uv.x+fi*2.0);\n        \n        uv0.y = uv0.y*step(step(0.4,uv1.y),0.01)+uv1.y*step(0.4,uv1.y);\n    }\n    col.r=uv0.y;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2GRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 130, 130, 613]], "test": "valid"}
{"id": "7df3Dl", "name": "Conics through Five Elements", "author": "mla", "description": "As nice a bit of maths as you are likely to see today: drawing conic sections through three points and tangent to two lines (or through two points and tangent to three lines).", "tags": ["conic", "projective"], "likes": 9, "viewed": 197, "published": "Public API", "date": "1616843988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Conics through 3 points and 2 lines. mla, 2021\n//\n// A conic through three given points and tangent to two given lines,\n// must satisfy a quartic equation, and thus there are four solutions\n// (taking due account of multiple roots), though the points of tangency\n// may not be real. A lovely geometric solution is given by Heinrich\n// Dörrie in 100 Great Problems of Elementary Mathematics, making use\n// of Desargues' Involution Theorem (though Apollonius had a thing or\n// two to say about all this as well).\n//\n// https://archive.org/details/100GreatProblemsOfElementaryMathematicsDoverHeinrichDrrie/page/n281/\n//\n// The white conics pass through the three red points and are tangent to\n// the green lines, the blue conics are tangent to the three red lines\n// (dual to the red points) and pass through the green points (dual to\n// the green lines).\n//\n// In the default configuration (see code), one of the green lines is\n// the line at infinity, so cannot be seen and the white conics are all\n// parabolas, with the dual blue conics all appearing as ellipses (I'll\n// leave why that is so as a puzzle).\n//\n// The mouse sets the position of the green line. For some positions there is\n// no (real) solution for the conic - I'll leave the criteria for that as\n// another puzzle.\n//\n// A nice video from CodeParade on all this & more:\n// https://www.youtube.com/watch?v=X83vac2uTUs who has some nice code here\n// (this shader uses a similar solution but was developed independently):\n// https://github.com/HackerPoet/Conics\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\nint configuration = 2;\n\nfloat lwidth = 0.015;\nfloat pwidth = 0.05;\nconst float scale = 2.5;\n\nconst vec3 background = vec3(0);//vec3(1,1,0.5);\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = pcolor2;\nconst vec3 ccolor0 = 0.8*vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: axx + byy + czz + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate (what about adjugate?).\n\n// The triangle of reference (ToR subsequently) is the three\n// points with homogeneous coordinates (1,0,0),(0,1,0),(0,0,1)\n// The ToR is mapped to any three points p,q,r by the matrix\n// mat3(p,q,r) (with the usual glsl column major convention) and\n// so the inverse matrix maps p,q,r to the ToR, and we can solve\n// many problems more easily by first mapping selected points to\n// the ToR, solving a simpler problem, and mapping back at the end.\n//\n// A conic through the ToR is represent by a matrix with the form\n//\n// C = mat3(0,d,e,\n//          d,0,f,\n//          e,f,0)\n//\n// which represents the conic with equation:\n//\n// dxy + ezx + fyz = 0\n//\n// and this can be thought of as a constraint on d,e,f for it to\n// pass through the point (x,y,z)\n//\n// The inverse of C gives the line equation form of the conic,\n// ie. vec3(l,m,n)*inverse(C)*vec3(l,m,n) = 0 just when the line\n// (l,m,n) is tangent to the conic.\n//\n// For a conic through the ToR, the requirement that the conic is\n// tangent to a line (l,m,n) simplifies to:\n//\n// 4mnef = (me+nf-ld)²,\n//\n// a quadratic constraint, so there will be 0,1, or 2 ways it can\n// be satisfied in general. This constraint may be simplified if,\n// for example, the line passes through a vertex of the ToR, in which\n// case one of l,m,n are zero and the constraint becomes linear (if\n// two are zero, then the line is a side of the ToR and the problem\n// becomes even simpler).\n//\n// The most difficult situation is for three points and two general\n// lines (or dually, three lines and two points), with two quadratic\n// constraints, giving rise to a quartic equation.\n//\n// In this case, there is a simpler way to proceed using the\n// Desargues Involution Theorem, for details see Dörrie, but\n// briefly, the two tangent lines meet the conic at two points,\n// with the tangent chord between, and the sides of the ToR meet\n// the tangent chord at the fixpoints of a certain involution of\n// the line (an involution is a self-inverse projective\n// transformation, with t mapping to t' with tt' + b(t+t') + d = 0),\n// the involution on BC, for example, takes (0,1,0) to (0,0,1) and\n// (0,-n,m) to (0,-N,M) where (l,m,n) and (L,M,N) are the two lines.\n// In fact, for our involutions, b = 0 and d = mM/nN for BC\n// with the fixpoint being (0,1,sqrt(d)) (with no solution if d < 0)\n// and similarly on AC (it's easy to see there are either 3 real\n// fixpoints or 1, so we only need to calculate for two lines).\n\nmat3 pointconic(vec3 p, vec3 P) {\n  // Construct matrix for conic through vertices of ToR\n  // (so diagonal is zero) and through p and P\n  //float x = p[0], y = p[1], z = p[2];\n  //float X = P[0], Y = P[1], Z = P[2];\n  // Solve the homogeneous linear system\n  // dxy+exz+fyz = 0\n  // dXY+eXZ+fYZ = 0\n  // This is just the intersection of two lines, so:\n  vec3 l0 = p.xzy*p.yxz; //vec3(x*y,z*x,y*z);\n  vec3 l1 = P.xzy*P.yxz; //vec3(X*Y,Z*X,Y*Z);\n  vec3 def = cross(l0,l1);\n  float d = def[0], e = def[1], f = def[2];\n  return mat3(0,d,e,\n              d,0,f,\n              e,f,0);\n}\n\nbool lineconicparams(out vec2 res, vec3 a, vec3 A) {\n  float l = a[0], m = a[1], n = a[2];\n  float L = A[0], M = A[1], N = A[2];\n  float lL = l*L, mM = m*M, nN = n*N;\n  // sqrt(d) and sqrt(D) are fixpoints of the involutions\n  // as described above.\n  if (lL == 0.0 || mM == 0.0 || nN == 0.0) return false;\n  float d = mM/nN;\n  if (d < 0.0) return false;\n  float D = nN/lL;\n  if (D < 0.0) return false;\n  res = vec2(sqrt(d),sqrt(D));\n  return true;\n}\n\nmat3 cofactor(mat3 m) {\n  // Cofactor matrix of m, ie. the transpose of the adjugate\n  // (determinant is dot(m[0],cross(m[1],m[2])) and matrix\n  // multiplication is dot products of rows and columns)\n  return mat3(cross(m[1],m[2]),\n              cross(m[2],m[0]),\n              cross(m[0],m[1]));\n}\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\n// Screen coords to P2 coords\nvec3 map(vec2 p) {\n  return vec3(scale*(2.0*p - iResolution.xy) / iResolution.y, 1);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = iTime;\n  p.y -= 0.1;\n  p.xy = rotate(p.xy,0.2*t);\n  p.y += 0.1;\n  if (false) p.yz = rotate(p.yz,0.1618*t);\n  return p;\n}\n\nfloat dwidth;\n\nfloat pointdist(vec3 p, vec3 q) {\n  if (p.z == 0.0 || q.z == 0.0) return 1.0;\n  p /= p.z; q /= q.z; // Normalize\n  return smoothstep(0.75*pwidth,max(pwidth,0.75*pwidth+dwidth),distance(p,q));\n}\n\nfloat conicdist(vec3 p, mat3 m) {\n  float d = dot(p,m*p);\n  vec3 dd = 2.0*m*p;\n  d = abs(d/(p.z*length(dd.xy))); // Normalize for Euclidean distance\n  return smoothstep(0.5*lwidth,max(lwidth,0.5*lwidth+dwidth),d);\n}\n\nfloat linedist(vec3 p, vec3 l) {\n  float k = p.z*length(l.xy);\n  if (k == 0.0) return 1.0;\n  float d = abs(dot(p,l)/k);\n  return smoothstep(0.5*lwidth,max(lwidth,0.5*lwidth+dwidth),d);\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,1.0-level);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 pos = map(fragCoord.xy);\n  dwidth = fwidth(pos.x/pos.z);\n\n  vec3 p0,p1,p2,l0,L0;\n  if (configuration == 0) {\n    p0 = vec3(1,0,0); p1 = vec3(0,1,0); p2 = vec3(0,0,1);\n    l0 = vec3(1,1,1); L0 = vec3(1.4,0.5,1);\n  } else if (configuration == 1) {\n    p0 = vec3(0,0,1); p1 = vec3(1,0,1); p2 = vec3(0,1,1);\n    l0 = vec3(1,1,1); L0 = vec3(1.5,0.5,1);\n  } else if (configuration == 2) {\n    p0 = vec3(0,1,1); p1 = vec3(0.866,-0.5,1); p2 = vec3(-0.866,-0.5,1);\n    l0 = vec3(0,0,1); L0 = vec3(-0.8,0,1);\n  } else {\n    p0 = vec3(1,0,1);  p1 = vec3(0,1,1); p2 = vec3(-1,0,1);\n    l0 = vec3(1,1,0); L0 = vec3(1.5,0.618,1);\n  }\n  p0 = transform(p0); p1 = transform(p1); p2 = transform(p2);\n  //l0 = transform(l0); L0 = transform(L0);\n  if (iMouse.x != 0.0) L0 = map(iMouse.xy);\n\n  vec3 p01 = join(p0,p1);\n  vec3 p02 = join(p0,p2);\n  vec3 p12 = join(p1,p2);\n\n  vec3 color = background;\n  \n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,linedist(pos,p01));\n  color = cmix(color,lcolor2,linedist(pos,p02));\n  color = cmix(color,lcolor2,linedist(pos,p12));\n\n  // The tangent lines\n  color = cmix(color,lcolor1,linedist(pos,l0));\n  color = cmix(color,lcolor1,linedist(pos,L0));\n\n  // The lines of the ToR\n  color = cmix(color,lcolor0,linedist(pos,p0));\n  color = cmix(color,lcolor0,linedist(pos,p1));\n  color = cmix(color,lcolor0,linedist(pos,p2));\n\n  mat3 m = mat3(p0,p1,p2); // Map from ToR to (p0,p1,p2)\n  if (determinant(m) != 0.0) {\n    // m must be invertible\n    vec3 l1 = l0*m, L1 = L0*m; // Map the lines\n    m = inverse(m); // And invert for point mapping\n    vec2 t;\n    if (lineconicparams(t,l1,L1)) {  // Find involution fixpoints\n      for (int i = -1; i <= 1; i += 2) {\n        for (int j = -1; j <= 1; j += 2) {\n          // Each involution has two fixpoints ±t\n          // so there are 4 combinations possible\n          vec3 p = vec3(0,1,float(i)*t[0]);\n          vec3 P = vec3(float(j)*t[1],0,1);\n          vec3 l = cross(p,P);  // Line though p and P\n          vec3 q = cross(l,l1); // Intersect with tangents to give points on conic\n          vec3 Q = cross(l,L1);\n          mat3 c = pointconic(q,Q); // Find conic through ToR, q and Q\n          c = transpose(m)*c*m; // Conjugate with map to ToR\n          // And draw conic and dual\n          color = cmix(color,ccolor0,conicdist(pos,c));\n          // For the dual, just use the cofactor matrix\n          color = cmix(color,ccolor1,conicdist(pos,cofactor(c)));\n        }\n      }\n    }\n  }\n\n  color = cmix(color,pcolor2,pointdist(pos,p01));\n  color = cmix(color,pcolor2,pointdist(pos,p02));\n  color = cmix(color,pcolor2,pointdist(pos,p12));\n\n  color = cmix(color,pcolor1,pointdist(pos,l0));\n  color = cmix(color,pcolor1,pointdist(pos,L0));\n\n  color = cmix(color,pcolor0,pointdist(pos,p0));\n  color = cmix(color,pcolor0,pointdist(pos,p1));\n  color = cmix(color,pcolor0,pointdist(pos,p2));\n\n  fragColor = vec4(pow(color,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7df3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2647, 5106, 5139, 5458, 5687], [5689, 5689, 5741, 5741, 6139], [6141, 6141, 6164, 6341, 6440], [6442, 6442, 6469, 6567, 6590], [6592, 6622, 6640, 6640, 6708], [6710, 6710, 6746, 6746, 6798], [6800, 6800, 6824, 6824, 6957], [6974, 6974, 7007, 7007, 7167], [7169, 7169, 7202, 7202, 7384], [7386, 7386, 7418, 7418, 7572], [7574, 7574, 7624, 7624, 7665], [7667, 7667, 7724, 7724, 10652]], "test": "error"}
{"id": "7dfGD2", "name": "Distance to 3D Quadratic Bezier", "author": "oneshade", "description": "The distance to quadratic bezier splines generalizes to other dimensions.", "tags": ["3d", "raymarching", "sdf", "bezier", "spline", "quadratic", "exact"], "likes": 8, "viewed": 180, "published": "Public", "date": "1616545213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBezier(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3) {\n    vec3 c1 = p - v1;\n    vec3 c2 = 2.0 * v2 - v3 - v1;\n    vec3 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec3 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec3 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid addShape(in float dist, in int id, inout vec2 scene) {\n    if (dist < scene.x) scene = vec2(dist, id);\n}\n\nvec2 mapScene(in vec3 p) {\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(c2 * 2.0, s3 + 0.25, s1) * 2.0;\n    vec3 b = vec3(s1 * 2.0, s2 + 0.25, c3) * 2.0;\n    vec3 c = vec3(c3 * 2.0, c1 + 0.25, s2) * 2.0;\n\n    vec2 scene = vec2(sdBezier(p, a, b, c) - 0.15, 0);\n    addShape(length(p - a) - 0.25, 1, scene);\n    addShape(length(p - c) - 0.25, 2, scene);\n    addShape(length(p - b) - 0.25, 3, scene);\n    addShape(sdLine(p, a, b) - 0.075, 4, scene);\n    addShape(sdLine(p, b, c) - 0.075, 5, scene);\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = mapScene(p);\n        if (d.x < 0.001) {\n            int id = int(d.y);\n            vec3 n = getNormal(p);\n            float diff = sqrt(max(0.0, dot(-rd, n)));\n\n            if (id == 0) fragColor.rgb = vec3(diff, 0.8 * diff, 0.0);\n            if (id == 1) fragColor.rgb = vec3(0.0, 0.0, diff);\n            if (id == 2) fragColor.rgb = vec3(0.0, 0.0, diff);\n            if (id == 3) fragColor.rgb = vec3(diff, 0.0, 0.0);\n            if (id == 4) fragColor.rgb = vec3(0.1 * diff);\n            if (id == 5) fragColor.rgb = vec3(0.1 * diff);\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (t < 20.0 ? tPlane < t : true)) {\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor -= 0.8 * exp(-mapScene(iPlane).x);\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 1276], [1278, 1278, 1325, 1325, 1433], [1435, 1435, 1494, 1494, 1544], [1546, 1546, 1572, 1572, 2210], [2212, 2212, 2239, 2239, 2498], [2500, 2500, 2555, 2555, 4905]], "test": "valid"}
{"id": "7dfGR4", "name": "AA with fwidth", "author": "Xor", "description": "Here's a quick SDF anti-aliasing demo. On the left is fwidth, on the right is using length with the dx,dy derivatives. Notice how with fwidth, the diagonals extend further than they should.", "tags": ["sdf"], "likes": 4, "viewed": 119, "published": "Public", "date": "1615562715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//AA radius (high for demonstration)\n#define AA 10.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c1 = vec4(1.,.7,.1,1);\n    vec4 c2 = vec4(.1,.1,.1,1);\n    vec2 coord = mod(fragCoord+iTime*32.,128.)-64.;\n    \n    //Side divider\n    float side = fragCoord.x-iResolution.x/2.;\n\n    //Distance function\n    float dis = length(coord)-48.;\n    //SDF derivative\n    vec2 der = vec2(dFdx(dis),dFdy(dis));\n    //Derivative width\n    float wid = (side>0.)? length(der) : fwidth(dis);\n    //Anti-alias value\n    float aa = clamp(dis/wid/AA,0.,1.);\n    \n    //Divider line\n    float edge = min(side*side/8.,1.);\n    fragColor = mix(c1,c2,aa)*edge;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 110, 110, 661]], "test": "valid"}
{"id": "7dfGW8", "name": "Colorful waves", "author": "pontusasp", "description": "Colorful rotating cos- and sin-waves.\n\nMouse X shifts time passed between [-100, 100] s, Mouse Y shifts time scale between [-5, 5].", "tags": ["waves", "colorful"], "likes": 4, "viewed": 87, "published": "Public", "date": "1616078835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool even(float digit) {\n    return floor(digit) == floor(digit/2.0) * 2.0;\n}\n\nmat2 rotate2d(float theta) {\n    mat2 rot;\n    rot[0] = vec2(cos(theta), -sin(theta));\n    rot[1] = vec2(sin(theta), cos(theta));\n    return rot;\n}\n\nvec3 addRed(vec3 col, float r) {\n    col.r += r;\n    if (col.r > 1.) {\n        float rem = col.r - 1.;\n        col.r = 1.;\n        rem = min(rem, 2. - col.g + col.b);\n        col.g += min(rem/2., 1. - col.g);\n        col.b += min(rem/2., 1. - col.b);\n    }\n    return col;\n}\n\nvec3 addGreen(vec3 col, float g) {\n    col.g += g;\n    if (col.g > 1.) {\n        float rem = col.g - 1.;\n        col.g = 1.;\n        rem = min(rem, 2. - col.r + col.b);\n        col.r += min(rem/2., 1. - col.r);\n        col.b += min(rem/2., 1. - col.b);\n    }\n    return col;\n}\n\nvec3 addBlue(vec3 col, float b) {\n    col.b += b;\n    if (col.b > 1.) {\n        float rem = col.b - 1.;\n        col.b = 1.;\n        rem = min(rem, 2. - col.g + col.r);\n        col.g += min(rem/2., 1. - col.g);\n        col.r += min(rem/2., 1. - col.r);\n    }\n    return col;\n}\n\n\nvec3 addColor(vec3 col, vec3 add) {\n    col = addRed(col, add.r);\n    col = addGreen(col, add.g);\n    col = addBlue(col, add.b);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float timeScale = (iMouse.y / iResolution.y - .5) * 10.;\n    float time = timeScale * iTime + ((iMouse.x / iResolution.x - .5) * 200.);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n    vec3 r = vec3(col.r, 0.0, 0.0);\n    vec3 g = vec3(0.0, col.g, 0.3);\n    vec3 b = vec3(0.0, 0.0, col.b);\n    vec3 black = vec3(0.);\n    \n    vec3 fc;\n    \n    \n    float scale = (40.0 + 20.0 * sin(time / 5.0)) * 4.;\n    float unitsX = iResolution.x / scale;\n    float unitsY = iResolution.y / scale;\n    \n    float x = uv.x * unitsX - unitsX / 2.0;\n    float y = uv.y * unitsY - unitsY / 2.0;\n    \n    vec2 pos = rotate2d(time / 10.0) * vec2(x, y);\n    \n    x = pos.x;\n    y = pos.y + 2.*cos(x/1000. * time);\n    \n    float num = x + sin(y / 2.0 * sin(time/8.0)*5.0 + cos(time / 5.0) * 10.0);\n    float dist = min(abs(num - floor(num)), abs(num - ceil(num)));\n    float margin = 0.5;\n    \n    if (dist < margin) {\n        r = r * pow(1.0 - dist/margin, 4.0);\n        g = g * pow(1.0 - dist/margin, 4.0);\n        b = b * pow(1.0 - dist/margin, 4.0);\n        r = addColor(r, r * 0.7);\n        g = addColor(g, g * 0.9);\n        b = addColor(b, b * 0.7);\n        fc = r + g + b;\n    }\n    \n    \n    \n    vec3 final = fc;\n    float biggest = max(final.x, max(final.y, final.z));\n    if (biggest > 1.0) final /= biggest;\n    fragColor = vec4(final, 1.0);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 77], [79, 79, 107, 107, 226], [228, 228, 260, 260, 502], [504, 504, 538, 538, 780], [782, 782, 815, 815, 1057], [1060, 1060, 1095, 1095, 1206], [1209, 1209, 1266, 1316, 2797]], "test": "valid"}
{"id": "7dfGWH", "name": "exp(z^2)+k", "author": "enslow", "description": "Another fractal. I am not sure how to make this run better.", "tags": ["fractal"], "likes": 4, "viewed": 58, "published": "Public", "date": "1615854965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ryan Enslow March 9, 2021.\n//I have no idea how to make this run better in real time tbh\n\n#define AA 2.\n#define PI 3.14159\n\n\n#define CONSTANT 3.*vec2(-0.340, -0.280)\n#define CENTER vec2(-0.28985, -0.58325)\n#define RE exp(z.x*z.x-z.y*z.y)*cos(2.*z.x*z.y) +CONSTANT.x \n#define IM exp(z.x*z.x-z.y*z.y)*sin(2.*z.x*z.y) +CONSTANT.y \n#define SCALE 1.89798\n#define ESCAPE 1.5\n#define COLORFUN vec3(0.5) + vec3(0.5)*cos( (vec3(0.405, 0.382, 0.344)*(i/68.59355)+vec3(0.440, 0.419, 0.142)))\n\n#define ITERATION 300.\n\n//Extra definitions just in case I want to edit them above.\n\n\n#define IFLOAT0 2.05*(-cos(iTime/(2.*PI))+3.6)\n#define IFLOAT1 5.*(-cos(iTime/(2.*PI))+1.2)\n#define IFLOAT2 0.\n\n\nmat2 rotate(float theta){\n  return mat2(cos(theta),-sin(theta)\n             ,sin(theta), cos(theta));\n}\n\n\n//Determine the color of a given point after its iterative transformation\n//  z: point in complex plane\n//  i: current iteration\n//  col: output color\nvoid colord (in vec2 z, in float i, out vec3 col, inout bool br){\n  col = vec3(1.0);\n  float fi = i/12.;\n  if (length(z)>ESCAPE){\n    br = true;\n    col = COLORFUN;\n  }\n  else{\n    col = vec3(0.0);\n  }\n}\n\n\n//The complex function to transform a point\nvoid anon (in vec2 z, inout vec3 s, in float t){\n  vec2 c = z; //Original point\n  vec2 temp;\n  bool br;\n  for (float i=0.0; i<ITERATION+exp(IFLOAT0)/(1.+IFLOAT0);i += 1.0){\n    colord(z,i,s,br);\n    if (br) break;\n    temp.x = RE;\n    temp.y = IM;\n    \n    z = temp;\n  }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 a = iResolution.xy;\n  vec3 s = vec3(1.0);\n  vec3 col = vec3(0.0);\n  \n  float t = exp(0.5*IFLOAT1);\n  for (float j = 0.; j < AA; j += 1.0){\n    for (float k = 0.; k < AA; k += 1.0){\n      \n      vec2 uv = rotate(IFLOAT2)*SCALE*(fragCoord + vec2(j,k)/AA - .5*a.xy)/a.y / t+CENTER;\n      anon(uv,s,t);\n      col += s;\n    }\n  }\n  col /= AA*AA;\n  \n  //fragColor = vec4(mix(col,second,0.2),1.0);\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[508, 683, 708, 708, 786], [789, 940, 1005, 1005, 1143], [1146, 1190, 1238, 1238, 1462], [1465, 1465, 1520, 1520, 1949]], "test": "valid"}
{"id": "7dfGWj", "name": "Space Filling Rotating Squares", "author": "Tater", "description": "It was fun figuring out the how the squares should scale, I'm sure I'll use this for something eventually.\n\n", "tags": ["squares"], "likes": 6, "viewed": 146, "published": "Public API", "date": "1616559773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv*=2.0+mod(floor(iTime/3.14159265359*2.0)*2.0,8.0);\n    float t = iTime;\n    //uv/=(pow((-cos(t*4.0)*0.5+0.5),0.45)*(sqrt(2.0)-1.0)+1.0);\n    vec2 ID = 1.-2.*mod(floor(uv),2.);\n    //float yID=1.0-2.0*mod(floor(uv.y),2.0);\n    //float xID=1.0-2.0*mod(floor(uv.x),2.0);\n    uv = mod(uv,1.0)-0.5;\n    uv*=rot(ID.x*ID.y*t)*(pow((-cos(t*4.0)*0.5+0.5),0.45)*(sqrt(2.0)-1.0)+1.0);\n    \n    //uv = (fract(uv*2.0)-0.5)*step(abs(uv.x),0.5)*step(abs(uv.y),0.5);\n      \n    \n    vec2 S = smoothstep(-.005,.005,.5-abs(uv) );\n    uv *= S.x*S.y;\n    \n    //uv = uv*smoothstep(abs(uv.x)-0.005,abs(uv.x)+0.005,0.5)*smoothstep(abs(uv.y)-0.005,abs(uv.y)+0.005,0.5);\n    //uv = uv*step(abs(uv.x),0.5)*step(abs(uv.y),0.5);\n    \n    fragColor = vec4(.5,.5,1,1)* S.x*S.y;\n    \n    \n    /*\n    //not really sure how to do this better\n    vec3 col;\n    if(length(uv.x)!=0.0){\n        col.rgb = vec3(0.5,0.5,1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n    */\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 79], [80, 80, 137, 137, 1155]], "test": "valid"}
{"id": "7dfGWX", "name": "Liney", "author": "Daizuukee", "description": "just some lines, might make them more pog later", "tags": ["lines"], "likes": 8, "viewed": 288, "published": "Public API", "date": "1616627448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\nfloat PHI=1.61803398874989484820459;// Φ = Golden Ratio\n\nfloat random(in vec2 xy,in float seed){\n    float f=length(fract((cross((cross(fract(xy.yxy*PHI*seed)+seed,fract(xy.xyx/seed)+seed)*PHI),vec3(5./PHI,7./PHI,3./PHI)))));\n    return fract(f*seed);\n}\n\nfloat noise(vec2 st){\n    vec2 st0=floor(st);\n    vec2 st1=.5-cos((st-st0)*PI)*.5;\n    float a0=random(vec2(int(st0.x),int(st0.y)),1.);\n    float a1=random(vec2(int(st0.x)+1,int(st0.y)),1.);\n    \n    float a2=random(vec2(int(st0.x),int(st0.y)+1),1.);\n    float a3=random(vec2(int(st0.x)+1,int(st0.y)+1),1.);\n    \n    float b0=(a1-a0)*st1.x+a0;\n    \n    float b1=(a3-a2)*st1.x+a2;\n    return(b1-b0)*st1.y+b0;\n}\n\nfloat LineHeight(vec2 uv){\n    return noise(uv);\n}\n#define lines 20.\n#define height 0.5\n#define edges 0.1\n#define horizontalEdges 0.05\n\nbool HitsLines(vec2 uv,float vOffset){\n    if(uv.x < horizontalEdges || uv.x > 1.-horizontalEdges)\n        return false;\n    uv.x = uv.x * (1.-horizontalEdges*2.) + horizontalEdges;\n    for(float i=lines;i >= 0.;i--){\n        vec2 nuv = uv + vec2(0,((i + 0.5)/(lines)-1.) * (1.-edges*2.) - edges);\n        vec2 check = vec2(uv.x* 20. + iTime * (abs(lines/2.-i) * -0.25 + 1.125),i * 10.);\n        float h = (LineHeight(check + vec2(0,vOffset))-0.5) * height * (1.-pow(abs(2.*(uv.x - 0.5)) + 0.15,0.25));\n        if(h > nuv.y)\n            return false;\n        if(h < nuv.y && h > nuv.y - 0.004)\n            return true;\n    }\n    return false;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    float r = (HitsLines(fragCoord/iResolution.xy, 0.25))?0.5:0.;\n    float g = (HitsLines(fragCoord/iResolution.xy, -0.25))?0.5:0.;\n    float b = (HitsLines(fragCoord/iResolution.xy, -0.5))?0.5:0.;\n    fragColor=(HitsLines(fragCoord/iResolution.xy,0.))?vec4(1,1,1,1):vec4(r,g,b,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 87, 126, 126, 283], [285, 285, 306, 306, 694], [696, 696, 722, 722, 746], [832, 832, 870, 870, 1476], [1477, 1477, 1530, 1530, 1815]], "test": "valid"}
{"id": "7dfGzB", "name": "Playing With 5.", "author": "Sp3cim4n", "description": "Learning Shader Magic", "tags": ["learning"], "likes": 1, "viewed": 147, "published": "Public API", "date": "1616151758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, top, bottom, blur);\n    return band1 * band2;\n}\n\n\nfloat Remap(float a, float b, float c, float d, float t)\n{\n    return (clamp(0., 1., (t - a) / (b - a))) * (d - c) + c;\n}\n\nvec3  RainbowBand(vec2 uv, vec2 p, float t, float t_col)\n{\n    uv -= p;\n\n    float x = uv.x;\n    float m = 0.1*sin(t * 2.+ x * 10.);\n    float y = uv.y - m;\n\n    float blur = Remap(-.8, .8, .0, .5, x);\n    blur = blur * blur * blur * blur;\n    float blur2 = Remap(-.8, .8, .5, .0, x);\n    blur2 = blur2 * blur2 * blur2 * blur2;\n    blur = blur + blur2;\n    \n    float mask = Rect(vec2(x,y), -.8, .8, -.05, .05, blur);\n    \n    vec3 color = vec3(1.,0.,0.);\n    float c_sin = sin(t_col + x * 10.);\n    float c_m = Remap(-1., 1., .5, 1., c_sin);\n    color = mix(color, vec3(.0,1.,0.) * c_m, smoothstep(-.4, .0, uv.x * .5));\n    color = mix(color, vec3(.0,0.,1.) * c_m, smoothstep(.0, .4, uv.x * .5));\n    color *= mask;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float x = uv.x;\n    float t = iTime;\n    float m = 0.1*sin(t * 2.+ x * 10.);\n    float y = uv.y - m;\n    \n    vec3 color = vec3(.0);\n    int base_band_count = 8; // INPUT, change this.\n    float frequency = 2.;\n    \n    float b = sin(t * frequency);\n    b = Remap(-1., 1., 1., float(base_band_count + 1), b);\n    int band_count = int(b);\n    \n    \n    float offset_y = float(band_count - 1) * .5;\n    for(int i = 0; i < band_count; i++)\n    {\n        float k = float(i) - offset_y;\n        color += RainbowBand(uv, vec2(.0, k * .15), t, t * k * 10.);\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 203], [205, 205, 288, 288, 414], [417, 417, 475, 475, 538], [540, 540, 598, 598, 1281], [1283, 1283, 1340, 1340, 2053]], "test": "valid"}
{"id": "7dfGzS", "name": "HEelements", "author": "polluxchi2", "description": "2", "tags": ["1"], "likes": 0, "viewed": 33, "published": "Public", "date": "1616134226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float polygon(in vec2 uv, float time)\n{\n    float PI = 3.1415926;\n    float a = atan(uv.x, uv.y) + PI;\n    float peices = 2.0  * PI / 4.0;\n\tfloat k = floor(0.6 + (a - time) / peices) * peices - a + time;\n   \n\n    float c = 1.0/atan((peices - 0.2) /k) * length(uv);\n   \n   // float c = k1;// k2 / length(uv);// cos(peices / 2.5) / cos(peices / 2.5 - k) * length(uv);\n//\n    if(c < 0.01 || c > 0.8){\n        c = 0.0;\n    }\n    else\n    {\n        c = 0.5;\n    }\n    \n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center =  4.* (  fragCoord - .5*iResolution.xy ) / iResolution.y;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float c = polygon(center, iTime);\n    \n    fragColor = vec4(c ,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dfGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 484], [486, 486, 543, 543, 802]], "test": "valid"}
{"id": "7djGRD", "name": "tres brazos--three arms", "author": "jorge2017a1", "description": "tres brazos--three arms", "tags": ["tresbrazosthreearms"], "likes": 1, "viewed": 133, "published": "Public API", "date": "1617073177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge flores p.\n//referencia\n//https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n  \nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float thick)\n{\n    //correcion por FabriceNeyret2,     \n    float pix = 1.5/iResolution.y;\n    return smoothstep(thick + pix, thick - pix, sdSegment(p,a,b));   \n\n    //return 1.-smoothstep(thick - 1.5/iResolution.y, thick, sdSegment(p,a,b));   \n}\n\nvec3 LineasCuadriculado(vec2 p, vec3 col)\n{\n     vec2 a1=vec2(0.0,-1.5);\n    vec2 b1=vec2(0.0,1.5);\n     \n    vec2 a2=vec2(-2.0, 0.0);\n    vec2 b2=vec2( 2.0, 0.0);\n    \n    //float thick = 2./iResolution.y;\n    float thick =3./iResolution.y;\n    \n    float ds2= line(p, a1, b1, thick);  //vertical\n    float ds3= line(p, a2, b2, thick);  //horizontal\n    \n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,ds2);\n    col = mix(col,vec3(0.0, 0.0,0.0)*1.2,ds3);\n    return col;\n    \n}\n    \nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}    \n\nvec3 HacerBrazo(vec2 p, vec3 col )\n{\n    float thick = 2./iResolution.y;\n    \n    vec2 p1=vec2(0.0,0.0) ;\n    vec2 p2=vec2(0.5,0.5) ;\n    \n    vec2 p3=p2 ;\n    vec2 p4=p3+vec2(0.35,0.0) ;\n    \n    \n    vec2 p5=p4 ;\n    vec2 p6=p5+vec2(0.3,0.3) ;\n    \n    \n    vec2 pr1= RotarPuntoPivote( p,  p1, iTime);\n    vec2 pr2= RotarPuntoPivote( pr1,p3, iTime);\n    vec2 pr3= RotarPuntoPivote( pr2,p5, iTime*0.25);\n    \n    \n    float ds2= line(pr1, p1, p2, thick);  \n    float ds3= line(pr2, p3, p4, thick);  \n    float ds4= line(pr3, p5, p6, thick);  \n    \n    col = mix(col,vec3(1.0, 0.0,0.0),ds2);\n    col = mix(col,vec3(0.0, 0.0,1.0),ds3);\n    col = mix(col,vec3(0.0, 1.0,1.0),ds4);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv;\n    //vec3 col=vec3(0.65,0.7,1.0);\n    vec3 col=vec3(0.65);\n    col= LineasCuadriculado(p, col);\n    col= HacerBrazo( p,col );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 191, 191, 213], [214, 214, 247, 247, 269], [270, 270, 303, 303, 324], [606, 684, 720, 720, 765], [769, 769, 821, 821, 940], [943, 943, 977, 977, 1074], [1076, 1076, 1113, 1113, 1193], [1196, 1196, 1231, 1231, 1259], [1262, 1262, 1323, 1364, 1555], [1557, 1557, 1600, 1600, 2029], [2035, 2035, 2090, 2090, 2217], [2223, 2223, 2259, 2259, 2923], [2925, 2925, 2982, 2982, 3241]], "test": "error"}
{"id": "7djGRW", "name": "Circulo con olas", "author": "amatiasq", "description": "Circle with waves", "tags": ["waves"], "likes": 1, "viewed": 35, "published": "Public", "date": "1617056516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getPosition(vec2 fragCoord) {\n  return fragCoord.xy / iResolution.xy;\n}\n\nvec2 squareViewport(vec2 viewport) {\n  float radiusXY = iResolution.x / iResolution.y;\n  float radiusYX = iResolution.y / iResolution.x;\n  vec2 copy = viewport - 0.5;\n  \n  if (radiusXY > radiusYX) {\n    copy.x *= radiusXY;\n  } else {\n    copy.y *= radiusYX;\n  }\n  \n  return copy + 0.5;\n}\n\nfloat wave(vec2 pos, float freqA, float freqB, float speed, float offset, float bluriness) {\n  float wave1 = sin(pos.x * freqA + iTime * speed);\n  float wave2 = sin(pos.x * freqB + iTime * speed);\n  float result = (wave1 + wave2) * 0.02;\n  return smoothstep(pos.y - offset, pos.y - offset + bluriness, result);\n}\n\nfloat blurredCircle(vec2 pos, float fromRadius, float toRadius) {\n  float start = min(fromRadius, toRadius);\n  float end = max(fromRadius, toRadius);\n  float distance = length(pos - vec2(0.5)) * 2.0;\n  return smoothstep(start, end, distance);\n}\n\nvec4 draw(vec2 pos) {\n  float circle = 1.0 - blurredCircle(pos, 0.72, 0.8);\n  \n  float w1 = wave(pos, 2.0, 5.0, 4.0, 0.2, 0.01);\n  float w2 = wave(pos, 2.0, 4.0, 3.0, 0.4, 0.02) * 0.75;\n  float w3 = wave(pos, 1.0, 2.0, 2.0, 0.6, 0.04) * 0.5;\n  float w4 = wave(pos, 0.5, 1.0, 1.0, 0.8, 0.08) * 0.25;\n  \n  float waves = max(max(w1, w2), max(w3, w4));\n  \n  vec3 colorA = vec3(0.298, 0.0157, 0.5255);\n  vec3 colorB = vec3(0.6941, 0.1255, 0.1255);\n  \n  vec3 color = mix(colorA, colorB, waves);\n  vec3 inverse = mix(color, 1.0 - color, circle);\n  \n  return vec4(inverse, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 pos = squareViewport(getPosition(fragCoord));\n  fragColor = draw(pos);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 76], [78, 78, 114, 114, 365], [367, 367, 459, 459, 679], [681, 681, 746, 746, 925], [927, 927, 948, 948, 1499], [1501, 1501, 1558, 1558, 1638]], "test": "valid"}
{"id": "7dl3RN", "name": "oldschool_rand", "author": "Shellderr", "description": "old school look", "tags": ["noise", "value"], "likes": 2, "viewed": 46, "published": "Public", "date": "1615625790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define num 40.\n\nfloat rand(vec2 v, float n){\n    return fract(.05*n+55.7*sin(dot(3435.9*fract((v+3.1415)*5545.7),v)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime*.5;\n\n    vec2 v = uv*num;\n    vec2 s = abs(fract(v+(0.))-.5)*2.;\n    float n = t;\n  \n    vec2 vf = mix(vec2(rand(floor(v+t),n)),vec2(rand(floor(v+t+.5),n)), s);   \n    float cf = dot(vf,vec2(1.));\n    fragColor = vec4(cos(t+vec3(1.5,2.2,2.3)*cf)*.5+.5,1.0);\n    fragColor.xy *= .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 45, 45, 121], [123, 123, 180, 180, 524]], "test": "valid"}
{"id": "7dl3Wn", "name": "Thirty-Thousand waves", "author": "z0rg", "description": "A small shader based on Anachronist's Thirty-Thousand Miles song.\n", "tags": ["sdf", "light", "retrowave"], "likes": 5, "viewed": 362, "published": "Public API", "date": "1615898005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define FFT(A) pow(texelFetch(iChannel0, ivec2(A, 0), 0).x, 5.)*.5\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat _time;\n\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(rd, r));\n    float fov = mix(1., 10., sat(sin(_time*.25)*.5+.5));\n    return normalize(rd+(uv.x*r+uv.y*u)*fov);\n}\n\nfloat _cyl(vec3 p, float r)\n{\n    float test = clamp(sin(p.z+_time*50.)*100., -1., 1.);\n    r += sin(_time*50.+p.z*.5)*.1+FFT(p.z*.1);\n    r += test*.07;\n    return length(p.xy)-r;\n}\n\nfloat map(vec3 p)\n{\n    p.x = abs(p.x);\n    vec3 cp = p-vec3(20., 0.02, 0.);\n   \n    float yrep = 10.;\n    float idx = (cp.y+yrep*.5)/yrep;\n    cp.y = mod(cp.y+yrep*.5, yrep)-yrep*.5;\n    cp.x += sin(idx*.1+iTime*1.)*2.+FFT(idx)*10.;\n    float cl = _cyl(cp, .1+abs(sin(iTime))*.25+FFT(10));\n\n    //min(_sph(p, .5), _sph(p-vec3(1.+sin(_time), 0., 0.), .5));\n    return cl;\n}\n\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    \n    vec3 ro = vec3(0.,sin(_time),-5.);\n    vec3 ta = vec3(sin(_time*.25)*5.,cos(_time*.5)*2.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 p = ro;\n    vec3 acc = vec3(0.);\n    float accth = 5.;\n    for (int i = 0; i < 128; ++i)\n    {\n        float d = map(p);\n        if (d < 0.01)\n        {\n            vec3 grad = 0.5 + 0.5*cos(_time+uv.xyx+vec3(0,2,4)+2.*FFT(p.z+10.));\n            col = grad;\n            break;\n        }\n        if (d < accth)\n        {\n            vec3 grad = 0.5 + 0.5*cos(_time+uv.xyx+vec3(0,2,4)+2.*FFT(p.z+10.));\n            acc += grad*(1.-sat(d/accth))*(1.-sat(distance(ro, p)/300.));\n        }\n        p += rd * d;\n    }\n    \n    col += .25*sat(dot(rd, vec3(0.,0.,1.)))*(0.5 + 0.5*cos(_time+uv.yxy+vec3(0,2,4)+2.*FFT(p.z+10.)));\n    return col+acc*.2*FFT(10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n_time = iTime+texture(iChannel1, fragCoord/8.).x*iTimeDelta*2.;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    uv *= r2d(_time*.1);\n    vec3 col = rdr(uv);\n    { // Not so cheap antialiasing SSAA x4\n\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*2.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot);\n        acc += rdr(uv-off.xy*rot);\n        acc += rdr(uv-off.yy*rot);\n        acc += rdr(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    \n    col = mix(col, vec3(0.), pow(sat(length(uv*1.7)), 1.5));\n    col = pow(col, vec3(.45));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4lfXWN", "previewfilepath": "https://soundcloud.com/theanachronist/thirty-thousand-miles", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/theanachronist/thirty-thousand-miles", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3Wn.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 496, 515, 515, 569], [584, 584, 613, 613, 639], [641, 641, 672, 672, 868], [870, 870, 899, 899, 1052], [1054, 1054, 1073, 1073, 1427], [1430, 1430, 1449, 1449, 2296], [2298, 2298, 2355, 2355, 3115]], "test": "error"}
{"id": "7dl3zB", "name": "Two Link IK Robot Arm", "author": "oneshade", "description": "A robotic arm grabbing things. Based on reinder's [url=https://www.shadertoy.com/view/tlSSDV]\"Robotic Arm Hunting Lights\"[/url] and also trying to learn how inverse kinematics works. I'm going to have to start doing some robotics with my raspberry pi!", "tags": ["ik", "tracker", "robotics", "inversekinematics", "arm", "twolink"], "likes": 8, "viewed": 113, "published": "Public", "date": "1616191788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n#define PLOT_RES 30\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\nvec2 getTarget(in float t) {\n    vec2 polar = Hash12(t);\n    polar = vec2(polar.x * 6.28, polar.y * 2.0 + 1.0);\n    return vec2(cos(polar.x), sin(polar.x)) * polar.y;\n}\n\nvec2 getJointAngles(in vec2 a, in vec2 b, in float ra, in float rb) {\n    vec2 ba = b - a;\n    float d = dot(ba, ba);\n    float q1 = atan(ba.y, ba.x) + acos((d + ra * ra - rb * rb) / (2.0 * ra * sqrt(d)));\n    float q2 = atan(ba.y - ra * sin(q1), ba.x - ra * cos(q1));\n    return vec2(q1, q2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 6.0;\n    float unit = 12.0 / iResolution.y;\n    vec3 color = vec3(0.5, 0.0, 0.0);\n    float time = iTime;\n\n    float ra = 2.0;\n    float rb = 1.0;\n\n    vec2 a = vec2(0.0);\n\n    vec2 cPrev = getTarget(floor(time));\n    vec2 cNext = getTarget(ceil(time));\n    float transition = smoothstep(0.0, 1.0, fract(time));\n\n    vec2 prevAngles = getJointAngles(a, cPrev, ra, rb);\n    vec2 nextAngles = getJointAngles(a, cNext, ra, rb);\n\n    vec2 curAngles = mix(prevAngles, nextAngles, transition);\n    vec2 b = a + ra * vec2(cos(curAngles[0]), sin(curAngles[0]));\n    vec2 c = b + rb * vec2(cos(curAngles[1]), sin(curAngles[1]));\n\n    draw(sdRing(uv, a, ra, rb), vec3(0.0, 0.5, 0.0));\n\n    float tStep = 1.0 / float(PLOT_RES);\n    vec2 j2Prev = cPrev;\n    bool dash = true;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 angles = mix(prevAngles, nextAngles, smoothstep(0.0, 1.0, t));\n        vec2 j1Cur = a + ra * vec2(cos(angles[0]), sin(angles[0]));\n        vec2 j2Cur = j1Cur + rb * vec2(cos(angles[1]), sin(angles[1]));\n        if (dash) draw(sdLine(uv, j2Prev, j2Cur, 0.0), vec3(0.0, 0.0, 1.0));\n        j2Prev = j2Cur;\n        dash = !dash;\n    }\n\n    color = mix(color, vec3(1.0, 0.5, 0.0), min(exp(-10.0 * sdDisc(uv, cPrev, 0.1)) * (1.0 - transition), 1.0));\n    color = mix(color, vec3(1.0, 0.5, 0.0), min(exp(-10.0 * sdDisc(uv, cNext, 0.1)) * transition, 1.0));\n\n    float clip = -sdLine(uv, c, 2.0 * c - b, 0.1);\n    draw(sdLine(uv, a, b, 0.05), vec3(1.0, 0.8, 0.0));\n    draw(max(sdLine(uv, b, c, 0.05), clip), vec3(1.0, 0.8, 0.0));\n\n    draw(sdDisc(uv, a, 0.1), vec3(1.0));\n    draw(sdDisc(uv, b, 0.1), vec3(1.0));\n    draw(max(sdDisc(uv, c, 0.2), clip), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dl3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 177, 202, 202, 330], [332, 332, 380, 380, 412], [414, 414, 473, 473, 585], [587, 587, 647, 647, 688], [690, 690, 718, 718, 858], [860, 860, 929, 929, 1155], [1157, 1157, 1212, 1212, 3007]], "test": "valid"}
{"id": "7dlGDs", "name": "modus4", "author": "modus", "description": "idk", "tags": ["2d"], "likes": 1, "viewed": 55, "published": "Public", "date": "1616771776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float k = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 10.0;\n    uv.x *= k;\n    float a = abs(sin(length(uv.x/cos(iTime))/length(uv.y))*sin(length(uv.y/cos(iTime))/length(uv.x)));\n    fragColor = vec4(a,a,a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 311]], "test": "valid"}
{"id": "7dlGRf", "name": "Parallelogram - distance 2D", "author": "iq", "description": "Distance to a parallelogram, with only two edge checks (ie, total SDF with just two divisions, and a single square root), by using symmetry.", "tags": ["2d", "distancefield", "sdf", "distance", "parallelogram"], "likes": 18, "viewed": 473, "published": "Public API", "date": "1616405811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Distance to a parallelogram, I implemented three methods:\n// Method 1: computed by two edges, by symmetry, single square root\n// Method 2: computed by interior/exterior, optimization of Pentan's idea\n// Method 3: computed by zones\n\n#define METHOD 1\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\n// signed distance to a 2D parallelogram (width, height, skew)\nfloat sdParallelogram_1( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    p = (p.y<0.0)?-p:p;\n    // horizontal edge\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    // vertical edge\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/e2,-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat sdParallelogram_2( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    float da = abs(p.x*e.y-p.y*e.x)-wi*he;\n    float db = abs(p.y)-e.y;\n    if( max(da,db)<0.0 ) // interior\n    {\n        return max( da*inversesqrt(e2), db );\n    }\n    else                 // exterior\n    {\n       float f = clamp(p.y/e.y,-1.0,1.0);\n       float g = clamp(p.x-e.x*f, -wi, wi);\n       float h = clamp(((p.x-g)*e.x+p.y*e.y)/e2,-1.0,1.0);\n       return length(p-vec2(g+e.x*h,e.y*h));\n    }\n}\n\nfloat sdParallelogram_3( in vec2 p, float wi, float he, float sk )\n{\n    // above\n    float db = abs(p.y)-he;\n    if( db>0.0 && abs(p.x-sk*sign(p.y))<wi )\n        return db;\n        \n    // inside\n    float e2 = sk*sk + he*he;\n    float h  = p.x*he - p.y*sk;\n    float da = (abs(h)-wi*he)*inversesqrt(e2);\n    if( da<0.0 && db<0.0 )\n        return max( da, db );\n\n    // sides\n    vec2 q = (h<0.0)?-p:p; q.x -= wi;\n    float v = abs(q.x*sk+q.y*he);\n    if( v<e2 )\n        return da;\n    \n    // exterior\n    return sqrt( dot(q,q)+e2-2.0*v );\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    #if METHOD==1\n    return sdParallelogram_1(p,wi,he,sk);\n    #endif\n    #if METHOD==2\n    return sdParallelogram_2(p,wi,he,sk);\n    #endif\n    #if METHOD==3\n    return sdParallelogram_3(p,wi,he,sk);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animate\n    float sk = 0.5*sin(iTime);\n        \n    //p.x -= sk; // enable to lock base in place\n\n    // distance\n\tfloat d = sdParallelogram(p,0.4,0.6,sk);\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdParallelogram(m,0.4,0.6,sk);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlGRf.jpg", "access": "shaders20k", "license": "mit", "functions": [[1491, 1554, 1622, 1622, 2035], [2037, 2037, 2105, 2105, 2572], [2574, 2574, 2642, 2655, 3117], [3119, 3119, 3185, 3185, 3400], [3402, 3402, 3459, 3459, 4236]], "test": "valid"}
{"id": "7dlGWf", "name": "Projet Synthèse d'image Lépine", "author": "lepinetang", "description": "Projet de synthèse d'image de Tanguy Lépine", "tags": ["projetraytracer"], "likes": 1, "viewed": 68, "published": "Public", "date": "1616782128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Changer le delta time pour augmenter le blur ou le diminuer\n#define MOTION_BLUR_SAMPLES 4\n#define MOTION_BLUR_DELTA_TIME 0.005f \n\n//Structures\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n/*\n// Structures pour rajouter plus de sphère (ne marche pas encore)\nstruct SphereInfo\n{\n    vec3 pos;\n    vec3 col;\n    Material mat;\n    float rad;\n};\n*/\n\n// Constantes\nconst int MAX_NB_BOUNCES = 5;\nconst int PIXEL_SAMPLING_GRID_SIZE = 5;\nconst int PIXEL_SAMPLING_SIZE = 20;\n\n//Parametres de caméra\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; //\n\n//Parametres de sphères\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,1,0); // jaune\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\nvec3 spherePos2 = cameraTarget + vec3(3,1,2);\nconst float sphereRadius2 = 1.0;\nconst vec3 sphereCol2 = vec3(1,0,1);\nconst Material sphereMat2 = Material(0.2,0.7,1.0,50.0);\nconst int sphereId2 = 3;\n\n//const int NB_SPHERES = 2;\n\n//SphereInfo sphere[2];\n\n//Paramètre de lumières\nconst vec3 ambiantCol = vec3(0,0,1);\n\nconst vec3 light1Col = vec3(1,1,1);\nvec3 light1Pos = vec3(8,10,-12);\nconst float light1Pow = 0.8;\n\nconst vec3 light2Col = vec3(1,1,0.5);\nvec3 light2Pos = vec3(3,10,1);\nconst float light2Pow = 0.5;\n\nconst vec3 light3Col = vec3(0.5,1,0.5);\nvec3 light3Pos = vec3(1,-4,3);\nconst float light3Pow = 0.3;\n\nconst int NB_LIGHTS = 3;\n\nLightInfo lights[NB_LIGHTS];\n\n// Paramètres de lumières\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Paramètres de plan\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.0);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\n// Normalise coordonnées pour éviter problèmes d'écran\nvec2 transform_to_apply(vec2 xy){\n    xy = (2.*xy.xy - iResolution.xy)/iResolution.y;\n    return vec2(xy.x,xy.y);\n}\n\n// Intersection rayon et sphère\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\n// Intersection rayon et plan\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\n// Calcul du rayon depuis le pixel\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\n// Calcul du Phong shading\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 A = sphereMat.Ka * ambiantCol / float(NB_LIGHTS);\n    vec3 D = sphereMat.Kd * sphereCol * light.col * light.power * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * light.col * light.power  * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\nvoid nearestIntersection(int id1, vec3 inter1, vec3 n1, float d1, int id2, vec3 inter2, vec3 n2, float d2, out int id, out vec3 inter, out vec3 n, out float d) {\n    bool is1 = d1 > 0.0 && (d2 <= 0.0 || d1 <= d2);\n    d = is1 ? d1 : d2;\n    id = is1 ? id1 : id2;\n    n = is1 ? n1 : n2;\n    inter = is1 ? inter1 : inter2;\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecS2, normalS2;\n    float distSphere2 = raySphere(rayPos, rayDir, spherePos2, sphereRadius2, intersecS2, normalS2);\n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n\n    float minDist;\n    nearestIntersection(sphereId, intersecS, normalS, distSphere, planeId, intersecP, normalP, distPlane, objectId, intersecI, normalI, minDist);\n    nearestIntersection(objectId, intersecI, normalI, minDist, sphereId2, intersecS2, normalS2, distSphere2, objectId, intersecI, normalI, minDist);\n    return minDist;\n}\n\n// retourne la couleur de la sphere 1\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n// retourne la couleur de la sphere 2\nvec3 getSphere2ColorAtPoint(vec3 pt)\n{\n    return sphereCol2;\n}\n\n// retourne la couleur du plan\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\n// retourne la couleur de l'objet (ciel, sphere, plan)\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        case 3:\n            objectMat = sphereMat2;\n            return getSphere2ColorAtPoint(pt);\n    }\n}\n\n// Retourne l'ombre\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\n// Fonction de raytracing\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n    \tvec3 V = -rayDir;\n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n        \n        vec3 c = vec3(0.);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n    \t\tvec3 L = normalize(lights[i].pos - intersecI);\n    \t\tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n        \n        \tfloat Ldist = distance(intersecI,lights[i].pos);\n        \n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t\tc += computePhongShading(col, objMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n        \n        infos[nbBounces].shadedCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n\n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n// Pseudo aléatoire\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\nvoid animateScene(float time)\n{\n    const float pi = 3.1415926535;\n    const float rs = 2.0;\n    const float spr = 5.0;\n    float as = 2.0 * pi * time / spr;\n    \n    spherePos = cameraTarget + rs * vec3(-sin(as),0.0,cos(as)) + vec3(0,1,0);\n    \n    light1Pos += vec3(0,10.5 + 9.5 * cos(time) - 10.,0);\n    light2Pos += vec3(0,10.5 + 9.5 * sin(time) - 10.,0);\n    light3Pos -= vec3(0,10.5 + 9.5 * tan(time) + 10.,0); // tan change étrangement la couleur\n    \n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0,0,targetDist);\n    cameraPos += targetDist * vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    animateScene(time * 1.0);\n\n    lights[0].pos = light1Pos;  // Position de la lumière 1\n    lights[0].col = light1Col;  // Couleur de la lumière 1\n    lights[0].power = light1Pow;// Puissance de la lumière 1\n    lights[1].pos = light2Pos;  // Position de la lumière 2\n    lights[1].col = light2Col;  // Couleur de la lumière 2\n    lights[1].power = light2Pow;// Puissance de la lumière 2\n    lights[2].pos = light3Pos;  // Position de la lumière 3\n    lights[2].col = light3Col;  // Couleur de la lumière 3\n    lights[2].power = light3Pow;// Puissance de la lumière 3\n\n\n    fragCoord = transform_to_apply(fragCoord.xy);\n\n    vec3 resCol = vec3(0);\n    for (int k = 0; k < MOTION_BLUR_SAMPLES; k++) {\n        animateScene(MOTION_BLUR_DELTA_TIME);\n\n        for (int i=0; i<PIXEL_SAMPLING_GRID_SIZE; i++) \n        {\n            for (int j=0; j<PIXEL_SAMPLING_SIZE; j++) \n            {\n                vec2 offset = vec2(float(i)/(float(PIXEL_SAMPLING_GRID_SIZE) * iResolution.x),float(j)/(float(PIXEL_SAMPLING_SIZE)*iResolution.y));\n                resCol += RaytraceAtPixelCoord(fragCoord + offset);\n            }\n        }\n    }\n    resCol /= float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_SIZE * MOTION_BLUR_SAMPLES);\n\n    fragColor = vec4(resCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1980, 2039, 2072, 2072, 2154], [2156, 2189, 2306, 2306, 2848], [2850, 2880, 2993, 2993, 3247], [3249, 3284, 3368, 3368, 3767], [3769, 3796, 3931, 3931, 4218], [4220, 4220, 4381, 4381, 4542], [4545, 4545, 4661, 4661, 5373], [5375, 5413, 5450, 5450, 5474], [5476, 5514, 5552, 5552, 5577], [5579, 5610, 5646, 5646, 5733], [5735, 5790, 5865, 5865, 6219], [6221, 6241, 6328, 6328, 6513], [6515, 6541, 6583, 6583, 8147], [8149, 8170, 8210, 8210, 8427], [8429, 8429, 8460, 8460, 9065], [9068, 9068, 9125, 9125, 10416]], "test": "error"}
{"id": "7ds3DX", "name": "String Theories", "author": "FuzzkingCool", "description": "Just playing around with another one of Inigo Quilez's brilliant shaders. Ended up with something quite unique I think. ", "tags": ["procedural", "3d", "raymarching", "distancefield", "endless", "antialias", "conetracing", "strings"], "likes": 9, "viewed": 185, "published": "Public", "date": "1616684905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on a Shader Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n \n#define ANTIALIASING\n\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.10, 1.0 );\n\treturn vec2( length( pa-ba*h ), h );\n}\n\nvec3 opU( vec3 d1, vec3 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec3 map( vec3 p )\n{\n    vec2 id = floor( (p.xz+1.0)/2.0);\n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;\n    \n    float ph = sin(1.1 + 1.0 *id.x + sin(-2.1*id.y));\n    \n    p.xz += 0.5*sincos(1.0+0.15*iTime+(p.y+11.0*ph)*1.108);\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-4.0*iTime+1.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iTime+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iTime+4.0);\n    \n    vec2 h1 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 150.0, 0.0) );\n    vec2 h2 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 150.0, 0.0) );\n    vec2 h3 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 150.0, 0.0) );\n    \n    return opU( opU( vec3(h1.x-0.012,                                         ph + 4.0/3.0, h1.y), \n                     vec3(h2.x-0.012-0.05*cos(300.0*h2.y - iTime*4.0), ph + 5.0/3.0, h2.y) ), \n                     vec3(h3.x-0.012-0.02*cos(2000.0*h3.y - iTime*4.0), ph + 2.0/3.0, h3.y) );\n}\n\n\n//-------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos, in float dt )\n{\n    vec2 e = vec2(1.0,-21.0)*dt;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.15;\n\tfloat ao = 0.2;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(0.45,9.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.5*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d);\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\n\n//-------------------------------------------------------\nvec3 shade( in float t, in float m, in float v, in vec3 ro, in vec3 rd )\n{\n    float px = 0.0001;//(2.0/iResolution.y)*(1.0/3.0);\n    float eps = px*t;\n\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormal( pos, eps );\n    float occ = calcOcc( pos, nor );\n\n    vec3 col = 0.5 + 0.5*cos( m*vec3(1.24,1.2,1.0) + vec3(10.0,1.0,2.0) );\n    col += 0.05*nor;\n    col = clamp( col, 0.0, 1.0 );\n    col *= 1.0 + 0.5*nor.x;\n    col += 0.2*clamp(1.0+dot(rd,nor),0.0,1.0);\n    col *= 3.4;\n    col *= occ;\n    col *= exp( -0.25*t );\n    col *= .80 - smoothstep( 15.0, 135.0, t );\n    \n    return col;\n}\n\n\n//-------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n\tvec3 ro = 0.6*vec3(2.0,-3.0, 4.0);\n\tvec3 ta = 0.5*vec3(0.0, 4.0,-4.0);\n    \n    float fl = 0.40;\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(1.0,0.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\t\n    float px = (2.0/iResolution.y)*(1.0/fl);\n    \n    vec3 col = vec3(0.0);\n\n    //---------------------------------------------\n    // raymarch loop\n    //---------------------------------------------\n    \n    const float maxdist = 22.0;\n\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    #ifdef ANTIALIASING\n    vec3 oh = vec3(0.0);\n    vec4 tmp = vec4(0.0);\n    #endif\n    \n    for( int i=0; i<256; i++ )\n    {\n\t    vec3 h = map( ro + t*rd );\n        float th1 = px*t;\n        #ifndef ANTIALIASING\n        th1 *= 1.5;\n        #endif\n        res = vec3( t, h.yz );\n        if( h.x<th1 || t>maxdist ) break;\n\n        \n        #ifdef ANTIALIASING\n        float th2 = px*t*2.0;\n        if( (h.x<th2) && (h.x>oh.x) )\n        {\n            float lalp = 1.0 - (h.x-th1)/(th2-th1);\n            vec3  lcol = shade( t, oh.y, oh.z, ro, rd );\n            tmp.xyz += (1.0-tmp.w)*lalp*lcol;\n            tmp.w   += (1.0-tmp.w)*lalp;\n            if( tmp.w>0.99 ) break;\n        }\n        oh = h;\n        #endif\n        \n        t += min( h.x, 0.5 )*0.5;\n    }\n    \n    if( t < maxdist )\n        col = shade( res.x, res.y, res.z, ro, rd );\n    \n    #ifdef ANTIALIASING\n\tcol = mix( col, tmp.xyz/(0.001+tmp.w), tmp.w );\n    #endif\n \n    //---------------------------------------------\n    \n    col = pow( col, vec3(0.5,0.7,0.5) );\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ds3DX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 166, 190, 190, 223], [225, 225, 276, 276, 399], [401, 401, 431, 431, 463], [465, 465, 485, 485, 1400], [1403, 1462, 1507, 1507, 1705], [1707, 1707, 1750, 1750, 2088], [2091, 2149, 2223, 2223, 2740], [2743, 2802, 2859, 2859, 4666]], "test": "valid"}
{"id": "7dS3Rz", "name": "Gear 2D using circle modificatio", "author": "lumic", "description": "Simple gear shape by modifying a circle SDF", "tags": ["2d", "sdf", "gear"], "likes": 2, "viewed": 76, "published": "Public", "date": "1616814881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RINNER 0.65\n#define ROUTER 0.7\n#define REPITITION 12.0\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdModulatedCircle(vec2 p, float radius)\n{\n    float repeat = REPITITION + floor(cos(iTime) * 5.0);\n\n    // Circle is centered at origin, convert to polar coordinates\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    \n    float bump = smoothstep(0.25, 1.5, cos(angle * repeat + iTime) + 1.0) * 0.125;\n\n    return r - (radius + bump);\n}\n\nfloat sdSubtract(float d1, float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat sdCombine( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat gear(vec2 p) {\n\tfloat d1 = sdCircle(p, RINNER);\n\tfloat d2 = sdModulatedCircle(p, ROUTER);\n    \n    return sdSubtract(d1, d2);\n}\n\nfloat ring(vec2 p) {\n\tfloat d1 = sdCircle(p, RINNER - 0.1);\n    return abs(d1) - 0.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float zoom  = 2.0;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y * zoom;\n    \n    float d = gear(p);\n    d = sdCombine(d, ring(p));\n    \n    // SDF Coloring based on https://www.shadertoy.com/view/3ltSW2\n    \n    float sgn = sign(d);\n    \n    col = col - sign(d) * vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-1.75 * abs(d));\n\tcol *= 0.8 + 0.2 * smoothstep(0.0, 2.0, cos(50.0*d) + 1.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    if (sgn > 0.0) {\n        col += smoothstep(1.75, 2.0, cos(100.0 * d) + 1.0);\n    } else {\n        col += 0.95;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dS3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 97, 97, 125], [127, 127, 174, 174, 480], [482, 482, 521, 521, 547], [549, 549, 588, 588, 613], [615, 615, 635, 635, 748], [750, 750, 770, 770, 838], [840, 840, 897, 947, 1730]], "test": "valid"}
{"id": "7ds3W2", "name": "Complex Field Lines", "author": "jllusty", "description": "Field lines of two charges of opposite signs using a complex potential.", "tags": ["complex"], "likes": 9, "viewed": 133, "published": "Public", "date": "1616602420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 4.0 * atan(1.0);\n\nvec2 mult(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\n\nvec2 div(in vec2 a, in vec2 b) {\n    return mult(a,vec2(b.x,-b.y))/length(b);\n}\n\nvec2 clog(in vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 func(in vec2 z) {\n    //return mult(z - vec2(2.0f, 0.0), div(vec2(1.0,0.0), z + vec2(sin(iTime), 0.0)));\n    return clog(z-vec2(-4.,1.)) + clog(z-vec2(0.,2.)) - mult(vec2(2.,0.), clog(z-vec2(2.,-2.)));\n}\n\nvec3 checkerboard(in vec2 uv) {\n    int parity = int(floor(uv.x)) + int(floor(uv.y));\n    if(parity % 2 == 0) {\n        return vec3(0.0);\n    }\n    else {\n        return vec3(1.0);\n    }\n}\n\n//float wrap(float x, float a) {\n//    return x - a * floor(x / a);\n//}\n\n\n// Smooth wrap.\nfloat wrap(float x, float a){\n    x -= a*floor(x/a);\n    // Smoothing factor.\n    const float sf = 16.; \n    // Rough smoothing.\n    return min(x, (1. - x)*x*16.);\n}\n\nfloat angdist(in float theta1, in float theta2) {\n    return wrap(theta2 - theta1 + pi, 2.0*pi) - pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 4.0*(2.0*fragCoord/iResolution.xy - 1.);\n    float aspect = iResolution.y/iResolution.x;\n    uv.x = uv.x/aspect;\n\n    // Save Pixel Position\n    vec2 pos = uv;\n\n    // Apply Function\n    uv = func(uv);\n    \n    // Get distance to closest arg(z)-isocurve\n    float n = 22.;\n    float arg = uv.y; //atan(uv.y, uv.x);\n    float gEps = 0.001;\n    float stretch = length(func(pos+vec2(gEps,gEps))-func(pos))/(sqrt(2.)*gEps);\n    float eps = 0.05;\n    float d = abs(fract(arg*n/(2.*pi)+.5)-.5)/stretch;\n    float r = length(uv);\n    //if (r >= 1.) d = d*r;\n    float c = 1. - smoothstep(eps, 2.*eps, d);\n    \n    //\n    float n1 = 22.;\n    float arg1 = uv.x-iTime/4.; //atan(uv.y, uv.x);\n    float gEps1 = 0.001;\n    float stretch1 = length(func(pos+vec2(gEps1,gEps1))-func(pos))/(sqrt(2.)*gEps1);\n    float eps1 = 0.05;\n    float d1 = abs(fract(arg1*n1/(2.*pi)+.5)-.5)/stretch1;\n    float r1 = length(uv);\n    //if (r >= 1.) d = d*r;\n    float c1 = 1. - smoothstep(eps1, 2.*eps1, d1);\n\n    // Stack onto Base Image (Contours)\n    //  background color\n    float bc = 1.0-wrap(length(uv.x-iTime),1.);\n    //  line color\n    c = max(c,c1);\n    vec3 lcol = vec3(1.0,0.0,0.0);\n    //vec3 col = (1.0 - c) * bcol + c * vec3(abs(sin(uv.x-iTime)), 0.0, 0.0);\n    vec3 col = vec3(0.);\n    if (bc > c) {\n        col = c*vec3(abs(sin(uv.x)),0.,0.);\n    } else {\n        col = bc*vec3(1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ds3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 62, 62, 127], [130, 130, 162, 162, 209], [211, 211, 233, 233, 284], [286, 286, 308, 395, 494], [496, 496, 527, 527, 684], [760, 776, 805, 805, 941], [943, 943, 992, 992, 1046], [1048, 1048, 1105, 1155, 2605]], "test": "valid"}
{"id": "7dSGRw", "name": "Gyroid Marching", "author": "kithy", "description": "gyroid marching", "tags": ["raymarching", "gyroid", "fisheyecamera"], "likes": 9, "viewed": 124, "published": "Public", "date": "1617114687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MAX_DIST 64.0\n#define EPS 0.0001\n\nmat2 Rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-0.9;\n}\n\nfloat sdGyroid(vec3 p,float scale,float tickness){\n\tp*=scale;\n\treturn abs(dot(sin(p),cos(p.zxy))-1.0)/scale-tickness;\n}\n\nfloat GetDist(vec3 p){\n\tp=mod(p,2.0)-1.0;\n\n\tp.xy*=Rot(iTime);\n\tp.yz*=Rot(iTime);\n\n\tfloat sphere=sdSphere(p);\n\tfloat gyroid=sdGyroid(p,8.0-sin(iTime),0.09);\n\tfloat d=max(sphere,gyroid);\n\n\treturn d;\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n\tfloat dO=0.0;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tvec3 p=ro+rd*dO;\n\t\tfloat dS=GetDist(p);\n\t\tdO+=dS;\n\t\tif(dS<EPS)break;\n\t}\n\treturn dO;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d=GetDist(p);\n\tvec2 e=vec2(EPS,0.0);\n\n\tvec3 n=d-vec3(\n\t\tGetDist(p-e.xyy),\n\t\tGetDist(p-e.yxy),\n\t\tGetDist(p-e.yyx));\n\treturn normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv,vec3 p,vec3 l,float z){\n\tvec3 f=normalize(l-p);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=f*z;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 d=normalize(i);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,-iTime);\n\t//vec3 rd=GetRayDir(uv,ro,vec3(0.0),1.0);\n\n\tvec3 rd=normalize(vec3(uv,(1.0-dot(uv,uv)*0.5)*0.5));//fish eye\n\n\trd.xy*=Rot(iTime*0.5);\n\trd.yz*=Rot(iTime*0.5);\n\n\tvec3 col=vec3(0.0);\n\tfloat d=RayMarch(ro,rd);\n\tvec3 n;\n\n\tif(d<MAX_DIST){\n\t\tvec3 p=ro+rd*d;\n\t\tn=GetNormal(p);\n\t\tvec3 r=reflect(rd,n);\n\t\t\n\t}\n\t\n\tfragColor=vec4(n*0.5+0.5,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 81, 81, 141], [143, 143, 166, 166, 191], [193, 193, 243, 243, 312], [314, 314, 336, 336, 512], [514, 514, 546, 546, 681], [683, 683, 706, 706, 852], [854, 854, 900, 900, 1064], [1066, 1066, 1119, 1119, 1541]], "test": "valid"}
{"id": "7dsGWN", "name": "Simple Raymarcher by me", "author": "Insidious_Scripter", "description": "A 3d shader... Working on adding keyboard input. PLS HELPPPPP!!!!!!!!!!!!! lol", "tags": ["3d"], "likes": 1, "viewed": 41, "published": "Public", "date": "1616457690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nbool KeyPressed(int KEY){\n\n    return texelFetch(iChannel0, ivec2(KEY, 0), 0).x > 0.5;\n}\n\n//SHAPES\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t * ab;\n    return length(p - c) - r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e + i;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n\n    float x = length(p.xz) - r.x;\n    return length (vec2(x, p.y)) - r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n\n    return length(max(abs(p) - s, 0.));\n}\n\nfloat GetDist(vec3 p) {\n    \n    float size = cos(sin(iTime));\n    vec4 s = vec4(-1.5, 1., 10., size * .7);\n    \n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    float cd = sdCapsule(p, vec3(.5, 1, 7), vec3(.5, 2, 7), size / 2.);\n    float td = sdTorus(p - vec3(3, .5, 6), vec2 (size, size / 3.));\n    float bd = dBox(p - vec3(-3, .5, 6), vec3(size / 2.));\n    float cyld = sdCylinder(p, vec3(-5, 1, 7), vec3(-5, 2, 6.5), size / 2.);\n    \n    float d = min(cd, planeDist);\n    d = min(d, td);\n    d = min(d, bd);\n    d = min(d, sphereDist);\n    d = min(d, cyld);\n    \n    return d;\n}\n//LOOPING\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n      vec3 p = ro + rd * dO;\n      float dS = GetDist (p);\n      dO += dS;\n      if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n//LIGHTING\nfloat GetLight(vec3 p){\n    \n    vec3 lightPos = vec3(0, 6, 5);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n * SURF_DIST * 2.1, l);\n    if(d < length(lightPos - p)) dif *= .1;\n    return dif;\n\n}\n\n//FINAL IMAGE/CAMERA SETTINGS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    float ry;\n    float rx;\n    \n    vec4 m = iMouse / iResolution.x;\n    vec2 rot;\n    rx = m.x - .45 + uv.x / 3.;\n    ry = m.y - .25 + uv.y / 3.;\n\n\n    float sz;\n    float sx;\n    if(KeyPressed(38))\n    {\n        sz += 1.;\n    }\n    else if(KeyPressed(40))\n    {\n        sz -= 1.;\n    }\n    else sz = sz;\n    if(KeyPressed(39))\n    {\n        sx += 1.;\n    }\n    else if(KeyPressed(37))\n    {\n        sx -= 1.;\n    }\n        \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(sx, 2, sz);\n    vec3 rd = normalize(vec3(uv.x - rx, uv.y - ry, .8));\n    \n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 92, 92, 155], [157, 166, 215, 215, 392], [394, 394, 444, 444, 780], [782, 782, 812, 812, 889], [891, 891, 918, 918, 961], [963, 963, 986, 986, 1586], [1587, 1597, 1631, 1631, 1843], [1845, 1845, 1869, 1869, 2072], [2073, 2084, 2107, 2107, 2423], [2425, 2455, 2512, 2512, 3285]], "test": "error"}
{"id": "7dsGWS", "name": "test-101", "author": "tangyuan", "description": "test", "tags": ["img"], "likes": 2, "viewed": 55, "published": "Public", "date": "1616491200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define STARFIELD_LAYERS_COUNT 12.0\n\nfloat PI = 3.1415;\nfloat MIN_DIVIDE = 64.0;\nfloat MAX_DIVIDE = 0.01;\n\nmat2 Rotate(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flaresize, float rotAngle, float randomN) {\n    float d = length(uv);\n\n    float starcore = 0.05/d;\n    uv *= Rotate(-2.0 * PI * rotAngle);\n    float flareMax = 1.0;\n\n    float starflares = max(0.0, flareMax - abs(uv.x * uv.y * 3000.0));\n    starcore += starflares * flaresize;\n    uv *= Rotate(PI * 0.25);\n\n    starflares = max(0.0, flareMax - abs(uv.x * uv.y * 3000.0));\n    starcore += starflares * 0.3 * flaresize;\n    starcore *= smoothstep(1.0, 0.05, d);\n\n    return starcore;\n}\n\nfloat PseudoRandomizer(vec2 p) {\n    p = fract(p*vec2(123.45, 345.67));\n    p += dot(p, p+45.32);\n\n    return (fract(p.x * p.y));\n}\n\nvec3 StarFieldLayer(vec2 uv, float rotAngle) {\n    vec3 col = vec3(0);\n    vec2 gv = fract(uv) -0.5;\n    vec2 id = floor(uv);\n\n    float deltaTimeTwinkle = iTime * 0.35;\n\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 offset = vec2(x, y);\n\n            float randomN = PseudoRandomizer(id + offset);\n            float randoX = randomN - 0.5;\n            float randoY = fract(randomN * 45.0) - 0.5;\n            vec2 randomPosition = gv - offset - vec2(randoX, randoY);\n\n            float size = fract(randomN * 1356.33);\n            float flareSwitch = smoothstep(0.9, 1.0, size);\n\n            float star = Star(randomPosition, flareSwitch, rotAngle, randomN);\n\n            float randomStarColorSeed = fract(randomN * 2150.0) * (3.0 * PI) * deltaTimeTwinkle;\n            vec3 color = sin(vec3(0.7, 0.3, 0.9) * randomStarColorSeed);\n\n            color = color * (0.4 * sin(deltaTimeTwinkle)) + 0.6;\n\n            color = color * vec3(1, 0.1,  0.9 + size);\n            float dimByDensity = 15.0/STARFIELD_LAYERS_COUNT;\n            col += star * size * color * dimByDensity;\n         }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n\n    float deltaTime = iTime * 0.01;\n    vec3 col = vec3(0.0);\n    float rotAngle = deltaTime * 0.09;\n\n    for (float i=0.0; i < 1.0; i += (1.0/STARFIELD_LAYERS_COUNT)) {\n        float layerDepth = fract(i + deltaTime);\n        float layerScale = mix(MIN_DIVIDE,MAX_DIVIDE,layerDepth);\n        float layerFader = layerDepth * smoothstep(0.1, 1.1, layerDepth);\n        float layerOffset = i * (3430.00 + fract(i));\n        mat2 layerRot = Rotate(rotAngle * i * -10.0);\n        uv *= layerRot;\n        vec2 starfieldUv = uv * layerScale + layerOffset;\n        col += StarFieldLayer(starfieldUv, rotAngle) * layerFader;\n    }\n\n    fragColor += vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 135, 135, 219], [221, 221, 290, 290, 731], [733, 733, 765, 765, 864], [866, 866, 912, 912, 2015], [2017, 2017, 2074, 2124, 2864]], "test": "error"}
{"id": "7dX3Dj", "name": "GridX6", "author": "Del", "description": "6 simple drop in grid distance functions - click a grid to show it as full screen\nHEX original  - https://www.shadertoy.com/view/lldfWH\nTRI original - https://www.shadertoy.com/view/4dKXR3\nOCT original - https://www.shadertoy.com/view/3tGBWV", "tags": ["grid", "square", "diamond", "distance", "brick", "hex", "tri", "octagon"], "likes": 12, "viewed": 272, "published": "Public API", "date": "1616535997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple Hex, Tri, Square, Ocatagonal, Diamond and Brick grids - (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 23/03/2021\n\n// All 6 Grid functions return the same:\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    uv += 0.5;\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\n// simple diamond grid equiv\nvec4 DiamondGrid(vec2 uv, out vec2 id)\n{\n    uv = uv* mat2(1,-1,1,1);\n    return(SquareGrid(uv,id));\n}\n\n// simple brick grid equiv\nvec4 BrickGrid(vec2 uv, out vec2 id)\n{\n    vec2 pos = uv * vec2(1.0,2.0);\n    if(fract(uv.y)>0.5)\n        pos.x += 0.5;\n    id = floor(pos);\n    id.y *= 0.5;\n    pos = fract(pos);\n    vec2 uv2 = fract (pos)-0.5;\n    uv2.y *= 0.5;\n    pos=abs(fract (pos + 0.5) - 0.5);\n    float d = min(pos.x,pos.y*0.5);\n    return vec4(abs(d),length(uv2),uv2);\n}\n\n// Shanes ocatagonal-diamond grid equiv - https://www.shadertoy.com/view/3tGBWV \nvec4 OcatagonalGrid(vec2 uv, out vec2 id)\n{\n    vec2 guv;\n    vec2 p = uv - .5;\n    id = floor(p) + .5;\n    p -= id;\n    float d = abs(p.x) + abs(p.y) - (1. - sqrt(2.)/2.);\n    if(d<.0)\n    {\n        // inside a diamond\n        guv = fract(p-0.5)-0.5;\n        id += .5;\n    }\n    else\n    {\n        // inside an octagon\n        guv = fract(p)-0.5;\n        p = uv;\n        id = floor(p) + .5;\n        p -= id;\n        d = max((abs(p.x) + abs(p.y))/sqrt(2.), max(abs(p.x), abs(p.y))) - .5;\n    }\n    return vec4(abs(d), length(guv), guv);\n}\n\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n// Demo 6xGrids or Let the user select a grid with mouse...\nfloat SelectGrid(vec2 xxyy)\n{\n    float gridtype = 0.5;\n    vec2 mx = ((iMouse.xy-.5*iResolution.xy) / iResolution.xy)+0.5;\n    if (iMouse.z>0.5)\n        xxyy=mx;\n    if (xxyy.x>0.66)\n        gridtype=2.5;\n    else if (xxyy.x>0.33)\n        gridtype = 1.5;\n    if (xxyy.y<0.5)\n        gridtype+=3.0;\n    return gridtype;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n    float yy = ((fragCoord.y-.5*iResolution.y) / iResolution.x)+0.5;\n\n    // dirty grid switching\n    vec2 id;\n    vec4 h;\n    float zoom = 8.0;\n    if (iMouse.z>0.5)\n        zoom += sin(t);\n    float gridtype = SelectGrid(vec2(xx,yy));\n    if (gridtype>= 5.0)\n        h = BrickGrid(uv*zoom, id);\n    else if (gridtype>= 4.0)\n        h = DiamondGrid(uv*zoom, id);\n    else if (gridtype>= 3.0)\n        h = OcatagonalGrid(uv*zoom, id);\n    else if (gridtype>= 2.0)\n        h = SquareGrid(uv*zoom, id);\n    else if (gridtype>=1.0)\n        h = HexGrid(uv*zoom, id);\n    else\n        h = TriGrid(uv*zoom, id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol1 = vec3(0.35,0.15,0.2);\n    vec3 shapecol2 = vec3(0.9,0.9,0.45);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 33.5\n    float blend = pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    float cm = 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n\n    vec3 shapecol = mix(shapecol1,shapecol2,blend)*cm;\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre\n\n    if (iMouse.z<0.5)\n    {\n        // add some red divider lines\n        float dd = max( step(abs(xx-0.33),0.0025), step(abs(xx-0.66),0.0025));\n        dd = max(dd,step(abs(yy-0.5),0.0025));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n    }\n\n    //finalcol = vec3(h.x,h.x,h.x); // just show cell edge distance\n    //finalcol = vec3(h.zw,0.0);    // just show cell uv\n    //finalcol = vec3(h.y,h.y,h.y); // just show cell centre distance\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 375, 411, 411, 919], [921, 1134, 1170, 1170, 1728], [1730, 1758, 1797, 1797, 1996], [1998, 2027, 2067, 2067, 2129], [2131, 2158, 2196, 2196, 2504], [2506, 2587, 2630, 2630, 3125], [3128, 3128, 3170, 3170, 3211], [3213, 3273, 3302, 3302, 3594], [3596, 3596, 3653, 3653, 5746]], "test": "error"}
{"id": "7dX3Wf", "name": "Fractunnel", "author": "dirkadirkadan", "description": "A fractal in a tunnel. A frunnel. Full screen or go home.", "tags": ["fractal", "tunnel"], "likes": 4, "viewed": 58, "published": "Public", "date": "1616641913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float eps = 0.001;\nvec2 eps2 = vec2(eps);\n\nvec3 color(vec2 p) {\n    float x = atan(p.y,p.x)/4.-.57;\n    float y = mod(iTime*.2+.5/sqrt(length(p))-1.2, 1.);\n\n    float bail=100.;\n    vec2 a = vec2(x,y);\n    vec3 col = vec3(0.);\n    for (int i=0; i < 75; i++)\n    {\n        a += vec2(a.x*a.x-a.y*a.y,a.x*a.y*2.)+vec2(.123, .134);\n        float af = clamp(0., 1., length(a));\n        vec2 ac = normalize(a);\n        col = 1.*vec3(.55*ac.x+0.2*ac.y+0.3*p.x, .47*ac.y, af);\n        col += vec3(1.-length(p));\n        col = sqrt(col);\n        if (length(a) > bail)\n        {\n            col = vec3(1.);\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 col = (color(p) + \n                color(p+eps2))/2.;\n                \n    col = pow(col-.0, vec3(8.));\n                \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dX3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 69, 69, 660], [662, 662, 719, 719, 944]], "test": "valid"}
{"id": "7dXGzB", "name": "Line color", "author": "rmdms", "description": "Hope this will inspires someone", "tags": ["line", "colors", "loop"], "likes": 0, "viewed": 24, "published": "Public", "date": "1616151066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n|--------------------------------------------------------------------------\n| Rémy Dumas\n|--------------------------------------------------------------------------\n|\n| Twitter: @remsdms\n| Portfolio: remydumas.fr\n|\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/*\n|--------------------------------------------------------------------------\n| Noise\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\nfloat noise(vec2 p) {\n    p=(p);\n    return fract(sin(p.x*45.11+p.y*97.23)*878.73+733.17)*2.-1.0;\n}  \n\n/*\n|--------------------------------------------------------------------------\n| Map\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\nfloat map(vec2 p) {\n    return length(p) - 0.2;\n}\n\n\n/*\n|--------------------------------------------------------------------------\n| Main\n|--------------------------------------------------------------------------\n|\n| Sandbox and sometimes something good\n|\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 col;\n  vec3 color = vec3(1.,1.,1.);\n\n  for(float j = 0.0; j < 4.0; j++){\n      for(float i = 1.; i < 8.0; i++){\n          uv.x += uv.y * sin(iTime);\n      }\n    col[int(j)] = clamp((abs(uv.x+uv.y)), 0.1, 1.0);\n  }\n  \n\n  vec3 bg = vec3(1.,1.,1.);\n  color = mix(\n    col,\n    bg,\n    abs(sin(iTime))\n  );   \n\n  fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 446, 467, 467, 545], [549, 724, 743, 743, 773], [776, 984, 1041, 1041, 1481]], "test": "valid"}
{"id": "7sB3Rz", "name": "Fork Julia Sets with Color", "author": "webbgamers", "description": "julia sets with various constants + color\n\nuncomment the first line for hybrid distance/iteration shading", "tags": ["fractal", "julia"], "likes": 2, "viewed": 51, "published": "Public", "date": "1616820770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define DISTANCE\n\nvec2 squ(in vec2 n){\n    return vec2(n.x*n.x - n.y*n.y, 2.0*n.x*n.y);\n}\n\nvec3 hsv2rgb( vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //uv -= vec2(13.0,6.0);\n    //uv /= 19.0;\n    uv *= 1.0;\n    \n    vec2 z = uv.yx;\n    \n    float iter = 0.0;\n    \n    for (int i = 0; i<100; i++){\n        z = squ(z);\n        z += vec2(0.5+0.2*sin(iTime/5.0),0.5+0.2*cos(iTime/5.0));\n        iter++;\n        if (length(z) > 2.0) break;\n    }\n    \n    vec2 o = vec2(0.0, 0.0);\n    float xd = o.x - z.x;\n    float yd = o.y - z.y;\n    float d = sqrt(xd*xd + yd*yd);\n    \n    float c = 0.0;\n    \n    if (length(z) > 2.0) c = iter/30.0; else c = 0.0;\n\n    #ifndef DISTANCE\n    float h = iter / 100.0;\n    float v = iter < 100.0 ? 1.0 : 0.0;\n    #else\n    float h = iter < 100.0 ? log(iter/100.0) : d*20.0;\n    float v = iter < 100.0 ? d - floor(d) : 1.0;\n    #endif\n    float s = 1.0;\n    vec3 col = hsv2rgb(vec3(h, s, v));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 40, 40, 91], [93, 93, 117, 117, 286], [288, 288, 345, 395, 1289]], "test": "valid"}
{"id": "7sBGzh", "name": "quadripole 2", "author": "FabriceNeyret2", "description": "dots emit tetraequivalued fields, figured as R,G,B,Y  ( green is mouse controlled ), resulting in a quadripolar field.\n( it quickly decrease as grey with distance ) \n\nThe right way is using a 4-simplex.", "tags": ["dipole", "tripole", "quarks", "chromodynamics", "quadripole"], "likes": 7, "viewed": 213, "published": "Public API", "date": "1616933476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of tripole https://shadertoy.com/view/Ns23zR\n// variant of dipole  https://shadertoy.com/view/Nsj3zR\n\n\n#define F(P)  1./dot(P-U,P-U)       // point field\n#define CS(a) vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y,\n         M = ( 2.*iMouse.xy  - R ) / R.y,\n         P = vec2(.4,0) +.3*CS(2.*iTime);\n    vec4 f = vec4( F(vec2(0,.3)), F(M), F(vec2(0,-.3)), F(P) );\n\n#if 1 // --- the correct way: using a simplex\n    vec2 A = CS(1.9111),  // 109.5° : tetraedron vertical angle\n         j = CS(2.0944);  // 2pi/3 \n\n    mat4x3 J = mat4x3( vec3(0,0,1) ,vec3(1,0,1)*A.yyx, vec3(j,1)*A.yyx, vec3(j.x,-j.y,1)*A.yyx );\n    vec3 F;\n#else // --- the wrong way: using 2D equals angle ( because not all mutually equal ) \n    mat4x2 J = mat4x2( vec2(1,0) ,vec2(0,1), vec2(-1,0), vec2 (0,-1) );\n    vec2 F;\n#endif    \n\n    F = J * f;\n    O = .5+.5*  F * J; O += (O.a-.5)*vec4(1,1,0,0);\n    \n    f /= R.y;\n    O =  max( O, max( max( f.x, f.y ),  max( f.z , f.w ) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 200, 238, 238, 1038]], "test": "valid"}
{"id": "7sBGzR", "name": "Grid Lines 2D", "author": "lumic", "description": "Simple grid shader with major/minor lines.", "tags": ["2d", "grid"], "likes": 2, "viewed": 215, "published": "Public API", "date": "1616809070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAJOR_INTERVAL 4.0\n#define INTERVAL_DIVISIONS 4.0\n\n#define MAJOR_INTENSITY 0.9\n#define MINOR_INTENSITY 0.3\n\n#define PI 3.141592653589793238f\n\nfloat grid(float x) {\n  // TODO make line width zoom-independent\n  float major = smoothstep(0.999, 1.0, cos(x * (2.0 * PI) / MAJOR_INTERVAL)) * MAJOR_INTENSITY;\n  float minor = smoothstep(0.995, 1.0, cos(x * (2.0 * PI) * INTERVAL_DIVISIONS / MAJOR_INTERVAL)) * MINOR_INTENSITY;\n  return max(major, minor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Vertically normalized pixel coordinates (from 0 to 1 on vertical only)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Zoom out\n    uv =  uv * (12.0 + 4.0 * cos(iTime));\n\n    vec3 col = vec3(0.2);\n    \n    float xCol = grid(uv.x);\n    float yCol = grid(uv.y);\n    \n    col = col + max(xCol, yCol);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 171, 214, 457], [459, 459, 516, 594, 882]], "test": "valid"}
{"id": "7sf3R7", "name": "Spiral Pie", "author": "bignobody", "description": "Tomorrow is Pi Day, so here's something pretty with Pi.", "tags": ["pi", "spirals"], "likes": 4, "viewed": 133, "published": "Public", "date": "1615687072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define particles 80.0\n#define PI 3.14159\n\n\nfloat circ(vec2 uv, float r)\n{\n    return smoothstep(length(uv)-r, length(uv)-r+0.001+(abs(sin(iTime*0.5))*0.001) , 0.0001);\n}\n\nfloat ring(vec2 uv, float r, float t, float w)\n{\n    return circ(uv,r)-circ(uv,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 * iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float t = iTime * (0.01 + (mouse.x*0.001));\n    float ct = iTime * 0.8;\n    vec3 col = vec3(ring(uv,0.5,0.49,0.0001));\n    const float incr = PI/particles;\n    for (float i = particles; i > 0.0; i -= incr)\n    {\n        vec2 bv = uv+(vec2(cos(t+i),sin(t+i)) * cos(t*i)*0.49);\n        bv *= uv;\n        col += circ(bv,0.001 + mouse.y*0.001);\n    }\n    vec3 tint = vec3(0.12 * abs(sin(ct * 0.2)), 0.09 * abs(sin(ct * 0.16)), 0.18 * abs(sin(ct * 0.18)));\n    fragColor = vec4(pow(tint*col,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sf3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 74, 74, 170], [172, 172, 220, 220, 256], [258, 258, 315, 315, 937]], "test": "valid"}
{"id": "7sf3z2", "name": "Fluid colors", "author": "rmdms", "description": "Hope this will inspires someone", "tags": ["colors", "fluid"], "likes": 12, "viewed": 228, "published": "Public", "date": "1616259975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n|--------------------------------------------------------------------------\n| Rémy Dumas\n|--------------------------------------------------------------------------\n|\n| Twitter: @remsdms\n| Portfolio: remydumas.fr\n|\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif  \n\n/*\n|--------------------------------------------------------------------------\n| Map\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\nfloat map(vec2 p) {\n    return length(p) - 0.2;\n}\n\n\n/*\n|--------------------------------------------------------------------------\n| Main\n|--------------------------------------------------------------------------\n|\n| Sandbox and sometimes something good\n|\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 col;\n  vec3 color = vec3(1.,1.,1.);\n\n  for(float j = 0.0; j < 4.0; j++){\n      for(float i = 1.; i < 8.0; i++){\n          uv.x += (1.0 * (0.2 / (i + j) * sin(i * atan(iTime) * 2.0 * uv.y + (iTime * 0.1) + i * j)));\n          uv.y+= (1.0 * (1.0 / (i + j) * cos(i * 0.6 * uv.x + (iTime * 0.25) + i * j)));\n      }\n      col[int(j)] = -1.0 * (uv.x * uv.y);\n  }\n  \n\n  vec3 bg = vec3(1.,1.,1.);\n  color = mix(\n    col,\n    bg,\n    1.0-smoothstep(0.0,abs(sin(iTime*0.05)*3.0),map(uv))\n  );   \n\n  fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sf3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 446, 465, 465, 495], [498, 707, 764, 764, 1385]], "test": "valid"}
{"id": "7sj3zw", "name": "Mandelbox crystal", "author": "mrange", "description": "License CC0: Mandelbox crystal\nWas reminded by some great additions lately that refraction is pretty cool to play around with\n", "tags": ["3d", "raymarch", "mandelbox"], "likes": 13, "viewed": 333, "published": "Public API", "date": "1617180925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Mandelbox crystal\n//  Was reminded by some great additions lately that refraction is pretty\n//  cool to play around with\n\n// Uncomment for a different \"skybox\"\n//#define SKY_VARIANT\n\n#define TOLERANCE         0.0001\n#define MAX_RAY_LENGTH    8.0\n#define MAX_RAY_MARCHES   100\n#define TIME              iTime\n#define RESOLUTION        iResolution\n// SABS by ollij\n#define LESS(a,b,c)       mix(a,b,step(0.,c))\n#define SABS(x,k)         LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n\n#define PERIOD            30.0\n#define FADE              3.0\n#define TIMEPERIOD        mod(TIME,PERIOD)\n#define NPERIOD           floor(TIME/PERIOD)\n#define PSIN(x)           (0.5 + 0.5*sin(x))\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n#ifdef SKY_VARIANT\n#define SKYCOLOR(ro, rd)  skyColor1(ro, rd)\n#else\n#define SKYCOLOR(ro, rd)  skyColor0(ro, rd)\n#endif\n\nconst float fixed_radius2 = 1.8;\nconst float min_radius2   = 0.5;\nconst vec4  folding_limit = vec4(1.0);\nconst float scale         = -2.9-0.2;\nconst mat2  rot0          = ROT(0.0);\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst float boundingSphere= 4.0;\nconst float dfZoom        = 1.0/8.0;\nconst vec3  glowCol       = vec3(3.0, 2.0, 1.);\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nfloat g_rand              = 0.5;\nmat2  g_rotb              = rot0;\nmat2  g_rotc              = rot0;\nmat2  g_rotd              = rot0;\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat hash(float co) {\n  co += 6.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's smooth min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec4 pmin(vec4 a, vec4 b, vec4 k) {\n  vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's box\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray sphere density\nfloat raySphereDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\n// From stackoverflow\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// IQ's ray sphere 4 intersection\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  // Perhaps IQ's ray sphere 4 supports inner intersect but I couldn't get it to work\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\n// IQ's ray plane intersection\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// Based on EvilRyu's Mandelbox\nvoid sphere_fold(inout vec4 z, inout float dz) {\n  float r2 = dot(z, z);\n    \n  float t1 = (fixed_radius2 / min_radius2);\n  float t2 = (fixed_radius2 / r2);\n\n  if (r2 < min_radius2) {\n    z  *= t1;\n    dz *= t1;\n  } else if (r2 < fixed_radius2) {\n    z  *= t2;\n    dz *= t2;\n  }\n}\n\nvoid box_fold(float k, inout vec4 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));\n  z = zz * 2.0 - z;\n}\n\nfloat mb(vec4 z) {\n  float rand = g_rand;\n  float off = iTime*0.25;\n  vec4 offset = z;\n  float dr = 1.0;\n  float d = 1E6;\n  float k = mix(0.05, 0.25, fract(37.0*rand));\n  for(int n = 0; n < 4; ++n) {\n    box_fold(k/dr, z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    float dd = min(d, (length(z) - 2.5)/abs(dr));\n    if (n < 2) d = dd;\n  }\n\n  float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);\n  return fract(17.0*rand) > 0.5 ? pmin(d0, d, 0.05) : d0;\n}\n\nfloat df(vec3 p) {\n  const float s = dfZoom;\n  float rand = g_rand;\n\n  p /= s;\n\n  float dbs = sphere(p, boundingSphere);\n//  if (dbs > 0.5) return dbs;\n\n  float a = fract(3.0*rand);\n  vec4 pp = vec4(p.x, p.y, p.z, 2.0*a*a);\n\n  pp.xw *= g_rotb;\n  pp.yw *= g_rotc;\n  pp.zw *= g_rotd;\n  \n  float dmb = mb(pp);\n  \n  float d = dmb;\n  d = max(d, dbs);\n  \n  return d*s;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render0(vec3 ro, vec3 rd, out float sd, out float td) {\n  int iter = 0;\n  const vec4 bs = vec4(vec3(0.0), boundingSphere*dfZoom);\n  const vec4 gs = vec4(vec3(0.0), boundingSphere*dfZoom*0.66);\n  vec2 tbs = raySphere(ro, rd, bs);\n  if (tbs == vec2(miss)) {\n    td = miss;\n    return vec3(0.0);\n  }\n  \n  float t = rayMarch(ro, rd, iter);\n  \n  sd = raySphereDensity(ro, rd, gs, t);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n\n  float h = g_rand;\n  \n  if (t < MAX_RAY_LENGTH) {\n    // Ray intersected object\n    nor       = normal(pos);\n    vec3 hsv  = (vec3(fract(h - 0.6 + 0.4+0.25*t), 1.0-ifade, 1.0));\n    color     = hsv2rgb(hsv);\n    td        = t;\n  } else {\n    // Ray intersected sky\n    td        = miss;\n    return vec3(0.0);\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n    \n  return col*ifade;\n}\n\nvec3 skyColor0(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.75));\n\n  if (tp > 0.0) {\n    // Ray intersected plane\n    vec3 pos  = ro + tp*rd;\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 col = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    float f = exp(-20.0*(max(tp-3.0, 0.0) / MAX_RAY_LENGTH));\n    return mix(final, col , f);\n  } else {\n    // Ray intersected sky\n    return final;\n  }\n}\n\nvec3 skyColor1(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.75));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.1+1.0*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 render1(vec3 ro, vec3 rd) {\n  const float eps  = 0.001;\n  vec3 ipos = ro + eps*rd;\n  vec3 ird  = rd;\n  float isd = 0.0;\n  float itd = 0.0;\n  vec3 col = vec3(0.0);\n  \n  const float scaleUp = 2.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    float rtd = miss;\n    float rsd;\n    col = scaleUp*render0(ipos, ird, rsd, rtd);\n    isd += rsd;\n    if (rtd < miss) { \n      itd += rtd; \n      break;\n    }\n    \n    float its4  = IRAYSHAPE(ipos, ird);\n    itd         += its4;\n    vec3 nipos  = ipos + ird*its4;\n    vec3 inor   = -sphere4Normal(nipos);\n    vec3 irefr  = refract(ird, inor, 1.0/refrIndex);\n    if (irefr == vec3(0.0)) {\n      ipos = nipos;\n      ird  = reflect(ird, inor);\n    } else {\n      vec3 rskyCol= SKYCOLOR(ipos, irefr);\n      col = rskyCol;\n      break;\n    }\n  }\n  float h = g_rand;\n  float t = 0.2;\n  vec3 hsv  = vec3(fract(h - 0.6 + 0.4+0.25*t), 0.3, 1);\n  vec3 glowCol = hsv2rgb(hsv);\n\n  isd = h > 0.5 ? isd : 0.0;\n  col = mix(col, 2.0*glowCol, isd);\n  \n  col *= exp(mix(-vec3(2.0, 3.0, 4.0).zyx, vec3(0.0), tanh_approx(3.0*isd))*itd);\n  \n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float rand = hash(NPERIOD);\n  g_rand = rand;\n\n  float a = fract(3.0*rand);\n  const float aa = PI/4.0;\n  const float bb = PI/4.0-aa*0.5;\n  float b = bb+aa*fract(5.0*rand);\n  float c = bb+aa*fract(7.0*rand);\n  float d = bb+aa*fract(13.0*rand);\n  g_rotb = ROT(b);\n  g_rotc = ROT(c);\n  g_rotd = ROT(d);\n\n\n  vec3 ro = 0.6*vec3(2.0, 0, 0.2)+vec3(0.0, 0.75, 0.0);\n  ro.xz *= ROT((TIME*0.05));\n  ro.yz *= ROT(sin(TIME*0.05*sqrt(0.5))*0.5);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0+0.5*tanh_approx(length(p));\n//  rdd = 2.0;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, FADE, TIMEPERIOD);\n  col *= 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEPERIOD);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [{"id": "MlfXWM", "previewfilepath": "https://soundcloud.com/serein/to-speak-of-solitude", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/serein/to-speak-of-solitude", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3zw.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[362, 1796, 1821, 1821, 1850], [1852, 1852, 1874, 1874, 1935], [1937, 1937, 1965, 1985, 2061], [2063, 2082, 2121, 2121, 2209], [2211, 2211, 2246, 2246, 2331], [2333, 2333, 2364, 2364, 2390], [2392, 2404, 2431, 2431, 2528], [2530, 2562, 2604, 2604, 2863], [2865, 2892, 2959, 2959, 3440], [3442, 3464, 3486, 3486, 3655], [3658, 3692, 3738, 3738, 4583], [4585, 4585, 4615, 4615, 4652], [4654, 4654, 4701, 4865, 5044], [5046, 5077, 5120, 5120, 5167], [5169, 5201, 5249, 5249, 5481], [5483, 5483, 5537, 5581, 5661], [5663, 5663, 5681, 5681, 6174], [6176, 6176, 6194, 6194, 6540], [6542, 6542, 6590, 6590, 6785], [6787, 6787, 6810, 6810, 7019], [7021, 7021, 7089, 7089, 7368], [7370, 7370, 7407, 7407, 7659], [7661, 7661, 7721, 7721, 8937], [8939, 8939, 8973, 8973, 9854], [9856, 9856, 9890, 9890, 10953], [10956, 10956, 10988, 10988, 12029], [12031, 12031, 12062, 12062, 13139], [13140, 13140, 13195, 13195, 14190]], "test": "error"}
{"id": "7sjGRw", "name": "mandelbrot zooming", "author": "grevel", "description": "click in different places for different colors", "tags": ["fractal", "interactive", "colors", "zoom", "animated", "animation"], "likes": 1, "viewed": 157, "published": "Public API", "date": "1617186620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat mandelbrot(vec2 c, float it)  // check if a point belongs to the mandelbrot set\n{\n    vec2 z = c;\n    float i = 0.;\n    \n    float maxDist = 0.;\n    \n    while (i < it && length(z) < 3.)\n    {\n        vec2 zn = vec2(z.x * z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z = zn;\n        \n        float dist = length(c-z);\n        \n        if(dist > maxDist) maxDist = dist;\n        \n        i++;\n    }\n    //return smoothstep(1.3, 2.7, length(z));\n    //return i/it * maxDist*.1;\n    //return i/it;\n    return maxDist*.1;\n}\n\nfloat interpolate(float a, float b, float d)\n{\n    return -(a-b)*d+a;\n}\n\nfloat map(float v, float a1, float a2, float b1, float b2)\n{\n    return (v-a1)/(a2-a1)*(b2-b1)+b1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    //uv.x = map(fragCoord.x, 0., 800., -3., 1.4);\n    //uv.y = map(fragCoord.y, 0., 450., -1.3, 1.3);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    if(iMouse.xy == vec2(0.)) mouseUV = vec2(.7);\n    \n    \n    float interpolation = 1.-pow(0.5+0.5*sin(iTime/3.), 3.); // 0-zoom out 1-zoom in\n    float zoom = .00003; // smaller = closer\n    \n    // calculate current camera position based on zoom and interpolation value\n    uv.x = map(fragCoord.x, 0., iResolution.x, interpolate(-3., -0.761574-zoom, interpolation), interpolate(1.4, -0.761574+zoom, interpolation));\n    uv.y = map(fragCoord.y, 0., iResolution.y, interpolate(-1.3, -0.0847596-zoom, interpolation), interpolate(1.3, -0.0847596+zoom, interpolation));\n    \n    float r = 1.-mandelbrot(uv, mouseUV.x*750.);\n    float g = 1.-mandelbrot(uv, mouseUV.y*300.);\n    float b = mandelbrot(uv, 10.);\n\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 88, 88, 521], [523, 523, 569, 569, 594], [596, 596, 656, 656, 696], [698, 698, 755, 755, 1669]], "test": "valid"}
{"id": "7slGDr", "name": "RM__", "author": "3t13nn3", "description": "RM", "tags": ["rm"], "likes": 0, "viewed": 27, "published": "Public", "date": "1615852830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst int reflectionCount = 2;\nconst float reflexionIntensity = 0.5;\nconst float envReflexionIntensity = 0.8;\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n\nfloat mengerSponge(vec3 p, int iteration){\n   float d = boxSDF(p, vec3(2));\n\n   float s = 1.0;\n   float da;\n   float db;\n   float dc;\n   float c;\n   for( int m=0; m<iteration; m++ )\n   {\n      vec3 a = mod(p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n\n\n      da = max(r.x,r.y);\n      db = max(r.y,r.z);\n      dc = max(r.z,r.x);\n      c = (min(da,min(db,dc))-1.0)/s;\n      \n\n      d = max(d,c); \n   }\n   return d;\n}\n\n\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nvec4 booleanUnion(vec4 pointA, vec4 pointB){\n\treturn (pointA.w <pointB.w) ? pointA : pointB;\n}\n\nfloat sdOctahedron(vec3 p, vec3 h)\n{\n    float d = 0.0;\n\n    // Get distance against pyramid's sides going through origin.\n    // Test: d = p.x * sin a + p.y * cos a\n    d = dot(vec2(max(abs(p.x), abs(p.z)), abs(p.y)), \n            vec2(h.x, h.y));\n\n    // Subtract distance to a side when at height h.z from the origin.\n    return d - h.y * h.z;\n}\nfloat sdP(vec3 p, vec3 h) // h = { sin a, cos a, height }\n{\n    float octa = sdOctahedron(p, h);\n\n    // Subtract bottom half\n    return max(octa, -p.y);\n}\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat booleanSubtraction(float pointA, float pointB){\n\treturn (-pointA >pointB) ? -pointA : pointB;\n}\n\n//Plus Z est grand, moins la figure est profonde\nfloat sdEth(in vec3 p, in float z, in float scale) {\n\n    float bot = 1.0;\n    float top = 1.0;\n    \n    mat3 extend = mat3(\n        vec3(scale,0,0),\n        vec3(0,scale,0),\n        vec3(0,0,scale)  \n    );\n    p*=extend;\n    \n    vec3 pp = p;\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.8),\n        vec3(0,0,z)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    top = sdPyramid(p, 1.0);\n    p *= rotateX(PI);\n    top = booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,sdPyramid(p, 0.5))).w *.2;\n    \n    p = pp*rotateY(PI);\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.4),\n        vec3(0,0,z/2.0)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.1205;\n    bot = sdPyramid(p, 1.0)*.4;\n    p = pp *rotateY(PI);\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.4),\n        vec3(0,0,0.01) //degree of the blank  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.12 - scale * 0.001;\n    bot = max(bot, -sdPyramid(p, 0.5)*0.6);\n    \n    /*if (z > 4.0)\n        return booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,bot)).w * .5 / scale;*/\n    \n    return booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,bot)).w /scale;\n    //return bot;\n\n}\n\n\n/*\n//Plus Z est grand, moins la figure est profonde\nfloat sdEth(in vec3 p, in float z, in float scale) {\n\n    float bot = 1.0;\n    float top = 1.0;\n    \n    mat3 extend = mat3(\n        vec3(scale,0,0),\n        vec3(0,scale,0),\n        vec3(0,0,scale)  \n    );\n    p*=extend;\n    \n    vec3 pp = p;\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.8),\n        vec3(0,0,z)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    top = sdP(p, vec3(0.5,0.25,1.0));\n    p *= rotateX(PI);\n    top = booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,sdP(p, vec3(0.5,0.5,0.5)))).w *.2;\n    \n    p = pp*rotateY(PI);\n    extend = mat3(\n        vec3(1.0 ,0,0),\n        vec3(0,1.0,0.4),\n        vec3(0,0,z/2.0)  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.1305;\n    bot = sdP(p, vec3(0.5,0.25,1.0))*.8;\n    p = pp *rotateY(PI);\n    extend = mat3(\n        vec3(1,0,0),\n        vec3(0,1,0.4),\n        vec3(0,0,0.01) //degree of the blank  \n    );\n    p*=extend;\n    p *= rotateY(PI/4.0);\n    p *= rotateX(PI);\n    p.y -= 0.12 - scale * 0.001;\n    bot = max(bot, -sdP(p, vec3(0.5,0.5,0.5))*0.8);\n    \n    \n    return booleanUnion(vec4(0.0,0.0,0.0, top),vec4(0.0,0.0,0.0,bot)).w /scale;\n    //return bot;\n\n}\n*/\n\nvec4 sceneSDF(vec3 p) {        \n    \n    vec4 ball = vec4(cos(iTime/3.0),0.3,0.2, sphereSDF(p, 0.2) - sin(p.x *8.0 + iTime*6.0) *0.02);\n    float scale = 4.0;\n    //vec4 ball = vec4(0.6,0.6,0.85,sdEth(samplePoint, 4.0, scale));\n    vec4 sponge = vec4(0.334, 0.44, 0.76, mengerSponge(p, 4));\n    \n    vec4 res = booleanUnion(ball/1.1, sponge);\n    \n    vec3 newPoint = p * rotateZ(3.14159265359) - vec3(0.0, 2.75, 0.0);\n    vec4 cone = vec4(0.8,0.9,0.7, sdCone(newPoint,vec2(1.0),1.5));\n    res = booleanUnion(res,cone);\n    \n    vec3 alias = p;\n    alias *= rotateY(-iTime/3.0);\n    alias += vec3(-8.0, -2.0*sin(iTime*0.5), -0.5);\n    //eye *= rotateZ(iTime);\n    //alias *= rotateX(iTime/3.0);\n    //alias *= rotateY(-iTime/3.0);\n    vec4 b = vec4(cos(iTime),cos(iTime*1.2),cos(iTime*1.42),sphereSDF(alias, 0.2));\n    \n    res = booleanUnion(res, b);\n    return res;\n    \n    /*\n    float scale = 1.5;\n    return vec4(0.6,0.6,0.85,sdEth(samplePoint, 4.0, scale));\n    */\n    //return vec4(0.6,0.6,0.85,sdP(samplePoint, vec3(0.5)));\n    \n}\n\n\nbool shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float maxDistance, int maxIteration, inout vec3 p, inout vec4 dist) {\n    float depth = start;\n    bool hit;\n    for (int i = 0; i < maxIteration; i++) {\n        p = eye + depth * marchingDirection;\n        dist = sceneSDF(p);\n        if (dist.w < EPSILON) {\n\t\t\thit = true;\n            break;\n        }\n        depth += dist.w;\n        if (depth >= maxDistance) {\n            hit = false;\n            break;\n        }\n    }\n    return hit;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).w - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).w,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).w - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).w,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).w - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).w\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n   \n   \n    //SHADOW\n    vec4 dist = vec4(0.0);\n    vec3 hitPosition;\n    shortestDistanceToSurface(p + N * EPSILON *2.0, L, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS, hitPosition, dist);\n\n\t\tif(dist.w<length(lightPos - p))\n\t\t\tlightIntensity *= 0.5;\n    \n    \n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(5.0,\n                          5.0,\n                          5.0);\n    \n    //vec3 light1Pos = eye - 8.0;\n                          \n    vec3 light1Intensity = vec3(0.7, 0.7, 0.7);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    /*vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);*/\n    vec3 light2Pos = eye - vec3(sin(iTime/10.0)/5.0,cos(iTime/8.0)/4.0,0.0);\n                         \n    vec3 light2Intensity = vec3(0.3, 0.3, 0.3);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    \n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 2.0*sin(iTime*0.5), -0.0);\n    //eye *= rotateZ(iTime);\n    eye *= rotateY(iTime/3.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec3 hitPosition;\n    vec4 dist;\n    \n    bool hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS, hitPosition, dist);\n    \n    vec4 res;\n    \n    if(hit){\n\n        vec3 K_a = dist.xyz;\n        vec3 K_d = K_a;\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n        vec3 s = phongIllumination(K_a, K_d, K_s, shininess, hitPosition, eye);\n        res = vec4(s,1.0);\n        vec3 n = estimateNormal(hitPosition);\n        res += vec4(texcube(iChannel0, hitPosition, n).rgb * reflexionIntensity * envReflexionIntensity,0);\n        if(reflectionCount > 0){\n            vec3 n = estimateNormal(hitPosition);\n            worldDir = normalize(reflect(worldDir,n));\n            eye = hitPosition + (worldDir * 0.01);\n            hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST * 0.5, MAX_MARCHING_STEPS / 2, hitPosition, dist);\n            if(hit) {\n                vec3 K_a = dist.xyz;\n                vec3 K_d = K_a;\n                vec3 K_s = vec3(1.0, 1.0, 1.0);\n                float shininess = 10.0;\n                vec3 s = phongIllumination(K_a, K_d, K_s, shininess, hitPosition, eye);\n\n                res = vec4(s * reflexionIntensity,1.0);\n\n                if(reflectionCount > 1){\n                    vec3 n = estimateNormal(hitPosition);\n                    worldDir = normalize(reflect(worldDir,n));\n                    eye = hitPosition + (worldDir * 0.01);\n                    hit = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST * 0.25, MAX_MARCHING_STEPS / 4, hitPosition, dist);\n                    if(hit) {\n                        vec3 K_a = dist.xyz;\n                        vec3 K_d = K_a;\n                        vec3 K_s = vec3(1.0, 1.0, 1.0);\n                        float shininess = 10.0;\n                        vec3 s = phongIllumination(K_a, K_d, K_s, shininess, hitPosition, eye);\n                        res = vec4(s * reflexionIntensity * 0.5,1.0);\n                    }\n                }\n            }\n        }\n        \n    } else {\n        \n        res = vec4(0.4,0.6,0.9,0);\n    }\n\n    \n    fragColor = res;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7slGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 309, 336, 336, 483], [485, 531, 558, 558, 705], [707, 753, 780, 780, 927], [929, 1020, 1066, 1066, 1098], [1100, 1184, 1226, 1226, 1258], [1260, 1349, 1396, 1396, 1429], [1431, 1539, 1572, 1572, 2002], [2004, 2091, 2125, 2125, 2153], [2155, 2272, 2317, 2386, 2992], [2995, 2995, 3037, 3037, 3435], [3439, 3439, 3486, 3620, 3955], [3957, 3957, 4001, 4001, 4051], [4053, 4053, 4089, 4089, 4401], [4402, 4402, 4461, 4461, 4557], [4560, 4560, 4595, 4595, 5080], [5082, 5082, 5135, 5135, 5183], [5185, 5234, 5286, 5286, 6495], [6498, 7744, 7767, 7767, 8783], [8786, 8786, 8933, 8933, 9305], [9320, 9320, 9385, 9385, 9517], [9520, 9520, 9549, 9549, 9871], [9874, 9874, 10014, 10014, 10870], [10873, 10873, 10958, 10958, 11905], [11907, 11907, 11956, 11956, 12092], [12094, 12094, 12139, 12139, 12285], [12289, 12289, 12346, 12346, 14795]], "test": "error"}
{"id": "7sS3Rw", "name": "metaballs colored", "author": "grevel", "description": "metashapes\n\nclick LMB to make them shine\n\nhttps://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nhttps://jsfiddle.net/87nw05kz/", "tags": ["blobs", "metaballs", "colors", "meta", "blob", "colored", "metashapes"], "likes": 0, "viewed": 189, "published": "Public API", "date": "1617186833", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//click LMB to make them shine\n\n\n// number of balls\n#define nBalls 15\n\n\nuint Hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nfloat r(uint seed)  // random numbers\n{\n    return float(Hash(seed)) / 4294967295.0; // 2^32-1\n}\n\nfloat interpolate(float a, float b, float d)\n{\n    return -(a-b)*d+a;\n}\n\nvec3 gradient(float c)\n{\n    vec4 cols[4];\n    \n    //                 r          g         b      position on gradient space (0 and 1 required)\n    cols[0] = vec4(255./255., 193./255., 36./255., 0.0);\n    cols[1] = vec4(182./255., 255./255., 36./255., 0.3);\n    cols[2] = vec4(255./255.,  76./255., 36./255., 0.6);\n    cols[3] = vec4(255./255., 200./255., 36./255., 1.0);\n    \n    \n    // pick two colors that are on the sides of a sample\n    int i = 0;\n    while(!(c >= cols[i].w && c <= cols[i+1].w))\n    {\n        i++;\n    }\n    \n    vec4 Bcol = cols[i];\n    vec4 Tcol = cols[i+1];\n    \n    // transform them to bottomColor-0.0 and topColor-1.0\n    c -= Bcol.w;\n    Tcol.w -= Bcol.w;\n    Bcol.w -= Bcol.w;\n\n    c /= Tcol.w;\n    Bcol.w /= Tcol.w;\n    Tcol.w /= Tcol.w;\n\n\n    // interpolate color\n    vec3 outcome;\n    outcome.x = interpolate(Bcol.x, Tcol.x, c);\n    outcome.y = interpolate(Bcol.y, Tcol.y, c);\n    outcome.z = interpolate(Bcol.z, Tcol.z, c);\n    \n    return outcome;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy + vec2(-.35, -.2)) * vec2(1.7);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float size = 1./ 0.04; // change size\n\n    uint rN = uint(4);  // seed value (change for different trajectories and colors)\n\n    float d = 0.;     // sum of 1/dist for all balls\n    vec3 col = vec3(0);\n\n    float cd[nBalls];     // 1/dist^2 for all balls \n    vec2 balls[nBalls];   // positions\n    vec3 colors[nBalls];  // colors\n    float total=0.;       // sum of cds\n    \n    for(int i = 0; i < nBalls; i++) // initialize balls\n    {\n        balls[i] = vec2(r(rN) + r(rN + uint(1))*sin(r(rN + uint(2)) + iTime*r(rN + uint(3))), r(rN + uint(4)) + r(rN + uint(5))*.6*sin(r(rN + uint(6)) + iTime*r(rN + uint(7))));\n        //colors[i] = vec3(r(rN + uint(8)), r(rN + uint(9)), r(rN + uint(10)));\n        //colors[i] /= vec3(max(colors[i].x, max(colors[i].y, colors[i].z)));\n        colors[i] = gradient(r(rN + uint(8)));\n        rN += uint(100);\n    }\n    \n\n    for(int i = 0; i < nBalls; i++) // distances for interpolation of colors\n    {\n        float dist = length(balls[i]-uv);\n        d += 1./dist * (.6+r(rN+uint(100))*.4);\n\n        if(dist == 0.) col = colors[i];\n\n        float oneover = 1./pow(dist, 4.);\n\n        cd[i] = oneover;\n        total += oneover;\n\n        rN += uint(100);\n    }\n\n    \n    //if(d > size-.5)   // no background\n    //if(d < size+1.5)  // border mode\n    //{\n        for(int i = 0; i < nBalls; i++)  // interpolation of colors based on distances\n        {\n            float ratio = cd[i] / total;\n            col.x += ratio * colors[i].x;\n            col.y += ratio * colors[i].y;\n            col.z += ratio * colors[i].z;\n        }\n    //}\n\n    \n    \n    if(iMouse.z > .5)   // coloring modes\n        col = vec3(smoothstep(size-11., size, d), smoothstep(size-6., size, d), smoothstep(size-30., size, d));\n    else\n        col *= vec3(.3+.73*smoothstep(size-0.5, size, d));\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 73, 92, 92, 232], [234, 234, 273, 273, 330], [332, 332, 378, 378, 403], [405, 405, 429, 429, 1392], [1395, 1395, 1452, 1452, 3411]], "test": "valid"}
{"id": "7ss3RX", "name": "wiggle functions", "author": "pronce", "description": "just a few nice handy wiggle functions for animation and procedural content creation. ", "tags": ["animation", "wiggle", "toolbox"], "likes": 4, "viewed": 95, "published": "Public", "date": "1616401052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*  \n    hey, just adding a few nice wiggle operators that come in super handy for animating\n    or generating stuff in shaders.  \n    \n    i really love adding toolbox functions, stay tuned for more!\n    \n    the wiggle expression is one of the most common used expression in motion graphics\n    and just produces a nice and stable curve over time without the need to integrate.\n    \n    there are 3 functions:\n    \n    green: simple wiggle function with hard edges\n      red: smooth version of the same curve\n     blue: a wiggle version with details in the curve\n     \n     parameters: \n         t is the time (basically, can be any sampling point)\n         frequency defines how often it oscillates\n         [octaves] adds details\n         \n         the amplitude is just a simple multiplication of the output value!\n         \n     the result of the function(of t) just results in a perfectly stable wiggle value\n     that you can use to animate objects for example, camera shakes, and so on\n     \n*/\n\n// pseudorandom canonical function from 'On generating random numbers, \n// with help of y= [(a+x)sin(bx)] mod 1\", W.J.J. Rey, 22nd European\n// Meeting of Statisticians and the 7th Vilnius Conference on Probability\n// Theory and Mathematical Statistics, August 1998'\n// aka the random generator everyone uses :)\n#define R(x) fract(sin(dot(x,vec2(12.9898,78.233))) * 43758.5453)\n#define PI 3.14159265\n\n// linear wiggle function\nfloat wiggle(float t, float frequency, float seed)\n{\n    t *= frequency;\n    float a = R(vec2(floor(t), seed)) * 2.0 - 1.0;\n    float b = R(vec2(ceil(t), seed)) * 2.0 - 1.0;\n    \n    t -= floor(t);\n    \n    return mix(a, b, t);\n}\n\n// linear wiggle function that allows details by increasing the octaves parameter\nfloat wiggle(float t, float frequency, int octaves, float seed)\n{\n    float w = 0.0;\n    \n    for(int i = 1; i <= octaves; i++)\n    {\n        float f = float(i * i);\n        w += wiggle(t, frequency * f, seed) / f;\n    }\n    \n    return w;\n}\n\n// smooth wiggle version, super handy!\nfloat smoothwiggle(float t, float frequency, float seed)\n{\n    t *= frequency;\n    float a = R(vec2(floor(t), seed)) * 2.0 - 1.0;\n    float b = R(vec2(ceil(t), seed)) * 2.0 - 1.0;\n    \n    t -= floor(t);\n    \n    return mix(a, b, sin(t * t * PI / 2.0)); // fake smooth blend\n}\n\nvec3 zeroline(vec2 uv, float h)\n{\n    return vec3(smoothstep(2.0 / iResolution.y, 0.0, abs(uv.y - h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // quick drawing test\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    // we sample the wiggle function at this point\n    float sampleTime = uv.x + iTime;\n    \n    // a constant value can be passed to the wiggle functions to produce unique looks\n    const float seed = 128.0;\n    \n    // the oscillation of each wiggle function can be controlled with the frequency\n    const float frequency = 10.0;\n    \n    // calculate the hard curve, this is just linear and has a rough appearance\n    vec2 hard = uv;\n    hard.y += wiggle(sampleTime, frequency, seed) * 0.1;\n    hard.y -= 0.35; // drawing offset\n    col.y = smoothstep(2.0 / iResolution.y, 0.0, abs(hard.y));\n        \n    // draw the smooth curve, this does some cheap smooth linear interpolation\n    vec2 soft = uv;\n    soft.y += smoothwiggle(sampleTime, frequency, seed) * 0.1;\n    soft.y -= 0.; // drawing offset\n    col.x = smoothstep(2.0 / iResolution.y, 0.0, abs(soft.y));\n        \n    // draw the hard curve with octaves (combination of multiple wiggles)\n    vec2 hard_oct = uv;\n    hard_oct.y += wiggle(sampleTime, frequency, 5, seed) * 0.1;\n    hard_oct.y += 0.35; // drawing offset\n    col.z = smoothstep(2.0 / iResolution.y, 0.0, abs(hard_oct.y));\n    \n    \n    // a few guides\n    col += zeroline(uv, 0.45) * 0.15;\n    col += zeroline(uv, 0.35) * 0.3;\n    col += zeroline(uv, 0.25) * 0.15;\n     \n    col += zeroline(uv, 0.1) * 0.15;\n    col += zeroline(uv, 0.0) * 0.3;\n    col += zeroline(uv, -0.1) * 0.15;\n    \n    col += zeroline(uv, -0.45) * 0.15;\n    col += zeroline(uv, -0.35) * 0.3;\n    col += zeroline(uv, -0.25) * 0.15;\n  \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ss3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1405, 1431, 1483, 1483, 1660], [1662, 1744, 1809, 1809, 1985], [1987, 2026, 2084, 2084, 2302], [2304, 2304, 2337, 2337, 2409], [2411, 2411, 2468, 2494, 4158]], "test": "valid"}
{"id": "7ss3Wj", "name": "Welp", "author": "Zeph", "description": "TP pas fini", "tags": ["moche"], "likes": 3, "viewed": 51, "published": "Public", "date": "1616591274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sunPosition;\n// clouds function\nvec3 computeClouds(vec2 uv) {\nif (uv.y < 0.5) { // if we are under the half part of the screen return black\nreturn vec3(0.0, 0.0, 0.0);\n}\nelse {\n// compute ray direction\nvec3 rd = normalize(vec3(uv*2.-1.,1.));\n// add two layers of cloud\nvec3 color = texture(iChannel0, rd.xz*.1/rd.y+iTime*.02).rrr;\ncolor += texture(iChannel0, rd.xz*.05/rd.y-iTime*.03).rrr;\nreturn color*.5;\n}\n}\n\nvec3 sky(vec2 uv){\n    vec3 col = vec3(1.1,1.1,1.1);\n    vec3 blue = vec3(0.0,0.3,0.75);\n    vec3 orange = vec3(1.0,0.85,0.1);\n    float norme = distance(uv,sunPosition);\n    vec3 noir = vec3(0.0,0.0,0.0);\n    vec3 nuit = mix(noir,blue,(0.5-norme)*6.0);\n    vec3 res = mix( mix(computeClouds(uv),nuit,uv.y).rgb, orange, (0.5-norme)*1.45);\n    \n    return res;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunPosition = vec2(cos(-iTime)/2.5 + 0.5,sin(-iTime)/2.5 +0.35);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvBis = vec2(uv.x,1.0-uv.y);\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 col = sky(uv);\n    \n    \n    if(uv.y > 0.4)fragColor = vec4(col,1.0);\n    \n    if(uv.y < 0.4) fragColor = vec4(sky(uvBis),1.0);\n    if(uv.y == 0.4) fragColor= vec4(mix(color,color,uv.x),1.0);\n    \n    \n    \n}\n", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ss3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 37, 66, 66, 415], [417, 417, 435, 435, 778], [783, 783, 840, 840, 1250]], "test": "error"}
{"id": "7ssGDj", "name": "Fork Cube lines doomedclou 672 W", "author": "doomedcloud", "description": "Layers sorted and support transparency and self-intersection-transparency (include reflections)\nAntialiasing is only dFd. (with some dFd fixes around edges)\n\ncineshader support [url]https://cineshader.com/view/NslGRN[/url]", "tags": ["3d", "intersection", "art", "cineshader"], "likes": 1, "viewed": 91, "published": "Public", "date": "1616598710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Danil (2021+) https://twitter.com/AruGL\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/NslGRN\n\n// using iq's intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n// using https://www.shadertoy.com/view/ltKBzG\n// using https://www.shadertoy.com/view/tsVXzh\n// using https://www.shadertoy.com/view/WlffDn\n// using https://www.shadertoy.com/view/WslGz4\n\n// uncomment for Animation 1\n//#define ANIM\n\n#define tshift 53.\n\n#define curvature 0.5\n// uncomment for Animation 2\n//#define curvature (0.001+1.5-1.5*smoothstep(0.,8.5,mod((iTime+tshift)*0.44,20.))*(1.-smoothstep(10.,18.5,mod((iTime+tshift)*0.44,20.))))\n\n// uncommenting curvature(to not const above) make compilation on Angle 15+ sec\n\n// reflect back side\n//#define backside_refl\n\n// Camera with mouse\n//#define MOUSE_control\n\n// min(iFrame,0) does not speedup compilation in ANGLE\n#define ANGLE_loops 0\n\n\n// this shader discover Nvidia bug with arrays https://www.shadertoy.com/view/NslGR4\n// use DEBUG with BUG, BUG trigger that bug and one layer will be white on Nvidia in OpenGL\n//#define DEBUG\n//#define BUG\n\n#define FDIST 0.3\n#define PI 3.1415926\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.5\n#define BOXDIMS vec3(0.75, 0.75, 1.25)\n\n#define IOR 1.33\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nvec3 fcos(vec3 x) {\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);\n}\n\n// rename to fcos\nvec3 fcos2( vec3 x){return cos(x);}\n\nvec3 getColor(vec3 p)\n{\n    // dFd fix, dFd broken on borders, but it fix only top level dFd, self intersection has border\n    if (length(p) > 0.99)return vec3(0.);\n    p = abs(p);\n\n    p *= 01.25;\n    p = 0.5 * p / dot(p, p);\n#ifdef ANIM\n    p+=0.2*iTime;\n#endif\n\n    float t = (0.13) * length(p);\n    vec3 col = vec3(0.3, 0.4, 0.5);\n    col += 0.12 * fcos(6.28318 * t * 1.0 + vec3(0.0, 0.8, 1.1));\n    col += 0.11 * fcos(6.28318 * t * 3.1 + vec3(0.3, 0.4, 0.1));\n    col += 0.10 * fcos(6.28318 * t * 5.1 + vec3(0.1, 0.7, 1.1));\n    col += 0.10 * fcos(6.28318 * t * 17.1 + vec3(0.2, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 31.1 + vec3(0.1, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 65.1 + vec3(0.0, 0.5, 0.8));\n    col += 0.10 * fcos(6.28318 * t * 115.1 + vec3(0.1, 0.4, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 265.1 + vec3(1.1, 1.4, 2.7));\n    col = clamp(col, 0., 1.);\n \n    return col;\n}\n\nvoid calcColor(vec3 ro, vec3 rd, vec3 nor, float d, float len, int idx, bool si, float td, out vec4 colx,\n               out vec4 colsi)\n{\n\n    vec3 pos = (ro + rd * d);\n#ifdef DEBUG\n    float a = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n    if (idx == 0)colx = vec4(1., 0., 0., a);\n    if (idx == 1)colx = vec4(0., 1., 0., a);\n    if (idx == 2)colx = vec4(0., 0., 1., a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n        if (idx == 0)colsi = vec4(1., 0., 0., ta);\n        if (idx == 1)colsi = vec4(0., 1., 0., ta);\n        if (idx == 2)colsi = vec4(0., 0., 1., ta);\n    }\n#else\n    float a = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n    //a=1.;\n    vec3 col = getColor(pos);\n    colx = vec4(col, a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n        //ta=1.;\n        col = getColor(pos);\n        colsi = vec4(col, ta);\n    }\n#endif\n}\n\n// xSI is self intersect data, fade to fix dFd on edges\nbool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,\n                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)\n{\n    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);\n    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);\n    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);\n    vec3 vd = vec3(ps.xy, ph.x);\n    t = -1.;\n    tsi = -1.;\n    si = false;\n\n    float tmp = 1.0 / (vb.y * vc.x);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = va.z * tmp;\n    float e = 0.0;\n    float f = 0.0;\n    float g = (vc.z * vb.y - vd.y * va.z) * tmp;\n    float h = (vb.z * vc.x - va.z * vd.x) * tmp;\n    float i = -1.0;\n    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;\n\n    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);\n    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +\n              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);\n    float r =\n        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;\n\n    if (abs(p) < 0.000001)\n    {\n        float tt = -r / q;\n        if (tt <= 0.)\n            return false;\n        t = tt;\n        // normal\n\n        vec3 pos = ro + t * rd;\n        vec3 grad =\n            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n        norm = -normalize(grad);\n        return true;\n    }\n    else\n    {\n        float sq = q * q - 4.0 * p * r;\n        if (sq < 0.0)\n        {\n            return false;\n        }\n        else\n        {\n            float s = sqrt(sq);\n            float t0 = (-q + s) / (2.0 * p);\n            float t1 = (-q - s) / (2.0 * p);\n            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);\n            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);\n            float tt0 = tt1;\n            if (tt0 <= 0.)\n                return false;\n            vec3 pos = ro + tt0 * rd;\n            // black border on end of circle and self intersection with alpha come because dFd\n            // uncomment this to see or rename fcos2 to fcos\n            //sz+=0.3; \n            bool ru = step(sz, length(pos)) > 0.5;\n            if (ru)\n            {\n                tt0 = tt2;\n                pos = ro + tt0 * rd;\n            }\n            if (tt0 <= 0.)\n                return false;\n            bool ru2 = step(sz, length(pos)) > 0.5;\n            if (ru2)\n                return false;\n\n            // self intersect\n            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))\n            {\n                si = true;\n                fadesi=s;\n                tsi = tt2;\n                vec3 tpos = ro + tsi * rd;\n                // normal\n                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +\n                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);\n                normsi = -normalize(tgrad);\n            }\n            \n            fade=s;\n            t = tt0;\n            // normal\n            vec3 grad =\n                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n            norm = -normalize(grad);\n\n            return true;\n        }\n    }\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz);\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4 + ANGLE_loops; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = rd;\n\tvec3 roo = ro;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    vec3 dr = 1.0 / rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 bgcol(in vec3 rd)\n{\n    return mix(vec3(0.01), vec3(0.595, 0.53, .7976), 1. - pow(abs(rd.z+0.25), 1.3));\n}\n\nvec3 background(in vec3 ro, in vec3 rd , vec3 l_dir)\n{\n    float t = (-BOXDIMS.z - ro.z) / rd.z;\n    vec3 bgc = bgcol(rd);\n    if (t < 0.)\n        return bgc;\n    vec2 uv = ro.xy + t * rd.xy;\n    float shad = boxSoftShadow((ro + t * rd), normalize(l_dir+vec3(0.,0.,1.))*rotz(PI*0.65) , BOXDIMS, 1.5);\n    float aofac = smoothstep(-0.95, .75, length(abs(uv) - min(abs(uv), vec2(0.45))));\n    aofac = min(aofac,smoothstep(-0.65, 1., shad));\n    float lght=max(dot(normalize(ro + t * rd+vec3(0.,-0.,-5.)), normalize(l_dir-vec3(0.,0.,1.))*rotz(PI*0.65)), 0.0);\n    vec3 col = mix(vec3(0.4), vec3(0.7535, 0.7346, .9342), lght*lght* aofac+ 0.05) * aofac;\n    return mix(col*length(col)*0.8,bgc,smoothstep(7.,10.,length(uv)));\n}\n\n#define swap(a,b) tv=a;a=b;b=tv\n\nvec4 insides(vec3 ro, vec3 rd, vec3 nor_c, vec3 l_dir, out float tout)\n{\n    tout = -1.;\n    vec3 trd=rd;\n\n    vec3 col = vec3(0.);\n\n    float pi = 3.1415926;\n\n    if (abs(nor_c.x) > 0.5)\n    {\n        rd = rd.xzy * nor_c.x;\n        ro = ro.xzy * nor_c.x;\n    }\n    else if (abs(nor_c.z) > 0.5)\n    {\n        l_dir *= roty(pi);\n        rd = rd.yxz * nor_c.z;\n        ro = ro.yxz * nor_c.z;\n    }\n    else if (abs(nor_c.y) > 0.5)\n    {\n        l_dir *= rotz(-pi * 0.5);\n        rd = rd * nor_c.y;\n        ro = ro * nor_c.y;\n    }\n\n\n    float bil_size = 1.;\n    vec4 ps = vec4(-bil_size, -bil_size, bil_size, bil_size) * curvature;\n    vec4 ph = vec4(-bil_size, bil_size, bil_size, -bil_size) * curvature;\n    \n    vec4 [3]colx=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    vec3 [3]dx=vec3[3](vec3(-1.),vec3(-1.),vec3(-1.));\n    vec4 [3]colxsi=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    int [3]order=int[3](0,1,2);\n\n    for (int i = 0; i < 3 + ANGLE_loops; i++)\n    {\n        if (abs(nor_c.x) > 0.5)\n        {\n            ro *= rotz(-pi * (1. / float(3)));\n            rd *= rotz(-pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.z) > 0.5)\n        {\n            ro *= rotz(pi * (1. / float(3)));\n            rd *= rotz(pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.y) > 0.5)\n        {\n            ro *= rotx(pi * (1. / float(3)));\n            rd *= rotx(pi * (1. / float(3)));\n        }\n        vec3 normnew;\n        float tnew;\n        bool si;\n        float tsi;\n        vec3 normsi;\n        float fade;\n        float fadesi;\n\n        if (iBilinearPatch(ro, rd, ps, ph, bil_size, tnew, normnew, si, tsi, normsi, fade, fadesi))\n        {\n            if (tnew > 0.)\n            {\n                vec4 tcol, tcolsi;\n                calcColor(ro, rd, normnew, tnew, bil_size, i, si, tsi, tcol, tcolsi);\n                if (tcol.a > 0.0)\n                {\n                    {\n                        vec3 tvalx = vec3(tnew, float(si), tsi);\n                        dx[i]=tvalx;\n                    }\n#ifdef DEBUG\n                    colx[i]=tcol;\n                    if (si)colxsi[i]=tcolsi;\n#else\n\n                    float dif = clamp(dot(normnew, l_dir), 0.0, 1.0);\n                    float amb = clamp(0.5 + 0.5 * dot(normnew, l_dir), 0.0, 1.0);\n\n                    {\n                        vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                        float ta = clamp(length(tcol.rgb),0.,1.);\n                        tcol=clamp(tcol*tcol*2.,0.,1.);\n                        vec4 tvalx =\n                            vec4((tcol.rgb*shad*1.4 + 3.*(vec3(1.,0.21,0.11)*tcol.rgb)*clamp(1.-(amb+dif),0.,1.)), min(tcol.a,ta));\n                        tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                        tvalx*=(min(fade*5.,1.));\n                        colx[i]=tvalx;\n                    }\n                    if (si)\n                    {\n                        dif = clamp(dot(normsi, l_dir), 0.0, 1.0);\n                        amb = clamp(0.5 + 0.5 * dot(normsi, l_dir), 0.0, 1.0);\n                        {\n                            vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                            float ta = clamp(length(tcolsi.rgb),0.,1.);\n                            tcolsi=clamp(tcolsi*tcolsi*2.,0.,1.);\n                            vec4 tvalx =\n                                vec4(tcolsi.rgb * shad + 3.*(vec3(1.,0.21,0.11)*tcolsi.rgb)*clamp(1.-(amb+dif),0.,1.), min(tcolsi.a,ta));\n                            tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                            tvalx.rgb*=(min(fadesi*5.,1.));\n                            colxsi[i]=tvalx;\n                        }\n                    }\n#endif\n                }\n            }\n        }\n    }\n    // transparency logic and layers sorting \n    float a = 1.;\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n    if (dx[1].x < dx[2].x){{vec3 swap(dx[1], dx[2]);}{int swap(order[1], order[2]);}}\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n\n    tout = max(max(dx[0].x, dx[1].x), dx[2].x);\n\n    if (dx[0].y < 0.5)\n    {\n        a=colx[order[0]].a;\n    }\n\n#if !(defined(DEBUG)&&defined(BUG))\n    \n    // self intersection\n    bool [3] rul= bool[3](\n        ((dx[0].y > 0.5) && (dx[1].x <= 0.)),\n        ((dx[1].y > 0.5) && (dx[0].x > dx[1].z)),\n        ((dx[2].y > 0.5) && (dx[1].x > dx[2].z))\n    );\n    for(int k=0;k<3;k++){\n        if(rul[k]){\n            vec4 tcolxsi = vec4(0.);\n            tcolxsi=colxsi[order[k]];\n            vec4 tcolx = vec4(0.);\n            tcolx=colx[order[k]];\n\n            vec4 tvalx = mix(tcolxsi, tcolx, tcolx.a);\n            colx[order[k]]=tvalx;\n\n            vec4 tvalx2 = mix(vec4(0.), tvalx, max(tcolx.a, tcolxsi.a));\n            colx[order[k]]=tvalx2;\n        }\n    }\n\n#endif\n\n    float a1 = (dx[1].y < 0.5) ? colx[order[1]].a : ((dx[1].z > dx[0].x) ? colx[order[1]].a : 1.);\n    float a2 = (dx[2].y < 0.5) ? colx[order[2]].a : ((dx[2].z > dx[1].x) ? colx[order[2]].a : 1.);\n    col = mix(mix(colx[order[0]].rgb, colx[order[1]].rgb, a1), colx[order[2]].rgb, a2);\n    a = max(max(a, a1), a2);\n    return vec4(col, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float osc = 0.5;\n    vec3 l_dir = normalize(vec3(0., 1., 0.));\n    //l_dir *= rotz(0.5);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    float mouseY = 1.0 * 0.5 * PI;\n#ifdef MOUSE_control\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n#endif\n    mouseY = PI*0.49  * 0.55 * PI*99.01;\n    float mouseX = -2.*PI-0.25*(iTime+tshift);\n#ifdef MOUSE_control\n    mouseX+=-(iMouse.x / iResolution.x) * 2. * PI;\n#endif\n    \n    vec3 eye = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(PI*0.49  * 1.4 * PI));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n\n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z/BOXDIMS.xy + ro.yz * ni.x/BOXDIMS.yz + ro.zx * ni.y/BOXDIMS.zx;\n    float fadeborders = (1.-smoothstep(0.915,1.05,abs(coords.x)))*(1.-smoothstep(0.915,1.05,abs(coords.y)));\n\n    if (t > 0.)\n    {\n        float ang = -iTime * 0.33;\n        vec3 col = vec3(0.);\n        float R0 = (IOR - 1.) / (IOR + 1.);\n        R0 *= R0;\n\n        vec2 theta = vec2(0.);\n        vec3 n = vec3(cos(theta.x) * sin(theta.y), sin(theta.x) * sin(theta.y), cos(theta.y));\n\n        vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n        vec3 rdr = reflect(rd, nr);\n        vec3 reflcol = background(ro, rdr, l_dir);\n\n        vec3 rd2 = refract(rd, nr, 1. / IOR);\n\n        float accum = 1.;\n        vec3 no2 = ni;\n        vec3 ro_refr = ro;\n\n        vec4 [2] colo = vec4[2](vec4(0.),vec4(0.));\n\n        for (int j = 0; j < 2 + ANGLE_loops; j++)\n        {\n            float tb;\n            vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n            vec3 eye2 = vec3(coords2, -1.);\n            vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n\n            rd2trans.z = -rd2trans.z;\n            vec4 internalcol = insides(eye2, rd2trans, no2, l_dir, tb);\n            if (tb > 0.)\n            {\n                internalcol.rgb *= accum;\n                colo[j]=internalcol;\n            }\n\n            if ((tb <= 0.) || (internalcol.a < 1.))\n            {\n                float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                vec3 rout = ro_refr + tout * rd2;\n                vec3 rdout = refract(rd2, -no2, IOR);\n                float fresnel2 = R0 + (1. - R0) * pow(1. - dot(rdout, no2), 1.3);\n                rd2 = reflect(rd2, -no2);\n\n#ifdef backside_refl\n                if((dot(rdout, no2))>0.5){fresnel2=1.;}\n#endif\n                ro_refr = rout;\n                ro_refr.z = max(ro_refr.z, -0.999);\n\n                accum *= fresnel2;\n            }\n        }\n        float fresnel = R0 + (1. - R0) * pow(1. - dot(-rd, nr), 5.);\n        col = mix(mix(colo[1].rgb * colo[1].a, colo[0].rgb, colo[0].a)*fadeborders, reflcol, pow(fresnel, 1.5));\n        col=clamp(col,0.,1.);\n        float cineshader_alpha = 0.;\n        cineshader_alpha = clamp(0.15*dot(eye,ro),0.,1.);\n        fragColor = vec4(col, cineshader_alpha);\n    }\n    else\n    {\n        fragColor = vec4(background(eye, rd, l_dir), 0.15);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[980, 1334, 1353, 1353, 1458], [1459, 1459, 1478, 1478, 1581], [1582, 1582, 1601, 1601, 1705], [1707, 1707, 1726, 1726, 1804], [1806, 1824, 1844, 1844, 1859], [1861, 1861, 1884, 1983, 2772], [2774, 2774, 2912, 2912, 3813], [3815, 3871, 4080, 4080, 7327], [7329, 7329, 7354, 7354, 7373], [7375, 7375, 7440, 7440, 7924], [7926, 7926, 8000, 8000, 8531], [8533, 8533, 8607, 8607, 9102], [9104, 9104, 9128, 9128, 9215], [9217, 9217, 9271, 9271, 9938], [9973, 9973, 10045, 10045, 15185], [15187, 15187, 15242, 15242, 18557]], "test": "valid"}
{"id": "7sSGRD", "name": "ccpn dog-n-snake", "author": "snolot", "description": "Try to. understand ccpn. For this one i use layer 4d unit 52. with positive channel trained on green snake and negative channel with dog faces. \n\nLayers doc: https://distill.pub/2017/feature-visualization/appendix/googlenet/4d.html#4d-52  ", "tags": ["neuralnetwork", "ccpn"], "likes": 4, "viewed": 99, "published": "Public", "date": "1617025856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(0.06675647,-0.112921976,0.24648738,0.19081993) + mat4(vec4(-0.09783562272787094,0.6033133864402771,0.5459284782409668,0.02353079617023468),vec4(-0.3991538882255554,-1.3593709468841553,-0.0828469917178154,0.00916012842208147),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(-0.16637897,0.032060042,0.6235564,0.13406448) + mat4(vec4(-0.03177807852625847,-0.46600407361984253,-0.8980035185813904,-0.4408663511276245),vec4(0.4701674282550812,0.09734643250703812,-0.6065258383750916,-0.13803772628307343),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.093900815,0.059695214,0.13368766,-0.14496166) + mat4(vec4(0.014996007084846497,0.23058615624904633,0.5903733372688293,-0.5065232515335083),vec4(0.04765687510371208,1.0434601306915283,-0.15459094941616058,-0.04395680129528046),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(0.06894048,0.23901846,-0.22204676,0.11799114) + mat4(vec4(-0.5124861001968384,0.19427071511745453,-0.11638811975717545,-0.5106224417686462),vec4(-0.3481813967227936,-0.5061563849449158,-0.4646241068840027,0.3108561635017395),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.31191385,-0.29288593,-0.06462119,0.3471689) + mat4(vec4(0.09521558,-0.2393689,0.17565285,-0.05644801),vec4(-0.2025828,0.04045431,-0.19146602,-0.14953166),vec4(0.1535205,-0.21470644,-0.024320683,0.23777646),vec4(0.1835395,-0.11058433,0.14133057,0.21997318)) * bufB[0] + mat4(vec4(-0.23472255,0.26315138,0.07784405,0.12776203),vec4(0.117864944,-0.03775555,0.22513601,-0.13755669),vec4(0.49349478,-0.3037894,0.22782052,0.13166158),vec4(-0.2084705,-0.22518641,0.21280292,0.027643045)) * bufB[1] + mat4(vec4(-0.045271885,0.04930907,-0.28713292,-0.07728993),vec4(0.078466535,0.0060628057,-0.24270466,0.0111124385),vec4(0.24182579,0.024143053,-0.29507804,0.18474518),vec4(-0.23012799,-0.09139378,0.3056654,-0.27864555)) * bufB[2] + mat4(vec4(0.09223258,0.20741265,0.44895506,-0.22271697),vec4(0.5333944,-0.107133806,-0.30311584,-0.056549065),vec4(-0.11748622,0.14121911,0.015259861,-0.25054222),vec4(0.098695844,-0.23570707,0.25568184,0.20333299)) * bufB[3] + mat4(vec4(-0.1483548,0.17834732,0.080172114,-0.051633585),vec4(0.36623797,0.42247728,0.20644708,0.120072916),vec4(-0.10026788,-0.33637932,-0.016536174,-0.5821363),vec4(-0.113274775,-0.18482517,-0.011562629,-0.21335478)) * bufB[4] + mat4(vec4(-0.11096339,0.6038018,-0.2648953,-0.14472058),vec4(-0.3025209,0.14579923,0.09886065,-0.3483382),vec4(0.03607077,-0.016846305,0.45575953,0.020413201),vec4(-0.103748225,0.024221847,-0.114988275,-0.38600072)) * bufB[5] + mat4(vec4(-0.057874415,0.2277737,0.28826293,-0.24303496),vec4(0.018760372,0.0385821,-0.110137634,-0.078890264),vec4(-0.4088666,-0.05535139,0.2248805,-0.31767708),vec4(-0.34371358,-0.23990996,-0.28214636,-0.26317057)) * bufB[6] + mat4(vec4(-0.4411922,0.069058076,-0.078962915,-0.33153766),vec4(-0.044511363,0.42533216,0.22338106,-0.28740382),vec4(-0.17583914,0.38716298,-0.24493924,0.018101322),vec4(-0.17858286,-0.13695191,0.24489948,-0.04586546)) * bufB[7];\nbufA[1] = vec4(-0.12161682,0.03302938,0.3311292,0.06456304) + mat4(vec4(-0.15609054,0.13791539,0.34604374,0.070171095),vec4(-0.12638548,0.30159396,-0.099741735,-0.10459452),vec4(0.090499975,-0.021709103,0.043841314,-0.10498797),vec4(0.00047399447,0.01961034,0.18406284,-0.04604898)) * bufB[0] + mat4(vec4(0.32464117,-0.19234481,-0.11194681,0.13985127),vec4(-0.039533835,-0.009642902,-0.14968152,0.030961506),vec4(-0.21714728,0.32721806,0.107433386,0.03808239),vec4(0.035229757,0.17353567,0.056380264,-0.20847885)) * bufB[1] + mat4(vec4(-0.049517456,-0.05417672,0.35370463,0.00983603),vec4(-0.35836902,-0.7198731,-0.05848045,0.32463476),vec4(0.3221375,-0.103509024,-0.15898836,0.034041476),vec4(0.26515552,-0.07467242,-0.22021848,0.24635606)) * bufB[2] + mat4(vec4(-0.08386965,0.36381882,-0.10022874,-0.1970722),vec4(-0.04350483,0.016338248,0.04293587,-0.2803881),vec4(0.07269556,0.1660234,-0.18115579,-0.36290285),vec4(0.012586684,-0.22577521,0.02054419,-0.023424163)) * bufB[3] + mat4(vec4(0.24931487,0.0342127,-0.4156288,-0.11986483),vec4(0.40868902,0.046713557,0.0069736964,-0.3816834),vec4(-0.4043451,0.30275828,-0.34973672,0.13343026),vec4(0.16029453,-0.23651135,-0.07741595,0.037960887)) * bufB[4] + mat4(vec4(0.23001035,0.2525871,-0.2286496,0.019005695),vec4(-0.23138055,-0.116328046,-0.11980361,0.011053427),vec4(-0.30644313,0.25789404,-0.008137624,0.10375634),vec4(-0.4295694,0.5189982,-0.3616282,0.22386709)) * bufB[5] + mat4(vec4(0.18474543,0.07591918,0.11629354,0.12737492),vec4(0.1823161,-0.17198879,0.1262444,-0.15552408),vec4(-0.34011137,0.44949928,-0.13020147,0.1970995),vec4(-0.40136456,0.42176306,-0.22126086,0.38268918)) * bufB[6] + mat4(vec4(-0.03579551,0.5027605,-0.20384967,0.050265975),vec4(0.43894133,-0.24326524,-0.04770866,-0.35511497),vec4(0.31796208,-0.5606602,-0.3244493,-0.109334156),vec4(-0.08286062,0.028762951,-0.07440038,0.1285617)) * bufB[7];\nbufA[2] = vec4(-0.13073297,-0.03886194,0.4579808,0.23209171) + mat4(vec4(-0.079347976,-0.2891175,-0.08106126,0.20189118),vec4(0.25812858,0.09163061,-0.19167025,0.067811385),vec4(-0.26447707,-0.035035163,0.105209805,-0.06949978),vec4(0.09929269,-0.015171873,0.44000024,0.051433664)) * bufB[0] + mat4(vec4(0.084143855,0.043272197,-0.045888603,-0.18104212),vec4(0.017684704,-0.12847002,0.03668412,-0.048705626),vec4(0.05136535,-0.078557454,0.37876332,-0.051361483),vec4(-0.049175028,-0.1580008,0.2278973,0.25207716)) * bufB[1] + mat4(vec4(-0.0031057512,-0.14331639,-0.18445489,-0.0726568),vec4(-0.09362166,0.09688721,0.1924463,-0.009370843),vec4(-0.25929078,0.28823993,0.21182053,0.2854076),vec4(-0.25353947,-0.2602448,-0.16237192,0.22253221)) * bufB[2] + mat4(vec4(-0.08823187,-0.045706965,0.095450625,-0.13331552),vec4(-0.12469636,-0.18259712,0.2232248,0.31818274),vec4(-0.2074046,0.117065504,-0.07732501,0.05597276),vec4(-0.123633474,-0.20920308,0.007291991,0.10086289)) * bufB[3] + mat4(vec4(-0.24184711,0.3751554,-0.17711441,-0.055521425),vec4(0.4735041,0.23825407,-0.008750533,-0.3922103),vec4(0.101740554,0.36819962,0.016381076,-0.41824618),vec4(0.10024821,-0.17311576,-0.31735232,-0.03970235)) * bufB[4] + mat4(vec4(-0.3693233,0.6653698,-0.39877716,-0.0225068),vec4(0.024534144,0.10099809,-0.25160608,0.14738737),vec4(0.059021246,0.05939752,0.025491802,0.10606971),vec4(0.16970235,-0.12657599,-0.012793356,-0.05116466)) * bufB[5] + mat4(vec4(0.1644103,0.38684872,0.0030378518,-0.075365305),vec4(-0.5295558,0.08649279,-0.3830413,0.110365905),vec4(0.1628557,0.13458367,-0.41200057,-0.32056078),vec4(0.39963916,-0.1442432,-0.065854,-0.2759029)) * bufB[6] + mat4(vec4(0.088487424,0.07325772,-0.17182514,-0.08526656),vec4(-0.03299312,0.3568527,-0.26335272,-0.16836417),vec4(-0.03896601,0.25373214,-0.16160318,0.31152597),vec4(0.35243285,-0.045897443,-0.27499855,-0.14351586)) * bufB[7];\nbufA[3] = vec4(0.39255074,-0.35711655,0.1675026,-0.44770655) + mat4(vec4(-0.06667194,0.17693512,-0.19810107,-0.013392772),vec4(0.07813232,-0.23626988,0.16282564,0.11144962),vec4(-0.19599223,-0.24995482,0.20663054,-0.38773954),vec4(0.22055328,-0.08807072,0.19542055,0.08506224)) * bufB[0] + mat4(vec4(-0.22664954,0.05717549,0.09470609,0.31208724),vec4(0.15083976,-0.20808263,-0.16760303,0.019189132),vec4(-0.21599549,-0.22628897,0.016070243,-0.5002365),vec4(-0.101882674,-0.1438922,0.25011718,-0.2074993)) * bufB[1] + mat4(vec4(-0.09308877,0.05638664,-0.24680147,0.08789703),vec4(-0.3383498,-0.18031362,-0.26540327,-0.2195796),vec4(-0.11650857,-0.18891661,0.27737302,-0.10088608),vec4(-0.49277845,0.06172176,0.11627604,0.16214459)) * bufB[2] + mat4(vec4(-0.36836687,-0.06395229,-0.32263267,-0.29845318),vec4(0.19311681,-0.076324165,-0.028812654,-0.21560112),vec4(-0.18980931,0.3310404,-0.5112735,0.10449813),vec4(-0.08269562,0.038776487,0.02234533,0.062322468)) * bufB[3] + mat4(vec4(0.041774902,0.35063896,-0.2707653,0.16454928),vec4(-0.19292194,0.1844851,-0.068886265,-0.0019683945),vec4(-0.19188657,-0.2453457,-0.06466206,0.5294236),vec4(-0.043940976,0.46116647,-0.04469035,0.16751921)) * bufB[4] + mat4(vec4(-0.2609985,0.19900016,-0.192194,0.23971096),vec4(0.2337402,0.0108836405,-0.052204136,0.046030205),vec4(-0.1928663,0.35460055,0.1862031,-0.16891876),vec4(0.14641711,0.06325493,-0.29208833,0.522427)) * bufB[5] + mat4(vec4(-0.02819261,0.33619225,-0.21245977,0.096264556),vec4(0.17066965,0.036693618,-0.35979697,-0.084153),vec4(0.10834701,0.5265363,-0.080103785,0.28425848),vec4(0.11549808,0.21695377,0.13363273,0.49897766)) * bufB[6] + mat4(vec4(-0.057966024,0.28208372,-0.08347174,0.30798677),vec4(-0.22041957,-0.071571894,0.107125975,0.25437617),vec4(-0.0055883205,0.24718785,-0.13315132,-0.015987212),vec4(-0.31161228,0.020961838,0.006760573,-0.15343244)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.29353645,0.1414231,-0.0030448288,-0.17936438) + mat4(vec4(0.15931667,-0.026018118,0.18494768,0.054415215),vec4(0.44306472,0.094115764,-0.24167797,-0.2949287),vec4(-0.35645965,0.03211645,0.07204554,-0.10915948),vec4(-0.055675387,0.44599015,0.07326002,-0.079665594)) * bufB[0] + mat4(vec4(0.8910882,0.3001869,0.3305241,0.028844137),vec4(0.029616954,-0.018874459,0.0063638007,0.13315505),vec4(0.07295069,0.09045997,0.07500015,-0.12552065),vec4(-0.35508093,-0.051399227,-0.3470462,0.109372236)) * bufB[1] + mat4(vec4(0.21110947,-0.3514422,-0.107337326,-0.38131544),vec4(0.100248575,-0.1233499,-0.047391813,-0.25817907),vec4(-0.79738003,0.43378848,-0.15941298,-0.17649497),vec4(-0.2095559,0.15633431,0.14958422,0.16925818)) * bufB[2] + mat4(vec4(-0.29102957,-0.12334695,-0.10115692,0.16634096),vec4(0.08913118,-0.07704421,0.0057249204,0.2905385),vec4(0.106931366,-0.03274426,-0.17408223,-0.43292898),vec4(0.03242325,-0.76990706,-0.30216992,-0.0496236)) * bufB[3] + mat4(vec4(-0.18992198,0.24436001,-0.16610001,-0.047848042),vec4(0.2886242,0.44767773,0.20597099,0.12092705),vec4(-0.37933317,-0.004156618,-0.10648967,-0.09068563),vec4(-0.055326644,0.17087233,0.45216933,0.36767513)) * bufB[4] + mat4(vec4(-0.1281185,-0.099092476,0.23731193,0.18374656),vec4(0.42306167,0.19492617,0.21841598,0.19788168),vec4(0.06947743,-0.13514565,0.03430967,0.13698535),vec4(0.17584065,-0.25517306,0.3398088,-0.122750625)) * bufB[5] + mat4(vec4(0.037481412,-0.48540032,-0.45120293,0.20287867),vec4(0.31366333,0.017776666,-0.13853619,-0.10970625),vec4(-0.23549278,-0.015865939,-0.12429995,0.0006220847),vec4(0.4161064,-0.3316283,-0.23939958,0.27866536)) * bufB[6] + mat4(vec4(-0.28485483,0.100897305,-0.18624265,-0.08353925),vec4(-0.13710783,-0.44793773,-0.085639335,0.5958614),vec4(0.025716528,0.16010134,-0.09707886,-0.07073844),vec4(-0.30950853,0.33585614,-0.27233574,-0.3390284)) * bufB[7];\nbufA[1] = vec4(-0.021308437,0.28870687,-0.37977257,0.34684768) + mat4(vec4(0.010095624,0.1582675,-0.27965823,0.52122617),vec4(-0.21724334,-0.368897,0.028106717,-0.1414443),vec4(0.0074408627,0.11841483,-0.08758872,-0.041512374),vec4(-0.28317103,0.03946306,-0.34827736,0.22301011)) * bufB[0] + mat4(vec4(-0.016897587,-0.21972667,-0.026065959,0.21202117),vec4(0.24715818,0.27040318,0.07415283,-0.025324685),vec4(-0.25233462,0.0326476,-0.1847623,0.015217792),vec4(-0.15516573,0.2907098,0.03972731,-0.09985073)) * bufB[1] + mat4(vec4(-0.08365699,0.16920745,-0.097448036,-0.19310424),vec4(-0.14814174,0.020406356,-0.21823521,-0.041716944),vec4(-0.32595313,0.54644495,-0.4627649,0.18102038),vec4(0.41769132,0.07676887,0.18075271,0.09891912)) * bufB[2] + mat4(vec4(-0.20587106,-0.011414986,-0.2055559,-0.17746842),vec4(0.07004157,-0.14994474,0.24288285,-0.09077937),vec4(-0.23871255,0.31072378,0.13946223,0.028683003),vec4(-0.14771424,-0.35222647,0.3021418,-0.34096345)) * bufB[3] + mat4(vec4(0.04116724,0.06935222,-0.15012191,0.26607245),vec4(0.37536177,-0.17245577,0.3069494,-0.06973444),vec4(-0.026888367,0.33141938,-0.13824324,-0.09166051),vec4(0.09605612,-0.3785268,0.2779457,-0.0014440313)) * bufB[4] + mat4(vec4(0.23091918,-0.17594954,0.45632374,-0.046153527),vec4(0.09607474,-0.1045079,-0.23454066,0.3294357),vec4(-0.30358803,-0.21194057,0.36193082,0.0666082),vec4(-0.016024208,-0.19118069,-0.088372685,0.13527036)) * bufB[5] + mat4(vec4(-0.3547632,0.17830145,-0.006955223,-0.20278932),vec4(-0.02851134,0.014426091,0.08753665,-0.13158551),vec4(-0.28078035,-0.52064955,0.1478875,-0.034805093),vec4(-0.31944785,0.18675815,0.14647223,-0.06412959)) * bufB[6] + mat4(vec4(-0.004018654,0.09961832,-0.21681975,-0.21716405),vec4(0.2346532,-0.3658756,0.24796332,-0.03824392),vec4(-0.12933816,-0.09314498,0.07454029,0.13957155),vec4(-0.107736394,0.29137728,0.15155391,-0.018746791)) * bufB[7];\nbufA[2] = vec4(-0.27240965,-0.35707167,0.03421841,-0.03275822) + mat4(vec4(0.059585102,-0.19401276,0.050501384,0.4825256),vec4(-0.045257535,0.47573063,0.07931047,-0.08667003),vec4(0.7815293,0.22612876,-0.14190257,0.113714024),vec4(-0.1493612,0.007018953,-0.16158836,0.1892331)) * bufB[0] + mat4(vec4(-0.24046616,0.20234977,0.07034289,0.16940504),vec4(0.02353191,-0.58023596,0.26000506,-0.42864996),vec4(0.08183605,0.0513789,-0.13624361,0.18462767),vec4(0.21886444,0.40649125,-0.101419374,-0.23956913)) * bufB[1] + mat4(vec4(0.31127223,-0.18583131,0.06694257,0.04858791),vec4(-0.5157086,0.17379202,0.19437088,-0.19684671),vec4(-0.25683483,-0.39600837,-0.02382032,0.077514835),vec4(-0.2029271,-0.30992985,0.084952556,0.21314651)) * bufB[2] + mat4(vec4(-0.6514051,-0.23466304,-0.12311087,0.21967933),vec4(0.2572627,0.3684342,-0.1906925,0.034926288),vec4(-0.531801,-0.17852943,0.07937364,-0.124725275),vec4(-0.4297761,0.3744847,-0.07588308,-0.0858929)) * bufB[3] + mat4(vec4(-0.21247326,-0.15150638,-0.02064545,-0.022037135),vec4(0.07782558,0.17479897,0.12567566,0.47403616),vec4(0.52544624,-0.21823026,0.32427472,0.0547502),vec4(-0.4447185,0.22690205,-0.19280055,0.15878274)) * bufB[4] + mat4(vec4(0.23315547,0.08359954,-0.17113455,0.107066564),vec4(-0.03751149,0.018462311,0.18365596,0.26287004),vec4(-0.03819548,0.2746802,-0.31055114,-0.026693666),vec4(-0.4443581,-0.022049835,-0.06869971,0.2631471)) * bufB[5] + mat4(vec4(0.15598777,0.23075995,-0.019957876,-0.083281755),vec4(-0.24571742,0.014316586,0.023382148,0.21521105),vec4(-0.12647578,0.18918674,-0.4857233,0.27618605),vec4(0.038239356,0.0037484237,-0.048388876,-0.24342117)) * bufB[6] + mat4(vec4(0.10314728,-0.047507625,0.073773086,-0.014716912),vec4(0.4934482,0.23910369,-0.15974212,-0.17402738),vec4(0.010190582,0.04068633,0.12149447,-0.25060958),vec4(0.3046156,0.21631734,-0.54150575,0.059720036)) * bufB[7];\nbufA[3] = vec4(-0.23444721,0.22843102,0.053983487,0.19245552) + mat4(vec4(-0.3270652,0.39123693,0.22187638,0.24039268),vec4(0.21063922,0.30951896,-0.14972079,0.07025263),vec4(-0.050822835,-0.02354538,-0.060185615,0.15589087),vec4(-0.22382954,0.27520642,0.18748917,-0.2872751)) * bufB[0] + mat4(vec4(0.095395185,0.028014898,0.2191617,0.087383166),vec4(-0.11922996,-0.084446914,-0.15221338,0.3668343),vec4(-0.06550441,0.04975423,-0.17227092,0.042034052),vec4(-0.16488235,-0.093831025,0.022375343,-0.66502935)) * bufB[1] + mat4(vec4(0.1313013,0.17712724,0.023142662,0.42406428),vec4(0.28670177,0.49225533,0.14317411,0.095333),vec4(-0.28347436,0.22619826,-0.21465228,-0.123411),vec4(0.045066822,-0.047641896,-0.11763055,0.04042674)) * bufB[2] + mat4(vec4(-0.12833016,-0.2173044,0.1794821,0.07108374),vec4(0.16695853,-0.07825016,0.24044277,-0.14979707),vec4(0.056594376,-0.042129856,-0.09539223,0.02277931),vec4(0.362164,-0.15412228,0.21352485,-0.1580222)) * bufB[3] + mat4(vec4(-0.0030438406,0.63070774,-0.12134414,0.11052006),vec4(-0.014121127,-0.5155956,0.18547376,-0.15962972),vec4(0.063713126,0.08847803,-0.0012808364,-0.030540332),vec4(0.1923708,-0.34341052,-0.11359982,-0.16151227)) * bufB[4] + mat4(vec4(-0.04899832,-0.3784304,0.023896318,-0.5830783),vec4(-0.030676935,-0.00987369,0.10918835,0.06907061),vec4(0.1431632,-0.03633984,-0.25321332,-0.048725888),vec4(0.059171867,0.6181594,-0.12968075,-0.11286216)) * bufB[5] + mat4(vec4(0.015676217,0.122169875,0.11301355,0.32508072),vec4(-0.10654036,0.16942044,0.23801823,-0.23936903),vec4(-0.27156964,0.11696089,0.106447786,-0.13852306),vec4(0.39272693,0.2282343,0.11290711,0.5095615)) * bufB[6] + mat4(vec4(0.13568798,0.08356784,-0.14749968,0.05440936),vec4(0.027320746,-0.25437215,-0.6276071,0.23114215),vec4(0.21370845,0.013311162,-0.36141104,0.045848876),vec4(-0.29857254,0.36359602,-0.15156499,0.05166514)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.13644853,0.08626685,0.14146107,0.4245383) + mat4(vec4(-0.42957795,-0.0203235,0.26413536,-0.22727425),vec4(-0.072188765,-0.37979174,0.052150935,-0.3569837),vec4(-0.41385713,-0.20340903,-0.27946764,-0.25610203),vec4(-0.19474289,-0.031219337,0.21102181,-0.20128348)) * bufB[0] + mat4(vec4(-0.102536626,-0.5159787,0.16126224,0.13320602),vec4(0.68527466,-0.0125480965,0.28412026,0.35078117),vec4(0.45890132,-0.18957493,-0.24891709,-0.10305492),vec4(-0.33917055,-0.37225068,0.06609315,0.02733256)) * bufB[1] + mat4(vec4(0.012886314,-0.05924429,0.5735959,-0.025080597),vec4(-0.15520336,0.5975244,0.28520304,-0.43181333),vec4(-0.26268527,0.022249721,0.13103926,0.41702905),vec4(-0.13913083,0.21093473,0.23588477,0.2984624)) * bufB[2] + mat4(vec4(-0.10047623,0.12711306,-0.22476563,-0.15873672),vec4(-0.13504195,0.34079993,0.22803839,0.5246767),vec4(0.05723726,0.41723272,-0.12832949,0.45658383),vec4(-0.089514,-0.18938658,0.1559746,0.28698948)) * bufB[3] + mat4(vec4(0.24421413,0.679603,-0.27154797,0.0008903189),vec4(0.43746623,0.042421304,0.09799274,-0.529203),vec4(-0.13326858,-0.3769047,0.09274417,0.005967151),vec4(-0.20566353,-0.28750697,0.15604626,0.000102197635)) * bufB[4] + mat4(vec4(-0.17682797,-0.633774,0.5042906,0.036138944),vec4(0.19320312,0.015036936,-0.20449053,-0.2873524),vec4(0.422451,0.026537549,0.36680418,-0.15333612),vec4(0.13084695,-0.17537512,0.08058293,-0.21142907)) * bufB[5] + mat4(vec4(-0.069919676,0.73153627,-0.06349234,0.8139511),vec4(-0.6429823,-0.2638386,-0.21963425,-0.03776624),vec4(0.21336874,0.0217567,-0.27739847,-0.074919365),vec4(-0.0022386275,-0.27316192,0.07781244,-0.092259474)) * bufB[6] + mat4(vec4(0.19536896,-0.074293464,0.04592668,-0.34345523),vec4(0.109901115,-0.12321442,-0.07883871,0.16464256),vec4(-0.095149115,0.05952164,0.090956785,-0.12986252),vec4(-0.28461438,0.092346236,-0.20554684,0.26020172)) * bufB[7] + in0;\nbufA[1] = vec4(0.17112863,-0.02326959,-0.1879816,0.20203371) + mat4(vec4(-0.090384066,-0.11101755,-0.13895759,-0.38140434),vec4(0.1565945,0.29508206,-0.70596504,0.3125021),vec4(0.44456813,0.012604896,-0.14618556,-0.39654544),vec4(-0.15436499,-0.021903258,0.10539066,-0.055238426)) * bufB[0] + mat4(vec4(0.20290293,-0.053841583,0.078484826,-0.18660979),vec4(-0.2280535,0.45375356,0.04754315,0.5095599),vec4(-0.052828383,0.31459472,0.7283451,-0.14703251),vec4(0.16946124,0.11880495,-0.6024014,0.19005202)) * bufB[1] + mat4(vec4(-0.35762912,0.03995775,0.10255088,0.04181225),vec4(-0.43157148,0.043140933,-0.05065849,-0.012910716),vec4(0.12512973,0.0064712167,0.009476947,-0.059112277),vec4(-0.004208077,-0.032465983,-0.35045105,-0.045421366)) * bufB[2] + mat4(vec4(-0.35810027,-0.16084234,0.083047934,-0.22645053),vec4(0.13028054,-0.31288612,-0.23013507,-0.054117244),vec4(0.024862483,0.15756093,-0.10289545,-0.08990099),vec4(0.025596362,0.01238911,0.019049939,-0.43444467)) * bufB[3] + mat4(vec4(-0.12147891,0.20028304,0.04457357,-0.019126132),vec4(-0.07571109,-0.21534929,0.14590065,-0.2954224),vec4(0.2855109,-0.14863637,0.20284033,0.06268032),vec4(-0.11678681,-0.14075714,0.43916297,0.016037256)) * bufB[4] + mat4(vec4(0.20269407,0.021733548,-0.0681778,0.25971788),vec4(-0.26738515,0.68169755,0.35620984,-0.190235),vec4(0.3213013,0.28769746,-0.25336438,0.1083498),vec4(0.19605614,-0.15638728,0.1334298,0.31826347)) * bufB[5] + mat4(vec4(-0.17517084,0.3810441,0.020516347,-0.013717265),vec4(0.09277243,-0.26943398,-0.13239384,0.026409714),vec4(0.014732826,-0.74628204,-0.19169205,-0.20128135),vec4(0.15771654,-0.11861967,0.040041417,-0.015573998)) * bufB[6] + mat4(vec4(-0.18632315,-0.15313783,-0.08739286,0.0748522),vec4(0.28082618,-0.4500328,-0.42252064,0.11073508),vec4(-0.077689335,0.10632075,0.31864598,-0.07647105),vec4(0.045980375,-0.06280395,0.18121065,-0.037435103)) * bufB[7] + in1;\nbufA[2] = vec4(0.13143983,0.14747304,-0.17766215,0.03561626) + mat4(vec4(-0.45263684,0.1705468,0.10960758,0.029965393),vec4(0.10589975,0.16168009,0.18012485,-0.06411419),vec4(-0.043377563,0.027379816,0.2443239,0.022399059),vec4(-0.08176937,-0.49744064,0.21258186,-0.33591878)) * bufB[0] + mat4(vec4(-0.14645503,-0.065130934,0.15383807,-0.37180302),vec4(0.5474147,0.24562031,-0.48085248,0.37564552),vec4(0.20888071,-0.22092627,0.23222296,-0.38278517),vec4(-0.18892635,0.2516972,0.22313146,-0.13327034)) * bufB[1] + mat4(vec4(-0.040351238,-0.11513816,0.21945672,0.09990152),vec4(-0.059774917,-0.48874235,0.11346494,0.47825384),vec4(0.14432165,0.0053925687,-0.11955587,-0.09568975),vec4(-0.35761625,0.0084802415,0.193548,0.2849898)) * bufB[2] + mat4(vec4(0.001148792,-0.043779206,-0.06728981,0.19054863),vec4(-0.21853386,-0.01189239,-0.32867748,0.08574441),vec4(-0.22259985,0.12867482,0.29347616,0.20699392),vec4(0.37651983,0.18354344,-0.22224416,-0.23622917)) * bufB[3] + mat4(vec4(-0.41418472,-0.20327628,0.4402631,0.2315247),vec4(0.14251547,0.2752894,-0.22665744,0.005916671),vec4(-0.013876162,-0.0634179,-0.0141456295,-0.5953048),vec4(0.01870352,-0.2810214,-0.009725695,0.017287942)) * bufB[4] + mat4(vec4(-0.05749252,-0.08308094,0.1757652,0.04494496),vec4(0.064160526,-0.087537654,0.37589404,-0.20041895),vec4(0.44184297,0.16912378,-0.11545738,-0.21803358),vec4(0.15075652,0.113414586,-0.10059908,-0.2116406)) * bufB[5] + mat4(vec4(0.10306412,-0.64576,-0.35262892,0.30318746),vec4(-0.046933036,0.15681131,-0.16879807,-0.4446104),vec4(-0.09333185,0.23584147,-0.005474396,0.10365222),vec4(-0.2738935,0.011856651,0.3491932,-0.15212244)) * bufB[6] + mat4(vec4(0.03483382,-0.21123879,0.13440426,0.23049149),vec4(0.15495896,-0.30268908,0.24178481,-0.014256568),vec4(0.009865945,-0.14832763,-0.10609698,0.15173239),vec4(-0.004026845,0.0030456712,-0.38411477,0.18286954)) * bufB[7] + in2;\nbufA[3] = vec4(-0.2507136,-0.018631166,0.20475024,0.20204812) + mat4(vec4(-0.120029956,-0.13418536,-0.390318,-0.01881051),vec4(-0.08958042,0.2913415,0.4374843,-0.3107137),vec4(-0.3008801,-0.05352455,0.0042052804,-0.14940801),vec4(-0.0014347276,-0.03704615,0.0056503573,-0.08936384)) * bufB[0] + mat4(vec4(-0.44316337,0.07314374,-0.09050141,0.049703155),vec4(-0.12502575,-0.012918857,0.58263844,0.5205919),vec4(0.29021525,0.08981398,-0.25362003,-0.34614003),vec4(0.008656493,-0.022870695,0.44676635,0.10766449)) * bufB[1] + mat4(vec4(0.38842747,0.2113921,0.38049877,-0.06990956),vec4(0.73278576,-0.07387523,-0.3789866,-0.36571082),vec4(-0.093960844,0.10297372,-0.370141,0.03672461),vec4(-0.4096168,0.033614457,0.16003694,-0.083808646)) * bufB[2] + mat4(vec4(0.18712977,0.103269294,-0.78829867,0.049221907),vec4(-0.0928036,-0.35160872,-0.028524535,0.06735653),vec4(-0.05917207,-0.08240987,-0.08919967,-0.03273156),vec4(-0.0015039014,-0.216372,-0.039720796,0.020236207)) * bufB[3] + mat4(vec4(-0.48083952,-0.23837337,-0.08021028,-0.19128609),vec4(0.14027838,-0.30582166,-0.11265524,-0.12928717),vec4(0.025078295,-0.036102325,-0.08579277,-0.29105344),vec4(-0.22349226,0.2807179,0.11516885,-0.045066506)) * bufB[4] + mat4(vec4(0.021395063,0.5758559,0.103631705,-0.14434262),vec4(-0.14578487,-0.3499335,-0.22572966,-0.11698603),vec4(0.39794004,-0.022916682,0.044263255,-0.11403629),vec4(0.053456627,-0.32778162,0.25982597,-0.395703)) * bufB[5] + mat4(vec4(-0.12019128,0.4657743,0.13268101,0.19896238),vec4(0.029746886,-0.391368,0.12554039,0.21150002),vec4(-0.38929784,-0.003892593,0.07064363,-0.25060606),vec4(0.42473042,-0.14839105,0.035136417,-0.31732154)) * bufB[6] + mat4(vec4(-0.415584,-0.28032658,0.28782246,-0.19373514),vec4(0.333353,0.0065670367,-0.19926971,-0.122275315),vec4(0.09570035,0.034824766,-0.004879635,0.013365656),vec4(0.11803416,0.14455132,-0.18801984,0.12097859)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.09181345,0.07529612,-0.19043925,-0.027964355) + mat4(vec4(0.12890849,-0.120982975,-0.06425728,0.37993723),vec4(-0.3046395,0.27366626,-0.06664109,0.042783238),vec4(-0.2015792,-0.16251579,0.24749449,-0.38181633),vec4(-0.45313638,0.07135942,-0.59324545,-0.03549839)) * bufB[0] + mat4(vec4(0.5295076,-0.21500231,-0.073115654,0.06626924),vec4(-0.3904776,-0.06229657,0.0065861596,0.033442605),vec4(0.14565006,-0.024179645,-0.33537433,0.1533061),vec4(-0.12051456,0.10236547,0.2654139,-0.043784074)) * bufB[1] + mat4(vec4(-0.1379835,-0.021666463,-0.10220279,-0.0490028),vec4(0.57628715,-0.12099353,-0.44923073,0.21000975),vec4(0.11357104,0.40783653,0.0039942246,-0.3499858),vec4(-0.3452912,-0.14405818,-0.17110592,0.23504475)) * bufB[2] + mat4(vec4(-0.009208328,-0.64794856,0.19041209,-0.32566902),vec4(-0.5090461,0.24553953,0.5065528,0.037693944),vec4(-0.028611194,0.0536158,0.06659824,0.034171622),vec4(0.21345899,0.1992491,-0.20295773,0.27157527)) * bufB[3] + mat4(vec4(-0.13989455,-0.46005937,0.3344976,-0.1411326),vec4(-0.5786241,0.0662675,0.5585023,0.001491266),vec4(-0.29423153,0.19074652,-0.09570268,-0.08531847),vec4(-0.047774028,0.14956146,-0.010742817,-0.14287199)) * bufB[4] + mat4(vec4(-0.044266388,-0.32163256,-0.2613107,0.35324088),vec4(0.37385154,0.055534914,0.15256156,-0.35447642),vec4(-0.15119645,-0.64618367,-0.22272147,-0.10221635),vec4(-0.09945271,0.030452164,-0.5680745,-0.07089461)) * bufB[5] + mat4(vec4(0.17875974,0.20708227,0.09577247,0.13725509),vec4(0.30809784,0.20032012,0.07602576,-0.5820048),vec4(0.110668235,0.38959008,0.21771273,-0.09196749),vec4(-0.3592196,-0.39537045,0.21434143,-0.011516374)) * bufB[6] + mat4(vec4(0.2608313,0.015311471,-0.21548086,-0.28657404),vec4(0.40588892,-0.0057934946,-0.054983985,-0.011651459),vec4(-0.048688218,0.0021460128,0.2685754,-0.19537503),vec4(0.3105335,0.13260895,-0.101146504,0.02841707)) * bufB[7];\nbufA[1] = vec4(-0.15353884,-0.12178243,0.0360533,-0.24478826) + mat4(vec4(0.1320547,0.80818045,-0.47731444,0.28487802),vec4(0.532977,0.2897515,-0.3031444,-0.19255014),vec4(-0.29260707,-0.49645844,0.32679313,0.15920582),vec4(0.11889599,-0.07390466,-0.101687066,-0.46725568)) * bufB[0] + mat4(vec4(-0.018380651,-0.15319867,0.5580352,-0.110911876),vec4(0.034987014,0.2946623,0.15832166,0.011450243),vec4(0.18900502,0.3599346,-0.39390773,0.43248647),vec4(0.3434454,-0.11127413,-0.15753193,-0.11876175)) * bufB[1] + mat4(vec4(-0.16121316,0.10543142,-0.41614717,0.0021924563),vec4(-0.16893208,0.21587217,0.12786984,0.33392432),vec4(0.22283244,-0.1166173,-0.042606037,0.27551565),vec4(0.6400831,-0.06808569,-0.17895542,0.1894886)) * bufB[2] + mat4(vec4(0.12178521,-0.19968659,-0.26355422,0.43139043),vec4(0.11885758,-0.27708146,-0.15668996,0.10620617),vec4(-0.14174816,0.39320853,0.3140953,-0.106494024),vec4(-0.5937846,-0.15295768,-0.23198742,-0.49097094)) * bufB[3] + mat4(vec4(-0.0125174895,-0.37230328,0.1843559,0.46740082),vec4(-0.007184302,0.06749822,-0.1928046,-0.24720833),vec4(-0.10693307,0.100345455,-0.2405602,0.08547994),vec4(-0.21137942,-0.12166274,0.0115421545,-0.22650665)) * bufB[4] + mat4(vec4(-0.45106497,-0.5520832,0.25929093,0.03490057),vec4(-0.10993066,-0.057019312,0.055738173,-0.062407054),vec4(0.54291844,-0.34026048,0.44998035,0.6527114),vec4(0.29791665,0.30088764,0.06024492,-0.05119476)) * bufB[5] + mat4(vec4(0.63325655,0.16383347,-0.068593755,-0.18065405),vec4(-0.24419636,0.03830839,-0.52699596,-0.06654682),vec4(-0.2119334,0.01136772,-0.41499567,-0.09759301),vec4(-0.15236305,-0.30314702,0.19297507,-0.076037794)) * bufB[6] + mat4(vec4(-0.45763144,0.21670306,0.3631592,-0.329224),vec4(0.054015912,0.2032686,-0.3088055,0.13612384),vec4(0.085463405,0.29442853,-0.12476324,-0.21780252),vec4(-0.38533992,0.051313043,-0.12690485,0.15212244)) * bufB[7];\nbufA[2] = vec4(-0.09504442,0.1252901,0.15360054,0.17767715) + mat4(vec4(-0.12499312,0.5199809,-0.37618804,0.16622946),vec4(-0.61413115,0.03983166,0.3148479,-0.10408164),vec4(0.15712142,0.25582045,-0.008174954,0.26801768),vec4(-0.19514458,0.2861607,0.3116919,0.16985752)) * bufB[0] + mat4(vec4(-0.06586392,0.110143445,0.11279528,0.08334031),vec4(-0.34534332,-0.04724278,-0.134565,-0.37049007),vec4(0.04140439,-0.14189126,-0.26528823,-0.043405358),vec4(-0.2566311,0.46275124,-0.22288443,-0.0058596777)) * bufB[1] + mat4(vec4(-0.26966828,0.052220833,-0.092896916,0.08546594),vec4(0.22222209,0.35022452,-0.13018124,0.07361649),vec4(0.473589,0.13086355,-0.13033992,-0.16475762),vec4(-0.39506555,0.13099481,0.84425706,0.25862536)) * bufB[2] + mat4(vec4(0.07956671,-0.085409686,0.17913468,-0.1819155),vec4(-0.27614072,-0.3436546,-0.2181973,-0.07253599),vec4(-0.2727466,0.13194521,-0.51698625,0.35611048),vec4(-0.60142046,0.113036886,-0.17244667,-0.2878965)) * bufB[3] + mat4(vec4(0.34847072,0.3363814,-0.20007357,0.11698274),vec4(0.33796018,0.023452403,0.2899619,-0.2008934),vec4(-0.019173605,-0.030584915,-0.06840266,0.2431719),vec4(-0.5459338,0.15459369,0.24755585,0.24090171)) * bufB[4] + mat4(vec4(0.16538754,0.16069783,-0.15038477,-0.17804559),vec4(-0.09554629,0.25951385,0.19777273,0.0032606972),vec4(-0.102054924,0.22652067,0.015139295,0.4795309),vec4(-0.020438274,-0.4962088,-0.04237311,0.1762743)) * bufB[5] + mat4(vec4(0.40690148,-0.14291288,-0.40186924,-0.1822104),vec4(0.17001194,0.072884284,-0.38113102,-0.49164224),vec4(0.25810462,0.31339478,0.0087625235,-0.34238774),vec4(0.43927127,-0.029841674,0.15442021,-0.03609715)) * bufB[6] + mat4(vec4(-0.35960934,0.16641487,0.08738858,-0.19812664),vec4(0.24599887,-0.6484395,-0.00363422,-0.2186445),vec4(-0.28951392,0.086208306,-0.15415974,-0.014822642),vec4(0.1558909,-0.00026534175,-0.34794337,-0.08669574)) * bufB[7];\nbufA[3] = vec4(-0.16355683,0.011897431,-0.10659852,-0.028323796) + mat4(vec4(-0.16479528,-0.19177933,0.5810059,-0.12017804),vec4(0.25283217,-0.30150884,-0.0193744,0.2855069),vec4(-0.39398396,-0.067963704,0.11693287,0.01061751),vec4(-0.22489057,0.124186315,-0.38439262,-0.18080784)) * bufB[0] + mat4(vec4(-0.02929706,0.09989566,0.04992713,-0.27060056),vec4(0.022651803,-0.2859927,-0.017749164,-0.46959773),vec4(-0.06746996,0.12776287,0.1418473,0.0024974518),vec4(-0.48934412,-0.30031136,0.12081329,-0.36335376)) * bufB[1] + mat4(vec4(-0.2175315,-0.20576715,0.108237356,-0.5541207),vec4(-0.2335451,-0.28267342,-0.08784964,0.1103547),vec4(0.7134224,0.17406602,0.06750715,0.092854805),vec4(-0.14441092,-0.19619846,0.30260724,0.4639469)) * bufB[2] + mat4(vec4(0.08405867,-0.08943122,0.08017332,-0.0804879),vec4(-0.44670674,0.008592037,-0.19784483,-0.32713526),vec4(-0.46644238,-0.43424296,0.13214947,-0.5004886),vec4(-0.14980148,-0.49599355,-0.36700526,-0.16869222)) * bufB[3] + mat4(vec4(-0.27612936,-0.23638992,-0.4010204,-0.28021014),vec4(0.1601196,0.6322402,0.7123485,-0.17359215),vec4(-0.3527564,0.14706616,0.17029154,-0.034406908),vec4(-0.68515736,-0.26389062,-0.38042977,0.33976787)) * bufB[4] + mat4(vec4(-0.10290578,0.22257277,0.2188344,0.23875448),vec4(-0.045465358,0.15157712,0.04838596,0.3241531),vec4(-0.10876603,-0.7411443,-0.22684681,0.35144317),vec4(0.2893747,0.10632406,-0.019262202,0.14777623)) * bufB[5] + mat4(vec4(-0.050431013,-0.060341917,0.3155954,-0.012604104),vec4(0.015990753,-0.10285018,-0.057440493,-0.4147573),vec4(0.47516316,-0.1227981,0.10654926,-0.2598722),vec4(0.25104403,0.23437166,-0.07080585,0.005113471)) * bufB[6] + mat4(vec4(0.077675916,0.5388046,-0.023109281,-0.04186147),vec4(-0.21319094,-0.027809115,-0.22664104,-0.2753854),vec4(-0.26313767,0.0054403017,0.41293195,-0.18958256),vec4(0.46660474,-0.17706892,0.2837293,-0.31779295)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.024496606,0.033880793,0.05452386,-0.16296972) + mat4(vec4(0.30252865,-0.15569238,-0.20530717,-0.38597363),vec4(-0.06814426,0.4141512,0.027027335,-0.3473715),vec4(-0.65089786,-0.076505795,0.14998284,0.3438439),vec4(-0.030385893,0.061261866,0.037197478,-0.060976267)) * bufB[0] + mat4(vec4(0.15231276,0.030542415,-0.08532395,0.16956355),vec4(0.5824213,0.5039652,-0.22795218,-0.049129877),vec4(0.049143396,-0.2085363,-0.28382343,-0.6624549),vec4(0.38415176,0.06692764,-0.6488085,0.32465732)) * bufB[1] + mat4(vec4(-0.10140947,-0.30436787,-0.23051928,0.14050885),vec4(0.22679566,0.0023323928,0.09603455,-0.09306697),vec4(0.21854103,0.38869238,0.24022737,-0.051774226),vec4(-0.016612304,-0.072957486,-0.18298864,0.032149136)) * bufB[2] + mat4(vec4(-0.12255158,0.20935026,0.07892955,0.54263085),vec4(-0.5907238,-0.006656524,0.22673295,0.08793034),vec4(0.27151397,0.29134968,-0.44789472,-0.1711934),vec4(-0.09469861,0.6354978,0.0617378,0.2063755)) * bufB[3] + mat4(vec4(-0.26769963,-0.25101113,0.22885174,-0.53895664),vec4(0.24477956,-0.17705448,-0.6960209,0.28960532),vec4(0.068414934,-0.18952271,0.44375178,-0.12650082),vec4(0.089561835,-0.08950067,-0.23494811,0.3916243)) * bufB[4] + mat4(vec4(-0.20084706,0.28127357,-0.13694644,0.37882555),vec4(0.11349211,-0.04830086,0.6474002,0.27977735),vec4(0.50772834,0.38838136,0.06927476,0.049793556),vec4(-0.038990766,-0.4928339,-0.1250321,-0.09389307)) * bufB[5] + mat4(vec4(-0.7565399,-0.23156534,-0.019750088,-0.050509125),vec4(-0.150151,-0.012951543,-0.42643258,0.012223125),vec4(-0.49666816,0.32657087,0.46931607,-0.29526487),vec4(0.24879473,-0.36886656,-0.4779592,0.21335159)) * bufB[6] + mat4(vec4(-0.03400546,-0.045528516,-0.13601686,0.21295868),vec4(-0.33970967,0.09568116,-0.06711718,0.09106673),vec4(0.07838937,-0.155382,-0.28053126,0.22902775),vec4(-0.28420693,-0.17056668,0.24398461,-0.1788941)) * bufB[7];\nbufA[1] = vec4(0.005760898,0.18759179,-0.022935228,-0.052253168) + mat4(vec4(0.22411975,0.013203131,0.40411663,0.21350998),vec4(-0.039556533,-0.45447287,-0.24623665,-0.12521175),vec4(0.18121092,-0.3700233,-0.13659883,-0.4127361),vec4(-0.2579387,-0.13378865,0.1829868,0.06327549)) * bufB[0] + mat4(vec4(0.16459098,-0.13304669,-0.17538488,0.08701383),vec4(-0.1926596,-0.0016408232,0.20289126,-0.0013199493),vec4(0.42821723,0.13806039,-0.57906383,0.115142964),vec4(0.23992567,-0.51003623,-0.34033078,0.33084115)) * bufB[1] + mat4(vec4(0.07448867,-0.21856816,-0.15351896,-0.17534265),vec4(-0.013604652,0.40790156,0.11411697,0.043979377),vec4(0.34493792,0.49868083,0.33521342,0.08744905),vec4(0.06018562,0.033271916,-0.07026209,-0.11710436)) * bufB[2] + mat4(vec4(-0.14486597,-0.124838606,-0.41920808,0.050703757),vec4(-0.20143074,-0.31326228,0.4319874,-0.5466026),vec4(-0.07971292,-0.08627304,0.010460933,-0.22998042),vec4(0.04378075,0.17028186,-0.2122213,0.051467843)) * bufB[3] + mat4(vec4(0.25118822,0.47611505,0.3334587,0.13286954),vec4(0.38348082,0.43215707,0.03283098,0.20024735),vec4(-0.418521,0.10043987,0.41337606,-0.12569334),vec4(0.11249145,-0.057141624,-0.1389418,-0.13131587)) * bufB[4] + mat4(vec4(0.20850272,0.47397432,0.106392786,-0.081098996),vec4(0.29317474,-0.04906584,-0.23130764,-0.29359263),vec4(-0.43207434,0.063481465,0.11718958,0.28293562),vec4(0.18704967,-0.08669536,0.38630944,-0.35757208)) * bufB[5] + mat4(vec4(-0.11610149,-0.27635458,-0.45258808,-0.71392775),vec4(0.31588638,-0.051937092,0.14068478,0.099649064),vec4(-0.1840024,0.080724604,-0.20311017,-0.5683546),vec4(0.4870221,-0.5210039,-0.2921363,0.024645086)) * bufB[6] + mat4(vec4(-0.045589395,-0.5333316,-0.16316156,-0.070298046),vec4(-0.056514155,0.27837873,-0.034569185,-0.40998745),vec4(-0.41402873,-0.11292576,0.2828321,-0.2006007),vec4(-0.36916202,-0.05519452,-0.43363872,-0.38052425)) * bufB[7];\nbufA[2] = vec4(-0.031991858,-0.10220299,-0.06194924,0.18424553) + mat4(vec4(0.39099088,0.16810805,0.5332972,-0.4674284),vec4(0.12238164,0.8718114,-0.23336172,-0.5569416),vec4(-0.26929277,0.41208464,0.06658154,-0.07813234),vec4(-0.10038776,-0.14476782,0.05146917,-0.20075895)) * bufB[0] + mat4(vec4(-0.15379053,-0.109054685,-0.040879358,-0.19889534),vec4(0.23107,-0.08224465,-0.09791026,0.18448506),vec4(-0.010092222,-0.043486513,-0.32908586,-0.21783629),vec4(0.11326673,-0.010522811,-0.16624561,0.026313255)) * bufB[1] + mat4(vec4(-0.10890974,0.29679155,0.56940216,-0.3277906),vec4(-0.17454867,0.20611458,-0.43624607,0.07055296),vec4(-0.47802794,-0.01981226,-0.21173191,0.4005046),vec4(-0.1293844,-0.24252675,-0.19305852,0.36483786)) * bufB[2] + mat4(vec4(-0.13934116,0.23296733,0.26263732,-0.24252416),vec4(-0.4906778,-0.28373653,0.14980754,0.45120564),vec4(-0.53890187,-0.0033793354,-0.25689837,0.2931405),vec4(-0.4506892,0.1449997,-0.13987331,-0.14682227)) * bufB[3] + mat4(vec4(-0.33171338,-0.31591636,0.031881418,0.07701439),vec4(0.23004924,-0.17159118,-0.50079703,0.18093586),vec4(0.46333313,0.19530448,0.174344,-0.0814147),vec4(-0.19972706,0.12919095,0.11832699,0.106560275)) * bufB[4] + mat4(vec4(-0.41167542,0.076562144,-0.46207947,0.14778581),vec4(0.25834835,-0.3788336,-0.27617523,0.13259101),vec4(0.10669818,-0.43503213,-0.27901828,0.17974576),vec4(0.001712698,-0.07469301,0.5547645,-0.3226843)) * bufB[5] + mat4(vec4(-0.42184234,0.07385454,0.09358669,-0.013457105),vec4(0.3253635,-0.43672597,-0.4855812,0.01846934),vec4(-0.30387133,-0.17809345,-0.0015105588,0.06429362),vec4(-0.039438695,0.059081376,0.30632934,-0.24446163)) * bufB[6] + mat4(vec4(0.3040184,0.4767081,-0.08962811,-0.27890423),vec4(-0.43682465,0.08091687,0.33867326,0.39501128),vec4(-0.36033407,0.28629524,-0.1929965,-0.2987556),vec4(-0.02323354,0.011411201,0.040802654,0.2839534)) * bufB[7];\nbufA[3] = vec4(0.06812802,0.21306793,-0.09187165,0.0014811365) + mat4(vec4(-0.32617164,-0.49387434,0.17583385,-0.42701188),vec4(0.30405942,-0.1740978,-0.04143782,0.07816047),vec4(-0.5387887,0.0012624692,0.46840012,-0.25314012),vec4(-0.13802887,-0.45681065,-0.119175375,0.028738905)) * bufB[0] + mat4(vec4(0.060228158,-0.10556925,0.16654006,0.6638538),vec4(0.05485874,-0.39855692,0.13663423,0.23222299),vec4(-0.014726624,0.70407635,-0.23664173,-0.14719412),vec4(-0.3518371,-0.49670464,0.16874889,0.27456918)) * bufB[1] + mat4(vec4(-0.79448014,0.22807282,0.09187802,0.21333103),vec4(0.14548455,-0.15190983,-0.16276929,0.07572969),vec4(0.13784158,-0.17110232,0.16533701,0.2454359),vec4(0.12236268,0.45773298,-0.35280958,0.11910894)) * bufB[2] + mat4(vec4(-0.27915037,-0.37890998,0.63731796,0.28841472),vec4(0.028767329,-0.45548657,0.16018671,-0.13969596),vec4(0.085373595,-0.28651285,0.36372805,0.2683212),vec4(0.008502142,-0.10424481,-0.45893532,-0.024252327)) * bufB[3] + mat4(vec4(-0.2419008,0.31681615,-0.4142246,-0.20473737),vec4(-0.45274252,-0.12641603,0.057502244,0.57026964),vec4(-0.103888474,-0.37603092,0.21052147,-0.05121751),vec4(-0.20546596,0.06598793,0.13217556,-0.25674492)) * bufB[4] + mat4(vec4(-0.39738193,-0.14576675,-0.017521007,-0.2332054),vec4(-0.14891993,0.27803272,-0.32895225,-0.22599725),vec4(-0.748537,-0.23086907,-0.14791021,0.45115268),vec4(0.2549656,0.115276724,-0.7009646,-0.6372781)) * bufB[5] + mat4(vec4(0.5524592,0.31804556,0.19996653,0.17258222),vec4(-0.32652697,0.12738633,0.13528128,0.27950537),vec4(0.14774938,-0.12109815,-0.281999,-0.22611459),vec4(0.286462,0.06087443,0.35098982,0.26577708)) * bufB[6] + mat4(vec4(-0.18210015,-0.09069933,0.54656184,0.40505522),vec4(-0.6242504,-0.25425178,-0.09131591,-0.1338198),vec4(-0.069763005,-0.41987947,0.091994,0.055603527),vec4(0.22416295,-0.004028949,0.09300441,-0.15915234)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.13644008,0.03986348,0.12060612,-0.08840298) + mat4(vec4(-0.38450116,0.13151121,-1.0089086,-0.2641864),vec4(-0.24602251,0.10188656,-0.24078174,0.05747213),vec4(0.30423978,-0.05476596,0.67285895,0.04859093),vec4(-0.6280035,0.39423224,-0.38153484,0.5251349)) * bufB[0] + mat4(vec4(-0.36846992,0.3757312,-0.46157008,-0.019140994),vec4(0.34156418,0.27001917,0.3771071,-0.16260305),vec4(0.20071767,-0.060624294,0.13384351,0.33310387),vec4(-0.091895364,0.21314931,-0.32506943,-0.16876537)) * bufB[1] + mat4(vec4(-0.15670738,0.2453369,0.06721401,-0.17526716),vec4(-0.3151986,-0.3348108,0.05132371,0.06310323),vec4(0.21573605,-0.13768524,-0.54282707,0.12277574),vec4(-0.1610648,-0.24947335,0.30795714,0.321663)) * bufB[2] + mat4(vec4(-0.23235881,-0.23769872,-0.03522131,-0.4269328),vec4(0.4305997,0.32942608,0.38496605,0.1305047),vec4(0.116733156,-0.31417236,0.016556688,-0.11064256),vec4(0.1578267,0.0512639,-0.043598697,-0.28071365)) * bufB[3] + mat4(vec4(-0.029777808,-0.21977587,-0.12480789,-0.31228998),vec4(-0.02883152,-0.17697391,0.30852452,0.2573945),vec4(0.08133614,0.17180659,-0.46838197,-0.7125852),vec4(0.17762452,0.21044949,0.73175246,0.16933866)) * bufB[4] + mat4(vec4(0.039922506,0.5528827,0.33019355,0.19906059),vec4(0.07320689,-0.0023268128,-0.09309802,-0.12845896),vec4(-0.47409078,0.8569203,-0.29659694,-0.09998653),vec4(0.38173085,-0.22862114,0.37742427,0.26518247)) * bufB[5] + mat4(vec4(-0.016130088,-0.13085242,-0.168194,0.22797477),vec4(-0.3489834,-0.07190295,0.0023713168,0.23127493),vec4(-0.11322908,0.20409805,-0.43298844,-0.4094399),vec4(-0.43010697,0.112430885,-0.07106092,-0.03422905)) * bufB[6] + mat4(vec4(0.467893,-0.35348877,-0.14366545,0.09024799),vec4(-0.30307302,-0.06548621,-0.32382905,-0.13100484),vec4(0.406212,-0.6113935,0.26839328,-0.15188143),vec4(-0.30937874,0.08310005,-0.58730984,-0.24629402)) * bufB[7];\nbufA[1] = vec4(0.24673875,0.27996972,0.0055293967,-0.122196056) + mat4(vec4(0.022189906,-0.14371257,0.5611908,0.065418504),vec4(0.11005351,-0.48264563,-0.41628823,0.102862805),vec4(0.33955878,0.07741006,-0.31971937,-0.46458545),vec4(-0.2638927,-0.14843339,-0.5881345,-0.11567209)) * bufB[0] + mat4(vec4(0.30779412,0.0019526058,0.20608957,0.12571281),vec4(1.010894,0.048111875,-0.342747,-0.23996896),vec4(0.011772935,-0.3268774,0.2757525,-0.307371),vec4(0.10292512,-0.07784224,0.29279882,0.26395395)) * bufB[1] + mat4(vec4(0.098323345,-0.5224365,0.6096349,0.6161378),vec4(-0.4596376,-0.18027203,0.037693057,0.50176376),vec4(-0.30165595,-0.037435994,0.17282015,0.45704415),vec4(0.34883943,-0.20561397,0.004491746,-0.14218578)) * bufB[2] + mat4(vec4(-0.09743747,-0.24372688,0.6970004,-0.3765516),vec4(0.74128455,0.7028856,0.07734595,0.10005596),vec4(-0.6040184,-0.03617321,0.0051107113,0.092650816),vec4(-0.43253833,-0.3557573,0.0015883791,-0.11251628)) * bufB[3] + mat4(vec4(-0.06849013,0.26132095,-0.75469446,0.73245406),vec4(-0.107496046,0.26843086,0.11917089,0.21858616),vec4(-0.16989131,-0.15844639,0.0039397385,-0.15422252),vec4(-0.25965667,-0.048733823,0.31205943,0.7283579)) * bufB[4] + mat4(vec4(0.46578163,0.5258436,-0.14740127,-0.21308997),vec4(0.26503915,0.042966653,-0.09663048,0.1296083),vec4(0.29092956,-0.08764995,0.2623495,-0.032943256),vec4(-0.09956309,0.08716821,-0.04167968,-0.09625686)) * bufB[5] + mat4(vec4(0.37721753,0.039999537,-0.6780426,-0.18005024),vec4(-0.7632612,-0.3847994,0.24394369,-0.07029093),vec4(0.91243905,-0.09196306,0.22605135,0.38826537),vec4(0.63505876,0.21966131,-0.03816108,-0.0030571718)) * bufB[6] + mat4(vec4(-0.15052459,0.09201173,0.20939964,-0.077035226),vec4(0.79142565,-0.36464477,-0.09322584,-0.43194684),vec4(-0.73133,0.051003713,0.358536,-0.41553918),vec4(0.12389747,-0.33983856,-0.27714342,0.44536722)) * bufB[7];\nbufA[2] = vec4(-0.0149298515,0.16497609,-0.062838,0.031034065) + mat4(vec4(0.19322465,-0.27903834,0.14712404,0.008411297),vec4(0.41746935,-0.10804673,0.44855228,-0.37639114),vec4(0.20066506,0.631689,0.11377411,-0.111599125),vec4(0.20334278,0.37468,0.08705128,0.051505532)) * bufB[0] + mat4(vec4(-0.30302006,-0.14688605,-0.26480523,-0.2989817),vec4(0.04357295,0.120794825,-0.33471408,-0.22478154),vec4(0.23940915,-0.30461195,-0.14393029,-0.21516249),vec4(-0.15549543,-0.21433383,-0.13744725,-0.4632706)) * bufB[1] + mat4(vec4(0.10313993,-0.092719205,0.08323702,-0.0338011),vec4(-0.01837971,0.043036733,-0.10507871,0.1922384),vec4(-0.02210991,0.07694558,-0.260553,0.25443295),vec4(0.50008136,0.3153499,-0.08834114,-0.35227138)) * bufB[2] + mat4(vec4(-0.14662251,0.17881325,0.07158828,0.41047058),vec4(-0.06885134,-0.1550587,-0.5297949,0.21146132),vec4(0.2538494,-0.45739892,0.19796723,0.083518066),vec4(-0.4969428,0.44075853,0.69714487,0.6410656)) * bufB[3] + mat4(vec4(0.081703246,0.25743768,-0.24577974,0.15106301),vec4(0.48718938,-0.05729885,0.079333454,0.49331754),vec4(0.22955921,-0.6372185,0.04671884,-0.05371362),vec4(-0.2080072,-0.38353112,-0.21516484,-0.6443348)) * bufB[4] + mat4(vec4(-0.10697599,0.06236792,0.2702021,0.109565765),vec4(0.042532608,0.10342015,-0.23272525,-0.13457729),vec4(-0.40548167,0.2231501,0.40407,-0.08977284),vec4(0.27078924,0.31044623,0.14917648,0.37357774)) * bufB[5] + mat4(vec4(0.025413401,-0.066298164,-0.07956674,0.0944611),vec4(0.05536626,-0.48907536,-0.20135419,0.08462546),vec4(-0.17764705,-0.35597777,0.16948871,0.22947814),vec4(0.21234202,-0.112478904,0.20957734,-0.20021985)) * bufB[6] + mat4(vec4(-0.0757193,0.13733381,-0.21321478,0.014818899),vec4(0.095765404,0.19981056,0.39179006,0.18752189),vec4(-0.45991534,-0.5267297,0.24208857,0.07266268),vec4(-0.095545135,-0.8589129,-0.2875272,-0.10382208)) * bufB[7];\nbufA[3] = vec4(0.031413868,0.046289444,-0.0010745357,0.012595109) + mat4(vec4(0.34857053,0.08924079,-0.396582,-0.17877637),vec4(-0.035733666,0.008758735,-0.074063286,0.19584295),vec4(-0.08120828,0.30344528,0.5072634,-0.47946852),vec4(0.3415655,0.28768903,-0.35574403,0.5092814)) * bufB[0] + mat4(vec4(-0.38941044,0.068882,-0.1250089,0.4154457),vec4(-0.31793442,0.3533626,0.09961668,-0.16598102),vec4(-0.4519921,0.01579286,0.3527984,-0.04096175),vec4(-0.118517324,-0.15440053,0.16773453,-0.017193506)) * bufB[1] + mat4(vec4(0.06468099,0.14432453,-0.30231783,-0.0052098436),vec4(-0.42369616,-0.25579953,-0.034707088,0.23300856),vec4(-0.12645465,0.0005103238,-0.15117174,-0.17029649),vec4(0.19076128,0.29667735,-0.054780442,0.055364266)) * bufB[2] + mat4(vec4(-0.49281242,0.64552176,-0.28141624,-0.4564281),vec4(-0.16097341,0.05021814,-0.1674425,0.10508711),vec4(0.041563626,-0.07053998,0.084094286,0.089766145),vec4(0.4089825,0.21929336,0.09621251,0.92181665)) * bufB[3] + mat4(vec4(-0.10759111,-0.17105846,-0.2398705,-0.16275313),vec4(-0.14173228,-0.34662846,-0.19033413,-0.13253224),vec4(0.14572023,-0.009692213,-0.34521165,-0.2520827),vec4(0.33789682,0.1085112,0.4727693,0.0055733025)) * bufB[4] + mat4(vec4(-0.1901519,0.088567,0.09287171,0.69342875),vec4(-0.023604665,0.22939429,-0.17224362,0.116126895),vec4(0.024081508,-0.28751957,-0.24441212,-0.31406993),vec4(0.15636304,0.1891677,-0.11771255,0.11741981)) * bufB[5] + mat4(vec4(0.053459235,0.001977569,0.2842723,-0.07886354),vec4(0.6054085,-0.18749103,0.11742437,0.2634923),vec4(0.13685071,0.26564896,-0.07839587,0.21320273),vec4(0.103594646,0.5065017,-0.333628,0.4161535)) * bufB[6] + mat4(vec4(0.09017815,-0.24094632,-0.013661493,0.62324655),vec4(-0.19035506,0.047490817,0.061181687,-0.17457949),vec4(-0.07530306,-0.45082867,0.30390993,-0.08958678),vec4(0.58181226,-0.18816712,0.1451558,0.2451909)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.008359729,0.32124224,-0.09453018,-0.006991587) + mat4(vec4(-0.09347802,0.11112163,-0.12438325,0.22559974),vec4(-0.037274703,-0.15581432,-0.08937133,-0.20541893),vec4(-0.032388955,-1.443686,-0.111201584,-0.24714732),vec4(0.057697747,-0.37883297,0.16123188,-0.028938293)) * bufB[0] + mat4(vec4(-0.25969434,1.0157162,-0.63464683,-0.18976864),vec4(0.56944674,-0.034179036,-0.19251038,0.07816577),vec4(-0.22488028,-0.07585859,-0.011720146,0.051709622),vec4(0.17914377,0.25591776,0.42877188,-0.38979876)) * bufB[1] + mat4(vec4(0.011135909,-0.10901428,0.101990394,-0.3371853),vec4(-0.52022827,-0.17014834,-0.3564037,0.0069931583),vec4(0.106993124,-0.047135334,0.041826524,0.19013765),vec4(0.21939626,-0.17504323,-0.30244058,0.28352347)) * bufB[2] + mat4(vec4(0.06009476,0.23226659,-0.29807398,-0.045420807),vec4(-0.5801345,0.26297715,-0.2761857,-0.17001805),vec4(0.32008153,-0.7403184,0.2279922,0.26977044),vec4(-0.08876187,0.3426638,0.18744892,-0.14476514)) * bufB[3] + mat4(vec4(-0.11414044,0.34896833,0.20298079,-0.076212585),vec4(-0.24759652,0.024992047,-0.14020139,0.16584307),vec4(0.19981284,0.9433071,0.15840356,-0.33513013),vec4(0.0043654814,-0.3195673,-0.20955756,0.028668135)) * bufB[4] + mat4(vec4(0.13476186,0.2518099,0.04214953,0.490023),vec4(-0.2822692,0.17274423,0.21561192,-0.13586701),vec4(-0.09574581,-0.03350149,-0.07331418,-0.4083384),vec4(-0.31496453,0.12906398,-0.2633022,0.10100087)) * bufB[5] + mat4(vec4(0.1359577,-0.2926599,-0.00081329694,-0.19682044),vec4(0.42836636,-0.108799465,0.3736294,-0.01093364),vec4(0.40503684,-0.047644924,0.22005075,0.014232597),vec4(0.15549967,-0.2620396,-0.26153523,0.28578565)) * bufB[6] + mat4(vec4(0.32708788,0.36441058,-0.34443396,0.06706482),vec4(-0.12579338,-0.2321282,0.08253584,0.1545921),vec4(0.12546954,0.010472013,-0.28060985,0.20738073),vec4(0.1313187,-0.08712431,0.28309953,0.25076586)) * bufB[7];\nbufA[1] = vec4(-0.09987806,0.14683048,0.18484181,-0.317701) + mat4(vec4(-0.5048049,0.0699725,0.16315508,-0.30661246),vec4(0.42179018,0.15769258,0.03763961,0.008941181),vec4(-0.28398153,-0.24532275,-0.11914759,0.37694433),vec4(0.4814798,0.25099233,-0.31347957,0.26181895)) * bufB[0] + mat4(vec4(0.06703999,-0.08458927,1.5517136,0.27339688),vec4(-0.2281937,0.4790028,-0.20554487,-0.45112774),vec4(0.17625794,-0.68287987,-0.52312607,0.5642941),vec4(-0.08058454,0.23168312,-0.29173872,-0.12932393)) * bufB[1] + mat4(vec4(0.00849399,-0.4788208,0.05188547,0.3065068),vec4(-0.10235431,-0.11967502,0.10506168,0.39610237),vec4(0.40605125,-0.3654121,0.1508011,-0.079017766),vec4(-0.5210228,-0.3431642,-0.11436022,0.14002234)) * bufB[2] + mat4(vec4(0.0003031136,0.37008205,0.44291094,0.13219187),vec4(0.19550876,-0.25594184,0.780998,0.03185468),vec4(0.11677523,0.24703361,-0.2522136,-0.37650016),vec4(0.5568056,0.137843,-0.23758844,0.31171453)) * bufB[3] + mat4(vec4(-0.0726723,0.6050839,0.22315174,-0.27134913),vec4(-0.13983355,-0.069896884,-0.681345,-0.19707885),vec4(0.7526665,-0.094117045,0.28884196,-0.04411886),vec4(0.301361,-0.079533294,0.054145154,0.113959774)) * bufB[4] + mat4(vec4(-0.07473748,0.315765,-0.06588472,-0.18840143),vec4(-0.21126871,-0.14610396,0.118519835,-0.42816082),vec4(-0.5165737,0.47246274,0.367553,0.15190409),vec4(-0.50595886,-0.01677877,0.2358333,-0.066750705)) * bufB[5] + mat4(vec4(-0.25847074,-0.3401468,0.29243794,-0.10876332),vec4(0.4997533,0.2307214,-0.271836,-0.38188085),vec4(-0.14035809,-0.031865224,-0.062357616,-0.18771629),vec4(-0.20004277,-0.16515815,0.16732602,0.0012846398)) * bufB[6] + mat4(vec4(-0.046095915,-0.23869099,0.18896295,0.102189675),vec4(0.11590616,0.08775084,-0.23673382,-0.016870003),vec4(0.30246335,0.30784202,-0.074115984,0.029644404),vec4(-0.38235134,0.34064633,-0.1016737,0.15590496)) * bufB[7];\nbufA[2] = vec4(0.0911137,-0.081960104,0.12099613,-0.06806274) + mat4(vec4(-0.032702573,-0.24843152,-0.32364148,0.33716738),vec4(0.16600502,0.045861404,0.5318815,-0.33931747),vec4(-0.46912086,0.05065836,0.0021614167,0.16932061),vec4(0.29447633,0.08885168,0.14124516,0.3457979)) * bufB[0] + mat4(vec4(-0.25575313,-0.7972603,0.5904923,-0.6019573),vec4(-0.24315578,0.008975327,0.050271414,0.050571166),vec4(-0.0278592,-0.12470744,0.037281137,-0.13394794),vec4(0.34562194,0.26373845,0.31584784,0.024370736)) * bufB[1] + mat4(vec4(0.14471003,-0.27172548,0.08379796,-0.39201602),vec4(-0.47385693,-0.3321742,-0.4011862,0.42760587),vec4(-0.0024613086,0.13274308,-0.1551642,0.2772444),vec4(0.0134687135,-0.020532908,-0.3937209,0.33061787)) * bufB[2] + mat4(vec4(0.26819593,0.11925997,0.03903885,-0.31611127),vec4(-0.3316611,-0.3747643,0.5062081,-0.18770258),vec4(0.2692489,-0.014831902,0.2293307,-0.13741694),vec4(0.28153315,0.29210034,0.08285669,-0.09756649)) * bufB[3] + mat4(vec4(-0.116399474,0.006395924,-0.1055291,-0.014856996),vec4(-0.19581443,-0.09367833,-0.26780424,0.46855354),vec4(0.16097689,0.44968265,0.38821062,-0.2554029),vec4(0.004573049,0.36847955,0.18683691,-0.2334498)) * bufB[4] + mat4(vec4(0.08411272,-0.25446647,-0.60635114,0.11400572),vec4(0.39433452,0.11261337,-0.053154457,0.11559163),vec4(0.35675403,-0.3740197,-0.108464226,0.097348996),vec4(-0.24480772,-0.45563343,-0.275951,0.14549726)) * bufB[5] + mat4(vec4(0.28314623,0.012745007,-0.019309215,-0.03543104),vec4(0.035005268,0.90997034,0.19655211,-0.48912588),vec4(0.37951255,0.42226335,0.18724011,-0.53677946),vec4(-0.23540343,-0.26580098,-0.2541725,0.03734841)) * bufB[6] + mat4(vec4(0.0981426,0.45311454,0.582181,-0.0055685667),vec4(0.112448774,-0.13115223,0.0015426574,0.32099214),vec4(0.29318076,0.516186,0.15565324,-0.3692148),vec4(0.07435583,0.4295489,0.18417907,0.07316759)) * bufB[7];\nbufA[3] = vec4(-0.1178584,7.1177725e-05,0.14588569,0.08331646) + mat4(vec4(-0.22337574,-0.022501117,0.079681166,0.05693774),vec4(0.086643785,0.49238312,0.60481113,-0.51057607),vec4(-0.75939333,-0.10551682,0.17187694,-0.21875165),vec4(-0.30426863,-0.28005677,0.10459874,-0.13849233)) * bufB[0] + mat4(vec4(-0.6159437,0.17198022,0.07092568,-0.41358802),vec4(-0.29806238,-0.20891893,0.38654682,0.020322947),vec4(-0.016850825,0.39103085,0.46767554,0.046101023),vec4(0.0194361,0.11094418,0.04912274,0.03905883)) * bufB[1] + mat4(vec4(0.32451627,0.16094987,-0.085924104,0.33994833),vec4(0.045537543,-0.22715046,0.051781643,0.15284751),vec4(0.19869222,-0.24021266,-0.075214624,0.028334934),vec4(0.22098295,-0.12702742,-0.18385057,0.6278619)) * bufB[2] + mat4(vec4(0.02254554,0.122380055,-0.094119795,0.20047565),vec4(0.20770602,0.94089377,-0.43632802,0.15268154),vec4(-0.4161918,-0.31312412,-0.10941354,-0.12985963),vec4(0.35738328,-0.08767692,-0.28373742,-0.025048314)) * bufB[3] + mat4(vec4(-0.31958926,0.4072608,-0.4037393,-0.29046032),vec4(-0.2264214,-0.39650595,0.280233,0.27372023),vec4(0.2897724,0.49194995,-0.24241477,-0.46331915),vec4(0.72604424,-0.08431313,0.29348442,-0.08490651)) * bufB[4] + mat4(vec4(0.06490884,-0.4209498,0.39735886,0.2678071),vec4(0.04616988,-0.27623546,-0.06466953,0.019404344),vec4(0.030641548,-0.3288183,-0.6355683,0.50378954),vec4(-0.060752325,-0.022041349,-0.3674405,0.7607354)) * bufB[5] + mat4(vec4(0.036050674,0.109297775,-0.2726729,-0.085560165),vec4(-0.09009493,0.42084748,0.0587093,-0.54211843),vec4(0.1333838,0.296694,-0.003046724,0.026884232),vec4(-0.2184997,-0.20248257,-0.23596051,0.43021423)) * bufB[6] + mat4(vec4(0.5721521,0.1475805,0.17548922,-0.035064638),vec4(-0.10575597,-0.3492974,0.22120418,0.46921697),vec4(0.13214281,-0.22948974,0.2645481,-0.070316665),vec4(0.020193623,0.17125228,0.36304837,-0.61942446)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.09659864753484726,-0.058776095509529114,0.061346184462308884,0.0) + mat4(vec4(-0.23453134298324585,-0.2182227522134781,-0.3649637699127197,0.0),vec4(-0.04259786754846573,-0.07943152636289597,0.22045154869556427,0.0),vec4(0.05897889658808708,0.16445790231227875,-0.2610852122306824,0.0),vec4(-0.02154979109764099,-0.0035010529682040215,-0.05402717366814613,0.0)) * bufB[0] + mat4(vec4(0.1609150767326355,0.1368110626935959,-0.027478255331516266,0.0),vec4(-0.10512419044971466,-0.007273986469954252,-0.20009098947048187,0.0),vec4(0.2586878538131714,0.04620569944381714,0.03255929425358772,0.0),vec4(0.09738064557313919,0.06370899826288223,-0.058780405670404434,0.0)) * bufB[1] + mat4(vec4(-0.20977310836315155,-0.22791823744773865,-0.14101840555667877,0.0),vec4(-0.3439013957977295,-0.46904483437538147,-0.5510905385017395,0.0),vec4(-0.16390211880207062,-0.23428162932395935,-0.39392855763435364,0.0),vec4(0.057054582983255386,0.18210525810718536,0.2497214376926422,0.0)) * bufB[2] + mat4(vec4(-0.06961369514465332,-0.27129530906677246,-0.40768709778785706,0.0),vec4(-0.2148783802986145,-0.16994328796863556,-0.01995101198554039,0.0),vec4(0.17170336842536926,0.15111374855041504,0.04740333929657936,0.0),vec4(-0.028913453221321106,-0.029023179784417152,-0.04471822828054428,0.0)) * bufB[3] + mat4(vec4(-0.021390536800026894,-0.01087136846035719,-0.043851587921381,0.0),vec4(0.2996104955673218,0.3052496016025543,0.09383931756019592,0.0),vec4(0.07206098735332489,0.12352744489908218,-0.000728474697098136,0.0),vec4(0.09423656761646271,0.019074145704507828,0.042043235152959824,0.0)) * bufB[4] + mat4(vec4(0.21766869723796844,0.1735689789056778,0.17662815749645233,0.0),vec4(-0.13219504058361053,-0.11321767419576645,0.008273648098111153,0.0),vec4(0.23479942977428436,0.24006500840187073,0.005287917330861092,0.0),vec4(-0.09625570476055145,-0.07017115503549576,-0.01396753266453743,0.0)) * bufB[5] + mat4(vec4(-0.13689664006233215,-0.012611398473381996,0.10360724478960037,0.0),vec4(-0.15887056291103363,-0.11684358865022659,-0.12004305422306061,0.0),vec4(0.047835495322942734,0.038180891424417496,0.007886465638875961,0.0),vec4(-0.18472781777381897,-0.2190498560667038,-0.267638623714447,0.0)) * bufB[6] + mat4(vec4(0.14622174203395844,0.056631848216056824,-0.06857673078775406,0.0),vec4(0.2215224951505661,0.19829954206943512,0.1658620685338974,0.0),vec4(0.051408153027296066,0.07151090353727341,0.057275764644145966,0.0),vec4(0.2769576609134674,0.23480260372161865,0.1637812703847885,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime), sin(2.*iTime), sin(3.*iTime), sin(4.*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 145, 145, 58662], [58664, 58664, 58721, 58771, 59195]], "test": "valid"}
{"id": "7ssGRs", "name": "Fractal 41_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 19, "viewed": 287, "published": "Public API", "date": "1616422605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,s,e,g=.1;\n        ++i<80.;\n        O.xyz+=.03*abs(cos(d+.5+log2(s)*.6))*exp(-.3*i*i*e)\n    )\n    {\n        p=g*d-vec3(.1,.2,1);\n        p.z-=1.;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=2.;\n        for(int j=0;j++<8;)\n            p-=clamp(p,-.9,.9)*2.,\n            p=p*(e=3./min(dot(p,p),1.))+q,\n            s*=e;\n            g+=e=length(p)/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.8,1.,1.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 622]], "test": "valid"}
{"id": "7ssGWS", "name": "Fork wave pract cghow 946", "author": "cghow", "description": "wave practice 01", "tags": ["wavepractice"], "likes": 1, "viewed": 24, "published": "Public", "date": "1616491975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec2 uv1 = abs(uv-.5);\n         uv1.y = pow(uv1.y,1.9);\n         uv1.y +=iTime*.5;\n         uv1.y = sin(uv1.y*10.)*.1;\n   vec3 color = mix(vec3(1.,sin(iTime*2.),sin(iTime)),vec3(0.,sin(iTime),sin(iTime*1.5)),uv1.y*5.);\n          \n    vec3 col = vec3(step(abs((uv+uv1.y)-.5).x,.002));\n    col = color*col;\n  col +=col*5.;\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 474]], "test": "valid"}
{"id": "7sSGzR", "name": "Julia Sets Over Time", "author": "sweggy", "description": "julia sets with various constants", "tags": ["fractal"], "likes": 1, "viewed": 32, "published": "Public", "date": "1616805769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 squ(in vec2 n){\n    return vec2(n.x*n.x - n.y*n.y, 2.0*n.x*n.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //uv -= vec2(13.0,6.0);\n    //uv /= 19.0;\n    uv *= 1.5;\n    \n    vec2 z = uv;\n    \n    float iter = 0.0;\n    \n    for (int i = 0; i<500; i++){\n        z = squ(z);\n        z += vec2(0.5+0.2*sin(iTime/10.0),0.5+0.2*cos(iTime/10.0));\n        iter++;\n        if (length(z) > 2.0) break;\n    }\n    \n    float c = 0.0;\n    \n    if (length(z) > 2.0) c = iter/30.0; else c = 0.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(c);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 71], [73, 73, 130, 180, 731]], "test": "valid"}
{"id": "7sSGzW", "name": "Live Coding - VCL Lab Hour", "author": "tripzilch", "description": "Final result of my 30 minute live coding session for the Virtual Care Lab / #LAB HOUR anniversary, 2021/03/28.", "tags": ["plasma", "livecoding"], "likes": 2, "viewed": 84, "published": "Public", "date": "1617023778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586 // 2 * PI\nuniform vec2 u_resolution;\nuniform float u_time;\nconst vec3 gamma = vec3(2.2);\nconst vec3 igamma = 1.0 / gamma;\n\nconst vec4 H0 = vec4(0.5138670813222691, 0.5431834938989584, 0.5741724246765705, 0.6069292917805363);\nconst vec4 H1 = vec4(0.6415549569952288, 0.678156036327837, 0.7168452282900885, 0.7577416609086309);\nconst vec4 H2 = vec4(0.8009712585325574, 0.846667129567511, 0.8949699763302439, 0.9460285282856136);\nconst vec4 R = vec4(0.632006, 0.128123, 0.223201, 0.988116);\n\nfloat wobbly(vec2 uv, float t, float seed) {\n  vec4 f = (fract(H0 * seed + R) - .5) * 4.0 + 1.0;\n  vec4 g = (fract(H1 * seed + R) - .5) * 2.0;\n  vec4 p = (fract(H2 * seed + R) - .5) * 2.0;\n  const float ma = 0.25;\n\n  vec2 a = sin((f.xy * uv + g.xy * t + p.xy) * TAU);\n  vec2 b = sin((f.zw * uv + g.zw * t + p.zw + ma * a.yx) * TAU);\n\n  return 0.5 * (b.x + b.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // this is how to get the pixels straight\n  vec2 aspect = iResolution.xy / iResolution.y;\n  vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * aspect;\n  uv *= 0.6;\n\n  float t = iTime * 0.1;\n  const float seedA = 562.0;\n  const float seedB = 845.0;\n  const float seedC = 173.0;\n\n  vec2 d = vec2(wobbly(uv, t, seedA), wobbly(uv, t, seedB));\n  float L = length(d);\n  d /= mix(1.0, L, smoothstep(.45, .4, L));\n\n  vec3 col = vec3(\n    .5 + .5 * wobbly(uv + 0.1 * d, t,  seedC),\n    .5 + .5 * wobbly(uv + 0.14 * d, t, seedC),\n    .5 + .5 * wobbly(uv + 0.18 * d, t, seedC)\n  );\n\n  float cm = (col.x + col.y + col.z) / 3.0;\n\n  col = smoothstep(0.0, 1.0, (col - cm) * 2.0 + cm);\n  float smokiness = 1.;//(.5 + .5 * sin(t * 0.5)) * 12.0 + 1.0;\n  float border = smoothstep(0.015 * smokiness,0.03 * smokiness, abs(L - 0.425));\n  col *= border;\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 519, 563, 563, 882], [885, 885, 942, 986, 1830]], "test": "error"}
{"id": "7sSGzz", "name": "4-Dimensional Ray-Marching", "author": "Zi7ar21", "description": "Ray-Marching in 4D projected onto a virtual Volumetric Display.", "tags": ["raymarching", "raymarch", "raymarched", "volumetric", "raymarcher", "4d", "4dimensional"], "likes": 4, "viewed": 215, "published": "Public API", "date": "1616822591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ####### 4-Dimensional Ray-Marching #######\n// Made by Jacob Bingham (Zi7ar21) on March 26th, 2021\n// Last Updated: March 26th, 2021 at 23:30 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the\n// original (and possibly updated version) can be found at:\n// https://www.shadertoy.com/view/7sSGzz\n\n// ##### CONSTANTS #####\n// Octuple Precision, even though Shadertoy is Full Precision (32-Bit Floating Point)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### PARAMETERS #####\n#define mousesensitivity 4.0\n#define gamma 2.2\n\n// 3D Parameters\n#define camfov 1.0\n#define maxmarches 32\n#define maxdist 4.0\n#define stepsize 0.125\n\n// 4D Parameters\n#define camfov4D 1.0\n#define campos4D vec4(0.0, 0.0, 0.0, (sin(iTime*pi*(1.0/3.0)))-1.0)\n#define maxmarches4D 32\n#define maxdist4D 4.0\n#define collisiondist 0.125\n\n// ##### RNG #####\n// RNG Utilities from Michael0884: https://www.shadertoy.com/user/michael0884\n// https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405U+2891336453U;\n    uint word = ((state>>((state>>28U)+4U))^state)*277803737U;\n    ns = (word>>22U)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\n//vec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Hash from Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash41(float p){\n\tvec4 p4 = fract(vec4(p)*vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// ##### 4D DISTANCE ESTIMATORS #####\n// Hypersphere Distance Estimator\nfloat hypersphere(vec4 raypos, vec4 sphpos, float sphrad){\n    return length(raypos-sphpos)-sphrad;\n}\n\n// Multiple Hyperspheres Distance Estimator\nfloat hyperspheres(vec4 raypos){\n    // Set-Up Variables\n    float sphere, minimum;\n\n    // Main Distance Estimator Loop\n    for(int i = 0; i < 8; i++){\n        // Compute the distance to a random hypersphere\n        sphere = hypersphere(raypos, normalize(hash41(float(i))-0.5), 0.125);\n\n        // The first sphere is the minimum of the first iteration\n        if(i == 0){minimum = sphere;}\n\n        // Find the closest sphere\n        minimum = min(sphere, minimum);\n    }\n    \n    // Return the distance to the closest sphere\n    return minimum;\n}\n\n// ##### ROTATION MATRICIES #####\n// The 4D Rotation Matrix was also made by Michael0884\n// aOb Plane Rotation\nmat4 rotplane(int a, int b, float angle){\n    mat4 rot = mat4(1.0);\n    float s = sin(angle), c = cos(angle);\n    rot[a][a] = c; rot[a][b] =-s;\n    rot[b][a] = s; rot[b][b] = c;\n    return rot;\n}\n\n// Rotation Matrix\nmat4 rotmat4D(vec4 rotation){\n    return rotplane(0, 1, rotation.x)*rotplane(1, 2, rotation.y)*rotplane(2, 3, rotation.z)*rotplane(3, 0, rotation.w);\n}\n\n// Rotation Matrix from LoicVDB\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// ##### RENDERING #####\n// 4D Ray-Marching\nvec3 raymarch4D(vec4 raydir, vec4 rayori){\n    // Put our Ray at the Camera Position\n    vec4 raypos = rayori;\n\n    // Initialize our Distance Estimator Variable\n    float distest;\n\n    // The Main Ray-Marching Loop\n    for(int i = 0; i < maxmarches4D; i++){\n        // Check if our Ray escaped the scene\n        if(length(raypos-rayori) > maxdist4D){break;}\n\n        // Find the distance from our Ray to our scene\n        distest = hyperspheres(raypos);\n\n        // Check if our Ray collided with the scene\n        if(distest < collisiondist){return vec3(1.0);}\n\n        // March our Ray\n        raypos += raydir*distest;\n    }\n\n    // If our Ray hit nothing, retuurn the Background Color\n    return vec3(0.0);\n}\n\n// 3D Screen Output Image\nvec3 mainImage4D(vec3 uv){\n    // Calculate the Direction of the Ray\n    mat4 rotmat = rotmat4D(vec4(0.0, 0.0, 0.0, 0.0));\n\n    // Render the Image\n    vec4 raydir = normalize(camfov4D*(uv.x*rotmat[0]+uv.y*rotmat[1]+uv.z*rotmat[2])+rotmat[3]);\n\n    // Output the Image to the Volumetric Display\n    vec3 color = raymarch4D(raydir, campos4D);\n    return color;\n}\n\n// 3D Raymarching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    // Put our Ray at the Camera Position\n    vec3 raypos = rayori+(raydir*rand()*stepsize);\n\n    // Initialize our Density Variable\n    vec3 density = vec3(0.0);\n\n    // The Main Ray-Marching Loop\n    for(int i = 0; i < maxmarches; i++){\n        // Check if our Ray escaped the scene\n        if(length(raypos-rayori) > maxdist){break;}\n\n        // Find the Volumetric Display's Color\n        density += mainImage4D(raypos);\n\n        // March our Ray\n        raypos  += raydir*stepsize;\n    }\n\n    // Return the total density\n    return density*0.125;\n}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Initialize RNG\n    INIT_RNG;\n\n    // Set up Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, fragCoord.xy)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse Controls\n    vec2 mouse = vec2(iTime*pi*0.25, 0.0);\n    //vec2 mouse = vec2(0.0, 0.0);\n    #ifdef mousesensitivity\n    if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n    #endif\n\n    // Calculate the Direction of the Ray\n    mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n    vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n    // Render the Image\n    vec3 color = raymarch(raydir, vec3(-sin(mouse.x)*2.0, 0.0, -cos(mouse.x)*2.0));\n\n    // Tonemap HDR\n    color = pow(color/(1.0+color), vec3(1.0/gamma));\n\n    // Output the Image to the Screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[896, 1131, 1142, 1142, 1278], [1280, 1280, 1293, 1293, 1337], [1338, 1338, 1351, 1351, 1380], [1381, 1381, 1394, 1394, 1431], [1432, 1432, 1445, 1445, 1490], [1492, 1552, 1588, 1588, 1685], [2007, 2071, 2092, 2092, 2237], [2239, 2311, 2369, 2369, 2412], [2414, 2458, 2490, 2514, 3007], [3009, 3120, 3161, 3161, 3315], [3317, 3336, 3365, 3365, 3487], [3489, 3521, 3548, 3587, 3980], [3982, 4026, 4068, 4110, 4739], [4741, 4767, 4793, 4835, 5128], [5130, 5148, 5188, 5230, 5742], [5744, 5764, 5818, 5840, 6688]], "test": "valid"}
{"id": "7sX3WN", "name": "Neon Dance", "author": "Kali", "description": "Raymarching a heightmap with fixed steps and binary search. 2D Mandelbox fractal variation used for animated coloring.", "tags": ["fractal", "terrain"], "likes": 62, "viewed": 3508, "published": "Public", "date": "1615944522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float st=.025, maxdist=15.;\nvec3 ldir=vec3(0.,-1.,-1.),col=vec3(0.);\n\nmat2 rot(float a) {\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 fractal(vec2 p) {\n    vec2 pos=p;\n    float d, ml=100.;\n    vec2 mc=vec2(100.);\n    p=abs(fract(p*.1)-.5);\n    vec2 c=p;\n    for(int i=0;i<8;i++) {\n        d=dot(p,p);\n        p=abs(p+1.)-abs(p-1.)-p;\n    \tp=p*-1.5/clamp(d,.5,1.)-c;\n        mc=min(mc,abs(p));\n        if (i>2) ml=min(ml*(1.+float(i)*.1),abs(p.y-.5));\n    }\n    mc=max(vec2(0.),1.-mc);\n    mc=normalize(mc)*.8;\n    ml=pow(max(0.,1.-ml),6.);\n    return vec3(mc,d*.4)*ml*(step(.7,fract(d*.1+iTime*.5+pos.x*.2)))-ml*.1;\n}\n\nfloat map(vec2 p) {\n    vec2 pos=p;\n    float t=iTime;\n    col+=fractal(p);\n    vec2 p2=abs(.5-fract(p*8.+4.));\n\tfloat h=0.;\n    h+=sin(length(p)+t);\n    p=floor(p*2.+1.);\n    float l=length(p2*p2);\n    h+=(cos(p.x+t)+sin(p.y+t))*.5;\n    h+=max(0.,5.-length(p-vec2(18.,0.)))*1.5;\n    h+=max(0.,5.-length(p+vec2(18.,0.)))*1.5;\n    p=p*2.+.2345;\n    t*=.5;\n    h+=(cos(p.x+t)+sin(p.y+t))*.3;\n    return h;\n}\n\nvec3 normal(vec2 p, float td) {\n\tvec2 eps=vec2(0.,.001);\n    return normalize(vec3(map(p+eps.yx)-map(p-eps.yx),2.*eps.y,map(p+eps.xy)-map(p-eps.xy)));\n}\n\nvec2 hit(vec3 p) {\n    float h=map(p.xz);\n    return vec2(step(p.y,h),h);\n}\n\nvec3 bsearch(vec3 from,vec3 dir,float td) {\n    vec3 p;\n    st*=-.5;\n    td+=st;\n    float h2=1.;\n    for (int i=0;i<20;i++) {\n        p=from+td*dir;\n        float h=hit(p).x;\n        if (abs(h-h2)>.001) {\n            st*=-.5;\n\t        h2=h;\n        }\n        td+=st;\n    }\n\treturn p;\n}\n\nvec3 shade(vec3 p,vec3 dir,float h,float td) {\n    ldir=normalize(ldir);\n\tcol=vec3(0.);\n    vec3 n=normal(p.xz,td);\n\tcol*=.25;\n    float dif=max(0.,dot(ldir,-n));\n    vec3 ref=reflect(ldir,dir);\n    float spe=pow(max(0.,dot(ref,-n)),8.);\n    return col+(dif*.5+.2+spe*vec3(1.,.8,.5))*.2;\n}\n\n\nvec3 march(vec3 from,vec3 dir) {\n\tvec3 p, col=vec3(0.);\n    float td=.5, k=0.;\n    vec2 h;\n    for (int i=0;i<600;i++) {\n    \tp=from+dir*td;\n        h=hit(p);\n        if (h.x>.5||td>maxdist) break;\n        td+=st;\n    }\n    if (h.x>.5) {\n        p=bsearch(from,dir,td);\n    \tcol=shade(p,dir,h.y,td);\n    } else {\n    }\n\tcol=mix(col,2.*vec3(mod(gl_FragCoord.y,4.)*.1),pow(td/maxdist,3.));\n    return col*vec3(.9,.8,1.);\n}\n\nmat3 lookat(vec3 dir,vec3 up) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\nvec3 path(float t) {\n\treturn vec3(cos(t)*5.5,1.5-cos(t)*.0,sin(t*2.))*2.5;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tfloat t=iTime*.2;\n    vec3 from=path(t);\n    vec3 dir=normalize(vec3(uv,.7));\n    vec3 adv=path(t+.1)-from;\n    dir=lookat(adv+vec3(0.,-.2-(1.+sin(t*2.)),0.),vec3(adv.x*.1,1.,0.))*dir;\n    vec3 col=march(from, dir)*1.5;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sX3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 144], [146, 146, 168, 168, 635], [637, 637, 656, 656, 1042], [1044, 1044, 1075, 1075, 1196], [1198, 1198, 1216, 1216, 1273], [1275, 1275, 1318, 1318, 1561], [1563, 1563, 1609, 1609, 1852], [1855, 1855, 1887, 1887, 2275], [2277, 2277, 2308, 2308, 2414], [2416, 2416, 2436, 2436, 2492], [2494, 2494, 2548, 2548, 2860]], "test": "valid"}
{"id": "7sX3z2", "name": "GridX4", "author": "Del", "description": "4 simple drop in grid distance functions - click a grid to show it as full screen\nHEX original  - https://www.shadertoy.com/view/lldfWH\nTRI original - https://www.shadertoy.com/view/4dKXR3\nOCT original - https://www.shadertoy.com/view/3tGBWV\n", "tags": ["grid", "simplex", "square", "distance", "edge", "hex", "tri", "octagon"], "likes": 9, "viewed": 194, "published": "Public API", "date": "1616260230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple Hex, Tri, Square and Ocatagonal grids - (SST)\n//\n// Feel free to optimize, golf and generally improve them :)\n//\n// Del - 20/03/2021\n\n// All 4 Grid functions return the same:\n// ret.x  - distance to border\n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n\n// simple square grid equiv\nvec4 SquareGrid(vec2 uv, out vec2 id)\n{\n    uv += 0.5;\n    vec2 fs =  fract(uv)-0.5;\n    id = floor(uv);\n    vec2 d = abs(fs)-0.5;\n    float edge = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return vec4(abs(edge),length(fs),fs.xy);\n}\n\n// Shanes ocatagonal-diamond grid equiv - https://www.shadertoy.com/view/3tGBWV \nvec4 OcatagonalGrid(vec2 uv, out vec2 id)\n{\n    vec2 guv;\n    vec2 p = uv - .5;\n    id = floor(p) + .5;\n    p -= id;\n    float d = abs(p.x) + abs(p.y) - (1. - sqrt(2.)/2.);\n    if(d<.0)\n    {\n        // inside a diamond\n        guv = fract(p-0.5)-0.5;\n        id += .5;\n    }\n    else\n    {\n        // inside an octagon\n        guv = fract(p)-0.5;\n        p = uv;\n        id = floor(p) + .5;\n        p -= id;\n        d = max((abs(p.x) + abs(p.y))/sqrt(2.), max(abs(p.x), abs(p.y))) - .5;\n    }\n    return vec4(abs(d), length(guv), guv);\n}\n\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\n// Demo 4xGrids or Let the user select a grid with mouse...\nfloat SelectGrid(float xx)\n{\n    float gridtype = 0.5;\n    float mx = ((iMouse.x-.5*iResolution.x) / iResolution.x)+0.5;\n    if (iMouse.z>0.5)\n        xx=mx;\n    if (xx>0.75)\n        gridtype=3.5;\n    else if (xx>0.5)\n        gridtype=2.5;\n    else if (xx>0.25)\n        gridtype = 1.5;\n    return gridtype;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n    float yy = ((fragCoord.y-.5*iResolution.y) / iResolution.x)+0.5;\n\n    // dirty grid switching\n    vec2 id;\n    vec4 h;\n    float zoom = 8.0;\n    if (iMouse.z>0.5)\n        zoom += sin(t);\n    float gridtype = SelectGrid(xx);\n    if (gridtype>= 3.0)\n        h = OcatagonalGrid(uv*zoom, id);\n    else if (gridtype>= 2.0)\n        h = SquareGrid(uv*zoom, id);\n    else if (gridtype>=1.0)\n        h = HexGrid(uv*zoom, id);\n    else\n        h = TriGrid(uv*zoom, id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.25,0.32,0.15);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 33.5\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre\n\n    if (iMouse.z<0.5)\n    {\n        if (uv.y < 0.0)\n            finalcol = vec3(h.x,h.x,h.x); // just show cell edge distances in bottom half of screen\n        // add some red divider lines\n        float dd = max(max( step(abs(xx-0.25),0.0025), step(abs(xx-0.5),0.0025)),step(abs(xx-0.75),0.0025));\n        dd = max(dd,step(abs(yy-0.5),0.0025));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n    }\n\n    //finalcol = vec3(h.x,h.x,h.x); // just show cell edge distance\n    //finalcol = vec3(h.zw,0.0);    // just show cell uv\n    //finalcol = vec3(h.y,h.y,h.y); // just show cell centre distance\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sX3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 359, 395, 395, 903], [905, 1118, 1154, 1154, 1712], [1714, 1742, 1781, 1781, 1980], [1982, 2063, 2106, 2106, 2601], [2604, 2604, 2646, 2646, 2687], [2689, 2749, 2777, 2777, 3057], [3059, 3059, 3116, 3116, 5172]], "test": "error"}
{"id": "7sXGD2", "name": "raymarching 213s1", "author": "csgradle", "description": "more raymarching. this is my 3rd piece", "tags": ["raymarching"], "likes": 6, "viewed": 82, "published": "Public", "date": "1616569744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 80.\n#define MIN_HIT 0.1\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 rotation(vec3 point, vec3 axis, float angle){ // https://www.shadertoy.com/view/Wtl3zN\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise3(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n// fog by inigo quilez\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float b = 0.02;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.2);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat getDist(vec3 p) {\n    float dist = MAX_DIST; \n    float node = sdOctahedron( opRep( p-vec3(0., 0., 0.), vec3(10.)), 2.5 );\n    dist = min( dist, node);\n    \n   \n    \n    vec3 pXpos = opRep( (p-vec3(5.,0.,0.)), vec3(10.));\n    vec3 pYpos = opRep( (p-vec3(0.,5.,0.)), vec3(10.));\n    vec3 pZpos = opRep( (p-vec3(0.,0.,5.)), vec3(10.));\n    \n    pXpos.yz *= rotate2d(p.x*0.5);\n    pYpos.xz *= rotate2d(p.y*0.5);\n    pZpos.xy *= rotate2d(p.z*0.5);\n    \n    float pipeX = sdBox( pXpos , vec3(4,0.5,0.5) );\n    dist = min( dist, pipeX );\n    float pipeY = sdBox( pYpos, vec3(0.5,4.,0.5) );\n    dist = min( dist, pipeY );\n    float pipeZ = sdBox( pZpos, vec3(0.5,0.5,4.) );\n    dist = min( dist, pipeZ );\n    \n    return dist;\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p);\n    vec3 n = d-vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx));\n    return normalize(n);\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\n    float rayDist = 0.;\n    for(int step = 0; step < MAX_STEPS; step++) {\n        vec3 pos = ro + rd*rayDist;\n        float distanceHit = getDist(pos);\n        rayDist += distanceHit;\n        if(distanceHit < MIN_HIT || abs(rayDist) > MAX_DIST) break;   \n    }\n    return rayDist;\n}\nvec3 getLight(vec3 p, vec3 sun) {\n    \n    vec3 n = getNormal(p);\n    float lighting = dot(n, normalize(sun-p));\n    lighting = clamp(lighting, 0., 1.);\n    \n    float d = rayMarch(p+n*MIN_HIT*1.1, normalize(sun-p));\n    if(d < length(sun- p)) {\n        lighting = lighting * 0.5;\n    }\n    \n\n    float noiseVal = (noise3((mod(p+50., 100.))*10.)+0.5)*0.5+1.;\n    vec3 brown = vec3(.4,.3,0.);\n    \n    return lighting*brown*noiseVal;\n}\nvec3 cameraPath(float t) {\n    float x = sin(t*1.)*5.;\n    float y = cos(t*1.)*5.;\n    float z = t/3.1415926*20.+5.;\n    return vec3(x,y,z);\n}\n// https://www.shadertoy.com/view/WlKBDw thank you!!\nmat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = map(iMouse.y/iResolution.y,0.,1.,1.7, 30.);\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    \n    vec3 rayOrigin = cameraPath(iTime);\n    vec3 cameraPx = vec3(uv.x, uv.y, 1.);\n    vec3 rayDir = normalize(cameraPx * lookAt(cameraPath(iTime), cameraPath(iTime+.5)));\n    rayDir.y *= -1.;\n    \n    vec3 sun = vec3(0., 0., 0.);\n    sun = rayOrigin;\n    \n    \n    float d = rayMarch(rayOrigin, rayDir);\n    if(d < MAX_DIST) {\n        vec3 p = rayOrigin+rayDir*d;\n\n        vec3 l = getLight(p, sun);\n        col = l;\n    }\n    col = applyFog(col, d);\n    // gamma correction\n    col = vec3(col.x*col.x, col.y*col.y, col.z*col.z);\n    fragColor = vec4(col*2.,1.);\n} \n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 134, 134, 200], [201, 201, 251, 292, 843], [844, 844, 872, 872, 958], [959, 1034, 1059, 1059, 1078], [1079, 1079, 1104, 1104, 1123], [1124, 1124, 1160, 1160, 1188], [1190, 1190, 1228, 1228, 1281], [1282, 1282, 1317, 1317, 1343], [1344, 1344, 1375, 1375, 1462], [1463, 1463, 1498, 1498, 1549], [1551, 1551, 1573, 1573, 1712], [1713, 1798, 1820, 1820, 2224], [2225, 2225, 2247, 2247, 2292], [2293, 2293, 2313, 2313, 2358], [2359, 2359, 2377, 2377, 2416], [2418, 2418, 2439, 2439, 2930], [2931, 2954, 3084, 3084, 3231], [3232, 3232, 3255, 3255, 3959], [3960, 3960, 3984, 3984, 4141], [4142, 4142, 4176, 4176, 4460], [4461, 4461, 4494, 4494, 4895], [4896, 4896, 4922, 4922, 5038], [5039, 5092, 5134, 5134, 5326], [5328, 5328, 5385, 5385, 6117]], "test": "valid"}
{"id": "7sXGR7", "name": "Quaternion for Julia 2", "author": "kovacjosh", "description": "Quaternion equivalent for the Julila set with power of 2 rendered with ray-marching", "tags": ["raymarching"], "likes": 1, "viewed": 76, "published": "Public", "date": "1615675977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float maxSteps = 100.;\nconst int iMaxSteps = 100;\nconst float hitThreshold = .0008;\nconst float maxDistance = 1000.;\nconst float specExp = 8.;\nconst float AA = 2.;\n\n// Self dot-product helper functions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\n\nstruct Triangle\n{\n  vec3 a;\n  vec3 b;\n  vec3 c;\n  vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\n\n\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\n\nmat3 rotMat(vec3 u, float t)\n{\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p - s.center) - s.radius, s.color);\n}\n\nHit boxSDF( vec3 p, Box b )\n{\n  vec3 q = abs(p - b.center) - (b.size);\n  float radius = 0.05;\n  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\n\nHit triangleSDF(vec3 p, Triangle tri)\n{\n    vec3 ba = tri.b - tri.a; vec3 pa = p - tri.a;\n    vec3 cb = tri.c - tri.b; vec3 pb = p - tri.b;\n    vec3 ac = tri.a - tri.c; vec3 pc = p - tri.c;\n    vec3 nor = cross( ba, ac );\n\n    float dist = sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(ac,nor),pc))<2.0)\n         ?\n         min( min(\n         dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n         dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n         dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n         :\n         dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    return Hit(dist, tri.color);\n}\n\n// Signed distance functions for different shapes\n\nHit mandelbulbSDF(vec3 p)\n{\n    float power = 8.;\n    vec3 z = p;\n    float dr = 1.;\n    float r;\n    vec3 c1 = vec3(1., 1., 1.);\n    vec3 c2 = vec3(1., 0., 0.) * .02;\n    \n    for (int i = 0; i < 15; i++)\n    {\n        r = length(z);\n        if (r > 2.)\n        {\n            break;\n        }\n        float theta = acos(z.z / r) * power + iTime;\n        float phi = atan(z.y/z.x) * power + iTime;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n        c2 += c2;\n    }\n    return Hit(0.5 * log(r) * r / dr, c1 - c2);\n}\n\nvec4 multQuaterion(vec4 a, vec4 b)\n{\n    return vec4(\n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w,\n        a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z,\n        a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y,\n        a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x\n    );\n}\n\nHit quaternionSDF2(vec3 p)\n{\n    vec4 c = 0.65*cos( vec4(0.5,3.9,1.4,1.1) + iTime*0.1*vec4(1.7,1.8,1.2,1.5) ) - vec4(0.1,0.4,0.2,0.0);\n    vec4 z = vec4(p, 0.5);\n    float md2 = 1.0; // derivative of min distance, |dz|^2\n    float mz2 = dot(z,z); // min distance to z, will be changed iteratively\n    //float steps = 0.0; // useful for certain coloring techniques\n    for (int i=0; i < 10; i++)\n    {\n        // |dz|^2 = |2z|^2\n        md2 *= 4.0*mz2;\n        // z <- z^2 + c\n        z = multQuaterion(z,z) + c;\n        mz2 = dot(z,z);\n        if(mz2 > 4.0){\n            break;\n        }\n        //steps += 1.0;\n    }\n    \n    float dist = 0.25*sqrt(mz2/md2)*log(mz2);\n    vec3 color = vec3(0.0, 0.0, 1.0) + mz2*vec3(0.2, 0.3, 0.0);\n    return Hit(dist, color);\n    \n}\n\nHit quaternionSDF3(vec3 p)\n{\n    vec4 c = vec4(-0.1,0.6,0.9,-0.3) + 0.1*sin( vec4(3.0,0.0,1.0,2.0) + 0.5*vec4(1.0,1.3,1.7,2.1)*iTime);\n    vec4 z = vec4(p, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n    \n    for (int i=0; i < 10; i++)\n    {\n        vec4 zSqr = multQuaterion(z,z);\n        // |dz|^2 = |3z^2|^2\n        md2 *= 9.0*(dot(zSqr,zSqr));\n        // z <- z^3 + c\n        z = multQuaterion(z, zSqr) + c;\n        \n        md2 = dot(z,z);\n        if(md2 > 10.0) \n        {\n            break;\n        }\n    }\n    \n    float dist = 0.25*sqrt(mz2/md2)*log(mz2);\n    vec3 color = vec3(1.0, 1.0, 0.0) + dot(z,z)*vec3(0.0, 0.0, .5);\n    return Hit(dist, color);\n}\n\n// Smooth min to cause shapes to morph into eachother\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nHit hitSMin(Hit a, Hit b, float k)\n{\n    float h = clamp(0.5+0.5*(b.t-a.t)/k, 0.0, 1.0 );\n    float f = mix(b.t, a.t, h) - k*h*(1.0-h);\n    vec3 c = mix(b.color, a.color, h) - k*h*(1.0-h);\n    return Hit(f, c);\n}\n\n// Define the objects in the scene and their relations to eachother\nHit map(vec3 p)\n{\n    mat3 rot = rotMat(vec3(0., 1., 0.), iTime/4.);\n    \n    //return Hit(mb(p).x, vec3(1.));\n    //return mandelbulbSDF(rot * p);\n    //Hit s = sphereSDF(p, Sphere(vec3(0., 0., 0.), .75, vec3(.7, .8, .2)));\n    //Hit b = boxSDF(p, Box(vec3(.0, 0., 0.), vec3(.25), vec3(1., 0., 0.)));\n    //return hitMin(s, b);\n    //return hitSMin(s, b, .1);\n    Hit b = quaternionSDF2(p);\n    return b;\n}\n\n// Calculate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec3 eps = vec3(0.001, 0., 0.);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n        i += 1;\n        if (i > iMaxSteps)\n        {\n            break;\n        }\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(0., 6., 5.), 20., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., -5., 5.), 2., vec3(1., .5, .1), 8.),\n        Light(vec3(5., 0., 5.), 6., vec3(1., 0., 1.), 1.)\n    );\n    vec3 ambient = vec3(0.8,0.63,0.50) * .05;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        //float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness);\n        \n        float strength = lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glow = vec3(1., 1., 1.) * .7;\n    float t = 0.;\n    float i = 0.;\n    while (i < maxSteps && t <= maxDistance)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color + glow * i/maxSteps;\n        }\n        t += closestHit.t;\n        i += 1.;\n    }\n    return vec3(0.01, 0.02, 0.03) + glow * smoothstep(0., 1.5, i/maxSteps);\n    //return texture(iChannel0, ray.dir).xyz + glow * smoothstep(0., 1.5, i/maxSteps);\n}\n\nvec4 render(in vec3 e, in mat4 view, in vec2 uv) {\n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    return vec4(raymarch(viewRay), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    vec3 e = vec3(sin(iTime*0.1), 0., 1.7);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n        // Convert pixel coordinates to uv coordinates\n    if (AA > 1.) {\n      vec4 average = vec4(0.0);\n      for (float s = 0.; s < AA; s++) {\n        for (float t = 0.; t < AA; t++) {\n            vec2 offset = (vec2(s, t) / AA) - 0.5;\n\n            vec2 uv = (fragCoord + offset)/iResolution.xy * 2. - 1.;\n            uv.y *= iResolution.y/iResolution.x;\n\n            average += render(e, view, uv);\n        }\n      }  \n      average /= AA*AA;\n      fragColor = average;\n    } else {\n      vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n      uv.y *= iResolution.y/iResolution.x;\n\n      fragColor = render(e, view, uv);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 208, 233, 233, 252], [253, 253, 278, 278, 297], [689, 689, 722, 722, 761], [763, 763, 793, 793, 1107], [1109, 1109, 1142, 1142, 1202], [1204, 1204, 1233, 1233, 1384], [1386, 1386, 1425, 1425, 2047], [2049, 2100, 2127, 2127, 2753], [2755, 2755, 2791, 2791, 3004], [3006, 3006, 3034, 3034, 3774], [3776, 3776, 3804, 3804, 4448], [4450, 4504, 4545, 4545, 4634], [4636, 4636, 4662, 4662, 4744], [4746, 4746, 4782, 4782, 4958], [4960, 5028, 5045, 5045, 5435], [5437, 5487, 5512, 5512, 5798], [5800, 5838, 5886, 5886, 6413], [6415, 6471, 6511, 6511, 7407], [7409, 7441, 7465, 7465, 8142], [8144, 8144, 8194, 8246, 8378], [8380, 8380, 8437, 8458, 9448]], "test": "error"}
{"id": "7sXGRj", "name": "sha Ocean", "author": "sha", "description": "this is Just my first Shadertoy", "tags": ["ocean"], "likes": 2, "viewed": 83, "published": "Public", "date": "1616228126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MARCH_STEP = 35;\nconst int FBM_STEP = 5;\n\nfloat hash(vec2 uv){\n    float a = dot(uv, vec2(231.02384, 339.23918));\n    return fract(sin(a)*3039.39482);\n}\n\nfloat noise(vec2 uv){\n    vec2 pf = floor(uv);\n    vec2 pr = fract(uv);\n    vec2 s = pr*pr*(3.0 - 2.0*pr);\n    float a = hash(pf);\n    float b = hash(pf + vec2(1.0, 0.0));\n    float c = hash(pf + vec2(0.0, 1.0));\n    float d = hash(pf + vec2(1.0, 1.0));\n    return mix(mix(a,b,s.x), mix(c,d,s.x), s.y);\n}\n\nfloat fbm(vec2 p){\n    float res = 0.0;\n    float amp = 1.0;\n    p += vec2(noise(p+iTime), noise(p+3.0))*0.2;\n    for(int i=0; i<FBM_STEP; i++){\n        vec2 v = vec2(1.0, 0.45)*iTime*2.0;\n        res += amp * abs((2.0*noise(p+v))-1.0);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    res = min(res*0.6, 1.0);\n    return 1.0 - res;\n}\n\nfloat GetDist(vec3 p){\n    vec2 uv = p.xz + vec2(0.3, 0.0)*iTime;\n    vec2 uv2 = p.xz + vec2(-0.4, -0.15)*iTime;\n    float a = fbm(uv*0.5)*0.3 + fbm(uv2)*0.2;\n    return max(p.y - a, 0.0);\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 d = vec2(0.001, 0.0);\n    vec3 n = vec3(GetDist(p + d.xyy) - GetDist(p - d.xyy),\n                    GetDist(p + d.yxy) - GetDist(p - d.yxy),\n                        GetDist(p + d.yyx) - GetDist(p - d.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 cp = vec3(sin(iTime*0.34), 4.5 + sin(iTime)*0.8, -5.0);\n    vec3 dir = vec3(uv.x, uv.y -0.34 + cos(iTime*0.89)*0.056, 1.0);\n    \n    vec3 ray = cp;\n    float hit=0.0;\n    float dist = 100.0;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    float alpha = 0.0;\n    float z = 0.0;\n    \n    for(int i=0; i<MARCH_STEP; i++){\n        dist = GetDist(ray);\n        if(dist < 0.001){\n            alpha = 1.0;\n            normal = GetNormal(ray);\n            break;\n        }\n        z += dist;\n        ray += dist*dir;\n    }\n    \n    z = min(z*0.01, 1.0);\n    vec3 zColor = z*vec3(0.6, 0.8, 1.0) + uv.y*0.5;\n    \n    normal = normalize(normal);\n    \n    float fre = 1.0 - dot(normal, normalize(cp));\n    fre = max(pow(fre, 2.0),0.0);\n    \n    //なんかしらんけど上手くいかなくて誤魔化した\n    fre = clamp(fre, 0.0, 1.0);\n    if(fre==1.0) fre = 0.0;\n    //-----------------------------------------------\n    \n    \n    float diff = dot(normal, vec3(0.0, 1.0, 0.0))*0.4 + 0.6;\n    diff = max(diff, 0.0);\n    \n    \n    vec3 col = mix(vec3(0.01, 0.35, 0.7), vec3(0.05, 0.68, 1.0), diff) + zColor + fre;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 72, 72, 162], [164, 164, 185, 185, 468], [470, 470, 488, 488, 803], [805, 805, 827, 827, 995], [997, 997, 1020, 1020, 1264], [1266, 1266, 1323, 1323, 2555]], "test": "valid"}
{"id": "7sXGz7", "name": "Spiralssss", "author": "elindie", "description": "Fiddlin", "tags": ["spiral"], "likes": 0, "viewed": 34, "published": "Public", "date": "1615684517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float val = abs(sin(fragCoord.x + -iTime + dot(fragCoord.x/10.0, fragCoord.y)));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n\n    col = col * val;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 419]], "test": "error"}
{"id": "7sXGzf", "name": "GridBlend4", "author": "Del", "description": "More grid blending fun - use mouse border change", "tags": ["grid", "blend", "hex", "tri"], "likes": 10, "viewed": 175, "published": "Public API", "date": "1616364297", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// more grid blending! (hex + tri grid)\n\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\n// Triangle grid using the skewed, split rectangle method (quicker)\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tuv *= rot(sin(uv.x*uv.y)*0.25+iTime*0.1);\n\n    // dirty grid blending attempt #4\n    vec2 id;\n    vec2 id2;\n    float zoom = 8.0;\n    zoom += sin(t)*2.0;\n    \n    float zoom2 = zoom;\n    //if (iMouse.z>0.5)\n    //    zoom2 *= 1.5;// secondary zoom\n    \n    vec4 h = HexGrid(uv*zoom2, id);\n    vec4 h2 = TriGrid(uv*zoom, id2);\n\n\tfloat vvv1 = abs(h2.x-h.x);\n\tfloat vvv2 = abs(h2.y-h.y)*0.95;\n\t\n\t\n\t\n    h.x = smin(h.x,h2.x,0.125); // blend distance\n    id = mix(id,id2,0.5); // blend IDs\n\n    float vvv = min(vvv1,vvv2)*(2.0+sin(length(id*8.0)));\n\t\n    vec3 bordercol = vec3(0.9,0.9,0.7);\n    vec3 shapecol = vec3(0.2,0.15,0.15);\n    vec3 shapecol2 = vec3(1.,.5,.3)*2.0;\n\tshapecol = mix(shapecol,shapecol2,vvv);\n    // just do a simple patterned shape tint based on (blended) cell IDs\n\n    float patternVal = .5; // 33.5 make this large to randomize the effect\n\n    float cm = 1.0 + pow(abs(sin(length(id)*patternVal + t*0.65)), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    shapecol *= cm;\n    if (iMouse.z<0.5)\n        bordercol = shapecol;\n    \n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol,vv); // white edge\n\n    fragColor = vec4(finalcol,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 42, 78, 78, 586], [588, 801, 837, 837, 1440], [1442, 1442, 1484, 1484, 1525], [1527, 1527, 1568, 1568, 1657], [1659, 1659, 1680, 1680, 1748], [1750, 1750, 1807, 1807, 3252]], "test": "error"}
{"id": "fd23zz", "name": "Menger Sponge Tunnel", "author": "kithy", "description": "fractal,raymarching,Menger Sponge", "tags": ["raymarching", "fractal", "mengersponge"], "likes": 12, "viewed": 188, "published": "Public", "date": "1616860451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPS 0.001\n#define ITR 5\n\n\nmat2 rotate(float r){\n\tfloat c=cos(r);\n\tfloat s=sin(r);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat maxcomp(vec2 p){\n\treturn max(p.x,p.y);\n}\n\n\nfloat sdCross(vec3 p){\n\tp=abs(p);\n\tvec3 d=vec3(max(p.x,p.y),\n\t\t\t\tmax(p.y,p.z),\n\t\t\t\tmax(p.z,p.x));\n\treturn min(d.x,min(d.y,d.z))-(1.0/3.0);\n}\n\n\nfloat sdCrossRep(vec3 p){\n\tvec3 q=mod(p+1.0,2.0)-1.0;\n\treturn sdCross(q);\n}\n\n\nfloat sdCrossRepScale(vec3 p,float s){\n\treturn sdCrossRep(p*s)/s;\n}\n\n\nfloat scene(vec3 p){\n\t\n\tfloat scale=1.0;\n\tfloat dist=0.0;\n\tfor(int i=0;i<ITR;i++){\n\t\tdist=max(dist,-sdCrossRepScale(p,scale));\n\t\tscale*=3.0;\n\t}\n\treturn dist;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tscene(p+vec3(EPS,0.0,0.0))-scene(p-vec3(EPS,0.0,0.0)),\n\t\tscene(p+vec3(0.0,EPS,0.0))-scene(p-vec3(0.0,EPS,0.0)),\n\t\tscene(p+vec3(0.0,0.0,EPS))-scene(p-vec3(0.0,0.0,EPS))\n\t\t));\n}\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);\n\tvec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);\n\treturn c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);\n}\n\nvec4 colorize(float c){\n\tfloat hue=mix(0.6,1.15,min(c*1.2-0.05,1.0));\n\tfloat sat=1.0-pow(c,4.0);\n\tfloat lum=c;\n\tvec3 hsv=vec3(hue,sat,lum);\n\tvec3 rgb=hsv2rgb(hsv);\n\treturn vec4(rgb,1.0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord.xy/iResolution.xy*2.0-1.0;\n\n\tvec3 cameraPos=vec3(0.0,0.0,iTime*0.5);\n\tvec3 cameraDir=vec3(0.0,0.0,1.0);\n\tvec3 cameraPlaneU=vec3(1.0,0.0,0.0);\n\tvec3 cameraPlaneV=vec3(0.0,1.0,0.0)*(iResolution.y/iResolution.x);\n\n\tvec3 rayPos=cameraPos;\n\n\tvec3 rayDir=cameraDir+uv.x*cameraPlaneU+uv.y*cameraPlaneV;\n\n\trayDir=normalize(rayDir);\n\n\trayDir.xy*=rotate(iTime*0.5);\n\trayDir.yz*=rotate(iTime*0.5);\n\n\tfloat dist=scene(rayPos);\n\n\tfloat emission=0.0;\n\t\n\n\tint stapsTaken;\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tif(dist<EPS)break;\n\t\trayPos+=rayDir*dist;\n\t\tdist=scene(rayPos);\n\n\t\temission+=exp(dist*-0.4);\n\t\n\t\tstapsTaken=i;\n\t}\n\n\n\tvec4 color=0.05*emission*vec4(0.3,0.3,0.9,1.0);\n\tfragColor=color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd23zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 76, 76, 136], [138, 138, 160, 160, 184], [187, 187, 209, 209, 327], [330, 330, 355, 355, 405], [408, 408, 446, 446, 475], [478, 478, 498, 498, 637], [639, 639, 662, 662, 864], [866, 866, 887, 887, 1022], [1024, 1024, 1047, 1047, 1212], [1214, 1214, 1267, 1267, 1961]], "test": "valid"}
{"id": "fdB3Rh", "name": "Raymarching Spheres", "author": "warptarium", "description": "This shader raymarches two spheres.\n\nIt uses an improvised phong shading method to calculate light, and uses sin/cos rotation to move the spheres.\n\nThe camera is rotated using an x axis rotation matrix.", "tags": ["raymarching", "practice"], "likes": 1, "viewed": 116, "published": "Public", "date": "1616897443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define SURF_DIST 0.03\n#define MAX_DIST 100.0\n#define GREEN vec3(0, 1.0, 0.0)\n#define RED vec3(1.0, 0.0, 0.0)\n#define AMB_LIGHT_STRENGTH 0.1\n#define SPECULAR_LIGHT_STRENGTH 0.5\n\n/*\n    Created by Weston McNamara\n*/\n\n\n//x axis rotation matrix\nmat3 rotX(float angle) \n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3\n    (\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\n\n//SDF to first sphere\nfloat sdfSphere(vec3 p) \n{\n    vec4 sphere = vec4(0, 1.1, 9, 1);\n    sphere.xz += vec2(-sin(iTime), cos(iTime))  * 5.;\n    \n    return length(p - sphere.xyz) - sphere.w;\n} \n\n//SDF to second sphere\nfloat sdfSphere2(vec3 p) \n{\n    vec4 sphere = vec4(0, 1.1, 9, 1);\n    sphere.x += sin(iTime) * 6.0;\n    \n    return length(p - sphere.xyz) - sphere.w;\n} \n\n//signed distance to axis aligned plane\nfloat sdfPlane(vec3 p) \n{\n    return p.y; //y at zero\n}\n\n//signed distance to scene\nfloat sdfScene(vec3 p) \n{\n    return min(sdfPlane(p), min(sdfSphere(p), sdfSphere2(p)));\n}\n\n//scene raymarching function\nfloat sceneMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        vec3 p = ro + rd * dO;\n        float dS = sdfScene(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n//weird calculus trick to get normal vector\nvec3 genNormal(vec3 p) \n{\n    float d = sdfScene(p); //very close to 0\n    \n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = vec3\n    (\n        d - sdfScene(p - e.xyy),\n        d - sdfScene(p - e.yxy),\n        d - sdfScene(p - e.yyx)\n    );\n        \n    return normalize(n);\n}\n\n//calculate the color of a pixel with a origin and direction\nvec3 calculateColor (vec3 ro, vec3 rd, vec2 uv) \n{\n    vec3 lightPos = vec3(0.0, 7.0, 8.0);\n\n    //march the scene coordinate\n    float d = sceneMarch(ro, rd);\n    \n    //Background color\n    if (d > MAX_DIST)\n        return vec3(0.0, 0.2, 0.4) * d;\n        \n    //create a point for the light to be calculated on\n    vec3 p = ro + rd * d;\n    \n    lightPos.xy += vec2(sin(iTime), cos(iTime)) * 2.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = genNormal(p);\n    \n    //diffuse\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    //specular\n    //https://learnopengl.com/Lighting/Basic-Lighting\n    vec3 viewDir = normalize(p - ro);\n    vec3 incident = reflect(-viewDir, n);\n    \n    float spec = pow(max(dot(viewDir + n * SURF_DIST, incident), 0.0), 66.0) * SPECULAR_LIGHT_STRENGTH;\n    \n    //shadow\n    float shadowDist = sceneMarch(p + n * SURF_DIST * 2.0, lightPos - p);\n        \n    if (shadowDist < distance(p, lightPos))\n    {\n        //in shadow\n        dif *= 0.1;\n        spec = 0.0; //remove specular highlight in shadow\n    }\n    \n    return vec3(dif + AMB_LIGHT_STRENGTH + spec) * vec3(0.1, 0.2, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center uvs\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    \n    //camera data\n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1) * (rotX(cos(iTime) / 5.0)) - 0.1);\n    \n    //calculate color\n    vec3 col = calculateColor(ro, rd, uv); \n    \n    //output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 264, 289, 289, 404], [406, 428, 454, 454, 599], [602, 625, 652, 652, 777], [780, 820, 845, 845, 875], [877, 904, 929, 929, 994], [996, 1025, 1062, 1062, 1304], [1306, 1350, 1375, 1375, 1624], [1626, 1687, 1737, 1737, 2815], [2817, 2817, 2874, 2891, 3221]], "test": "valid"}
{"id": "fdB3zh", "name": "Random procedural textures 4", "author": "jarble", "description": "This fractal formula makes many interesting tiled patterns, or procedural textures.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 171, "published": "Public API", "date": "1616899470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07);\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = .5;\n    float scale = 1.1;\n    //float scale2 = .25;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    float scale2 = h1.z+.5;\n    vec2 uv1 = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv1 += vec2(iTime/2.0,iTime/3.0)/t1/8.0; \n    vec2 uv = uv1; \n    for(int c=0;c<6;c++){\n        uv = triangle_wave(uv,scale,h1);\n        uv.yx = triangle_wave(uv+col.xy,scale,h1);\n        //offset /= scale2;\n        uv.x /= -1.0;\n        col[c] = fract((uv.x)-(uv.y));\n        col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 348, 371, 371, 456], [458, 568, 590, 590, 723], [727, 727, 774, 774, 830], [832, 832, 889, 889, 1484]], "test": "valid"}
{"id": "fdBGz1", "name": "regular Voronoi Noise", "author": "lonelywaiting", "description": "voronoi implement", "tags": ["noise"], "likes": 1, "viewed": 62, "published": "Public", "date": "1616912434", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 generate_feature_pos(vec2 p)\n{\n    vec2 d0 = vec2(127.1, 311.7);\n    vec2 d1 = vec2(269.5, 183.3);\n    return fract(sin(vec2(dot(p, d0), dot(p, d1))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 scale_pos = fragCoord.xy/iResolution.xy;\n    scale_pos.x *= iResolution.x / iResolution.y;\n    \n    scale_pos *= vec2(4,4);\n    \n    vec2 floor_pos = floor(scale_pos);\n    vec2 frac_pos  = fract(scale_pos);\n    \n    float min_dist = 1.0f;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            vec2 neighbor = vec2(i, j);\n            vec2 feature_pos = generate_feature_pos(floor_pos + neighbor);\n            feature_pos = 0.5 + 0.5 * sin(iTime + 6.2831 * feature_pos);\n            \n            vec2 diff = neighbor + feature_pos - frac_pos;\n            \n            min_dist = min(min_dist, length(diff));\n        }\n    }\n    \n    fragColor = vec4(min_dist, min_dist, min_dist, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 171], [173, 173, 230, 280, 1024]], "test": "valid"}
{"id": "fdf3D2", "name": "ray marching - v3", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 3, "viewed": 155, "published": "Public API", "date": "1616611398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 20.0\n#define FOG_DENSITY 0.2\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(vec3(-1,0,-1));\nvec3 light2 = normalize(vec3(0.5,1,-0.9));\n\nfloat distance_to_wave_sphere_repeat(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(vec3(mod(ray.x+2.,2.)-1., ray.y, mod(ray.z+2.,2.)-1.), pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_plane(vec3 ray, vec3 pos, vec3 normal){\n    return dot(ray-pos, normal);\n}\n\nfloat distance_to_wave_plane(vec3 ray, vec3 pos, vec3 normal){\n    return dot(ray-pos, normal)+sin(ray.x*2.+iTime)*0.1 + cos(ray.z*4.+iTime)*0.1;\n}\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(ray, pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    /*float h = clamp( 0.5 + 0.5*(d2-d1)/s, 0.0, 1.0 );\n    return mix( d2, d1, h ) - s*h*(1.0-h);*/\n    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nvec4 smooth_min_color(vec4 c1, vec4 c2, float s){ // c_.w component is distance\n    float d1 = c1.w, d2 = c2.w;\n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*c2 + (1.-t)*c1)/2.;\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess){\n    float min_distance = MAX_STEP_SIZE;\n    \n    float size = .8;\n    float orbit = 1.6;\n    float k = SHAPE_BLEND;\n    \n    //float d = distance_to_wave_sphere_repeat(ray, vec3(0,-4,0), 1., 0.05, vec3(5.3,3.7,4.5), 1.9);\n    float d = distance_to_wave_plane(ray, vec3(0,-3,0), normalize(vec3(0,1,0)));\n    float d1 = distance_to_wave_sphere(ray, vec3(0,0,6), 1.5, 0.05, vec3(5.3,3.7,4.5), .9);\n    float d2 = distance_to_sphere(ray, vec3(orbit*sin(iTime*2.0), orbit*sin(iTime*0.8), 6.+orbit*sin(iTime*0.6)), size); \n    float d3 = distance_to_sphere(ray, vec3(orbit*sin(iTime*0.8), orbit*sin(iTime*0.6), 6.+orbit*sin(iTime*2.)), size); \n    float d4 = distance_to_sphere(ray, vec3(orbit*sin(iTime*0.1), orbit*sin(iTime*2.0), 6.+orbit*sin(iTime*0.4)), size); \n    //float d5 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.5), 2.*sin(iTime*2.1), 6.+2.*sin(iTime*0.7)), size);\n   \n    //min_distance = smooth_min(smooth_min(smooth_min(d1, d2, k), smooth_min(d3, d4, k), k), d5, k);\n    \n    // shape blending\n    min_distance = smooth_min(smooth_min(d1,d2,k), smooth_min(d3,d4,k), k);\n    min_distance = min(min_distance, d);\n    \n    \n    // color blending\n    float p = 0., q = 1., r = .5;\n    \n    vec4 c1 = vec4(.1,.1,.1, d1); // center ball\n    vec4 c2 = vec4(p,q,r, d2);\n    vec4 c3 = vec4(r,p,q, d3);\n    vec4 c4 = vec4(q,r,p, d4);\n    \n    k = COLOR_BLEND;\n    \n    color = smooth_min_color(smooth_min_color(c1,c2,k), smooth_min_color(c3,c4,k), k).xyz;\n    \n    shininess = 1.;\n    \n    if(d == min_distance){\n        color *= 0.4;\n        //color = vec3(.05,.05,.05);\n        shininess = 1.5;\n    }\n    \n    \n    return min_distance;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    return safe_distance(ray, c, s);\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float shininess = 0.;\n    vec3 bodyColor = vec3(0);\n    float d = 0.; // ray length\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d, bodyColor, shininess);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5;\n            color = bodyColor*l1 + bodyColor*l2 + (vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.))*shininess;\n            //color = vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.);\n            \n            // fog in the distance\n            color /= (exp((d-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            return color;\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.4,.9)*pow(max(1.-min_distance,0.),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 353, 465, 465, 693], [695, 695, 752, 752, 787], [789, 789, 851, 851, 936], [938, 938, 1043, 1043, 1221], [1223, 1223, 1277, 1277, 1314], [1316, 1316, 1365, 1466, 1543], [1545, 1545, 1594, 1624, 1728], [1730, 1730, 1797, 1797, 3439], [3441, 3441, 3471, 3471, 3550], [3552, 3552, 3574, 3574, 3936], [3938, 3938, 3963, 3963, 5166], [5168, 5168, 5225, 5260, 5505]], "test": "valid"}
{"id": "fdf3D4", "name": "Pixel Spirit Deck - Hierophant", "author": "tonynogo", "description": "Based on the Deck of Patricio Gonzales :\nhttps://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n", "tags": ["pixelspirit"], "likes": 1, "viewed": 62, "published": "Public", "date": "1616351608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define flip(v,pct) mix(v, 1.-v,pct)\n#define fill(x,s) step(x,s)\n#define stroke(x,s,w) smoothstep(6./iResolution.y, 0., abs(s-x) - w*.5 )\n\nfloat rectSDF(vec2 st, vec2 s)\n{\n    return max(abs(st.x/s.x),abs(st.y/s.y));\n}\n\nfloat crossSDF(vec2 st, float s)\n{\n    vec2 size = vec2(.25,s);\n    return min(rectSDF(st,size.xy), rectSDF(st,size.yx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float color = 0.;\n    vec2 st = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float rect = rectSDF(st, vec2(.5));\n    color += fill(rect,1.);\n    float crosssdf = crossSDF(st, clamp(abs(sin(iTime))+.3,.6,1.));\n    color*= step(.5,fract(crosssdf*4.+iTime));\n    color*= step(1., crosssdf);\n    color+=fill(crosssdf,.5);\n    color += stroke(rect,1.1,.05);\n    color += stroke(rect,1.2,.025);\n    color = flip(color, stroke((cos(iTime)*st.x+st.y)*2., 0., .5));\n    //color.rgb = vec3(fract(fragCoord.x/10.)) * vec3(fract(fragCoord.y/10.)); // GridDebug\n    fragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 171, 171, 218], [220, 220, 254, 254, 343], [345, 345, 402, 402, 1005]], "test": "valid"}
{"id": "fdf3Wj", "name": "firework fun (vlllll)", "author": "valalalalala", "description": "Finally got around to watching BigWing's tutorial and  wanted to play around with some different distance metrics.", "tags": ["firework"], "likes": 8, "viewed": 109, "published": "Public", "date": "1616618915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "        ///////////////////////////////////////////////////////////////////\n       //                                                              ////\n      //  \"firework fun\"                                              // //\n     //                                                              //  //\n    //  Finally got around to watching BigWing's tutorial and       //   //\n   //  wanted to play around with some different distance metrics. //    //\n  //  https://www.youtube.com/watch?v=xDxAnguEOn8                 //     //\n //                                                              //     //\n//////////////////////////////////////////////////////////////////     // \n//                                                              //    //\n// CC0 1.0 Universal                                            //   //\n// https://creativecommons.org/publicdomain/zero/1.0/           //  //\n//                                                              // //\n// by Val \"valalalalala\" GvM 💃 2021                            ////\n//                                                              ///\n//////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////\n// tweak 'em if ya got 'em! I do... settings, pervert! yeesh...\n\nconst float FIREWORKS   = 3.;\nconst float PARTICLES   = 22.;\n\nconst float SPEED       = 1.;\nconst float MAX_EFFECT  = .004;\n\nconst float CLOSE_ENUFF = .77;\n\n//////////////////////////////////////////////////////////////////\n// so many fun distance metrics and so much time!\n\nfloat euclid( vec2 p );\nfloat eumomma( vec2 p );\nfloat manhattan( vec2 p );\nfloat langth( vec2 p );\nfloat maxhattan( vec2 p );\nfloat minhattan( vec2 p );\nfloat manmanhathattantan( vec2 p, float dampening );\nfloat atlanta( vec2 p );\nfloat marietta( vec2 p );\nfloat newnan( vec2 p );\nfloat diz1( vec2 p );\nfloat distancish( vec2 a );\n\nfloat dizd( vec2 p, int which ) {\n    // uncomment to always use the same function\n    //which = 8; \n    switch ( which % 11 ) {\n        case  0: return euclid( p );\n        case  1: return eumomma( p );\n        case  2: return langth( p );\n        case  3: return manhattan( p );\n        case  4: return maxhattan( p );\n        case  5: return manmanhathattantan( p, 4.4 );\n        case  6: return atlanta( p );\n        case  7: return marietta( p );\n        case  8: return newnan( p );\n        case  9: return diz1( p );\n        case 10: return distancish( p );\n    }\n}\n\n//////////////////////////////////////////////////////////////////\n// the dao of the tau \n\nconst float TAU = 6.283185307179586;\n\n//////////////////////////////////////////////////////////////////\n// here is a thrilling function to write over and over!\n\nvec2 fromScreen( in vec2 fragCoord );\n\n//////////////////////////////////////////////////////////////////\n// hashtastic, blackle!\n\n#define FBI(v) floatBitsToInt(v*v*3.3)^floatBitsToInt(v)\n\nfloat hash( float v );\nvec2 hash2( float v );\nvec2 rash2( float v );\n\n\n//////////////////////////////////////////////////////////////////\n// finally getting exciting!\n\nvec3 fireworkShow( vec2 uv );\nvec3 shootFirework( vec2 uv, float firework );\n\n//////////////////////////////////////////////////////////////////\n// and now... the main event!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4( fireworkShow( fromScreen( fragCoord ) ), 1. );\n}\n\n//////////////////////////////////////////////////////////////////\n// oh, gee whiz! that's really swell!\n\nvec3 fireworkShow( vec2 uv ) {\n    vec3 accumulator = vec3( .0 );\n    \n    for( float firework = 1. ; firework <= FIREWORKS ; firework++ ) {\n        accumulator += shootFirework( uv, firework );\n    }\n    \n    return accumulator;\n}\n\nvec3 shootFirework( vec2 uv, float firework ) {\n    float accumulator = .0;\n    \n    float t = iTime * firework * SPEED + firework * 4.4;\n\n    float epoch = floor( t );\n    float moment = t - epoch;\n    float imoment = ( 1. - moment );\n\n    vec2 fireworkOffset = hash2( epoch + firework * 3.3 + 4.4 );\n    vec2 fireworkLocation = uv + fireworkOffset * vec2( .8, .4 );\n        \n    vec3 color = sin( vec3( fireworkOffset.xy, fireworkOffset.x + fireworkOffset.y ) ) * .5 + .5;\n        \n    int distanceFunction = int( hash( epoch + firework ) * 11. );\n    \n    for ( float particle = 1. ; particle <= PARTICLES ; particle++ ) {\n        vec2 offset = rash2( epoch + particle + firework ) * .3;\n        vec2 location = fireworkLocation - offset * moment;\n        \n        float d = dizd( location, distanceFunction );\n        d = min( d, CLOSE_ENUFF );\n        accumulator += MAX_EFFECT / d * imoment;\n    }\n    \n    return color * accumulator;\n}\n\n//////////////////////////////////////////////////////////////////\n// here's the moment you've been waiting for:\n\nvec2 fromScreen( in vec2 fragCoord ) {\n    return ( fragCoord - iResolution.xy * .5 ) / iResolution.y;\n}\n\n//////////////////////////////////////////////////////////////////\n// hash implementations\n\nfloat hash( float v ) {\n    int q = FBI( v );\n    return float( q * q ) / 2.1248e9;\n}\n\nvec2 hash2( float v ) {\n    return vec2( hash( v - 1.234 ), hash( v + 33.44 ) );\n}\n\n// such a great trick to get that nice round distribution!\nvec2 hashToRash( vec2 h ) {\n    h *= vec2( TAU, 1. );\n    return vec2( cos( h.x ), sin( h.x ) ) * h.y;\n}\n\nvec2 rash2( float v ) {\n    return hashToRash( hash2( v ) );\n}\n\n//////////////////////////////////////////////////////////////////\n// keep your distance functions handy\n\nfloat euclid( vec2 p ) {\n    return length( p );\n}\n\nfloat eumomma( vec2 p ) {\n    return dot( p, p );\n}\n\nfloat manhattan( vec2 p ) {\n    p = abs( p );\n    return p.x + p.y;\n}\n\nfloat langth( vec2 p ) {\n    return eumomma( p ) / manhattan( p );\n}\n\nfloat maxhattan( vec2 p ) {\n    p = abs(p);\n    return max(p.x,p.y);\n}\n\nfloat minhattan( vec2 p ) {\n    p = abs(p);\n    return min(p.x,p.y);\n}\n\nfloat manmanhathattantan( vec2 p, float dampening ) {\n    float d = manhattan( p );\n    return d * d * dampening;\n}\n\n// lookit! hometown girl makes good (distance functions)! \n\nfloat atlanta( vec2 p ) {\n    return p.x * p.x * p.y * p.y * 1e7;\n}\n\nfloat marietta( vec2 p ) {\n    p = abs(p);\n    return p.x * p.y * 1e4;\n}\n\nfloat newnan( vec2 p ) {\n    return p.x * p.y * 1e2;\n}\n\nfloat diz1( vec2 p ) {\n    float dd = p.x * p.y;\n    float dp = p.x + p.y;\n    return 1. - ( dp * dd * .002 ) / ( 1e-13 + dd * dd );\n}\n\nfloat distancish( vec2 a ) {\n    vec2 d = abs( a );\n    float d1 = min( d.x, d.y );\n    float d2 = max( d.x, d.y );\n    return ( d1 * .3 + d2 * 0.7 ) * 1.41;\n}\n\n// EOF, please don't read this comment... thanks!\n//////////////////////////////////////////////////////////////////", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3Wj.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1464, 1915, 1948, 2015, 2487], [3177, 3275, 3332, 3332, 3403], [3405, 3511, 3541, 3541, 3742], [3744, 3744, 3791, 3791, 4686], [4688, 4802, 4840, 4840, 4906], [4908, 5000, 5023, 5023, 5085], [5087, 5087, 5110, 5110, 5169], [5171, 5230, 5257, 5257, 5334], [5336, 5336, 5359, 5359, 5398], [5400, 5506, 5530, 5530, 5556], [5558, 5558, 5583, 5583, 5609], [5611, 5611, 5638, 5638, 5680], [5682, 5682, 5706, 5706, 5750], [5752, 5752, 5779, 5779, 5822], [5824, 5824, 5851, 5851, 5894], [5896, 5896, 5949, 5949, 6011], [6013, 6073, 6098, 6098, 6140], [6142, 6142, 6168, 6168, 6214], [6216, 6216, 6240, 6240, 6270], [6272, 6272, 6294, 6294, 6406], [6408, 6408, 6436, 6436, 6567]], "test": "error"}
{"id": "fdf3Wn", "name": "Power Stone (4K)", "author": "dean_the_coder", "description": " Unlocking the 'Power Stone' from Guardians of the Galaxy.", "tags": ["3d", "raymarching", "movie", "cineshader", "gotg"], "likes": 24, "viewed": 2364, "published": "Public API", "date": "1615742994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Power Stone (4K)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/fdf3Wn (YouTube: https://youtu.be/jP95Nqi_Qxw)\n//\n// Unlocking the 'Power Stone' from Guardians of the Galaxy.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle, Ivan Dianov, and a bunch of others for sharing\n// their knowledge!\n\n#define Z0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n#define S(x) smoothstep(0., 1., x)\n\nfloat g = 0., T;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define minH(a) if (a.d < h.d) h = a\n\nmat2 rot(float a) {\n\tvec2 cs = cos(vec2(a, a - 1.5705));\n\treturn mat2(cs, -cs.y, cs.x);\n}\n\nvec2 polar(vec2 p, float n)\n{\n\tfloat t = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x) + t, 2. * t) - t;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat bx(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdOcta(vec3 p, float s) {\n  p = abs(p);\n  return (p.x + p.y + p.z - s) * .577;\n}\n\nfloat claws(vec3 p) {\n\tp.yz = polar(p.yz, 3.);\n\n\tp.x = abs(p.x) - .9;\n\tp.y -= 1.;\n\tp.xy *= rot(-.5);\n\tfloat d = max(cap(p, 1.2, .12 * S(p.x + .5)), abs(p.z) - .06);\n\n\tp.xy *= rot(-2.725);\n\tp.x += .1;\n\tp.y -= .05;\n\treturn min(d, max(cap(p, .9, .1 * (1.1 - S(p.x - .2))), abs(p.z) - .04));\n}\n\nHit map(vec3 p) {\n\tp.y -= 2.;\n\n\t// Ground.\n\tHit h = Hit(abs(p.y + 2.), 1);\n\n\tvec3 op = p;\n\n\t// Shell rotations.\n\tfloat t = (5. - clamp(T - 3., 0., 5.)) * 1.25664;\n\tp.yz *= rot((sin(t) + sin(2. * t)) * sign(p.x) * 1.4);\n\tt = max(0., T - 8.);\n\tfloat anim = sat((t - 1.) / 8.);\n\tvec2 shellOpen = S(vec2(anim * 4., anim * 4.5 - 3.)) * .7, // Outer, inner.\n\t\t f = p.x - shellOpen * sign(p.x),\n\t\t gaps = -abs(p.x) - .01 + shellOpen;\n\tp.x = p.x < 0. ? min(0., f.x) : max(0., f.x);\n\n\t// Claws.\n\tfloat x = abs(p.x) - .6,\n\t\t  d = max(dot(vec2(1.5, .6), vec2(length(p.yz), -x)), -x);\n\td = max(d, max(length(p.yz) - .5, 1.2 - abs(p.x)));\n\tminH(Hit(min(d, claws(p)), 3));\n\n\t// Outer shell halves.\n\tfloat s = length(p) - 1.;\n\td = max(min(\n\t\t\t   // Gyroid pattern.\n\t\t\t   length(vec2(s, dot(sin(p * 26.), cos(p.zxy * 26.)) * .03)) - .02,\n\t\t\t   // Shell.\n\t\t\t   abs(s + .08) - .05), gaps.x);\n\n\t// Inner shell halves.\n\tp.x = op.x < 0. ? min(0., f.y) : max(0., f.y);\n\n\tfloat i = mod(floor(atan(-p.y, p.z) * 3.183 + 10.) + 2., 20.),\n\t\t  temp = sat(anim * 4. - 2.) * 20.;\n\tfloat d2 = max(\n\t\tabs(length(p) - .65) - .05, // Shell.\n\t\tgaps.y // Split into two halves.\n\t\t+ .01 + .13 * step(i, temp) * min(temp - i, 1.));\n\n\t// Cut away shell slots.\n\tp.yz = polar(p.yz, 20.);\n\tp.y -= .64;\n\td = min(d, max(d2, -bx(p, vec3(.15, .08, .025))));\n\n\t// Stone.\n\tp = op;\n\tp.yz *= rot(t * .1);\n\tmat2 r = rot(2.5);\n\td2 = 1e7;\n\tfor (i = Z0; i < 4.; i++) {\n\t\tp -= .02;\n\t\tp.xy *= rot(3.7 + i);\n\t\tp.yz *= r;\n\t\td2 = min(d2, sdOcta(p, .3) - .005);\n\t}\n\n\tg += .00008 / (.001 + d2 * d2); // Glow - Stone.\n\tminH(Hit(d2, 4));\n\n\t// Glow - Flux.\n\tp = op;\n\tp.x = abs(p.x);\n\tp.y += cos(p.x + t) * .05;\n\td2 = length(p.yz) - .01;\n\tg += .0005 / (.001 + d2 * d2);\n\n\tminH(Hit(min(d, d2), 2));\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1, i, h;\n\tfor (i = Z0; i < 15.; i++)\n\t{\n\t\th = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 10.) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002); }\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 35, -10) - p),\n\t\t n = N(p, d), c;\n\tfloat gg = g, sp = 1.;\n\n\tif (h.id == 2)\n\t\tc = vec3(.2), sp = 3.;\n\telse if (h.id == 1)\n\t\tc = vec3(.03);\n\telse if (h.id == 3)\n\t\tc = vec3(.6);\n\telse c = vec3(.18, .02, .34);\n\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\n\t// Primary light.\n\tl1 = sat(.1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * shadow(p, ld)) // ...with shadow.\n\t\t * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 1, -1), n))\n\n\t// Specular.\n\t\t + pow(sat(dot(rd, reflect(ld, n))), 10.) * sp,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5;\n\n\t// Combine into final color.\n\tg = gg;\n\treturn mix((l1 * vec3(.43, .29, .52) +\n\t\t\t\tl2 * ao * vec3(2.11, 1.69, 1.48)) * c,\n\t\t\t   vec3(.05),\n\t\t\t   fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s, float mx) {\n\tfloat d = .01, i;\n\tg = 0.;\n\tHit h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t\tif (d > mx)\n\t\t\treturn vec4(0);\n\n\t\tp += h.d * rd; // No hit, so keep marching.\n\t}\n\n\tfloat pulse = mix(1., .3, (sin(T) * .5 + .5) * smoothstep(13., 15., T));\n\treturn vec4(pow(g, pulse) * vec3(.73, .5, .88) + lights(p, rd, d, h), h.id);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tvec4 col = march(p, rd, 100., 50.);\n\tcol.rgb *= fog(p - ro);\n\n\tif (col.w > 1.) {\n\t\trd = reflect(rd, N(p, length(p - ro)));\n\t\tp += rd * .01;\n\t\tcol += mix(.2, .3, col.w - 2.)\n\t\t\t   * march(p, rd, 50., 10.)\n\t\t\t   * fog(ro - p);\n\t}\n\n\treturn max(vec3(0), col.rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = mod(iTime, 30.);\n\n\t// Camera.\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 lookAt = vec3(0, 2, 0),\n         ro = mix(vec3(1, 2, -4), vec3(0, 3.5, -3), S(T / 4.)),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         rd = normalize(f + r * uv.x + cross(f, r) * uv.y),\n         col = scene(ro, rd);\n\n#ifdef AA\n\tif (fwidth(col.r) > .03) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++) {\n                vec2 luv = uv + (vec2(dx, dy) - .5) / iResolution.xy;\n\t\t\t\tcol += scene(ro, normalize(f + r * luv.x + cross(f, r) * luv.y));\n            }\n\t\tcol /= 5.;\n\t}\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vig(pow(col, vec3(.45)) * sat(iTime), fc), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 595, 614, 614, 684], [686, 686, 715, 715, 826], [828, 828, 854, 854, 941], [943, 943, 980, 980, 1032], [1034, 1034, 1065, 1065, 1120], [1122, 1122, 1143, 1143, 1411], [1413, 1413, 1430, 1430, 3158], [3160, 3160, 3185, 3185, 3404], [3406, 3406, 3437, 3452, 3630], [3632, 3660, 3695, 3695, 3726], [3728, 3728, 3755, 3755, 3870], [3872, 3872, 3891, 3891, 3924], [3926, 3926, 3972, 3972, 4763], [4765, 4765, 4819, 4819, 5183], [5185, 5185, 5215, 5215, 5492], [5494, 5494, 5539, 5539, 6284]], "test": "valid"}
{"id": "fdf3zn", "name": "Pretty Noisy Fireworks", "author": "kstyler", "description": "Oh my, these fireworks sure are noisy!", "tags": ["noise", "explosion", "fireworks", "boom"], "likes": 1, "viewed": 231, "published": "Public API", "date": "1615523787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat circle(vec2 p, float r){\n    return smoothstep(.0,.04,length(p) - r);\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat random(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * 20.1001);\n    p3 += dot(p3, p3.yzx + 300.3);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat explosion(vec2 p, float time){\n    vec2 dir = normalize(p);\n    float acc = -random(dir)/2.;\n    float friction = 0.8;\n    float timeRamping =  1.-pow(1.-time*1.5,5.);\n    vec2 pos = p+dir*acc*timeRamping*friction;\n    return circle(pos,.001)+time;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=2.5;\n    \n    float minium_value = 1.;\n    for(int i = 0; i < 10; i++){\n        minium_value = min(minium_value,\n        explosion(uv+vec2(cos(float(i))*1.,sin(float(i))*.5),\n        mod((iTime*.9)+float(i),1.6)));\n    }\n    vec3 col = vec3(minium_value);\n    col = 1.-col;\n    col*=vec3(sin(iTime*2.)+1.,cos(iTime*1.5)+1.,cos(iTime*4.)+1.)+1.5;\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 78], [80, 120, 141, 141, 260], [262, 262, 298, 298, 521], [523, 523, 578, 578, 1025]], "test": "valid"}
{"id": "fdf3zs", "name": "GridBlend7", "author": "Del", "description": "another blend", "tags": ["grid", "blend", "hex", "tri"], "likes": 10, "viewed": 171, "published": "Public API", "date": "1616412244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n    if((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);\n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0));\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\nvec4 TriGrid(vec2 uv, out vec2 id)\n{\n    float scaler = 0.866026;\n    uv *= mat2(1,-1./1.73, 0,2./1.73)*scaler;\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    id*= mat2(1,.5, 0,1.73/2.);\n    id.xy += sign(lg-1.)*0.1;\n    return vec4(((1.0-edge)*0.43)/scaler,length(triuv),triuv);\n}\nfloat hbar(vec2 p, float nline, float t)\n{\nreturn 0.5+sin((p.y*nline)+t)*0.5;\n}\nfloat smin( float a, float b, float k )\n{\nfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\nmat2 _rot(float th)\n{\n\tvec2 a = sin(vec2(1.5707963, 0) + th);\n\treturn mat2(a.xy, -a.y, a.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tt = iTime;\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= _rot(iTime*0.1);\n    vec2 id;\n    vec2 id2;\n    float zoom = 5.;\n    zoom += sin(uv.x*2.0+tt) * 0.5;\n    vec4 h = HexGrid(uv*zoom*2.0, id)*1.1;\n    uv *= _rot(-iTime*0.16);\n    vec4 h2 = TriGrid(uv*zoom, id2)*1.1;\n    h.x = min(h.x+1.5, h2.x*2.75);\n    float vvv1 = abs(h2.x-h.x)*0.4;\n    float vvv2 = abs(h2.y-h.y)*0.25;\n\th.x = smin(h.x,h2.y-0.05,1.95);\n    id = mix(id,id2,0.5);\n    float vvv = min(vvv1,vvv2)*(1.75+sin(tt*1.5+length(id*16.0)));\n    vec3 shapecol = vec3(0.125, 0.275, 0.155)*.95;\n\tshapecol = shapecol.xzy;\n    vec3 shapecol2 = vec3(1.53,0.9,0.7) * 5.0;\n    shapecol = mix(shapecol,shapecol2,vvv);\n    float cm = 1.0 + pow(abs(sin(length(id)*.25 + tt*0.65)), 32.0);\n    cm *= 1.0 + (hbar(h.zw,100.0,tt*12.0)*0.1);\n    shapecol *= cm;\n    vec3 bordercol = shapecol;\n    vec3 finalcol = mix(bordercol*0.2,shapecol,smoothstep(-0.05, 0.045, h.x));\n    fragColor = vec4(finalcol*3.2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 521], [522, 522, 558, 558, 1062], [1063, 1063, 1105, 1105, 1142], [1143, 1143, 1184, 1184, 1271], [1272, 1272, 1293, 1293, 1366], [1368, 1368, 1425, 1425, 2430]], "test": "error"}
{"id": "fdf3zX", "name": "goku v2", "author": "jorge2017a1", "description": "goku v2", "tags": ["gokuv2"], "likes": 1, "viewed": 148, "published": "Public API", "date": "1616337028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Modificado por jorge2017a1 ----jorgeFloresP\n\n//Referencia :\n//IQ https://www.shadertoy.com/view/wdBXRW\n//https://www.shadertoy.com/view/tlGBW3 //Created by manu210404 in 2021-03-13 \n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\nconst int N1 =30;\nconst int N2 =29;\nconst int N3 =10;\n\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\nfloat sdPoly11 POLY(11)\nfloat sdPoly29 POLY(29)\nfloat sdPoly16 POLY(16)\nfloat sdPoly36 POLY(36)\nfloat sdPoly15 POLY(15)\nfloat sdPoly17 POLY(17)\nfloat sdPoly07 POLY(7)\nfloat sdPoly13 POLY(13)\nfloat sdPoly12 POLY(12)\n\nvec2 pt0[11]=vec2[](vec2(.55,1.08),vec2(.7,1.16),vec2(.77,1.16),vec2(.86,1.1),vec2(.94,1.05),\nvec2(.94,1.02),vec2(.99,.73),vec2(1.02,.6),vec2(.75,.46),vec2(.44,.56),vec2(.55,1.08) );\n\n//pelo 1\nvec2 pt1[29]=vec2[]( vec2(.43,.95), vec2(.21,.86), vec2(.29,.83), vec2(.12,.66),\nvec2(.26,.66), vec2(.14,.48),  vec2(.11,.45), vec2(.07,.40), vec2(.04,.38),\nvec2(.01,.36), vec2(.06,.32), vec2(.12,.30), vec2(.18,.29), vec2(.21,.29), \nvec2(.25,.31), vec2(.31,.35), vec2(.29,.29),  vec2(.27,.17), vec2(.26,.14),\nvec2(.22,.05), vec2(.19,.00), vec2(.25,.00),  vec2(.31,.01), vec2(.37,.03),\nvec2(.44,.07), vec2(.49,.14), vec2(.53,.23), vec2(.55,.28), vec2(.43,.95) );\n\n//pelo 2\nvec2 pt2[16]=vec2[]( vec2(.61,.95), vec2(.83,.92), vec2(.76,.87), vec2(.91,.81),\nvec2(.80,.77), vec2(.97,.63), vec2(.93,.59), vec2(.89,.57), vec2(.84,.56),\nvec2(.98,.41), vec2(.90,.40),  vec2(.81,.40), vec2(.76,.41), vec2(.73,.42),\nvec2(.55,.28), vec2(.61,.95) );\n\n//pelo 3\nvec2 pt3[36]=vec2[]( vec2(.35,.71), vec2(.37,.73), vec2(.36,.66), vec2(.39,.68),\nvec2(.38,.58), vec2(.38,.55), vec2(.41,.50), vec2(.41,.54), vec2(.42,.59),\nvec2(.42,.62), vec2(.44,.67), vec2(.46,.57), vec2(.47,.53), vec2(.52,.47),\nvec2(.55,.43), vec2(.56,.47), vec2(.58,.52), vec2(.59,.54), vec2(.59,.58),\nvec2(.59,.65), vec2(.63,.61), vec2(.64,.58), vec2(.66,.56), vec2(.67,.51),\nvec2(.67,.52), vec2(.68,.54), vec2(.68,.57), vec2(.68,.61), vec2(.66,.70),\nvec2(.69,.67), vec2(.68,.73), vec2(.70,.73), vec2(.73,.49), vec2(.53,.38),\nvec2(.32,.46), vec2(.35,.71) );\n\n// ojo \nvec2 pt4[16]=vec2[]( vec2(.41,.81), vec2(.40,.78),  vec2(.39,.72), vec2(.40,.69),\nvec2(.41,.66), vec2(.43,.65), vec2(.45,.65), vec2(.46,.66), vec2(.47,.68),\nvec2(.48,.70), vec2(.49,.73), vec2(.49,.80), vec2(.47,.81), vec2(.45,.82),\nvec2(.42,.81), vec2(.41,.81) );\n\n/// ojo\nvec2 pt5[17]=vec2[]( vec2(.57,.81), vec2(.56,.78), vec2(.56,.75), vec2(.56,.71),\nvec2(.57,.69), vec2(.59,.66), vec2(.61,.65), vec2(.62,.65), vec2(.64,.66),\nvec2(.65,.68), vec2(.65,.70), vec2(.65,.73), vec2(.65,.77), vec2(.64,.81),\nvec2(.60,.81), vec2(.59,.82), vec2(.57,.81) );\n\n//nariz\nvec2 pt6[7]=vec2[]( vec2(.52,.85), vec2(.51,.84), vec2(.52,.81), vec2(.52,.83),\nvec2(.52,.84), vec2(.52,.85), vec2(.52,.85) );\n\n// ceja 1\nvec2 pt7[15]=vec2[]( vec2(.56,.60), vec2(.58,.55), vec2(.61,.54), vec2(.62,.54),\nvec2(.63,.54), vec2(.65,.56), vec2(.66,.57), vec2(.66,.58), vec2(.65,.60),\nvec2(.63,.58), vec2(.62,.57), vec2(.60,.57), vec2(.58,.57), vec2(.57,.59),\nvec2(.56,.60) );\n\n// ceja 2\nvec2 pt8[16]=vec2[]( vec2(.39,.58), vec2(.41,.55), vec2(.43,.54), vec2(.44,.53),\nvec2(.45,.54), vec2(.47,.55), vec2(.48,.57), vec2(.49,.59), vec2(.48,.60),\nvec2(.47,.57), vec2(.45,.56), vec2(.44,.56), vec2(.43,.56), vec2(.42,.57),\nvec2(.41,.60), vec2(.39,.58)  );\n\n//boca\nvec2 pt9[13]=vec2[]( vec2(.48,.87), vec2(.51,.88), vec2(.53,.88), vec2(.54,.87),\nvec2(.56,.87), vec2(.57,.87), vec2(.57,.90), vec2(.55,.93), vec2(.52,.93),\nvec2(.49,.93), vec2(.48,.90), vec2(.48,.88), vec2(.48,.87) );\n\nvec2 pt10[12]=vec2[]( vec2(.38,.88), vec2(.36,.88), vec2(.34,.86), vec2(.31,.82),\nvec2(.31,.80), vec2(.31,.75),  vec2(.31,.71), vec2(.31,.70), vec2(.32,.69),\nvec2(.33,.70), vec2(.35,.72), vec2(.38,.88)\n);\n\nvec2 pt11[13]=vec2[]( vec2(.67,.88), vec2(.69,.88), vec2(.72,.86), vec2(.74,.83),\nvec2(.74,.82), vec2(.75,.78), vec2(.75,.75), vec2(.75,.72), vec2(.75,.70),\nvec2(.73,.70), vec2(.72,.70), vec2(.70,.73), vec2(.67,.88)\n);\n\n\nvec3 RostroGoku(in vec2 pp, vec3 col) \n{\n  vec2 p= rotatev2( pp, radians(180.0)); \n  float sd0 = sdPoly11(p-vec2(0.0,-0.2), pt0);\n  //pelo 1\n  float sd1 = sdPoly29(p-vec2(0.22,0.0), pt1);\n  //pelo 2\n  float sd2 = sdPoly16(p-vec2(0.20,0.0), pt2);\n  //pelo centro\n  float sd3 = sdPoly36(p*0.7-vec2(-0.02,-0.21), pt3);\n  //ojo \n  float sd4 = sdPoly16(p-vec2(0.15,-0.02), pt4);\n  float sd5 = sdPoly17(p-vec2(0.2,-0.02), pt5);\n  //nariz\n  float sd6 = sdPoly07(p-vec2(0.18,-0.03), pt6);\n  //ceja 1 y 2\n  float sd7 = sdPoly15(p-vec2(0.0,0.0), pt7);\n  float sd8 = sdPoly16(p-vec2(0.35,0.0), pt8);\n  //boca\n  float sd9 = sdPoly13(p-vec2(0.19,0.0), pt9);\n  //orejas\n  float sd10 = sdPoly12(p-vec2(0.16,-0.04), pt10);\n  float sd11 = sdPoly13(p-vec2(0.26,-0.04), pt11);\n  float dcornea1= sdCircle(p-vec2(0.6,0.75), 0.02 );\n  float dcornea2= sdCircle(p-vec2(0.8,0.75), 0.02 );\n  //---------------\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd1,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd2,0.0));\n  //rostro\n  col = mix(col,vec3(0.99, 0.73,0.70)*1.2,S(sd0,0.0));\n  //ojos\n  col = mix(col,vec3(1.0)*1.2,S(sd4,0.0));\n  col = mix(col,vec3(1.0)*1.2,S(sd5,0.0));\n  //pelo centro\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd3,0.0));\n  //nariz\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd6,0.0));\n  //ceja\n  col = mix(col,vec3(0.0)*1.2,S(sd7,0.0));\n  col = mix(col,vec3(0.0)*1.2,S(sd8,0.0));\n  // boca\n  col = mix(col,vec3(0.0, 0.0,0.0)*1.2,S(sd9,0.0));\n  //oreja\n  col = mix(col,vec3(0.9, 0.75,0.71)*1.2,S(sd10,0.0));\n  col = mix(col,vec3(0.9, 0.75,0.71)*1.2,S(sd11,0.0));\n  //cornea\n  col = mix(col,vec3(0.0)*1.2,S(dcornea1,0.0));\n  col = mix(col,vec3(0.0)*1.2,S(dcornea2,0.0));\n  \n  \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv*0.75+vec2(-0.5,-0.5);\n    \n   \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+uv.yyx);\n    \n    \n     col= RostroGoku( p,col);\n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdf3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 513, 546, 546, 568], [569, 569, 602, 602, 624], [625, 625, 658, 658, 679], [681, 719, 755, 755, 800], [801, 814, 851, 851, 931], [933, 933, 968, 968, 996], [997, 997, 1031, 1031, 1128], [1129, 1153, 1178, 1178, 1197], [1198, 1198, 1238, 1238, 1270], [4692, 5345, 5385, 5385, 7029], [7030, 7030, 7087, 7087, 7391]], "test": "valid"}
{"id": "fdfGR7", "name": "Artifact as an animation effect", "author": "yasuo", "description": "Artifact as an animation effect.", "tags": ["effect"], "likes": 6, "viewed": 238, "published": "Public API", "date": "1615654833", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 16\n#define MAX_DIST 16.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat octahedrons(vec3 p, float tval) {\n    vec3 prevP = p; \n    float t = iTime*tval;\n    float t2 = iTime*tval*2.0;\n    \n    float d = sdOctahedron(p*matRotateX(radians(-40.0*t))*matRotateZ(radians(20.0*t)),0.3);\n    \n    p = prevP;\n    p*=matRotateZ(radians(20.0*t2))*matRotateY(radians(30.0*t2));\n    \n    p.xy = DF(vec2(p.x,p.y),2.0);\n    p.xy = abs(p.xy);\n    p.xy -= vec2(0.6+sin(t)*0.2);\n    \n    float d2 = sdOctahedron(p*matRotateX(radians(-40.0*t)),0.15);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    vec3 tempP = p;\n    p.x = abs(p.x);\n    \n    float lineThickness = 0.01;\n    vec3 pos0 = vec3(1.5,1.0,0.0);\n    vec3 pos1 = vec3(1.5,-0.5,0.0);\n    vec3 pos2 = vec3(1.5,-2.0,0.0);\n    float d = octahedrons(p-pos0,1.5);\n    d = min(d, max(length(p.yz-pos0.yz)-lineThickness,p.x-pos0.x));\n    \n    tempP = p;\n    p*=matRotateZ(radians(-55.0));\n    p.y+=1.65;\n    d = min(d, max(length(p.yz-pos0.yz)-lineThickness,p.x-pos0.x));\n    p = tempP;\n        \n    tempP = p;\n    p*=matRotateZ(radians(30.0));\n    p.y-=0.7;\n    p.x+=0.7;\n    d = min(d, max(length(p.yz-pos0.yz)-lineThickness,p.x-pos0.x));\n    p = tempP;\n    \n    d = min(d,octahedrons(p-pos1,1.6));\n    \n    tempP = p;\n    p*=matRotateZ(radians(25.0));\n    p.y+=0.6;\n    p.x-=0.5;\n    d = min(d, max(length(p.yz-pos1.yz)-lineThickness,p.x-pos1.x));\n    p = tempP;    \n    \n    tempP = p;\n    p*=matRotateZ(radians(-25.0));\n    p.y+=0.7;\n    p.x+=0.4;\n    d = min(d, max(length(p.yz-pos1.yz)-lineThickness,p.x-pos1.x));\n    p = tempP;  \n    \n    d = min(d, max(length(p.yz-pos1.yz)-lineThickness,p.x-pos1.x));\n    \n    tempP = p;\n    p.y+=0.5;\n    p.y=abs(p.y);\n    d = min(d, max(length(p.xz-pos1.xz)-lineThickness,p.y-pos1.y-2.0));\n    p = tempP;\n    \n    d = min(d,octahedrons(p-pos2,1.3));\n    \n    d = min(d, max(length(p.yz-pos2.yz)-lineThickness,p.x-pos2.x));\n    \n    tempP = p;\n    p*=matRotateZ(radians(-25.0));\n    p.y+=0.5;\n    p.x+=1.1;\n    d = min(d, max(length(p.yz-pos2.yz)-lineThickness,p.x-pos2.x));\n    p = tempP; \n    \n    p = prevP;\n    \n    p.y+=0.4;\n    p.y = abs(p.y);\n    p.y-=2.3;\n    float d2 = min(d,octahedrons(p,1.7));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y+=0.5;\n    p.y = abs(p.y);\n    p.y-=2.0;\n    d2 = octahedrons(p-vec3(0.0,-1.25,0.0),2.0);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=matRotateX(radians(30.0*iTime));\n    p.xz = DF(vec2(p.x,p.z),6.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(2.7+sin(iTime)*0.6);\n    \n    d2 = sdOctahedron(p,0.2);\n    d = min(d,d2);\n    \n    d*= (1.-hash12(gl_FragCoord.xy+iTime)*.2); // by https://www.shadertoy.com/view/tlGfzd\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyz+vec3(0,1,2));\n    vec4 res = vec4(col,d);\n        \n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*0.5+0.5;\n    vec3 col = 0.5 + 0.5*cos(iTime+rd.xyz+vec3(0,1,2));\n    vec3 col2 = mix(vec3(.2,.3,.8),col,k);\n    return col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, -6.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(iTime*1.2);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r),vec3(dif),0.5)+spec;\n    } else {\n        // background\n        col += Bg(rd);\n    }\n    \n    fragColor = vec4(col,1.0)+(noise(uv.x*uv.y*iTime*0.1))*0.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 654, 676, 676, 750], [751, 770, 792, 792, 909], [910, 910, 948, 948, 1001], [1003, 1003, 1042, 1042, 1514], [1516, 1516, 1538, 1538, 3763], [3765, 3765, 3798, 3798, 4051], [4053, 4053, 4077, 4077, 4278], [4280, 4280, 4322, 4322, 4517], [4519, 4519, 4537, 4537, 4683], [4685, 4685, 4742, 4742, 5564]], "test": "valid"}
{"id": "fdfGR8", "name": "Fractal 38_gaz", "author": "gaz", "description": "inspired : https://twitter.com/zozuar/status/1369637083430744068", "tags": ["fractal"], "likes": 8, "viewed": 333, "published": "Public API", "date": "1615441483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 q=vec3(3,3,.0),\n    p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=.3;\n        ++i<99.;\n        O.xyz+=cos(vec3(7,6,9)/log(s*.2))*.02\n    )\n    {\n        p=g*d-vec3(.4,.1,.8);\n        p=R(p,normalize(vec3(1,2,3)),-iTime*.1);\n        s=2.;\n        for(int i=0;\n            i++<7;\n            p=q-abs(p-q*.4)\n        )\n            s*=e=15./min(dot(p,p),15.),\n            p=abs(p)*e-2.;\n        g+=min(10.,length(p.xz)-.5)/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.5,3.6,.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 628]], "test": "valid"}
{"id": "fdfGzX", "name": "Fractal 40_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 241, "published": "Public API", "date": "1616336421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,s,e,g=.2,l;\n        ++i<80.;\n        O+=abs(cos(vec4(4,3,24,1)+log(s)*.8))*s*1e-4/i\n    )\n    {\n        p=g*d-vec3(.1,.2,1);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        s=2.;\n        l=dot(p,p);\n        p=abs(abs(p)-.7)-.5;\n        p.x<p.y?p=p.yxz:p;\n        p.y<p.z?p=p.xzy:p;\n        for(int i=0;i++<8;){\n            s*=e=2./clamp(dot(p,p),.004+tan(10.*sin(iTime*.2))*.002,1.35);\n            p=abs(p)*e-vec2(.5*l,12.).xxy;\n        }\n        g+=e=length(p-clamp(p,-1.,1.))/s;\n    }\n    O.xyz=pow(O.xyz,vec3(1.1,.6,.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdfGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 734]], "test": "valid"}
{"id": "fdjGRD", "name": "3D Rotation Example", "author": "inspirnathan", "description": "Example of rotating a cube. Learn more about how this all works in my tutorial: [url]https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8[/url]", "tags": ["raymarching", "tutorial", "rotate", "rotation", "inspirnathan"], "likes": 4, "viewed": 178, "published": "Public", "date": "1617042995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Visit my tutorial to learn how this works: https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface sdScene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = minWithColor(co, sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), rotateY(iTime)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n\n    col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 145, 172, 172, 319], [321, 359, 386, 386, 533], [535, 573, 600, 600, 747], [749, 769, 786, 786, 880], [1091, 1091, 1162, 1162, 1310], [1312, 1312, 1347, 1347, 1397], [1399, 1399, 1449, 1449, 1504], [1506, 1506, 1531, 1531, 1748], [1750, 1750, 1810, 1810, 2077], [2079, 2079, 2107, 2107, 2333], [2335, 2335, 2392, 2392, 3271]], "test": "valid"}
{"id": "fdjGzh", "name": "my test of ray marching", "author": "Stazis", "description": "asd", "tags": ["raymarching"], "likes": 0, "viewed": 60, "published": "Public", "date": "1617117405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_DIST = 100.0;\n\nconst float EPSILON = 0.00001;\nconst float Power = 2.0;\nconst float Bailout = 2.0;\nconst int Iterations = 100;\n\nfloat DE(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat spehereDista(vec3 point) {\n    return DE(point);\n    return length(point) - 1.0;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        spehereDista(vec3(p.x + EPSILON, p.y, p.z)) - spehereDista(vec3(p.x - EPSILON, p.y, p.z)),\n        spehereDista(vec3(p.x, p.y + EPSILON, p.z)) - spehereDista(vec3(p.x, p.y - EPSILON, p.z)),\n        spehereDista(vec3(p.x, p.y, p.z  + EPSILON)) - spehereDista(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.010;\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y * zoom;\n    \n    vec3 eye = vec3(0,0,10);\n    vec3 direction = normalize(vec3(uv.x, uv.y, -5));\n    \n    float dist = 0.0;\n    float depth = 0.0;\n    vec3 point = eye;\n    \n    for (int i = 0; i < 255; i++) {\n    \n        depth = spehereDista(point);\n        if (dist > MAX_DIST) {\n            fragColor = vec4(0, 0, 0, 1);\n            return;\n        }\n        dist += depth;\n        point = eye + dist * direction;\n        \n        if (depth < .00001) {\n            vec3 K_a = vec3(0.2, 0.2, 0.2);\n            vec3 K_d = vec3(0.7, 0.2, 0.2);\n            vec3 K_s = vec3(1.0, 1.0, 1.0);\n            float shininess = 10.0;\n            vec3 color = phongIllumination(K_a, K_d, K_s, shininess, point, eye);\n    \n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n    }\n    \n        fragColor = vec4(0,0,0,1);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 163, 163, 691], [693, 693, 725, 725, 781], [783, 783, 812, 812, 1146], [1149, 1149, 1289, 1289, 1879], [1881, 1881, 1966, 1966, 2766], [2768, 2768, 2825, 2825, 3756]], "test": "valid"}
{"id": "fdl3Rr", "name": "NY167 - SDF Test", "author": "newyork167", "description": "Test scene using SDF", "tags": ["cornellbox"], "likes": 0, "viewed": 30, "published": "Public", "date": "1615930113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n};\n\nfloat sphereSDF(vec3 p, Sphere sphere) {\n    float dSphere = length(p - sphere.position.xyz) - sphere.radius;\n    return dSphere;\n}\n\nvec3 getNormalSphere(vec3 p, Sphere sphere) {\n    vec2 e = vec2(.0001, 0);\n    float d = sphereSDF(p, sphere);\n    vec3 n = d - vec3(\n        sphereSDF(p-e.xyy, sphere),\n        sphereSDF(p-e.yxy, sphere),\n        sphereSDF(p-e.yyx, sphere));\n    return normalize(n);\n}\n\nfloat getDist(vec3 p, Sphere sphere) {\n    return sphereSDF(p, sphere);\n}\n\nfloat rayMarch(Ray r, Sphere sphere) {\n\tfloat d0 = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = r.origin + d0*r.direction;\n        float dS = getDist(p, sphere);\n        d0 += dS;\n        \n        if (dS < SURFACE_DIST || d0 > MAX_DIST)\n            break;\n    }\n    \n    return d0;\n}\n\nfloat getLightSphere(vec3 p, Sphere sphere) {\n    vec3 lightPos = vec3(-sin(iTime), 20.0 * sin(cos(iTime)), -cos(iTime));\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormalSphere(p, sphere);\n    \n    float dif = dot(n, l);\n    float d = rayMarch(Ray(p + n*SURFACE_DIST*2., l), sphere);\n    \n    if (d < length(lightPos - p)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    Ray ray = Ray(ro, rd);\n    \n    Sphere testSphere = Sphere(vec3(sin(iTime), 1, 6. + cos(iTime)), 1.0);    \n    vec3 sphereColor = vec3(1, 0.5, 0);\n\n    vec3 col = vec3(0);\n    vec3 p = vec3(uv, 1.0) - vec3(0., .0, 0.);\n    float r = 1.;\n    float d = rayMarch(ray, testSphere);\n    \n    vec3 p1 = ro + rd * d;\n    float dif = getLightSphere(p1, testSphere);\n    \n    col = dif * sphereColor;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdl3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 218, 218, 309], [311, 311, 356, 356, 580], [582, 582, 620, 620, 655], [657, 657, 695, 695, 962], [964, 964, 1009, 1009, 1353], [1355, 1355, 1412, 1462, 2056]], "test": "valid"}
{"id": "fdlGDM", "name": "Awkward Face", "author": "BrownieYi", "description": "111", "tags": ["111"], "likes": 5, "viewed": 37, "published": "Public", "date": "1616064122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float sadTime) {\n    float offs = mix(.2, 0., sadTime);\n    uv.y += offs;\n    \n    float y = uv.y;\n    uv.y += .6*uv.x*mix(.5, .8, sadTime)-mix(.1, .3, sadTime) - .6;\n    uv.x -= mix(.0, .1, sadTime)+ .1;\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n   \tfloat d1 = length(uv);\n    float s1 = S(.45, 0.45-blur, d1*1.);\n    float d2 = length(uv-vec2(.1, -.2)*.7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s2-s1);\n    \n    float colMask = remap01(.7, .8, y)*.75;\n    colMask *= S(.6, .9, browMask);\n    colMask *= sadTime;\n    vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); \n   \n    uv.y += .15-offs*.5;\n    blur += mix(.0, .1, sadTime);\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s2-s1);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float sadTime) {\n    uv -= .5;\n    uv.x *= side;\n    \n\tfloat d = length(uv);\n    vec4 irisCol = vec4(.6, .3, .1, 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5);\n    col.a = S(.5, .48, d);\n    \n    col.rgb *= 1. - S(.45, .5, d)*.5*sat(-uv.y-uv.x*side);\n    d = length(uv-m*.4);\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d));\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\n    float irisMask = S(.28, .25, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n    \n    d = length(uv-m*.45);\n    \n    float pupilSize = mix(.4, .16, sadTime);\n    float pupilMask = S(pupilSize, pupilSize*.85, d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask);\n    \n    float t = iTime*3.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-sadTime);\n    \n    uv += offs;\n    float highlight = S(.1, .09, length(uv-vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(.92), highlight);\n    return col;\n}\n\nvec4 Mouth(vec2 uv, float sadTime) {\n    uv -= .5;\n\tvec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x*uv.x*-2.*sadTime; //2. -> -2.\n    \n    uv.x *= mix(2.5, 1.5, sadTime); //1. -> 1.5\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x)*.5+.1)*(1.-sadTime);\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1., 1., .8)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv, float sadTime) {\n\tvec4 col = vec4(1., .25, .1, 1.);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix(col.rgb, vec3(.7, .2, .2), S(.47, .48, d));\n    \n    float highlight = S(.41, .405, d);\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= .3*S(.18, .19, length(uv-vec2(.21, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25, -.2));\n    float cheek = S(.2,.01, d)*.4;\n    cheek *= 3.*S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1., 0., 0.), cheek);\n    \n    \n    float t = iTime*3.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-sadTime);\n    return col;\n}\n\nvec4 Awkward(vec2 uv, vec2 m, float sadTime) {\n\tvec4 col = vec4(0.);\n    \n    if(length(uv)<.5) {\t\t\t\t\t// only bother about pixels that are actually inside the head\n        float side = sign(uv.x);\n        uv.x = abs(uv.x);\n        vec4 head = Head(uv, sadTime);\n        col = mix(col, head, head.a);\n\n        if(length(uv-vec2(.2, .075))<.175) {\n            vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, sadTime);\n            col = mix(col, eye, eye.a);\n        }\n\n        if(length(uv-vec2(.0, -.15))<.3) {\n            vec4 mouth = Mouth(within(uv, vec4(-.3, -.43, .3, -.13)), sadTime);\n            col = mix(col, mouth, mouth.a);\n        }\n\n        if(length(uv-vec2(.185, .325))<.18) {\n            vec4 brow = Brow(within(uv, vec4(-.2, .2, .6, .45)), sadTime);\n            col = mix(col, brow, brow.a);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    if(m.x<-.49 && m.y<-.49) {\n    \tfloat s = sin(t*.5);\n        float c = cos(t*.38);\n        \n        m = vec2(s, c)*.4;\n    }\n    \n    if(length(m) > .707) m *= 0.;\n    \n    float d = dot(uv, uv);\n    uv -= m*sat(.23-d);\n    \n    float sadTime = sin(t*.5)*.5+.5;\n\tfragColor = Awkward(uv, m, sadTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 181, 181, 209], [211, 211, 269, 269, 309], [311, 311, 344, 344, 386], [388, 388, 423, 423, 1424], [1426, 1426, 1480, 1480, 2473], [2475, 2475, 2511, 2511, 3080], [3082, 3082, 3117, 3117, 3890], [3892, 3892, 3938, 3938, 4752], [4754, 4754, 4811, 4811, 5304]], "test": "valid"}
{"id": "fdlGR7", "name": "Astronium", "author": "wildniklin", "description": "I know it's missing the plug at the end, most likely won't add anyways. Element from Astroneer, the game.", "tags": ["astronium"], "likes": 3, "viewed": 116, "published": "Public API", "date": "1615713710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int maxsteps = 100;\nconst float maxdist = 100.0;\nconst float mindist = 0.0001;\n\nconst float pi = 3.1415;\nconst float pid3 = pi / 3.0;\nconst float pid6 = pid3 * 0.5;\n\nmat2 rotate(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nstruct mapresult {\n    float d;\n    int m;\n};\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nmapresult map(vec3 p) {\n    float d = maxdist;\n    int m = 0;\n    \n    float ad = p.y + 0.5;\n    if(ad < d) {\n        d = ad;\n        m = 2;\n    }\n    \n    ////////\n    \n    ad = d;\n    \n    float time = fract(iTime * 0.125) * 4.0;\n    \n    vec3 tp = p;\n    tp.y = tp.y - clamp(round(tp.y), 0.0, floor(clamp(time - 1.0, 0.0, 1.0) * 3.0));\n    \n    if(time > 0.0) ad = min(ad, sdSphere(tp, 0.5));\n    vec3 pos = vec3(0.0, 0.0, 1.0);\n    if(time > 0.0833) ad = min(ad, sdSphere(tp - pos, 0.5));\n    if(time > 0.1666) ad = min(ad, sdSphere(tp + pos, 0.5));\n    pos.xz *= rotate(pid3);\n    if(time > 0.25) ad = min(ad, sdSphere(tp - pos, 0.5));\n    if(time > 0.3333) ad = min(ad, sdSphere(tp + pos, 0.5));\n    pos.xz *= rotate(pid3);\n    if(time > 0.4166) ad = min(ad, sdSphere(tp - pos, 0.5));\n    if(time > 0.5) ad = min(ad, sdSphere(tp + pos, 0.5));\n    pos.xz *= rotate(pid6);\n    if(time > 0.5833) ad = min(ad, sdSphere(tp - pos * 1.72, 0.5));\n    if(time > 0.6666) ad = min(ad, sdSphere(tp + pos * 1.72, 0.5));\n    pos.xz *= rotate(pid3);\n    if(time > 0.75) ad = min(ad, sdSphere(tp - pos * 1.72, 0.5));\n    if(time > 0.8333) ad = min(ad, sdSphere(tp + pos * 1.72, 0.5));\n    pos.xz *= rotate(pid3);\n    if(time > 0.9166) ad = min(ad, sdSphere(tp - pos * 1.72, 0.5));\n    if(time > 1.0) ad = min(ad, sdSphere(tp + pos * 1.72, 0.5));\n    \n    if(ad < d) {\n        d = ad;\n        m = 1;\n    }\n    \n    ////////\n    \n    return mapresult(d, m);\n}\n\nmapresult march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    int m = 0;\n    for(int i = 0; i < maxsteps; i++) {\n        mapresult di = map(ro + (rd * d));\n        d += di.d;\n        m = di.m;\n        if((abs(di.d) < mindist) || (d > maxdist)) break;\n    }\n    return mapresult(d, m);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(mindist, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).d - map(p - e.xyy).d,\n        map(p + e.yxy).d - map(p - e.yxy).d,\n        map(p + e.yyx).d - map(p - e.yyx).d\n    ));\n}\n\nfloat light_directional(vec3 p, vec3 dir) {\n    vec3 n = normal(p);\n    float d = march(p + (n * mindist * 2.0), dir).d;\n    float v = 0.0;\n    if(d >= maxdist) v = 1.0;\n    return v * dot(n, dir);\n}\n\nvec3 sky(vec3 rd) {\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.2, 0.1, 0.0) * smoothstep(0.1, 0.0, abs(rd.y));\n    col += vec3(0.7, 0.85, 1.0);\n    return col;\n}\n\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 4.5, -8.0);\n    vec3 rd = normalize(vec3(uv, 0.8));\n\n    rd.yz *= rotate(pi * 0.125);\n\n    ro.xz *= rotate(iTime * pi * 0.125);\n    rd.xz *= rotate(iTime * pi * 0.125);\n\n    mapresult di = march(ro, rd);\n    float d = di.d;\n    int m = di.m;\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    float brightness = 0.5 + (0.5 * light_directional(p, normalize(vec3(0.5, 0.5, 0.5))));\n\n    col += brightness;\n\n    if(m == 1) {\n        col *= mix(mix(vec3(0.6, 1.0, 0.5), vec3(0.5, 0.2, 1.0), smoothstep(0.0, 0.5, 0.5 + (0.5 * dot(rd, n)))), vec3(0.4, 0.7, 0.8), brightness * smoothstep(0.8, 0.5, brightness));\n    } else if(m == 2) {\n        col *= mix(vec3(0.07, 0.07, 0.07), vec3(0.5, 0.7, 1.0), clamp(step(fract(p.x), 0.01) + step(fract(p.z), 0.01) + step(0.99, fract(p.x)) + step(0.99, fract(p.z)), 0.0, 1.0));\n    }\n    \n    col = mix(col, sky(rd), smoothstep(maxdist * 0.5, maxdist, d));\n\n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 194, 194, 260], [309, 309, 342, 342, 370], [372, 372, 395, 395, 1819], [1821, 1821, 1856, 1856, 2104], [2106, 2106, 2127, 2127, 2331], [2333, 2333, 2376, 2376, 2532], [2534, 2534, 2553, 2553, 2706], [2708, 2708, 2747, 2747, 3811]], "test": "valid"}
{"id": "fdlGRH", "name": "neuron 1512 \"lol\"", "author": "eps", "description": "Neuron 4/5/add_6:1512 from CLIP model, responsible for \"lol\" emotion, parameterized to CPPN and exported to GLSL with simple animation. \n\noriginal technique https://github.com/wxs/cppn-to-glsl", "tags": ["clip", "neurons", "cppn"], "likes": 10, "viewed": 146, "published": "Public", "date": "1615498258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 16\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.405, -0.198, 0.010, 0.438) + mat4(vec4(0.613, -1.955, -1.409, 0.006), vec4(0.442, -0.127, 0.383, -0.466), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(0.335, -0.245, 0.153, 0.266) + mat4(vec4(0.303, 1.814, 0.008, 0.682), vec4(-0.464, -0.481, 0.607, -1.136), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.297, 0.034, -0.104, 0.092) + mat4(vec4(0.072, 0.305, -0.642, 0.698), vec4(-0.120, -0.788, -0.056, 0.304), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.193, -0.177, -0.210, 0.108) + mat4(vec4(0.345, -0.795, 0.873, -0.498), vec4(0.443, -0.264, -0.762, 1.473), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 1 \nbufA[0] = vec4(-0.227, -0.220, 0.471, -0.100) + mat4(vec4(0.449, 0.112, 0.259, 0.100), vec4(0.398, -0.566, -0.033, -0.497), vec4(0.374, 0.053, 0.529, -0.129), vec4(-0.381, -0.127, -0.295, -0.277)) * bufB[0] + mat4(vec4(-0.109, -0.083, 0.032, -0.272), vec4(0.157, -0.403, -0.230, 0.099), vec4(-0.295, 0.203, 0.108, 0.270), vec4(0.050, 0.393, 0.025, 0.333)) * bufB[1] + mat4(vec4(-0.226, -0.276, -0.229, 0.099), vec4(0.301, 0.240, -0.389, -0.073), vec4(-0.307, 0.058, -0.092, -0.334), vec4(-0.209, -0.375, -0.159, -0.173)) * bufB[2] + mat4(vec4(-0.131, 0.120, 0.300, 0.035), vec4(-0.550, -0.503, 0.518, 0.414), vec4(0.254, -0.156, 0.210, 0.111), vec4(-0.389, 0.300, 0.759, 0.202)) * bufB[3];\nbufA[1] = vec4(-0.163, -0.245, 0.312, 0.055) + mat4(vec4(-0.161, 0.305, 0.010, 0.272), vec4(0.122, 0.185, -0.415, 0.534), vec4(-0.206, -0.248, -0.077, -0.242), vec4(-0.189, -0.088, 0.019, 0.373)) * bufB[0] + mat4(vec4(-0.171, 0.120, 0.379, 0.011), vec4(0.124, 0.249, -0.172, -0.243), vec4(0.216, 0.093, 0.130, -0.387), vec4(-0.223, 0.076, 0.273, -0.051)) * bufB[1] + mat4(vec4(-0.317, 0.061, -0.008, -0.410), vec4(0.002, -0.279, 0.120, 0.226), vec4(-0.306, 0.355, -0.203, 0.084), vec4(0.275, 0.381, -0.345, 0.102)) * bufB[2] + mat4(vec4(0.231, 0.311, 0.036, -0.083), vec4(0.458, -0.131, -0.206, 0.496), vec4(0.206, -0.001, -0.400, 0.371), vec4(0.148, -0.001, 0.165, 0.512)) * bufB[3];\nbufA[2] = vec4(0.281, -0.226, -0.310, 0.447) + mat4(vec4(0.475, 0.100, -0.271, 0.103), vec4(0.437, 0.053, 0.130, -0.124), vec4(-0.233, -0.020, -0.344, -0.482), vec4(0.540, 0.048, 0.328, 0.369)) * bufB[0] + mat4(vec4(0.153, -0.339, 0.106, 0.327), vec4(0.245, 0.458, 0.220, -0.237), vec4(0.002, 0.033, 0.256, -0.162), vec4(0.049, 0.018, 0.315, 0.238)) * bufB[1] + mat4(vec4(-0.064, -0.106, 0.188, -0.124), vec4(0.116, -0.110, 0.305, 0.799), vec4(0.347, 0.165, -0.011, 0.202), vec4(0.287, 0.423, -0.182, -0.498)) * bufB[2] + mat4(vec4(-0.354, 0.468, -0.212, 0.058), vec4(-0.143, -0.060, 0.341, 0.009), vec4(-0.315, -0.220, 0.558, 0.071), vec4(-0.044, -0.081, -0.050, 0.069)) * bufB[3];\nbufA[3] = vec4(-0.053, 0.415, -0.178, 0.411) + mat4(vec4(0.434, 0.021, -0.398, 0.104), vec4(0.105, -0.330, -0.417, -0.255), vec4(0.055, 0.083, -0.017, 0.328), vec4(-0.195, -0.152, -0.393, -0.000)) * bufB[0] + mat4(vec4(-0.106, -0.083, -0.348, 0.011), vec4(0.135, 0.020, -0.026, 0.585), vec4(-0.086, 0.224, -0.005, 0.112), vec4(0.073, 0.079, -0.183, -0.317)) * bufB[1] + mat4(vec4(0.013, 0.331, -0.205, -0.276), vec4(-0.371, -0.249, -0.422, 0.246), vec4(0.217, 0.405, -0.089, -0.039), vec4(0.487, 0.462, -0.296, -0.308)) * bufB[2] + mat4(vec4(-0.239, -0.308, 0.158, -0.168), vec4(-0.046, 0.193, 0.292, -0.137), vec4(0.097, -0.034, 0.156, 0.102), vec4(0.206, -0.045, 0.223, 0.166)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 2 \nbufA[0] = vec4(-0.481, 0.314, -0.351, -0.215) + mat4(vec4(0.341, 0.008, 0.337, 0.020), vec4(0.016, -0.104, 0.479, 0.099), vec4(-0.120, -0.151, 0.229, 0.079), vec4(0.457, 0.025, -0.534, -0.216)) * bufB[0] + mat4(vec4(-0.093, 0.232, 0.576, 0.237), vec4(0.568, -0.368, 0.173, -0.052), vec4(-0.276, 0.120, 0.137, 0.085), vec4(0.253, -0.145, 0.110, -0.435)) * bufB[1] + mat4(vec4(0.214, 0.053, 0.584, -0.089), vec4(0.053, -0.053, 0.123, 0.256), vec4(0.114, -0.253, -0.390, -0.042), vec4(-0.267, 0.260, 0.120, -0.308)) * bufB[2] + mat4(vec4(0.200, -0.456, 0.070, -0.134), vec4(0.457, 0.261, -0.143, 0.164), vec4(0.455, -0.188, -0.241, 0.073), vec4(-0.017, 0.069, 0.348, 0.114)) * bufB[3];\nbufA[1] = vec4(-0.057, -0.128, 0.539, -0.087) + mat4(vec4(0.445, -0.406, -0.420, -0.111), vec4(-0.190, 0.335, 0.137, -0.031), vec4(0.303, -0.064, 0.000, -0.082), vec4(0.069, -0.086, 0.191, 0.366)) * bufB[0] + mat4(vec4(0.044, 0.539, -0.418, -0.025), vec4(-0.186, 0.284, 0.286, 0.176), vec4(0.038, -0.154, 0.021, -0.466), vec4(0.402, -0.234, 0.230, 0.511)) * bufB[1] + mat4(vec4(0.068, -0.240, 0.087, -0.004), vec4(-0.258, -0.250, 0.068, -0.280), vec4(-0.284, 0.370, 0.066, 0.118), vec4(0.174, -0.261, 0.239, 0.237)) * bufB[2] + mat4(vec4(-0.266, 0.446, 0.375, 0.056), vec4(-0.127, -0.202, 0.055, 0.126), vec4(-0.090, -0.088, 0.137, 0.029), vec4(0.162, -0.150, 0.129, -0.089)) * bufB[3];\nbufA[2] = vec4(-0.421, 0.165, 0.113, 0.360) + mat4(vec4(-0.064, -0.133, 0.024, -0.400), vec4(-0.208, 0.229, 0.052, -0.121), vec4(-0.255, -0.324, 0.136, -0.155), vec4(-0.349, 0.041, -0.258, 0.234)) * bufB[0] + mat4(vec4(-0.095, -0.171, 0.246, -0.128), vec4(0.055, 0.108, -0.208, -0.143), vec4(0.075, 0.033, -0.085, -0.340), vec4(-0.103, -0.202, -0.233, -0.149)) * bufB[1] + mat4(vec4(0.442, -0.082, 0.068, -0.012), vec4(0.024, 0.037, -0.209, -0.019), vec4(-0.120, -0.135, 0.631, -0.028), vec4(-0.002, -0.131, -0.062, 0.109)) * bufB[2] + mat4(vec4(-0.133, -0.006, -0.078, -0.501), vec4(-0.133, 0.001, -0.254, -0.060), vec4(-0.166, 0.120, -0.225, -0.097), vec4(0.117, -0.333, 0.275, 0.221)) * bufB[3];\nbufA[3] = vec4(-0.002, 0.502, 0.498, 0.130) + mat4(vec4(-0.303, -0.023, 0.324, -0.061), vec4(-0.088, 0.270, 0.051, 0.089), vec4(-0.373, -0.374, -0.402, -0.113), vec4(0.496, 0.063, 0.158, -0.100)) * bufB[0] + mat4(vec4(-0.154, -0.030, 0.177, -0.406), vec4(0.051, -0.083, 0.082, 0.291), vec4(-0.011, -0.254, -0.555, 0.070), vec4(-0.051, 0.282, -0.556, -0.297)) * bufB[1] + mat4(vec4(-0.092, 0.262, 0.327, -0.152), vec4(0.136, 0.513, 0.156, -0.433), vec4(-0.418, 0.160, 0.102, 0.210), vec4(-0.058, 0.166, -0.750, 0.017)) * bufB[2] + mat4(vec4(-0.468, -0.069, 0.327, -0.194), vec4(-0.087, 0.154, -0.241, -0.127), vec4(-0.018, -0.021, -0.078, 0.096), vec4(-0.223, -0.103, 0.019, 0.481)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 3 \nbufA[0] = vec4(-0.521, -0.250, 0.061, -0.003) + mat4(vec4(-0.357, 0.338, -0.222, 0.139), vec4(0.082, -0.298, -0.044, -0.666), vec4(0.460, 0.056, -0.578, -0.025), vec4(0.207, 0.171, 0.038, 0.128)) * bufB[0] + mat4(vec4(-0.009, -0.194, -0.147, -0.231), vec4(-0.242, 0.101, -0.065, -0.096), vec4(0.159, 0.210, 0.064, 0.072), vec4(0.446, 0.012, -0.270, 0.104)) * bufB[1] + mat4(vec4(-0.116, -0.185, -0.082, -0.051), vec4(0.273, -0.297, -0.527, -0.051), vec4(-0.037, 0.024, 0.035, 0.203), vec4(0.070, 0.287, 0.056, -0.383)) * bufB[2] + mat4(vec4(0.219, 0.356, 0.038, 0.289), vec4(-0.215, 0.124, 0.098, 0.219), vec4(0.084, 0.168, 0.136, -0.349), vec4(-0.076, 0.040, 0.036, 0.255)) * bufB[3] + in0;\nbufA[1] = vec4(0.486, -0.336, -0.396, 0.070) + mat4(vec4(-0.144, -0.371, -0.192, -0.291), vec4(0.101, -0.079, 0.074, 0.034), vec4(-0.568, -0.350, 0.238, -0.023), vec4(-0.189, 0.184, 0.386, 0.189)) * bufB[0] + mat4(vec4(-0.454, 0.395, 0.055, 0.029), vec4(-0.248, 0.215, 0.020, -0.279), vec4(-0.351, 0.075, 0.452, 0.268), vec4(0.069, -0.191, 0.429, -0.235)) * bufB[1] + mat4(vec4(0.158, 0.462, 0.325, -0.144), vec4(0.358, 0.430, 0.219, 0.155), vec4(-0.100, -0.356, 0.165, 0.036), vec4(-0.165, 0.242, -0.562, -0.027)) * bufB[2] + mat4(vec4(-0.031, 0.379, 0.317, 0.133), vec4(-0.074, 0.087, -0.072, 0.091), vec4(0.286, -0.123, -0.182, 0.360), vec4(0.285, -0.124, 0.064, 0.010)) * bufB[3] + in1;\nbufA[2] = vec4(-0.270, -0.160, -0.145, 0.478) + mat4(vec4(0.195, 0.161, 0.284, -0.060), vec4(0.624, 0.008, -0.035, 0.140), vec4(-0.068, 0.247, -0.317, 0.160), vec4(0.005, 0.179, -0.000, 0.104)) * bufB[0] + mat4(vec4(0.294, 0.456, 0.274, -0.013), vec4(-0.131, 0.155, 0.014, 0.170), vec4(0.221, 0.292, -0.221, 0.179), vec4(0.072, 0.377, -0.328, -0.013)) * bufB[1] + mat4(vec4(0.238, -0.431, -0.452, -0.200), vec4(-0.095, 0.371, -0.211, -0.197), vec4(-0.026, 0.207, 0.098, 0.154), vec4(0.381, 0.063, 0.043, 0.225)) * bufB[2] + mat4(vec4(-0.037, 0.233, -0.093, -0.289), vec4(-0.346, 0.490, -0.497, 0.041), vec4(0.055, -0.376, -0.136, -0.014), vec4(-0.056, 0.172, -0.216, 0.453)) * bufB[3] + in2;\nbufA[3] = vec4(-0.165, -0.094, -0.286, 0.330) + mat4(vec4(-0.014, 0.033, 0.097, 0.108), vec4(0.328, -0.552, -0.090, 0.088), vec4(-0.171, -0.165, 0.256, 0.222), vec4(-0.296, 0.122, -0.015, 0.134)) * bufB[0] + mat4(vec4(-0.086, -0.739, -0.243, 0.430), vec4(0.335, -0.147, 0.132, -0.117), vec4(-0.005, 0.310, 0.231, -0.053), vec4(-0.128, -0.031, -0.239, 0.064)) * bufB[1] + mat4(vec4(0.372, -0.153, 0.212, 0.323), vec4(0.251, 0.054, 0.222, 0.347), vec4(0.229, -0.250, 0.070, 0.280), vec4(-0.027, -0.246, 0.172, 0.497)) * bufB[2] + mat4(vec4(0.059, -0.151, 0.456, -0.037), vec4(-0.358, 0.389, -0.007, -0.211), vec4(0.175, 0.141, 0.167, 0.319), vec4(0.229, -0.089, 0.166, -0.023)) * bufB[3] + in3;\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 4 \nbufA[0] = vec4(0.290, -0.027, 0.479, 0.240) + mat4(vec4(0.228, -0.221, 0.088, -0.191), vec4(0.181, 0.067, -0.205, -0.075), vec4(0.245, 0.124, -0.177, 0.103), vec4(0.170, -0.069, 0.423, 0.215)) * bufB[0] + mat4(vec4(0.119, 0.210, -0.519, 0.024), vec4(-0.166, 0.062, 0.006, 0.292), vec4(-0.457, 0.072, 0.245, 0.227), vec4(0.022, 0.003, 0.334, -0.165)) * bufB[1] + mat4(vec4(-0.059, 0.170, -0.208, -0.138), vec4(0.536, 0.058, 0.479, -0.465), vec4(0.420, 0.185, -0.051, -0.519), vec4(0.058, 0.562, -0.061, 0.057)) * bufB[2] + mat4(vec4(-0.674, -0.004, -0.039, 0.254), vec4(0.365, -0.028, 0.100, -0.184), vec4(0.054, -0.164, 0.429, -0.195), vec4(0.114, -0.968, 0.016, -0.245)) * bufB[3];\nbufA[1] = vec4(-0.179, 0.324, -0.303, 0.319) + mat4(vec4(0.264, 0.442, 0.003, -0.205), vec4(0.368, -0.049, 0.020, -0.558), vec4(0.073, 0.276, 0.281, -0.521), vec4(0.042, 0.173, -0.107, -0.150)) * bufB[0] + mat4(vec4(-0.171, -0.136, -0.620, 0.170), vec4(0.549, 0.021, 0.130, -0.098), vec4(0.014, -0.219, -0.207, 0.522), vec4(-0.092, 0.409, 0.042, 0.063)) * bufB[1] + mat4(vec4(-0.182, 0.274, -0.323, -0.260), vec4(-0.164, -0.208, 0.134, -0.176), vec4(0.391, -0.277, -0.222, 0.165), vec4(0.081, 0.020, -0.000, -0.133)) * bufB[2] + mat4(vec4(0.182, 0.137, 0.406, -0.093), vec4(0.238, -0.268, 0.126, -0.273), vec4(0.389, -0.076, -0.606, -0.018), vec4(0.114, 0.322, 0.220, -0.056)) * bufB[3];\nbufA[2] = vec4(0.358, -0.318, 0.403, -0.547) + mat4(vec4(-0.138, -0.247, -0.339, 0.412), vec4(0.043, -0.380, -0.251, 0.318), vec4(0.498, -0.254, -0.249, 0.253), vec4(-0.261, -0.449, -0.222, 0.480)) * bufB[0] + mat4(vec4(-0.258, -0.119, 0.238, 0.143), vec4(-0.323, -0.389, -0.209, 0.253), vec4(-0.089, -0.420, -0.114, 0.089), vec4(0.199, -0.462, 0.321, 0.117)) * bufB[1] + mat4(vec4(0.054, 0.293, 0.099, -0.139), vec4(-0.011, -0.863, -0.376, 0.344), vec4(-0.044, -0.023, 0.076, 0.174), vec4(0.349, 0.050, 0.007, 0.386)) * bufB[2] + mat4(vec4(0.011, -0.026, 0.209, -0.035), vec4(0.332, 0.219, -0.132, 0.333), vec4(0.349, -0.098, -0.370, 0.020), vec4(0.029, -0.549, -0.043, -0.006)) * bufB[3];\nbufA[3] = vec4(-0.449, 0.350, -0.122, -0.190) + mat4(vec4(0.161, 0.212, -0.349, 0.136), vec4(-0.265, -0.160, -0.383, 0.187), vec4(0.512, -0.230, 0.171, 0.325), vec4(-0.003, 0.304, -0.347, 0.375)) * bufB[0] + mat4(vec4(-0.177, 0.053, 0.423, 0.001), vec4(-0.170, 0.045, -0.080, -0.105), vec4(-0.212, 0.364, 0.146, -0.576), vec4(-0.146, -0.128, 0.133, -0.416)) * bufB[1] + mat4(vec4(-0.079, -0.009, -0.251, -0.263), vec4(-0.222, 0.141, 0.227, -0.379), vec4(0.029, 0.367, -0.086, 0.044), vec4(-0.385, 0.008, -0.198, 0.070)) * bufB[2] + mat4(vec4(-0.689, 0.167, -0.119, 0.274), vec4(0.239, -0.335, -0.169, -0.081), vec4(0.275, -0.110, 0.236, 0.281), vec4(0.007, 0.100, 0.124, 0.072)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 5 \nbufA[0] = vec4(0.039, -0.389, -0.527, 0.071) + mat4(vec4(0.205, 0.077, -0.036, -0.123), vec4(-0.104, 0.425, 0.097, -0.121), vec4(0.013, -0.018, 0.134, -0.389), vec4(-0.287, -0.177, 0.087, 0.062)) * bufB[0] + mat4(vec4(-0.256, 0.214, -0.151, 0.103), vec4(0.367, -0.051, 0.134, 0.086), vec4(0.112, -0.285, 0.128, 0.350), vec4(0.029, 0.484, -0.066, 0.332)) * bufB[1] + mat4(vec4(0.186, 0.262, -0.179, 0.279), vec4(-0.302, -0.067, -0.039, 0.259), vec4(-0.391, -0.350, -0.295, -0.038), vec4(-0.347, 0.038, -0.310, -0.091)) * bufB[2] + mat4(vec4(0.157, -0.332, 0.263, -0.313), vec4(0.392, -0.379, -0.168, -0.141), vec4(-0.192, -0.059, -0.140, -0.183), vec4(-0.039, -0.439, 0.046, -0.041)) * bufB[3];\nbufA[1] = vec4(0.333, 0.099, -0.256, -0.105) + mat4(vec4(0.324, 0.541, 0.071, -0.107), vec4(0.246, 0.255, 0.590, -0.034), vec4(-0.213, 0.245, -0.061, 0.011), vec4(-0.325, -0.663, 0.141, 0.241)) * bufB[0] + mat4(vec4(-0.213, 0.195, 0.221, -0.026), vec4(0.161, -0.144, -0.118, -0.374), vec4(0.080, -0.012, -0.429, -0.126), vec4(0.230, -0.041, 0.394, 0.171)) * bufB[1] + mat4(vec4(0.505, -0.284, -0.212, -0.164), vec4(0.038, 0.033, -0.606, 0.326), vec4(0.257, -0.154, 0.209, -0.218), vec4(0.349, 0.255, -0.053, 0.392)) * bufB[2] + mat4(vec4(-0.527, -0.430, -0.569, 0.455), vec4(0.503, 0.593, 0.085, -0.538), vec4(-0.310, 0.054, 0.150, 0.059), vec4(0.151, 0.654, 0.131, 0.649)) * bufB[3];\nbufA[2] = vec4(-0.200, -0.070, 0.003, -0.445) + mat4(vec4(0.138, -0.083, 0.226, 0.226), vec4(-0.054, 0.043, -0.084, 0.256), vec4(-0.829, -0.107, -0.111, -0.232), vec4(-0.249, -0.177, -0.330, -0.482)) * bufB[0] + mat4(vec4(-0.023, -0.673, 0.174, -0.454), vec4(-0.038, 0.099, -0.111, -0.354), vec4(-0.039, -0.160, 0.231, 0.356), vec4(0.411, -0.175, -0.158, -0.546)) * bufB[1] + mat4(vec4(-0.149, -0.132, 0.517, 0.151), vec4(0.062, -0.035, 0.042, 0.341), vec4(0.033, 0.168, 0.103, -0.218), vec4(-0.237, -0.455, -0.332, 0.119)) * bufB[2] + mat4(vec4(-0.195, -0.501, -0.255, 0.272), vec4(0.067, 0.044, -0.055, -0.102), vec4(-0.263, 0.669, -0.238, 0.288), vec4(0.418, 0.017, -0.107, 0.639)) * bufB[3];\nbufA[3] = vec4(0.103, 0.307, -0.540, -0.242) + mat4(vec4(0.288, -0.167, -0.145, 0.076), vec4(0.052, -0.113, 0.033, -0.065), vec4(0.255, -0.301, 0.348, -0.346), vec4(0.096, -0.093, -0.437, -0.493)) * bufB[0] + mat4(vec4(0.196, -0.256, -0.197, 0.340), vec4(0.427, -0.123, 0.387, 0.453), vec4(0.242, -0.360, 0.037, 0.217), vec4(-0.384, -0.241, -0.000, 0.140)) * bufB[1] + mat4(vec4(0.197, 0.191, 0.015, 0.562), vec4(-0.068, -0.243, -0.741, -0.090), vec4(-0.170, 0.467, -0.098, -0.051), vec4(-0.025, -0.109, 0.239, -0.054)) * bufB[2] + mat4(vec4(-0.057, -0.200, 0.382, -0.494), vec4(-0.424, -0.135, -0.041, 0.072), vec4(-0.137, -0.106, 0.352, 0.020), vec4(0.090, -0.236, 0.094, 0.265)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 6 \nbufA[0] = vec4(0.165, 0.362, -0.541, -0.376) + mat4(vec4(0.452, -0.256, 0.341, -0.059), vec4(0.034, -0.173, 0.389, 0.534), vec4(0.425, -0.078, -0.363, -0.059), vec4(0.333, 0.281, 0.282, -0.256)) * bufB[0] + mat4(vec4(-0.043, 0.057, 0.146, 0.357), vec4(0.063, -0.549, -0.378, -0.060), vec4(-0.004, 0.397, -0.049, -0.105), vec4(0.570, -0.394, 0.186, -0.481)) * bufB[1] + mat4(vec4(-0.345, -0.199, 0.239, 0.013), vec4(0.402, -0.158, 0.108, -0.150), vec4(0.336, 0.307, -0.263, 0.031), vec4(0.014, -0.658, 0.436, -0.157)) * bufB[2] + mat4(vec4(0.331, 0.551, -0.111, 0.204), vec4(-0.217, -0.199, 0.319, 0.100), vec4(0.197, 0.119, 0.126, -0.560), vec4(0.185, 0.196, 0.082, 0.038)) * bufB[3];\nbufA[1] = vec4(0.139, -0.828, -0.430, 0.534) + mat4(vec4(-0.120, 0.092, 0.365, 0.009), vec4(0.382, -0.535, -0.051, 0.118), vec4(-0.176, 0.347, 0.157, -0.252), vec4(0.288, 0.193, -0.045, -0.122)) * bufB[0] + mat4(vec4(0.109, 0.161, 0.167, -0.455), vec4(0.276, 0.012, 0.072, -0.156), vec4(-0.415, -0.140, 0.446, 0.826), vec4(-0.021, 0.332, 0.160, 0.036)) * bufB[1] + mat4(vec4(0.118, 0.260, 0.096, -0.031), vec4(-0.672, -0.390, -0.045, 0.179), vec4(0.327, -0.113, -0.351, 0.087), vec4(-0.346, -0.014, -0.143, -0.186)) * bufB[2] + mat4(vec4(-0.206, 0.272, -0.453, -0.081), vec4(0.210, -0.396, 0.140, 0.177), vec4(0.185, -0.046, 0.205, -0.477), vec4(0.377, -0.050, -0.542, -0.295)) * bufB[3];\nbufA[2] = vec4(-0.070, 0.311, -0.324, 0.317) + mat4(vec4(-0.439, -0.085, 0.678, 0.061), vec4(0.317, -0.590, 0.005, -0.211), vec4(-0.002, -0.479, 0.333, 0.006), vec4(0.248, -0.234, 0.227, -0.366)) * bufB[0] + mat4(vec4(-0.298, 0.081, -0.187, -0.085), vec4(-0.151, 0.321, 0.115, -0.107), vec4(-0.362, 0.133, 0.517, -0.318), vec4(0.410, 0.036, -0.059, 0.126)) * bufB[1] + mat4(vec4(0.084, 0.283, -0.307, -0.074), vec4(0.173, 0.208, 0.221, -0.538), vec4(-0.275, -0.048, -0.092, 0.060), vec4(0.066, -0.704, -0.048, -0.037)) * bufB[2] + mat4(vec4(-0.048, -0.309, 0.012, -0.200), vec4(0.247, -0.322, 0.072, 0.394), vec4(-0.047, -0.063, -0.035, -0.078), vec4(0.220, -0.190, 0.067, -0.391)) * bufB[3];\nbufA[3] = vec4(0.060, -0.177, 0.157, 0.184) + mat4(vec4(-0.077, -0.222, -0.060, -0.046), vec4(-0.935, -0.032, 0.363, -0.028), vec4(-0.530, 0.355, -0.048, 0.041), vec4(0.029, -0.516, -0.354, 0.008)) * bufB[0] + mat4(vec4(0.250, 0.243, 0.115, -0.369), vec4(-0.266, -0.159, -0.196, 0.012), vec4(-0.028, -0.310, 0.273, 0.435), vec4(-0.048, 0.076, -0.084, -0.163)) * bufB[1] + mat4(vec4(0.051, -0.031, 0.477, -0.153), vec4(0.115, 0.298, 0.212, 0.205), vec4(-0.150, -0.081, -0.037, -0.185), vec4(0.101, 0.250, 0.371, -0.038)) * bufB[2] + mat4(vec4(-0.242, 0.264, 0.151, -0.051), vec4(0.501, 0.036, 0.082, 0.043), vec4(0.015, 0.086, 0.041, 0.529), vec4(-0.397, 0.640, 0.117, -0.237)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 7 \nbufA[0] = vec4(0.209, -0.284, 0.340, -0.556) + mat4(vec4(0.108, -0.339, -0.151, 0.447), vec4(-0.283, -0.235, 0.342, 0.028), vec4(0.303, 0.275, -0.254, 0.487), vec4(0.076, -0.851, 0.198, -0.046)) * bufB[0] + mat4(vec4(0.283, 0.347, -0.118, 0.034), vec4(-0.237, 0.069, 0.558, -0.273), vec4(-0.422, -0.208, 0.260, 0.424), vec4(0.087, -0.003, 0.550, 0.096)) * bufB[1] + mat4(vec4(-0.387, 0.267, -0.269, 0.186), vec4(-0.264, -0.474, 0.034, 0.067), vec4(-0.041, -0.056, -0.176, 0.569), vec4(0.195, 0.214, 0.033, 0.320)) * bufB[2] + mat4(vec4(0.112, 0.158, 0.445, -0.131), vec4(-0.057, 0.110, 0.352, -0.003), vec4(-0.494, 0.120, 0.471, 0.515), vec4(-0.230, 0.459, 0.059, 0.391)) * bufB[3];\nbufA[1] = vec4(0.507, 0.302, 0.272, -0.251) + mat4(vec4(-0.073, 0.216, -0.506, 0.224), vec4(0.177, -0.278, 0.005, -0.699), vec4(0.273, 0.466, 0.243, 0.317), vec4(-0.003, 0.522, 0.046, 0.020)) * bufB[0] + mat4(vec4(-0.679, 0.009, -0.020, 0.182), vec4(0.192, 0.017, -0.713, -0.290), vec4(-0.067, 0.656, 0.380, 0.094), vec4(0.022, -0.056, 0.181, -0.450)) * bufB[1] + mat4(vec4(0.143, -0.447, 0.130, 0.067), vec4(0.256, 0.533, -0.015, 0.495), vec4(-0.500, 0.127, 0.119, -0.001), vec4(-0.204, 0.469, -0.567, -0.092)) * bufB[2] + mat4(vec4(0.020, 0.005, 0.122, 0.276), vec4(0.424, 0.049, -0.381, -0.231), vec4(0.174, 0.206, -0.082, -0.347), vec4(-0.433, 0.097, -0.237, -0.301)) * bufB[3];\nbufA[2] = vec4(-0.338, 0.310, 0.306, -0.137) + mat4(vec4(-0.440, 0.118, 0.413, 0.074), vec4(-0.115, -0.008, 0.206, -0.208), vec4(0.262, -0.149, -0.039, -0.772), vec4(-0.441, -0.053, 0.172, -0.178)) * bufB[0] + mat4(vec4(0.066, -0.449, -0.164, -0.438), vec4(0.035, 0.214, 0.215, -0.814), vec4(0.238, 0.148, -0.205, 0.027), vec4(-0.223, 0.215, 0.463, 0.098)) * bufB[1] + mat4(vec4(0.048, 0.005, 0.137, 0.005), vec4(-0.406, 0.586, -0.161, 0.067), vec4(-0.206, 0.324, 0.013, -0.023), vec4(0.137, -0.139, 0.067, -0.071)) * bufB[2] + mat4(vec4(0.594, 0.109, 0.072, -0.018), vec4(0.046, -0.209, -0.100, -0.263), vec4(0.102, 0.291, -0.174, -0.333), vec4(0.289, -0.207, -0.100, -0.181)) * bufB[3];\nbufA[3] = vec4(0.177, -0.654, 0.335, 0.056) + mat4(vec4(-0.079, 0.212, 0.107, -0.255), vec4(0.409, -0.123, 0.139, -0.263), vec4(-0.292, 0.323, -0.228, 0.245), vec4(-0.038, -0.430, -0.150, 0.185)) * bufB[0] + mat4(vec4(0.095, 0.061, 0.131, 0.318), vec4(-0.528, 0.189, -0.140, 0.179), vec4(0.363, -0.203, -0.229, 0.223), vec4(0.602, -0.425, 0.370, -0.086)) * bufB[1] + mat4(vec4(-0.065, 0.368, -0.597, 0.345), vec4(0.194, 0.020, 0.196, 0.483), vec4(0.151, 0.787, 0.568, 0.141), vec4(-0.414, 0.015, 0.001, -0.094)) * bufB[2] + mat4(vec4(-0.268, -0.041, 0.207, 0.160), vec4(-0.127, 0.077, 0.182, -0.074), vec4(-0.133, 0.006, -0.436, 0.056), vec4(-0.227, 0.123, -0.226, -0.089)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 8 \nbufA[0] = vec4(-0.094, 0.284, -0.264, -0.135) + mat4(vec4(0.132, 0.022, -0.338, -0.353), vec4(0.719, -0.163, 0.040, -0.481), vec4(-0.329, 0.440, 0.053, 0.212), vec4(-0.400, -0.079, -0.115, -0.183)) * bufB[0] + mat4(vec4(-0.716, 0.335, 0.258, 0.659), vec4(-0.023, 0.014, -0.168, -0.414), vec4(-0.255, -0.366, 0.065, -0.385), vec4(0.230, -0.458, -0.566, -0.198)) * bufB[1] + mat4(vec4(0.234, -0.479, 0.162, -0.322), vec4(0.163, 0.038, 0.018, -0.189), vec4(-0.207, 0.010, -0.219, 0.126), vec4(-0.408, 0.345, -0.215, 0.069)) * bufB[2] + mat4(vec4(-0.567, 0.069, 0.107, 0.112), vec4(-0.187, -0.174, -0.452, 0.041), vec4(-0.092, -0.166, -0.027, -0.194), vec4(0.078, 0.094, -0.690, 0.248)) * bufB[3];\nbufA[1] = vec4(-0.268, -0.424, -0.361, 0.592) + mat4(vec4(-0.060, 0.230, 0.291, 0.021), vec4(-0.267, -0.175, 0.171, -0.370), vec4(-0.122, 0.272, 0.073, 0.241), vec4(-0.058, -0.336, 0.232, -0.434)) * bufB[0] + mat4(vec4(-0.209, 0.343, -0.054, 0.533), vec4(-0.229, -0.137, -0.184, -0.694), vec4(-0.156, -0.563, 0.254, 0.145), vec4(-0.297, 0.327, 0.440, -0.082)) * bufB[1] + mat4(vec4(0.276, -0.308, 0.073, -0.244), vec4(0.008, 0.440, 0.028, 0.248), vec4(0.071, 0.001, -0.524, -0.175), vec4(-0.262, -0.365, 0.152, -0.021)) * bufB[2] + mat4(vec4(-0.819, 0.005, -0.594, -0.255), vec4(0.366, -0.334, 0.148, -0.022), vec4(-0.181, 0.536, -0.174, -0.169), vec4(0.199, 0.188, 0.225, 0.106)) * bufB[3];\nbufA[2] = vec4(0.366, 0.226, 0.357, -0.544) + mat4(vec4(0.278, 0.219, 0.240, -0.021), vec4(0.621, -0.017, 0.038, 0.319), vec4(0.224, -0.351, 0.190, -0.229), vec4(-0.016, 0.081, -0.079, -0.204)) * bufB[0] + mat4(vec4(-0.267, 0.271, 0.283, -0.296), vec4(-0.018, 0.058, 0.125, -0.093), vec4(0.165, 0.060, 0.108, -0.061), vec4(0.214, -0.143, -0.248, -0.456)) * bufB[1] + mat4(vec4(0.442, -0.329, -0.150, 0.017), vec4(-0.327, -0.069, 0.136, -0.118), vec4(-0.168, 0.319, -0.271, -0.050), vec4(-0.919, -0.025, 0.392, -0.093)) * bufB[2] + mat4(vec4(0.085, 0.638, -0.011, 0.155), vec4(0.505, 0.056, -0.338, 0.110), vec4(-0.132, -0.499, -0.162, 0.011), vec4(-0.406, -0.314, -0.272, 0.486)) * bufB[3];\nbufA[3] = vec4(-0.006, 0.263, -0.089, 0.190) + mat4(vec4(-0.451, -0.199, 0.217, 0.149), vec4(-0.050, -0.408, 0.266, 0.723), vec4(-0.439, 0.067, 0.379, 0.290), vec4(0.036, -0.532, -0.512, 0.604)) * bufB[0] + mat4(vec4(0.257, 0.446, 0.091, -0.341), vec4(-0.541, -0.945, 0.280, -0.437), vec4(-0.111, 0.122, -0.077, -0.112), vec4(-0.119, -0.199, -0.084, 0.411)) * bufB[1] + mat4(vec4(-0.264, -0.438, 0.072, -0.022), vec4(0.478, -0.038, 0.313, -0.070), vec4(0.618, -0.478, 0.067, -0.066), vec4(0.190, -0.080, -0.367, -0.066)) * bufB[2] + mat4(vec4(-0.029, -0.270, -0.311, -0.491), vec4(-0.584, -0.265, -0.130, 0.694), vec4(-0.332, -0.014, 0.064, -0.350), vec4(0.568, 0.406, 0.060, -0.587)) * bufB[3];\nbufB[0] = (max(bufA[0], 0.) - 0.4) / 0.58;\nbufB[1] = (max(bufA[1], 0.) - 0.4) / 0.58;\nbufB[2] = (max(bufA[2], 0.) - 0.4) / 0.58;\nbufB[3] = (max(bufA[3], 0.) - 0.4) / 0.58;\n\n // layer 9 \nbufA[0] = vec4(0.389, 0.003, -0.104, 0.000) + mat4(vec4(0.231, 0.279, 0.273, 0.000), vec4(-0.133, -0.051, -0.095, 0.000), vec4(0.016, 0.060, 0.000, 0.000), vec4(-0.089, -0.151, -0.118, 0.000)) * bufB[0] + mat4(vec4(-0.391, 0.067, -0.064, 0.000), vec4(-0.146, -0.115, -0.123, 0.000), vec4(0.074, 0.161, 0.164, 0.000), vec4(-0.150, -0.132, -0.159, 0.000)) * bufB[1] + mat4(vec4(0.083, 0.161, 0.168, 0.000), vec4(0.094, 0.064, 0.100, 0.000), vec4(0.028, -0.068, -0.043, 0.000), vec4(-0.251, -0.152, -0.028, 0.000)) * bufB[2] + mat4(vec4(-0.207, -0.107, -0.081, 0.000), vec4(-0.202, -0.320, -0.255, 0.000), vec4(0.024, 0.057, 0.109, 0.000), vec4(0.136, 0.099, 0.137, 0.000)) * bufB[3];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 4. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.32*sin(1.23*iTime), 0.08*sin(8.69*iTime), 0.11*sin(12.44*iTime), 0.23*sin(3.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 185, 185, 25557], [25559, 25559, 25616, 25666, 26120]], "test": "valid"}
{"id": "fdlGWB", "name": "MandelViz", "author": "webbgamers", "description": "renders mandelbrot fractal at various iterations in greyscale or color using iterations or distance to shade", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 81, "published": "Public", "date": "1616475620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER  200\n\n// Window bounds\n#define LEFT     -2.0\n#define RIGHT     1.0\n#define BOTTOM   -1.0\n#define TOP       1.0\n\n// Uncomment to use greyscale colors\n//#define GRAYSCALE\n\n// Uncomment to use distance coloring\n//#define DISTANCE\n\n// Uncomment to use a hybrid distance and iteration coloring (must also have DISTANCE enabled, does nothing on GREYSCALE))\n//#define HYBRID\n\n// Uncomment to remove iteration bouncing\n//#define NOBOUNCE\n\n// Convert HSV to RGB\nvec3 hsv2rgb( in vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Complex number square\nvec2 csquare( in vec2 c )\n{\n    return vec2(c.x*c.x + -1.0*c.y*c.y, 2.0*c.x*c.y);\n}\n\n// Mandelbrot iteration\nint mandelbrot( in vec2 c, in int maxIter, out float d )\n{\n    vec2 z;\n    int n;\n    for (int i = 0; i <= MAX_ITER; i++)\n    {\n        // Break if out of bounds\n        if (z.x*z.x + z.y*z.y >= 4.0) {break;}\n        \n        // Calculate z*z + c but complex numbers\n        z = csquare(z);\n        z = vec2(z.x + c.x, z.y + c.y);\n        n++;\n    }\n    \n    // Calculate distance for distance coloring\n    #ifdef DISTANCE\n    vec2 o = vec2(-3.0, 0.0);\n    float xd = o.x - z.x;\n    float yd = o.y - z.y;\n    d = sqrt(xd*xd + yd*yd);\n    #endif\n    \n    return n;\n}\n\n// Generate image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Convert pixel coordinates into complex number\n    float x = LEFT + (fragCoord.x / iResolution.x) * (RIGHT - LEFT);\n    float y = BOTTOM + (fragCoord.y / iResolution.y) * (TOP - BOTTOM);\n    vec2 c = vec2(x, y);\n    \n    // Change max iterations for pulsing effect\n    #ifdef NOBOUNCE\n    int maxIter = MAX_ITER;\n    #else\n    int maxIter = int(float(MAX_ITER)*(sin(iTime)+1.0)/2.0)+1;\n    #endif\n\n    // Calculate mandelbrot\n    float d;\n    int m = mandelbrot(c, maxIter, d);\n    \n    // Calculate color based on mandelbrot value and chosen settings\n    #ifdef GRAYSCALE\n    #ifdef DISTANCE\n    vec3 col = m < maxIter ? vec3(d - floor(d)) : vec3(0.0);\n    #else\n    float v = float(m) / float(maxIter);\n    vec3 col = vec3(v);\n    #endif\n    #else\n    #ifdef DISTANCE\n    #ifdef HYBRID\n    float h = m < maxIter ? (float(m)/float(maxIter)) : d*5.0;\n    float v = m < maxIter ? d - floor(d) : 1.0;\n    #else\n    float h = d;\n    float v = m < maxIter ? 1.0 : 0.0;\n    #endif\n    #else\n    float h = float(m) / float(maxIter);\n    float v = m < maxIter ? 1.0 : 0.0;\n    #endif\n    float s = 1.0;\n    vec3 col = hsv2rgb(vec3(h, s, v));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 470, 497, 497, 666], [668, 693, 720, 720, 776], [778, 802, 860, 860, 1367], [1369, 1387, 1444, 1500, 2658]], "test": "valid"}
{"id": "fdlGWM", "name": "180-final", "author": "yuehan", "description": "180 final", "tags": ["chess"], "likes": 0, "viewed": 35, "published": "Public", "date": "1616054213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define STATICCAM\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n//float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat noise( in vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel1, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel1, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel1, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel1, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm4( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 );\n    n += 0.500*noise( p*2.0 );\n    n += 0.250*noise( p*4.0 );\n    n += 0.125*noise( p*8.0 );\n    return n;\n}\n\nfloat fbm6( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm4( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    return n;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n\n\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax )\n{\n    return p-s*clamp(round(p/s),-limmin,limmax);\n}\n\nvec4 textureGood( sampler2D sam, in vec2 uv )\n{\n    uv = uv*1024.0 - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, 0.0 );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n}\n\n#define ZERO (min(iFrame,0))\n\n//------------\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n}\n\nvec3 temple( in vec3 p )\n{\n    vec3 op = p;    \n    vec3 res = vec3(-1.0,-1.0,0.5);\n    float an = sin(iTime);\n\n    p.y += 2.0;\n\n    // bounding box\n    float bbox = usdBox(p,vec3(15.0,12.0,15.0)*1.5 );\n    if( bbox>5.0 ) return vec3(bbox+1.0,-1.0,0.5);\n    \n    vec3 q = p;\n    //p.x+=2.0;\n    //p.y -= 3.2;\n\tfloat d = max(length(p.xz) - .3+0.05*p.y, p.y);\n    d= max(d,-p.y-3.0);\n\td = min(d, length(p) - .7);\n\tp.y += 0.95;\n\td = min(d, sdEllipsoid(p, vec3(0.75, 0.2, 0.75)));\n\tp.y += 1.5;\n\td = min(d, sdEllipsoid(p, vec3(0.9, 0.2, 0.9)));\n\tp.y += .4;\n    d= min(d, sdCappedCylinder(p, .9, .2));\n    {\n    vec3 qq = vec3(q.x+3.0,q.y, q.z+3.0 );\n    \n    d = min(d,max(length(qq.xz)- 0.3+0.05*qq.y, qq.y));\n    d = max(d, -qq.y-3.2);\n    d = min(d, length(qq) - 0.7);\n\tqq.y += 0.95;\n\td = min(d, sdEllipsoid(qq, vec3(0.75, 0.2, 0.75)));\n\tqq.y += 1.5;\n\td = min(d, sdEllipsoid(qq, vec3(0.9, 0.2, 0.9)));\n\tqq.y += .4;\n    d= min(d, sdCappedCylinder(qq, .9, .2));\n    }\n    {\n    vec3 qq1 = vec3(q.x+6.0,q.y, q.z+3.0 );\n    //float d1=d;\n    \n    \n    float d1 = min(d,max(length(qq1.xz)- 0.3+0.05*qq1.y, qq1.y));\n    d1 = max(d1, -qq1.y-3.2);\n    d1 = min(d1, length(qq1) - 0.7);\n\tqq1.y += 0.95;\n\td1 = min(d1, sdEllipsoid(qq1, vec3(0.75, 0.2, 0.75)));\n\tqq1.y += 1.5;\n\td1 = min(d1, sdEllipsoid(qq1, vec3(0.9, 0.2, 0.9)));\n\tqq1.y += .4;\n    d1= min(d1, sdCappedCylinder(qq1, .9, .2));\n    \n    vec3 qq2 = vec3(q.x+6.0,q.y, q.z+3.0+3.0*an );\n    float d2 = min(d,max(length(qq2.xz)- 0.3+0.05*qq2.y, qq2.y));\n    d2 = max(d2, -qq2.y-3.2);\n    d2 = min(d2, length(qq2) - 0.7);\n\tqq2.y += 0.95;\n\td2 = min(d2, sdEllipsoid(qq2, vec3(0.75, 0.2, 0.75)));\n\tqq2.y += 1.5;\n\td2 = min(d2, sdEllipsoid(qq2, vec3(0.9, 0.2, 0.9)));\n\tqq2.y += .4;\n    d2= min(d2, sdCappedCylinder(qq2, .9, .2));\n    \n    \n    float dt = opSmoothUnion(d1,d2, 0.25);\n    d =min(d, dt);\n    }\n    {\n    vec3 king = vec3(q.x+3.0,q.y,q.z);\n    d = min(d,max(length(king.xz)- 0.3+0.05*king.y, king.y-0.5));\n    d = max(d, -king.y-3.2);\n    \n    king.y -= 0.5;\n    d = min(d, sdSolidAngle(vec3(king.x,king.y+0.9,king.z), vec2(5,15)/15.81, 1.8 ));\n    d = min(d, sdRoundBox(vec3(king.x, king.y-1.35,king.z), vec3(0.3,0.08,0.05),0.1));\n    d = min(d, sdRoundBox(vec3(king.x, king.y-1.35,king.z), vec3(0.08,0.45,0.05),0.1));\n\tking.y += 0.25;\n\td = min(d, sdEllipsoid(king, vec3(0.45, 0.1, 0.45)));\n\tking.y += 0.25;\n    d = min(d, sdEllipsoid(king, vec3(0.5, 0.15, 0.5)));\n    king.y += 1.75;\n\td = min(d, sdCappedCone(vec3(king.x,king.y+0.4,king.z), 0.5, 0.7, 0.4 ));\n\tking.y +=1.2;\n    d= min(d, sdCappedCylinder(king, .9, .2));\n    }\n    {\n    vec3 king2 = vec3(q.x,q.y,q.z+3.0);\n    float d3 = min(d,max(length(king2.xz)- 0.3+0.05*king2.y, king2.y-0.5));\n    d3 = max(d3, -king2.y-3.2);\n    \n    king2.y -= 0.5;\n    d3 = min(d3, sdSolidAngle(vec3(king2.x,king2.y+0.9,king2.z), vec2(5,15)/15.81, 1.8 ));\n    d3 = min(d3, sdRoundBox(vec3(king2.x, king2.y-1.35,king2.z), vec3(0.3,0.08,0.05),0.1));\n    d3 = min(d3, sdRoundBox(vec3(king2.x, king2.y-1.35,king2.z), vec3(0.08,0.45,0.05),0.1));\n\tking2.y += 0.25;\n\td3 = min(d3, sdEllipsoid(king2, vec3(0.45, 0.1, 0.45)));\n\tking2.y += 0.25;\n    d3 = min(d3, sdEllipsoid(king2, vec3(0.5, 0.15, 0.5)));\n    king2.y += 1.75;\n\td3 = min(d3, sdCappedCone(vec3(king2.x,king2.y+0.4,king2.z), 0.5, 0.7, 0.4 ));\n\tking2.y +=1.2;\n    d3= min(d3, sdCappedCylinder(king2, .9, .2));\n    \n    vec3 king3 = vec3(q.x +3.0*an,q.y,q.z+3.0);\n    float d4 = min(d,max(length(king3.xz)- 0.3+0.05*king3.y, king3.y-0.5));\n    d4 = max(d4, -king3.y-3.2);\n    \n    king3.y -= 0.5;\n    d4 = min(d4, sdSolidAngle(vec3(king3.x,king3.y+0.9,king3.z), vec2(5,15)/15.81, 1.8 ));\n    d4 = min(d4, sdRoundBox(vec3(king3.x, king3.y-1.35,king3.z), vec3(0.3,0.08,0.05),0.1));\n    d4 = min(d4, sdRoundBox(vec3(king3.x, king3.y-1.35,king3.z), vec3(0.08,0.45,0.05),0.1));\n\tking3.y += 0.25;\n\td4 = min(d4, sdEllipsoid(king3, vec3(0.45, 0.1, 0.45)));\n\tking3.y += 0.25;\n    d4 = min(d4, sdEllipsoid(king3, vec3(0.5, 0.15, 0.5)));\n    king3.y += 1.75;\n\td4 = min(d4, sdCappedCone(vec3(king3.x,king3.y+0.4,king3.z), 0.5, 0.7, 0.4 ));\n\tking3.y +=1.2;\n    d4= min(d4, sdCappedCylinder(king3, .9, .2));\n    \n    float dt2 = opSmoothSubtraction(d4,d3, 0.25);\n    d =min(d, dt2);\n    \n    }\n    \n    \n    res = vec3( d, 1.0, res.z );\n\n    return res;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 res = temple(p);\n    \n    // floor\n    float m = p.y + 15.0;\n    if( m<res.x ) res = vec3( m, 2.0, 0.0 );\n\n    return res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 ma = vec2(0.0);\n\n    vec3 res = vec3(-1.0);\n    \n    float tmax = 1000.0;\n\n        \n    float t = 10.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 h = map( pos );\n        if( h.x<(0.0001*t) || t>tmax ) break;\n        t += h.x;\n\n        ma = h.yz;\n    }\n\n    if( t<tmax )\n    {\n    \tres = vec3(t, ma);\n    }\n\n    return res;\n}\n\nvec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )\n{\n    vec4 cx = texture( tex, pos.yz );\n    vec4 cy = texture( tex, pos.xz );\n    vec4 cz = texture( tex, pos.xy );\n    vec3 m = nor*nor;\n    return (cx*m.x + cy*m.y + cz*m.z)/(m.x+m.y+m.z);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    \n    float t = 0.01;\n    for( int i=0; i<150; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)/t );\n        if( res<0.0001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float ra )\n{\n    float occ = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = 0.01 + 4.0*pow(float(i)/31.0,2.0);\n        vec2 an = hash2( ra + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n        vec3 dir = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n        dir *= sign( dot(dir,nor) );\n        occ += clamp( 5.0*map( pos + h*dir ).x/h, -1.0, 1.0);\n    }\n    return clamp( occ/32.0, 0.0, 1.0 );\n}\n\n\nvec3 sunLig = normalize(vec3(0.7,0.1,0.4));\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3*rd.y;\n\n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    return col;\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.002;\n    float b = 0.015;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    float e = 0.002;\n    float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    \n    uvec2 px = uvec2(fragCoord);\n    float ran = hash( px.x + 1920U*px.y + (1920U*1080U)*uint(iFrame*0) );    \n    \n    #ifdef STATICCAM\n    float an = -0.96;\n    #else\n    float an = sin(iTime*0.2)*0.5;\n    #endif\n    float ra = 35.0;\n    float fl = 3.0;\n    vec3 ta = vec3(0.0,-2.0,0.0);\n    vec3 ro = ta + vec3(ra*sin(an),6.0,ra*cos(an));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n    \n    \n    vec3 col = vec3(0.0);\n    \n    col = skyColor( ro, rd );\n    \n    float resT = 10000.0;\n    vec3 res = intersect( ro, rd );\n    if( res.y>0.0 )\n    {\n        float t = res.x;\n        resT = t;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \n        float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0), 5.0 );\n\t\tfloat foc = 1.0;\n        \n        vec3 mate = vec3(0.2);\n        vec2 mspe = vec2(0.0);\n        float mbou = 0.0;\n        float mter = 0.0;\n        if( res.y<1.5 )\n        {\n            vec3 te = textureBox( iChannel0, pos*0.05, nor ).xyz;\n            //mate = vec3(0.12,0.08,0.05) + 0.15*te;\n            mate = vec3(0.14,0.10,0.07) + 0.1*te;\n            mate *= 0.8 + 0.4*res.z;\n            mate *= 1.15;            \n            mspe = vec2(1.0,8.0);\n            mbou = 1.0;\n            \n            foc = 0.7 + 0.3*smoothstep(0.4,0.7,fbm4( 3.0*pos ));\n\n            float ho = 1.0;\n            if( pos.y>-7.5 ) ho *= smoothstep( 0.0, 5.0, (pos.y+7.5)  );\n            ho = mix( 0.1+ho*0.3, 1.0, clamp( 0.6 + 0.4*dot( normalize(nor.xz*vec2(0.5,1.0)), normalize(pos.xz*vec2(0.5,1.0)) ) + 1.0*nor.y*nor.y, 0.0, 1.0 ) );\n            foc *= ho;\n            foc *= 0.4 + 0.6*smoothstep( 2.0, 15.0, length(pos*vec3(0.5,0.25,1.0)) );\n            float rdis = clamp( -0.15*max(sdRhombus( pos.yz-vec2(8.3,0.0)+vec2(2.0,0.0), vec2(2.25,8.5), 0.05 ),-(pos.y-8.3+2.0)), 0.0, 1.0 );\n            if( rdis>0.0001 ) foc = 0.1 + sqrt(rdis);\n\t\t\tif( pos.y<5.8 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 1.5, -(pos.y-5.8) );\n            if( pos.y<3.4 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 2.5, -(pos.y-3.4)  );\n\n            foc *= 0.8;            \n        }\n        else\n        {\n            mate = vec3(0.1,0.1,0.1);\n\t\t\tfloat h;\n            mspe = vec2(2.5,4.0);\n            mter = 1.0;\n        }\n\n        float occ = 0.33 + 0.5*nor.y;\n        occ = calcOcclusion(pos,nor,ran) * foc;\n        \n        vec3 lig = sunLig;\n        vec3 ligbak = normalize(vec3(-lig.x,0.0,-lig.z));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float sha = calcShadow( pos+nor*0.001, lig, 32.0 );\n              dif *= sha;\n        float amb = (0.8 + 0.2*nor.y);\n              amb = mix( amb, amb*(0.5+0.5*smoothstep( -8.0,-1.0,pos.y)), mbou );\n\n        vec3 qos = pos/1.5 - vec3(0.0,1.0,0.0);\n\n        float bak = clamp( 0.4+0.6*dot( nor, ligbak ), 0.0, 1.0 );\n              bak *= 0.6 + 0.4*smoothstep( -8.0,-1.0,qos.y);\n        \n        vec3 hal = normalize( lig -rd );\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0), mspe.y )*(0.1+0.9*fre)*sha*(0.5+0.5*occ);\n\n        col = vec3(0.0);\n        col += amb*3.0*vec3(0.15,0.25,0.35)*occ*(1.0+mter);\n        col += dif*6.0*vec3(0.90,0.55,0.35);\n        col += bak*9.0*vec3(0.10,0.11,0.12)*occ*mbou;\n        col += spe*6.0*mspe.x*occ;\n        \n        col *= mate;\n\n        vec3 fogcol = vec3(0.2,0.25,0.30)*0.5;\n\n        float fog = 1.0 - exp(-0.0013*t);\n        col *= 1.0-0.5*fog;\n        col = mix( col, fogcol, fog );\n    }\n\n    col = max( col, 0.0 );\n    \n    col = sqrt( col );\n\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 46, 46, 65], [66, 66, 91, 91, 110], [111, 179, 202, 202, 279], [281, 281, 304, 304, 440], [442, 442, 465, 465, 535], [537, 537, 563, 563, 1007], [1009, 1009, 1035, 1035, 1242], [1244, 1244, 1269, 1269, 1428], [1430, 1430, 1455, 1455, 1690], [1692, 1692, 1717, 1717, 1952], [1954, 1954, 1979, 1979, 2146], [2148, 2148, 2177, 2177, 2205], [2207, 2207, 2261, 2261, 2472], [2474, 2474, 2512, 2512, 2555], [2557, 2557, 2588, 2588, 2675], [2677, 2677, 2710, 2710, 2733], [2735, 2735, 2770, 2770, 2796], [2798, 2798, 2846, 2846, 3134], [3135, 3135, 3194, 3194, 3283], [3285, 3285, 3318, 3318, 3373], [3375, 3375, 3445, 3445, 3585], [3587, 3587, 3623, 3623, 3934], [3936, 3936, 3992, 3992, 4494], [4496, 4496, 4548, 4548, 4662], [4664, 4664, 4728, 4728, 5006], [5008, 5008, 5071, 5135, 5722], [5724, 5724, 5760, 5760, 6110], [6112, 6124, 6160, 6160, 6263], [6265, 6290, 6341, 6341, 6696], [6698, 6710, 6757, 6757, 7102], [7104, 7104, 7175, 7175, 7513], [7515, 7515, 7579, 7579, 8139], [8141, 8187, 8235, 8235, 8404], [8406, 8406, 8443, 8443, 9037], [9039, 9039, 9081, 9081, 9681], [9686, 9686, 9739, 9739, 9784], [9786, 9786, 9858, 9858, 9909], [9911, 9911, 9958, 9958, 10377], [10409, 10424, 10463, 10463, 10555], [10556, 10556, 10606, 10606, 10714], [10715, 10715, 10760, 10760, 10851], [10853, 10853, 10905, 10905, 10981], [10983, 10983, 11041, 11041, 11119], [11121, 11121, 11147, 11147, 15409], [15411, 15411, 15434, 15434, 15568], [15570, 15634, 15676, 15676, 16231], [16233, 16233, 16275, 16275, 16647], [16649, 16649, 16712, 16712, 16903], [16905, 16905, 16958, 16958, 17234], [17236, 17236, 17295, 17295, 17706], [17754, 17754, 17795, 17795, 17933], [17935, 17935, 17979, 17979, 18347], [18349, 18349, 18413, 18413, 18742], [18744, 18744, 18796, 18796, 18973], [18975, 18975, 19032, 19032, 22627]], "test": "error"}
{"id": "fdlGzS", "name": " Robot hand", "author": "dopa", "description": "A robot hand follow the mouse ", "tags": ["2d", "inversekinematics"], "likes": 10, "viewed": 183, "published": "Public API", "date": "1616162707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float segment(vec2 P, vec2 A, vec2 B, float r) \n\n{\n\n    vec2 g = B - A;\n\n    vec2 h = P - A;\n\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\n\treturn smoothstep(r, 0.5*r, d);\n\n}\n\nconst vec3 backColor  = vec3(0.3);\n\nconst vec3 pointColor = vec3(1,0,0.51);\n\nconst vec3 lineColor = vec3(0.95,0.95,0.10);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    //uv=fragCoord/iResolution.xy;\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    //mouse =iMouse.xy/ iResolution.y;\n    if(sign(iMouse.z)!=1.0){\n        mouse = vec2(0.0,-0.3)+vec2(cos(iTime)*2.0, sin(iTime)) * 0.4;\n    }\n    \n    vec3 color = backColor;\n    \n    int iterations=5;\n    \n    vec2 startPoint=vec2(0,0);\n    \n    int piece=5;\n    \n    vec2[] points=vec2[] (vec2(0,0),vec2(0,1),vec2(0,2),vec2(0,3),vec2(0,4),vec2(0,5));\n\n    //vec2[] points=vec2[] (vec2(0,0),vec2(1,1),vec2(2,2),vec2(3,3),vec2(4,4),vec2(5,5));\n    \n    //vec2[] points=vec2[] (vec2(-5,-5),vec2(-3,-3),vec2(-1,-1),vec2(1,1),vec2(3,3),vec2(5,5));\n\n    //vec2[] points=vec2[] (vec2(0,0),vec2(1,1),vec2(2,-2),vec2(3,3),vec2(4,-4),vec2(5,5));\n    \n    //vec2[] points=vec2[] (vec2(0,1),vec2(1,0),vec2(0,-1),vec2(-1,0),vec2(0,1),vec2(1,0));\n\n    float[] lenghts=float[](0.3,0.25,0.2,0.15,0.1);\n   \n    \n    for (int j=0;j<=iterations;j++){\n        vec2 target=mouse;\n        for (int i=piece;i>0;i--){\n            points[i]=target;\n\n            vec2 dir;\n            dir=(target-points[i-1])/ length(target-points[i-1]);\n            points[i-1] = target-(dir*lenghts[i-1]);\n\n\n            target=points[i-1];\n        }\n        \n        target=startPoint;\n        for (int i=0;i<piece;i++){\n            points[i]=target;\n\n            vec2 dir;\n            dir=(target-points[i+1])/ length(target-points[i+1]);\n            points[i+1] = target-(dir*lenghts[i]);\n\n\n            target=points[i+1];\n        }\n    }\n    \n    /*\n    \n        vec2 target=mouse;\n        for (int i=piece;i>0;i--){\n            points[i]=target;\n\n            vec2 dir;\n            dir=(target-points[i-1])/ length(target-points[i-1]);\n            points[i-1] = target-(dir*lenghts[i-1]);\n\n\n            target=points[i-1];\n        }\n        \n    */\n    float intensity;\n    for (int i=piece;i>=1;i--){\n        intensity = segment(uv, points[i],points[i-1], 0.01);\n        color = mix(color, lineColor, intensity);\n    }\n    for (int i=piece;i>=0;i--){\n        intensity = segment(uv, points[i],points[i], 0.02);\n        color = mix(color, pointColor, intensity);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n      ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 199], [325, 325, 381, 381, 2632]], "test": "error"}
{"id": "fds3Wl", "name": "Rainbow tie-dye", "author": "jarble", "description": "This fractal pattern has many overlapping and blended colors.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 5, "viewed": 162, "published": "Public API", "date": "1616879644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07); //looks like a carpet\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .16;\n    float scale2 = 1.2;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    for(int c=0;c<6;c++){\n        float scale = c1.z;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        for(int i=0;i<3;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            //scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            //uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fds3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [516, 747, 794, 794, 850], [852, 852, 909, 909, 1644]], "test": "valid"}
{"id": "fdsGRf", "name": "Endless Rainbow Well", "author": "Tater", "description": "first shader I've made without any tutorial.\nIf you watch it for a long time it produces some interesting color palettes. ", "tags": ["2d", "rainbow"], "likes": 4, "viewed": 148, "published": "Public API", "date": "1616386013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n}\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur ,d);\n    return c;\n}\nvec3 endlessRGB(float offset, float iTime){\n    //color intensity\n    float colori = 0.4+0.25*(1.0+sin(iTime));\n    //magic\n    return vec3(\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(offset),1000.0))),\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(10.0+offset),1000.0))),\n    colori*(1.0+sin(mod(iTime/100.0,5.0)*mod(floor(20.0+offset),1000.0))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 cuv=uv; //Untoched uv for center stuff\n    \n    //manipulating UV to setup side walls\n    uv*=1.3;\n    clamp(uv.x,-1.0,1.0);\n    uv.x=1.0-mod(uv.x,2.0);\n    \n    //Speed\n    float t=iTime*2.0;\n    \n    //Wobbly Jerk Time\n    t= floor(t*0.25)+pow(fract(t*0.25),0.6);\n    t*=4.0;\n    //Rotation\n    uv*=Rot(0.05*sin(iTime));\n    vec3 col = vec3(0.0);\n    vec2 ruv = uv;\n    \n    //Downward Movement and initial offset\n    ruv.y+=t*0.1+10.0;\n    \n    //Wavey Y\n    ruv.y-=0.04*abs(sin(ruv.x*6.0+sin(ruv.y*3.0)));\n    \n    //Scaling Y for to make space for Layers\n    ruv.y *= 25.0;\n    \n    //Row on/off\n    float rid = floor(mod(ruv.y,2.0));\n\n    //Inner Edge\n    float edge1 = smoothstep(abs(ruv.x)-0.002,abs(ruv.x),0.2);\n    \n    //Moving Edge\n    float edge2;\n    float waves=3.0;\n    \n    if(ruv.x>0.0){\n        edge2 = smoothstep(ruv.x-0.005,ruv.x,0.5+0.2*sin(t+floor(ruv.y*waves))); //I think this might be backwards\n    }\n    else{\n        edge2 = smoothstep(-ruv.x-0.00,-ruv.x,0.5+0.2*sin(-t-floor(ruv.y*waves)));\n    }    \n    edge2+=(1.0-rid);\n    \n    //coloring edges\n    float l1 = rid*edge2;\n    float l2 = (1.0-rid)*edge1;\n    \n    col.rgb+=l1*endlessRGB(ruv.y,iTime);\n    col.rbg+=vec3(l2);\n    \n    //duplicating the circle and moving it\n    float rotDir = 1.0-2.0*mod(floor((cuv.y-t*0.05)*2.0),2.0);\n    cuv.y=0.25-mod(cuv.y-t*0.05,.5);\n    cuv*=Rot(rotDir*t*0.4);\n    \n    //adding circles\n    col+= endlessRGB(cuv.y*30.0+10.0,iTime)*Circle(cuv, vec2(0.0), .2, .2);\n    \n    fragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdsGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 79], [80, 80, 131, 131, 215], [216, 216, 259, 281, 579], [580, 580, 637, 637, 2227]], "test": "valid"}
{"id": "fdSGWz", "name": "SimpleRT", "author": "jackisgames", "description": "raytrace", "tags": ["raytrace"], "likes": 1, "viewed": 72, "published": "Public", "date": "1617199976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//posisi adalah posisi ray\n//arah adalah arah depan ray, harus di normalisasi\n//'bola' adalah vec4 (4 angka) di definisi kan dengan posisi xyz dan radius z.\n//Bisa juga pakai vec3 tuk posisi dan float tuk radius\n//Adaptasi dari Realtime Collision Detection - Christer Ericson\nfloat InterseksiBola(vec3 posisi, vec3 arah, vec4 bola)\n{\n    vec3 m = posisi - bola.xyz;\n    float b = dot( arah , m );\n    float c = dot( m, m ) - ( bola.w * bola.w );\n    \n    float discr = b * b - c;\n    \n    float t = -b - sqrt( abs( discr ) );\n    \n    return mix( 999.0, t, step( 0.0, min( t, discr ) ) );\n}\n\n//ini cuman sky box, ganti aja ama implementasi kamu\nvec3 LatarBelakang( vec3 arah )\n{ \n    float facingSky = dot( arah, vec3( 0, 1, 0 ) );\n    \n    float angle = (iTime * .5 + atan( arah.z, arah.x)) * 7.0;\n    float wave = sin( angle );\n    float weight = .03;\n    \n    vec3 lightDirection = normalize( vec3( -1, -1, 0 ) );\n    vec3 bgNormal = -arah;\n    bgNormal.y += wave;\n    bgNormal = normalize( bgNormal );\n    \n    float lightInfluence = mix( .50, 1.0, dot( lightDirection, bgNormal ) );\n    \n    float horizon = step(0.0, arah.y - wave * weight );\n    \n    vec3 color = mix( vec3(1), vec3( 1, 0, 0), horizon );\n\n    return mix( vec3(mix(.40, 1.0, -facingSky * lightInfluence)), vec3( mix(.40, 1.0, facingSky * lightInfluence ), 0, 0), horizon );\n}\n\n//konversi frag coord ke ray\n//jadi kita tembak ray dari setiap pixels di layar\nvoid KalkulasiRay( in vec2 fragCoord, out vec3 posisi, out vec3 arah )\n{\n    posisi = vec3( 0, 1, 0);\n    float n = 1.0/max(iResolution.x, iResolution.y);\n    arah = normalize(vec3((fragCoord - iResolution.xy*0.5)*n, 0.5));\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nvoid sminCubic( float a, float b, vec3 va, vec3 vb, float k, out float blend, out vec3 blendV3 )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    blend = min( b, a ) - h*h*h*k*(1.0/6.0);\n    blendV3 = mix( vb, va, h );\n}\n\nvec3 Raytrace(in vec2 fragCoord )\n{\n    //ray for this pixel\n    vec3 posisiRay;\n    vec3 arahRay;\n    KalkulasiRay( fragCoord, posisiRay, arahRay );\n    \n    //bola di tengah layar\n    vec4 bola = vec4( 0, 0, 11, 3);\n    \n    //jarak dari ray ke permukaan, atau kalau miss\n    float t = InterseksiBola( posisiRay, arahRay, bola );\n    \n    //surface normal dari bola\n    vec3 normal = normalize(bola.xyz - (posisiRay + arahRay * t));\n    \n    //bola kecil, disini bolanya nya di combine kalau dekat satu sama lain\n    for( int i = 0; i < 5; i++)\n    {\n        float angle = float(i) * (3.14 * .20) * 2.0 + iTime;\n        float jarak = 1.0 + abs( sin( iTime ) * 3.0 );\n        \n        vec4 bolaKecil = vec4( bola.x + cos(angle) * jarak, bola.y , bola.z + sin(angle) * jarak, .5 + abs( sin(iTime * .1) ) );\n\n        float tk = InterseksiBola( posisiRay, arahRay, bolaKecil );\n        \n        float blend = step(t, tk );\n        \n        vec3 tnormal = normalize(bolaKecil.xyz - (posisiRay + arahRay * tk));\n        \n        //smoothing blend\n        sminCubic( t , tk, normal, tnormal, 1.1, tk, tnormal );\n        \n        normal = mix(tnormal, normal, blend );\n        \n        t = tk;\n        \n    }\n    \n    //kalau t > 0 ( ray kena permukaan bola )\n    //sample pixel dengan latar belakang dengan arah ray yang di pantul kan dengan surface normal dari bola\n    //else sample pixel dengan arah ray yang ga di pantul kan\n    return mix( LatarBelakang(reflect( arahRay, normal )),\n                LatarBelakang( arahRay ), \n                step(100.0, t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor = vec4( Raytrace( fragCoord ), 0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 276, 333, 333, 590], [592, 645, 678, 678, 1348], [1350, 1430, 1502, 1502, 1655], [1657, 1714, 1812, 1812, 1931], [1933, 1933, 1968, 1993, 3493], [3495, 3495, 3552, 3576, 3628]], "test": "valid"}
{"id": "fdX3DB", "name": "#WillstallChallenge day 3", "author": "ja6kjak", "description": "followed this tutorial: https://www.youtube.com/watch?v=Ff0jJyyiVyw&list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P\n", "tags": ["raymarching", "beginner", "willstallchallege"], "likes": 0, "viewed": 62, "published": "Public", "date": "1616436420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n// smooth min from https://www.cl.cam.ac.uk/teaching/1718/FGraphics/1.%20Ray%20Marching%20and%20Signed%20Distance%20Fields.pdf\nfloat smin(float a, float b) {\nfloat k = 0.2;\nfloat h = clamp(0.5+ 0.5 *(b-a) /k, 0.,1.);\n\nreturn mix(b,a,h) - k * h *(1. -h);\n\n}\n\n// rotation copied from: https://www.shadertoy.com/view/Wtl3zN\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    //distance between point p to point c\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    // exterior distance\n    float e = length(max(vec2(x, y),0.0));\n    float i = min(max(x,y),0.);\n    return e + i;\n    \n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    //distance between point p to point c\n    return length(p-c)-r;\n    \n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.));\n}\n\nfloat GetDist(vec3 p) {\n    // sphere    position  radius\n   vec4 s = vec4(0,1,6,1);\n   vec3 cubePos = rotation(p - vec3(0.,1.,6), vec3(0.,.5,0.5), iTime);\n   \n   float sphereDist = length(p-s.xyz) - s.w;\n   float planeDist = p.y;\n   \n   float td = sdTorus(p-vec3(.0,.2,6), vec2(1.5, .3));\n   float td2 = sdTorus(cubePos, vec2(1.5,.3));\n   float bdrotate = sdBox(cubePos, vec3(.95));\n   \n   float d = smin(td, planeDist);\n   d= smin(d, bdrotate);\n   d = smin(d, td2);\n   return d;\n   \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    // distance from origin\n    float dO=0.;\n    \n    // Ray marching loop\n    for(int i=0; i<MAX_STEPS; i++) {\n        // start at ray origin then march in certain distance in ray direction\n        vec3 p = ro + rd *dO;\n        float dS = GetDist(p);\n        dO += dS;\n        //HIT!!\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0. , 1.);\n    //shadows\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(0, 2, 0);\n    // ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y-.2, 1));\n   \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    //difuse lighting\n    float dif = GetLight(p);\n    vec3 col = vec3(.1, dif, .3);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdX3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 194, 224, 224, 323], [325, 388, 438, 438, 989], [991, 991, 1042, 1042, 1419], [1422, 1422, 1472, 1472, 1685], [1687, 1687, 1718, 1718, 1791], [1793, 1793, 1822, 1822, 1862], [1864, 1864, 1887, 1921, 2350], [2352, 2352, 2386, 2414, 2742], [2745, 2745, 2769, 2769, 2969], [2971, 2971, 2995, 2995, 3317], [3319, 3319, 3376, 3376, 3761]], "test": "valid"}
{"id": "fdX3Dr", "name": "Fyrecean Mandelbulb", "author": "Fyrecean", "description": "A mandelbulb rendered with a ray marcher", "tags": ["raymarchfractalmandelbulb"], "likes": 6, "viewed": 138, "published": "Public", "date": "1615754248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int maxSteps = 70;\nconst float hitThreshold = .001;\nconst float maxDistance = 800.;\nconst float specExp = 8.;\nconst float AA = 1.;\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\n\n\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\n\nmat3 rotMat3(vec3 u, float t)\n{\n    u = normalize(u);\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\nmat2 rotMat2(float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p - s.center) - s.radius, s.color);\n}\n\nHit boxSDF( vec3 p, Box b )\n{\n  vec3 q = abs(p - b.center) - (b.size);\n  float radius = 0.02;\n  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\n\n// Signed distance functions for different shapes\n\nHit mandelbulbSDF(vec3 p)\n{\n    float power = 8.;\n    vec3 z = p;\n    float dr = 1.;\n    float r;\n    vec3 c1 = vec3(.5, 1., 1.);\n    vec3 c2 = vec3(0., 1., 0.) * .02;\n    \n    for (int i = 0; i < 15; i++)\n    {\n        r = length(z);\n        if (r > 2.)\n        {\n            break;\n        }\n        float theta = acos(z.z / r) * power + iTime;\n        float phi = atan(z.y/z.x) * power + iTime;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n        c2 += c2;\n    }\n    return Hit(0.5 * log(r) * r / dr, c1 - c2);\n}\n\n// Smooth min to cause shapes to morph into eachother\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nHit hitSMin(Hit a, Hit b, float k)\n{\n    float h = clamp(0.5+0.5*(b.t-a.t)/k, 0.0, 1.0 );\n    float f = mix(b.t, a.t, h) - k*h*(1.0-h);\n    vec3 c = mix(b.color, a.color, h) - k*h*(1.0-h);\n    return Hit(f, c);\n}\n\n// Define the objects in the scene and their relations to eachother\nHit map(vec3 p)\n{\n    mat3 rot = rotMat3(vec3(1., 0., -0.5), iTime/4.);\n    return mandelbulbSDF(rot * p);\n}\n\n// Calculate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec3 eps = vec3(0.001, 0., 0.);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n        i += 3;\n        if (i > maxSteps)\n        {\n            break;\n        }\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(5., 3., 6.), 8., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., 5., 5.), 4., vec3(1., .5, .1), 8.),\n        Light(vec3(-4., -10., 2.), 7., vec3(1., 0.5, .8), 8.)\n    );\n    vec3 ambient = vec3(1.) * .05;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness) * 4.;\n        \n        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glowBase = vec3(1., .0, .3) * .002;\n    vec3 glow = vec3(0.);\n    float t = 0.;\n    for (int i = 0; i < maxSteps && t <= maxDistance; i++)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color + glow;\n        }\n        t += closestHit.t;\n        glow += glowBase;\n    }\n\n    return vec3(0.01, 0.02, 0.03) + glow;\n}\n\nvec4 render(in vec3 e, in mat4 view, in vec2 uv) {\n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    return vec4(raymarch(viewRay), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    mat3 rot = rotMat3(vec3(0.), 0.);\n    vec3 e = vec3(0., 0., 2.3);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n        // Convert pixel coordinates to uv coordinates\n    if (AA > 1.) {\n      vec4 average = vec4(0.0);\n      for (float s = 0.; s < AA; s++) {\n        for (float t = 0.; t < AA; t++) {\n            vec2 offset = (vec2(s, t) / AA) - 0.5;\n\n            vec2 uv = (fragCoord + offset)/iResolution.xy * 2. - 1.;\n            uv.y *= iResolution.y/iResolution.x;\n\n            average += render(e, view, uv);\n        }\n      }  \n      average /= AA*AA;\n      fragColor = average;\n    } else {\n      vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n      uv.y *= iResolution.y/iResolution.x;\n\n      fragColor = render(e, view, uv);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdX3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 495, 495, 534], [536, 536, 567, 567, 903], [905, 905, 928, 928, 1026], [1028, 1028, 1061, 1061, 1121], [1123, 1123, 1152, 1152, 1303], [1305, 1356, 1383, 1383, 2009], [2011, 2065, 2106, 2106, 2195], [2197, 2197, 2223, 2223, 2305], [2307, 2307, 2343, 2343, 2519], [2521, 2589, 2606, 2606, 2697], [2699, 2749, 2774, 2774, 3060], [3062, 3100, 3148, 3148, 3674], [3676, 3732, 3772, 3772, 4671], [4673, 4705, 4729, 4729, 5310], [5312, 5312, 5362, 5414, 5546], [5548, 5548, 5605, 5626, 6642]], "test": "error"}
{"id": "fdXGD2", "name": "Неявные функции", "author": "Boria", "description": "границы неявных функций", "tags": [], "likes": 1, "viewed": 28, "published": "Public", "date": "1617005060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =50.0 * fragCoord/iResolution.xy-25.0;\n    float x = uv.x - sin(iMouse.x / 100.0);\n    float y = uv.y * (iResolution.y / iResolution.x);\n    float a = sin(iTime);\n    vec3 col;\n    \n    //vec3 col =vec3(0.8, y - a / 1000.0 - sin(3.0 * y / (x + a * y)) ,0.5);\n     x /= 4.0;\n     y/= -4.0;\n     float c = sin(x  / y * a * a);\n     c = 0.01 / c;\n    if (c >= 0.0) {\n    col = vec3(c  ,0.0 ,0.0);\n    }\n    else {\n    col = vec3( 0.0,0.0, -c);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n// x * x + y * y +10x -", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 554]], "test": "valid"}
{"id": "fsB3Rz", "name": "First Trippy Shader", "author": "iamyou__", "description": "Trying out Shadertoy with some wavy functions. Really trippy stuff!", "tags": ["trippy"], "likes": 0, "viewed": 54, "published": "Public", "date": "1616793409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching guide (https://michaelwalczyk.com/blog-ray-marching.html) that got me started.\n// \n// Inspiration from my friend who has been doing this quite a while.\n\n\nconst float pi = 3.1415926535897932384626433832795;\n\n/// Map\nfloat map(in vec3 pos){\n    float v1 = sin(pi * (pos.z - pos.y) * (-9.2)+ 130.0);\n    float v2 = cos(pi * (pos.x + pos.z) * (-2.0) - 20.0);\n    \n    float p = v1 * v2 * sin(cos(pi * pos.x * 8.3));\n    float t = mod(iTime, 4.1);   \n    \n    float x = p - 0.3 * pos.y * 0.2;\n    return sin(pi * 0.28521235) * x * t;\n}\n\n\n/// Ray Marching function\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n        float distance_to_closest = map(current_position);\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            return current_position;\n        }\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return ro - 1.0 * rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv.x = -uv.x;\n    vec3 camera_position = vec3(278, 273, -800) * 0.001;\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv, 1.0);\n    float t = 0.0;\n    t += iTime + 0.0001;\n    \n    // Ray march here \n    vec3 current_position = ray_march(ro, rd);    \n    fragColor = vec4(current_position, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 231, 254, 254, 546], [549, 575, 615, 615, 1270], [1272, 1272, 1329, 1329, 1703]], "test": "valid"}
{"id": "fsf3Rj", "name": "SkewTriGrid", "author": "Del", "description": "Triangle grid using the skewed, split rectangle method - outputs border distance, centre distance, cell UVs and cell IDs.\nIs it possible to make this shorter / quicker ?", "tags": ["grid", "triangle", "uv", "distance", "edge", "skew", "id"], "likes": 10, "viewed": 204, "published": "Public API", "date": "1616197538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Triangle grid using the skewed, split rectangle method\n//\n// Is it possible to make this any quicker?\n\n// SkewTriGrid outputs:\n// x = dist to border\n// y = dist to centre\n// zw = uv\n// id = celltile ID\n\n// this version based on fabrices excellent hexagonal tiling tutorial (I wish I'd found this earlier!!)\n// https://www.shadertoy.com/view/4dKXR3\nvec4 SkewTriGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(uv,1.-uv.x-uv.y);\n    vec3 _id = floor(g)+0.5;\n    g = fract(g);\n    float lg = length(g);\n    if (lg>1.)\n        g = 1.-g;\n    vec3 g2 = abs(2.*fract(g)-1.);                  // distance to borders\n    vec2 triuv = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);\n    float edge = max(max(g2.x,g2.y),g2.z);\n    id = _id.xy;\n    //id*= mat2(1,.5, 0,1.73/2.); // Optional, unskew IDs\n    //id.xy += sign(lg-1.)*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43,length(triuv),triuv);\n}\n/*\n// my original version...\nvec4 SkewTriGrid(vec2 uv, out vec2 id)\n{\n    const mat2 m=mat2(1.0, -0.57735, 0.0, 1.15470);\n    uv*=m;\n    vec3 ftri = fract(vec3(uv,1.0-uv.x-uv.y));\n    vec3 border = abs(2.0*ftri-1.0);\n    float edge = max(max(border.x,border.y),border.z); \n    id = floor(uv)+0.5;\n    vec2 triuv = (ftri.xy-0.5) * inverse(m);\n    float itri = sign(length(ftri)-1.);\n    triuv -= vec2(0.25, 0.1443376) * itri;\n    triuv.xy *= -itri;\n    //id*= inverse(m); // Optional, unskew IDs\n    //id.xy += itri*0.1; // Optional tastefully adjust ID's\n    return vec4((1.0-edge)*0.43, length(triuv), triuv);\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float xx = ((fragCoord.x-.5*iResolution.x) / iResolution.x)+0.5;\n\n    vec2 id;\n    vec4 h = SkewTriGrid(uv*(8.0+sin(iTime)),id);\n\n    vec3 bordercol = vec3(1.0,1.0,1.0);\n    vec3 shapecol = vec3(0.45,0.35,0.15);\n    \n    // just do a simple patterned shape tint based on cell IDs\n    float patternVal = .5; // 4.1\n    shapecol *= 1.0 + pow(abs(sin(length(id)*patternVal + iTime*0.65)), 4.0);\t// pulse mult\n    \n    // Output to screen\n    vec3 finalcol = mix(vec3(0.0),shapecol,smoothstep(0.0, 0.035, h.x-0.035)); // black outline edge\n    float vv = smoothstep(0.0, 0.055, h.x);\n    finalcol = mix(bordercol,finalcol, vv*vv); // white edge\n    finalcol = mix(vec3(0.0),finalcol,smoothstep(0.0, 0.035, h.y-0.035)); // black outline centre\n    vv = smoothstep(0.0, 0.055, h.y);\n    finalcol = mix(bordercol,finalcol, vv*vv);  // white centre    \n\n    // show the distances/UVs etc.\n    if (uv.y<-0.3)\n    {\n        if (xx<0.33)\n            finalcol = vec3(h.x);// show edge distance\n        else if (xx<0.66)\n            finalcol = vec3(h.y); // show centre distance\n        else\n            finalcol = vec3(h.zw,0.0); // show cellUV\n        // add some red divider lines\n        float dd = max( step(abs(xx-0.33),0.0025),step(abs(xx-0.66),0.0025));\n        dd = max(dd,step(abs(uv.y+0.305),0.0065));\n        finalcol = dd<1.0 ? finalcol : vec3(1.0,0.3,0.3);\n            \n    }\n    \n    fragColor = vec4(finalcol ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 351, 391, 391, 953], [954, 1570, 1627, 1627, 3118]], "test": "valid"}
{"id": "fsf3Wf", "name": "Fractal 46_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 346, "published": "Public API", "date": "1616620575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=.1*H(log(s)*.1+.2)*exp(-2.*i*i*e)\n    )\n    {\n        p=g*d-vec3(-.2,.3,2.5);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        q=p;\n        s=4.;\n        for(int j=0;j++<6;s*=e)\n            p=sign(p)*(1.-abs(abs(p-2.)-1.)),\n            p=p*(e=6./clamp(dot(p,p),.1,3.))-q*vec3(2,8,1)-vec3(5,2,1);\n        g+=e=length(p)/s;\n    }\n    O.xyz=mix(O.xyz,dot(O.xyz,vec3(1))*vec3(1),.2);\n    O.xyz=min(O.xyz,.99);\n    O.xyz=pow(O.xyz,vec3(1,1,5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 754]], "test": "valid"}
{"id": "fsf3Wl", "name": "modus1", "author": "modus", "description": "weird\nalso w/ artefact", "tags": ["blink"], "likes": 0, "viewed": 24, "published": "Public", "date": "1616769358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    float k = iResolution.x/iResolution.y; //monitor ratio (basically 16/9)\n    uv.x *= k;\n    \n    float a = abs(sin(iTime))*(uv.y/tan(uv.y))*(uv.x/tan(uv.x));\n    fragColor = vec4(a,a,a,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 296]], "test": "valid"}
{"id": "fsf3WX", "name": "3D Sierpinsky ternary bits", "author": "FabriceNeyret2", "description": "3D Sierpinsky: outside if one of the ternary bits of location is 1 in at least 2 dimensions simultaneously.\nBut you can experiment other counts ;-)\n\nset OPAQUE to 0 for transparency ( costly ! )", "tags": ["sierpinsky"], "likes": 13, "viewed": 238, "published": "Public API", "date": "1616612094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Sierpinsky ternary bits\" by FabriceNeyret2. https://shadertoy.com/view/NdX3WX\n\n#define OPAQUE 1\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    vec2 R = iResolution.xy;\n    int i, z, n = int(log2(R.x));\n\n    vec2 t = .5 * vec2( cos(iTime), sin(iTime) );   // 3rd dim projection angle\n\n // z = iFrame % int(R.y); { \n    for ( z = 0; z <= int(R.y); z++ ) {             // slices along depth\n        ivec3 I =  ivec3 (U - t*float(z) , z ), F;  // I = 3D location\n        for ( i = 0; i <= n; i++, I/=3 ) {          // inspect ternary bits\n            F = 1-abs(I%3-1);                       // iseq(I,1)\n         // F = ivec3(equal( I%3, ivec3(1) ));      // iseq(I,1)\n            if ( F.x+F.y+F.z > 1 ) break;           // at least 2 bits at 1: exit\n          }\n#if OPAQUE\n        if ( i == n+1 ) {                           // in Sierpinsky\n            O += vec4( i == n+1 )*exp(-float(z)*4./R.y); // AO \n            break;\n        }\n#else\n        if ( i == n+1 )  O += vec4( i == n+1 );     // in Sierpinsky : optical depth++\n#endif\n    }\n  \n#if !OPAQUE\n    O = 1.-exp(-O/40.);                             // optical depth to opacity\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 147, 147, 1160]], "test": "error"}
{"id": "fsf3zf", "name": "Day 2 WillstallChallenge", "author": "ja6kjak", "description": "I followed a The Art of Code tutorial! https://www.youtube.com/watch?v=PGtv-dBi2wE&list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P&index=4", "tags": ["raymarching", "beginner", "willstallchallenge"], "likes": 2, "viewed": 77, "published": "Public", "date": "1616349103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat GetDist(vec3 p) {\n    // sphere    position  radius\n    vec4 s = vec4(0, 1, 6, 1);\n    vec4 s2 = vec4(3,1,6,1);\n    vec4 s3 = vec4(-3, 1, 6,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float sphereDist2 = length(p-s2.xyz) -s2.w;\n    float sphereDist3 = length(p-s3.xyz) -s3.w; \n    float planeDist = p.y;\n    \n    // is there a better way to do this?\n    float d = min(min(sphereDist, min(sphereDist2, sphereDist3)), planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    // distance from origin\n    float dO=0.;\n    \n    // Ray marching loop\n    for(int i=0; i<MAX_STEPS; i++) {\n        // start at ray origin then march in certain distance in ray direction\n        vec3 p = ro + rd *dO;\n        float dS = GetDist(p);\n        dO += dS;\n        //HIT!!\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0. , 1.);\n    //shadows\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(0, 1, 0);\n    // ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n   \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    //difuse lighting\n    float dif = GetLight(p);\n    vec3 col = vec3(dif, .10, .5);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsf3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 91, 125, 525], [527, 527, 561, 589, 917], [920, 920, 944, 944, 1144], [1146, 1146, 1170, 1170, 1492], [1494, 1494, 1551, 1551, 1934]], "test": "valid"}
{"id": "fsfGWj", "name": "Projet Synthèse d'Images // QUIN", "author": "quinthomas", "description": "Rendu du projet de Synthèse d'Images", "tags": ["raytracing", "raycasting"], "likes": 3, "viewed": 71, "published": "Public", "date": "1616699492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//QUIN Thomas ING3 VISUAL\n//Rendu du projet Synthèse d'Images\n\n//Fonctionnalités présentes : \n// - Raytracing étendu\n// - Antialiasing\n// - Lumières multiples\n// - Motion blur\n\n//##############################################################################################\n\n//PARAMETERS\n//##############################################################################################\n//Material Structure\nstruct Material\n{\n    float Ka;\t// ambiant coefficient\n    float Kd;\t// diffuse coefficient\n    float Ks;\t// specular coefficient\n    float Kn;\t// specular power coefficient\n};\n\n//Structure which represents shade informations\nstruct ShadeInfo\n{\n    vec3 shadeCol;\n    float Ks;\n};\n\n//Structure which represents light informations\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \n//Maximum number of bounce allowed for a ray    \nconst int MAX_NB_BOUNCES = 5;\n\n//Camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0;\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(0,0,1);\nconst Material sphereMat = Material(0.2/*Ka*/,0.7/*Kd*/,1.0/*Ks*/,50.0/*Kn*/);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1);\n\n//Light 1\nconst vec3 light1Col = vec3(1,1,1);\nvec3 light1Pos = vec3(8,10,-12);\nconst float light1Pow = 0.8;\n\n//Light 2\nconst vec3 light2Col = vec3(1,1,0.5);\nvec3 light2Pos = vec3(3,10,1);\nconst float light2Pow = 0.5;\n\n//You can edit this value, but have to create more parameters for each light you add\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0, 0.1, 0);\nconst vec3 planeNormal = vec3(0,1.0,0);\nconst vec3 planeCol1 = vec3(1.0);\nconst vec3 planeCol2 = vec3(0.4);\nconst Material planeMat = Material(0.2/*Ka*/,1.0/*Kd*/,0.2/*Ks*/,5.0/*Kn*/);\nconst int planeId = 2;\n\n//Antialiasing constant, you are free to edit this value, this may have a impact on the antialiasing visual effect\nconst int ANTIALIASING = 5;\n\n//Motion blur constants\nconst int MOTION_BLUR = 5;\nconst float MOTION_BLUR_TIME = 0.0; // Useless\n\nfloat FLT_MAX = 9999999.9;\n\n//##############################################################################################\n\n// METHODS & CODE\n\n//##############################################################################################\n\n//Cast ray on sphere\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if(di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1.0 / (2.0 * a);\n        float t1 = (-b - sdi) * den;\n        float t2 = (-b + sdi) * den;\n        \n        intersecS = rayPos + t1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return t1;\n    }\n    \n    return -1.;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Cast ray on plane\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Cast ray and find the nearest intersection object\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI){\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    //If it's a sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    //If it's the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Get the sphere color\nvec3 getSphereColorAtPoint(vec3 pt){\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Get the plane color\nvec3 getPlaneColorAtPoint(vec3 pt){\n    return mod(floor(pt.x * 0.5) + floor(pt.z * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n//Get the color of the object at the point\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat){\n   if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n//Throw ray from camera\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos;\n    \n    float f = 1./tan(radians(cameraFovY)/2.);\n    \n    vec3 PT = cameraTarget - cameraPos;\n    vec3 cz = normalize(PT);\n    \n    vec3 PO = f*cz;\n    \n    vec3 cyT = vec3(0,-1.,0);\n    vec3 cxT = cross(cyT,cz);\n    \n    vec3 cx = normalize(cxT);\n    \n    vec3 cy = cross(cz,cx);\n    \n    vec3 OS = pixCoord.x * cx - pixCoord.y * cy;\n    \n    rayDir = normalize(PO+OS);\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Get the factor of shadow at the point\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    I += 0.001*N;\n    int objId;\n    vec3 intersecS, normalS;\n    float d = computeNearestIntersection(I,L,objId,intersecS,normalS);\n    return (d<=0.0 || d>=Ldist)?1.0:objectMat.Ka;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Phong Shading\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normal, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 A = sphereMat.Ka * ambiantCol / float(NB_LIGHTS);\n    vec3 D = sphereMat.Kd * sphereCol * light.col * light.power * max(dot(L,normal),0.0);\n    vec3 S = sphereMat.Ks * light.col * light.power  * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    return A+shadowFactor*D+shadowFactor*S;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n//Throw ray at pixel coords\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        if(distI <= 0.0)\n        {\n            infos[nbBounces].shadeCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n    \tvec3 V = -rayDir;\n        Material objMat;\n    \tvec3 col = getObjectColorAtPoint(objectId, intersecI, objMat);\n        \n        vec3 c = vec3(0.);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n    \t\tvec3 L = normalize(lights[i].pos - intersecI);\n    \t\tvec3 R = normalize(2.0*dot(normalI,L)*normalI - L);\n        \n        \tfloat Ldist = distance(intersecI,lights[i].pos);\n        \n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objMat, L, Ldist);\n        \n    \t\t//Phong shading to get the color of the surface point\n    \t\tc += computePhongShading(col, objMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n        \n        infos[nbBounces].shadeCol = c;\n        infos[nbBounces].Ks = objMat.Ks;\n        \n        rayPos = intersecI + 0.001*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        \n        nbBounces++;\n        \n    }while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n   \tdo\n    {\n        resCol = infos[nbBounces].shadeCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }while(nbBounces >= 0);\n    \n    return resCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Make noise (antialiasing)\nvec2 noise2(vec2 location, vec2 delta){\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c))*m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c))*m)\n        );\n}\n\n//----------------------------------------------------------------------------------------------\n\n//Animate the scene\nvoid updateScene(float time)\n{  \n    cameraPos.xz = vec2(cos(time), sin(time)) * 4.0f;\n    light1Pos = vec3(cos(0.5 * time + 1.0), 2.0f, sin(0.5 * time + 1.0)) * 3.0f;\n    light2Pos = vec3(cos(0.5 * time), 2.0f, sin(0.5 * time)) * 2.0f;\n}\n\n//##############################################################################################\n\n//MAIN CODE\n\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    //updateScene(time);\n    \n    //Edit this value to change the noise\n    float delta = 0.01;\n    \n    \n    \n    //Apply change of coordinates from pixel\n    fragCoord = (2. * fragCoord - iResolution.xy) / iResolution.y;;\n    \n    vec3 resCol;\n    for(int j=0 ;j<MOTION_BLUR;j++){\n        \n        //Modifying update time to have a difference between images\n        float time_blur = time + float(j) * iTimeDelta / float(MOTION_BLUR);\n        updateScene(time_blur* /*Up this value to have a better view point on motion blur*/4.0);\n        \n        lights[0].pos = light1Pos;\n        lights[0].col = light1Col;\n        lights[0].power = light1Pow;\n        lights[1].pos = light2Pos;\n        lights[1].col = light2Col;\n        lights[1].power = light2Pow;\n    \n        for (int i=0; i<ANTIALIASING; i++) \n        {\n            vec2 aa = noise2(fragCoord, vec2(delta)) / iResolution.xy;\n            resCol += RaytraceAtPixelCoord(fragCoord + aa);\n        }\n    }\n    resCol /= float(ANTIALIASING * MOTION_BLUR);\n\n    fragColor = vec4(resCol,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2490, 2511, 2628, 2628, 3170], [3270, 3290, 3403, 3403, 3657], [3757, 3809, 3924, 3924, 4710], [4810, 4833, 4869, 4869, 4893], [4993, 5015, 5050, 5050, 5143], [5245, 5288, 5362, 5362, 5623], [5724, 5748, 5832, 5832, 6231], [6331, 6371, 6458, 6458, 6643], [6743, 6759, 6894, 6894, 7181], [7282, 7310, 7352, 7352, 8981], [9081, 9109, 9148, 9148, 9364], [9464, 9484, 9514, 9514, 9722], [9835, 9933, 9990, 9990, 11066]], "test": "valid"}
{"id": "fsfGWM", "name": "Star Rider", "author": "ahmaderfani12", "description": "Star Rider\ncheck the unity project using it:\nhttps://youtu.be/dvlMRb8_ugw\nhttps://github.com/ahmaderfani12/StarRider-shader", "tags": ["2d", "light", "star", "stars"], "likes": 9, "viewed": 365, "published": "Public API", "date": "1616243170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap(float s, float a1, float a2, float b1, float b2)\n{\n    return b1 + (s-a1)*(b2-b1)/(a2-a1);\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec3 stars(vec2 uv, float radious , vec3 shineColor , float power,float isVisible){\n    vec3 color=vec3(0.0);\n      if(isVisible>=0.65){\n      \n    float dis = distance(uv,vec2(0.5));\n    float circle  = smoothstep(radious,radious+0.01,dis);\n    float light = distance(uv-vec2(0.5),normalize(uv-vec2(0.5))*radious)*step(radious,circle)*3.0;\n\tlight =(1. - clamp(light,0.0,1.0));\n    \n     color = mix(vec3(1.),(shineColor*light),vec3(circle))*power;\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    //adjust uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *=  iResolution.x/iResolution.y;\n     \n     vec3 starsCol = vec3(0.0);\n                \n     //scale uv\n     uv *=vec2(30.);\n     //move star rows\n    uv.x += iTime*(random(floor(uv.y))+0.1)*20.;\n    vec2 ipos = floor(uv);  \n    vec2 fpos = fract(uv);\n     \n    float cellSize = random(ipos);\n    cellSize=remap(cellSize,0.0,1.0,0.0,0.3);\n    \n    starsCol=stars(fpos,cellSize,vec3(0.190,0.283,0.770),1.,random(ipos*100.));\n    \n \n    \n    fragColor = vec4(starsCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 104], [106, 106, 133, 133, 165], [167, 167, 194, 194, 268], [270, 270, 353, 353, 749], [753, 753, 810, 828, 1351]], "test": "valid"}
{"id": "fsfGWN", "name": "Flare try", "author": "DomenPigeon", "description": "Flare try 1, my first shader, done with out any tutorial :D", "tags": ["flare"], "likes": 2, "viewed": 65, "published": "Public", "date": "1615921702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float shine_f(){\n    float x = iTime;\n    return pow(sin(x/5.)*sin(x/2.)*sin(2.*x), 2.) + .2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p - vec2(.5, .5);\n    q.x *= iResolution.x / iResolution.y;\n\n    vec3 sky = vec3(7./255., 18./255., 27./255.);    \n    vec3 shine = vec3(119./255., 199./255., 242./255.);\n\n    float curve = 1.;\n    curve = exp(length(q) * 5.) - 1.3;\n    curve *= shine_f();\n    curve *= 6.;\n    curve += cos((atan(q.x, q.y) + iTime) * 6.) * .3; \n    shine = mix(vec3(1.), shine, curve);\n\n    fragColor = vec4(shine, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsfGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 95], [98, 98, 155, 155, 614]], "test": "valid"}
{"id": "fsj3z1", "name": "Starry Capsule", "author": "warptarium", "description": "Adaptation of the capsule signed distance functions introduced in this video https://youtu.be/Ff0jJyyiVyw\n\nThe capsule and the background are phong shaded and rendered with raymarching.", "tags": ["raymarching", "texture", "practice", "capsule"], "likes": 0, "viewed": 48, "published": "Public", "date": "1616974756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.03\n#define AMBIENT_LIGHT_STRENGTH 0.1\n#define DIFFUSE_LIGHT_STRENGTH 0.5\n#define SPECULAR_LIGHT_STRENGTH 0.5\n\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n\n#define YELLOW vec3(1.0, 1.0, 0.0)\n\n//Created by Weston McNamara \n//capsule SDF adapted https://youtu.be/Ff0jJyyiVyw\n\nfloat sdfCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    //https://youtu.be/Ff0jJyyiVyw\n    a *= sin(iTime) / 2.0;\n    b *= cos(iTime) / 2.0;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t * ab;\n    return length(p-c) - r;\n}\n\nfloat sdfPlane(vec3 p) \n{\n    vec3 planePos = vec3(0, 0, 8);\n    \n    return length(planePos - p);\n}\n\n//SDF to the background plane\nfloat sdfScene(vec3 p) \n{\n    float dsCapsule = sdfCapsule(p, vec3(0.0, -0.6, 2.0), vec3(0.0, 0.8, 2.0), 0.3);\n    float dsPlane = sdfPlane(p);\n    return min(dsCapsule, dsPlane);\n}\n\n//Generates a normal by sampling points\nvec3 genNormal(vec3 p) \n{\n    float d = sdfScene(p); //very close to 0\n    \n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = vec3\n    (\n        d - sdfScene(p - e.xyy),\n        d - sdfScene(p - e.yxy),\n        d - sdfScene(p - e.yyx)\n    );\n        \n    return normalize(n);\n}\n\n//calculates phong shading at a given point\nfloat phong(vec3 p, vec3 viewPos) \n{\n    vec3 lightPos = vec3(sin(iTime) * 3., 3, cos(iTime)*3.);\n    vec3 lightDir = vec3(0, 0, -1);\n    vec3 lightRay = lightPos + lightDir;\n    \n    float color = AMBIENT_LIGHT_STRENGTH; //start with ambient\n    \n    vec3 norm = genNormal(p);\n    \n    //diffuse\n    float dif = dot(lightRay, norm) * DIFFUSE_LIGHT_STRENGTH;\n    \n    //specular\n    //modification of https://learnopengl.com/Lighting/Basic-Lighting\n    vec3 viewDir = normalize(p - viewPos);\n    vec3 incident = reflect(-viewDir, norm);\n    \n    float spec = pow(clamp(dot(viewDir + norm * SURF_DIST, incident), 0.0, 1.0), 64.0) * SPECULAR_LIGHT_STRENGTH;\n    \n    return color + dif + spec;\n}\n\n//standard raymarch function\nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        vec3 p = ro + rd * dO;\n        \n        float dist = sdfScene(p);\n        dO += dist;\n        \n        if (dO > MAX_DIST || dist < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center uvs\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 col = vec4(0);\n        \n    //camera\n    vec3 ro = vec3(0, 0, -3);    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //march point\n    float dS = RayMarch(ro, rd);\n    \n    //calculate light\n    vec3 p = ro + rd * dS;\n    float light = phong(p, ro);\n    \n    col = vec4(light) / 2.0;\n    \n    //if the distance is less than 5, it must be the capsule\n    //because the plane is further than 5 units away.\n    if (dS < 5.) //cube\n    {\n       //Do cool effects to uv and color\n       uv *= vec2(sin(iTime), cos(iTime)) + 1.0 * 3.0;\n       vec3 capsuleColor = vec3(YELLOW / 2.0 * sin(iTime) + 0.8);\n       \n       col *= vec4(capsuleColor, 1.0);       \n    }\n    else //background\n       col *= texture(iChannel0, uv);\n       \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsj3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 393, 445, 480, 711], [713, 713, 738, 738, 813], [815, 845, 870, 870, 1026], [1028, 1068, 1093, 1093, 1342], [1344, 1388, 1424, 1424, 2081], [2083, 2112, 2147, 2147, 2404], [2406, 2406, 2463, 2480, 3373]], "test": "error"}
{"id": "fsj3zW", "name": "detached stimuli", "author": "tripzilch", "description": "you know what, this sketch needs more sine waves.", "tags": ["plasma"], "likes": 7, "viewed": 128, "published": "Public", "date": "1617048218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (c) Piter Pasma\n\n#define TAU 6.283185307179586 // 2 * PI\nconst vec3 gamma = vec3(2.2);\nconst vec3 igamma = 1.0 / gamma;\n\n// sequence 1/Φ(12) from\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nconst vec4 H0 = vec4(0.5138670813222691, 0.5431834938989584, 0.5741724246765705, 0.6069292917805363);\nconst vec4 H1 = vec4(0.6415549569952288, 0.678156036327837, 0.7168452282900885, 0.7577416609086309);\nconst vec4 H2 = vec4(0.8009712585325574, 0.846667129567511, 0.8949699763302439, 0.9460285282856136);\n\n// these numbers are random (except one digit--can you spot it?)\nconst vec4 R = vec4(0.632006, 0.128123, 0.223201, 0.988116);\n\nfloat wobbly(vec2 uv, float t, float seed) {\n  // wobbles vec2 to float using sine waves. the parameters for the\n  // sine waves are initialised randomly from the quasirandom sequence\n  // based on seed.\n  vec4 f = (fract(H0 * seed + R) - .5) * 2.4; f += .4 * sign(f);\n  vec4 g = (fract(H1 * seed + R) - .5) * 0.2; g += .1 * sign(g);\n  vec4 p = (fract(H2 * seed + R) - .5) * 2.0;\n  const float ma = 0.3; // modulation amount \n\n  vec2 a = sin((f.xy * uv + g.xy * t + p.xy) * TAU);\n  vec2 b = sin((f.zw * uv + g.zw * t + p.zw + ma * a.yx) * TAU);\n\n  return 0.5 * (b.x + b.y);\n}\n\nvec2 wobbly2(vec2 uv, float t, vec2 seed) {\n  // wobbles vec2 to vec2, using the other wobbly function. also vec2 for seed, now.\n  return (vec2(wobbly(uv, t, seed.x), wobbly(uv, t, seed.y))\n        + vec2(wobbly(uv * .5, t, seed.y + 2323.), wobbly(uv * .5, t, seed.x + 1123.))) * .5  ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // gently show the pixels to their seating arrangement\n  vec2 iRes1 = 1. / iResolution.xy; \n  vec2 aspect = iResolution.xy * iRes1.y;\n  vec2 uv = (fragCoord.xy * iRes1 - 0.5) * aspect;\n\n  // scale adjustment, makes everything bigger or smaller\n  uv *= 1.2;\n  \n  // speed adjustment\n  float t = iTime * 0.1;\n\n  const float seedA = 1.0; // these three seeds can be any number. tested\n  const float seedB = 2.0; // with integers. but I think any value would\n  const float seedC = 3.0; // work.\n  const vec2 seedAB = vec2(seedA, seedB);\n  \n  // Because wobbly2 makes a vec2->vec2 field, we can take a small step in\n  // direction of that field, then get the new value, make another small step, etc.\n  // Modulating the step_size value in a circular wave from out to in \n  // creates the textural shifts.\n  float step_size = .025 * (.1 + .9 * smoothstep(-.4, .4, sin(4. * length(uv) + t * 1.9)));\n  \n  // We scale the step size slightly differently for the r, g and b channels. \n  // when step_size is small this difference becomes less, which is why those \n  // regions appear more grey / desaturated.\n  float r0 = step_size * 5., g0 = step_size * 6., b0 = step_size * 7.;\n\n  // and then we step on the field, a few times, for the r, g and b channels.\n  vec2 uvr = uv, uvg = uv, uvb = uv;\n  uvr += r0 * wobbly2(uvr, t, seedAB); uvr += r0 * wobbly2(uvr, t, seedAB);\n  uvr += r0 * wobbly2(uvr, t, seedAB); uvr += r0 * wobbly2(uvr, t, seedAB);\n  uvr += r0 * wobbly2(uvr, t, seedAB);\n  uvg += g0 * wobbly2(uvg, t, seedAB); uvg += g0 * wobbly2(uvg, t, seedAB);\n  uvg += g0 * wobbly2(uvg, t, seedAB); uvg += g0 * wobbly2(uvg, t, seedAB);\n  uvg += g0 * wobbly2(uvg, t, seedAB);\n  uvb += b0 * wobbly2(uvb, t, seedAB); uvb += b0 * wobbly2(uvb, t, seedAB);\n  uvb += b0 * wobbly2(uvb, t, seedAB); uvb += b0 * wobbly2(uvb, t, seedAB);\n  uvb += b0 * wobbly2(uvb, t, seedAB);\n\n  // I figured stripes would look cool. Stripes are based on the average dist\n  // moved over the 3 channels (I don't know, seemed like a good idea)\n  float strip = distance(uv, (uvr + uvg + uvb) / 3.);\n  strip = smoothstep(.22, .28, abs(fract(strip * 8.0) - 0.5));\n  \n  // Because we got 3 uv coordinates now, we need to feed those through the \n  // wobbly function one more time, in order to convert them to a float, one\n  // for each color channel.\n  vec3 col = vec3(\n    .5 + .5 * wobbly(uvr, t, seedC),\n    .5 + .5 * wobbly(uvg, t, seedC),\n    .5 + .5 * wobbly(uvb, t, seedC)\n  ) * strip; // apply stripes \n\n  // Intensify colors: Subtract the average value of the three channels, from\n  // each channel separately. Amplify contrast, then add back the average.\n  // Finally saturate values into a smoothstep.\n  const float intensity = 2.0;\n  float c_avg = (col.x + col.y + col.z) / 3.0;\n  col = smoothstep(0.0, 1.0, (col - c_avg) * intensity + c_avg);\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsj3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 668, 712, 871, 1243], [1245, 1245, 1288, 1373, 1532], [1534, 1534, 1591, 1648, 4463]], "test": "valid"}
{"id": "fsl3D2", "name": "Ligth in the dark", "author": "Arseny", "description": "exp", "tags": ["2d"], "likes": 0, "viewed": 144, "published": "Public API", "date": "1616742506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define pi (3.14159265359)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 toPolar(vec2 uv){ // 0 <= x and -pi <= y <= pi\n    return vec2(length(uv), atan(uv.y, uv.x));\n}\n\nvec2 toNormalizedPolar(vec2 uv){ // 0 <= res.x and 0 <= res.y <= 1\n    vec2 res = toPolar(uv);\n    res.y = fract(res.y / pi / 2. + 1.);\n    return res;\n}\n\nvec4 roundedSquare(vec2 uv){\n    vec2 pv = toNormalizedPolar(uv);\n    //return vec4(pv.x, vec3(uv * step(pv.x, 1.), sqrt(1. - pv.x * step(pv.x, 1.))));\n    float t = pv.y;\n    t = fract(t * 4.);\n    t = 2. * abs(t - 0.5);\n    float maxval = mix(1., sqrt(2.), cos(iTime));\n    maxval = mix(1., sqrt(2.), 0.25);    \n    float needD = mix(maxval, 1., S(0., 1., t));\n    float d = pv.x - needD;\n    //return vec4(d / needD, vec3(0.));\n    float l = smoothstep(0., 1., -d / needD);\n    //l = pow(l, 1.5);\n    float k = sqrt(max(1. - l*l, 0.));\n    k *= step(0., -d);\n    l = step(0., -d) * l + step(-d, 0.);\n    return vec4(d, vec3(normalize(uv) * k, l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // uv.y in range(-0.5, 0.5) uv.x proportionately\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float k = 2.5;\n    uv *= k;\n    float pix = 3. / iResolution.y;\n    pix *= k;\n    \n    vec3 lightDir = normalize(vec3(0.4 * sin(iTime * 1.5), 0.4 * cos(iTime * 1.), -1.));\n    //lightDir = vec3(0., 0.2, -1.);\n    vec4 sqrInfo = roundedSquare(uv);\n    fragColor = vec4(sqrInfo.yzw * 0.5 + 0.5, 0.);\n    fragColor = vec4(smoothstep(0., -1., dot(sqrInfo.yzw, lightDir)) * 0.4 + 0.3);\n    \n    return;\n    vec3 ref = reflect(lightDir, sqrInfo.yzw);\n    \n    float d = sqrInfo.x;\n    fragColor = vec4(S(0., pix, abs(d + 0.5 * sin(iTime) + 0.5)));\n    //fragColor = vec4(-d);\n    //return;\n    fragColor = vec4(abs(sqrInfo.yzw), 0.);\n    fragColor = vec4(ref, 0.);\n    \n    //fragColor = vec4(step(0., ref.z) * ref.z * ref.z * ref.z);\n    fragColor = vec4(pow(ref.z, 1.));\n    fragColor = vec4(max(-dot(sqrInfo.yzw, lightDir), 0.) * ref.z * ref.z);\n    //fragColor = vec4(ref.z);\n    //fragColor = vec4(smoothstep(0., 0.01, abs(sqrInfo.x - 0.5 + 0.5 * cos(iTime))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 140, 162, 162, 312], [314, 314, 336, 365, 414], [416, 416, 448, 482, 569], [571, 571, 599, 599, 1223], [1225, 1225, 1282, 1340, 2366]], "test": "valid"}
{"id": "fsl3R2", "name": "Breathing Eye", "author": "manu210404", "description": "I took some inspiration from the logo of this website and decided to add my own twist to it. ", "tags": ["noise", "eye", "psychedelic", "iris"], "likes": 13, "viewed": 259, "published": "Public API", "date": "1616456997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n\n// -------------------------------------- //\n// Animation\n#define ANIM\n\n// inner/outer Radius of iris\n#define INNER_R (0.25+sin(iTime*PI*0.5)*0.06125)\n#define OUTER_R .875\n\n// Background, background of the iris, inner and outer color of eye\n#define BG     vec3(0.1, 0.0, 0.1 )\n#define EYE_BG vec3(0.1, 0.05,0.15)\n#define EYE_1  vec3(0.5, 0.25,0.03)\n#define EYE_2  vec3(0.45,0.65,0.6 )\n\n// how many layers of \"strings\" are rendered\n#define LAYERS 4\n// -------------------------------------- //\n\n// Antialiasing\n#define EPS 12. / iResolution.y / length(p) // epsilon for antialiasing\n\n// gamma correction\n#define G(a) pow((a), vec3(0.4545))\n#define IG(a) pow((a), vec3(2.2))\n\n// hash functions by Dave_Hoskins - https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash11(in float p) {uvec2 n = uint(int(p)) * UI2;uint q = (n.x ^ n.y) * UI0;return float(q) * UIF;}\n\nvec2 hash22(in vec2 p) {uvec2 q = uvec2(ivec2(p))*UI2;q = (q.x ^ q.y) * UI2;return vec2(q) * UIF;}\n\n// simplex noise by iq - https://www.shadertoy.com/view/Msf3WH\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404,K2 = 0.211324865;vec2 i=floor(p+(p.x+p.y)*K1),a=p-i+(i.x+i.y)*K2;float m=step(a.y,a.x);vec2 o=vec2(m,1.-m);\n    vec2 b=a-o+K2,c=a-1.+2.*K2;vec3 h=max(0.5-vec3(dot(a,a),dot(b,b),dot(c,c)),0.),n=h*h*h*h*vec3(dot(a,hash22(i+0.0)),dot(b,hash22(i+o)),dot(c,hash22(i+1.)));\n    return dot(n,vec3(70.0));\n}\n\nmat2 rot(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat iris(in vec2 p) {\n    float d = (OUTER_R + INNER_R) * 0.5;\n    d = (abs(length(p) - d) - d + INNER_R) / (d - INNER_R); // normalized distance to the radii\n    mat2 r;                        // animated rotation of noise-domain\n    float s,                       // animated scale of noise-domain\n          a = atan(p.y, p.x),      // angle to center\n          na,                      // offset of the angle (determined by 2d-noise)\n          f = exp2(float(LAYERS)), // scale of the layers\n          pattern,                 // output variable\n          n,                       // value of the \"strings\" (determined by looping 1d-noise)\n          t,                       // added thickness to \"strings\"\n          alpha;                   // maybe not alpha but I don't know how else to call it\n    vec2 m = iMouse.xy/iResolution.y; // mouse offset of noise-domain\n\n    #ifdef ANIM\n    s = sin(iTime * PI * 0.25) * 0.25;    // animated scale of domain\n    r = rot(iTime * PI * 0.0078125);      // animated rotation of domain\n    #endif\n    \n    for (int i=0; i<LAYERS; i++) {\n        na = a + noise((p - m/f) * 1.5 * f * (1. + s / f) * r) * length(p) * 0.5 / f; // noise to warp strings\n        n = noise(vec2(sin(na),cos(na)) * 2. * f);                                    // value of strings\n        \n        \n        t = .75 / f ;                                     // thickness/density of strings\n        t += - 1.5 * smoothstep(1.0, 0.0, d + 0.5) + 1.5; // strings are cut off at the edge of the iris\n        t += -.125 * smoothstep(1.0, 0.0, d + 1.);        // strings are thicker when closer to center radius\n        \n        pattern -= smoothstep(-0.35,  0.25,  n - t) * 0.5 * pattern; // \"shadows\" of the \"strings\"\n        alpha =    smoothstep(-EPS*f, EPS*f, n - t);\n        pattern += pow(alpha, 2.) * (1. - pattern);               // addition of the layers (i don't really know what im doing here but it looks nice)\n    \n        f *= 0.5;\n    }\n    return max(0.0, pattern); // because of the shadows it could be negative so i clamp it here\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float irisPerimiter_mask = smoothstep(0.1,  -0.1,  length(p) - OUTER_R);\n    float irisPupil_mask =     smoothstep(0.05, -0.05, length(p) - INNER_R);\n    float iris_mask =          -irisPupil_mask + irisPerimiter_mask;\n    \n    float iris_pattern = iris(p);\n    \n    vec3 iris_color = IG(mix(G(EYE_1), G(EYE_2), vec3(sqrt(clamp((length(p) - INNER_R) / (OUTER_R - INNER_R) + 0.01, 0.0, 1.0))))); // color gradient (is this how you gamma correct?)\n    \n    vec3 col = iris_pattern * iris_color + EYE_BG * (1. - iris_pattern); // blending between the gradient and the background\n    \n    col = col * iris_mask + (1. - iris_mask) * BG;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 927, 953, 953, 1032], [1034, 1034, 1058, 1058, 1132], [1134, 1197, 1221, 1221, 1554], [1556, 1556, 1578, 1578, 1641], [1643, 1643, 1666, 1666, 3705], [3707, 3707, 3764, 3764, 4508]], "test": "valid"}
{"id": "fsl3zS", "name": "Glowing Heart", "author": "DomenPigeon", "description": "My first shader which I actually think looks nice :D\n\nThe shader has 3 variants, if you like it please vote which one you like the best in the comments. (DOMEN or KATJUŠA).\n\n\n", "tags": ["tutorial", "heart"], "likes": 3, "viewed": 73, "published": "Public", "date": "1616160277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define DOMEN\n\n\n#ifdef DOMEN_FIRST          ////// DOMEN FIRST TRY\n#define DENS 20.\n#define NEG_COL vec3(1, 0.949, 0.478)\n#define POS_COL vec3(0.76,0,0.01)\n#define FADE_COL vec3(1, 0.658, 0.8)\n\n\n#elif defined DOMEN         ////// DOMEN FINAL\n#define DENS 40.\n#define NEG_COL vec3(153./255., 25./255., 8./255.)\n#define POS_COL vec3(51./255., 8./255., 3./255.)\n#define FADE_COL vec3(51./255., 8./255., 3./255.)\n\n\n#else                       ////// KATJUŠA FINAL\n#define DENS 40.\n#define NEG_COL vec3(1., .180, .204)\n#define POS_COL vec3(.4, .6, .6)\n#define FADE_COL vec3(.9, .8, .8)\n#endif\n\n\nvec3 color_effect(float curve){\n    float neg = abs(min(0., curve));\n    neg = clamp(neg, 0., .85);\n    //neg += cos(curve*DENS) * .15;\n    \n    \n    float pos = max(0., curve);\n    pos = clamp(pos, 0., .85);\n    //pos += cos(curve*DENS) * .15;\n    \n\n    vec3 n = mix(FADE_COL, NEG_COL, neg);\n    vec3 p = mix(FADE_COL, POS_COL, pos);\n    \n    float i = clamp((curve + 1.)/2., 0., 1.);\n    vec3 res = mix(n, p, i);\n    res += exp(-abs(curve*DENS*.6));\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord/iResolution.xy - vec2(.5, .5))*2.;\n    p.x *= iResolution.x / iResolution.y;\n\n    float x = p.x;\n    float y = p.y;\n    float r = 1.8;\n    \n    y += .2;\n    y *= 2.5;\n    y -= abs(sin(x*2.5));\n    x *= 1.9;\n    \n    float d = iTime < .7 ? 0. : iTime - .7;\n    float t = d * 3. + y * 0.3;\n    r += .3 * pow(sin(t), 4.);\n    \n    float c = x*x + y*y - r;\n    \n    vec3 col = color_effect(c);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsl3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 593, 624, 624, 1062], [1064, 1064, 1121, 1121, 1568]], "test": "valid"}
{"id": "fslGD2", "name": "9. Raymarching 1", "author": "Sp3cim4n", "description": "Learning Shader Magic", "tags": ["raymarching", "sdf", "learning"], "likes": 1, "viewed": 155, "published": "Public API", "date": "1616574988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0., 1., 6., 1.);\n    \n    float sphere_dist = length(p - s.xyz) - s.w;\n    float plane_dist = p.y;\n    \n    float d = min(sphere_dist, plane_dist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for(int i = 0; i <= MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO * rd;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO>MAX_DIST || ds < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n             GetDist(p - e.xyy),\n             GetDist(p - e.yxy),\n             GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos =  vec3(0, 4, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime) * 3.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(l, n), 0., 1.);\n        \n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d < length(lightPos - p))\n        dif *= .1;\n\n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. *fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(.0, 1., .0);\n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p /*Surface Position*/ = ro + rd * d;\n    \n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 272], [274, 274, 308, 308, 535], [537, 537, 561, 561, 770], [772, 772, 796, 796, 1118], [1120, 1120, 1175, 1175, 1532]], "test": "valid"}
{"id": "fss3D2", "name": "Fractal 45_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 4, "viewed": 214, "published": "Public API", "date": "1616586401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=.03*H(log(s)*.3+.5)*exp(-8.*i*i*e)\n    )\n    {\n        p=g*d-vec3(-.2,.3,1.2);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        s=2.;\n        for(int j=0;j++<10;s*=e)\n            p=sign(p)*(1.-abs(abs(p-2.)-1.)),\n            p=p*(e=6./clamp(dot(p,p),.1,3.))-vec3(8,.2,8);\n        g+=e=length(p)/s;}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fss3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 611]], "test": "valid"}
{"id": "fssGWM", "name": "bloom grow", "author": "jokey", "description": "with the second UVs,make plant effect of growing", "tags": ["grow"], "likes": 3, "viewed": 53, "published": "Public", "date": "1616056778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 hash22(vec2 p) {\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n    return fract(sin(p)*43758.5453);\n}\n      \n\nfloat perlinNoise(vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    //vec2 u = f*f*(3.0-2.0*f);//插值函数\n    vec2 u =f*f*f*(6.0*f*f-15.0*f+10.0);\n    float n = mix( mix( dot( -1.0+2.0*hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                        dot( -1.0+2.0*hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                        dot( -1.0+2.0*hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return n;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float n=perlinNoise(uv*15.0);\n    vec3 orignCol=texture(iChannel0,uv).rgb;\n    vec3 col0=vec3(0.23,0.95,0.1);\n    float t=mod(iTime*0.2,1.25);\n    float x=uv.x+n*0.1+0.75-t;\n    float d=(max(abs(x-0.5)*5.0-0.1,0.0))*step(x,0.525)+step(0.525,x)*0.02;\n    d=d*20.0;\n    vec3 col=orignCol+(col0/d); \n    col*=step(uv.x,t);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fssGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 132], [141, 141, 169, 169, 692], [697, 697, 754, 804, 1234]], "test": "error"}
{"id": "fsX3zf", "name": "Neon cube", "author": "longshot", "description": "Plain old retro wirecube with a distance field twist.", "tags": ["cube"], "likes": 1, "viewed": 49, "published": "Public", "date": "1616347817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------\n// Plain old retro wirecube with a distance field twist  \n// \n// v1.0 - 2021-03-21 - Initial version\n// Thanks to mrange for improvements\n//--------------------------------------------------------\n\nmat4 model = mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n\nvec2 Project(vec3 p0) {\n  vec3 viewport = vec3(0.0,-2.0,0.0);\n  p0 -= viewport;\n  return length(viewport) * p0.xz / p0.y;\n}\n\nmat4 Scale(vec3 v) {\n  return mat4(vec4(v.x,0,0,0), vec4(0,v.y,0,0), vec4(0,0,v.z,0), vec4(0,0,0,1));\n}\n\nmat4 Rotate(vec3 u, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  vec3 c0 = vec3(c + (u.x*u.x) * (1.0-c), (u.y*u.x) * (1.0-c) + (u.z*s), (u.z*u.x) * (1.0-c) - (u.y*s));    \n  vec3 c1 = vec3((u.x*u.y) * (1.0-c) - (u.z*s), c + (u.y*u.y) * (1.0-c), (u.z*u.y) * (1.0-c) + (u.x*s)); \n  vec3 c2 = vec3((u.x*u.z) * (1.0-c) + (u.y*s), (u.y*u.z) * (1.0-c) - (u.x*s), c + (u.z*u.z) * (1.0-c));\n  return mat4(mat3(c0,c1,c2));\n}\n \nmat4 Translate(vec3 v) {\n  return mat4(vec4(1.0,0,0,v.x), vec4(0,1.0,0,v.y), vec4(0,0,1.0,v.z), vec4(0,0,0,1.0));\n}\n\n\nfloat DistanceToLine(vec3 p0,vec3 p1,vec2 uv) {\n  p0 = (vec4(p0,1.0) * model).xyz;\n  p1 = (vec4(p1,1.0) * model).xyz;    \n  p0.xy = Project(p0);\n  p1.xy = Project(p1);    \n  vec2 d = normalize(p1.xy - p0.xy);    \n  uv = (uv - p0.xy) * mat2(d.x, d.y, -d.y, d.x);  \n  float dist = distance(uv, clamp(uv, vec2(0.0), vec2(distance(p0.xy, p1.xy), 0.0)));\n  return dist;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.7*(b-a)/k, 0.0, 1.0);\n  return mix(b,a,h) - k*h*(1.0-h);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 res = iResolution.xy/iResolution.y;\n  vec2 uv = (fragCoord.xy/iResolution.y) - (res/2.0);\n  uv *= 3.0;     \n  float time = iTime;\n    \n  model *= Scale(vec3(0.3));\n  model *= Rotate(vec3(1.0, 0, 0.0), 1.2*time);\n  model *= Rotate(vec3(0.0, 1.0, 0.0), 1.2*time);\n  model *= Rotate(vec3(0.0, 0, 1.0), 1.2*time);\n  model *= Translate(vec3(0.6*sin(time), 0.2*cos(time)-0.73, 0.18*cos(time)+0.1));\n    \n  vec3 cube[8];\n  cube[0] = vec3(-1,-1,-1);\n  cube[1] = vec3( 1,-1,-1);\n  cube[2] = vec3(-1, 1,-1);\n  cube[3] = vec3( 1, 1,-1);\n  cube[4] = vec3(-1,-1, 1);\n  cube[5] = vec3( 1,-1, 1);\n  cube[6] = vec3(-1, 1, 1);\n  cube[7] = vec3( 1, 1, 1);\n   \n  float dist = 1E6;\n  const float sm = 0.3;\n  dist = pmin(dist, DistanceToLine(cube[0],cube[1], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[1],cube[3], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[3],cube[2], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[2],cube[0], uv), sm);\n\n  dist = pmin(dist, DistanceToLine(cube[4],cube[5], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[5],cube[7], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[7],cube[6], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[6],cube[4], uv), sm);\n\n  dist = pmin(dist, DistanceToLine(cube[0],cube[4], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[5],cube[1], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[2],cube[6], uv), sm);\n  dist = pmin(dist, DistanceToLine(cube[7],cube[3], uv), sm);\n\n  vec3 linecube = vec3(0);     \n  linecube = mix(linecube, vec3(0,0,1), smoothstep(5.0/iResolution.y, 0.0, dist));\n  linecube += sin(0.5*dist*vec3(290.0, 0.0, 3.0));\n  fragColor = vec4(linecube,0.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsX3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 313, 336, 336, 436], [438, 438, 458, 458, 541], [543, 543, 573, 573, 966], [969, 969, 993, 993, 1084], [1087, 1087, 1134, 1134, 1453], [1455, 1455, 1494, 1494, 1578], [1581, 1581, 1636, 1636, 3278]], "test": "valid"}
{"id": "fsX3zN", "name": "bubbles enhanced ", "author": "davecaputo", "description": "Pulsating, moving bubbles", "tags": ["bubble"], "likes": 2, "viewed": 29, "published": "Public", "date": "1615561165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Bubble(vec2 origin, float r, float blur)\n{\n    float d = length(origin);\n    float c = smoothstep(r, r - blur, d);\n    return c;\n}\nfloat SuperBubble(vec2 origin, float r){\n    float c = Bubble(origin, r, .03);\n    c += Bubble(origin - vec2(r * .25), r * 0.7, .2);\n    return c;\n}\nvec2 orig(vec2 fragCoord, float x, float y){\n    vec2 o;\n    o.x = x;\n    o.y = y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Current origin\n    uv -= o;\n    // Not an ellipse anymore\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\nfloat SuperBubble2(vec2 fragCoord,float x, float y, float r){\n    return SuperBubble(orig(fragCoord,x,y), r);\n}\nconst int nbubbles = 3;\nfloat bubbles[nbubbles];\nstruct BubbleData{\n    float x0, y0, r0, p;\n    float vx,vy;\n};\nBubbleData newBubble(float x0, float y0, float r0, float p, float vx, float vy){\n    BubbleData b;\n    b.x0 = x0;\n    b.y0 = y0;\n    b.r0 = r0;\n    b.p = p;\n    b.vx = vx;\n    b.vy = vy;\n    return b;\n}\nfloat MovingBubble(vec2 fragCoord, BubbleData b){\n    return SuperBubble2(\n        fragCoord, \n        b.x0 + 0.1 * sin(b.vx * iTime), \n        b.y0 + 0.1 * cos(b.vy * iTime), \n        b.r0 + 0.1 * sin(iTime * b.p) * sin(iTime * b.p)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    BubbleData b1 = newBubble(0.5, 0.5, 0.2, 0.6, 0.5, 0.8);\n    BubbleData b2 = newBubble(0.2, 0.2, 0.2, 2., 0.5, 0.8);\n    BubbleData b3 = newBubble(0.75,0.6, 0.2, 0.6, 0.1, 0.8);\n    bubbles[0] = MovingBubble(fragCoord, b1);\n    bubbles[1] = MovingBubble(fragCoord, b2);\n    bubbles[2] = MovingBubble(fragCoord, b3);\n    float b = .0;\n    for(int i = 0; i < nbubbles; i++) b+= bubbles[i];\n    vec3 col = vec3(0.9 ,1, 9.) * b * 0.5;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsX3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 136], [137, 137, 177, 177, 285], [286, 286, 330, 330, 581], [582, 582, 643, 643, 693], [807, 807, 887, 887, 1009], [1010, 1010, 1059, 1059, 1252], [1253, 1253, 1310, 1310, 1779]], "test": "valid"}
{"id": "fsXGWs", "name": "something simple", "author": "sullly", "description": "first shader post", "tags": ["2d", "simple", "abstract", "idk"], "likes": 2, "viewed": 48, "published": "Public", "date": "1616698971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265358979\n#define time iTime\n\n\n//useful functions\nvec2 rotate(vec2 v, float a) { return mat2(cos(a), -sin(a), sin(a), cos(a))*v; }\nfloat remap(float v, float a, float b, float c, float d) { return (v - a) / (b - a) * (d - c) + c; }\nfloat divMod(float a, float m) { return remap(mod(a, m), 0.0, m, -1.0, 1.0); }\n\n\nvoid mainImage( out vec4 p, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n  uv.x = divMod(uv.x, 0.3);\n  uv.y = divMod(uv.y, 0.3);\n  \n  for (int i = 0; i < 8; ++i){\n    uv = abs(uv) - 0.09;\n    uv = rotate(uv, 0.5*time);\n    //uv = rotate(uv, abs(uv.y)- 0.2);\n    //uv = rotate(uv, abs(uv.x) + 0.1);\n  }\n  \n  p = vec4(sqrt(uv.x+uv.y),uv.x*uv.y, 0.1 / sqrt(uv.x+uv.y), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsXGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 69, 99, 99, 149], [150, 150, 208, 208, 250], [251, 251, 283, 283, 329], [332, 332, 381, 381, 736]], "test": "valid"}
{"id": "ldsXWH", "name": "solarDance [mod1]", "author": "entropynine", "description": "modified version from trisomie21", "tags": ["audio", "solar"], "likes": 4, "viewed": 151, "published": "Public API", "date": "1616627556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// modified only for learning fun\n\nfloat snoise(vec3 uv, float res)\t// code modded from trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.5*sin(iTime) ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5*sin(iTime), 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5*sin(iTime);\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4lXGzj", "previewfilepath": "https://soundcloud.com/callmemano/zeitgeist", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/callmemano/zeitgeist", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 112, 177, 177, 703], [722, 722, 779, 779, 3270]], "test": "error"}
{"id": "llsyDM", "name": "Multiverse2", "author": "patu", "description": "POC for last scene from https://www.youtube.com/watch?v=oITx9xMrAcM", "tags": ["demoscene", "spaghetti"], "likes": 7, "viewed": 202, "published": "Public API", "date": "1617153472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define getNormal getNormalCube\n\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 80.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nbool inball = false;\nfloat iter = 0.;\n\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat noiseShort(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 DE(vec3 p)\n{\n \tconst float scale = 1.45;\n\tconst float offset = 2.0;\n    const int FRACTALITERATIONS = 15;\n    vec3 modifier = vec3(-12.3 , -4.1, -4.1);\n\tp.y = -p.y;\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n        \n\t\tp.xy = (p.x + p.y <= 0.0) ? -p.yx : p.xy;\n\t\tp.xz = (p.x + p.z <= 0.0) ? -p.zx : p.xz;\n\t\tp.zy = (p.z + p.y <= 0.0) ? -p.yz : p.zy;\n\n\t\tp.y -= 4.1;\n        pR(p.xz, 0.82915);\n        \n        p.yz = -p.zy * vec2(1., -1.);\n        p.x -= 25.;\n        pR(p.zx, -.16915);\n\n\t\tp = scale*p-offset*(scale-1.0) * modifier;\n\t}\n \tvec3 obj;\n    obj.x = length(p) * pow(scale, -float(FRACTALITERATIONS)); \n\n    return obj;\n}\n\nvec3 map(vec3 p) {\n    \n    vec3 bp = p;\n   // p += 15.;\n    vec3 r = pMod3(p, vec3(100.));\n\tp += noiseShort(r) * 20.;\n    vec3 obj, obj2;\n    obj2.x = FAR;\n    obj.x = FAR;\n    obj.y = 2.;\n\n    if (inball) {\n        obj.x = min(obj.x, DE(p).x);\n        obj2.y = 3.;\n        obj = opU2(obj, obj2);\n    } else {\n        obj.x = min(obj.x, fSphere(p, noiseShort(p * .05 + t) * 2. + 30. * sin(length(r)))); \n\n    }\n\n    return obj;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 tr = vec3(.5, -1., 0.0);\n    for (int i = 0; i < 126; i++) {\n        vec3 d = map(ro + rd * tr.x);\n        tr.x += d.x * 0.4; // Using more accuracy, in the first pass.\n        tr.yz = d.yz;\n        if (abs(d.x) < 0.02 || tr.x > FAR) break;\n\t\titer += 1.;\n    }\n    return tr;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).x - map( pos - delta.xyy ).x;\n   n.y = map( pos + delta.yxy ).x - map( pos - delta.yxy ).x;\n   n.z = map( pos + delta.yyx ).x - map( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = 3.5;\n   float sunAmount = max(dot(rd, lightDir), 0.4);\n   float v = pow(1. - max(rd.y, 0.0), .1);\n   vec3 sky = mix(fromRGB(0,136,254), vec3(.1, .2, .3) * .1, v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n   \n   return clamp(sky / noiseShort(rd * 3.), 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n    \n    if (obj.material.x == 0.0) { \n        col = vec3(1., .6, .5);       \n    };\n    \n    if (obj.material.x == 1.0) { col = fromRGB(255,128,0); }\n    if (obj.material.x == 2.0) { \n        col = fromRGB(255,128,50);     \n    }\n    \n    if (obj.material.x == 4.0) { \n        col = vec3(1., .6, .5); \n    };\n    return col;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 7.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), 1.), 1.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .1);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    float t2 = t - 35.;\n    float \n        sk = sin(-t2 * .04) * 26.0, \n        ck = cos(-t2 * .07) * 32.0 - sk,\n        \n        mat = 0.;\n    \n    light = vec3(0., 17., 100.);        \n    lightDir = light;\n        \n    vec3 \n        vuv = vec3(sin(t / 10.), 1., sin(t / 10.)), // up\n    \tro = vec3(-2., ck, sk) + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 10.); // pos\n    ro -= 120.;\n    vec3\n        vrp =  vec3(sin(t / 30.) * 12., + sin(t * 2.) / 5., 10.) +\n        \tvec3(\n                -2., \n                0. + sin(t) / 3., \n                0. + sin(t / 3.) / 4.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n\n    vec3 tr = trace(ro, rd);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x);\n    hit = ro + rd * tr.x;\n    vec3 otr = tr;\n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, 15.2);\n\n    vec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    vec3 skyNoSun = Sky(rd, false, normalize(light)) * 1.;\n        \n    if (tr.x < FAR) { \n        sceneColor += 0.2;\n        inball = true;\n        vec3 bcol = vec3(0.);\n        if (tr.x > 0.) {\n            rd = refract(rd, sn, 1. - min(1., tr.x / 100.));\n            bcol = vec3(1., .9, 1.0) * pow(noiseShort(sn * 1.) * 1.3, 7.) * .3;\n            bcol += pow(max(0., dot(rd, normalize(light))), 13.);\n            tr = trace(hit, rd);\n        } else {\n            tr = trace(ro, rd);\n        }\n        \n        if (tr.x < FAR) {\n        \thit = hit + rd * (tr.x);\n            sceneColor += 9. / pow(tr.x, 1.1);\n            sceneColor = mix(sceneColor, sky, clamp(tr.x / 30., 0., 1.));\n        } else {\n            sceneColor += sky;\n        }\n        sceneColor += bcol;\n\n    } else {\n        sceneColor = sky;\n\n    }\n    sceneColor += pow(sin(float(iter) / 500.), 1.9) ;\n    sceneColor = mix(sceneColor, sky, clamp(otr.x / 400., 0., 1.));\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 309, 346, 346, 438], [440, 440, 466, 466, 716], [717, 717, 752, 752, 809], [958, 958, 990, 990, 1032], [1034, 1034, 1065, 1065, 1114], [1225, 1225, 1257, 1257, 1282], [1284, 1284, 1301, 1301, 1927], [1929, 1929, 1947, 1947, 2359], [2361, 2361, 2391, 2391, 2678], [2680, 2680, 2725, 2725, 3297], [3320, 3320, 3349, 3349, 3581], [3616, 3616, 3649, 3649, 3882], [3885, 3885, 3934, 3934, 4047], [4049, 4049, 4100, 4100, 4504], [4506, 4506, 4557, 4557, 4911], [4913, 4913, 4990, 4990, 5928], [5930, 5930, 5985, 5985, 8334]], "test": "valid"}
{"id": "Ms3XDf", "name": "Uzorilka", "author": "Bananaft", "description": " moire pattern generator based on Delphi app I wrote in high school ", "tags": ["moirepattern"], "likes": 4, "viewed": 65, "published": "Public", "date": "1615277789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fC )\n{\n\tfC -= iResolution.xy * 0.5;\n    float sc = pow(iTime*0.5,2.0);\n   \n    int n = int(fC.x*fC.y * sc);\n    \n    int r = (n * 256 * 256);\n\tint g = (n * 256 - r * 256) ;\n\tint b = (n  - r*256 -g*256*256) ;\n    \n\tfragColor = vec4(vec3(float(b)/256.0,float(g)/256.0,float(r)/256.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3XDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 333]], "test": "valid"}
{"id": "Nd23Rm", "name": "sdf octree", "author": "ch3coohlink", "description": "fork from https://www.shadertoy.com/view/4sVfWw", "tags": ["sdf", "octree"], "likes": 1, "viewed": 112, "published": "Public", "date": "1617156632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// octree subdivision level, higher for greater detail\n#define detail 7\n// sample count n*n, higher for better quality\n#define samples 1\n// max traversal step, the bigger the more accurate\n#define steps 300\n// if a traversal failed, the fragColor will be red\n#define maxdistance 1.\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define sqr(a) (a*a)\n#define pi 3.1415926535\n#define opacity 1.\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n    float d = min(max(-sdSphere(p, .218), sdBox(p, vec3(.15))), -sdSphere(p, .5));\n    //float d = -sdSphere(p, 1.);\n    return int(d < size*1.73205080757);\n}\n\n//ray-cube intersection, on the inside of the cube\nvec3 voxel(vec3 ro, vec3 rd, vec3 ird, float size) {\n    size *= 0.5; return -(sign(rd)*(ro-size)-size)*ird;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int i, j; vec3 sp; int spc = samples;\n\n    for (j = 0; j < spc*spc; j++) {\n    float d = 1./float(spc);\n    vec2 spv = vec2(float(j%spc)*d-0.5, float(j/spc)*d-0.5);\n    vec2 uv = ((fragCoord.xy+spv) * 2.0 - iResolution.xy) /iResolution.y;\n    float size=1.;\n    vec3 ro = vec3(0.4*sin(iTime), 0, 0.4*cos(iTime)), rd = normalize(vec3(uv,1.0));\n    //rd.yz *= rot(0.304085*pi-pi*0.5); rd.xz *= rot(0.375*pi*2.0-pi);\n    float x = mod(iMouse.x/iResolution.x+0.5,1.), y = mod(iMouse.y/iResolution.y+0.5,1.);\n    rd.yz *= rot(y*pi-pi*0.5); rd.xz *= rot(iTime-pi); rd.xz *= rot(x*pi*2.0-pi);\n    \n    vec3 lro = mod(ro,size), fro = ro-lro;\n    vec3 ird = 1.0/max(abs(rd),0.001), mask;\n    bool exit = false; int recursions = 0;\n    float dist = 0.0, fdist = 0.0; vec3 lastmask;\n    \n    for (i = 0; i < steps; i++) {\n        if (dist > maxdistance) { break; }\n        if (exit) {\n            vec3 newfro = floor(fro/(size*2.0))*(size*2.0);\n            lro += fro-newfro;\n            fro = newfro;\n            recursions--;\n            size *= 2.0;\n            exit = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n            continue;\n        } int v = getvoxel(fro, size);\n        if (v == 1 && recursions >= detail) { v = 2; }\n        if (v == 1) {\n            recursions++;\n            size *= 0.5;\n            //find which of the 8 voxels i will enter\n            vec3 mask2 = step(vec3(size),lro);\n            fro += mask2*size;\n            lro -= mask2*size;\n        } else if (v==2) { break; } else { //move forward\n            //raycast and find distance to nearest voxel surface in ray direction\n            //i don't need to use voxel() every time, but i do anyway\n            vec3 hit = voxel(lro, rd, ird, size);\n\n            if (hit.x < min(hit.y,hit.z)) { mask = vec3(1,0,0); }\n            else if (hit.y < hit.z) { mask = vec3(0,1,0); }\n            else { mask = vec3(0,0,1); }\n\n            //moving forward in ray direction, and checking if i need to go up a level\n            float len = dot(hit,mask);\n            dist += len;\n            fdist += len;\n            lro += rd*len-mask*sign(rd)*size;\n            vec3 newfro = fro+mask*sign(rd)*size;\n            exit = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n            fro = newfro; lastmask = mask;\n        }\n    }\n    if (dist > maxdistance) { sp += vec3(0,opacity,0); }\n    else if(i < steps) {\n        vec3 color = vec3(1);//sin(val*vec3(39.896,57.3225,48.25))*0.5+0.5;\n        vec3 normal = -lastmask*sign(rd);\n        //vec3 light = normalize(vec3(-1,0.1,0.1));\n        sp += sqrt(color*0.3 + normal*0.7)*opacity;\n        //sp += sqrt(color*0.3 + max(color*0.7*(dot(normal, light)), 0.0))*opacity;\n    } else { sp += vec3(1,0,0); }\n    } fragColor = vec4(sp/float(spc*spc),1);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 473, 492, 492, 562], [564, 564, 597, 597, 621], [624, 624, 655, 655, 751], [753, 796, 830, 830, 989], [991, 1042, 1094, 1094, 1152], [1154, 1154, 1206, 1206, 4031]], "test": "valid"}
{"id": "Nd23zR", "name": "mana!", "author": "DEMERCY", "description": "make some difference with voronoi pattern", "tags": ["2d", "voronoipattern"], "likes": 0, "viewed": 101, "published": "Public API", "date": "1616848669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p ){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+= dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n\n}\nfloat remap(float a1,float a2,float b1,float b2,float v){\n    return abs(a1-v/(a2-v))*b1+abs(a2-v/(a1-v))*b2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     uv *= 5.;\n    float m = 0.;\n    float t = iTime*2.;\n   \n    float minDist =3.;\n    vec3 col = vec3(0);\n    \n        \n    int stage = 5;\n    for(int i = stage;i>0;i--){\n        uv = uv*1.2+t*.2;\n        vec2 gv = fract(uv) -.5;\n        vec2 id = floor(uv);\n        vec3 c = vec3(0);\n    \n        for(int y = -1;y<= 1;y++){\n            for(int x = -1;x<= 1;x++){\n                vec2 offs = vec2(x,y);\n            \n                vec2 n =  N22(id + offs+float(i));\n                vec2 p = offs + sin(n*t)*.5;\n                float d = length(gv-p);\n    \n                if(minDist > d){\n                    minDist = d;\n                }\n            }\n        }\n        c= vec3(1.5*remap(0.,1.,0.7,0.,minDist),1.*remap(0.,1.,0.3,0.,minDist),1.4*minDist);\n        col = mix(col,c,.1);\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 140], [141, 141, 198, 198, 252], [254, 254, 311, 311, 1202]], "test": "valid"}
{"id": "NdBGRW", "name": "Adjustable Squircle", "author": "marcelliino", "description": "Squircle with adjustable size and radius", "tags": ["circle", "square", "squircle", "roundedrectangle"], "likes": 2, "viewed": 83, "published": "Public", "date": "1616986734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float squircle(vec2 uv, vec2 size, float radius){\n radius = 1.0/radius/min(size.x, size.y);\n float shape = length(pow(abs(uv/size), radius * size));\n return smoothstep(-1.0, 1.0, (shape-1.0)/min(1.0, fwidth(shape)));\n}\n\n#define blur 1.5/iResolution.y\n\nfloat roundedRect(vec2 uv, vec2 size, float radius){\nradius = radius*min(size.x, size.y);\nvec2 d = abs(uv)-(size-radius);\nfloat shape = length(max(d, vec2(0.0)))+min(max(d.x, d.y),  0.0);\nreturn smoothstep(radius-blur, radius+blur, shape);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.75);\n    \n    float t = iTime/1.25;\n    vec2 r = vec2(sin(t), cos(t))*0.5+0.5;;\n    vec2 s = vec2(0.75);\n    \n    col.r = squircle(uv, s, r.x);\n    col.r = max(col.r, 1.0-squircle(uv/0.99, s, r.x));\n    \n    col.g = roundedRect(uv, s, r.y);\n    col.g = max(col.g, 1.0-roundedRect(uv/0.99, s, r.y));\n    \n    fragColor = vec4(1.0-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 218], [252, 252, 304, 304, 493], [495, 495, 552, 552, 989]], "test": "valid"}
{"id": "NdBGzz", "name": "RayCastingProjet", "author": "Mehdix92i", "description": "Shader de base", "tags": ["lighting"], "likes": 1, "viewed": 31, "published": "Public", "date": "1616798359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float     FLT_MAX                   = 1.0 / 0.0;    \n\nconst int       MAX_NB_BOUNCES            = 5;\n\nconst int       NB_LIGHTS                 = 2;\n\nconst int       TIME_SAMPLING_SIZE        = 5;\nconst float     TIME_SAMPLING_OFFSET_TIME = 0.075;\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n\nstruct ShaderInfo\n{\n    vec3 shaderCol;\n    float Ks;\n};\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \n    //_________________________________________________________________________________\n        \n// Camera parameters\n      vec3\t   cameraPos    = vec3(6,  3.5, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0.3,0.4,1);\t\t\t\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t\nconst vec3     planeCol2    = vec3(0.1);\t\t\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,0);\t\t\nconst vec3     light1Col     = vec3(1,1,1);\t\t// white\n      vec3     light1Pos     = vec3(8, 10, -12);\nconst float    light1Pow    = 0.8;\nconst vec3     light2Col   = vec3(1,0.4,1);    //purple\n      vec3     light2Pos    = vec3(3, 10, 1);\nconst float    light2Pow    = 0.5; \n\nLightInfo lights[NB_LIGHTS];\n\n//##############################################################################################\n\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{   \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n   \n    intersecPt = rayPos + t * rayDir;\n    \n   \n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n\n    vec3 cy = normalize(cross( cz, cx));\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n \n //Antialiasing\n    //return smoothstep( pct-0.02, pct, v) - smoothstep( pct, pct+0.02, v);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t// Move the surface point a little outward\n    \t\t\t\t\t\t\t\t\t\t// (along its normal) to ensure it is a bit\n    \t\t\t\t\t\t\t\t\t\t// above the surface.\n\n\t\n    vec3  shadowRayDir   = L;\n    \n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n    \n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, int indL, vec3 L, vec3 R, vec3 V)\n{   \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lights[indL].col * lights[indL].power *   max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lights[indL].col * lights[indL].power *   pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    light1Pos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 RaycastAtPixelCoord(vec2 pixCoord)\n{\n    // Set the time used for the animation\n    float time = iTime;\n    float dtime = iTimeDelta;\n    \n    \n    // Animate scene objects\n    AnimateScene(time);\n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n\t// Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distI > 0.0)\n    {\n        // unit-vector going from the surface point toward the light and\n        // length of the segment between the two points\n\t    vec3 L = light1Pos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n\t\t// Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \treturn vec3(computePhongShading(objectCol, objectMat,\n                                             shadowFactor, normalI, 0/*light1*/,  L, R, V));\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n     \treturn vec3(skyCol);\n}\n\n\n\n//##############################################################################################\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;\n\n    vec3 resCol = RaycastAtPixelCoord(fragCoord);\n    \n    \n    fragColor = vec4(resCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1942, 2041, 2186, 2186, 2976], [2979, 3079, 3219, 3219, 3663], [3666, 3765, 3850, 3850, 4273], [4375, 4471, 4620, 4697, 5635], [5638, 5737, 5774, 5774, 5798], [5900, 5944, 5980, 5980, 6715], [6718, 6817, 6892, 6892, 7154], [7157, 7256, 7343, 7343, 7909], [7912, 8011, 8160, 8160, 8630], [8633, 8732, 8763, 8798, 9738], [9742, 9841, 9882, 9925, 11897], [11901, 12000, 12057, 12057, 12345]], "test": "error"}
{"id": "Ndf3WH", "name": "Box - interaction ", "author": "Bushra", "description": "Apply box-interaction technique to draw two boxes. Find out what happens when two box's intersect each other. ", "tags": ["boxinteraction"], "likes": 0, "viewed": 85, "published": "Public", "date": "1615839351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Ray-Box intersection, by convertig the ray to the local space of the box.\n//\n// Form http://iquilezles.org/www/articles/intersectors/intersectors.htm\n//\n// If this was used to raytace many equally oriented boxes (say you are traversing\n// a BVH), then the transformations in line 34 and 35 could be skipped, as well as\n// the normal computation in line 50. One over the ray direction is usually accessible\n// as well in raytracers, so the division would go away in real world applications.\n\n\n// Other intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n\n// Other Box functions (http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm)\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec2( tN, tF );\n}\n\n\n/*\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n*/\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy) / iResolution.y; // iResolution, viewport resolution (in pixels)\n\n    // camera movement\t\n\tfloat an = iTime;      \n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.80, 0.0 );                    //LookAt position\n\n    // camera matrix\n    vec3 ww = normalize(ta - ro );                       //calculate forward\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) ); //calculate right; right = forward cross y\n    vec3 vv = normalize( cross(uu,ww));                  //calculate up; up = forward cross right \n\n    float zoom = 1.80;      //zoom the camera\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + zoom*ww );\n\n    // rotate and translate box\t1: proxy geometry\n    float angle = 0.0;\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), angle );\n\tmat4 tra = translate( 0.0, 1.0 , 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n    \n\n    // rotate and translate box 2: clip geometry\n    float trans = 0.80 * iTime;\n    float angle_clip = 0.0;\n\tmat4 rot_clip = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), angle_clip );\n\tmat4 tra_clip = translate( 1. * cos(trans), 1.0 , 0.0 );\n    //mat4 tra_clip = translate( 0.50, 1.0 , 0.0 );\n\tmat4 txi_clip = tra_clip * rot_clip; \n\tmat4 txx_clip = inverse( txi_clip );\n    \n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t\n\t// raytrace box\n\tvec3 box_proxy = vec3(0.35,0.35,0.35) ;\n    vec3 box_clip = vec3(0.2,0.2,0.2) ;\n    \n    float occ = 1.0;\n    vec3  mate;\n\n\tvec2 res_proxy = iBox( ro, rd, txx, txi, box_proxy);          //function return near and far distance \n    vec2 res_clip = iBox( ro, rd, txx_clip, txi_clip, box_clip);  //function return near and far distance \n    \n    //claculating the intersection position of two boxes (clip and proxy geometry)\n    float t_start = max(res_proxy.x, res_clip.x);\n    float t_end = min(res_proxy.x, res_clip.x);        \n    \n    vec3 col;\n    \n    \n    if( res_proxy.x>0.0 && res_proxy.x<tmin && res_clip.x>0.0 && res_clip.x<tmin)\n    {\n        \n        //here ray is starting from the proxy near point and exit in clip far point\n        // if  proxy near distance is less than clip far distance\n        if(res_proxy.x < res_clip.y)\n        {           \n            tmin = res_proxy.x; \n            mate = vec3(1.0,1.0,0.0); //yellow, intersection position            \n         }  \n             \n        \n        /*\n        else if (res_clip.x < res_clip.y)\n        {\n            tmin = res_clip.x; \n            mate = vec3(1.0,1.0,0.0); //yellow, intersection position\n        } */\n    } \n    \n    //clip\n    if( res_clip.x>0.0 && res_clip.x<tmin  )\n    {\n        tmin = res_clip.x; \n        //nor = res_2.yzw;\n\t\t\n        // material\n        mate = vec3(0.0,1.0,0.0); //green, clip geometry\n     }\n        \n     //proxy\n     if( res_proxy.x>0.0 && res_proxy.x<tmin)\n     {\n        tmin = res_proxy.x; \n        //nor = res.yzw;\n\n        // material\n        mate = vec3(1.0,0.0,0.0); //red, proxy geometry  \n     }\n     \n       \n    col = vec3(1.0); //background color    \t\n       \n   \n    if( tmin<100.0 )\n    {      \n       col = mate;\n    }\n    \n    //discard non-interaction part of two boxes(clip and proxy geometry)\n    /*\n    if (t_end <t_start)\n    {\n      //discard;\n      \n    }    \n    */\n        \n    \n\t//col = sqrt( col ); \n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndf3WH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1878, 1946, 2023, 2060, 2577], [3051, 3144, 3191, 3191, 3595], [3597, 3597, 3642, 3642, 3758], [3761, 3761, 3818, 3818, 7238]], "test": "error"}
{"id": "Ndf3zM", "name": "x^y - y^x", "author": "sig", "description": "Formula visualization; coordinates transformed such that 0..1 -> 0..1  and  1..inf -> 1..2", "tags": ["math"], "likes": 1, "viewed": 159, "published": "Public API", "date": "1615653143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(float x) {\n    return step(1., x) / abs(2. - x) + (1. - step(1., x)) * x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = f(uv.x * 4.);\n    float y = f(uv.y * 4.);\n    \n    float z = pow(x, y) - pow(y, x);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + z*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndf3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 83], [85, 85, 142, 192, 475]], "test": "valid"}
{"id": "NdfGDl", "name": "Trigochiselled shaft descent", "author": "evvvvil", "description": "Trigochiselled shaft descent - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["texture", "lines", "demoscene", "light", "fog", "tower", "plane", "organic", "scifi", "boolean", "point", "cut", "architecture", "vertical", "inside", "descent", "techy"], "likes": 26, "viewed": 540, "published": "Public", "date": "1616696759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trigochiselled shaft descent - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"You've always been the same, even at school. Nothing but books, learning, education...\n// - that's why you're no good at snooker.\" - Del Boy\n\nvec2 z,v,vv,e=vec2(.00035,-.00035);float tt,b,bb,g=0.,gg=0.,tnoi,res=1.;vec3 bp,pp,rd,fo,lp,po,op,no,al,ld,vcp;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nfloat smax(float a,float b,float k){float h=max(k-abs(-a-b),0.);return max(-a,b)+h*h*.25/k;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p )\n{\n  op=p;p.y=mod(p.y-tt*2.,20.)-10.;  \n  vec2 h,t=vec2(bo(p,vec3(3,20,3)),6); //white box\n  vec3 cp=p+vec3(0.,0.0,.3);  \n  t.x=max(t.x,-(length(cp.xz)-3.0)); //inner white cylinder\n  h=vec2(bo(p,vec3(3.05,20,3.05)),3); //black box  \n  h.x=max(h.x,-(length(cp.xz)-3.0));\n  t.x=abs(abs(t.x)-.5)-.2; //onion \n  h.x=abs(abs(h.x)-.5)-.3;\n  vcp=p; //cut position\n  vcp.y=abs(abs(abs(p.y)-10.)-4.)-2.;  //first horizontal cut  \n  t.x=max(t.x,min(vcp.y,p.z+1.2)); \n  h.x=max(h.x,min(vcp.y+.2,p.z+1.4)); \n  vcp.yz*=r2(0.785);\n  t.x=max(t.x,-(abs(abs(vcp.y+1.)-.4)-.1)); \n  t.x=max(t.x,vcp.y-1.5);  \n  h.x=max(h.x,-(abs(abs(vcp.y+1.)-.4)-.3)); \n  h.x=max(h.x,vcp.y-1.3); \n  bp=op+vec3(0.,bb,.3);  \n  float glo=length(abs(bp)-vec3(0,2.,0.))-.5;   //platform\n  t.x=min(t.x,max(length(abs(bp.xz)-.75)-.1,abs(bp.y)-1.));  \n  float glo2=max(abs(length(bp.xz)-1.)-.5,abs(abs(bp.y)-1.5)-.2);\n  glo=min(glo,glo2);\n  g+=0.1/(0.1+glo*glo*40.);\n  t.x=min(t.x,glo);  \n  t=t.x<h.x?t:h;   \n  h=vec2(length(abs(p.xz)-3.)-0.15,7);  //shaft edge cylinders\n  h.x=min(h.x,max(abs(length(bp.xz)-1.)-.4,abs(abs(bp.y)-1.5)-.5));  \n  t=t.x<h.x?t:h;    \n  vec3 mop=op+vec3(0,-tt*2.,0);\n  tnoi=texNoise(mop.xy*.06,iChannel0).r*1.2;\n  vec3 tp=op-vec3(0,0,12);  \n  b=sin(op.y-tt*2.)+sin(op.x*.5);  \n  h=vec2(abs(length(tp.xz)-22.+tnoi+b)-.2,5);  //main tunnel cylinder    \n  h.x=max(abs(h.x)-2.,abs(p.y)-100.);    \n  vec3 prp=vec3(atan(tp.x,tp.z)*3.142*5.,op.y-tt*2.,length(tp.xz)-19.5+b); //projected position\n  prp.xy=mod(prp.xy,5.)-2.5;\n  h.x=smin(h.x,length(prp.yz)-1.-sin(mop.x)*.3+tnoi,1.2) ;\n  h.x=smin(h.x,length(abs(prp.yz)-vec2(1.,0))-.1-sin(prp.x*10.0)*.1-tnoi,.5) ;  \n  float tun=h.x+1.;\n  h.x=smax((abs(prp.y)-.1),h.x,.5);\n  pp=op+vec3(0,0,-13);pp.xz=abs(pp.xz)-15.+b;\n  h.x=smin(h.x,length(pp.xz)-2.0-sin(mop.y*.5),3.); //edges bits    \n  tun=abs(tun)-.2; \n  tun=max(tun,abs(p.y)-100.);\n  g+=0.1/(0.1+tun*tun*4.);\n  h.x=min(h.x,tun);h.x*=0.6;\n  t=t.x<h.x?t:h;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>65.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>65.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvec3 lit(float da,float atn){    \n    ld=normalize(lp-po);\n    float dif=da*max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,ld),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.),\n    attn=1.-pow(min(1.,length(lp-po)/atn),4.0); \n    return attn*mix(sp+al*(a(.1)+.2)*(dif+s(.5)),fo,min(fr,.5)); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vv,uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vv=uv;uv-=0.5;vv*=1.-vv;uv/=vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.83)+23.6;\n  bb=-40.+smoothstep(0.,1.,smoothstep(0.,1.,sin(tt*.2)*.5+.5))*80.;\n  b=ceil(cos(tt*.2));\n  vec3 ro=mix(vec3(-9.,00,6.+sin(tt*.2)*4.),vec3(sin(tt*.2)*12.,-bb-sin(bb*.05)*10.,5.0),b),\n  cw=normalize(vec3(0.,mix(-bb*.2,-bb,b),1)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),co;\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.55));\n  co=fo=vec3(.1);\n  z=tr(ro,rd);\n  if(z.y>0.){\n    po=ro+rd*z.x;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);    \n    al=mix(vec3(.5,.4,.3),vec3(.2,.2,.2),tnoi*5.0);\n    if(z.y<5.) {\n      v=vcp.yz; \n      for(int i=0;i<4;i++){\n        v=abs(v)-.3;\n        v*=r2(-.785); v*=1.22;\n        float per=abs(sin(v.x))-.1+clamp(sin(v.y*2.),-.1,.1)*.5;\n        res=min(res,ceil(per));\n        g+=.25/(0.1+(per*per)*(20.-18.9*sin(uv.y*1.5+tt*2.)));  \n      }\n      al=vec3(1.-res);\n    }\n    if(z.y>5.) al=vec3(0.4,.5,.7);\n    if(z.y>6.) al=vec3(0.);\n    lp=vec3(0,-bb,0);    \n    co=lit(3.,10.);    \n    lp=ro;\n    co+=.75*lit(2.,15.);      \n    co=mix(fo,co,exp(-.00003*z.x*z.x*z.x));    \n  }  \n  co=mix(co+g*.2*vec3(.1,.2,.7),fo,min(1.,length(ro.y-op.y)*.02));      \n  fragColor = vec4(pow(co*pow(vv.x*vv.y*15.0,0.25),vec3(.65)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 458, 482, 482, 523], [524, 524, 541, 541, 584], [585, 585, 621, 621, 675], [676, 676, 712, 712, 768], [769, 769, 807, 807, 1003], [1004, 1004, 1023, 1023, 2972], [2973, 2973, 3000, 3000, 3163], [3253, 3253, 3282, 3282, 3545], [3546, 3546, 3603, 3603, 5010]], "test": "error"}
{"id": "NdfGDr", "name": "Raiden Fireball", "author": "rvanbronkhorst", "description": "raymarching", "tags": ["raymarching"], "likes": 5, "viewed": 172, "published": "Public", "date": "1615753602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float maxSteps = 100.;\nconst int iMaxSteps = 100;\nconst float hitThreshold = .002;\nconst float maxDistance = 20.;\nconst float specExp = 40.;\nconst float AA = 2.;\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\n\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p - s.center) - s.radius, s.color);\n}\n\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\n\n// Signed distance functions for different shapes\n\nHit mandelbulbSDF(vec3 p)\n{\n    float power = 3.;\n    vec3 z = p.zyx;\n    float dr = 1.;\n    float r;\n    vec3 c1 = vec3(0.65, 0.65, .8);\n    vec3 c2 = vec3(.6, 0.2, 0.) * 0.01;\n    \n    for (int i = 0; i < 15; i++)\n    {\n        r = length(z);\n        if (r > 2.)\n        {\n            break;\n        }\n        float theta = acos(z.z / r) * power + iTime;\n        float phi = atan(z.y/z.x) * power + iTime;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n        c2 += c2;\n    }\n    return Hit(0.5 * log(r) * r / dr, c1 + c2);\n}\n\n// Smooth min to cause shapes to morph into eachother\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Define the objects in the scene and their relations to eachother\nHit map(vec3 p)\n{\n    return mandelbulbSDF(p);\n}\n\n// Calculate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec3 eps = vec3(0.001, 0., 0.);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n        i += 1;\n        if (i > iMaxSteps) \n        {\n            break;\n        }\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 1;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(0., 6., 5.), 20., vec3(1., 1., 1.), 8.)\n        // Light(vec3(0., -5., 5.), 2., vec3(1., .5, .1), 8.)\n        // Light(vec3(5., 0., 5.), 6., vec3(0., 1., 0.), 1.)\n    );\n    vec3 ambient = vec3(1.00,1.,1.0) * 0.09;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness);\n        \n        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glow = vec3(1., .0, -.5) * .1;\n    float t = 0.;\n    float i = 0.;\n    while (i < maxSteps)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color + glow * i/maxSteps;\n        }\n        \n        if (t > maxDistance)\n        {\n            break;\n        }\n        t += closestHit.t;\n        i += 1.;\n    }\n    return vec3(0.01, 0.02, 0.03);// + glow * smoothstep(0., 1.5, i/maxSteps);\n}\n\nvec4 render(in vec3 e, in mat4 view, in vec2 uv) {\n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    return vec4(raymarch(viewRay), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    vec3 e = vec3(0., 0., 2.5);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n\n    // Convert pixel coordinates to uv coordinates\n    if (AA > 1.) {\n      vec4 average = vec4(0.0);\n      for (float s = 0.; s < AA; s++) {\n        for (float t = 0.; t < AA; t++) {\n            vec2 offset = (vec2(s, t) / AA) - 0.5;\n\n            vec2 uv = (fragCoord + offset)/iResolution.xy * 2. - 1.;\n            uv.y *= iResolution.y/iResolution.x;\n\n            average += render(e, view, uv);\n        }\n      }  \n      average /= AA*AA;\n      fragColor = average;\n    } else {\n      vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n      uv.y *= iResolution.y/iResolution.x;\n\n      fragColor = render(e, view, uv);\n    }\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 460, 460, 520], [522, 522, 555, 555, 594], [596, 647, 674, 674, 1310], [1312, 1366, 1407, 1407, 1500], [1502, 1570, 1587, 1587, 1618], [1620, 1670, 1695, 1695, 1981], [1983, 2021, 2069, 2069, 2597], [2599, 2655, 2695, 2695, 3601], [3603, 3635, 3659, 3659, 4310], [4312, 4312, 4362, 4414, 4546], [4548, 4548, 4605, 4626, 5611]], "test": "error"}
{"id": "NdfGRn", "name": "Hex Thing", "author": "Tater", "description": "The colors worked much better than expected.", "tags": ["2d", "hexagons"], "likes": 7, "viewed": 230, "published": "Public API", "date": "1615357172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Hex Tiling From \"The Art of Code\" tutorial\n//Colors, movement, and flickering stuff is original\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return((t-a) / (b-a))* (d-c) + c;\n}\nfloat HexDist(vec2 p) {\n    p = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c,p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv) \n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;  \n    vec2 gv = dot(a,a)<dot(b,b) ? a : b;\n    float x = atan(gv.x,gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(gv.x, y, id.x, id.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    t*=1.0;//Speed Adjustment\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n    \n    uv+=t/50.;\n    uv *= 8.5;\n    \n    vec4 hc = HexCoords(uv);\n    float vary =remap(-.95,-.75,0.,1.,sin(t*3.+hc.z+hc.w))/2.;\n    float c2=1.-smoothstep(.0+vary,vary,abs(hc.x));  \n    c2*=smoothstep(.03, .04, hc.y*sin((hc.z+hc.w)+t/1.2));\n    col+=c2;\n        \n    float r = remap(-1.,1.,0.,1.,sin(hc.z));\n    float g = remap(-1.,1.,0.,1.,sin(hc.w));\n    float b = remap(-1.,1.,0.,1.,sin(hc.w+hc.z)+remap(-1.,1.,-.25,.5,sin(t/2.)));\n    \n    col.rgb*=vec3(r,g,b)/2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 156, 156, 196], [197, 197, 220, 220, 319], [321, 321, 347, 347, 619], [620, 620, 677, 677, 1323]], "test": "valid"}
{"id": "NdfGWX", "name": "pixelate with less colors", "author": "Leuchtstift", "description": "trying to emulate color schemes", "tags": ["retro", "pixel"], "likes": 2, "viewed": 88, "published": "Public", "date": "1616607590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat staircase(float x, float w, float h){\n\treturn h * (x / w + 0.5 - (atan(tan(PI * (x / w + 0.5))) / PI)) - w;\n}\n\nvec3 scolor(vec3 c, float n){\n\treturn vec3(\n\t\tstaircase(c.x, n, n),\n\t\tstaircase(c.y, n, n),\n\t\tstaircase(c.z, n, n)\n\t\t);\n}\n\n// from https://www.shadertoy.com/view/4t3czs\nvec3 HSVToSRGB(float h, float s, float v) {\n    return vec3(v * (1. - s + s * clamp(abs(fract(h + 1.0)   * 6. - 3.) - 1., 0., 1.)),\n                v * (1. - s + s * clamp(abs(fract(h + 2./3.) * 6. - 3.) - 1., 0., 1.)),\n                v * (1. - s + s * clamp(abs(fract(h + 1./3.) * 6. - 3.) - 1., 0., 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // pixalate uv\n    float r = (sin(iTime * 0.1) + 1.0 ) * 8.0;\n    //float r = 8.0;\n    vec2 uv = floor(fragCoord/r)*r/iResolution.xy;\n    \n    float s = (sin(iTime * 0.1) + 1.0) * 0.2;\n    //float s = 0.4;\n    \n    // from https://www.shadertoy.com/view/4t3czs\n    vec3 C = (uv.x < 0.5) ?\n         ((uv.y < 0.5) ?\n           HSVToSRGB(uv.x * 2.0, 1.0, uv.y * 2.0) :\n           HSVToSRGB(uv.x * 2.0, 2.0 - uv.y * 2.0, 1.0)) :\n    \t ((uv.y < 0.5) ?\n            texture(iChannel0, vec2(uv.x * 2.0 - 1.0, uv.y * 2.0)).rgb :\n            texture(iChannel1, uv *2.0 -1.0).rgb);\n            \n    fragColor = vec4(scolor(C, s), 1.0);\n\t//fragColor = vec4(scolor(texture(iChannel0, floor(fragCoord/r)*r/iResolution.xy).rgb, s), 1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 89, 89, 161], [163, 163, 192, 192, 284], [286, 332, 375, 375, 642], [644, 644, 701, 720, 1430]], "test": "error"}
{"id": "NdfGzM", "name": "3rd improvement", "author": "jemappelle", "description": "3rd iteration of a shader I have been making in between writing a JavaScript project to make use of it", "tags": ["messy"], "likes": 2, "viewed": 198, "published": "Public API", "date": "1615647835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\n//--Operators\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\n//--Shapes (SDFs)\nfloat sphere(vec3 d, float r){ \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.2) - r;\n}\n\n//Return objects/shapes in environment\nfloat map(vec3 d){\n  \td = mod(d, 3.)-3.*0.5;\n    return mix(sdRoundedX(d.xy, 0.3, 0.12), sphere(d, 0.4), cos(iTime*0.2*0.8));\n}\n\n//--Shading\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.6 + .4;\n}\n\n//Measure normals for shading\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.001,2.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    //Re-define fftVariables\n    float fftDivider = 2.;\n    float low = lowFreqFFT/fftDivider;\n    float mid = midFreqFFT/fftDivider;\n    float high = highFreqFFT/fftDivider;\n\n\t//Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.4;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    \n    //Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.x, 1.,length(uv.x));\n  \n    //--Camera Positioning\n    //ro = Ray origin | p = Ray Origin Position\n    //rd = Ray distance\n  \tvec3 ro = vec3(0.+sin(iTime)/2., -zMotion, -8.+(iTime*4.));\n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv, 0.8));\n  \n    //hit = If the sphere trace hits an SDF, defined in 'map'\n  \tbool hit = false;\n  \tfloat shading = 0.;\n  \n    //dtm = Distance to march\n    //env = Environment / Distance field\n    float dtm = 75.;\n  \tfor(float i = 0.; i < dtm; i++){\n    \tfloat env = map(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/-dtm*low;\n      \t\tbreak;\n    \t}\n        //Step the ray origin position (sphere trace) forward by the environment\n        //with a multiplier to create some interesting effect\n    \tp += env * sin(rd-ro/dtm);\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*1.5)*0.4;\n  \tuv.y += sin(uv.x+iTime)*0.1;\n    \n    //--The following is more experimental code\n  \tfloat verLine = tan(smoothstep(0.06, 0.9,length(uv.y/(circle*(midFreqFFT*4.0)))));\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n    \n    \n    vec3 fogcolour = vec3(0.4,0.4,2.);\n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        color = mix(vec3(0.1,0.0,0.2), vec3(0.1, low,0.0), vec3(diffuse_directional(n,l)));\n        hit = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading) + vec3(circle + verLine)*0.9;\n        //color = vec3(circle - shading)+0.9;\n    \t//color = vec3(circle *= sin(verLine/1.)*iTime);\n  \t}\n  \tfloat t = length(ro-p)-5.0*mid; //lowFreqFFT/140.0;\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.2,0.2, high), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.2) - vec4((color * circle / 1.5), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 117, 154, 154, 174], [175, 175, 216, 216, 235], [237, 255, 285, 285, 311], [313, 313, 366, 366, 429], [431, 470, 488, 488, 597], [599, 611, 653, 653, 695], [697, 727, 751, 751, 919], [921, 921, 978, 1014, 3283]], "test": "error"}
{"id": "Ndl3Ds", "name": "Flying Bathtubs", "author": "dr2", "description": "Ornithopter squadron", "tags": ["flight", "kinematics", "replicate", "absurd"], "likes": 19, "viewed": 321, "published": "Public API", "date": "1616756973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Flying Bathtubs\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Length4 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 wngLink;\nvec3 sunDir, qHit, flDisp;\nvec2 cId, wngCs;\nfloat tCur, dstFar, bGrid, grLim, wngH, wngAh, whlRad, whlRot, hVel, prpRot;\nint idObj;\nconst int idBod = 1, idProp = 2, idWingF = 3, idWingC = 4, idLnk = 5, idEng = 6, idNos = 7,\n   idWhl = 8, idSpok = 9, idSeat = 10;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat BodDf (vec3 p)\n{\n  return PrRound4BoxDf (p, vec3 (max (vec2 (0.15, 0.4) - vec2 (0.03, 0.1) * p.z * p.z, 0.), 1.6), 0.3);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, dr, dw, dx;\n  dMin = dstFar;\n  p -= flDisp;\n  p.xz = Rot2D (p.xz, 0.25 * pi);\n  q = p;\n  q.z -= -0.2;\n  db = BodDf (q);\n  d = SmoothMax (min (abs (db) - 0.03, max (q.y + 0.45, db)), q.y - 0.3, 0.02);\n  d = max (d, 0.07 - length (vec2 (q.y + 0.65, abs (q.z) - 0.8)));\n  d = 0.9 * min (d, PrRoundBoxDf (vec3 (abs (q.x) - 0.45, q.y + 0.65, abs (q.z) - 0.8), vec3 (0.01, 0.1, 0.02), 0.02));\n  DMINQ (idBod);\n  q = p;\n  q.z = abs (q.z + 0.2) - 1.;\n  q.y -= 0.1;\n  d = max (PrRoundBox2Df (q.yz, vec2 (0.01, 0.1), 0.02), db);\n  DMINQ (idSeat);\n  q = p;\n  q.z -= -0.2;\n  d = min (max (PrCylDf (q, 0.32, 0.08), 0.05 - length (q.xz - vec2 (0., 0.08))),\n     PrCylDf (q - vec3 (0., 0., -0.35), 0.25, 0.3));\n  DMINQ (idEng);\n  q = p;\n  q.y -= 0.6;\n  d = PrCapsDf (q.xzy, 0.05, 1.1);\n  DMINQ (idEng);\n  q = p;\n  q.x = abs (q.x) - wngLink.x;\n  dx = 0.03 - q.x;\n  q.z -= -0.02;\n  d = PrCapsDf (q, 0.06, 0.42);\n  q.xy = Rot2Cs (q.xy, wngCs * vec2 (1., -1.));\n  d = min (d, PrCylDf (q - vec3 (wngLink.y, 0., -0.15), 0.02, 0.55));\n  DMINQ (idWingF);\n  dr = length (q.xz) - 2.8;\n  q.xz = Rot2D (q.xz, 0.06 * pi);\n  dw = dot (vec2 (abs (q.z) + 0.2, q.x), sin (-0.06 * pi + vec2 (0.5 * pi, 0.)));\n  d = max (max (abs (q.y) - 0.01, abs (dw) - 0.6), max (dr, dx));\n  DMINQ (idWingC);\n  d = max (length (vec2 (dr, q.y)) - 0.02, abs (dw) - 0.6);\n  q.xz = Rot2D (vec2 (q.x, abs (q.z) - 0.26), -0.04 * pi);\n  dw = dot (vec2 (abs (q.z) - 0.135, q.x), sin (-0.02 * pi + vec2 (0.5 * pi, 0.)));\n  d = min (d, max (length (vec2 (q.y, dw)) -0.02, max (dr - 0.01, dx)));\n  DMINQ (idWingF)\n  q = p;\n  q.x = abs (q.x) - wngLink.x;\n  q.xy -= wngLink.y * wngCs;\n  d = PrCylDf (q, 0.06, 0.04);\n  DMINQ (idLnk);\n  q.xy = Rot2D (q.xy, wngAh);\n  q.x -= 0.5 * wngLink.w;\n  d = PrCylDf (q.yzx, 0.02, 0.5 * wngLink.w);\n  DMINQ (idLnk);\n  q = p;\n  q.y -= wngH - 0.6;\n  d = PrCylDf (q.xzy, wngLink.z - 0.01, 0.7);\n  DMINQ (idLnk);\n  q.yz -= vec2 (-0.7, -0.1);\n  d = PrCylDf (q, 0.03, 0.1);\n  DMINQ (idLnk);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (wngLink.z, wngH);\n  d = PrCylDf (q, 0.05, 0.04);\n  DMINQ (idLnk);\n  q = p;\n  q.z -= -1.3;\n  d = PrCylDf (q, 0.03, 1.);\n  DMINQ (idProp);\n  q.z -= -1.;\n  d = PrCapsDf (q, 0.1, 0.03);\n  DMINQ (idProp);\n  q.xy = Rot2D (q.xy, prpRot);\n  q.yz = Rot2D (q.yz, 0.35 * pi * sign (q.x));\n  q.x = abs (q.x) - 0.48;\n  d = PrRoundBoxDf (q, vec3 (0.38, 0.002, 0.07 * (1. + q.x)), 0.01);\n  DMINQ (idProp);\n  q = p;\n  q.z -= 1.7;\n  d = max (PrCapsDf (q, 0.15, 0.15), - db);\n  DMINQ (idNos);\n  q = p;\n  q.y -= -0.7 + max (1.1 - flDisp.y, 0.);\n  q.z = abs (q.z + 0.2) - 0.8;\n  d = PrCylDf (q.yzx, 0.03, 0.65);\n  q.x = abs (q.x) - 0.6;\n  q.yz = Rot2D (q.yz, whlRot * sign (p.z));\n  d = min (d, max (abs (length (q.yz) - whlRad + 0.02) - 0.02, abs (q.x) - 0.04));\n  DMINQ (idWhl);\n  q.yz = Rot2D (q.yz, 2. * pi * floor (8. * (atan (q.z, - q.y) / (2. * pi) + 0.5) + 0.5) / 8.);\n  q.y -= 0.19;\n  d = PrCylDf (q.xzy, 0.02, 0.19);\n  DMINQ (idSpok);\n  return dMin;\n}\n\nvoid ObjState ()\n{\n  vec2 h;\n  float wngAng, tc, t, tt;\n  tc = tCur + 0.7 * (cId.x + cId.y);\n  t = cos (2. * pi * mod (0.6 * tc, 1.));\n  wngAng = 0.12 * pi * (1. + 0.7 * t);\n  wngCs = sin (wngAng + vec2 (0.5 * pi, 0.));\n  wngH = wngLink.y * wngCs.x + wngLink.x - wngLink.z;\n  wngH = sqrt (max (0., wngLink.w * wngLink.w - wngH * wngH));\n  wngAh = pi + asin (wngH / wngLink.w);\n  wngH += wngLink.y * wngCs.y;\n  tt = (mod (0.3 * tc, 6.) - 2.) / 4.;\n  h = Hashv2v2 (17.1 * cId + 0.1) - 0.5;\n  flDisp.xz = bGrid * (cId + 0.5 + 0.2 * h);\n  flDisp.y = 1. + ((tt > 0.) ? 0.2 * (1. - t) + (7. + dot (h, vec2 (0.5))) *\n     SmoothBump (0.2, 0.8, 0.2, tt) : 0.);\n  prpRot = -2. * pi * tc;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = (Maxv2 (abs (cId)) <= grLim) ? ObjDf (p) : dstFar;\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (Minv2 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    if (Maxv2 (abs (cId)) <= grLim) {\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.3 * bGrid;\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else if (rd.y < 0.) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, q;\n  float dstObj, dstGrnd, sh, t;\n  bool isBg;\n  wngLink = vec4 (0.5, 0.8, 0.08, 1.5);\n  hVel = 1.;\n  whlRad = 0.4;\n  whlRot = - (hVel / whlRad) * tCur;\n  dstGrnd = dstFar;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idBod) {\n      t = BodDf (qHit);\n      if (qHit.y < 0.25) col4 = vec4 (1., 1., 0.8, 0.2) * (0.85 + 0.15 * smoothstep (0., 0.02, abs (mod (4. *\n         ((t > 0.) ? 2. * qHit.y : ((abs (qHit.z) < 1.8) ? qHit.z : 2. * qHit.x)) + 0.5, 1.) - 0.5) - 0.05));\n      else col4 = mix (vec4 (0.8, 0.7, 0., 0.2), vec4 (0.5, 0.2, 0., 0.1), smoothstep (0.01, 0.02, abs (t)));\n      if (t > 0. && PrRoundBox2Df (qHit.zy - vec2 (1.3, -0.01), vec2 (0.3, 0.15), 0.01) < 0.) col4.rgb =\n         mix (col4.rgb, vec3 (1., 0.2, 0.2), ShowIntPZ ((qHit.zy - vec2 (1.3 + 0.25 * sign (qHit.x), -0.13)),\n         vec2 (0.5 * sign (qHit.x), 0.25), 3., 1. + grLim - cId.x + (2. * grLim + 1.) * (grLim - cId.y)));\n    } else if (idObj == idProp) col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.8, 0.9, 0.8, 0.2), \n       smoothstep (0., 0.02, abs (qHit.x - 0.27) - 0.05));\n    else if (idObj == idWingF) col4 = vec4 (0.8, 0.5, 0.1, 0.2);\n    else if (idObj == idWingC) col4 = vec4 (0.9, 0.9, 0.8, 0.2) * (0.93 + 0.07 * smoothstep (0., 0.02,\n       abs (abs (length (qHit.xz) - 1.9) - 0.3) - 0.01));\n    else if (idObj == idLnk) col4 = vec4 (0.8, 0.6, 0.3, 0.2);\n    else if (idObj == idEng) col4 = vec4 (0.8, 0.85, 0.8, 0.2);\n    else if (idObj == idNos) col4 = vec4 (1., 0.3, 0., 0.2);\n    else if (idObj == idWhl) col4 = vec4 (0.7, 0.6, 0.6, 0.05);\n    else if (idObj == idSpok) col4 = vec4 (0.5, 0.6, 0.7, 0.1);\n    else if (idObj == idSeat) col4 = vec4 (0.5, 0.2, 0., 0.1) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       mod (16. * qHit.z, 1.) - 0.2));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    cId = floor (ro.xz / bGrid);\n    q = ro;\n    q.xz += (hVel / sqrt(2.)) * tCur;\n    col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.), smoothstep (0.2, 0.8, Fbm2 (4. * q.xz)));\n    col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.3, 0.6, dstGrnd / dstFar));\n    vn = VaryNf (4. * q, vec3 (0., 1., 0.), 2. * (1. - smoothstep (0.1, 0.3, dstGrnd / dstFar)));\n  } else {\n    col = SkyBgCol (ro, rd);\n    isBg = true;\n  }\n  if (! isBg) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       step (0.95, sh) * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (dstObj >= dstFar) col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bGrid = 8.;\n  grLim = 3.;\n  az = pi;\n  el = -0.04 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 7., -4. - 1.4 * (grLim + 1.) * bGrid * (0.9 - 0.1 * cos (4. * az)));\n  ro.xz = Rot2D (ro.xz, - az) + 0.5 * bGrid;\n  zmFac = 3.;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (0., 1., 1.));\n  sunDir.xz = Rot2D (sunDir.xz, -0.01 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  return Length4 (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Length4 (vec3 p)\n{\n  return sqrt (length (p * p));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3Ds.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1195, 1217, 1217, 1323], [1325, 1325, 1347, 1347, 4324], [4326, 4326, 4344, 4344, 5006], [5008, 5008, 5041, 5041, 5677], [5679, 5679, 5700, 5700, 5955], [5957, 5957, 5994, 5994, 6481], [6483, 6483, 6517, 6517, 7343], [7345, 7345, 7380, 7380, 10171], [10215, 10215, 10271, 10271, 11483], [11485, 11485, 11531, 11531, 11578], [11580, 11580, 11627, 11627, 11674], [11676, 11676, 11723, 11723, 11771], [11773, 11773, 11815, 11815, 11866], [11868, 11868, 11911, 11911, 11975], [11977, 11977, 12001, 12001, 12035], [12037, 12037, 12059, 12059, 12086], [12088, 12088, 12110, 12110, 12137], [12139, 12139, 12184, 12184, 12287], [12289, 12289, 12334, 12334, 12372], [12374, 12374, 12431, 12431, 12514], [12516, 12516, 12552, 12552, 12758], [12760, 12760, 12790, 12790, 12903], [12905, 12905, 12936, 12936, 13000], [13002, 13002, 13025, 13025, 13129], [13202, 13202, 13234, 13234, 13782], [13784, 13784, 13846, 13846, 14213], [14247, 14247, 14271, 14271, 14324], [14326, 14326, 14350, 14350, 14480], [14482, 14482, 14507, 14507, 14653], [14655, 14655, 14680, 14680, 14866], [14868, 14868, 14890, 14890, 15044], [15046, 15046, 15067, 15067, 15222], [15224, 15224, 15253, 15253, 15465], [15467, 15467, 15506, 15506, 15686]], "test": "error"}
{"id": "Ndl3R2", "name": "Droplet Splash", "author": "gunthern", "description": "Trying to recreate the effect of a drop of liquid landing on a surface with raymarched SDFs!", "tags": ["raymarching"], "likes": 10, "viewed": 91, "published": "Public", "date": "1616342650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define  MAX_DIST 100.0\n#define SURFACE_DIST 0.02\n\n//rotate2D from the art of code youTube\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//smooth min from the art of code\nfloat smin(float a, float b, float k) {\n    \n    float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);\n\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//from iquilez.org - distance functions\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    float d = length(p-c) - r;\n    return d;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-0.5)-0.5)*length(ab); \n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n\n    return e + i;\n}\n\nfloat sdSphere(vec3 p, vec3 s, float r) {\n    float d = length(p-s.xyz)-r;\n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    float d = length(vec2(x, p.y)) - r.y;\n    return d;\n}\n\nfloat GetDist(vec3 p){\n    \n    //hide main drop return\n    float s0Active = 0.0;\n    if (sign(sin(iTime)) == -1.0) {\n        s0Active = 0.0;\n    }\n    else {\n        s0Active = 1.0;\n    }\n    //main drop\n    float sphere0Dist = sdSphere(p, vec3(0.0 + (100.0 - 100.0*s0Active), 6.0*(cos(iTime)), 6.0), 0.3*s0Active);\n    \n    //surface\n    float planeDist = p.y - noise(p.xz)*.03*sin(iTime*2.) - noise(p.xz*2.)*.01*cos(iTime*2.); //noise modulation\n    \n    //splash drops\n    float sphere1Dist = sdSphere(p, vec3(0.0, 2.22*sin(iTime - 1.8),6.0), 0.15*sin(iTime - 2.0));\n    float sphere2Dist = sdSphere(p, vec3(0.0, 3.22*sin(iTime - 1.8),6.0), 0.25);\n    \n    //splash cone\n    float coneDist = sdCone(p - vec3(0.0,2.0*sin(iTime - 1.8),6.0), vec2(0.2,1.0), 2.0);\n    \n    //ripples\n    float t0DHeight = min(cos(iTime - 2.5)-1.0,0.0);\n    float torus0Dist = sdTorus(p - vec3(0.0,t0DHeight,6.0), vec2(2.0*sin(iTime - 2.2),0.35*sin(iTime)));\n    \n    float t1DHeight = min(cos(iTime - 2.75)-1.0,0.0);\n    float torus1Dist = sdTorus(p - vec3(0.0,t1DHeight,6.0), vec2(3.0*sin(iTime - 1.8),0.55*sin(iTime + 0.25)));\n    \n    float t2DHeight = min(cos(iTime - 4.75)-1.0,0.0);\n    float torus2Dist = sdTorus(p - vec3(0.0,t2DHeight,6.0), vec2(2.0*sin(iTime - 4.75),0.35*sin(iTime - 4.75)));\n    \n    //combine!\n    float boolUnion = smin(coneDist, planeDist, .5);\n    boolUnion = smin(boolUnion, sphere1Dist, .75);\n    boolUnion = smin(boolUnion, sphere2Dist, .2);\n    boolUnion = smin(boolUnion, torus0Dist, .5);\n    boolUnion = smin(boolUnion, torus1Dist, .5);\n    boolUnion = smin(boolUnion, torus2Dist, .5);\n    \n    float d = smin(boolUnion, sphere0Dist, .2);\n    \n    //test:\n    //d = min(torus2Dist, sphere0Dist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO>MAX_DIST || dS<SURFACE_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3.0*sin(iTime*.1), 4.0, 3.0*cos(iTime*.1));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p); \n    \n    float dif = dot(n, l);\n    float d = RayMarch(p+n*SURFACE_DIST*2.0, l);\n    if (d<length(lightPos-p)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n   \n    //Camera\n    //ray origin\n    vec3 ro = vec3(0.0, 2.0+iMouse.y/100., 0.0);\n    //ray direction\n    vec3 rd = normalize(vec3(uv.x,uv.y-iMouse.y/500.,1.0));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    \n    vec3 diffuse = vec3(0.0);\n    if (d<MAX_DIST) {\n        diffuse = vec3(0.5,0.75,0.9);\n        col = vec3(dif) * diffuse + GetNormal(p).zxy*.1; //a little hacky shading with normals\n    }\n    else {\n        diffuse = vec3(0.5,0.75,1.0)/3.;\n        col = diffuse;\n    }\n    \n    //gamma\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndl3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 113, 132, 132, 208], [210, 244, 283, 283, 384], [386, 386, 414, 414, 490], [492, 579, 605, 605, 1122], [1124, 1164, 1211, 1345, 1680], [1683, 1683, 1733, 1733, 1920], [1922, 1922, 1973, 1973, 2263], [2265, 2265, 2306, 2306, 2355], [2357, 2357, 2388, 2388, 2480], [2482, 2482, 2504, 2537, 4217], [4219, 4219, 4252, 4252, 4471], [4473, 4473, 4497, 4497, 4695], [4697, 4697, 4721, 4721, 5002], [5004, 5004, 5061, 5111, 5834]], "test": "valid"}
{"id": "Nds3W7", "name": "Dante's natty vessel", "author": "evvvvil", "description": "Dante's natty vessel - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["cute", "waves", "wave", "sea", "demoscene", "water", "ocean", "flag", "moon", "toon", "boat", "pirate", "divine", "dante", "comedy", "tide"], "likes": 28, "viewed": 742, "published": "Public", "date": "1616077927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Dante's natty vessel - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"You have to keep busy, after all, no dog ever pissed on a moving car.\" - Tom Waits\n\n// Major thankx to KALI for helping me \"rock the boat\", also thankx to CanadianCornDog, Brandon Stargrave, Neffers and Haptix for the recommendations and jokes\n\nvec2 z,v,e=vec2(.00035,-.00035),f=vec2(-1.7,1.7);float t,tt,b=0.,bb=0.,g=0.,sa;vec3 cp,rp,pp,po,no,al,zp,ld;\nfloat bo(vec3 p,vec3 r){  p=abs(p)-r;  return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nconst mat2 r2fucked=mat2(cos(.023),sin(.023),-cos(.023),sin(.023));\nfloat el( vec3 p, float r,vec3 h ){ vec3 q = p - clamp( p, -h, h ); return length( q )-r;}\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nfloat noi(vec3 p){\n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43785.5),fract(sin(h+s.x)*43785.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nfloat wave( vec3 p,int iter,float ga)\n{  \n  vec3 np=p-vec3(0,0,tt*3.); \n  float nois=0.,amp=3.0;\n  for(int i=0;i<iter;i++){\n   nois+=abs(sin(noi((np-vec3(0,0,tt*3.))*.15)-.5)*3.14)*(amp*=.51);   \n   np.xy*=r2fucked;\n   np*=1.75;    \n  }\n  if(ga>0.)cp=np,bb=nois;  \n  float t=p.y+nois;t*=0.5;    \n  return t;\n}\nmat3 lookat(vec3 dir,vec3 up) {vec3 rt=normalize(cross(dir,up));return mat3(rt,cross(rt,dir),dir);}//NOTE TO SELF: dir and up should be normalized \nvec2 mp( vec3 p,float ga)\n{    \n  vec2 h,t=vec2(wave(p,7,1.),5.);   \n  if(abs(p.x)-2.8<0.){\n    b=wave(vec3(0),4,0.);\n    rp = p+vec3(0,b,0);\n    vec3 wp= p-vec3(0,b*.5,0);\n    no=normalize(f.xyy*wave(f.xyy,1,0.)+f.yyx*wave(f.yyx,1,0.)+f.yxy*wave(f.yxy,1,0.)+f.xxx*wave(f.xxx,1,0.));    \n    rp*=lookat(no,vec3(0.,0.,1.));     \n    float tnoi=texNoise(rp.xz*.15,iChannel1).r;  \n    float cose=cos(rp.y*.5);\n    float boat=0.9*el(rp,0.48-tnoi-sin(rp.z*15.)*0.03,vec3(cose*.75,2.9,cose));\n    h=vec2(boat,3);    \n    h.x=abs(h.x)-.15;\n    h.x=max(h.x,rp.z-1.+tnoi+cos(rp.y*.4)*.5);\n    h.x=min(h.x, max(length(rp.xy-vec2(0,2.6))-.2+tnoi*.3,abs(rp.z-2.3)-2.7)); h.x*=0.8;\n    zp=p+vec3(0,1.7,0);\n    float wake =max( length(zp.xy)-1.2-p.z*.05,-3.-p.z);\n    wake=max(wake,-(length(wp.xy-vec2(0,2.0-abs(sin(p.z*2.5-tt*12.))*.5+abs(sin(p.x*.2))))-4.5));\n    t.x=smin(t.x,0.7*wake,1.0);        \n    t.x=max(t.x,-boat+.2);    \n    t=t.x<h.x?t:h;\n    pp=rp;pp.y=abs(pp.y)-3.2;\n    h=vec2(length(pp)-.2,6);\n    if(ga>0.)g+=0.1/(.1+h.x*h.x*(10.-9.5*sin(p.z-tt*5.)));\n    pp=rp-vec3(sin(rp.z*rp.y*.4+tt*4.)*max(0.,rp.y-2.5)*.2,3.6,3.8);\n    h.x=min(h.x,.7*bo(pp,vec3(.02,1,1)));\n    t=t.x<h.x?t:h;\n  }\t  \n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>43.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>43.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.83);\n  vec3 ro=vec3(5.+cos(tt*.4)*2.,4.+sin(tt*.4)*2.,7.415),\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.6)),co,fo;\n  ld=normalize(vec3(0.0,.1,-.5));\n  v = ld.xy/ld.z-rd.xy/rd.z;\n  vec3 moon = vec3(0.4,0.55,.75)*pow(max(dot(rd,ld),0.),24.0)+texNoise(v.xy+1.,iChannel0).r*smoothstep(.142, .13, length(v)); \n  co=fo=vec3(.13,.11,.12)+moon-length(uv)*.12;  \n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){    \n    po=ro+rd*t; ld=normalize(vec3(.2,.5,-.5));\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    float tnoi=texNoise(cp.xz*.0005,iChannel0).r+texNoise(cp.xz*.005,iChannel0).r*.5;\n    al=vec3(.1,.2,0.9)*tnoi/bb*2.,sa=5.;   \n    if(z.y<5.) al=vec3(.3,.2,.0)-min(rp.z*.2,0.4),sa=0.;   \n    if(z.y>5.) al=vec3(1.)-max(ceil(rp.z-2.9),0.)*ceil(max(-(length(abs(pp+vec3(0,0,-.25))-vec3(0,0.2,0))-.15), min(length(pp)-.4+.5*clamp(cos(rp.z*5.+1.3),-.6,.5),bo(abs(abs(pp.xzy)-vec3(0.0,0,0.2))-vec3(0,0,0.1),vec3(0.5,.5-2.*abs(sin(pp.y*.3)),.05))))),sa=0.;\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.1)+.2)*(dif+s(1.0)*sa),fo,min(fr,.6));\n    co=mix(fo,co,exp(-.00005*t*t*t));\n  }\n  fragColor = vec4(pow(co+g*.2*vec3(.7,.2,.1),vec3(0.55)),1);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "ltlXDB", "previewfilepath": "https://soundcloud.com/john-holt-official/the-tide-is-high-8", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/john-holt-official/the-tide-is-high-8", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 550, 574, 574, 619], [620, 620, 637, 637, 680], [749, 749, 784, 784, 839], [840, 840, 876, 876, 930], [931, 931, 969, 969, 1165], [1166, 1166, 1184, 1184, 1403], [1404, 1404, 1443, 1443, 1713], [1714, 1714, 1745, 1745, 1813], [1813, 1862, 1889, 1889, 3068], [3069, 3069, 3098, 3098, 3264], [3360, 3360, 3417, 3417, 4839]], "test": "error"}
{"id": "Nds3WM", "name": "Mediated Life", "author": "alexshortt", "description": "Raymarching Volume turned Art Piece\n\nRemix of https://www.shadertoy.com/view/7sf3W7", "tags": ["volume", "raymarch", "cloud"], "likes": 1, "viewed": 49, "published": "Public", "date": "1616061919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// camera from https://www.shadertoy.com/view/4dcBRN\nmat3 camera(vec3 ro, vec3 ta, float cr ) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// fbm from https://www.shadertoy.com/view/lss3zr\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n ) { \n    return fract(sin(n)*43758.5453); \n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\n\n// smin from the legend iq \nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n#define VOL_STEPS 6\n#define VOL_LENGTH 10.\n#define VOL_DENSITY 0.15\n\n#define SHA_STEPS 24\n#define SHA_LENGTH 10.\n#define SHA_DENSITY 0.8\n\n#define DLIGHT_DIR normalize(vec3(1., 2., 1.))\n#define DLIGHT_COL vec3(1., 0., 0.)\n\n#define ALIGHT_COL vec3(0.94, 0.94, 0.94)\n#define ALIGHT_DENSITY 0.1\n\n#define VOL_1_COL vec3(0.08, 0.02, 0.02)\n#define VOL_2_COL vec3(0.1, 1., 0.)\n\n#define EXTINCTION_COL vec3(0.6, 0.6, 1.)\n\nfloat jitter;\n\n// returns (color, depth)\nvec4 volume( vec3 p )\n{\n    // get noise value\n    float t = iTime * 0.38;\n    \n    vec3 q = 1. * (p - vec3(0.0,0.5,1.0) * t * 0.5);\n    float f = fbm(q);\n\n    float f2 = fbm(p - vec3(0.0,-0.5,-1.0) * t * 0.5);\n    \n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    float s2 = 0.3 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n    \n    float s3_1 = length(p * 0.2 - vec3(cos(t * 3.) * 6., sin(f2) * 2., sin(t * 3.) * 6.));\n    float s3_2 = length(p * 2. - vec3(0.0, sin(f2) * 4., cos(t * 2.) * 3.));\n    float s3_3 = length(p * 3. - vec3(cos(t * 2.) * 3., 0.0, sin(f2 * 3.3) * 7.));\n    float s3 = 1.0 - smin(smin(s3_1 ,s3_2 , 4.0), s3_3, 4.0) + f * 2.5;\n    \n    float d = mix(s1, s3, 0.5);\n    float perc1 = abs(s1) / mix(s1, s3, 0.5);\n    vec3 color = mix(VOL_2_COL, VOL_1_COL, perc1);\n    \n    return vec4( color, min(max(0.0, d), 1.0) );\n}\n\nvec4 raymarchVolume(vec3 rot, vec3 ray) {\n    float stepLength = VOL_LENGTH / float(VOL_STEPS);\n    float shadowStepLength = SHA_LENGTH / float(SHA_STEPS);\n    \n    float volumeDensity = VOL_DENSITY * stepLength;\n    float shadowDensity = SHA_DENSITY * shadowStepLength;\n    vec3 dlight = DLIGHT_DIR * shadowStepLength;\n    \n    float density = 0.;\n    float transmittance = 1.;\n    vec3 energy = vec3(0.);\n    vec3 pos = rot + ray * jitter * stepLength;\n    \n    // raymarch\n    for (int i = 0; i < VOL_STEPS; i++) {\n        vec4 vol = volume(pos);\n        float dsample = vol.a;\n        vec3 vol_color = vol.rgb * 0.2;\n        \n        if(transmittance < 0.1) break;\n        \n        if (dsample > 0.001) {\n            vec3 lpos = pos;\n            float shadow = 0.;\n            \n            // raymarch shadows\n            for (int s = 0; s < SHA_STEPS; s++) {\n                lpos += dlight;\n                vec4 lsample = volume(lpos);\n                shadow += lsample.a;\n            }\n            \n            // combine shadow with density\n            density = clamp(dsample * volumeDensity, 0., 1.);\n            vec3 shadowterm = exp(-shadow * vec3(shadowDensity) / (EXTINCTION_COL + vol_color));\n            vec3 absorbedlight = shadowterm * density;\n            energy += absorbedlight * transmittance;\n            transmittance *= 1. - density;     \n            \n            // ambient lighting\n            shadow = 0.;\n            vec4 asample = vec4(0.);\n            for (float s = 0.; s < 3.; s++) {\n                lpos = pos + vec3(0., 0., 0.05 + s * 1.3);\n                asample = volume(lpos);\n                shadow += asample.a;\n            }\n            \n            energy += exp(-shadow * ALIGHT_DENSITY) * density * ALIGHT_COL * transmittance / vol_color;\n        }\n\n        pos += ray * stepLength;\n    }\n    \n    return vec4(energy, transmittance);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up raycast\n    vec2 origin = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 rot = vec3(cos(iTime * .3) * 8., -5.5, sin(iTime * .3) * 8.);\n    vec3 tran = vec3(0.0, 1., 1.0);\n    mat3 cam = camera(rot, tran, 0.0);\n    vec3 ray = cam * normalize(vec3(origin, 3.));\n    \n    jitter = 0. * hash(origin.x + origin.y * 70.0 + iTime);\n    vec4 col = raymarchVolume(rot, ray);\n    \n    // Output to screen\n    vec3 top_col = vec3(.99);\n    vec3 bot_col = vec3(.94);\n    vec3 result = col.rgb + mix(top_col, bot_col, -origin.y) * (col.a);\n\n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 95, 95, 285], [287, 444, 467, 467, 508], [510, 510, 536, 536, 938], [940, 940, 961, 961, 1146], [1149, 1177, 1220, 1220, 1320], [1750, 1776, 1799, 1822, 2637], [2639, 2639, 2680, 2680, 4518], [4521, 4521, 4578, 4600, 5192]], "test": "valid"}
{"id": "Nds3zN", "name": "Pi Island (Pi Day 2021)", "author": "Rowsej", "description": "A raycasted island in the shape of π!\nHuge credits to IQ for lots of functions.\nMade for Pi Day 2021.", "tags": ["pi", "piday", "piday2021"], "likes": 2, "viewed": 181, "published": "Public API", "date": "1615713424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nπ Island\nBy Rowsej\nBEEG credits to IQ - I used five of his functions in this code!\n(Oh yes, and he made this website, so...)\n\nIt has a step size of 0.1, but each time it hits, it takes a step\nbackwards and then lowers the step size so it's more accurate\nuntil the step size is SMOL.\n\n*/\n\n#define PI 3.14159\n#define ROTATION (iTime * 32.)\n\n#define MAX_RAY_DIS 6.\n#define STEP_SIZE .1\n\n// Looks good but makes it look like plastic!\n#define SPECULARITY false\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang * PI / 180.);\n    float s = sin(ang * PI / 180.);\n    return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\n\n// Credit to IQ for this function:\nfloat sdSegment(vec2 a, vec2 b, vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n// And this polynomial-based smooth-minimum function:\nfloat sMin(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n// Oh, and these noise-related functions (https://www.shadertoy.com/view/lsf3WH):\nfloat hash(vec2 p) {\n    p = 50. * fract(p * .3183099 + vec2(.71, .113));\n    return -1. + 2. * fract(p.x * p.y * (p.x + p.y));\n}\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(\n        mix(hash(i + vec2(0.)), hash(i + vec2(1., 0.)), u.x),\n        mix(hash(i + vec2(0., 1.)), hash(i + vec2(1., 1.)), u.x),\n    u.y);\n}\n\nvoid add(inout float a, float b) {\n    a = sMin(a, b, .03);\n}\nvoid addS(inout float d, vec2 a, vec2 b, vec2 p) {\n    add(d, sdSegment(a, b, p));\n}\n\nfloat sdPi(vec2 p) {\n    // The top\n    float d = sdSegment(vec2(-1., .8), vec2(-.8, 1.), p);\n    addS(d, vec2(-.8, 1.), vec2(1.), p);\n    // The left leg\n    addS(d, vec2(-.3, 1.), vec2(-.4, -.5), p);\n    addS(d, vec2(-.4, -.5), vec2(-.6, -.7), p);\n    // The right leg\n    addS(d, vec2(.4, 1.), vec2(.5, -.5), p);\n    addS(d, vec2(.5, -.5), vec2(.8, -.7), p);\n    d -= .25;\n    return d;\n}\nfloat heightmap(vec2 p) {\n    float n = -sdPi(p);\n    n = sin(clamp(n, -.2, .2) * (90. / .2) * PI / 180.) * .1;\n    n += noise(p * 4.) * .03 * mix(1., .2, clamp(n / -.1, 0., 1.));\n    return n;\n}\n// And this is IQ's as well:\nvec3 getNormal(vec2 p) {\n    float eps = 0.01;\n    vec2 h = vec2(eps, 0.);\n    return normalize(vec3(\n        heightmap(p - h.xy) - heightmap(p + h.xy),\n        2. * h.x,\n        heightmap(p - h.yx) - heightmap(p + h.yx)\n    ));\n}\nvec3 bg(vec3 rd) {\n    return mix(vec3(.65, .65, .9), vec3(.55, .55, 1.), rd.y);\n}\nvec3 shading(float h) {\n    vec3 y = vec3(1., 1., 0.);\n    vec3 b = vec3(.2, .95, 1.);\n    vec3 g = vec3(0., 1., 0.);\n    vec3 g2 = vec3(0., .7, 0.);\n    if(h < 0.) {\n        return mix(y, b, clamp(-h * 10. + .1, 0., 1.));\n    } else if(h < .02) {\n        return y;\n    } else if(h < .06) {\n        return mix(y, g, clamp((h - .02) / .04, 0., 1.));\n    } else if(h < .08) {\n        return mix(g, g2, clamp((h - .06) / .02, 0., 1.));\n    } else {\n        return g2;\n    }\n}\nvec3 getCol(vec2 p) {\n    vec3 ro = vec3(0., 1., -1.25);\n    ro.xz = rotate(ro.xz, ROTATION);\n    vec3 rd = normalize(vec3(p, 1.));\n    rd.yz = rotate(rd.yz, 37.5);\n    rd.xz = rotate(rd.xz, ROTATION);\n    float s = STEP_SIZE;\n    for(float t = 0.; t < MAX_RAY_DIS; t += s) {\n        vec3 p = ro + rd * t;\n        float d = heightmap(p.xz);\n        if(p.y < d) {\n            if(STEP_SIZE / s > 100.) {\n                vec3 col = shading((p.y + d) / 2.);\n                vec3 n = getNormal(p.xz);\n                vec3 l = normalize(vec3(2., 2., -2.) - p);\n                float d = clamp(dot(n, l), .3, 1.);\n                vec3 final;\n                if(SPECULARITY) {\n                    float s = clamp(pow(dot(n, normalize(l - rd)), 256.), 0., 1.);\n                    final = col * d + vec3(1.) * s;\n                } else {\n                    final = col * d;\n                }\n                float fog = t / MAX_RAY_DIS;\n                vec3 fogCol = bg(rd);\n                return mix(final, fogCol, fog);\n            } else {\n                t -= s;\n                s /= 10.;\n            }\n        }\n    }\n    return bg(rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mind = min(iResolution.x, iResolution.y) / 1.5;\n    vec2 coords = fragCoord / mind * 2. - 1.;\n    coords.x -= (iResolution.x - mind) / mind;\n    coords.y -= (iResolution.y - mind) / mind;\n    vec3 col = getCol(coords);\n    fragColor = vec4(mix(vec3(0.), col, iTime > 0.? min(iTime, 1.) : 1.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 462, 494, 494, 623], [625, 660, 701, 701, 824], [825, 879, 918, 918, 1016], [1017, 1099, 1119, 1119, 1228], [1229, 1229, 1250, 1250, 1488], [1490, 1490, 1524, 1524, 1551], [1552, 1552, 1602, 1602, 1636], [1638, 1638, 1658, 1673, 2029], [2030, 2030, 2055, 2055, 2225], [2226, 2255, 2279, 2279, 2485], [2486, 2486, 2504, 2504, 2568], [2569, 2569, 2592, 2592, 3041], [3042, 3042, 3063, 3063, 4178], [4180, 4180, 4235, 4235, 4545]], "test": "valid"}
{"id": "NdsGRB", "name": "Spider on mouse", "author": "dopa", "description": "A spider on mouse and follow the targets on the scene! ", "tags": ["2d", "ik", "inversekinematics"], "likes": 29, "viewed": 262, "published": "Public API", "date": "1616170478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float segment(vec2 P, vec2 A, vec2 B, float r) \n\n{\n\n    vec2 g = B - A;\n\n    vec2 h = P - A;\n\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\n\treturn smoothstep(r,0.9*r, d);\n\n}\n\nconst vec3 backColor  = vec3(0.3);\n\nconst vec3 pointColor = vec3(0.15,0.1,0.1);\n\nconst vec3 targetsColor = vec3(0.9,0.9,1);\n\nconst vec3 lineColor = vec3(0,0,0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n     \n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    if(mouse== - iResolution.xy / iResolution.y)\n        mouse=vec2(0,0);\n        \n    vec3 color = backColor;\n    \n    vec2 targets[]=vec2[] (\n                            vec2(.3,0),vec2(.4,.2),vec2(.7,.1),vec2(.2,-.6),vec2(-.8,.1),vec2(-.8,-.6),\n                            vec2(.5,.2),vec2(.1,.7),vec2(.7,.6),vec2(.3,-.2),vec2(.4,.1),vec2(-.6,.5),\n                            vec2(.4,0),vec2(.2,.4),vec2(-.7,-.3),vec2(.2,-.6),vec2(-.8,.1),vec2(-.7,.3),\n                            vec2(-.6,.2),vec2(-.4,.7),vec2(-.6,-.7),vec2(-.4,-.2),vec2(-.2,.1),vec2(-.1,.4)\n                          \n                          );\n    /*                      \n    for (int i = targets.length() - 1; i >= 0; --i) {\n      float f=0.0;\n      //f = (float(i)/float(targets.length() - 1) + 5.0) / 5.0;\n      //f=fract(sin(dot(targets[i].xy,vec2(12.9898,78.233)))*43758.5453123);\n      f=float(i%10+1)/10.0;\n      targets[i] += vec2(cos(iTime * f), sin(iTime * f)) * 0.05;\n    }                      \n    */\n    \n    mouse += vec2(cos(iTime)*2.0, sin(iTime)) * 0.05;\n    \n    float radius=.08;\n    \n    int legsNum = 8;//\n    \n    float dalte=3.1415926*2.0/float(legsNum);\n    for (float k=0.0;k<3.1415926*2.0;k+=dalte){\n        float angle = k;\n        vec2 pos;\n        pos.x =cos(angle)*radius;\n        pos.y = sin(angle)*radius;\n        \n        int iterations=5;//\n\n        vec2 startPoint=mouse+pos;\n        \n        float reach=4.5;\n        \n        float closestLength=10.0;\n        vec2 closestPoint;\n        for (int i=targets.length()-1;i>=0;i--)\n        {\n            if(closestLength>length(targets[i]-(mouse+pos*reach)))\n            {\n                closestLength=length(targets[i]-(mouse+pos*reach));\n                closestPoint=targets[i];\n            }\n        }\n        \n        \n        vec2 endPoint=closestPoint;\n        \n        int piece=3;\n\n        vec2[] points=vec2[] (vec2(1,1),vec2(2,2),vec2(3,3),vec2(4,4));\n\n        float[] lenghts=float[](0.3,0.25,0.1);\n\n\n        for (int j=0;j<=iterations;j++){\n            vec2 target=endPoint;\n            for (int i=piece;i>0;i--){\n                points[i]=target;\n\n                vec2 dir;\n                dir=(target-points[i-1])/ length(target-points[i-1]);\n                points[i-1] = target-(dir*lenghts[i-1]);\n\n\n                target=points[i-1];\n            }\n\n            target=startPoint;\n            for (int i=0;i<piece;i++){\n                points[i]=target;\n\n                vec2 dir;\n                dir=(target-points[i+1])/ length(target-points[i+1]);\n                points[i+1] = target-(dir*lenghts[i]);\n\n\n                target=points[i+1];\n            }\n        }\n\n        \n        float intensity;\n        \n        for (int i=piece;i>=0;i--){\n            intensity = segment(uv, points[i],points[i], 0.03);\n            color = mix(color, pointColor, intensity);\n        }\n        \n        \n        for (int i=piece;i>=1;i--){\n            intensity = segment(uv, points[i],points[i-1], 0.01);\n            color = mix(color, lineColor, intensity);\n        }\n       \n         for (int i=targets.length()-1;i>=0;i--){\n            intensity = segment(uv, targets[i],targets[i], 0.02);\n            color = mix(color, targetsColor, intensity);\n        }\n        intensity = segment(uv, mouse,mouse, radius+0.03);\n        color = mix(color, pointColor, intensity);\n        \n    }\n    fragColor = vec4(color, 1.0);\n}\n\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 198], [363, 363, 419, 419, 3954]], "test": "error"}
{"id": "NdsGRj", "name": "simple sierpinski triangle", "author": "Angramme", "description": "a really simple sierpinski triangle", "tags": ["fractal", "triangle", "sierpinski"], "likes": 4, "viewed": 153, "published": "Public", "date": "1616263187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define PI 3.14159265359\n#define L 1.5\n#define N 11.\n\n#define OVERFLOW 0.035\n#define HARSHNESS 2.\n\n#define SPEED .8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 1.7*(fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y *= -1.;\n    //vec3 color = vec3(uv.xy, 0);\n    vec3 color = vec3(0);\n\n    uv.y -= .25;\n    \n    // a value of 1/2 works because homotheties scale by 1/2\n    const float logval = .5;\n    float T = (exp(mod(iTime*log(logval)*SPEED, 1.*log(logval)))-1.)/(logval-1.);\n    uv *= mix(.5, .25, T);\n    //uv.xy -= vec2(0, 1)*mix(.5, .75, T);\n    uv.xy -= vec2(cos(PI*30./180.), -sin(PI*30./180.))*mix(.5, .75, T);\n    \n    \n\n    //complexité O(n)\n    for(int i=0; i<int(N); i++){\n        if(-uv.y > abs(uv.x)*0.57735026){\n            uv = (uv-vec2(0, -L/3.))*2.;\n        }else if(uv.x > 0.){\n            uv = (uv-vec2(cos(PI/6.)/3.*L, sin(PI/6.)/3.*L))*2.;\n        }else{\n            uv = (uv-vec2(-cos(PI/6.)/3.*L, sin(PI/6.)/3.*L))*2.;\n        }\n    }\n    \n\n    //check if point is inside the triangle in the middle\n    // if(//dot(normalize(uv-vec2(0, -2./3.*L)), vec2(0, 1)) > 0.866025404\n    //     uv.y+2./3.*L > abs(uv.x)*1.7320\n    //     && uv.y < 1./3.*L){\n    //     color.rg = vec2(1.);\n    // }\n\n    float inside_amount = HARSHNESS*min(\n        min(max(0., (uv.y+2./3.*L) - (abs(uv.x)-OVERFLOW*N)*1.7320)*10./N, 1.),\n        min(max(0., -uv.y + 1./3.*L +OVERFLOW*N)*15./N, 1.)  \n    );\n    color.rg = vec2(inside_amount);\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 198, 198, 1533]], "test": "valid"}
{"id": "NdsGzj", "name": "I have no idea what I am doing", "author": "ja6kjak", "description": "#Willstallchallenge a shader a day.\nplaying around with smoothstep. I still have no understanding", "tags": ["beginner", "smoothstep", "willstallchallenge"], "likes": 3, "viewed": 79, "published": "Public", "date": "1616266152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    float smoothstepR = smoothstep(smoothstep(st.x,st.y, 0.5), \n                        smoothstep(st.x + sin(iTime),st.y + cos(iTime),0.5), \n                        0.0);\n    \n    float y = smoothstepR;\n    \n    vec3 color = vec3(y, .5, .7);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdsGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 134, 462]], "test": "valid"}
{"id": "NdX3R7", "name": "Fork Color arcs RaduBT 036", "author": "RaduBT", "description": "Basic arcs demo\n\n/// https://www.shadertoy.com/view/tdjXDd\n/// Shadertoy : Avin - Color Arcs Shadertoy", "tags": ["arcs", "multicolor"], "likes": 9, "viewed": 378, "published": "Public API", "date": "1615656583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// https://www.shadertoy.com/view/tdjXDd\n/// Shadertoy : Avin - Color Arcs Shadertoy\n\n\n\n\n\n#define PI 3.1415926\n#define TAU 6.2831852\n#define BLACK_COL vec3(24,32,38)/255.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n#define hue(h) clamp( abs( fract(11.2*h + vec4(3,2,1,0)/12.) * 4. - 2.8) -1. , 0.1, 15.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n\n    float SIZE = 4. + cos(iTime*0.5)*0.1;\n    float r = length(uv) * SIZE;\n    r*=10.0;\n    float id = ceil(r);\n    float s = mod(id, 2.)*2. - 1.; // Direction\n    float a = fract(atan(uv.y, uv.x)/TAU + s*(iTime*(rand1(id+400.)*0.5+0.5)*0.2 + id*0.2));\n    float inRange = step(3.,id); // Don's draw center arcs    \n    float sm = (1./iResolution.y * 30.* SIZE);    \n    \n    inRange *= smoothstep(.0, sm, fract(r)) * smoothstep(1.0, 1.0 - sm, fract(r));\n    float arcLength =  (rand1(id)*0.25 + 0.25);\n    \n    sm = (sqrt(SIZE)*(1./iResolution.y * 5. / id));\n    inRange *= smoothstep(arcLength, arcLength + sm, a) * smoothstep(1.0, 1. - sm, a);\n        \n    vec3 col = hue(rand1(id)).rgb;\n    \n    col = mix(BLACK_COL, col, inRange);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdX3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 315, 372, 372, 1214]], "test": "valid"}
{"id": "NdX3RH", "name": "Layer Slice display", "author": "nebbul", "description": "Draw slices to display different layers of something\n\nI use this is my solar system shader to display the different render passes: https://www.shadertoy.com/view/3tyfWy", "tags": ["visualization", "slice", "debug", "render", "layer"], "likes": 1, "viewed": 54, "published": "Public", "date": "1615457801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LAYER_DISPLAY 1\n\n// background grid from https://www.shadertoy.com/view/XtBfzz\nconst float N = 2.0; // grid ratio\nfloat gridTexture( in vec2 p )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    //return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // default \"beautypass\"\n    vec3 col = 0.2 * vec3(1., 1., 1.) * gridTexture(fragCoord.xy/iResolution.xx * vec2(5., 5.)) + 0.6;\n\n    // display render layers by using global flag\n#if LAYER_DISPLAY\n    vec2 visuv = fragCoord.xy / iResolution.yy + fragCoord.y/iResolution.y;\n    float sliceCount = 6.;\n    float sliceWidth = 2.;\n    \n    float lineWidth = 0.05;\n    float speed = 0.2;\n    \n    float slice = floor(mod(visuv.x * sliceWidth - iTime * speed, sliceCount)) / sliceCount;\n    float line = 1.-(smoothstep(0., lineWidth, mod((visuv.x - iTime * speed * (1./sliceWidth)) * sliceWidth * sliceCount, sliceCount)) * smoothstep(0., lineWidth, mod((-visuv.x + iTime * speed * (1./sliceWidth)) * sliceWidth * sliceCount, sliceCount)));\n    \n    float sliceStep = 1. / sliceCount;\n\n    // just increase this with number of slices\n    if(slice >= sliceStep && slice <= sliceStep*2.) col = vec3(1.,0.,0.);\n    if(slice >= sliceStep*2. && slice <= sliceStep*3.) col = vec3(0.,1.,0.);\n    if(slice >= sliceStep*3. && slice <= sliceStep*4.) col = vec3(0.,0.,1.);\n    if(slice >= sliceStep*4. && slice <= sliceStep*5.) col = vec3(1.,0.,1.);\n    if(slice >= sliceStep*5. && slice <= sliceStep*6.) col = vec3(1.,1.,0.);\n    \n    col = mix(col, vec3(0.,0.,0.), line);\n#endif\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdX3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 122, 154, 173, 436], [438, 438, 495, 523, 1796]], "test": "valid"}
{"id": "Ns23z1", "name": "Autumn grid ", "author": "josemorval", "description": "Just a bunch of cubes in a repeated space with some noisy movement", "tags": ["raymarching", "cubes", "repeated"], "likes": 34, "viewed": 540, "published": "Public API", "date": "1616959298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Box signed distance\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Distance mapping\nfloat map(vec3 p){\n    float d = 1000.;\n    vec3 q = p;\n    \n    //Here we compute the cell coordinates + index per cell\n    float size = 2.;\n    vec3 iq = floor((p+size/2.)/size);\n    q = mod(q+size/2.,size)-size/2.;\n    \n    //Some noisy pattern\n    float n=0.;\n    n+=0.5*sin(0.8*iq.x+1.1*iTime)*sin(0.71*iq.y+0.2*iTime+0.4)*sin(0.85*iq.z+0.3*iTime+1.4);\n    n+=0.5*sin(0.5*iq.x+1.1*iTime+1.5)*sin(0.3*iq.y+1.3*iTime+1.7)*sin(0.1*iq.z+0.3*iTime+2.4);\n    n = 1.-smoothstep(0.,0.2,n+0.1);\n\n    \n    //Distance to box in a cell + space clamp (tweak box distance to raymarch slow)\n    d = 0.25*box(q,0.9*vec3(n));\n    d = max(d,box(p,vec3(9.)));\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = 0.001*vec2(1.,0.);float d = map(p);\n    return normalize(vec3(map(p+e.xyy)-d,map(p+e.yxy)-d,map(p+e.yyx)-d));\n}\n\n//Raymarch (and shadow march) routines\nconst float FAR = 10000.;\nfloat raytrace(vec3 ro,vec3 rd){\n    float t = 0.;\n    for(int i=0;i<200;i++){\n        float d = map(ro+rd*t);\n        if(abs(d)<0.001){\n            return t;\n        }\n        t+=d;\n    }\n    \n    return FAR;\n}\n\nfloat shadow(vec3 ro,vec3 rd){\n    float t = 0.;\n    for(int i=0;i<200;i++){\n        float d = map(ro+rd*t);\n        if(abs(d)<0.001){\n            return 0.;\n        }\n        t+=d;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord/iResolution.xy;;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n\n    float f =0.5*sin(0.5*iTime)-0.5;\n\n    //Ortho camera\n    vec3 ro= 5.*vec3(3.*sin(f),2.,3.*cos(f));\n    vec3 rd = -normalize(ro);\n    vec3 up = vec3(0.,1.,0.);vec3 fw =rd;vec3 ri = cross(fw,up); up = cross(ri,fw);\n    ro=ro+20.*(uv.x*ri+uv.y*up);\n    \n    float t = raytrace(ro,rd);\n    \n    //Background\n    col = vec3(1.,0.9,0.8)*(0.4-0.3*uv.y);\n    vec3 lightdir = normalize(vec3(1.,2.,1.));\n    \n    if(t<FAR){\n        \n        //Simple lighting (dot, shadow and height based)\n        vec3 pos = ro+rd*t;\n        vec3 n = normal(pos);\n        float sha = shadow(pos+0.01*n,lightdir);\n        \n        vec3 lin = max(dot(n,lightdir),0.)*vec3(1.,0.95,0.85)*(0.+1.*sha);\n        lin += 1.1*vec3(0.1,0.05,0.0)*(1.5+0.1*pos.y);\n        \n        \n        col = lin;\n \n    }\n\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 51, 51, 138], [140, 159, 177, 177, 820], [822, 822, 842, 842, 967], [969, 1034, 1066, 1066, 1245], [1247, 1247, 1277, 1277, 1456], [1458, 1458, 1515, 1515, 2461]], "test": "valid"}
{"id": "Ns2GzR", "name": "attempt_dotprod", "author": "singoltone", "description": "attempt with dot product", "tags": ["attempt"], "likes": 2, "viewed": 45, "published": "Public", "date": "1616849708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 st) \n{\n    return fract(sin(dot(st.xx*st.yy*0.15,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat Circle(vec2 uv, float radius, float blur)\n{\n    return smoothstep(radius, radius-blur, length(uv))/\n    smoothstep(radius*.01, radius+blur, length(uv)*.2);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0., 0., 0.);\n    \n    uv *= uv * (100. + (cos(iTime*.1) * sin(iTime*.2) * 100.))*0.2;\n    uv.x = abs(uv.x);\n    \n    //uv.x = fract(uv.x);\n    uv = rotate(uv, sin(iTime*0.01)*180.);\n    \n    float choice = random(uv)*5.;\n    vec2 dotProdChoice = vec2(0.);\n    \n    if (choice < (sin(iTime)*3.)+3.)\n        dotProdChoice = uv.yy;\n    else\n        dotProdChoice = uv.yx;\n    \n    \n    uv.y = dot(dotProdChoice, uv.xy) * random(uv);\n    \n    \n    float x = uv.x*.1;\n    float m = ((x+-1. * .2) * (x-cos(iTime))*20. ) / sin(iTime);\n    m += m * 0.1;\n    float y = uv.y + sin(m)*cos(m)*2.;\n      \n    y = pow(y, random(uv)*2.)*0.1 ;\n    col += Circle(vec2(x,y) * 0.2 , ((.5 + sin(iTime*.01))*0.3), 0.7);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2GzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 142], [144, 144, 193, 193, 307], [309, 309, 339, 339, 423], [425, 425, 482, 532, 1444]], "test": "valid"}
{"id": "NsB3zm", "name": "Grid Horizon", "author": "midorikuma", "description": "nostalgy", "tags": ["80s", "vaporwave"], "likes": 1, "viewed": 141, "published": "Public", "date": "1617113567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 c;\nvoid ori(vec2 p,out vec3 c)\n{\n    float t = iTime;\n    c=vec3(0.3/p.y-0.1,sin(t*0.2)-0.5,0.7);\n    if (length(vec2(p.x,p.y-0.45))<0.4 &&\n    mod(9.0,0.25/(p.y-0.2))<0.7+abs(cos(t*100.0)*cos(t*33.3))){\n        c=vec3(1.0,0.4+(p.y*3.0-1.5),0.0);\n    }\n    \n    float mt=(asin(sin(p.x*50.0))+asin(sin(p.x*15.0))*2.0-asin(sin(p.x*80.0))/10.0)/90.0;\n    if (p.y<mt+abs(p.x)/8.0+0.3){\n        c=vec3(0.01);\n    }\n\n    float w = 2.0 + p.y/10.0;\n    vec2 q1 =p*w/(p.y-0.3);\n    q1.y = q1.y/0.1 - t+cos(t)*0.2;  \n    float size =0.7;\n    vec2 q2 = abs(mod(q1, size)-size/2.0);\n    float f = (max(q2.x,q2.y)-0.3)*10.0;\n    if (p.y<0.2){\n    c = vec3(1.0,0.2,1.0)*f;\n    }\n}\n\nvoid fil(vec2 p,inout vec3 prec,vec3 val)\n{\n    float t = iTime;\n    p.x+=sin(t*2.0+p.y*60.0)*0.02;\n    ori(p,c);\n    prec+=c*val*0.2*(abs(sin(t*0.3))-1.2);\n    prec+=cos(t*-80.0+p.y*80.0)*0.2;\n    prec+=cos(t*5.0+p.y*20.0)*0.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    ori(p,c);\n    fil(p+0.02,c,vec3(1.0,0.0,0.0));\n    fil(p-0.02,c,vec3(0.0,0.0,1.0));\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 37, 37, 671], [673, 673, 716, 716, 904], [906, 906, 963, 963, 1175]], "test": "valid"}
{"id": "Nsf3Dn", "name": "Fyrecean Ray Marching #2", "author": "Fyrecean", "description": "Making scenes with a ray marching renderer", "tags": ["raymarch"], "likes": 4, "viewed": 135, "published": "Public", "date": "1615753848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int maxSteps = 80;\nconst float hitThreshold = .002;\nconst float maxDistance = 800.;\nconst float specExp = 8.;\nconst float AA = 2.;\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\n\n\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\n\nmat3 rotMat3(vec3 u, float t)\n{\n    u = normalize(u);\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\nmat2 rotMat2(float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p - s.center) - s.radius, s.color);\n}\n\nHit boxSDF( vec3 p, Box b )\n{\n  vec3 q = abs(p - b.center) - (b.size);\n  float radius = 0.02;\n  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\n\n// Signed distance functions for different shapes\n\nHit mandelbulbSDF(vec3 p)\n{\n    float power = 8.;\n    vec3 z = p;\n    float dr = 1.;\n    float r;\n    vec3 c1 = vec3(1., 1., 1.);\n    vec3 c2 = vec3(1., 0., 0.) * .02;\n    \n    for (int i = 0; i < 15; i++)\n    {\n        r = length(z);\n        if (r > 2.)\n        {\n            break;\n        }\n        float theta = acos(z.z / r) * power + iTime;\n        float phi = atan(z.y/z.x) * power + iTime;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n        c2 += c2;\n    }\n    return Hit(0.5 * log(r) * r / dr, c1 - c2);\n}\n\nHit linesSDF(vec3 _p)\n{\n    vec2 p = _p.xz;\n    int iter = 4;\n    float q = 10.8 + .2*_p.y;\n    float scale = 2.2;\n    float s = .5;\n    p *= s;\n    float r = (1.1+sin(iTime))/3.;\n    vec3 color = vec3(0.);\n    int i = 0;\n    p = p*rotMat2(-0.4*q);\n    for (; i < iter; i++)\n    {\n        if (p.x < 0.)\n        {\n            p.x = -p.x;\n            color.r += 1.;\n        }\n        p = rotMat2(.9 * q) * p;\n        if (p.y < 0.)\n        {\n            p.y = -p.y;\n            color.g += 1.;\n        }\n        p = rotMat2(q) * p;\n        if (p.x - p.y < 0.)\n        {\n            p.xy = p.yx;\n            color.b += 1.;\n        }\n        p *= scale;\n        p -= 2.;\n        p = rotMat2(iTime) * p;\n    }\n    float d = .6 * (length(p)-r) * pow(scale, float(-i))/s;\n    return Hit(d, color/float(iter));\n}\n\n// Smooth min to cause shapes to morph into eachother\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nHit hitSMin(Hit a, Hit b, float k)\n{\n    float h = clamp(0.5+0.5*(b.t-a.t)/k, 0.0, 1.0 );\n    float f = mix(b.t, a.t, h) - k*h*(1.0-h);\n    vec3 c = mix(b.color, a.color, h) - k*h*(1.0-h);\n    return Hit(f, c);\n}\n\n// Define the objects in the scene and their relations to eachother\nHit map(vec3 p)\n{\n    mat3 rot = rotMat3(vec3(1., 0., -0.5), 1.2);\n    return linesSDF(rot * p);\n}\n\n// Calculate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec3 eps = vec3(0.001, 0., 0.);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n        i += 3;\n        if (i > maxSteps)\n        {\n            break;\n        }\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(5., 0., -6.), 50., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., 5., 5.), 25., vec3(1., .5, .1), 8.),\n        Light(vec3(0., 0., 0.), 25., vec3(1., 0.5, 1.), 1.)\n    );\n    vec3 ambient = vec3(1.) * .2;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness) * 4.;\n        \n        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glowBase = vec3(1., .5, 1.) * .001;\n    vec3 glow = vec3(0.);\n    float t = 0.;\n    for (int i = 0; i < maxSteps && t <= maxDistance; i++)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color;\n        }\n        t += closestHit.t;\n        glow += glowBase;\n    }\n\n    return vec3(0.01, 0.02, 0.03) + glow;\n}\n\nvec4 render(in vec3 e, in mat4 view, in vec2 uv) {\n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    return vec4(raymarch(viewRay), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    mat3 rot = rotMat3(vec3(0.), 0.);\n    vec3 e = vec3(0., 0., 10.);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n        // Convert pixel coordinates to uv coordinates\n    if (AA > 1.) {\n      vec4 average = vec4(0.0);\n      for (float s = 0.; s < AA; s++) {\n        for (float t = 0.; t < AA; t++) {\n            vec2 offset = (vec2(s, t) / AA) - 0.5;\n\n            vec2 uv = (fragCoord + offset)/iResolution.xy * 2. - 1.;\n            uv.y *= iResolution.y/iResolution.x;\n\n            average += render(e, view, uv);\n        }\n      }  \n      average /= AA*AA;\n      fragColor = average;\n    } else {\n      vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n      uv.y *= iResolution.y/iResolution.x;\n\n      fragColor = render(e, view, uv);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 495, 495, 534], [536, 536, 567, 567, 903], [905, 905, 928, 928, 1026], [1028, 1028, 1061, 1061, 1121], [1123, 1123, 1152, 1152, 1303], [1305, 1356, 1383, 1383, 2009], [2011, 2011, 2034, 2034, 2813], [2815, 2869, 2910, 2910, 2999], [3001, 3001, 3027, 3027, 3109], [3111, 3111, 3147, 3147, 3323], [3325, 3393, 3410, 3410, 3491], [3493, 3543, 3568, 3568, 3854], [3856, 3894, 3942, 3942, 4468], [4470, 4526, 4566, 4566, 5465], [5467, 5499, 5523, 5523, 6097], [6099, 6099, 6149, 6201, 6333], [6335, 6335, 6392, 6413, 7429]], "test": "error"}
{"id": "Nsf3WM", "name": "Gen1", "author": "cody_shader", "description": "Gen1", "tags": ["raymarching"], "likes": 9, "viewed": 128, "published": "Public", "date": "1616008461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATION 500\n#define MAX_DIST 10.\n#define EX vec3(0.001, 0., 0.)\n#define EY vec3(0., 0.001, 0.)\n#define EZ vec3(0., 0., 0.001)\n#define w iResolution.x\n#define h iResolution.y\n#define iTime iTime*1.2\n\nfloat smin(float a, float b, float k) {\n\tfloat m = max(min(0.5 + 0.5 * (b - a) / k, 1.), 0.);\n\treturn a * m + b * (1. - m) - k * m * (1. - m);\n}\n\nfloat getDist(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО СФЕРЫ\n\tvec3 sphere = vec3(0.,0.-0.2+sin(iTime*0.5)*0.4,0.);\n\tfloat sphereDist = distance(p, sphere) - 1.;\n\tfloat planeDist = smin(+p.y + 0.9, -p.z +10.8,10.0);\n\tfloat d = smin(sphereDist, planeDist, 0.4);\n\treturn d;\n\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = getDist(p);\n\tfloat p1 = getDist(p - EX);\n\tfloat p2 = getDist(p - EY);\n\tfloat p3 = getDist(p - EZ);\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = vec3(d) - tri;\n\treturn normalize(n);\n}\n\nfloat light(vec3 p) {\n\tvec3 lightPos = vec3(sin(iTime)*2., 0., cos(iTime)*2.);\n\tvec3 lightDir = normalize(lightPos - p);\n\tvec3 n = normal(p);\n\treturn dot(n, lightDir) * 0.5 + 0.5;\n}\n\nfloat rayMarching(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tfor (int i = -0; i < 500; i++){\n\t\tfloat d = getDist(p);\n\t\tif (d > MAX_DIST) {break;}\n\t\tp = vec3(p) +  rd * d;\n\t\tif (d < 0.0001){\n\t\t\treturn light(p);\n\t\t} \n\t}\n\treturn 0.;\n}\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\nfloat random (in vec2 _st, float col) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123)*col;\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st, float col) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    int j = int(col*3.);\n   \n    // Four corners in 2D of a tile\n    float a = random(i, col);\n    float b = random(i + vec2(1.0, 0.0), col);\n    float c = random(i + vec2(0.0, 1.0), col);\n    float d = random(i + vec2(1.0, 1.0), col);\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st, float col ) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st, col);\n        _st = rot * _st * 2.0 + shift;\n        a *= col;\n    }\n  \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = fragCoord.xy/iResolution.y*3.;\n    const int iteration = 500;\n    const float max_dist = 10.0;\n\n\t//координаты камеры\n\tvec3 ro = vec3(0., 0., -2.);\n\n    float x = (fragCoord.x / w) * 2. - 1.;\n    float y = (fragCoord.y / h) * 2. - 1.;\n    x *= w / h;\n\n    //направление луча\n    vec3 rd = vec3(x, y , 1.);\n    rd = normalize(rd);\n\n    //круг\n    float col = rayMarching(ro, rd);\n\t\t\t\n\n    \n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime, col);\n    q.y = fbm( st + vec2(1.0), col);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime , col);\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime, col);\n\n    float f = fbm(st+r, col);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n            \n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 248, 248, 353], [355, 355, 378, 450, 663], [665, 665, 686, 686, 875], [877, 877, 898, 898, 1058], [1060, 1060, 1097, 1097, 1283], [1285, 1397, 1436, 1436, 1548], [1550, 1628, 1666, 1666, 2096], [2121, 2121, 2159, 2159, 2509], [2511, 2511, 2568, 2568, 3771]], "test": "error"}
{"id": "Nsf3Ws", "name": "random generator", "author": "mdb", "description": "easy to use pseudo random generator that you can copy paste on your project", "tags": ["random"], "likes": 3, "viewed": 310, "published": "Public API", "date": "1616704506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandomGenerator(fragCoord);\n    vec3 col = vec3(random());\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 99, 99, 249], [250, 250, 291, 291, 404], [406, 406, 421, 421, 472], [473, 544, 601, 601, 702]], "test": "valid"}
{"id": "Nsf3zM", "name": "Compare simplex with lerp noise", "author": "foxes", "description": "Copied from https://www.shadertoy.com/view/4dXyRS\nLeft - lerp noise (Lnoise)\nRight - simplex noise (Snoise)", "tags": ["noise", "simplex"], "likes": 1, "viewed": 187, "published": "Public API", "date": "1615656599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see also analytical derivatives version: https://www.shadertoy.com/view/XdlyzS\n\n// --- noise from procedural pseudo-Perlin ( adapted from IQ ) ---------\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n//#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n#define hash3(p)  fract(mod(dot(p,vec3(1,57,-13.7))*dot(p,vec3(1,57,-13.7))*34.+dot(p,vec3(1,57,-13.7)),289.)/289.)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define Lnoise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n// --- Simplex noise 3D from  Makio64 / Ashima https://www.shadertoy.com/view/Xd3GRf\n\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float Snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 6. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U.x -= iResolution.x*0.5;\n    U *= 8./iResolution.y;\n    float n;\n    if (U.x>0.)\n        n = Snoise(vec3(U*1.0,.3*iTime));\n    else\n        n = Lnoise(vec3(U*2.0,.6*iTime));\n    O = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsf3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 157, 181, 181, 877], [975, 2693, 2731, 2731, 2929]], "test": "error"}
{"id": "NsfGRf", "name": "Simplified Two Link IK Solver", "author": "oneshade", "description": "Major simplifications using trigonometric identities!\nNote that you don't get the luxury of these simplifications if you need the actual angles, e.g. for controlling an actual robot arm or performing joint interpolated motion ;)\nMouseable.", "tags": ["ik", "solver", "simplified", "inversekinematics", "twolink"], "likes": 6, "viewed": 75, "published": "Public", "date": "1616342252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\n// Only two square roots!\n// config sets the handedness, -1 for left, 1 for right\nvec2 solveJoint(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d = dot(ba, ba), l = sqrt(d);\n    float q = (d + ra * ra - rb * rb) / (2.0 * ra * l);\n    return a + (ba * q + vec2(-ba.y, ba.x) * sqrt(1.0 - q * q) * config) * ra / l;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    // Link lengths\n    float ra = 3.0;\n    float rb = 1.5;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 6.0;\n    if (iMouse.z < 0.0 || ivec2(iMouse.xy) == ivec2(0)) {\n        mouse = ra * vec2(cos(iTime), cos(iTime * 2.0) * sin(iTime));\n    }\n\n    vec2 uv = (fragCoord - center) / iResolution.y * 6.0;\n    float unit = 12.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Joints\n    vec2 a = vec2(0.0);\n    vec2 c = mouse;\n    vec2 b = solveJoint(a, c, ra, rb, 1.0);\n\n    // Reachable area\n    draw(sdRing(uv, a, ra, rb), vec3(0.2, 0.8, 0.5));\n\n    // Draw links\n    draw(sdLine(uv, a, b, 0.1), vec3(0.0));\n    draw(sdLine(uv, b, c, 0.1), vec3(0.0));\n\n    // Draw joints\n    draw(sdDisc(uv, a, 0.15), vec3(0.5));\n    draw(sdDisc(uv, b, 0.15), vec3(0.5));\n    draw(sdDisc(uv, c, 0.15), vec3(0.5));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsfGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 127, 127, 239], [241, 241, 289, 289, 321], [323, 323, 383, 383, 424], [426, 508, 590, 590, 792], [794, 794, 849, 849, 1742]], "test": "valid"}
{"id": "NsjGRD", "name": "The Vibe Bubble", "author": "_bm", "description": "sit back, relax, and enjoy the subtle good vibes", "tags": ["color", "relaxing", "vibe"], "likes": 6, "viewed": 73, "published": "Public", "date": "1617042766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nfloat nsin(in float x)\n{\n    return sin(x) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float thickness = 0.005;\n    float alias = 3.0 / iResolution.x;\n    float speed = 0.05;\n    float t = iTime * speed;\n    vec3 color;\n    for (float i = 0.0; i < 50.0; i += 1.0) {\n        float outer = sin((i / 50.0) * PI * 2.0 + t) * 0.25 + 0.25;\n        float a = atan(st.y, st.x);\n        float d = length(st);\n        float f = d\n            + sin(iTime * speed * 4.1 + st.y * 10.0) * 0.01\n            + sin(iTime * speed * 4.6 + st.x * 9.0) * 0.015\n            + sin((a + t) * 16.0) * 0.05 * d\n            + sin((0.31 + a + t * 0.77) * 6.0) * 0.03 * d\n            + sin((7.71 + a + t * 0.98) * 12.0) * 0.04 * d;\n        f *= 1.05;\n        float v = smoothstep(0.0, -alias, abs(f - outer + thickness / 2.0) - thickness);\n        color += vec3(\n            nsin(i * nsin(0.2 + t * 1.23)),\n            nsin(i * nsin(2.0 + t * 1.67)),\n            nsin(i * nsin(1.0 + t * 1.76))\n        ) * v;\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 49, 49, 82], [84, 84, 141, 141, 1145]], "test": "valid"}
{"id": "Nsl3Dl", "name": "Quadratic Bezier to \"y=\"", "author": "oneshade", "description": "Solving for the y coordinate of a quadratic bezier. The same process can be applied to other parametrics, take the inverse of the x component and plug it into the y component as the parameter.", "tags": ["bezier", "1d", "de", "quadratic", "inverse", "parametric"], "likes": 1, "viewed": 65, "published": "Public", "date": "1616747469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// There are two roots, you can only choose one (k = -1 or k = 1)\nvec2 yBezier(in float x, in float k, in vec2 a, in vec2 b, in vec2 c) {\n    float c1 = a.x - 2.0 * b.x + c.x;\n    float c2 = 2.0 * (b.x - a.x);\n    float c3 = a.x - x;\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        float t = (sqrt(discr) * k - c2) / c1 * 0.5, tInv = 1.0 - t;\n        if (abs(t - 0.5) < 0.5) return vec2(a.y * tInv * tInv + 2.0 * b.y * tInv * t + c.y * t * t, 1.0);\n        return vec2(0.0);\n    }\n\n    return vec2(0.0);\n}\n\n// Derivative (mainly for distance estimation)\nvec2 dBezier(in float x, in float k, in vec2 a, in vec2 b, in vec2 c) {\n    float c1 = a.x - 2.0 * b.x + c.x;\n    float c2 = 2.0 * (b.x - a.x);\n    float c3 = a.x - x;\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        float sq = sqrt(discr);\n\n        float t = (sq * k - c2) / c1 * 0.5;\n        if (abs(t - 0.5) < 0.5) { // In the range [0, 1]\n            float u = 2.0 * (a.y * (t - 1.0) + b.y * (1.0 - 2.0 * t) + c.y * t);\n            float v = u * k / sq;\n            return vec2(v, 1.0);\n        }\n\n        return vec2(0.0);\n    }\n\n    return vec2(0.0);\n}\n\nvec3 xMaxBezier(in vec2 a, in vec2 b, in vec2 c) {\n    float t = (a.x - b.x) / (a.x - 2.0 * b.x + c.x), tInv = 1.0 - t;\n    if (abs(t - 0.5) < 0.5) return vec3(a * tInv * tInv + 2.0 * b * tInv * t + c * t * t, 1.0);\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c2, s3) * 0.5;\n    vec2 b = vec2(s1, s2) * 0.5;\n    vec2 c = vec2(c3, c1) * 0.5;\n\n    // First part (k = 1)\n    vec2 dx = dBezier(uv.x, 1.0, a, b, c);\n    if (dx.y > 0.0) {\n        vec2 de = abs(uv.y - yBezier(uv.x, 1.0, a, b, c)) / sqrt(1.0 + dx * dx);\n        draw(de.x - 0.01, vec3(1.0, 0.5, 0.0));\n    }\n\n    // Second part (k = -1)\n    dx = dBezier(uv.x, -1.0, a, b, c);\n    if (dx.y > 0.0) {\n        vec2 de = abs(uv.y - yBezier(uv.x, -1.0, a, b, c)) / sqrt(1.0 + dx * dx);\n        draw(de.x - 0.01, vec3(0.0, 0.0, 1.0));\n    }\n\n    draw(sdLine(uv, a, b), vec3(1.0));\n    draw(sdLine(uv, b, c), vec3(1.0));\n\n    vec3 xMax = xMaxBezier(a, b, c);\n    if (xMax.z > 0.0) draw((length(uv - xMax.xy) - 0.02) + 0.01 * sin(iTime * 10.0), vec3(1.0, 0.0, 0.0));\n\n    draw(length(uv - a) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - b) - 0.01, vec3(1.0, 1.0, 0.0));\n    draw(length(uv - c) - 0.01, vec3(1.0, 1.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsl3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 115, 115, 223], [225, 291, 362, 362, 757], [759, 806, 877, 877, 1390], [1392, 1392, 1442, 1442, 1631], [1633, 1633, 1688, 1688, 2973]], "test": "valid"}
{"id": "Nsl3W8", "name": "redpillbluepill", "author": "nvollo", "description": "test", "tags": ["test"], "likes": 1, "viewed": 49, "published": "Public", "date": "1616133818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float geo(int i, vec3 coords){\n    \n    if(i==0){\n        vec3 pos = vec3(0.,-1,20.);\n        vec3 q = abs(coords)-pos;\n        return length(max(q-vec3(2.,1.,2.),1.));\n    }\n    \n    //if(i==3) return distance(coords, vec3(sin(iTime)*0.7,cos(iTime)*0.2,sin(iTime)*0.2+3.))-1.;\n    if(i==3) return distance(coords, vec3(sin(iTime+coords.z)*0.5,cos(iTime)*0.2,sin(iTime)*0.2+3.))-1.;\n    if(i==2) return distance(coords, vec3(-sin(iTime+coords.z)*0.5,-cos(iTime)*0.2,sin(iTime)*0.2+3.))-1.;\n    \n    if(i==1) return distance(coords, vec3(-sin(iTime)*0.8,-cos(iTime)*0.2,sin(iTime)*0.2+2.44))-.4;\n    float xx = cos(iTime*4.)*0.03+sin(coords.x)*0.1;\n    float yy = sin(iTime*4.)*0.03;\n    if(i==4) return distance(coords, vec3(-sin(iTime)*0.84+xx,-cos(iTime)*0.2+yy,sin(iTime)*0.2+2.24))-.2;\n    \n    if(i==5) return distance(coords, vec3(sin(iTime)*0.8,cos(iTime)*0.2,sin(iTime)*0.2+2.44))-.4;\n    xx = -cos(iTime*4.)*0.03+sin(coords.x)*0.1;\n    //xx = mod(xx,2.);\n    yy = -sin(iTime*4.)*0.03;\n    if(i==6) return distance(coords, vec3(sin(iTime)*0.84+xx,cos(iTime)*0.2+yy,sin(iTime)*0.2+2.24))-.2;\n    \n}\n\nfloat sdf(vec3 coords){\n    float minimum=1000.;\n    for( int i = 0; i <= 5; i++){\n        minimum = min(minimum,geo(i, coords));\n    }\n    return min(minimum,.1);\n}\nfloat march(vec3 ro, vec3 rd, int limit){\n    float rlen = 0.;\n    for(int i = 0; i < limit; i ++ ){\n        float marchDistance = sdf(ro+(rlen*rd));\n        rlen += marchDistance;\n        if(marchDistance < 0.001){\n            return rlen;\n        }\n    }\n    return rlen;\n}\n\nvec3 getCol(vec3 col, vec3 coord){\n    if(geo(3,coord) < 0.001){\n        col.x += 2.;\n        col += -cos(iTime)*vec3(0.3,.3,.3);\n    }\n    if(geo(2,coord) < 0.01){\n        col *= vec3(1.0,1.0,2.);\n        col += -cos(iTime)*vec3(0.3,.3,.3);\n    }\n    if(geo(0,coord) < 0.01){\n        col += vec3(.01,.3,.3);\n    }\n    \n    if(geo(1,coord) < 0.01){\n        col += vec3(0.3,.3,.3);\n    }\n    \n    if(geo(4,coord) < 0.01){\n        col *= vec3(0.,.0,.8);\n        col -= cos(iTime)*vec3(0.3,.3,.3);\n    }\n    \n    if(geo(5,coord) < 0.01){\n        col += vec3(0.3,.3,.3);\n    }\n    \n    if(geo(6,coord) < 0.01){\n        col *= vec3(0.8,.0,.0);\n        col -= sin(iTime)*vec3(0.3,.3,.3);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv =((2.*fragCoord)-(iResolution.xy))/iResolution.y;\n\n    vec3 ro = vec3(0.,0.,1.);\n    \n    //point from uv image flat plane towards RayOrigin]\n    //ro is just 1 unit deep in z\n    vec3 rd = normalize(vec3(uv,0.)+ro);\n    \n    \n    \n    vec3 col = vec3(1.,0.,1.);// + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float rlen = march(ro,rd, 100);\n    \n    col *= rlen/2.;\n    col = getCol(col, ro+(rd*rlen));\n    \n    //dont worry be happy\n    if(rlen > 3. && (ro+(rlen*rd)).y < -1.){\n        col += vec3(.2,.2,.2);\n        float rlen = 0.;\n        bool refl = false;\n        for(int i = 0; i < 100; i ++ ){\n            float marchDistance = sdf(ro+(rlen*rd)*.8+vec3(0.,1.,-.2)+.1);\n            rlen += marchDistance;\n            if(marchDistance < 0.001){\n                refl=true;\n                break;\n            }\n        }\n        if(refl){\n            col = (getCol(col,ro+(rd*rlen)*.8+vec3(0.,1.,-.2)+.1)+vec3(5.))*0.09;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsl3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 1105], [1107, 1107, 1130, 1130, 1272], [1273, 1273, 1314, 1314, 1548], [1550, 1550, 1584, 1584, 2255], [2257, 2257, 2314, 2365, 3377]], "test": "error"}
{"id": "NslGRM", "name": "Eth dreamz", "author": "Shellderr", "description": "Eth dreams. heh.", "tags": ["ethereum"], "likes": 3, "viewed": 82, "published": "Public", "date": "1615690581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ft float\n#define num 20.\n\nfloat rand(vec2 v, float n){\n    return fract(n+sin(dot(fract((v+3.1415)*5545.7),v)));\n}\n\nfloat in_tri(ft x, ft y, ft x1, ft y1, ft x2, ft y2, ft x3, ft y3){\n\tft a = ((y2 - y3)*(x - x3) + (x3 - x2)*(y - y3)) / ((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3));\n\tft b = ((y3 - y1)*(x - x3) + (x1 - x3)*(y - y3)) / ((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3));\n\tft c = 1. - a - b;\n    return step(0.,a)*step(a, 1.)*step(0., b)*step(b, 1.)*step(0., c)*step(c, 1.);\n}\n\nvoid mainImage( out vec4 cc, in vec2 fc )\n{\n    vec2 uv = (2.*fc-iResolution.xy)/iResolution.y;\n\n    vec2 v = uv*num;\n    float t = iTime*.4;\n    vec2 vf = mix(vec2(rand(floor(v+t),t)), vec2(rand(floor(v+t+.5),t)), abs(fract(v)-.5)*2.);     \n    float cf = dot(vf,vec2(1.));\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float xedge = sin(iTime)*.7;   \n    ft f = in_tri(uv.x, uv.y, -xedge, .0, .0, .9, .0, .3);\n      f += in_tri(uv.x, uv.y, xedge, .0, .0, .3, .0, .9);\n      f += in_tri(uv.x, uv.y, -xedge, -.02, .0, -.32, .0, .28);\n      f += in_tri(uv.x, uv.y, xedge, -.02, .0, -.32, .0, .28);\n      f += in_tri(uv.x, uv.y, -xedge, -.1, .0, -.9, .0, -.4);\n      f += in_tri(uv.x, uv.y, xedge, -.1, .0, -.9, .0, -.4);\n\n    vec3 ccf = cos(t+vec3(2.5,2.2,1.3)*cf)*.5+.5;\n    ccf.y *= .4;\n    cc = vec4(ccf*(1.-f)+(f*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 62, 62, 122], [124, 124, 191, 191, 490], [492, 492, 535, 535, 1340]], "test": "valid"}
{"id": "NslGRN", "name": "Cube lines", "author": "morimea", "description": "Art shader.\n\nCineshader support [url]https://cineshader.com/view/NslGRN[/url]\n\nThis shader as Desktop wallpaper in linux:\n[b]for KDE[/b] [url]https://store.kde.org/p/1505365[/url]\n[b]for Gnome[/b] [url]https://www.gnome-look.org/p/1505898/[/url]", "tags": ["3d", "intersection", "art", "cineshader"], "likes": 378, "viewed": 30438, "published": "Public API", "date": "1615641551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Danil (2021+) https://twitter.com/AruGL\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// self https://www.shadertoy.com/view/NslGRN\n\n\n// --defines for \"DESKTOP WALLPAPERS\" that use this shader--\n// comment or uncomment every define to make it work (add or remove \"//\" before #define)\n\n\n// this shadertoy use ALPHA, NO_ALPHA set alpha to 1, BG_ALPHA set background as alpha\n// iChannel0 used as background if alpha ignored by wallpaper-app\n//#define NO_ALPHA\n//#define BG_ALPHA\n//#define SHADOW_ALPHA\n//#define ONLY_BOX\n\n\n// save PERFORMANCE by disabling shadow (about 2x less GPU usage)\n//#define NO_SHADOW\n\n\n// static CAMERA position, 0.49 on top, 0.001 horizontal\n//#define CAMERA_POS 0.049\n\n\n// speed of ROTATION\n#define ROTATION_SPEED 0.8999\n\n\n// static SHAPE form, default 0.5\n//#define STATIC_SHAPE 0.15\n\n\n// static SCALE far/close to camera, 2.0 is default, exampe 0.5 or 10.0\n//#define CAMERA_FAR 0.1\n\n\n// ANIMATION shape change\n//#define ANIM_SHAPE\n\n\n// ANIMATION color change\n//#define ANIM_COLOR\n\n\n// custom COLOR, and change those const values\n//#define USE_COLOR\nconst vec3 color_blue=vec3(0.5,0.65,0.8);\nconst vec3 color_red=vec3(0.99,0.2,0.1);\n\n\n// use 4xMSAA for cube only (set 2-4-etc level os MSAA)\n//#define AA_CUBE 4\n\n\n\n// --shader code--\n\n// Layers sorted and support transparency and self-intersection-transparency\n// Antialiasing is only dFd. (with some dFd fixes around edges)\n\n// using iq's intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n// using https://www.shadertoy.com/view/ltKBzG\n// using https://www.shadertoy.com/view/tsVXzh\n// using https://www.shadertoy.com/view/WlffDn\n// using https://www.shadertoy.com/view/WslGz4\n\n#define tshift 53.\n\n// reflect back side\n//#define backside_refl\n\n// Camera with mouse\n#define MOUSE_control\n\n// min(iFrame,0) does not speedup compilation in ANGLE\n#define ANGLE_loops 0\n\n\n// this shader discover Nvidia bug with arrays https://www.shadertoy.com/view/NslGR4\n// use DEBUG with BUG, BUG trigger that bug and one layer will be white on Nvidia in OpenGL\n//#define DEBUG\n//#define BUG\n\n#define FDIST 0.7\n#define PI 3.1415926\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(0.75, 0.75, 1.25)\n\n#define IOR 1.33\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nvec3 fcos(vec3 x) {\n    vec3 w = fwidth(x);\n    //if((length(w)==0.))return vec3(0.); // dFd fix2\n    //w*=0.; //test\n    float lw=length(w);\n    if((lw==0.)||isnan(lw)||isinf(lw)){vec3 tc=vec3(0.); for(int i=0;i<8;i++)tc+=cos(x+x*float(i-4)*(0.01*400./iResolution.y));return tc/8.;}\n    \n    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);\n}\n\n// rename to fcos\nvec3 fcos2( vec3 x){return cos(x);}\n\nvec3 getColor(vec3 p)\n{\n    // dFd fix, dFd broken on borders, but it fix only top level dFd, self intersection has border\n    //if (length(p) > 0.99)return vec3(0.);\n    p = abs(p);\n\n    p *= 01.25;\n    p = 0.5 * p / dot(p, p);\n#ifdef ANIM_COLOR\n    p+=0.072*iTime;\n#endif\n\n    float t = (0.13) * length(p);\n    vec3 col = vec3(0.3, 0.4, 0.5);\n    col += 0.12 * fcos(6.28318 * t * 1.0 + vec3(0.0, 0.8, 1.1));\n    col += 0.11 * fcos(6.28318 * t * 3.1 + vec3(0.3, 0.4, 0.1));\n    col += 0.10 * fcos(6.28318 * t * 5.1 + vec3(0.1, 0.7, 1.1));\n    col += 0.10 * fcos(6.28318 * t * 17.1 + vec3(0.2, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 31.1 + vec3(0.1, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 65.1 + vec3(0.0, 0.5, 0.8));\n    col += 0.10 * fcos(6.28318 * t * 115.1 + vec3(0.1, 0.4, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 265.1 + vec3(1.1, 1.4, 2.7));\n    col = clamp(col, 0., 1.);\n \n    return col;\n}\n\nvoid calcColor(vec3 ro, vec3 rd, vec3 nor, float d, float len, int idx, bool si, float td, out vec4 colx,\n               out vec4 colsi)\n{\n\n    vec3 pos = (ro + rd * d);\n#ifdef DEBUG\n    float a = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n    if (idx == 0)colx = vec4(1., 0., 0., a);\n    if (idx == 1)colx = vec4(0., 1., 0., a);\n    if (idx == 2)colx = vec4(0., 0., 1., a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n        if (idx == 0)colsi = vec4(1., 0., 0., ta);\n        if (idx == 1)colsi = vec4(0., 1., 0., ta);\n        if (idx == 2)colsi = vec4(0., 0., 1., ta);\n    }\n#else\n    float a = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n    //a=1.;\n    vec3 col = getColor(pos);\n    colx = vec4(col, a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n        //ta=1.;\n        col = getColor(pos);\n        colsi = vec4(col, ta);\n    }\n#endif\n}\n\n// xSI is self intersect data, fade to fix dFd on edges\nbool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,\n                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)\n{\n    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);\n    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);\n    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);\n    vec3 vd = vec3(ps.xy, ph.x);\n    t = -1.;\n    tsi = -1.;\n    si = false;\n    fade = 1.;\n    fadesi = 1.;\n    norm=vec3(0.,1.,0.);normsi=vec3(0.,1.,0.);\n\n    float tmp = 1.0 / (vb.y * vc.x);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = va.z * tmp;\n    float e = 0.0;\n    float f = 0.0;\n    float g = (vc.z * vb.y - vd.y * va.z) * tmp;\n    float h = (vb.z * vc.x - va.z * vd.x) * tmp;\n    float i = -1.0;\n    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;\n\n    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);\n    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +\n              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);\n    float r =\n        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;\n\n    if (abs(p) < 0.000001)\n    {\n        float tt = -r / q;\n        if (tt <= 0.)\n            return false;\n        t = tt;\n        // normal\n\n        vec3 pos = ro + t * rd;\n        if(length(pos)>sz)return false;\n        vec3 grad =\n            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n        norm = -normalize(grad);\n        return true;\n    }\n    else\n    {\n        float sq = q * q - 4.0 * p * r;\n        if (sq < 0.0)\n        {\n            return false;\n        }\n        else\n        {\n            float s = sqrt(sq);\n            float t0 = (-q + s) / (2.0 * p);\n            float t1 = (-q - s) / (2.0 * p);\n            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);\n            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);\n            float tt0 = tt1;\n            if (tt0 <= 0.)\n                return false;\n            vec3 pos = ro + tt0 * rd;\n            // black border on end of circle and self intersection with alpha come because dFd\n            // uncomment this to see or rename fcos2 to fcos\n            //sz+=0.3; \n            bool ru = step(sz, length(pos)) > 0.5;\n            if (ru)\n            {\n                tt0 = tt2;\n                pos = ro + tt0 * rd;\n            }\n            if (tt0 <= 0.)\n                return false;\n            bool ru2 = step(sz, length(pos)) > 0.5;\n            if (ru2)\n                return false;\n\n            // self intersect\n            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))\n            {\n                si = true;\n                fadesi=s;\n                tsi = tt2;\n                vec3 tpos = ro + tsi * rd;\n                // normal\n                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +\n                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);\n                normsi = -normalize(tgrad);\n            }\n            \n            fade=s;\n            t = tt0;\n            // normal\n            vec3 grad =\n                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n            norm = -normalize(grad);\n\n            return true;\n        }\n    }\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz);\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4 + ANGLE_loops; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in vec3 rad, in float sk ) \n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n\tvec3 rdd = rd;\n\tvec3 roo = ro;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 dr = 1.0 / rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 bgcol(in vec3 rd)\n{\n    return mix(vec3(0.01), vec3(0.336, 0.458, .668), 1. - pow(abs(rd.z+0.25), 1.3));\n}\n\nvec3 background(in vec3 ro, in vec3 rd , vec3 l_dir, out float alpha)\n{\n#ifdef ONLY_BOX\nalpha=0.;\nreturn vec3(0.01);\n#endif\n    float t = (-BOXDIMS.z - ro.z) / rd.z;\n    alpha=0.;\n    vec3 bgc = bgcol(rd);\n    if (t < 0.)\n        return bgc;\n    vec2 uv = ro.xy + t * rd.xy;\n#ifdef NO_SHADOW\n    float shad=1.;\n#else\n    float shad = boxSoftShadow((ro + t * rd), normalize(l_dir+vec3(0.,0.,1.))*rotz(PI*0.65) , BOXDIMS, 1.5);\n#endif\n    float aofac = smoothstep(-0.95, .75, length(abs(uv) - min(abs(uv), vec2(0.45))));\n    aofac = min(aofac,smoothstep(-0.65, 1., shad));\n    float lght=max(dot(normalize(ro + t * rd+vec3(0.,-0.,-5.)), normalize(l_dir-vec3(0.,0.,1.))*rotz(PI*0.65)), 0.0);\n    vec3 col = mix(vec3(0.4), vec3(.71,.772,0.895), lght*lght* aofac+ 0.05) * aofac;\n    alpha=1.-smoothstep(7.,10.,length(uv));\n#ifdef SHADOW_ALPHA\n    //alpha=clamp(alpha*max(lght*lght*0.95,(1.-aofac)*1.25),0.,1.);\n    alpha=clamp(alpha*(1.-aofac)*1.25,0.,1.);\n#endif\n    return mix(col*length(col)*0.8,bgc,smoothstep(7.,10.,length(uv)));\n}\n\n#define swap(a,b) tv=a;a=b;b=tv\n\nvec4 insides(vec3 ro, vec3 rd, vec3 nor_c, vec3 l_dir, out float tout)\n{\n    tout = -1.;\n    vec3 trd=rd;\n\n    vec3 col = vec3(0.);\n\n    float pi = 3.1415926;\n\n    if (abs(nor_c.x) > 0.5)\n    {\n        rd = rd.xzy * nor_c.x;\n        ro = ro.xzy * nor_c.x;\n    }\n    else if (abs(nor_c.z) > 0.5)\n    {\n        l_dir *= roty(pi);\n        rd = rd.yxz * nor_c.z;\n        ro = ro.yxz * nor_c.z;\n    }\n    else if (abs(nor_c.y) > 0.5)\n    {\n        l_dir *= rotz(-pi * 0.5);\n        rd = rd * nor_c.y;\n        ro = ro * nor_c.y;\n    }\n\n#ifdef ANIM_SHAPE\n    float curvature = (0.001+1.5-1.5*smoothstep(0.,8.5,mod((iTime+tshift)*0.44,20.))*(1.-smoothstep(10.,18.5,mod((iTime+tshift)*0.44,20.))));\n    // curvature(to not const above) make compilation on Angle 15+ sec\n#else\n#ifdef STATIC_SHAPE\n    const float curvature = STATIC_SHAPE;\n#else\n    const float curvature = .5;\n#endif\n#endif\n    float bil_size = 1.;\n    vec4 ps = vec4(-bil_size, -bil_size, bil_size, bil_size) * curvature;\n    vec4 ph = vec4(-bil_size, bil_size, bil_size, -bil_size) * curvature;\n    \n    vec4 [3]colx=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    vec3 [3]dx=vec3[3](vec3(-1.),vec3(-1.),vec3(-1.));\n    vec4 [3]colxsi=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    int [3]order=int[3](0,1,2);\n\n    for (int i = 0; i < 3 + ANGLE_loops; i++)\n    {\n        if (abs(nor_c.x) > 0.5)\n        {\n            ro *= rotz(-pi * (1. / float(3)));\n            rd *= rotz(-pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.z) > 0.5)\n        {\n            ro *= rotz(pi * (1. / float(3)));\n            rd *= rotz(pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.y) > 0.5)\n        {\n            ro *= rotx(pi * (1. / float(3)));\n            rd *= rotx(pi * (1. / float(3)));\n        }\n        vec3 normnew;\n        float tnew;\n        bool si;\n        float tsi;\n        vec3 normsi;\n        float fade;\n        float fadesi;\n\n        if (iBilinearPatch(ro, rd, ps, ph, bil_size, tnew, normnew, si, tsi, normsi, fade, fadesi))\n        {\n            if (tnew > 0.)\n            {\n                vec4 tcol, tcolsi;\n                calcColor(ro, rd, normnew, tnew, bil_size, i, si, tsi, tcol, tcolsi);\n                if (tcol.a > 0.0)\n                {\n                    {\n                        vec3 tvalx = vec3(tnew, float(si), tsi);\n                        dx[i]=tvalx;\n                    }\n#ifdef DEBUG\n                    colx[i]=tcol;\n                    if (si)colxsi[i]=tcolsi;\n#else\n\n                    float dif = clamp(dot(normnew, l_dir), 0.0, 1.0);\n                    float amb = clamp(0.5 + 0.5 * dot(normnew, l_dir), 0.0, 1.0);\n\n                    {\n#ifdef USE_COLOR\n                        vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                        const vec3 tcr = color_red;\n#else\n                        vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                        const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                        float ta = clamp(length(tcol.rgb),0.,1.);\n                        tcol=clamp(tcol*tcol*2.,0.,1.);\n                        vec4 tvalx =\n                            vec4((tcol.rgb*shad*1.4 + 3.*(tcr*tcol.rgb)*clamp(1.-(amb+dif),0.,1.)), min(tcol.a,ta));\n                        tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                        tvalx*=(min(fade*5.,1.));\n                        colx[i]=tvalx;\n                    }\n                    if (si)\n                    {\n                        dif = clamp(dot(normsi, l_dir), 0.0, 1.0);\n                        amb = clamp(0.5 + 0.5 * dot(normsi, l_dir), 0.0, 1.0);\n                        {\n#ifdef USE_COLOR\n                            vec3 shad = 0.57 * color_blue * amb + 1.5*color_blue.bgr * dif;\n                            const vec3 tcr = color_red;\n#else\n                            vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                            const vec3 tcr = vec3(1.,0.21,0.11);\n#endif\n                            float ta = clamp(length(tcolsi.rgb),0.,1.);\n                            tcolsi=clamp(tcolsi*tcolsi*2.,0.,1.);\n                            vec4 tvalx =\n                                vec4(tcolsi.rgb * shad + 3.*(tcr*tcolsi.rgb)*clamp(1.-(amb+dif),0.,1.), min(tcolsi.a,ta));\n                            tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                            tvalx.rgb*=(min(fadesi*5.,1.));\n                            colxsi[i]=tvalx;\n                        }\n                    }\n#endif\n                }\n            }\n        }\n    }\n    // transparency logic and layers sorting \n    float a = 1.;\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n    if (dx[1].x < dx[2].x){{vec3 swap(dx[1], dx[2]);}{int swap(order[1], order[2]);}}\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n\n    tout = max(max(dx[0].x, dx[1].x), dx[2].x);\n\n    if (dx[0].y < 0.5)\n    {\n        a=colx[order[0]].a;\n    }\n\n#if !(defined(DEBUG)&&defined(BUG))\n    \n    // self intersection\n    bool [3] rul= bool[3](\n        ((dx[0].y > 0.5) && (dx[1].x <= 0.)),\n        ((dx[1].y > 0.5) && (dx[0].x > dx[1].z)),\n        ((dx[2].y > 0.5) && (dx[1].x > dx[2].z))\n    );\n    for(int k=0;k<3;k++){\n        if(rul[k]){\n            vec4 tcolxsi = vec4(0.);\n            tcolxsi=colxsi[order[k]];\n            vec4 tcolx = vec4(0.);\n            tcolx=colx[order[k]];\n\n            vec4 tvalx = mix(tcolxsi, tcolx, tcolx.a);\n            colx[order[k]]=tvalx;\n\n            vec4 tvalx2 = mix(vec4(0.), tvalx, max(tcolx.a, tcolxsi.a));\n            colx[order[k]]=tvalx2;\n        }\n    }\n\n#endif\n\n    float a1 = (dx[1].y < 0.5) ? colx[order[1]].a : ((dx[1].z > dx[0].x) ? colx[order[1]].a : 1.);\n    float a2 = (dx[2].y < 0.5) ? colx[order[2]].a : ((dx[2].z > dx[1].x) ? colx[order[2]].a : 1.);\n    col = mix(mix(colx[order[0]].rgb, colx[order[1]].rgb, a1), colx[order[2]].rgb, a2);\n    a = max(max(a, a1), a2);\n    return vec4(col, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float osc = 0.5;\n    vec3 l_dir = normalize(vec3(0., 1., 0.));\n    l_dir *= rotz(0.5);\n    float mouseY = 1.0 * 0.5 * PI;\n#ifdef MOUSE_control\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n#endif\n#ifdef CAMERA_POS\n    mouseY = PI*CAMERA_POS;\n#else\n    mouseY = PI*0.49 - smoothstep(0.,8.5,mod((iTime+tshift)*0.33,25.))*(1.-smoothstep(14.,24.0,mod((iTime+tshift)*0.33,25.))) * 0.55 * PI;\n#endif\n#ifdef ROTATION_SPEED\n    float mouseX = -2.*PI-0.25*(iTime*ROTATION_SPEED+tshift);\n#else\n    float mouseX = -2.*PI-0.25*(iTime+tshift);\n#endif\n#ifdef MOUSE_control\n    mouseX+=-(iMouse.x / iResolution.x) * 2. * PI;\n#endif\n    \n#ifdef CAMERA_FAR\n    vec3 eye = (2. + CAMERA_FAR) * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#else\n    vec3 eye = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n#endif\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec4 tot=vec4(0.);\n#ifdef AA_CUBE\n    const int AA = AA_CUBE;\n    vec3 incol_once=vec3(0.);\n    bool in_once=false;\n    vec4 incolbg_once=vec4(0.);\n    bool bg_in_once=false;\n    vec4 outcolbg_once=vec4(0.);\n    bool bg_out_once=false;\n    for( int mx=0; mx<AA; mx++ )\n    for( int nx=0; nx<AA; nx++ )\n    {\n    vec2 o = vec2(mod(float(mx+AA/2),float(AA)),mod(float(nx+AA/2),float(AA))) / float(AA) - 0.5;\n    vec2 uv = (fragCoord + o - 0.5 * iResolution.xy) / iResolution.x;\n#else\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n#endif\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n\n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z/BOXDIMS.xy + ro.yz * ni.x/BOXDIMS.yz + ro.zx * ni.y/BOXDIMS.zx;\n    float fadeborders = (1.-smoothstep(0.915,1.05,abs(coords.x)))*(1.-smoothstep(0.915,1.05,abs(coords.y)));\n\n    if (t > 0.)\n    {\n        float ang = -iTime * 0.33;\n        vec3 col = vec3(0.);\n#ifdef AA_CUBE\n        if(in_once)col=incol_once;\n        else{\n        in_once=true;\n#endif\n        float R0 = (IOR - 1.) / (IOR + 1.);\n        R0 *= R0;\n\n        vec2 theta = vec2(0.);\n        vec3 n = vec3(cos(theta.x) * sin(theta.y), sin(theta.x) * sin(theta.y), cos(theta.y));\n\n        vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n        vec3 rdr = reflect(rd, nr);\n        float talpha;\n        vec3 reflcol = background(ro, rdr, l_dir,talpha);\n\n        vec3 rd2 = refract(rd, nr, 1. / IOR);\n\n        float accum = 1.;\n        vec3 no2 = ni;\n        vec3 ro_refr = ro;\n\n        vec4 [2] colo = vec4[2](vec4(0.),vec4(0.));\n\n        for (int j = 0; j < 2 + ANGLE_loops; j++)\n        {\n            float tb;\n            vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n            vec3 eye2 = vec3(coords2, -1.);\n            vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n\n            rd2trans.z = -rd2trans.z;\n            vec4 internalcol = insides(eye2, rd2trans, no2, l_dir, tb);\n            if (tb > 0.)\n            {\n                internalcol.rgb *= accum;\n                colo[j]=internalcol;\n            }\n\n            if ((tb <= 0.) || (internalcol.a < 1.))\n            {\n                float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                vec3 rout = ro_refr + tout * rd2;\n                vec3 rdout = refract(rd2, -no2, IOR);\n                float fresnel2 = R0 + (1. - R0) * pow(1. - dot(rdout, no2), 1.3);\n                rd2 = reflect(rd2, -no2);\n\n#ifdef backside_refl\n                if((dot(rdout, no2))>0.5){fresnel2=1.;}\n#endif\n                ro_refr = rout;\n                ro_refr.z = max(ro_refr.z, -0.999);\n\n                accum *= fresnel2;\n            }\n        }\n        float fresnel = R0 + (1. - R0) * pow(1. - dot(-rd, nr), 5.);\n        col = mix(mix(colo[1].rgb * colo[1].a, colo[0].rgb, colo[0].a)*fadeborders, reflcol, pow(fresnel, 1.5));\n        col=clamp(col,0.,1.);\n#ifdef AA_CUBE\n        }\n        incol_once=col;\n        if(!bg_in_once){\n        bg_in_once=true;\n        float alpha;\n        incolbg_once = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        incolbg_once.w = alpha;\n#endif\n        }\n#endif\n        \n        float cineshader_alpha = 0.;\n        cineshader_alpha = clamp(0.15*dot(eye,ro),0.,1.);\n        vec4 tcolx = vec4(col, cineshader_alpha);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = 1.;\n#endif\n        tot += tcolx;\n    }\n    else\n    {\n        vec4 tcolx = vec4(0.);\n#ifdef AA_CUBE\n        if(!bg_out_once){\n        bg_out_once=true;\n#endif\n        float alpha;\n        tcolx = vec4(background(eye, rd, l_dir, alpha), 0.15);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n        tcolx.w = alpha;\n#endif\n#ifdef AA_CUBE\n        outcolbg_once=tcolx;\n        }else tcolx=max(outcolbg_once,incolbg_once);\n#endif\n        tot += tcolx;\n    }\n#ifdef AA_CUBE\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = tot;\n#ifdef NO_ALPHA\n    fragColor.w = 1.;\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\n#if defined(BG_ALPHA)||defined(ONLY_BOX)||defined(SHADOW_ALPHA)\n    fragColor.rgb=fragColor.rgb*fragColor.w+texture(iChannel0, fragCoord/iResolution.xy).rgb*(1.-fragColor.w);\n#endif\n    //fragColor=vec4(fragColor.w);\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslGRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1928, 2283, 2302, 2302, 2407], [2408, 2408, 2427, 2427, 2530], [2531, 2531, 2550, 2550, 2654], [2656, 2656, 2675, 2675, 2998], [3000, 3018, 3038, 3038, 3053], [3055, 3055, 3078, 3221, 3976], [3978, 3978, 4116, 4116, 5017], [5019, 5075, 5284, 5284, 8650], [8652, 8652, 8677, 8677, 8696], [8698, 8698, 8763, 8763, 9247], [9249, 9249, 9323, 9323, 9896], [9898, 9898, 9972, 9972, 10509], [10511, 10511, 10535, 10535, 10622], [10624, 10624, 10695, 10695, 11655], [11690, 11690, 11762, 11762, 17696]], "test": "error"}
{"id": "NsS3Rm", "name": "space rainbows", "author": "tripzilch", "description": "It was just a color out of space ...", "tags": ["space", "rainbows"], "likes": 4, "viewed": 84, "published": "Public", "date": "1617112097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n#define phase3 vec3(0.0, 2.0943951023931953, 4.1887902047863905)\n#define gamma vec3(2.2)\n#define igamma vec3(0.454545)\n\nvec3 florp(float a, float p) {\n    // this one maps the color\n    // a = brightness\n    // p = mushrooms\n    float b = clamp(2.*a - 1.,0.,1.); b *= b; b *= b; b *= b;\n    vec3 res = pow(vec3(2.*a - a * a, a * a, b), gamma); // sRGB stands for stupid RGB\n    vec3 f = (1. + sin(phase3 + p)) * 0.333333333;\n    return res.bgr * f.x + res.rbg * f.y + res.rgb * f.z;\n}\n\nfloat onk(vec2 uv, float t) {\n    // this one makes a wobbly function over t, ranged -1 .. 1\n    float bx = uv.x * -3.13 + 2.04 * sin(uv.y * -2.3 + 1.3 * t) - 0.5* t;\n    float by = uv.y * 4.17 - 1.73 * sin(uv.x * 2.5 - 0.7 * t) + 0.9 * t;\n    return .5 * (sin(bx) + sin(by));\n}\n\nfloat unk(vec2 uv, float t) {\n    // this one ALSO makes a wobbly function over t, ranged 0 .. 1\n    float cx = uv.x * 2.23 - 3.33 * sin(uv.y * -1.3 + 0.3 * t) - 0.4* t;\n    float cy = uv.y * -1.41 + 3.15 * sin(uv.x * 1.5 + 0.4 * t) + 0.1 * t;\n    return .5 + .25 * (sin(cx) + sin(cy));\n}\n\nconst vec3 H3 = vec3(0.5497004779019702, 0.671043606703789, 0.8191725133961644);\nfloat space(vec2 uv, float t,float seed) {\n    uv += vec2(271., 497.) * seed; // space is far--it's not\n    uv.x += t * 15.;\n    vec2 ij = floor(uv), fg = uv - ij - .5;\n    float idx = 57. * ij.y + ij.x + seed + .5;\n    vec3 cr = fract(777. * sin(555. * fract(idx * H3)));\n    fg += (cr.xy - .5) * .8;\n    fg *= 5.;\n    return smoothstep(.5, .45, length(fg)) * step(.8, cr.z);\n}\n\nconst vec2 cos_plz = vec2(0, 0.25); // actually forgot to multiply by TAU, but now it is what it is\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1) (??)\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * aspect;\n    uv *= 1.2; // scale\n    float t = iTime * 0.2; // global speed\n    vec2 ee = vec2(4.35, -5.33); // bonus numbers\n    float c = unk(uv * vec2(0.43, -0.53), t); // weirdness amount\n    vec2 trun = sin(cos_plz + c * 8. + t * 0.61); \n    vec2 wp = uv + trun;\n    vec2 wq = uv - trun;\n    float lava = 3. * onk(wp, t) * (1. + onk((wq + ee * c) * 0.618, t * .7)); // left as exercise for the reader\n    float hi = 1.000420 + .7 * c; // how high we are \n    float a = smoothstep(-1., hi, lava); // brightness\n    float hole = smoothstep(hi + .02, hi, lava); // no more brightness\n    hole = max(0., hole - .4 * smoothstep(0., -1., lava));\n\n    float scifi = min(1., // four space, please\n          space(uv*5., t, 81.) \n        + space(uv*10., t, 72.)\n        + space(uv*15., t, 63.)\n        + space(uv*20., t, 54.)\n        );\n    vec3 col = florp(a, c * 12. + 2.5 * t);\n    col = mix(vec3(scifi), col, hole); // put everything together\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(igamma)),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 180, 254, 514], [516, 516, 545, 608, 794], [796, 796, 825, 892, 1084], [1167, 1167, 1209, 1209, 1545], [1583, 1648, 1703, 1758, 2881]], "test": "valid"}
{"id": "NsS3Rw", "name": "Calibration", "author": "iq", "description": "Calibration", "tags": ["2d", "calibration"], "likes": 30, "viewed": 795, "published": "Public API", "date": "1617095109", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2021\n\n\n// Useful calibration shader, not just for Shadertoy, but\n// for any renderer.\n//\n//\n// 1. checks that all pixels are rendered,\n//    including first and last rows and columns, in orange\n//\n// 2. checks that there's no pixel interpolation happening\n//    in the canvas (1x1 checkerboard in bottom left corner)\n//\n// 3. checks that gamma in fine (no circles should be visible\n//    in the image)\n//\n// 4. checks resolution\n//\n// 5. checks no frames are skipped (every box should be\n//    ticked/highlighted exactly once at the appropriate\n//    framerate column)\n\n//-----------------------------------------------------------------\n\nfloat PrintDigit(in int n, in vec2 p)\n{\t\t\n    // digit bitmap by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    const int lut[10] = int[10](480599,139810,476951,476999,71028,464711,464727,476228,481111,481095);\n    \n\tivec2 xy = ivec2(p*vec2(4,5));\n\tint   id = 4*xy.y + xy.x;\n    return float( (lut[n]>>id) & 1 );\n}\n\nfloat PrintInt(const in vec2 uv, in int value )\n{\n    float res = 0.0;\n\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        float maxDigits = (value==0) ? 1.0 : floor(1.0+log2(float(value))/log2(10.0));\n        float digitID = floor(uv.x);\n        if( digitID>=0.0 && digitID<maxDigits )\n        {\n            float digitVa = mod( floor(float(value)/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n            res = PrintDigit( int(digitVa), vec2(fract(uv.x), uv.y) );\n        }\n    }\n\treturn res;\t\n}\n\nfloat PrintIntN(const in vec2 uv, in int value, in int maxDigits )\n{\n    float res = 0.0;\n\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int digitID = int(floor(uv.x));\n        if( digitID>=0 && digitID<maxDigits )\n        {\n            float digitVa = mod( floor(float(value)/pow(10.0,float(maxDigits-1-digitID)) ), 10.0 );\n            res = PrintDigit( int(digitVa), vec2(fract(uv.x), uv.y) );\n        }\n    }\n\treturn res;\t\n}\n\n//-----------------------------------------------------------------\n\nvec3 pat1( in vec2 pixel, in vec2 res )\n{\n    vec2  uv = pixel/res.y;\n    \n    vec2 p = floor(pixel*exp2(-floor(6.0*uv.y)) );\n\n    float col = mod( p.x + p.y, 2.0 );\n    col *= smoothstep(0.005,0.010,abs(fract(6.0*uv.y+0.5)-0.5));\n    \n    return vec3( col );\n}\n\nvec3 pat2( in vec2 pixel, in vec2 res )\n{\n    vec2 uv = (2.0*pixel-res)/res.y;\n    float h = res.y*0.8;\n    \n    vec3 col = vec3(0.2);\n    \n    if( pixel.y<h )\n    {\n        col = vec3( pixel.y/h );\n\n        if( uv.x>0.0 )\n        {\n            vec2 p = floor(pixel);\n            float f = mod( p.x +p.y, 2.0 );\n\n            const float gamma = 2.3;\n            float midgrey = pow( 0.5, 1.0/gamma );\n\n            f = mix( midgrey,  f, smoothstep(0.1,0.101,length(vec2(uv.x,(fract(3.0*uv.y+0.5)-0.5)/3.0)-vec2(0.5*res.x/res.y,0.0))) );\n\n            col = vec3(f);\n        }\n    }\n    else\n    {\n        vec2 q = vec2(uv.x,uv.y-0.9);\n        q = 0.707*abs(vec2(q.x+q.y,-q.y+q.x));\n        q = (q.y<q.x)?q.yx:q;\n        q -= vec2(0.01,0.05);\n        float t = step( max(q.x,q.y), 0.0 );\n        \n        t += PrintInt( (uv-vec2(-0.5,0.85))*10.0, int(iResolution.x) );\n        t += PrintInt( (uv-vec2( 0.1,0.85))*10.0, int(iResolution.y) );\n\n        int ideg = int(iTime*60.0);\n        int degs = (ideg   ) % 60;\n        int secs = (ideg/60) % 60;\n        int mins = (ideg/3600) % 60;\n        t += PrintIntN( (uv-vec2(-0.3,0.67))*10.0, mins, 2 );\n        t += PrintIntN( (uv-vec2( 0.0,0.67))*10.0, secs, 2 );\n        t += PrintIntN( (uv-vec2( 0.3,0.67))*10.0, degs, 2 );\n        \n        // draw : :\n        q = vec2( abs(uv.x-0.087)-0.147,abs(uv.y-0.72)-0.035);\n        q = abs(q)-0.01;\n        t += step( max(q.x,q.y), 0.0 );\n\n        col = mix( col, vec3(1.0,0.5,0.0), t );\n    }\n\n\n    return col;\n}\n\nvec3 pat3( in vec2 pixel, in vec2 res )\n{\n    float v = pixel.y/res.y;\n    \n    int fps = 10;\n    if( pixel.x>res.x*1.0/5.0 ) fps =  15;\n    if( pixel.x>res.x*2.0/5.0 ) fps =  30;\n    if( pixel.x>res.x*3.0/5.0 ) fps =  60;\n    if( pixel.x>res.x*4.0/5.0 ) fps = 120;\n    int id = int(floor(v*float(fps)));\n    \n    float f = 0.2+0.2*float(id&1);\n    \n    vec3 col = vec3(f);\n\n    if( (int(iTime*float(fps))%fps)==id ) col = vec3(1.0);\n\n    col *= smoothstep(0.01,0.02,abs(fract(5.0*pixel.x/res.x+0.5)-0.5));\n\n    \n    vec2 q = vec2( mod(pixel.x,res.x/5.0)-res.x/64.0,pixel.y-res.y*0.97);\n    float t = PrintInt( q/res.y*50.0, fps );\n    \n    col = mix( col, vec3(1.0,0.5,0.0), t );\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x0 = iResolution.x*0.0/3.0;\n    float x1 = iResolution.x*1.0/3.0;\n    float x2 = iResolution.x*2.0/3.0;\n    float wi = iResolution.x/3.0;\n    \n    vec3                 col = pat1(fragCoord-vec2(x0,0.0),vec2(wi,iResolution.y));\n    if( fragCoord.x>x1 ) col = pat2(fragCoord-vec2(x1,0.0),vec2(wi,iResolution.y));\n    if( fragCoord.x>x2 ) col = pat3(fragCoord-vec2(x2,0.0),vec2(wi,iResolution.y));\n\n    col *= smoothstep( 2.0, 4.0, mod(fragCoord.x,wi) );\n\n    ivec2 p = ivec2(fragCoord);\n    ivec2 r = ivec2(iResolution);\n    if( p.x==0 || p.y==0 || p.x==(r.x-1)  || p.y==(r.y-1) ) col = vec3(1.0,0.5,0.0);\n\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[602, 671, 710, 783, 990], [992, 992, 1041, 1041, 1477], [1479, 1479, 1547, 1547, 1902], [1904, 1973, 2014, 2014, 2234], [2236, 2236, 2277, 2277, 3735], [3737, 3737, 3778, 3778, 4440], [4443, 4443, 4500, 4500, 5146]], "test": "error"}
{"id": "Nss3WB", "name": "Fractal 42_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 3, "viewed": 211, "published": "Public API", "date": "1616483981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=1.;\n        ++i<80.;\n        O.xyz+=.04*abs(cos(d+log(s)*.3))*exp(-i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=mix(.5,10.,step(.5,fract(iTime*.1)));\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=1.5;\n        for(int j=0;j++<12;)\n            p=sign(p)*(1.5-abs(p-1.5)),\n            p=p*(e=8./clamp(dot(p,p),.5,5.))+q,s*=e;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nss3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 591]], "test": "valid"}
{"id": "NssGDf", "name": "Crash test for \"Gold Noise\"", "author": "sciroccorics", "description": "This shader illustrates the strong weakness of the \"Gold Noise\" generator by\nDominic Cesarino (dcerisano@standard3d.com)\nsee https://www.shadertoy.com/view/ltB3zD\n\nThis random generator creates visible color bandings and Moire patterns", "tags": ["noise", "random", "generator"], "likes": 1, "viewed": 177, "published": "Public", "date": "1616667657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Crash test for the so-called \"Gold Noise\"\n//\n// This shader illustrates the strong weakness\n// of the \"Gold Noise\" generator written by\n// Dominic Cesarino (dcerisano@standard3d.com)\n// see https://www.shadertoy.com/view/ltB3zD\n\n// This random generator creates strong visible color\n// bandings and Moire patterns, as soon as you leave\n// the area near (0,0) for the pixel coordinates. This\n// mainly comes from the tangent function which become\n// numerically instable for large values. To emphasize\n// the phenomenon, I simply used some larger values\n// for the seeds (100, 300, 500), instead of the small\n// ones (1, 2, 3) that were used in the original shader\n// to hide this major defect\n\n// Click on the 'Full Screen' icon to show it even better\n\n// --------------------------------------------------------------\n// Original code from https://www.shadertoy.com/view/ltB3zD\n\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n\nconst float PHI = 1.61803398874989484820459; // Φ = Golden Ratio \n\nfloat gold_noise(in vec2 xy, in float seed) {\n  return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n// ---------------------------------------------------------------\n// My simple crash test to illustrate bandings and Moire patterns:\n// simply choose some large seeds to create numerical instability\n// for the tangent function (of course, things are even worse on\n// low-precision devices, such as mobile SoCs)\n\nvoid mainImage(out vec4 color, in vec2 pos) {\n  color = vec4(gold_noise(pos, fract(iTime)+100.0),\n               gold_noise(pos, fract(iTime)+300.0),\n               gold_noise(pos, fract(iTime)+500.0),\n               1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1117, 1140, 1185, 1185, 1240], [1242, 1555, 1600, 1600, 1779]], "test": "valid"}
{"id": "NssGDH", "name": "Piz Gloria With Helicopter", "author": "dr2", "description": "Perhaps Mr. Bond is trying to land on the Schilthorn?", "tags": ["snow", "mountain", "flight", "building"], "likes": 11, "viewed": 247, "published": "Public API", "date": "1615884859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Piz Gloria With Helicopter\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Perhaps Mr. Bond is trying to land on the Schilthorn?\n\n// Note: high frame rate needed to avoid rotor artifacts (alternative is semi-opaque\n// disk, as for propellers in e.g. \"River Flight 2\").\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, sunDir, qHit;\nvec2 csRotor;\nfloat tCur, dstFar, grndScl, bldgScl, heliScl;\nint idObj;\nbool isSh;\nconst int idPk = 1, idBldg = 2, idWin = 3, idPol = 4, idBase = 5, idBaseH = 6, idBrg = 7,\n   idHeli = 11, idRotorM = 12, idRotorT = 13, idSkd = 14;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndDf (vec3 p)\n{   // (annular mountains from \"Mountain Lake with Tower\")\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 22.;\n    h = 6. * s * mix (Fbm2 (f * vec2 (s, a + 1.)), Fbm2 (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - mix (4. * s, h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, r, s;\n  dMin /= heliScl;\n  p /= heliScl;\n  if (! isSh) d = PrRoundBoxDf (p - vec3 (0., 0.5, -1.2), vec3 (4.5, 2., 5.5), 0.1);\n  if (isSh || d < 0.1) {\n    q = p;\n    r = 1.;\n    if (q.z < -0.1) {\n      s = (q.z + 0.1) * (q.z + 0.1);\n      r *= 1. - 0.1 * s;\n      q.y -= 0.05 * s;\n    } else if (q.z > 0.1) {\n      s = (q.z - 0.1) * (q.z - 0.1);\n      r *= 1. - 0.03 * s;\n    }\n    q.x *= 0.8;\n    d = PrCapsDf (q, max (r, 0.), 2.);\n    q = p;\n    q.yz = Rot2D (q.yz - vec2 (1.1, -4.2), -0.05 * pi);\n    r = 0.2 * (1. + 0.25 * q.z);\n    q.y *= 0.7;\n    d = min (d, PrCapsDf (q, r, 1.5));\n    q = p;\n    q.yz -= vec2 (1.7, -0.2);\n    d = min (d, PrCylDf (q.xzy, 0.4, 0.4));\n    q = p;\n    q.yz -= vec2 (0.4, -1.);\n    r = 1.1;\n    if (q.z < 0.) {\n      s = q.z * q.z;\n      r *= 1. - 0.2 * s;\n      q.y -= 0.1 * s;\n    }\n    q.y *= 0.8;\n    d = SmoothMin (d, PrCapsDf (q, max (r, 0.), 1.5), 0.03);\n    q = p;\n    q.yz -= vec2 (1.4, -6.15);\n    d = min (d, max (PrRoundCylDf (q.yzx, 0.5, 0.05, 0.02), 0.35 - length (q.yz)));\n    DMIN (idHeli);\n    if (! isSh) {\n      q.yz = Rot2Cs (q.yz, csRotor);\n      d = PrRoundBoxDf (q, vec3 (0.01, 0.32, 0.04), 0.02);\n      DMIN (idRotorT);\n    }\n    q = p;\n    q.yz -= vec2 (2., -0.2);\n    d = PrCylDf (q.xzy, 0.12, 0.5);\n    if (! isSh) {\n      q.y -= 0.4;\n      q.xz = Rot2Cs (q.xz, csRotor);\n      d = min (d, PrRoundBoxDf (q, vec3 (4.5, 0.02, 0.08), 0.03));\n    }\n    DMIN (idRotorM);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.9, -1.4);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.01, 1.4), 0.04);\n    q.xy = Rot2D (q.xy, -0.1 * pi);\n    q.z = abs (q.z);\n    q.yz -= vec2 (0.4, 0.7);\n    d = min (d, PrCylDf (q.xzy, 0.06, 0.4));\n    DMIN (idSkd);\n    dMin *= 0.7;\n  } else dMin = min (dMin, d);\n  return heliScl * dMin;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, hPk, hb, bs;\n  p /= bldgScl;\n  dMin /= bldgScl;\n  hPk = 6.;\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.8, 0.5 * hPk);\n  a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (33. * a + 0.5) / 33.);\n  q.xy = Rot2D (q.xy, -0.2 * pi);\n  d = length (q.xz) - 3.3 + p.y * (hPk - p.y) / (hPk * hPk) -\n     0.5 * Fbm2 (vec2 (32. * mod (a + 0.5, 1.), 0.8 * q.y));\n  d = SmoothMax (d, p.y - hPk, 0.1);\n  hb = 0.6;\n  q = p;\n  q.y -= -0.11;\n  d = 0.8 * SmoothMin (d, PrCylDf (q.xzy, 10., 0.1), 0.5);\n  DMINQ (idPk);\n  q = p;\n  q.xy -= vec2 (1.4, hPk + hb + 0.3);\n  d = PrCapsDf ((q - vec3 (0., 0.8, 0.)).xzy, 0.03, 0.1);\n  DMINQ (idPol);\n  q.xz = Rot2D (q.xz, 2. * pi * floor (8. * (atan (q.z, - q.x) / (2. * pi) + 0.5) + 0.5) / 8.);\n  bs = dot (q.xy, sin (0.04 * pi + vec2 (0.5 * pi, 0.))) - 0.9;\n  d = SmoothMax (bs, max (- PrRoundBox2Df (q.yz - vec2 (-0.12, 0.), vec2 (0.47, 0.27 - 0.03 * q.y), 0.02),\n     dot (q.yx, sin (0.08 * pi + vec2 (0.5 * pi, 0.))) - hb - 0.08), 0.02);\n  DMINQ (idBldg);\n  d = min (d, max (bs + 0.02, abs (q.y + 0.1) - 0.5));\n  DMINQ (idWin);\n  hb = 0.1;\n  q = p;\n  q.xy -= vec2 (1.4, hPk + hb);\n  d = PrRoundCylDf (q.xzy, 1.4, 0.02, hb - 0.02);\n  DMINQ (idBase);\n  q = p;\n  q.xy -= vec2 (-1.5, hPk + hb);\n  d = PrRoundCylDf (q.xzy, 1., 0.02, hb - 0.02);\n  DMINQ (idBaseH);\n  q = p;\n  q.y -= hPk + 1.5 * hb;\n  d = PrRoundBoxDf (q, vec3 (1., 0.5 * hb, 0.2) - 0.02, 0.02);\n  DMINQ (idBrg);\n  return bldgScl * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = FlyerDf (flMat * (p - flPos), dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.1, h);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.005 * (ro.xz + 5. * tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  float a;\n  a = atan (ro.z, - ro.x);\n  col4 = vec4 (0.9, 0.9, 0.9, 0.3);\n  if (ro.y > 0.) {\n    col4 = mix (col4, vec4 (0.85, 0.85, 0.85, 0.1), smoothstep (0.1, 0.25, 1. - vn.y));\n    col4 = mix (col4, vec4 (0.75, 0.75, 0.75, 0.1), smoothstep (0.25, 0.6, 1. - vn.y));\n    col4 = mix (col4, vec4 (1., 1., 1., 0.4), smoothstep (0.65, 0.95, ro.y / grndScl +\n       0.2 * sin (8. * a)));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstGrnd, dstObj, sh;\n  bool isRefl;\n  csRotor = sin (10.3 * pi * tCur + vec2 (0.5 * pi, 0.));\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  isRefl = false;\n  if (dstObj < dstFar && idObj == idWin) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  dstGrnd = GrndRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (32. * ro / grndScl, vn, 1.);\n      col4 = GrndCol (ro, vn);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj < idHeli) {\n        if (idObj == idPk) {\n          vn = VaryNf (32. * ro, vn, 0.5);\n          col4 = mix (vec4 (0.6, 0.6, 0.6, 0.1), vec4 (1., 1., 1., 0.2), smoothstep (0.2, 0.6, vn.y)) *\n             (1. - 0.05 * Noisefv2 (8. * ro.xz));\n          qHit = ro / bldgScl;\n          col4 *= 0.6 + 0.4 * smoothstep (0., 0.1, min (length (qHit.xz - vec2 (1.4, 0.)) - 1.4,\n             length (qHit.xz - vec2 (-1.5, 0.)) - 1.));\n        } else if (idObj == idBldg) {\n          col4 = vec4 (0.7, 0.7, 0.6, 0.1) * (0.93 + 0.07 * sin (64. * pi * qHit.y));\n        } else if (idObj == idPol) {\n          col4 = vec4 (0.7, 0.7, 0.6, 0.1);\n        } else if (idObj == idBase || idObj == idBaseH || idObj == idBrg) {\n          col4 = vec4 (0.6, 0.6, 0.65, 0.) * (1. - 0.05 * Noisefv2 (16. * ro.xz));\n          if (idObj != idBrg) col4 *= 0.9 + 0.1 * sin (64. * pi * qHit.y);\n          if (idObj == idBaseH) {\n            qHit.xz = abs (qHit.xz);\n            col4 = mix (vec4 (1., 1., 0.5, 0.1), col4, smoothstep (0., 0.02,\n               min (max (qHit.x - 0.4, abs (qHit.z - 0.3)), max (qHit.x, qHit.z - 0.3)) - 0.07));\n          }\n        }\n      } else {\n        qHit = flMat * (ro - flPos) / heliScl;\n        if (idObj == idHeli) {\n          col4 = mix (vec4 (1., 1., 0., 0.2), vec4 (0.8, 0., 0., 0.2),\n             smoothstep (0., 0.02, abs (qHit.y) - 0.04));\n          if (length (vec2 (qHit.x, qHit.y / 0.8)) > 1.24 && qHit.y > 0.55 && qHit.z > 0.4 &&\n             abs (abs (qHit.x) - 0.3) > 0.05) col4 = vec4 (0., 0.5, 0.5, -1.);\n        } else if (idObj == idRotorM) {\n          col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n          if (length (qHit.xz - vec2 (0., -0.2)) > 4.2) col4 = vec4 (1., 1., 0.2, 0.1);\n        } else if (idObj == idRotorT) {\n          col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n          if (length (qHit.yz - vec2 (1.4, -6.15)) < 0.06) col4 = vec4 (1., 1., 0.2, 0.1);\n        } else if (idObj == idSkd) {\n          col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n        }\n      }\n    }\n    if (col4.a >= 0.) {\n      isSh = true;\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir, 0.5 * grndScl);\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else col = mix (col4.rgb, SkyCol (ro, reflect (rd, vn)), 0.8);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (isRefl) col = mix (col, vec3 (0., 1., 1.), 0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vd, cb, sb;\n  float flPit, flYaw, flRol, vh;\n  flPos = vec3 (-1.5 * bldgScl, 6.7 * bldgScl + 2.7 * (1. + sin (0.3 * t)), 0.);\n  vd.xz = Rot2D (vec2 (1., 0.), 1.8 * pi * sin (0.03 * pi * t));\n  vd.y = -0.07 * pi * cos (0.1 * pi * t);\n  vh = length (vd.xz);\n  if (vh > 0.) {\n    flPit = atan (vd.y, vh);\n    flYaw = 0.5 * pi - atan (vd.z, - vd.x);\n  } else {\n    flPit = 0.;\n    flYaw = 0.5 * pi;\n  }\n  flRol = 0.1 * sin (1. * t);\n  cb = cos (vec3 (flPit, flYaw, flRol));\n  sb = sin (vec3 (flPit, flYaw, flRol));\n  flMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.5 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2.2 * pi * mPtr.x;\n    el -= 0.3 * pi * mPtr.y;\n  } else {\n    az -= 2. * pi * SmoothBump (0.25, 0.75, 0.25, mod (0.01 * tCur, 1.));\n    el -= 0.04 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.15 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  bldgScl = 4.;\n  heliScl = 0.5;\n  FlyerPM (tCur);\n  ro = vuMat * vec3 (0., 0., -1.4) * grndScl;\n  ro.y += 0.22 * grndScl + 4. * bldgScl;\n  zmFac = 6. - 2. * cos (az + 0.5 * pi);\n  dstFar = 10. * grndScl;\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssGDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[192, 1358, 1381, 1438, 1835], [1837, 1837, 1871, 1871, 2362], [2364, 2364, 2386, 2386, 2642], [2644, 2644, 2680, 2680, 4470], [4472, 4472, 4507, 4507, 5990], [5992, 5992, 6014, 6014, 6135], [6137, 6137, 6170, 6170, 6374], [6376, 6376, 6397, 6397, 6652], [6654, 6654, 6703, 6703, 6955], [6957, 6957, 6989, 6989, 7524], [7526, 7526, 7559, 7559, 7978], [7980, 7980, 8015, 8015, 11144], [11146, 11146, 11170, 11170, 11882], [11899, 11899, 11955, 11955, 13366], [13368, 13368, 13414, 13414, 13461], [13463, 13463, 13510, 13510, 13557], [13559, 13559, 13601, 13601, 13652], [13654, 13654, 13697, 13697, 13770], [13772, 13772, 13829, 13829, 13905], [13907, 13907, 13952, 13952, 14055], [14057, 14057, 14102, 14102, 14140], [14142, 14142, 14199, 14199, 14282], [14284, 14284, 14320, 14320, 14526], [14528, 14528, 14558, 14558, 14671], [14673, 14673, 14704, 14704, 14768], [14802, 14802, 14826, 14826, 14938], [14940, 14940, 14965, 14965, 15151], [15153, 15153, 15174, 15174, 15329], [15331, 15331, 15360, 15360, 15572], [15574, 15574, 15613, 15613, 15793]], "test": "error"}
{"id": "NsX3WM", "name": "gradient_freq", "author": "imanishi", "description": " ", "tags": ["gradient"], "likes": 1, "viewed": 56, "published": "Public", "date": "1616006709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float frequency = 1.0;\n    //float index = uv.x + (iTime * 0.5) + uv.y;\n    float index = (uv.x * 0.5) + uv.y - (iTime * 0.3) ;\n    fragColor = sin(frequency * index + vec4(0,2,4,0)) * 0.2 + 0.8;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsX3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 301]], "test": "valid"}
{"id": "NsXGRB", "name": "origin of symmetry", "author": "Angramme", "description": "This is made to look more or less like the cover of MUSE Origin of Symmetry album.", "tags": ["cover", "originofsymmetry"], "likes": 10, "viewed": 84, "published": "Public", "date": "1616110006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/\nprecision highp float;\n\n\n#define MAX_STEPS 400\n#define MIN_DIST .0001\n#define MAX_DIST 300.\n\n#define BW .25\n#define GS 30.\n\n\nfloat r1(vec2 uv){\n\treturn texture(iChannel0, uv).r;\n\t}\nfloat dbox( vec3 p, vec3 b ){\n\tvec3 q = abs(p) - b;\n    return length(max(q,0.0))\n        + min(max(q.x,max(q.y,q.z)),0.0);\n}\n/*\nfloat antenna(vec3 p, vec3 s){\n\tfloat b1 = dbox(p-vec3(0,s.x,0),\n\t\t\tvec3(BW,s.x,BW));\n\t\t\t\tfloat b2 = dbox(p-vec3(0,s.x*2.,0),\n\t\t\t\t\t\tvec3(s.z, BW, BW));\n\tfloat b31 = dbox(p-vec3(s.z,s.x*2.+s.y,0),\n\t\t\tvec3(BW, s.y, BW));\n\t\t\t\tfloat b32 = dbox(p-vec3(-s.z,s.x*2.+s.y,0),\n\t\t\t\t\t\tvec3(BW, s.y, BW));\n\t\t\t\t\t\t\treturn min(min(b1, b2),min(b31,b32));\n\t\t\t\t\t\t\t}*/\nfloat antenna2(vec3 p){\n\tif(p.y < 16.){\n        return min(\n            dbox(p-vec3(0,8,0), vec3(BW,8,BW)),\n            dbox(p-vec3(0,16,0), vec3(2,BW,BW))\n        );\n    }else{\n        return min(min(\n                dbox(p-vec3(-2,21,0), vec3(BW,5,BW)),\n                dbox(p-vec3(02,21,0), vec3(BW,5,BW))\n            ),\n            dbox(p-vec3(0,16,0), vec3(2,BW,BW))\n        );\n    }\n}\nfloat dist(vec3 p){\n\tfloat plane = p.y;\n\tvec2 id = floor(p.xz/GS);\n\t\tvec3 ap = vec3(0);\n        ap.xz = id*GS + .5*GS;\n        /*float ant = antenna(p-ap,\n        vec3(\n        /*mix(1.,16.,r1(id*.7)),\n        mix(1.,8.,r1(id*.37)),\n        mix(2.,5.,r1(id*.43))\n        8.,5.,2.\n        ));*/\n        float ant = antenna2(p-ap);\n        return min(ant\n            +.06*sin(dot(p,vec3(.3,.4,.7))),\n            plane);\n}\n\nvec3 normal(vec3 p){\n\tvec2 e = vec2(.001, 0);\n    return (vec3(\n        dist(p+e.xyy),\n        dist(p+e.yxy),\n        dist(p+e.yyx)\n    )-dist(p))/e.x;\n}\n\nvec2 trace(vec3 ro, vec3 rd){\n\tfloat d0 = 0.;\n    float mn = MAX_DIST;\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + d0*rd;\n        float d = dist(p);\n        mn = min(mn, d);\n        d0 += d;\n        if(d<MIN_DIST || d0>MAX_DIST)break;\n    }\n    return vec2(d0, mn);\n}\nfloat sshadow(vec3 p, vec3 ld, float k, float maxd){\n\tfloat res = 1.;\n    for(float d0=0.; d0<maxd;){\n        float d = dist(p+ld*d0);\n        if(d<MIN_DIST)return 0.;\n        res = min(res,k*d/d0);\n        d0 += d;\n    }\n    return res;\n}\nvec3 material(vec3 p, vec3 rd){\n\t//vec3 color = vec3(0);\n\t//sun\n    //const vec3 sp = vec3(1000,500,-300);\n    const vec3 sc = vec3(1,.9,.9);\n\t//vec3 L = normalize(sp - p);\n    const vec3 L = normalize(vec3(10,5,-3));\n    vec3 n = normal(p);\n\t//stylized white floor\n    if(p.y<.1){\n        return vec3(trace(p+n*MIN_DIST*2., L).x<MAX_DIST ? 0. : 1.);\n        //return vec3(\n        //\tsshadow(p+n*MIN_DIST*2., L, 128., 999.));\n    }else{\n        //diffuse\n        //color += max(0.,dot(L, n))*sc;\n        return max(0.,dot(L, n))*sc*2.;\n    }\n    //return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t\t\t/ iResolution.x;\n\tvec3 color = vec3(0);\n\tvec3 ro = vec3(\n\t\t\tiTime*15.,\n\t\t\t\t\t4,\n\t\t\t\t\t\t\tsin(iTime*.5)*30.);\n\tvec3 rd = normalize(vec3(uv*1.5, 1));\n    rd.yz *= mat2(cos(0.15), sin(.15), -sin(.15), cos(.15));\n\t/*const float angle = -.5;\n    const float c = cos(angle);\n    const float s = sin(angle);\n    const mat2 rot = mat2(c, -s, s, c);*/\n    float angle = -.5 - (iMouse.x/iResolution.x-.5);\n    //float angle = -.5;\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    rd.xz *= rot;\n\tvec2 d = trace(ro, rd);\n\tif(d.x < MAX_DIST){\n        vec3 p = ro + rd*d.x;\n        color += material(p,rd);\n    }else{\n        color += vec3(1,.75,0);\n        color *= clamp(d.y, 0., 1.) < .1 ? 0. : 1.;\n    }\n\n\t//color += d*.001;\n\n\tfragColor = vec4(color, 1.0);\n}\n\t\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 427, 445, 445, 482], [483, 483, 512, 512, 608], [609, 961, 984, 984, 1351], [1352, 1352, 1371, 1371, 1771], [1773, 1773, 1793, 1793, 1926], [1928, 1928, 1957, 1957, 2211], [2212, 2212, 2264, 2264, 2451], [2452, 2452, 2483, 2558, 3016], [3018, 3018, 3074, 3074, 3908]], "test": "error"}
{"id": "NsXGRn", "name": "Dark aura", "author": "rmdms", "description": "Hope this will inspires someone", "tags": ["noise", "white", "black"], "likes": 4, "viewed": 57, "published": "Public", "date": "1615343389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n|--------------------------------------------------------------------------\n| Rémy Dumas\n|--------------------------------------------------------------------------\n|\n| Twitter: @remsdms\n| Portfolio: remydumas.fr\n|\n*/\n\n/*\n|--------------------------------------------------------------------------\n| Simplex 3D Noise\n|--------------------------------------------------------------------------\n|\n| by Ian McEwan, Ashima Arts\n|\n*/\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  float n_ = 1.0/7.0;\n  vec3  ns = n_ * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n/*\n|--------------------------------------------------------------------------\n| Main\n|--------------------------------------------------------------------------\n|\n| Sandbox and sometimes something good\n|\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime;\n    \n    float n = snoise(vec3(uv.x * 2.4 - time * 0.1, uv.y * 1.8 - time * 0.2, 10. + time * 0.3));\n\n    float dist = length(uv);\n    dist = smoothstep(.1, .75, dist);\n    dist += 0.5 + 0.5;\n\n    vec3 color = vec3(smoothstep(.005, .001 * sin(time) * 0.5 + 0.5, length(uv) * 2.5));\n\n    float grain = snoise(vec3(n * sin(uv.x) + 0.4, n * sin(uv.y) + 0.4, time * 0.75)) * .75 - .75;\n    color += vec3(grain) * 0.25;\n    color *= dist;\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 433, 454, 454, 491], [492, 492, 519, 519, 567], [568, 568, 589, 589, 2165], [2168, 2376, 2433, 2433, 3035]], "test": "valid"}
{"id": "NsXGWM", "name": "My first stupid raymarching demo", "author": "Dubko", "description": "Currently, I am tryin to put some things together for school's project. Well, hopefully it will become more interesting over time.", "tags": ["raymarching"], "likes": 2, "viewed": 36, "published": "Public", "date": "1616006441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int g_maxIterations    = 64;\nconst float g_eps            = 0.001;\n\nconst int coloringMode       = 0;\n\nconst float roughness        = 0.7;\nconst float ambientRatio     = 0.0;\nconst float shininess        = 20.0;\nconst float specularity      = 0.3;\n\nconst vec3  albedoColor      = vec3(1.0,1.0,1.0);\nconst vec3  sunColor         = vec3(1.0,1.0,1.0);\n\n\nconst float floorElevation   = -2.0;\nconst float farPlane         = 100.0;\nconst float fogStartPlane    = 50.0;\nconst vec3  fogColor         = vec3(0.2,0.2,0.7);\n\nconst vec3  floorAColor      = vec3(1.0);\nconst vec3  floorBColor      = vec3(0.0);\nconst float floorThickness   = 0.99;\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos)-radius;\n}\n\nfloat sphereModulated(vec3 pos, float radius)\n{\n    pos.x += 0.1*(sin(iTime*pos.y*pos.x*3.0));\n    return length(pos)-radius;\n}\n\nfloat cube(vec3 pos, float radius)\n{\n    return max(abs(pos.x),max(abs(pos.y),abs(pos.z)))-radius;\n}\n\nfloat unite(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat uniteSmooth(float a, float b)\n{\n    return smoothstep(a,b, min(0.0,max(1.0,a/(a+b))));\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat ground(vec3 position, float elevation)\n{\n    return position.y - elevation;\n}\n\nfloat object(vec3 pos)\n{\n    pos.y += sin(cos(tan(iTime*3.0)*pos.x)+pos.y*0.3*20.0)*0.3;\n    pos.x += sin(pos.y*pos.x*2.0);\n    pos.y += sin(iTime);\n    float b = sphere(pos+vec3(0.0,0.0,0.0), 1.0);\n    float c = sphere(pos+vec3(1.0,0.0,0.0), 1.0);\n    return intersect(b,c);\n}\n\nfloat df(vec3 pos)\n{\n    float gd = ground(pos, floorElevation);\n    //float a = sphere(pos, 1.0);\n    //float ab = sphere(pos+vec3(0.5+sin(iTime),0.0,sin(iTime)*-0.0), 1.0);\n    \n    //float d = unite(a,b);\n    return unite(gd,object(pos));\n    //return uniteSmooth(ab,a);\n}\n\nfloat threshold(float val, float thres)\n{\n    return float(val > thres);\n}\n\nvec3 colorize(vec3 pos)\n{\n    float distToFloor = max(0.0, min(1.0, 10.0*g_eps+pos.y-(floorElevation)));\n    float checkerColor = clamp(0.0,1.0,threshold(sin(6.0*pos.x),floorThickness)+\n                                       threshold(sin(6.0*pos.z),floorThickness));\n    return mix(mix(floorAColor, floorBColor, checkerColor),\n               vec3(1.0,0.8,0.5),\n               distToFloor);\n}\nvec2 rayMarchWithIterations(vec3 o, vec3 d)\n{\n    int currentIterations = 0;\n    float t = 0.0;\n    while((g_maxIterations-currentIterations) > 0)\n    {\n        float closestDistance = df(o+t*d);\n        if(closestDistance < g_eps)\n        {\n            return vec2(t+closestDistance, currentIterations);\n        }\n        t += closestDistance;\n        currentIterations = currentIterations + 1;\n    }\n    return vec2(t, currentIterations);\n}\n\nfloat rayMarch(vec3 o, vec3 d)\n{\n    int maximumIterations = g_maxIterations;\n    float t = 0.0;\n    while(maximumIterations > 0)\n    {\n        float closestDistance = df(o+t*d);\n        if(closestDistance < g_eps)\n        {\n            return t+closestDistance;\n        }\n        t += closestDistance*0.5;\n        maximumIterations = maximumIterations - 1;\n    }\n    return t;\n}\n\nvec3 normalVector(vec3 o, vec3 d)\n{\n    vec2 eps = vec2(g_eps, 0);\n    float t = rayMarch(o, d);\n    if(t < 0.0)\n    {\n        return vec3(0.0);\n    }\n    vec3 p = o+d*t;\n    vec3 ds = vec3(df(p));\n    vec3 dd = vec3(df(p-eps.xyy), df(p-eps.yxy), df(p-eps.yyx));\n    return ds-dd;\n}\n\nvec3 phongShading(vec3 o, vec3 d, vec3 l)\n{;\n \n    float dO = rayMarch(o, d);\n    if(dO < 0.0 || dO > farPlane)\n    {\n       return fogColor;\n    }\n    vec3 p = o+d*dO;\n    \n  \n    vec3  nlDir = normalize(l-p);\n    float lightDistance = length(l-p);\n    \n    bool visibility = (rayMarch(p+nlDir*g_eps*5.0, nlDir) >= lightDistance-2.0*g_eps);\n    \n    vec3 nd = normalize(o-p);\n \n    vec3 nv = normalize(normalVector(o, d));\n    vec3 nnv = nv;\n    \n    vec3 halfDir = normalize(nlDir + nd);\n    float specAngle = max(dot(halfDir, nnv), 0.0);\n    float specular = pow(specAngle, shininess);\n    \n    float specularRatio = specular*specularity;\n    float lambertianRatio = max(dot(nlDir, nnv),0.0);\n    if(length(nv) < g_eps)\n    {\n      lambertianRatio = 0.0;\n    }\n    float lightAttenuation = 0.1*(pow(lightDistance,2.0)+1.0);\n    float lightIntensity = 1.0/lightAttenuation;\n    float fogRatio = max(0.0,(1.0+dO)/farPlane);\n    \n    \n    vec3 albedoColor = colorize(p);\n    \n    vec3 ambientColorPart    = albedoColor*ambientRatio;\n    vec3 shadingColor = ambientColorPart;\n    if(visibility)\n    {\n        vec3 lambertianColorPart = albedoColor*lightIntensity*lambertianRatio*roughness;\n        vec3 specularColorPart   = sunColor*specularRatio*lightIntensity;\n    \n    \n        shadingColor += lambertianColorPart + specularColorPart;\n    }\n    \n    return mix(shadingColor, fogColor, fogRatio);\n}\n\n\nvec3 depthMap(vec3 o, vec3 d)\n{\n    \n    float dO = rayMarch(o, d);\n    if(dO < 0.0)\n    {\n        return vec3(0.0);\n    }\n    return vec3(1.0-(1.0/dO),0.0,0.0);\n    //return vec3(1.0-(exp(dO)/10.0));\n}\n\nvec3 iterationsMap(vec3 o, vec3 d)\n{\n    vec2 result = rayMarchWithIterations(o, d);\n    float dO = result.x;\n    if(dO < 0.0)\n    {\n        return vec3(0.0);\n    }\n    return vec3(result.y/float(g_maxIterations),0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sunPos = vec3(sin(iTime)*0.0,2.0,sin(iTime)*10.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - vec2(0.5);\n    uv = uv * 2.0;\n    uv *= 0.5;\n    \n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    //vec3 cameraOrigin = vec3(0,0.0,-(sin(0.0)+5.0));\n    vec3  orbiterPoint = vec3(0.0);\n    float orbiterSpeed = 0.3;\n    vec3  orbiterDir = vec3(sin(orbiterSpeed*iTime),0.0, cos(orbiterSpeed*iTime));\n    float orbiterRadius = (3.0+2.0*sin(iTime*1.0))*3.0;\n    vec3 cameraOrigin = orbiterPoint+orbiterDir*orbiterRadius;\n    \n    vec3 cameraLookUp = vec3(sin(iTime)*0.1,1.0,cos(iTime)*0.1);\n    //vec3 cameraDir = normalize(vec3(sin(0.0), 0.0,abs(cos(0.0))));\n    vec3 cameraDir = -normalize(orbiterDir);\n    mat3 rotation = mat3( cross(cameraLookUp,cameraDir), cameraLookUp,cameraDir);\n    vec3 screenLookVector = normalize(vec3(uv, 1.0));\n    \n    screenLookVector = rotation*screenLookVector;\n    \n\n    \n    vec3 col = vec3(0.0);\n    switch(coloringMode)\n    {\n        case 0:\n            col = phongShading(cameraOrigin, screenLookVector, sunPos);\n            break;\n        case 1:\n            col = depthMap(cameraOrigin, screenLookVector);\n            break;\n        case 2:\n            col = abs(normalize(normalVector(cameraOrigin, screenLookVector)));\n            break;\n        case 3:\n            col = iterationsMap(cameraOrigin, screenLookVector);\n            break;\n            \n        default:\n            col = vec3(1.0,0.0,0.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsXGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 642, 680, 680, 713], [715, 715, 762, 762, 842], [844, 844, 880, 880, 944], [946, 946, 977, 977, 1001], [1003, 1003, 1040, 1040, 1097], [1099, 1099, 1134, 1134, 1158], [1160, 1160, 1206, 1206, 1243], [1245, 1245, 1269, 1269, 1522], [1524, 1524, 1544, 1544, 1799], [1801, 1801, 1842, 1842, 1875], [1877, 1877, 1902, 1902, 2269], [2270, 2270, 2315, 2315, 2712], [2714, 2714, 2746, 2746, 3093], [3095, 3095, 3130, 3130, 3377], [3379, 3379, 3422, 3422, 4779], [4782, 4782, 4813, 4813, 4984], [4986, 4986, 5022, 5022, 5210], [5212, 5212, 5269, 5269, 6875]], "test": "valid"}
{"id": "sd23RW", "name": "Acid Acid", "author": "Tater", "description": "I figured I had to make one of these at some point. ", "tags": ["2d", "waves", "flashing", "lsd"], "likes": 5, "viewed": 160, "published": "Public API", "date": "1617064593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float func(float x){\nfloat r = 0.0; \nr+=abs(-0.3+sin(iTime+x))*2.0;\nr+=abs(-0.3+sin(-iTime+x))*2.0;\nr*=r;\nr/=6.0;\nreturn r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    uv.y=-uv.y;\n    float y0 = uv.y;\n    float y1 = uv.y;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i<17; i++){\n        float fi = float(i);\n        y1=uv.y+1.5-0.1*fi;\n        \n        y1+=0.1*-(0.5+(sin(uv.x+t)*sin(uv.x+t)))*func(t+10.0*uv.x+fi*2.0);\n        \n        y0 = y0*step(step(0.4,y1),0.01)+y1*step(0.4,y1);\n    }\n    col.g=(1.0-fract(y0*12.0*(0.1+pow(sin(0.3*t+1.0),2.0))));\n    col.r=(1.0-fract(y0*6.0*(0.1+pow(sin(0.6*t+2.0),2.0))));\n    col.b=(1.0-fract(y0* 3.0*(0.1+pow(sin(0.9*t+3.1),2.0))))*(sin(t)*sin(t));\n    //col+=1.0-step(0.41,y0);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd23RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 125], [126, 126, 183, 183, 864]], "test": "valid"}
{"id": "sd2GRz", "name": "3D Sphere Orbits", "author": "warptarium", "description": "This shader orbits two 3D sphere points around each other using sin/cos circular motion. They do not appear 3D, but in fact are. There is just no shading on them :P", "tags": ["3d", "shader", "practice"], "likes": 1, "viewed": 35, "published": "Public", "date": "1616875279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n\n//distance from a point to a ray.\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) \n{\n    return length(cross(p - ro, rd)) / length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //center uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //create look ray\n    vec3 ro = vec3(0.0, 0.0, -3);\n    vec3 rd = vec3(uv.x, uv.y, 0.0) - ro;\n    \n    //create the two circles and rotate them\n    vec3 p = vec3(sin(iTime) / 3., 0.0, cos(iTime)); \n    vec3 p1 = vec3(-sin(iTime) / 3., cos(iTime) / 3., 0.); \n    \n    //calculate the pixels with smoothstep\n    float d = DistLine(ro, rd, p);\n    vec3 dCol = vec3(smoothstep(0.09, 0.08, d)) * RED;\n    \n    float d2 = DistLine(ro, rd, p1);\n    vec3 d2Col = vec3(smoothstep(0.09, 0.08, d2)) * GREEN;\n\n    // Output to screen\n    fragColor = vec4(dCol + d2Col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 134, 177, 177, 230], [232, 232, 289, 305, 976]], "test": "valid"}
{"id": "sd2Gzh", "name": "Sin Wave Wave [2D]", "author": "Tater", "description": "non ray marched version of [url]https://www.shadertoy.com/view/tsKSzR[/url]\n\nThere may be a less janky way to AA this, but I couldn't figure it out.\n\n", "tags": ["2d", "wave", "monochrome"], "likes": 26, "viewed": 582, "published": "Public API", "date": "1616984445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//2D version of https://www.shadertoy.com/view/tsKSzR\n//Original by skaplun\n\n//I tried to match it just by looking\n\n//I tried to match the perspective for fun but it got kinda tedious so\n//it's not perfect.\n\n\n#define pi 3.141592653\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*1.0;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    uv.y=-uv.y;\n    float y0 = uv.y;\n    float y1 = uv.y;\n    \n    float wc = 130.0;\n    float aa = 0.005*(450.0/max(iResolution.y,450.0)); \n    float w = 0.0035; //width\n    w-=aa; \n    \n    for(int i = 0; i<int(wc); i++){\n        float fi = float(i);\n        \n        y1=uv.y+1.1-2.5*(pow(fi/9.0,2.0)/300.0);\n\n        float x = uv.x*4.4+1.8*sin(fi/11.0+t)*((fi*3.3)/300.0);\n        \n        float h;\n        h = 3.5*sin((fi/11.0)+t);\n        \n        //Try these too\n        //h = 3.5*sin((fi/11.0)+t)*sin((fi/11.0)+t);\n        //h = 3.5*abs(sin((fi/11.0)+t));\n        \n        y1+=h*(cos(x*pi)+1.0)*0.05*step(-1.0,x)*step(x,1.0);\n        \n        y0 = y0*smoothstep((y1+w)+aa,(y1+w)+aa*3.0,0.4)  \n        +(y1-w)*smoothstep(0.4,0.4+aa,(y1-w)+aa);    \n    }\n    \n    //This is bad but I'm too stupid to fix it.\n    y0=1.0-y0;\n    y0=smoothstep(y0-0.4,y0,0.6);\n    y0=1.0-y0;\n\n    fragColor = vec4(vec3(y0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2Gzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 232, 289, 289, 1298]], "test": "valid"}
{"id": "sdBGzm", "name": "black hole(if gravity: 1/r^3)", "author": "neoned71", "description": "It is a ray marched example of a black hole render. Light rays follow newtonian gravity to make computations simple. This code has been assembled and edited by neoned71 using code written by other people on shadertoy.", "tags": ["raymarching", "blackhole"], "likes": 5, "viewed": 171, "published": "Public", "date": "1617131258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed 3.0  //disk rotation speed\n\n#define _Steps  1. //disk texture layers\n#define _Size 0.3 //size of BH\n\n\n\n//float hash(float x){ return fract(sin(x)*152754.742);}\n//float hash(vec2 x){   return hash(x.x + hash(x.y));}\n\nmat4 rotationX( in float angle ) {\n    return mat4(    1.0,        0,          0,          0,\n                    0,  cos(angle), -sin(angle),        0,\n                    0,  sin(angle),  cos(angle),        0,\n                    0,          0,            0,        1);\n}\n\nmat4 rotationY( in float angle ) {\n    return mat4(    cos(angle),     0,      sin(angle), 0,\n                            0,      1.0,             0, 0,\n                    -sin(angle),    0,      cos(angle), 0,\n                            0,      0,              0,  1);\n}\n\nmat4 rotationZ( in float angle ) {\n    return mat4(    cos(angle),     -sin(angle),    0,  0,\n                    sin(angle),     cos(angle),     0,  0,\n                            0,              0,      1,  0,\n                            0,              0,      0,  1);\n}\n\nfloat hash(float x){ return fract(sin(x)*15.0); }\nfloat hash(vec2 x){ return hash(x.x + hash(x.y)); }\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;    \n    float b = mix(bl, br, fr.x);    \n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*5.1, 100.); \n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    return vec4(stars, 1.0);\n}\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.);\n    \n    vec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.04 *(1./_Steps) /( abs(ray.y) );\n\n    position += dist*_Steps*ray*0.8;     \n\n    vec2 deltaPos;\n    deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;\n    deltaPos.y = zeroPos.x*0.01 + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= sqrt(lengthPos);\n    parallel *= 0.6;\n    float redShift = parallel +0.4;\n    redShift *= redShift;\n\n    redShift = clamp(redShift, 0., 1.);\n    \n    float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);\n    vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);\n    \n    insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);\n    insideCol *= 1.4;\n    redShift += 0.14;\n    redShift *= redShift;\n\n    vec4 o = vec4(0.);\n\n    for(float i = 0. ; i < _Steps; i++)\n    {                      \n        position -= dist * ray ;  \n\n        float intensity =clamp( 1. - abs((i - 0.8) * (1.) * 2.), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 1.;\n\n        distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);        \n        distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);\n        distMult *= distMult;\n\n        float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;\n\n        vec2 xy ;\n        float rot = mod(iTime*_Speed, 8192.);\n        xy.x = -position.z*sin(rot) + position.x*cos(rot);\n        xy.y = position.x*sin(rot) + position.z*cos(rot);\n\n        float x = abs( xy.x/(xy.y));         \n        float angle = 0.02*atan(x);\n  \n        const float f = 70.;\n        float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);\n        noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);     \n        \n        float extraWidth =  noise * 3.0 * (1. -  clamp(i * (1.)*2. - 1., 0., 1.));\n\n        float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);\n\n        vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));\n        o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));\n\n        lengthPos *= (1./_Size);\n   \n        o.rgb+= redShift*(intensity*1. + 0.5)* (1.0) * 100.*distMult/(lengthPos*lengthPos);\n    }  \n \n    o.rgb = clamp(o.rgb - 0.02, 0.2, 1.);\n    return o ;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n    vector.yz = cos(angle.y)*vector.yz\n                +sin(angle.y)*vec2(-1,1)*vector.zy;\n    vector.xz = cos(angle.x)*vector.xz\n                +sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    vec3 rotation=vec3(0.0,1,10);\n    mat4 f=rotationX(rotation.x) * rotationY(rotation.y) * rotationZ(rotation.z);\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 pos = vec3(1.025,-.05,-4.1);\n        // inside location looking outside:> vec3 pos = vec3(0.025,0.05,0.1);\n        vec2 angle = vec2(0.1+0.3*sin(iTime),-0.010);      \n        //angle.y = (2.*0.0/iResolution.y)*3.14 + 0.1 + 3.14;\n        float dist = length(pos);\n        Rotate(pos,angle*0.05);\n        //angle.xy -= min(.3/dist , 3.14) * vec2(1, 0.5);\n        Rotate(ray,angle);\n\n        vec4 col = vec4(0.); \n        vec4 glow = vec4(0.); \n        vec4 outCol =vec4(100.);\n\n        for(int disks = 0; disks< 200; disks++) //steps\n        {\n\n            for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)\n            {\n                float dotpos = dot(pos,pos);\n                float invDist = inversesqrt(dotpos); //1/distance to BH\n                float centDist = dotpos * invDist;  //distance to BH\n                float stepDist = 0.92 * abs(pos.y /(ray.y));  //conservative distance to disk (y==0)   \n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n                \n                float invDistSqr = invDist * invDist*invDist;\n                float forceK = 0.725; //0.625;\n                float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n                ray =  normalize(ray - (bendForce * invDist )*pos);  //bend ray towards BH\n                pos += stepDist * ray; \n                \n                glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            }\n\n            float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.1) //ray sucked in to BH\n            {\n                //outCol=vec4(0.1,0.1,0.1,1.0);\n                outCol =  vec4( col.rgb * col.a + glow.rgb *(0.8-col.a ) ,1.) ;\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {                   \n                vec4 bg = background (ray);\n                outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);       \n                break;\n            }\n\n            else if (abs(pos.y) <= _Size * 0.002 ) //ray hit accretion disk\n            {                             \n                //utCol=vec4(0.1,0.1,0.1,1.0);\n                //break;\n                vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n                pos.y = 0.;\n                pos += abs(_Size * 0.001 /ray.y) * ray;  \n                col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }   \n        }\n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 285, 319, 319, 558], [560, 560, 594, 594, 833], [835, 835, 869, 869, 1108], [1110, 1110, 1130, 1130, 1159], [1160, 1160, 1179, 1179, 1211], [1213, 1213, 1257, 1257, 1613], [1615, 1615, 1642, 1642, 2100], [2102, 2102, 2145, 2177, 4692], [4695, 4695, 4741, 4741, 4925], [4927, 4927, 4981, 4981, 8602]], "test": "valid"}
{"id": "sdf3RN", "name": "Wobbly Ring", "author": "dh7892", "description": "A ring, and it wobbles", "tags": ["ring2d"], "likes": 2, "viewed": 160, "published": "Public API", "date": "1615570851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Try playing with these parameters\nfloat MAGNITUDE = 1.0/10.0; // How big the perturbation away from a sphere can get\nfloat SPEED = 0.8; // How fast the shape will evolve\nfloat RESOLUTION = 180.0 / 360.0; // Number of perturbations per 360 degrees\nfloat COL = 1.0; // Amount of colour to use\nfloat SMOOTH = 1.0; // Smmothness of perturbation\nfloat WOBBLE = 0.0; // Wobble!\n\n// Other constants\nfloat RADIUS = 0.3;\nvec2 CENTRE = vec2(0.5, 0.5);\nfloat BORDER_THICKNESS = 0.005;\nvec3 RED = vec3(1.0, 0.0, 0.0);\nvec3 BLUE = vec3(0.0, 0.0, 1.0);\nvec3 WHITE = vec3(1.0, 1.0, 1.0);\nvec3 BLACK = vec3(0.0, 0.0, 0.0);\n\n\nfloat rand(float x, float time)\n{\n    float scale = (0.001 + WOBBLE) * mod(time, 1000.0) * 0.001;\n    return fract(sin(x + scale)*100000.0);\n}\n\nvec2 polar(vec2 uv)\n{\n    float r = distance(uv, CENTRE);\n    float theta = degrees(atan(uv.y, uv.x)) * RESOLUTION;\n    return vec2(r, theta);\n}\n\nfloat perturb(float time)\n{\n    return pow(sin(float(SPEED * time)), 2.0);\n}\n\nfloat smoothDist(vec2 uv, float time)\n{\n    // Return the distance from our wobbly ring at a time\n    float dist = distance(uv, CENTRE);\n    float theta = degrees(atan(uv.y, uv.x)) * RESOLUTION;\n    float diff = smoothstep(floor(theta), ceil(theta), theta);\n    \n    float dR = mix(rand(floor(theta), time), rand(ceil(theta), time), diff) * MAGNITUDE;\n    \n    return dist - (dR *perturb(time)) - RADIUS;\n}\n\n\n\nfloat stepDist(vec2 uv, float time)\n{\n    \n    float dist = distance(uv, CENTRE);\n    float theta = floor(degrees(atan(uv.y, uv.x)) * RESOLUTION);\n    \n    float dR = rand(theta, time) * MAGNITUDE;\n    \n    return dist - (dR * perturb(time)) - RADIUS;\n}\n\nfloat borderDist(vec2 uv, float time)\n{\n    return mix(stepDist(uv, time), smoothDist(uv, time), SMOOTH);\n}\n\nvec4 border(float dist)\n{\n    float border = step(BORDER_THICKNESS, abs(dist));\n        \n    vec3 borderColor = mix(BLACK, WHITE, border);\n    return vec4(borderColor, 1.0 - borderColor);\n}\n\n\nvec4 redArea(float dist)\n{    \n    vec4 borderColor = border(dist);\n\n    return mix(vec4(RED, 1.0), vec4(WHITE, 0.0), step(BORDER_THICKNESS,dist));    \n}\n\nvec4 blueArea(float dist)\n{    \n    vec4 borderColor = border(dist);\n\n    return mix(vec4(BLUE, 1.0), vec4(WHITE, 0.0), step(BORDER_THICKNESS,dist));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float bDist = borderDist(uv, float(iTime));\n    vec4 borderColor = border(bDist);\n    \n    float redDist = borderDist(uv, float(floor(iTime * 10.0)));\n    vec4 red = redArea(redDist);\n    \n    float blueDist = borderDist(uv, float(floor(iTime * 9.0)));\n    vec4 blue = blueArea(blueDist);\n    \n    vec4 col = mix(red, blue, 0.5);\n    col = mix(vec4(WHITE, 1.0), col, COL);\n\n    fragColor = mix(col, borderColor, borderColor.w);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdf3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 613, 646, 646, 755], [757, 757, 778, 778, 901], [903, 903, 930, 930, 979], [981, 981, 1020, 1078, 1387], [1391, 1391, 1428, 1428, 1644], [1646, 1646, 1685, 1685, 1753], [1755, 1755, 1780, 1780, 1944], [1947, 1947, 1973, 1973, 2100], [2102, 2102, 2129, 2129, 2257], [2259, 2259, 2316, 2366, 2845]], "test": "valid"}
{"id": "sdfGD7", "name": "Infinite field", "author": "LevAsmanov", "description": "I did that shader as a gift for my grandpa (why not?)", "tags": ["rgb", "rainbow", "field", "moving", "move"], "likes": 0, "viewed": 101, "published": "Public", "date": "1616048672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I don't understand a little how it works, and how i made it\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv*2. - vec2(1.,1.))/(vec2(iResolution.x/iResolution.y)) + vec2(sin(iTime)/4.,0.);\n    float value = 0.;\n    if(uv.y > 0.)\n    value = tan(3.1415*(sin(uv.x/uv.y-sin(iTime/8.)*8.)+1.))+0.5;\n    else\n    value = tan(3.1415*(sin(uv.x/uv.y+sin(iTime/8.)*8.)+1.))+0.5;\n    vec3 col = vec3(value/(sin(iTime)+1.), value/(sin(iTime/2.)+1.),value/(sin(iTime/4.)+1.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 119, 119, 561]], "test": "valid"}
{"id": "sdfGz7", "name": "Castle Oblivion", "author": "kstyler", "description": "A shader inspired by castle oblivion from kingdom hearts", "tags": ["3d", "raymarching", "organization13", "kingdomhearts"], "likes": 12, "viewed": 245, "published": "Public API", "date": "1616535469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Reference https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat pi = acos(-1.);\nint mat_id = 0;\n\nfloat s_union( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat s_sub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvec3 radial_rep(vec3 p, float num_rep){\n    float ang = (2.*pi) / num_rep;\n    float sector = round(atan(p.z,p.x)/ang); \n    float an = sector*ang;\n    vec3 q = p;\n    q.xz = rot(an)*q.xz;\n    return q;\n} \n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n}\n\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat disk(vec3 p , float radius, float thickness){\n    float d = length(p.xz)-radius;\n    d = max(d,p.y-thickness*.5);\n    d = max(d,-p.y-thickness*.5);\n    return d;\n}\nfloat block( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pedestal(vec3 p){\n    p.y+=10.;\n    float union_ptc = 1.5;\n    float y_offset = 3.;\n    float top =  block(p+vec3(0.,-y_offset,0.),vec3(2.,.6,2.));\n    float mid =  block(p,vec3(1.5,2.5,1.5));\n    float bot =  block(p+vec3(0.,y_offset,0.),vec3(2.5,.6,2.5));\n    return s_union(bot,s_union(top,mid,union_ptc),union_ptc);\n}\n\nfloat planter(vec3 p){\n    p.y+=10.;\n    vec3 pos = radial_rep(p,4.)-.1;\n    float poker = block(pos+vec3(-5.,0.,0.),vec3(1.5,2.,3.));\n    float union_ptc = .5;\n    float y_offset = 3.5;\n    float top =  block(p+vec3(0.,-y_offset,0.),vec3(4.5,.6,4.5));\n    float mid =  block(p,vec3(4.,3.5,4.));\n    float bot =  block(p+vec3(0.,y_offset,0.),vec3(4.5,.6,4.5));\n    float core = s_union(bot,s_union(top,mid,union_ptc),union_ptc);\n    return s_sub(poker,core,union_ptc);\n}\n\nfloat vase(vec3 p){\n    p.y +=5.;\n    float pre_core = sphere(p,2.);\n    float core = max(pre_core,p.y-1.5);\n    float top = torus(p+vec3(0.,-1.5,0.),vec2(1.6,.3));\n    return min(top,core);\n}\n\nfloat room_box(vec3 p){\n    p+=vec3(0.,-7.7,-59.);\n    float box1 = block(p,vec3(25.,19.,60.));\n    float box2 = block(p,vec3(24.,18.,64.));\n    float box3 = block(p+vec3(0.,8.,29.),vec3(8.,10.,3.));\n    return max(-box3,max(box1,-box2));\n}\n\nfloat base(vec3 p){\n    vec3 pos = radial_rep(p,12.)-.1;\n    vec3 pos2 = radial_rep(p,12.*3.);\n    vec3 posOfs = vec3(9.,0.,0.);\n    vec3 posOfs2 = vec3(4.,0.,0.);\n    float dsk = disk(p,5.,.9);\n    float cutter = block(pos-posOfs,vec3(5.,6.,200.));\n    return max(-sphere(pos2-posOfs2,.3),max(-cutter,dsk));\n}\n\nfloat column_shaft(vec3 p){\n    p.y-=15.;\n    float rad = 2.;\n    rad -= (sin(p.y*.1)-1.)*.8;\n    rad -= 0.50*(0.3+0.3*sin(13.*atan(p.x,p.z)));\n    float d = length(p.xz)- rad;\n    d = max(d,p.y);\n    d = max(d,-p.y-30.);\n    return d;\n}\n\nfloat ellipsoid(vec3 p, vec3 r ){\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\nfloat chip(vec3 p){\n    p*=.9;\n    p.xz*=rot(p.x*.2);\n    return ellipsoid(p,vec3(5,6.-max(2.,p.y),.8)*.2);\n}\n\nfloat chip_ring(vec3 p,float r){\n    vec3 pos = radial_rep(p,12.);\n    vec3 final_pos = pos - vec3(r,0,0);\n    final_pos.xz*=rot(90.*pi/180.);\n    final_pos.yz*=rot(15.*pi/180.);\n    return chip(final_pos);\n}\n\nfloat full_column(vec3 p){\n    p.y+=15.;\n    vec3 q = abs(p+vec3(0.,-15.,0.));\n    vec3 b = abs(q+vec3(0.,15.,0.)); \n    q+=vec3(0.,-1.8,0.);\n    q.xz*=rot(45.*pi/180.);\n    q.xy*=rot(pi);\n    b.xy*=rot(pi);\n    b.y+=15.*2.;      \n    float total_base = min(chip_ring(q+vec3(0,11.4,0),3.3),\n            s_union(chip_ring(b+vec3(0.,-1.2 ,0.),3.55),\n            (base(b)),.45));                            \n                   \n    return min(column_shaft(p+vec3(0.,-15.,0.)),total_base);\n}\n\nfloat door_frame(vec3 p){\n    vec3 q = p;\n    p.x = abs(p.x);\n    p.x-= 9.;\n    float tall_block = block(p,vec3(1.1,10,1.1));\n    float base_block = block(p+vec3(0.,10,0.),vec3(1.6,.5,1.6));\n    float top_block = block(q+vec3(0.,-10,0),vec3(11,1.,1.6));\n    float top_block2 = block(q+vec3(0.,-11,0),vec3(12,.5,2.));\n    return s_union(top_block2,s_union(top_block,s_union(tall_block,base_block,.5),.5),1.5);\n}\n\n\nfloat plant(vec3 p){ \n    p.y+=7.;   \n    p.y+=(1.+sin(p.z*2.+.1))*.2;\n    p*=.5;\n    float eli = 90.;\n    for(int i = -4; i<-1; i++){\n        p.xz*=rot(((float(i)*10.)*pi/180.));\n        vec3 pos = radial_rep(p,5.)-.1;\n        pos.y+=float(i)*.4;\n        pos.x-=float(i)*.2;\n        pos.xz*=rot(-90.*pi/180.);\n        eli =s_union(eli,ellipsoid(pos,vec3((1.+pos.z*.001),.4,3.)),.1);\n    }\n    return eli;\n}\n\nfloat full_planter(vec3 p){\n    return min(plant(p),planter(p));\n}\n\nfloat full_pedistal(vec3 p){\n    return min(plant((p+vec3(0.,1.2,0.))/.4),min(vase(p),pedestal(p)));\n}\n\nfloat stair_way(vec3 p){\n    float c =4.;\n    vec3 q = p;\n    p.y+=12.7;\n    p.zy*=rot(8.*pi/180.);\n    p.z = p.z-c*clamp(round(p.z/c),-8.,0.);\n    p.z = mod(p.z+0.5*c,c)-0.5*c;  \n    p.zy *= rot(-8.*pi/180.);\n    float stp = block(p,vec3(10.,2.7,.5));\n    return stp;\n}\n\nfloat hall_way(vec3 p){\n    p.z+=10.;\n    float size = 10.;\n    float box1 = block(p,vec3(size,size+5.,size));\n    float box2 = block(p,vec3(size-.5,size+5.-.6,size+1.));\n    return max(box1,-box2);\n}\n\nfloat full_hall(vec3 p){\n    p.xz*=rot(pi);\n\n    return min(door_frame(p-vec3(0.,3.,-21.)),min(hall_way(p),\n        min(door_frame(p+vec3(0,.3,0.)),stair_way(p))));}\n\nfloat map(vec3 p){\n    float c =200.;\n    float c2 =c/4.;\n\n    vec3 q = p;\n    vec3 r = p;\n    vec3 s = p;\n      \n    p.zy*=rot(-8.*pi/180.);\n    p.z = mod(p.z+0.5*c,c)-0.5*c;\n    p.zy*=rot(8.*pi/180.);\n    \n    float box = block(p,vec3(100.,100,.1));\n    box = max(box,-block(p,vec3(8,10,1.)));\n    \n    q.y+=6.;\n    q.xz+=c2/2.;\n    q.zy*=rot(-8.*pi/180.);  \n    q.z = mod(q.z+0.5*c2,c2)-0.5*c2;\n    q.x = q.x-c2*clamp(round(q.x/c2),0.,1.);\n    q.zy*=rot(8.*pi/180.);\n   \n    r.x+=c2*.5/2.;\n    r.z+=50.;\n    r.y+=6.;\n    r.zy*=rot(-8.*pi/180.);  \n    r.z = mod(r.z+0.5*c2*2.,c2*2.)-0.5*c2*2.;\n    r.x = r.x-(c2*.5)*clamp(round(r.x/(c2*.5)),0.,1.);\n    r.zy*=rot(8.*pi/180.);\n     \n    s.x+=c2*.6/2.;\n    s.z+=100.;\n    s.y+=16.;\n    s.zy*=rot(-8.*pi/180.);  \n    s.z = mod(s.z+0.5*c2*4.,c2*4.)-0.5*c2*4.;\n    s.x = s.x-(c2*.6)*clamp(round(s.x/(c2*.6)),0.,1.);\n    s.zy*=rot(8.*pi/180.);\n    \n    return min(full_planter(s*.9),min(full_pedistal(r*.8),\n        min(full_column(q*.6),min(box,full_hall(p)))));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i <700; i++){\n        dst = map(ro+rd*tot);\n        tot += dst;\n        if(dst < 0.03 || tot > 700.){\n            tot=float(i)/200.;//https://www.shadertoy.com/view/tdBGWD\n            break;\n        }\n    }\n    if (dst > 0.03) mat_id = 1;\n    return tot;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,-1.,iTime*20.);\n    vec3 rd = normalize(vec3(uv,1.));\n    float tilt = -8.;\n    ro.yz*=rot(tilt*pi/180.);\n    rd.yz*=rot(tilt*pi/180.);\n    vec3 col = 1.-vec3(march(ro,rd));\n    if(mat_id ==1)col = vec3(.95); \n    fragColor = vec4((col),1.0);\n}", "image_inputs": [{"id": "llsXD4", "previewfilepath": "https://soundcloud.com/michael-mike-carter/kingdom-hearts-iii-organization-13", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/michael-mike-carter/kingdom-hearts-iii-organization-13", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 166, 166, 266], [268, 268, 312, 312, 413], [415, 415, 433, 433, 482], [484, 484, 523, 523, 688], [691, 691, 726, 726, 757], [760, 760, 790, 790, 855], [857, 857, 908, 908, 1026], [1027, 1027, 1057, 1057, 1144], [1146, 1146, 1169, 1169, 1473], [1475, 1475, 1497, 1497, 1945], [1947, 1947, 1966, 1966, 2139], [2141, 2141, 2164, 2164, 2381], [2383, 2383, 2402, 2402, 2693], [2695, 2695, 2722, 2722, 2932], [2934, 2934, 2967, 2967, 3056], [3058, 3058, 3077, 3077, 3167], [3169, 3169, 3201, 3201, 3377], [3379, 3379, 3405, 3405, 3866], [3868, 3868, 3893, 3893, 4278], [4281, 4281, 4301, 4301, 4688], [4690, 4690, 4717, 4717, 4756], [4758, 4758, 4786, 4786, 4860], [4862, 4862, 4886, 4886, 5132], [5134, 5134, 5157, 5157, 5334], [5336, 5336, 5360, 5360, 5501], [5503, 5503, 5521, 5521, 6514], [6516, 6516, 6546, 6546, 6862], [6864, 6864, 6919, 6919, 7245]], "test": "valid"}
{"id": "sdfGzH", "name": "Fork Analys Cub NikolaErce 538", "author": "NikolaErceg", "description": "WE ARE BACK. The cube shader from my modchart \"Analys\": https://www.youtube.com/watch?v=eqZE60HanCM", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 72, "published": "Public", "date": "1615486547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Analys cube\n// (c) 2019 FMS_Cat, MIT License\n\n// == tweak these numbers, yee =====================================================================\n#define SIZE 0.5\n#define FX_NYOOOM (iMouse.x/iResolution.x)\n#define FX_FORWARD 1.0\n#define FX_KICK (0.1*exp(-3.0*mod(BEAT,4.0)))\n#define FX_TWIST (20.0*exp(-3.0*mod(BEAT-2.0,4.0)))\n#define FX_SKEW 0.0\n#define FX_DEFORM (0.2*iMouse.y/iResolution.y)\n#define FX_DEFORM_FREQ 0.1\n\n// == raymarch related constants ===================================================================\n#define MARCH_ITER 64\n#define MARCH_EPSILON 1E-4\n#define MARCH_NEAR 0.01\n#define MARCH_FAR 40.0\n#define MARCH_MULP 0.6\n\n// == common macros ================================================================================\n#define HALF_PI 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define BEAT (iTime*170.0/60.0)\n#define saturate(i) clamp(i,0.,1.)\n#define linearstep(a,b,t) saturate(((t)-(a))/((b)-(a)))\n\n// == common functions =============================================================================\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), -sin( t ), sin( t ), cos( t ) );\n}\n\n// == camera =======================================================================================\nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 up;\n  float roll;\n  float fov;\n};\n\nCamera newCamera( vec3 pos, vec3 dir ) {\n  Camera camera;\n  camera.pos = pos;\n  camera.dir = dir;\n  camera.up = vec3( 0.0, 1.0, 0.0 );\n  camera.roll = 0.0;\n  camera.fov = 0.5;\n  return camera;\n}\n\n// == ray ==========================================================================================\nstruct Ray {\n  vec3 orig;\n  vec3 dir;\n};\n\nRay newRay( vec3 ori, vec3 dir ) {\n  Ray ray;\n  ray.orig = ori;\n  ray.dir = dir;\n  return ray;\n}\n\nRay rayFromCamera( Camera camera, vec2 p ) {\n  vec3 dirX = normalize( cross( camera.dir, camera.up ) );\n  vec3 dirY = cross( dirX, camera.dir );\n  vec2 pt = rotate2D( camera.roll ) * p;\n  return newRay(\n    camera.pos,\n    normalize( pt.x * dirX + pt.y * dirY + camera.dir / tan( camera.fov ) )\n  );\n}\n\nvec3 getRayPosition( Ray ray, float len ) {\n  return ray.orig + ray.dir * len;\n}\n\n// == isect ========================================================================================\nstruct Intersection {\n  Ray ray;\n  float len;\n  vec3 pos;\n};\n\nIntersection newIntersection( Ray ray, float len ) {\n  Intersection isect;\n  isect.ray = ray;\n  isect.len = len;\n  isect.pos = getRayPosition( ray, len );\n  return isect;\n}\n\n// == march result =================================================================================\nstruct MarchResult {\n  float dist;\n  vec2 uv;\n};\n\n// == distFuncs ====================================================================================\nfloat distFuncBox( vec3 p, vec3 b ) {\n  vec3 d = abs( p ) - b;\n  return length( max( d, 0.0 ) ) + min( max( d.x, max( d.y, d.z ) ), 0.0 );\n}\n\nvec3 deform( vec3 p ) {\n  vec3 pt = p;\n  pt.xy = rotate2D( FX_SKEW * pt.z ) * pt.xy;\n  pt.x *= 1.0 - sqrt( FX_NYOOOM );\n  pt.yz = rotate2D( FX_NYOOOM * exp( 5.0 * FX_NYOOOM ) * pt.x ) * pt.yz;\n  pt.y += 2.0 * FX_SKEW * pt.x;\n  pt += FX_DEFORM * (\n    texture( iChannel1, FX_DEFORM_FREQ * ( pt.xy ) + 5.5 ).xyz - 5.5\n  );\n  pt.zx = rotate2D( mod(0.5 * iTime + PI, TAU ) + FX_TWIST * pt.y ) * pt.zx;\n  pt.xy = rotate2D( 0.6 * sin( 0.9 * iTime ) ) * pt.xy;\n  pt.yz = rotate2D( 0.6 * sin( 1.4 * iTime ) ) * pt.yz;\n  pt -= normalize( pt ) * FX_KICK * sin( 15.0 * length( pt ) - 40.0 * iTime );\n  return pt;\n}\n\nMarchResult distFunc( vec3 p ) {\n  MarchResult result;\n\n  vec3 pt = p;\n  pt = deform( pt );\n  result.dist = distFuncBox( pt, vec3( SIZE ) );\n\n  vec3 spt = vec3( 2.0 );\n\n  if ( FX_FORWARD > 0.0 ) {\n    vec3 ptIfs = p;\n    ptIfs.z = mod( ptIfs.z - 16.0 * iTime + 3.0 * sin( HALF_PI * BEAT + 0.5 ), 6.0 ) - 3.0;\n    for ( int i = 0; i < 6; i ++ ) {\n      float fi = float( i );\n      spt *= sign( ptIfs );\n      ptIfs = abs( ptIfs ) - vec3( 3.2, 4.5, 1.2 ) / max( 1E-2, FX_FORWARD ) * pow( 0.5, fi );\n      ptIfs.xy = rotate2D( 1.1 ) * ptIfs.xy;\n      ptIfs.zx = rotate2D( 2.1 ) * ptIfs.zx;\n    }\n\n    ptIfs = deform( ptIfs );\n\n    float distIfs = distFuncBox( ptIfs, vec3( SIZE ) );\n\n    if ( result.dist < distIfs ) {\n      spt = vec3( 1.0 );\n    } else {\n      result.dist = distIfs;\n      pt = ptIfs;\n    }\n  }\n\n  vec3 abspt = abs( pt );\n  float n = max( abspt.x, max( abspt.y, abspt.z ) );\n\n  result.uv = 0.5 + (\n    ( n == abspt.z ) ? ( pt.xy * vec2( sign( pt.z ), 1.0 ) ) :\n    ( n == abspt.x ) ? ( pt.zy * vec2( -sign( pt.x ), 1.0 ) ) :\n    ( pt.xz * vec2( 1.0, -sign( pt.y ) ) )\n  ) * spt.x * spt.y * spt.z * 0.5 / SIZE;\n\n  return result;\n}\n\nvec3 normalFunc( vec3 p, float dd ) {\n  vec2 d = vec2( 0.0, dd );\n  return normalize( vec3(\n    distFunc( p + d.yxx ).dist - distFunc( p - d.yxx ).dist,\n    distFunc( p + d.xyx ).dist - distFunc( p - d.xyx ).dist,\n    distFunc( p + d.xxy ).dist - distFunc( p - d.xxy ).dist\n  ) );\n}\n\nvec3 normalFunc( vec3 p ) {\n  return normalFunc( p, MARCH_NEAR );\n}\n\n// == main procedure ===============================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n  Camera camera = newCamera( vec3( 0.0, 0.0, 0.0 ), vec3( 0.0, 0.0, -1.0 ) );\n  camera.fov = 0.6 + 0.9 * FX_FORWARD * ( 0.5 + 0.5 * sin( HALF_PI * BEAT - 0.5 ) );\n  camera.pos.z = 0.5 + 1.5 / camera.fov;\n  Ray ray = rayFromCamera( camera, p );\n\n  Intersection isect;\n  float rayLen = MARCH_NEAR;\n  vec3 rayPos = getRayPosition( ray, rayLen );\n  MarchResult result;\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    result = distFunc( rayPos );\n    if ( abs( result.dist ) < MARCH_NEAR ) { break; }\n    rayLen += result.dist * MARCH_MULP;\n    if ( MARCH_FAR < rayLen ) { break; }\n    rayPos = getRayPosition( ray, rayLen );\n  }\n\n  vec3 bg = vec3( 0.0 );\n\n  if ( abs( result.dist ) < MARCH_NEAR ) {\n    vec3 normal = normalFunc( rayPos );\n    float edge = linearstep( 0.498, 0.499, abs( result.uv.x - 0.5 ) );\n    edge += linearstep( 0.495, 0.497, abs( result.uv.y - 0.5 ) );\n    vec2 uv = result.uv;\n    vec4 tex = texture( iChannel0, uv );\n    float fog = exp( -0.2 * max( 0.0, rayLen - 3.0 ) );\n    fragColor = vec4( fog * mix(\n      0.1 + 0.1 * normal + 0.8 * tex.rgb,\n      1.0 + 1.0 * sin( vec3( 0.0, 1.0, 2.0 ) + 10.0 * length( result.uv - 0.5 ) - 10.0 * iTime ),\n      edge\n    ), 1.0 );\n  } else {\n    // discard;\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n  }\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGzH.jpg", "access": "shaders20k", "license": "mit", "functions": [[953, 1054, 1080, 1080, 1140], [1142, 1325, 1365, 1365, 1519], [1521, 1664, 1698, 1698, 1760], [1762, 1762, 1806, 1806, 2063], [2065, 2065, 2108, 2108, 2145], [2147, 2310, 2362, 2362, 2482], [2635, 2736, 2773, 2773, 2876], [2878, 2878, 2901, 2901, 3481], [3483, 3483, 3515, 3515, 4629], [4631, 4631, 4668, 4668, 4913], [4915, 4915, 4942, 4942, 4982], [4984, 5085, 5142, 5142, 6479]], "test": "error"}
{"id": "sdfGzN", "name": "Battle of Morengo public", "author": "zoeclark", "description": "Saving the project without the private assets to make it public. \nFollow the instructions in the README to load the sound and background image. \nHackday Project, Eigen, March 2021 by Zoe Clark, Sylvan O'Sullivan, and Bryan Uribe.", "tags": ["sun", "snow", "art", "war"], "likes": 1, "viewed": 44, "published": "Public", "date": "1615571608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nREADME\n\nThis shadertoy commemorates the victory of Napoleonic France \nover Austria at the Battle of Morengo. Glory.\n\nWhile it may seem at first contradictory to have “god rays” while the sun traverses the entire sky,\nthis clearly symbolizes how war is both an endless moment and eternal progression simultaneously.\nThe snow is because it was snowing when we made this and we wanted to make the battle more personal to us. \nWe certainly  feel the battle of Morenego very personally. \n\n\nMost of the sunlight creation was copied from https://www.shadertoy.com/view/MdSyDz\nThis code incorporates slight modulation of the \"sunlight\" with input music.\n\nA background image and soundcloud input are required for full enjoyment.\n\nThe soundcloud layer in iChannel0 should load this:\nhttps://soundcloud.com/pau-ng/jean-francois-le-sueur-oratorios-pour-le-couronnement\n\nHit the pause/play button twice on the soundcloud box to load it. \nWait a few seconds, \nthe audio doesn't play immediately. It starts out pretty loud, like many\nclassical symphonies.\n\n\nTo load the background image, (\"Battle of Morengo\", Louis-François Lejeune, 1800)\n\n\"\"\"\nTo add the base image to shadertoy: \n1. open the dev tools js console (for chrome on a mac, it's option + cmd + j). \n2. copy/paste and run the following: \ngShaderToy.SetTexture(1, \n{mSrc:'https://dl.dropboxusercontent.com/s/xwq7dv4zp4vi7et/Lejeune_-_Bataille_de_Marengo.jpg?dl=0', \nmType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n\"\"\"\n\n*/\n\n\n#define pi 3.1415926\n\nfloat T;\n\n\n//SUN STUFF\n\nfloat audioMungler( float cosAngle )\n{\n float aud = texture(iChannel0,vec2(abs(floor(20.*cosAngle)/20.))).r*exp(1.+cosAngle)*2.;\n return aud;\n }\n\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n{\n\tvec2 sourceToCoord = coord - raySource;\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n    float aud = audioMungler(cosAngle);\n\tseedA *= 0.5;\n\treturn clamp(\n\t\t(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed*aud)) +\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed*aud)),\n\t\t0.0, 1.0) *\n\t\tclamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);\n}\n\n\n\n\nvec4 musicalSunlight_1(vec2 fragCoord , vec2 coord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\n\t// Set the parameters of the sun rays\n\tvec2 rayPos1 = vec2(iResolution.x * 0.7, iResolution.y * -0.4);\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\tfloat raySeedA1 = 36.2214;\n\tfloat raySeedB1 = 21.11349;\n\tfloat raySpeed1 = 0.001;//SPEED1 - original 1.5. Controls horizontal sweeping movement\n\t\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n\treturn\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1);\n        \n}\n\nvec4 musicalSunlight_2(vec2 fragCoord , vec2 coord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\n\t// Set the parameters of the sun rays\n\tvec2 rayPos2 = vec2(iResolution.x * 0.8, iResolution.y * -0.6);\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\tfloat raySeedA2 = 22.399;\n\tconst float raySeedB2 = 18.0234;\n    float raySpeed2 = 0.001;//SPEED2 - original 1.1 controls fade in/out\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n \n    return\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2);\n}   \n\n\nvoid musicalSunlightMap( inout vec4 fragColor, \n    in vec2 coord, in vec4 rays1, in vec4 rays2)\n{\n    fragColor = rays1 * 0.5 + rays2 * 0.1;\n\t\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\t// Give the whole thing a blue-green tinge as well.\n\n\tfloat brightness = (1.0 - (coord.y / iResolution.y))*1.1;\n    //fragColor *= vec4(brightness);\n\tfragColor.r *= 0.1 + (brightness * 0.8); // + 0.1\n\tfragColor.g *= 0.3 + (brightness * 0.6); // + 0.3\n\tfragColor.b *= 0.5 + (brightness * 0.5); // + 0.5*/\n}\n\n//END SUN STUFF\n\n\n//SNOW STUFF\n\n// iq's hash function from https://www.shadertoy.com/view/MslGD8\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nfloat simplegridnoise(vec2 v)\n{\n    float s = 1. / 256.;\n    vec2 fl = floor(v), fr = fract(v);\n    float mindist = 1e9;\n    for(int y = -1; y <= 1; y++)\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 pos = .5 + .5 * cos(2. * pi * (T*.1 + hash(fl+offset)) + vec2(0,1.6));\n            mindist = min(mindist, length(pos+offset -fr));\n        }\n    \n    return mindist;\n}\n\nfloat blobnoise(vec2 v, float s)\n{\n    return pow(.5 + .5 * cos(pi * clamp(simplegridnoise(v)*2., 0., 1.)), s);\n}\n\nfloat fractalblobnoise(vec2 v, float s)\n{\n    float val = 0.;\n    const float n = 4.;\n    for(float i = 0.; i < n; i++)\n        //val += 1.0 / (i + 1.0) * blobnoise((i + 1.0) * v + vec2(0.0, iTime * 1.0), s);\n        val += pow(0.5, i+1.) * blobnoise(exp2(i) * v + vec2(0, T), s);\n\n    return val;\n}\n\n//END SNOW STUFF\n\n// SUN CIRCILE STUFF\nvoid sun(vec2 r, vec2 center, float radius, vec4 color, inout vec4 pixel) {\n\t\n    if( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //snow code\n    T = iTime;\n    vec2 r = vec2(1., iResolution.y / iResolution.x);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float snow_val = fractalblobnoise(r * uv * 20.0, 30.0);\n    //end snow code\n    \n    //sun rays code\n\tvec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\tvec4 rays1 = musicalSunlight_1(fragCoord, coord);\n    vec4 rays2 = musicalSunlight_2(fragCoord, coord);\n\tmusicalSunlightMap(fragColor, coord, rays1, rays2);\n    //end sun code\n    \n    //mixing shaders with the background image\n    vec4 texColor = texture(iChannel1, uv);\n    fragColor *= texColor*6.;\n    fragColor = mix(fragColor, vec4(1.0), vec4(snow_val * 0.5));\n    \n    //sun circle code\n    vec4 pixel = fragColor;\n    // get the distance b/w two points w/ aspect ratio\n    vec2 special_vector =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n    float time = iTime / 2.0; // period \n        float x = 1.3*sin(time) +  - 0.9*cos(time);\n        float y = 1.5*sin(time) + cos(time);\n        // increase the red as it goes through quadrant 1\n        vec4 yellowpink = vec4(1.0, 0.6 + cos(time), 0.00, 0.00); \n    if (special_vector.y > 0.3){ // horizion line (ish)\n        //oscilate w/ gradient \n        sun(special_vector, vec2(x , y - 0.5), 0.2, yellowpink, fragColor);\n       \n        }\n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1582, 1595, 1633, 1633, 1739], [1742, 1742, 1850, 1850, 2241], [2246, 2246, 2299, 2299, 2856], [2858, 2858, 2911, 2911, 3450], [3456, 3456, 3554, 3554, 3987], [4021, 4086, 4107, 4107, 4198], [4200, 4200, 4231, 4231, 4623], [4625, 4625, 4659, 4659, 4738], [4740, 4740, 4781, 4781, 5039], [5059, 5080, 5155, 5155, 5216], [5218, 5218, 5275, 5291, 6595]], "test": "error"}
{"id": "sdjGRD", "name": "Volcanic trenches", "author": "jarble", "description": "A simple fractal formula.", "tags": ["lava", "volcano", "volcanic"], "likes": 4, "viewed": 159, "published": "Public API", "date": "1617072402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(iTime/2.0,iTime/8.0)/10.0;\n    for(int c=0;c<3;c++){\n        float scale = 2.5;\n        float scale1 = 1.5;\n        float scale3 = 8.0;\n        for(int i=0;i<9;i++)\n        {\n            uv = (fract(uv/scale1)+fract(uv/scale/scale3))*scale1;\n            uv= fract(uv/(scale1-fract((uv.x-uv.y)/(scale3)))-(uv/(scale+(fract(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yx;\n            uv=uv.yx+col.xy;\n            uv.x *= -1.;\n\n        }\n        col[c] += abs(fract(uv.y)-fract(uv.x));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 748]], "test": "valid"}
{"id": "sdl3Ds", "name": "Alien Eyes", "author": "Shapkofil", "description": "Something I made while playing around with hexagon tiling. ", "tags": ["alieneyeeyes2danimationsoundcloud"], "likes": 4, "viewed": 61, "published": "Public", "date": "1616774508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ?\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat cdHex(vec2 pos){\n    vec2 p = abs(pos);\n    float c = dot(p, normalize(vec2(1,1.73)));\n\n    return max(c,p.x);\n}\n\nvec4 HexTile(vec2 p){\n    vec2 rate = vec2(1,1.73);\n    vec2 hrate = .5*rate;\n    vec2 a = mod(p, rate) - hrate;\n    vec2 b = mod(p - hrate, rate) - hrate;\n\n    vec2 gv = length(a)<length(b)?a:b;\n\n    vec2 id = 2.0*(p - gv);\n    return vec4(gv,id);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = mod(x, 2.0*c);\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat saw(float x){\n    return int(floor(x))%2==0?fract(x):1.0-fract(x);\n}\n\nfloat bquant(float bl, vec4 bond){\n    return smoothstep(bond.x, bond.y, bl) - smoothstep(bond.z, bond.w, bl);\n}\n\nfloat blink(float x){\n    float bl = min(mod(iTime,x), 1.0);\n    return 1.0 - bquant(bl, vec4(0.0, .2, .28, .4));\n}\n\nfloat hash21(vec2 p){\n    //return fract( sin(p.x*184.0 + p.y*425.)*532. );\n    return length(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    p *= 1.75;\n\n    vec3 col = vec3(0.0);\n\n    vec4 hc = HexTile(p.yx);\n\n    vec2 pey = 4.0*hc.yx;\n    vec2 rad = vec2(.5*atan(hc.w+0.01, hc.z)/3.1415 + .5, 1.0/(length(hc.wz) + 1.0));\n    //pey = p;\n\n    pey.y = abs(pey.y);\n    float bl = min(blink(5.0 + 2.0*hash21(rad)),blink(13.0)) + 0.025*cos(iTime+hash21(0.01*hc.wz));\n    bl *= smoothstep(.05, .1, cubicPulse(1.0, pow(rad.x/16.0 + rad.y, .5), .05*iTime));\n    float sr = smoothstep(.55, 1.0, fract(.5*.05*iTime));\n    float sdEye = sdParabola(pey, -clamp(bl*bl, 0.06, 1.0)) - bl + 0.06;\n    col += smoothstep(0.015, 0.025, abs(sdEye));\n\n    float dt = floor(iTime*.8 + fract(iTime)*1.5*sr);\n    float ft = fract(iTime*.8 + fract(iTime)*1.5*sr);\n    vec2 da0 = sin(1.7*(dt+0.0)) + sin(2.3*(dt+0.0)+vec2(1.0,2.0));\n    vec2 da1 = sin(1.7*(dt+1.0)) + sin(2.3*(dt+1.0)+vec2(1.0,2.0));\n    vec2 da = mix(da0,da1,smoothstep(0.95,1.0,ft));\n    float shd = fract(.5*.05*iTime);\n    da = mix(da, vec2(0), smoothstep(.848, .85, shd));\n    col = min(col, smoothstep(-0.01, 0.0, max(length(2.0*hc.xy - .2*da) -\n                                              .3 - .5*smoothstep(.895, .9, shd),\n                                              sdEye)));\n    //col -= smoothstep(.05, .06, hc.y * (hc.z*sin(2.0*iTime) + hc.w*sin(3.0*iTime)));\n\n    fragColor = vec4(1.0-col , 1.0);\n}\n", "image_inputs": [{"id": "ltlSWN", "previewfilepath": "https://soundcloud.com/user-735274416/alien-eyes", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-735274416/alien-eyes", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 398], [400, 400, 422, 422, 518], [520, 520, 541, 541, 770], [772, 772, 819, 819, 936], [938, 938, 957, 957, 1012], [1014, 1014, 1048, 1048, 1126], [1128, 1128, 1149, 1149, 1243], [1245, 1245, 1266, 1320, 1344], [1346, 1346, 1401, 1401, 2782]], "test": "valid"}
{"id": "sdl3Wl", "name": "Breaking Blocks", "author": "midorikuma", "description": "first post", "tags": ["minecraft"], "likes": 4, "viewed": 70, "published": "Public", "date": "1616763349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define white vec3(1.0)\n#define black vec3(0.0)\nconst vec3 grass = vec3(0.0, 0.8, 0.0);\nconst vec3 dirt = vec3(1.0, 0.5, 0.0);\nconst float rad = radians(360.0)/6.0;\nfloat time;\nfloat angle;\n\nvoid times(out float time,out float angle)\n{\n    time = mod(iTime*2.0,8.0);\n    float count = floor(iTime/4.0);\n    float rad = radians(360.0)/1.0;\n    angle = mod(count,rad);\n}\n\nvoid strain(inout vec3 i,inout vec2 q,float num,inout float angle,inout float r,float bold){\n    float s = sin(-angle);\n    float c = cos(-angle);\n    q = q-vec2(c,s)*r*(1.0-bold);\n    angle = angle+rad*num;\n    s = sin(angle);\n    c = cos(angle);\n    vec2 qr = q * mat2(c, -s, s, c);\n    r = bold*4.0+bold*num;\n    if (qr.y<bold&&qr.y>-bold&&qr.x>0.0&&qr.x<r){\n    i = black;\n    }\n}\n\nvoid strain3(inout vec3 i,vec2 q,float time,float num,float angle,float r){\n    float bold = 0.03;\n    strain   (i,q,num,angle,r,bold);\n}\nvoid strain2(inout vec3 i,vec2 q,float time,float num,float angle,float r){\n    float bold = 0.04;\n    strain   (i,q,num,angle,r,bold);\n    if (time>4.0){\n    strain3   (i,q,time,0.8,angle,r);\n    strain3   (i,q,time,5.2,angle,r);\n    }\n}\nvoid strain1(inout vec3 i,vec2 q,float time,float num,float angle,float r){\n    float bold = 0.05;\n    strain   (i,q,num,angle,r,bold);\n    if (time>3.0){\n    strain2   (i,q,time,1.3,angle,r);\n    strain2   (i,q,time,5.3,angle,r);\n    }\n}\n\nvoid gradation(vec2 p,inout vec3 i)\n{\n    i=i-vec3(1.0+p.x-p.y,1.0+p.x,0.0)*0.05;\n}\nvoid surface(vec2 p, vec2 offset, bool side, float rad, inout vec3 i){\n    float s = sin(radians(rad));\n    float c = cos(radians(rad));\n    mat2 rot = mat2(c, -s, s, -c) * mat2(-c, s, -s, -c);\n    times(time,angle);\n    if(side==false){\n        rot = mat2(c/1.5, -s*2.0, s/1.5, c*2.0);\n    }\n    if (time<1.0){\n        p.y=p.y-(1.0-time)*time*1.0;\n    }\n    vec2 q = p / 0.3 *  rot - offset*0.999;\n    if (time<5.0){\n    if(abs(q.x) < 1.0 && abs(q.y) < 1.0){\n        i = grass;\n    if(side==true && q.y < 0.5){\n        i = dirt;\n    }\n        gradation (q,i);\n    }\n    if (time>2.0){\n    float r = 0.0;\n    strain1   (i,q,time,0.0,angle,r);\n    strain1   (i,q,time,2.0,angle,r);\n    strain1   (i,q,time,4.0,angle,r);\n    }\n    }\n}\n\n\nvoid particle(vec2 p,float time0,inout vec3 i)\n{\n    times(time,angle);\n    if (time>time0) {\n    for (float n=0.0;n<time0*time0;++n)\n{\n    float nradx =sin(1.0*n*n/time0+angle)*4.0;\n    float nrady =sin(0.5*n+time0)*2.0-1.0;\n    float x = (time-time0)*1.0;\n    float y = x-0.25;\n    if (nradx>0.0){\n        x=-x;\n    }\n    vec2 q = (p - vec2( x*3.0/time0, -y*y*4.0)) / 0.1+vec2(nradx,nrady);\n    if(abs(q.x) < 0.6 && abs(q.y) < 0.6){\n    i = dirt*0.6+n*0.01;\n    }\n    }\n}\n}\nvoid particles(vec2 p,inout vec3 i)\n{\n    particle  (p,2.0,i);\n    particle  (p,3.0,i);\n    particle  (p,4.0,i);\n    particle  (p,5.0,i);\n}\nvoid background(vec2 p,inout vec3 i)\n{\n    i=vec3(p.y*0.3,1.0+p.y*0.6,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 destColor = black;\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    background  (p,destColor);\n    surface   (p, vec2( 1.0, -1.0), true, -10.0, destColor);\n    surface   (p, vec2( -1.0, -1.0), true, 10.0, destColor);\n    surface   (p, vec2( 1.0, 1.0), false, -45.0, destColor);\n    particles  (p,destColor);\n    fragColor = vec4(destColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdl3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 235, 235, 368], [370, 370, 462, 462, 754], [756, 756, 831, 831, 893], [894, 894, 969, 969, 1132], [1133, 1133, 1208, 1208, 1371], [1373, 1373, 1410, 1410, 1456], [1457, 1457, 1527, 1527, 2189], [2192, 2192, 2240, 2240, 2667], [2668, 2668, 2705, 2705, 2807], [2808, 2808, 2846, 2846, 2885], [2887, 2887, 2943, 2943, 3340]], "test": "error"}
{"id": "sdlGDN", "name": "Conic gradient", "author": "brunoimbrizi", "description": "Radial / conic gradient. Forked from https://www.shadertoy.com/view/3l23RK", "tags": ["sdf", "radial", "gradient", "conic", "pie", "horseshoe"], "likes": 1, "viewed": 131, "published": "Public", "date": "1616060776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from https://www.shadertoy.com/view/3l23RK\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n\n#define PI 3.1415\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float falloff = 1.0;\n    float t = PI;\n    float u = (PI + falloff) * (0.5+0.5*cos(iTime*0.52)) - falloff;\n    \n    \n    // distance\n    float d = sdPie(uv,vec2(sin(t),cos(t)), 0.5);\n    d = sdHorseshoe(uv,vec2(cos(0.0),sin(0.0)), 0.5, vec2(0.0, 0.2));\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d);\n    \n    float a = 0.0;\n\tif (uv.y >= 0.0) a =      atan(uv.y,  uv.x);\n    if (uv.y <  0.0) a = PI - atan(uv.y, -uv.x);\n    \n    vec2 angle = vec2(u * 2.0, (u + falloff) * 2.0);\n    \n    a = smoothstep(angle.x, angle.y, a);\n    a = 1.0 - a;\n\n    col = min(col, vec3(a));\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlGDN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1132, 1278, 1344, 1344, 1603], [1605, 1655, 1704, 1704, 1847], [1849, 1849, 1906, 1942, 2640]], "test": "valid"}
{"id": "sdlGWN", "name": "5. Domain Distorted Rectangle", "author": "Sp3cim4n", "description": "Learning Shaders", "tags": ["distortion", "learning", "domaindistortion"], "likes": 2, "viewed": 151, "published": "Public API", "date": "1615998927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    \n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float top, float bottom, float blur)\n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, top, bottom, blur);\n    return band1 * band2;\n}\n\nfloat Remap01(float a, float b, float t)\n{\n    return (t - a) / (b - a);\n}\n\nfloat Remap(float a, float b, float c, float d, float t)\n{\n    return Remap01(a,b,t) * (d - c) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float x = uv.x;\n    float t = iTime;\n    float m = 0.1*sin(t + x * 10.);\n    float y = uv.y - m;\n    \n    float blur = Remap(-.8, .8, 0.01, .8, x);\n    blur = blur * blur * blur;\n    float mask = Rect(vec2(x,y), -.8, .8, -.1, .1, blur);\n    \n    vec3 color = vec3(1.,1.,0.);\n    color *= mask;\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdlGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 208], [210, 210, 293, 293, 419], [421, 421, 463, 463, 495], [497, 497, 555, 555, 598], [600, 600, 657, 657, 1107]], "test": "valid"}
{"id": "sds3Ds", "name": "p6 voronoy pattern", "author": "DEMERCY", "description": "practice2020", "tags": ["pattern"], "likes": 0, "viewed": 104, "published": "Public API", "date": "1616777480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p ){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+= dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float m = 0.;\n    float t = iTime*4.;\n    \n    float minDist =3.;\n    vec3 col = vec3(0);\n    \n    if(false){\n        for(float i = 0.;i<50.;i++){\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n*t);\n            \n            float d = length(uv - p);\n            m += smoothstep(.02,.01,d);\n            if(d < minDist){\n                minDist = d;\n            }\n        }\n    }else{\n       uv *= 5.;\n       vec2 gv = fract(uv) - .5;\n       vec2 id = floor(uv);\n       vec2 cid = vec2(0);\n       //col.rg = abs(id*.1);\n       \n       for(int y = -1;y<= 1;y++){\n            for(int x = -1;x<= 1;x++){\n               vec2 offs = vec2(x,y);\n               \n               vec2 n =  N22(id + offs);\n               vec2 p = offs + sin(n*t)*.5;\n               float d = length(gv-p);\n               \n               //p-= gv;                  //Manhattan Dist\n               //d = length(p);\n               //d = abs(p.x)+abs(p.y);\n               if(minDist > d){\n                   minDist = d;\n                   cid = abs(id+offs);\n                   //col   = vec3(cid,.5);\n               }\n            }\n            \n        }\n       //col   = vec3(cid*.1,minDist); \n       col = vec3(1.,minDist,minDist);\n    }\n    \n    \n    \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sds3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 140], [142, 142, 199, 199, 1537]], "test": "valid"}
{"id": "sdS3Dz", "name": "Moving Mold", "author": "iamyou__", "description": "wow", "tags": ["mold"], "likes": 0, "viewed": 21, "published": "Public", "date": "1617226198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932384;\n\nfloat map (in vec3 p) {\n    // Sphere\n    float d = length(p) - 0.15;\n    \n    // Plane\n    float bend = 1.1;\n    float zoom = 1.8;\n    float d2 = max(p.y + length(vec2(p.x, p.z)) -  bend, zoom);\n    \n    return smoothstep(d, d2, 1.2);\n}\n\nvec3 sn ( in vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                             map(p + e.yxy) - map(p - e.yxy),   \n                             map(p + e.yyx) - map(p - e.yyx)));               \n}\n\nfloat march(in vec3 o, in vec3 d)\n{\n    float t = 0.0;\n    for (int i = 0; i <=100; i++) {\n        vec3 pos = o + t * d;\n        float h = map(pos);\n        \n        if (h < 0.0001) break;\n        t += h;\n        if (t > 20.0) break;\n    }\n    if (t < 20.0) {\n        return t;\n    }\n    return -1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // Camera parameters\n    float mi = 5.0 * iMouse.x / iResolution.x;\n    mi = iTime;\n    vec3 o = vec3(1.0 * sin(mi), 0.0, 1.0 * cos(mi));\n    vec3 lookat = vec3(0.0);    \n    vec3 forward = normalize(lookat - o);\n    vec3 camRight = normalize ( cross(forward, vec3(0, 1, 0)));\n    vec3 camUp = normalize ( cross(camRight, forward));\n    vec3 d = normalize( uv.x * camRight + uv.y * camUp + 1.0 * forward);\n    \n    // Lights\n    vec3 lc = vec3(2.0);\n    vec3 lp = vec3(4.5, 4.2, 3.5);\n   \n    // colors\n    vec3 sc = vec3(0.17, 0.15, 0.4);\n    \n    float t = march(o, d);\n    if (t > 0.0) {\n        vec3 p = o + t * d;\n        vec3 ld = normalize(lp - p);\n        vec3 n = sn(p);\n        float diff = max(dot(n, ld), 0.0) / pi;\n        col = sc + diff * lc;\n    }\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 64, 78, 278], [280, 280, 302, 302, 539], [541, 541, 576, 576, 843], [846, 846, 903, 953, 1853]], "test": "valid"}
{"id": "sds3zl", "name": "polygon n", "author": "jezersek", "description": "polygon", "tags": ["polygon"], "likes": 2, "viewed": 176, "published": "Public API", "date": "1616424037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mind = 1.;\nvec4 color(float v, vec3 col){\n    vec3 c = vec3(v*.1,v*.1,v*.1);\n    c += mix(vec3(0,0,0), col, 0.1/(v*pow(sin(v*100.),2.)));\n    return vec4(c, 1);\n}\n\nvec2 point(int i){\n    float j = float(i);\n    float fx = (2.+sin(iTime/10.+j))*10.;\n    vec2 p = vec2(\n        mix(0.2,iResolution.x/mind-0.2, 0.5+0.5*sin(iTime*0.17+fx)), \n        mix(0.2,iResolution.y/mind-0.2, 0.5+0.5*cos(iTime*0.19+fx))\n    );\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    mind = min(iResolution.y, iResolution.x);\n    vec2 uv = fragCoord/mind;\n    \n    // distortion\n    float rotationSpeed = 0.1;\n    float amplitude = 0.05;\n    float rotation = (uv.x*sin(iTime*rotationSpeed)+uv.y*cos(iTime*rotationSpeed))*10.;\n    uv.x += sin(rotation+iTime)*amplitude;\n    uv.y += cos(rotation+iTime)*amplitude;\n   \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float v = 1./0.; // neskončno\n    \n    int n = 5; // stevilo ogljišč\n    \n    for(int i=0; i<n; i++){\n        int j = (i+1)%n;\n        \n        float s = 0.;\n        \n        vec2 p1 = point(i);\n        vec2 p2 = point(j);\n        \n        vec2 pMid = (p1+p2)/2.;\n        \n        float dp = distance(p1, pMid); // razdalja od sredine daljice do oglijšča\n    \n        // izračunaj razdaljo od premice (med p1 in p2)\n        vec2 r = normalize(p1 - p2); // smerni vektor\n        float d = length(uv-p1-dot(r, uv-p1)*r); // razdalja trenutne točke od premice\n        \n        // izračunaj razdaljo pravokotne projekcije uv na daljico do središča daljice med p1 in p2\n        float dMid = length(dot(r,uv-pMid));\n        \n        // če je razdalja od središča daljice prevelika, vzemi razdaljo do enega ogljišča (p1/p2)\n        if(dMid > dp) d = distance(uv, p1); \n        \n        if(d < v)v = d;\n    }\n    \n    fragColor = color(v, col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sds3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 47, 47, 168], [170, 170, 188, 188, 439], [441, 441, 498, 498, 1854]], "test": "valid"}
{"id": "sdSGRw", "name": "Batik patterns", "author": "jarble", "description": "This fractal makes many patterns that resemble batik cloth.\nFull-screen mode recommended.", "tags": ["fractal", "batik"], "likes": 4, "viewed": 174, "published": "Public API", "date": "1617113772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07);\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .16;\n    float scale2 = 1.2;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n            vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<6;c++){\n        float scale = c1.z;\n\n        for(int i=0;i<3;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            //scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            //uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [516, 725, 772, 772, 828], [830, 830, 887, 887, 1627]], "test": "valid"}
{"id": "sdSGzw", "name": "raymarching 123435", "author": "csgradle", "description": "lol. don't know what i'm doing here.\nmap function from inigo quilez", "tags": ["raymarching"], "likes": 0, "viewed": 90, "published": "Public", "date": "1617120808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 30.\n#define MIN_HIT 0.0001\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 rotation(vec3 point, vec3 axis, float angle){ // https://www.shadertoy.com/view/Wtl3zN\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise3(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n// fog by inigo quilez\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float b = 0.02;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor  = vec3(0.2);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat getDist(vec3 p) {\n    float dist = MAX_DIST; \n    float node = sdOctahedron( opRep( p-vec3(0., 0., 0.), vec3(10.)), 2.5 );\n    dist = min( dist, node);\n    \n   \n    \n    vec3 pXpos = opRep( (p-vec3(5.,0.,0.)), vec3(10.));\n    vec3 pYpos = opRep( (p-vec3(0.,5.,0.)), vec3(10.));\n    vec3 pZpos = opRep( (p-vec3(0.,0.,5.)), vec3(10.));\n    \n    pXpos.yz *= rotate2d(p.x*0.5);\n    pYpos.xz *= rotate2d(p.y*0.5);\n    pZpos.xy *= rotate2d(p.z*0.5);\n    \n    float pipeX = sdBox( pXpos , vec3(4,0.5,0.5) );\n    dist = min( dist, pipeX );\n    float pipeY = sdBox( pYpos, vec3(0.5,4.,0.5) );\n    dist = min( dist, pipeY );\n    float pipeZ = sdBox( pZpos, vec3(0.5,0.5,4.) );\n    dist = min( dist, pipeZ );\n    \n    return dist;\n}\nfloat map1(vec3 pOriginal){\n  vec4 p = vec4(pOriginal, 1); // w coordinate is our \"space scale\"\n  for(int i = 0; i < 5; i++){\n    if (p.x > p.y) p.xy = p.yx; // reflection\n    if (p.z > p.y) p.zy = p.yz; // reflection\n    p.xyz = abs(p.xyz) - 0.1; // reflection and movement\n    p *= 1.7;   // scaling\n    p.xyz = mod(p.xyz - 0.5,1.) - 0.5;   // simple space repetition\n  \n    p /= dot(p.xyz,p.xyz); // kleinian/sphere inversion\n  }\n  \n  p.xyz /= p.w; // VERY IMPORTANT, unscale/untransform back space\n\n  float distance = length(p.xyz); // INSERT ANY SDF HERE\n  return distance;\n}\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\tvec4 orb = vec4(1000.0); \n\t\n\tfor( int i=0; i<7;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p);\n    vec3 n = d-vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx));\n    return normalize(n);\n}\nvec2 rayMarchAll(vec3 ro, vec3 rd) {\n    float rayDist = 0.;\n    float steps = 0.;\n    for(int step = 0; step < MAX_STEPS; step++) {\n        vec3 pos = ro + rd*rayDist;\n        float distanceHit = map(pos, 1.3);\n        rayDist += distanceHit;\n        steps = float(step);\n        if(distanceHit < MIN_HIT || abs(rayDist) > MAX_DIST) break;   \n    }\n    return vec2(rayDist,steps);\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n    return rayMarchAll(ro, rd).x;\n    \n}\n\nvec3 getLight(vec3 p, vec3 sun) {\n    \n    vec3 n = getNormal(p);\n    float lighting = dot(n, normalize(sun-p));\n    lighting = clamp(lighting, 0., 1.);\n    \n    vec2 d = rayMarchAll(p+n*MIN_HIT*1.1, normalize(sun-p));\n    float baseCol = d.y/float(MAX_STEPS);\n    if(d.x < length(sun- p)) {\n       //lighting = lighting * 0.5;\n    }\n    \n\n    vec3 col = vec3(baseCol,1.-baseCol,step(baseCol, 0.9));\n    //col = vec3(baseCol);\n    return lighting*col;\n}\nvec3 cameraPath(float t) {\n    float x = sin(t*1.)*5.;\n    float y = cos(t*1.)*5.;\n    float z = t/3.1415926*20.+5.;\n    return vec3(x,y,z);\n}\n// https://www.shadertoy.com/view/WlKBDw thank you!!\nmat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = map(iMouse.y/iResolution.y,0.,1.,1.7, 30.);\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    \n    vec3 rayOrigin = vec3(-3.,-2.93,95.-iTime);\n    \n    vec3 cameraPx = vec3(uv.x, uv.y, 1.);\n    vec3 rayDir = normalize(cameraPx * lookAt(cameraPath(iTime), cameraPath(iTime+.5)*0.9));\n    rayDir.y *= -1.;\n    vec3 sun = vec3(0., 0., 0.);\n    sun = rayOrigin+vec3(0.,-1.8,0.);\n    \n    \n    float d = rayMarch(rayOrigin, rayDir);\n    if(d < MAX_DIST) {\n        vec3 p = rayOrigin+rayDir*d;\n\n        vec3 l = getLight(p, sun);\n        col = l;\n    }\n    col = applyFog(col, d);\n    // gamma correction\n    col = vec3(col.x*col.x, col.y*col.y, col.z*col.z);\n    fragColor = vec4(col*5.,1.);\n} \n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 138, 138, 204], [205, 205, 255, 296, 847], [848, 848, 876, 876, 962], [963, 1038, 1063, 1063, 1082], [1083, 1083, 1108, 1108, 1127], [1128, 1128, 1164, 1164, 1192], [1194, 1194, 1232, 1232, 1285], [1286, 1286, 1321, 1321, 1347], [1348, 1348, 1379, 1379, 1466], [1467, 1467, 1502, 1502, 1553], [1555, 1555, 1577, 1577, 1716], [1717, 1802, 1824, 1824, 2228], [2229, 2229, 2251, 2251, 2296], [2297, 2297, 2317, 2317, 2362], [2363, 2363, 2381, 2381, 2420], [2422, 2422, 2443, 2443, 2934], [2935, 2958, 3088, 3088, 3235], [3236, 3236, 3259, 3259, 3963], [3964, 3964, 3991, 3991, 4544], [4545, 4545, 4575, 4575, 4843], [4844, 4844, 4868, 4868, 5025], [5026, 5026, 5062, 5062, 5409], [5410, 5410, 5444, 5444, 5485], [5487, 5487, 5520, 5520, 5940], [5941, 5941, 5967, 5967, 6083], [6084, 6137, 6179, 6179, 6371], [6373, 6373, 6430, 6430, 7191]], "test": "valid"}
{"id": "sdSGzz", "name": "Pixel Windfaker Water", "author": "jsfehler", "description": "Trying to replicate the more delicate lighting of complex pixel art.\n\nInspired by https://www.deviantart.com/oni1ink/art/Tutorial-How-to-draw-Water-645199166", "tags": ["voronoi", "water", "zelda", "toon", "pixellate", "windwaker", "voronoiegde"], "likes": 6, "viewed": 107, "published": "Public", "date": "1616863844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 firstColorlo = vec3(.18,.47,.86);\nvec3 middleColorlo = vec3(.16,.65,1.0);\nvec3 endColorlo = vec3(.54,1.0,1.0);\n\nvec3 firstColorlt = vec3(.08,.38,.63);\nvec3 middleColorlt = vec3(.16,.65,1.0);\nvec3 endColorlt = vec3(.54,1.0,1.0);\n\nfloat densityLayer1 = 10.0;\nfloat densityLayer2 = 6.0;\n\nint pixellateX = 5;\nint pixellateY = 4;\n\nvec2 pseudoRand(vec2 p) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// https://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nvec3 vorobord( in vec2 x ) {\n    vec2 idx = floor(x);\n    vec2 pad = fract(x);\n\n\tvec2 selfcell, closecell;\n\n    float mindist = 4.0;\n    for( float x = -1.0; x <= 1.0; ++x) {\n        for(float y = -1.0; y <= 1.0; ++y) {\n            vec2 offset = vec2(x, y);\n            vec2 self = pseudoRand( idx + offset );\n            self = 0.5 + 0.5*sin( iTime * self * .5 );\n            vec2 neighbor = offset + self - pad;\n            float dist = length(neighbor);\n\n            if (dist < mindist) {\n                mindist = dist;\n                closecell = neighbor;\n                selfcell = offset;\n            }\n        }\n    }\n\n    mindist = 4.0;\n    for(float x = -2.0; x <= 2.0; ++x) {\n        for(float y = -2.0; y <= 2.0; ++y) {\n            vec2 offsetcell = selfcell + vec2(x, y);\n            vec2 self = pseudoRand(idx + offsetcell);\n            self = 0.5 + 0.5*sin(iTime * self  * 0.5);\n            vec2 neighbor = offsetcell + self - pad;\n\n            if(length(closecell - neighbor) > 0.00001){\n                mindist = sin(min(mindist, dot(0.5 * (closecell + neighbor), normalize(neighbor - closecell))));\n            }\n        }\n    }\n\n    return vec3(mindist, closecell);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Pixellate\n    fragCoord.x -= (float(int(fragCoord.x * 1.0) % pixellateX) / 1.0);\n    fragCoord.y -= (float(int(fragCoord.y * 1.0) % pixellateY) / 1.0);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Animate the texture for a water ripple\n    vec3 displ = vec3(texture(iChannel0, (uv * 0.25) + (sin(iTime * .15) * 0.25) + 0.25).xyz);\n    \n    // Create a voronoi pattern\n    vec3 layerone = vorobord(densityLayer1 * mix(uv, displ.rg, 0.12));\n    vec3 layertwo = vorobord(densityLayer2 * mix((uv + .5), displ.rg, 0.1));\n    \n    // Color the the upper portion\n    // Based on y position, fade from white to blue\n    vec3 upperColor1 = vec3(.24, .8, 1.0);\n    upperColor1 += (uv.y/2.);\n\n    vec3 upperColor2 = vec3(.16, .65, 1.);\n    upperColor2 += (uv.y);\n\n    // Gradient a base water color\n    // Mercilessly ganked from https://www.shadertoy.com/view/ttB3Rh\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    float h = 0.5; // adjust position of middleColor\n    vec3 waterColorlo = mix(mix(firstColorlo, middleColorlo, xy.y/h), mix(middleColorlo, endColorlo, (xy.y - h)/(1.0 - h)), step(h, xy.y));\n    vec3 waterColorlt = mix(mix(firstColorlt, middleColorlt, xy.y/h), mix(middleColorlt, endColorlt, (xy.y - h)/(1.0 - h)), step(h, xy.y));  \n\n    // Mix the upper layer with water color\n    vec3 locol = mix(upperColor1, waterColorlo, smoothstep(0.09, 0.1, layerone.x * 2.2));\n    locol = mix(upperColor2, locol, smoothstep(0.09, 0.1, layerone.x * 4.0));\n    \n    // Mix the lower layer with water color\n    vec3 ltcol = mix(vec3(.8,.8,1.0), vec3(1.0, 1.0, 1.0), smoothstep(0.04, 0.04, layertwo.x * 0.3));\n    ltcol = mix(waterColorlt, ltcol, smoothstep(0.09, 0.1, layertwo.x * 2.0));\n    \n    // Mix uppper water with lower water\n    vec3 vorolayers = mix(locol, ltcol, 0.3);\n\n    fragColor = vec4(vorolayers, 1.0);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 356, 356, 446], [448, 521, 549, 549, 1708], [1711, 1711, 1768, 1786, 3600]], "test": "error"}
{"id": "sdX3Dr", "name": "ROCK PLANET ", "author": "romeosoft", "description": "Earth-like rocky planet simulation.\nThanks to IQ for creating this website, I simulated many interesting things.", "tags": ["earth", "planet"], "likes": 3, "viewed": 95, "published": "Public", "date": "1615863125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\nconst float pi = 3.1415926;\n\nconst vec3 \n    c1 = vec3(0.04, 0.02, 0.3),\n\tc2 = vec3(0.12, 0.06,1.25);\nconst vec3 \n    c3 = vec3(0.06, 0.1, 0.1),\n\tc4 = vec3(0.10, 0.10,0.9);\n\nconst float R = 0.5;\n\nfloat time;\n\n//--------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.001 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 7; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*2.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\n// iq's noise\n//--------------------------------------------------------------\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n*5.;\n}\n/*\n// The following are from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n*/\n//--------------------------------------------------------------\n// hsv and rgb\n//--------------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n\n//--------------------------------------------------------------\nconst float unit = 0.001;\nvec3 getCor(float r, vec3 p, float dr, vec3 v, vec3 right, vec3 up)\n{\n    vec3 p2 = p + right * unit;\n    p2 = normalize(p2);\n    float dr2 = fbm(p2 * (r * 3.0)) * 0.01;\n    p2 = p2 * (r + dr2 - dr);\n    \n    vec3 p3 = p + up * unit;\n    p3 = normalize(p3);\n    float dr3 = fbm(p3 * (r * 3.0)) * 0.01;\n    p3 = p3 * (r + dr3 - dr);\n    \n    vec3 nz = normalize(cross(p2-p, p3-p));\n    vec3 cor0 = mix(vec3(0.0,0.1,0.0), vec3(0.8,0.6,0.5), dr / 0.1);\n    return mix(vec3(0.01,0.005,0.),cor0,clamp(-dot(vec3(-1.414 / 2.,-1.414 / 2.,0.), -nz),0.,1.));\n    \n}\n\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x + 80.5) / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n        \n    ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.75 + left*pp.x + up*pp.y);\n    float dis = length(cam);\n    float dotv = max(0.001, dot(v,front));\n    vec3 p = cam+v*(dis-R - 0.2);\n    \n    float dt = 0.0025;\n    vec3 cor = vec3(0.0);\n    \n    for(int i = 0; i < 150; i ++)\n    {\n        float r = length(p);\n        dt = mix(0.0001,0.01,smoothstep(0.,0.25,(r - R)/dotv)); // To be smooth\n\t\t\n        float dr = fbm(p*3.0) * 0.01;\n        if(r < R + 0.05)\n        {  \n            cor = mix(vec3(0.,0.0, 0.05),vec3(0.4,0.65,1.0),clamp(dot(normalize(p),vec3(-1.414 / 2.,-1.414 / 2.,0.)), 0., 1.));\n            break;\n        }\n        if(r < R + dr)\n        {  \n            vec3 right2 = normalize(cross(up,p));\n            vec3 up2 = normalize(cross(p,right2));\n            cor = getCor(r, p, dr, v, right2, up2);\n            break;\n        }\n        if(r < R + 0.2)\n        {\n           cor += (0.0075 * (smoothstep(0.2,0.,r-R))) * vec3(0.3,0.5,0.75);\n        }\n        p += v * dt;\n    }\n    fragColor = vec4(cor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdX3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 929, 957, 957, 1506], [1508, 1508, 1537, 1537, 1785], [1787, 1787, 1814, 1814, 2065], [2067, 2067, 2087, 2087, 2233], [2234, 2378, 2401, 2401, 2437], [2438, 2438, 2461, 2461, 2830], [2831, 2831, 2853, 2853, 3095], [3096, 4761, 4783, 4783, 5099], [5101, 5101, 5123, 5123, 5283], [5285, 5376, 5445, 5445, 5931], [5933, 5998, 6055, 6055, 7618]], "test": "valid"}
{"id": "sdX3RH", "name": "Fork am_produit anthonybat 703", "author": "anthonybattel", "description": "produit scalaire ex. 2", "tags": ["ateliermaths"], "likes": 3, "viewed": 86, "published": "Public", "date": "1616695017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////////////\n// Exercice : retourner la distance entre le point m et le segment AB\n/////////////////////////////////////////////////////////////////////\nfloat pointToSegmentDistance(vec3 m, vec3 A, vec3 B) {\n    vec3 AB = B - A;\n    float L = dot (AB, m - A) / length(AB);\n    if(L < 0.) {\n        return length(A - m); \n    } \n    else if (L > length(AB)){\n        return length(B - m); \n    }\n    else { \n        vec3 mprim = A + normalize(AB) * L; \n        return  length(m - mprim);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// Private\n/////////////////////////////////////////////////////////////////////\nfloat map(vec3 m) {\n    \n    float anim = iTime;\n    \n    vec3 A = vec3(cos(anim)*5., 0, 20.0+sin(anim)*5.);\n    vec3 B = A + (vec3(0, 0, 20)- A)*2.;    \n    \n    float radius = 3.0;\n    \n    return pointToSegmentDistance(m, A, B) - radius;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvec4 iridescent(in vec3 ray, in vec3 m, in vec3 normal) {\n\n   \tvec3 pos = m;\n    vec3 ref = reflect(ray, normal);\n    vec3 lig = normalize(vec3(.5,1,-.5));\n    vec3 dome = vec3(0,1,0);\n    vec3 eye = vec3(0,0,-1);\n\n    vec3 perturb = sin(pos * 1.);\n    vec3 color = spectrum( dot(normal + perturb * .05, eye) * 2.);\n\n    float specular = clamp(dot(ref, lig), 0., 1.);\n    specular = pow((sin(specular * 20. - 3.) * .5 + .5) + .1, 32.) * specular;\n    specular *= .1;\n    specular += pow(clamp(dot(ref, lig), 0., 1.) + .3, 8.) * .1;\n\n    float shadow = pow(clamp(dot(normal, dome) * .5 + 1.2, 0., 1.), 3.);\n    color = color * shadow + specular;\n\n    return vec4(color, 1.0);\n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 p, in vec3 normal, in vec3 lightSource) {\n    \n    vec3 light = normalize(p-lightSource);\n    vec3 light2 = normalize(vec3(-1,1,-8));    \n    \n    float distorsion = -0.6;\n    float diffuse = clamp(dot(normal, light2), 0.0, 1.0) * 1.;\n    vec3 outlight = normalize(light2 + normal * distorsion);\n    float scatter = clamp(dot(-ray, outlight), 0.0, 1.0) * 0.5;\n\n    vec4 outter_color = vec4(121, 179, 255, 255)/255.;    \n    vec4 inner_color  = vec4(0, 179, 255, 255)/255.;\n\n    vec3 cp = (p - vec3(0., 0.0, +20.0)) / 20.0;\n    outter_color = vec4(normalize(vec3(cp.x, 1.0-cp.z, cp.x)), 1.0);\n    \n    outter_color = vec4(normalize(vec3(1.0+cp.x, cp.y*10.0, -cp.z*10.)), 1.0);\n    inner_color = outter_color;\n    \n    vec4 solid_color = outter_color * (0.15+diffuse) + inner_color * scatter;        \n    \n    vec3 ref = reflect(light2, normal);\n    float specular = pow(clamp(dot(ref, ray), 0.0, 1.0), 60.0);\n    \n    vec4 irri = iridescent(ray, p, normal);\n\n    return mix(solid_color, irri, 0.75);\n    \n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n\n    const float zFar  = 40.0;\n\n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n    for(int i = 0; i<200; i++) {\n        m = origin + ray * marchingDist;    \n    \tfloat dist = map(m);\n        if(dist < 0.001) {\n            return true;\n        }\n        else {\n            marchingDist += dist * 0.75;\n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\nvec4 run(in vec2 fragCoord) {\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), 1.);\n    vec3\teye\t\t\t\t= vec3(0.0, 1.25, -0.185);\n    vec3\tray\t\t\t\t= normalize(viewportCoord);\n    vec3\tp;\n    \n    vec3\tlightSource\t\t= vec3(-20.0, 0.0, 40.0);\n    \n    if(rayMarching(eye, ray, p)) {\n        vec3 normal = computeNormal(p);\n        return computeColor(ray, p, normal, lightSource);\n    }\n    else {\n        return vec4(0.5, 0, 1.0, 1.0);  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = run(fragCoord); \n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdX3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 210, 264, 264, 551], [554, 705, 724, 724, 947], [949, 949, 1017, 1017, 1060], [1062, 1062, 1086, 1086, 1184], [1186, 1186, 1243, 1243, 1862], [1865, 1865, 1945, 1945, 2909], [2911, 2911, 2970, 2970, 3395], [3397, 3397, 3430, 3430, 3640], [3643, 3643, 3672, 3672, 4167], [4170, 4170, 4227, 4227, 4262]], "test": "valid"}
{"id": "sdX3WS", "name": "3D Shadertext", "author": "eimink", "description": "3D version of proportional spacing shadertext shader https://www.shadertoy.com/view/4s3XDn", "tags": ["3d", "text", "distance", "font"], "likes": 2, "viewed": 82, "published": "Public", "date": "1616442371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define line1 H_ E_ L_ L_ O_ crlf\n#define line2 S_ h_ a_ d_ e_ r_ t_ o_ y_\n\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w) {\n    return uv-vec2(cp-(w*.5),0.);\n}\n\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n//Render char always (no effects anymore)\n#define ch(l,w) x = min(x,l(clc(pp,cp+=w,w)));\n\n//Make it a bit easier to type text\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n    \n//Space\n#define _ cp+=.5;\n\n//Next line\n#define crlf pp.y += 2.0; cp = 0.;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf(vec3 p){\n   p = p + vec3(3.5,-1.,0.);\n   vec2 pp = p.xy;\n   float cp = 0.;\n   float x = 1.;\n   line1;\n   line2;\n   vec3 bd = vec3(7.,3.,0.2);\n   float res = max(x,sdBox(p,bd));\n   return res;\n}\n\nvec3 march(in vec3 ro, in vec3 rd, inout float t){\n\n    vec3 p = ro+rd;\n    for(int i = 0; i < 40; ++i){\n        float d = sdf(p);\n        t += d;\n        p += rd*d;\n        \n        if(d < 0.01 || t > 100.){\n            break;\n        }\n        \n    }\n    return p;\n}\n\nvec2 map( in vec3 pos)  \n{\n    float id = 0.;\n    \n    float d = sdf(pos);\n    \n    return vec2(d, id);\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.0000001, 0.0);\n    return normalize( vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                           map(pos+e.yxy).x-map(pos-e.yxy).x,\n                           map(pos+e.yyx).x-map(pos-e.yyx).x ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(sin(iTime)*10.,2.0,cos(iTime)*10.);\n    vec3 ct = vec3(0,0,0);\n    vec3 ld = cp;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    p = march(cp,rd,t);\n    \n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        col = vec3(0.2,0.6,0.8) + (clamp(dot(calcNormal(p), ld), 0.0, 1.0)*0.3);\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdX3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 113, 113, 238], [240, 290, 327, 327, 486], [487, 487, 506, 506, 560], [561, 561, 580, 580, 811], [812, 812, 831, 831, 901], [902, 902, 921, 921, 985], [987, 1011, 1030, 1030, 1280], [1281, 1281, 1300, 1300, 1367], [1368, 1368, 1387, 1387, 1626], [1627, 1627, 1646, 1646, 1684], [1685, 1685, 1704, 1704, 1887], [1888, 1888, 1907, 1907, 2070], [2071, 2071, 2090, 2090, 2238], [2239, 2239, 2258, 2258, 2367], [2368, 2368, 2387, 2387, 2440], [2441, 2441, 2460, 2460, 2532], [2533, 2533, 2552, 2552, 2706], [2707, 2707, 2726, 2726, 2747], [2748, 2748, 2767, 2786, 2943], [2944, 2944, 2963, 2963, 3053], [3054, 3054, 3073, 3073, 3094], [3095, 3095, 3114, 3114, 3197], [3198, 3198, 3217, 3217, 3256], [3257, 3257, 3276, 3276, 3494], [3495, 3495, 3514, 3514, 3776], [3777, 3777, 3796, 3796, 3934], [3935, 3935, 3954, 3954, 3983], [3984, 3984, 4003, 4003, 4076], [4077, 4077, 4096, 4096, 4227], [4228, 4228, 4247, 4247, 4312], [4313, 4313, 4332, 4332, 4441], [4442, 4442, 4461, 4461, 4620], [4622, 4634, 4653, 4653, 4878], [4880, 4880, 4899, 4899, 5162], [5163, 5163, 5182, 5182, 5483], [5484, 5484, 5503, 5503, 5781], [5782, 5782, 5801, 5801, 6027], [6028, 6028, 6047, 6047, 6251], [6252, 6252, 6271, 6271, 6706], [6707, 6707, 6726, 6726, 6884], [6885, 6885, 6904, 6904, 7061], [7062, 7062, 7081, 7081, 7340], [7341, 7341, 7360, 7360, 7556], [7557, 7557, 7576, 7576, 7713], [7714, 7714, 7733, 7733, 7982], [7983, 7983, 8002, 8002, 8201], [8202, 8202, 8221, 8221, 8288], [8289, 8289, 8308, 8308, 8537], [8538, 8538, 8557, 8557, 8742], [8743, 8743, 8762, 8762, 9046], [9047, 9047, 9066, 9066, 9340], [9341, 9341, 9360, 9360, 9496], [9497, 9497, 9516, 9516, 9691], [9692, 9692, 9711, 9711, 9784], [9785, 9785, 9804, 9804, 9935], [9936, 9936, 9955, 9955, 10036], [10037, 10037, 10056, 10056, 10241], [10242, 10242, 10261, 10261, 10434], [10436, 10446, 10466, 10466, 10670], [10671, 10671, 10691, 10691, 10964], [10965, 10965, 10985, 10985, 11159], [11160, 11160, 11180, 11180, 11370], [11371, 11371, 11391, 11391, 11743], [11744, 11744, 11764, 11764, 12059], [12060, 12060, 12080, 12080, 12201], [12202, 12202, 12222, 12222, 12384], [12385, 12385, 12405, 12405, 12686], [12687, 12687, 12707, 12707, 12785], [12787, 12797, 12818, 12818, 12869], [12870, 12870, 12892, 12892, 12963], [12964, 12964, 12987, 12987, 13067], [13068, 13068, 13093, 13093, 13321], [13322, 13322, 13344, 13344, 13485], [13486, 13486, 13509, 13509, 13551], [13552, 13552, 13575, 13575, 13653], [13654, 13654, 13679, 13679, 13819], [13820, 13820, 13843, 13843, 13940], [13941, 13941, 13962, 13962, 14095], [14096, 14096, 14117, 14117, 14175], [14176, 14176, 14197, 14197, 14348], [14349, 14349, 14370, 14370, 14425], [14426, 14426, 14445, 14445, 14535], [14536, 14536, 14555, 14555, 14592], [14593, 14593, 14614, 14614, 14793], [14794, 14794, 14814, 14814, 15207], [15208, 15208, 15227, 15227, 15297], [15298, 15298, 15318, 15318, 15376], [15377, 15377, 15399, 15399, 15562], [15563, 15563, 15586, 15586, 15626], [15627, 15627, 15649, 15649, 15897], [15898, 15898, 15921, 15921, 15961], [15963, 15963, 16001, 16001, 16037], [16039, 16039, 16091, 16091, 16128], [18394, 18442, 18473, 18473, 18560], [18562, 18562, 18580, 18580, 18765], [18767, 18767, 18817, 18817, 19035], [19037, 19037, 19063, 19063, 19142], [19144, 19144, 19176, 19176, 19403], [19406, 19406, 19463, 19463, 20128]], "test": "valid"}
{"id": "sdX3zH", "name": "Fork MANO fract NikolaErce 337", "author": "NikolaErceg", "description": "https://twitter.com/fms_eraser/status/863410581436379137", "tags": ["2d", "fractal"], "likes": 0, "viewed": 48, "published": "Public", "date": "1615489350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RECUR 8\n\n#define V vec3(2.,1.,-1.)\n#define ODST 4\n\nvec3 catColor( float phase ) {\n    return vec3(\n        sin( phase + 2.0 ),\n        sin( phase + 2.0 ),\n        sin( phase + 3.0 )\n    ) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n    \n\tvec2 v1 = vec2( 0.0, 2);\n    vec2 v2 = vec2( -ODST, -1 );\n    vec2 v3 = vec2( ODST, -1);\n    \n    float line = 3.3;\n    float phase = 1.3;\n    float outside = 0.3;\n    \n    for ( int i = 0; i < RECUR; i ++ ) {\n        float dot1 = dot( normalize( v2 - v1 ).yx * V.zy, p - v1 );\n        float dot2 = dot( normalize( v3 - v2 ).yx * V.zy, p - v2 );\n        float dot3 = dot( normalize( v1 - v3 ).yx * V.zy, p - v3 );\n        \n        float len = min( min( dot1, dot2 ), dot3 );\n        if ( len < 0.0 ) {\n            outside = 1.0;\n            break;\n        }\n        line = max( 0., 0.0 - abs( len ) *800.0 );\n        \n        vec2 c = ( v1 + v2 + v3 ) / 3.0;\n        phase += length( c - p ) * float( i );\n        \n        float comp1 = dot( ( v1 - c ).yx * V.zy, p - c );\n        float comp2 = dot( ( v2 - c ).yx * V.zy, p - c );\n        float comp3 = dot( ( v3 - c ).yx * V.zy, p - c );\n        if ( comp1 < 0.0 ) {\n            if ( comp3 < 0.0) {\n                v1 = c;\n            } else {\n                v2 = c;\n            }\n        } else if ( comp2 < 0.0 ) {\n            v3 = c;\n        } else {\n\t\t    v1 = c;\n        }\n        \n    }\n    \n    if ( outside ==1.0 ) {\n        fragColor = vec4( 1, 0.0, 0.0, 30 );\n    } else {\n\t    fragColor = vec4( catColor( phase * 3.1 - iTime + 0.9 ) - line * 1.0, 3.0 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdX3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 89, 89, 210], [212, 212, 269, 269, 1670]], "test": "valid"}
{"id": "sdXGDN", "name": "Fractal spheres", "author": "sfavaron", "description": "Fractal spheres", "tags": ["spheres", "fractals"], "likes": 1, "viewed": 79, "published": "Public", "date": "1615947195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//map function, core of all the ray marching shaders. They return a scalar value, given a 3D point.\nfloat map(vec3 p) {\n    // you transform the space so it's a repeating coordinate system\n    p = fract(p) * 2. - 1.;\n  \t\n    //sphere map function is the length of the point minus the radius\n    //it's negative on the inside of the sphere and positive on the outside and 0 on the surface.\n    float r = 0.25; //(sin(iTime*2.)+1.)/8. + 0.01;\n    return length(p) - r;\n}\n\n//we use a numerical marching algorithim called trace\n//o = origin\n//r = ray to march along\n//t = intersection along the ray\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for(int i=0; i < 32; i++) {\n        //origin + ray*t = where we are along the ray;\n        // we step along the ray in variable length segments, \n        //until we gradual converge on the intersection and evaluate the map function at that point\n        float d = map(o+r*t);\n        if(d>15.) break; // Near and far break;\n        //we add that to t\n        // the smaller the 0.5 value, the less accurate the map function is\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //transform the cordinates to -1 to 1, instead of 0 to 1\n    uv = uv * 2.0 - 1.0;\n    //correct the aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //r = ray\n    // it needs to be normalized so it doesn't poke through the geometry when it's really close to the camera\n    //the z cordinate is 1.0, that's how you project the 2D coordinate into 3D space, \n    //you just decide the z value, which determines the field of view of the camera\n    // smaller z = higher fov. 1.0 = 90 degrees\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    //rotation around the y axis\n    //you have to look up on wikipedia what this is\n    float the= iTime*0.5;\n    //r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    //r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    //r.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n    // the sphere is at (0.0,0.0,0.0)\n    vec3 o = vec3(0., 0., iTime);\n    \n    //trace from the origin along the ray to find the intersection from our map function\n    float t = trace(o, r);\n    \n    // simple fogging funcition to darken things the further away they are\n    float fog = 1.0 / (1. + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXGDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 119, 188, 468], [470, 595, 624, 624, 1118], [1120, 1120, 1177, 1227, 2498]], "test": "valid"}
{"id": "sdXGW8", "name": "Barycentric Space", "author": "oneshade", "description": "Barycentric coordinates taking strange slices of a box gradient.", "tags": ["3d", "space", "barycentric", "thoughtexperiment"], "likes": 3, "viewed": 69, "published": "Public", "date": "1615860559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 barycoords(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    return vec3(bcp, cap, abp) / abc;\n}\n\nfloat map(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    mat2 rot = mat2(c, -s, s, c);\n\n    p.xy *= rot;\n    p.xz *= rot;\n\n    //return length(vec2(length(p.xz) - 0.5, p.y)) - 0.25;\n\n    //return length(p) - 0.75;\n\n    vec3 q = abs(p) - 0.5;\n    //return max(q.x, max(q.y, q.z));\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\nvec3 grad(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    vec2 a = vec2(-0.5, -0.5);\n    vec2 b = vec2( 0.5, -0.5);\n    vec2 c = vec2( 0.0,  1.0);\n\n    vec3 uvw = barycoords(uv, a, b, c);\n    fragColor = vec4(grad(uvw), 1.0);\n    //fragColor = vec4(smoothstep(unit, 0.0, map(uvw)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdXGW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 385], [387, 387, 409, 409, 748], [750, 750, 772, 772, 989], [991, 991, 1046, 1046, 1382]], "test": "valid"}
{"id": "ss23RW", "name": "modus6 julia fractal", "author": "tholzer", "description": "small improvements to original\npress mouse button to explore julia set...", "tags": ["2d", "fractal", "juliaset", "3folded"], "likes": 2, "viewed": 38, "published": "Public", "date": "1617063426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"modus6 [cube julia set]\" by modus. https://shadertoy.com/view/sdsGDl 2021-03-29\n// Modus6JuliaFractal.glsl by THolzer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 m = 0.5*iResolution.xy; \n  vec2 z = 2.5*(fragCoord - m) / iResolution.y;\n  if (iMouse.x > 0.0) m.xy = 2.5*(iMouse.xy - m) / iResolution.y;\n  if (iMouse.z <= 0.0) m = 0.8*vec2(sin(0.1*iTime), cos(0.1*iTime));\n  vec3 col = vec3(1.0);\n  for(float i=0.; i<64.; i++)\n  {\n    z = vec2(     z.x*z.x*z.x -3.0*z.x*z.y*z.y\n            , 3.0*z.x*z.x*z.y -    z.y*z.y*z.y) + m;\n    float lz = length(z);\n    if(lz > 4.0)\n    {\n      col = vec3(-lz / i + 1.0); \n      break;\n    }\n  }\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss23RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 130, 187, 187, 697]], "test": "valid"}
{"id": "ss2GRR", "name": "p7 univers", "author": "DEMERCY", "description": "practice", "tags": ["drawline"], "likes": 1, "viewed": 45, "published": "Public", "date": "1616862846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\nfloat DistLine(vec2 p,vec2 a ,vec2 b){\n   \n   vec2 pa = p-a;\n   vec2 ba = b-a;\n   float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n   return length(pa-ba*t);\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34,833.46));\n    p += dot(p,p+43.43);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p){\n    float n = N21(p);\n    return vec2(n,N21(p+n));\n}\nvec2 GetPos(vec2 id,vec2 offs){\n    \n    vec2 n = N22(id+offs)*iTime;\n    \n    return offs+sin(n)*.4;\n    \n}\nfloat Line(vec2 p,vec2 a,vec2 b){\n    float d = DistLine(p,a,b);\n    float m = S(.03,.01,d);\n    m*= S(1.2,.8,length(a-b));\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 5.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    float m = 0.;\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.;y<=1.;y++){\n        for(float x = -1.;x<=1.;x++){\n            p[i++] = GetPos(id,vec2(x,y));\n            \n        }\n    }\n    float t = iTime*10.;\n    for(int i = 0; i<9;i++){\n        Line(gv,p[4],p[i]);\n        m += Line(gv,p[4],p[i]);\n        \n        vec2 j = (p[i]-gv)*20.;\n        float sparkle = 1./dot(j,j);\n        m+= sparkle*(sin(t+p[i].x*10.)*.5+.5);\n    }\n    m += Line(gv,p[1],p[3]);\n    m += Line(gv,p[1],p[5]);\n    m += Line(gv,p[7],p[3]);\n    m += Line(gv,p[7],p[5]);\n    vec3 col = vec3(m);\n    \n    \n    \n    //if (gv.x >.48||gv.y > .48)col += vec3(1,0,0);\n    fragColor = vec4(col,1.);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 191], [193, 193, 211, 211, 303], [305, 305, 322, 322, 375], [376, 376, 407, 407, 484], [485, 485, 518, 518, 624], [626, 626, 683, 683, 1508]], "test": "valid"}
{"id": "ss2GzW", "name": "Seafloor fractal", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "feather", "coral"], "likes": 2, "viewed": 164, "published": "Public API", "date": "1617069063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -1.0;\n        }\n     col[c] = fract((uv.y)+(uv.x));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 698]], "test": "valid"}
{"id": "ssf3D8", "name": "Mandelbar Julia Set Zoom", "author": "enslow", "description": "another fractal ¯\\_(ツ)_/¯", "tags": ["fractal"], "likes": 7, "viewed": 60, "published": "Public", "date": "1615854097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Ryan Enslow March 1, 2021.\n//Mandelbar Fractal (julia set)\n//https://twitter.com/ComplexFractal\n\n#define PI 3.14159\n#define AA 2.\n\n#define CONSTANT vec2(-0.510, -0.412)\n#define CENTER 2.*vec2(-0.048, 0.1765)\n\n#define RE 2.*z.x*z.y+CONSTANT.x\n#define IM z.x*z.x-z.y*z.y+CONSTANT.y\n\n//This technique is outlined in this article by Inigo Quilez. I would highly suggest reading it; it's an amazing technique. https://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n#define SMOOTH float(i)-log2(log2(length(z))) + 4.0\n#define COLORFUN 0.5 + 0.5*cos(3.0 + mix(float(i),SMOOTH,1.0)*0.10+vec3(0.059, 0.455, 0.340));\n\n//I've pasted this from Smoothstep so I've just decided to define these here with trig functions.\n#define IFLOAT0 4.*(-cos(iTime/(2.*PI))+2.)\n#define IFLOAT1 5.*(-cos(iTime/(2.*PI))+1.2)\n#define IFLOAT2 10.*smoothstep(0.,38.,mod(iTime,38.))\n\n#define ITERATION 80.\n#define ESCAPE 4.\n\nmat2 rotate(float theta){\n  return mat2(cos(theta),-sin(theta)\n             ,sin(theta), cos(theta));\n}\n\n//Determine the color of a given point after its iterative transformation\n//  z: point in complex plane\n//  i: current iteration\n//  col: output color\nvoid colord (in vec2 z, in float i, out vec3 col, inout bool br){\n  col = vec3(1.0);\n  if (length(z)>ESCAPE){\n    br = true;\n    col = COLORFUN;\n  }\n  else{\n    col = vec3(0.0);\n  }\n}\n\n\n//The complex function to transform a point\nvoid anon (in vec2 z, inout vec3 s, in float t){\n  vec2 c = z; //Original point\n  vec2 temp;\n  bool br;\n  for (float i=0.0; i<ITERATION+exp(IFLOAT0)/IFLOAT0;i += 1.0){\n    colord(z,i,s,br);\n    if (br) break;\n    \n      temp.x = RE;\n      temp.y = IM;\n    z = temp;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 a = iResolution.xy;\n  vec3 s = vec3(1.0);\n  vec3 col = vec3(0.0);\n  \n  float t = exp(IFLOAT1)+1.0;\n  for (float j = 0.; j < AA; j += 1.0){\n    for (float k = 0.; k < AA; k += 1.0){\n      vec2 uv;\n      uv = 10.*rotate(IFLOAT2)*(fragCoord + vec2(j,k)/AA - .5*a.xy)/a.y / t+CENTER;\n      anon(uv,s,t);\n      col += s;\n    }\n  }\n  col /= AA*AA;\n  \n  //fragColor = vec4(mix(col,second,0.2),1.0);\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssf3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 906, 931, 931, 1009], [1011, 1162, 1227, 1227, 1345], [1348, 1392, 1440, 1440, 1663], [1665, 1665, 1720, 1720, 2150]], "test": "valid"}
{"id": "ssf3RB", "name": "demoballs", "author": "mcheshkov", "description": "metaballs for demo 2020.03.19", "tags": ["metaballs"], "likes": 5, "viewed": 78, "published": "Public", "date": "1616155608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opSmoothUnion(float d1, float d2, float k){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nfloat scene(vec3 p) {\n    float d = 100500.;\n    for (int i=0;i<16;i+=1) {\n        float fi = float(i);\n        vec3 dir = sin(1.2*(sin(fi)+1.)*iTime + fi * vec3(1.5,0.5,3.0));\n        d = opSmoothUnion(\n            sdSphere(p - vec3(0.,1.,3.) + 2.*dir, 0.5 + 0.2*sin(iTime)),\n            d,\n            1.3\n        );    \n    }\n    return d;\n}\n\nvec3 marchScene(vec3 ro, vec3 rd) {\n    for(float t = 0.0; t < 10.0;) {\n        float h = scene(ro + rd*t);\n        if( h<0.001 )\n            return vec3(t, 0., 0.);\n        t += h;\n    }\n    return vec3(-1.0);\n}\n\nvec3 calcNormal(vec3 p) {\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float backFreq = 4.;\n    // Time varying pixel color\n    float backCol = 0.5 + 0.2*pow((sin(backFreq * iTime) + 1.) / 2., 8.);\n\n    // Output to screen\n    fragColor = vec4(vec3(backCol),1.0);\n    \n    vec3 ro = vec3(0.,0.,-1.);\n\tvec3 rd = vec3(uv, 0.) - ro;\n    \n    vec3 d = marchScene(ro, rd);\n    if (d.x > -1.) {\n        float colorP = pow(1.-d.x/4., 1./2.);\n        fragColor = vec4(0.9*colorP, 0.8*colorP, 0., 0.);\n        \n        vec3 p = ro + d.x * rd;\n        vec3 n = calcNormal(p);\n        float b = max(0.0, dot(n, vec3(0.577)));\n        vec3 col = (0.6 + 1.3 * cos((b + iTime * 3.0) + vec3(0,2,4)) * vec3(0.7, 0., 0.)) * (1.3*backCol + b * 0.35);\n        col *= exp( -d.x * 0.15 );\n        fragColor = vec4(col, 1.);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssf3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 148], [150, 150, 183, 183, 209], [211, 211, 232, 232, 555], [557, 557, 592, 592, 769], [771, 771, 796, 796, 1086], [1088, 1088, 1145, 1196, 2002]], "test": "valid"}
{"id": "ssfGDB", "name": "_mandala_", "author": "DannnYXZ", "description": "Simple geometry mandala.", "tags": ["geometry", "mandala"], "likes": 2, "viewed": 74, "published": "Public", "date": "1616808050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926553589793238\n// t : (start, end, inv)\nvec2 ring(vec2 uv, vec3 t) {\n    float id = floor(length(uv)), f = (id-t.x)/(t.y-t.x);\n    return vec2((t.z == .0 ? f : 1.-f)*step(t.x, id)*(1.-step(t.y+1., id)), t.x <= id && id <= t.y);\n}\nvec2 mirror(vec2 uv, vec2 n) {\n    return uv - n*min(2.*dot(uv, n), 0.);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d + iTime*.05) );\n}\nvec3 rnb(float t){\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float fd = 1.0+.05*sin(iTime), fdd = 1.0+.005*sin(iTime);\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.x*58.;\n    vec3 col = rnb(.3);\n    vec3 r1 = vec3(0., 5., 0.), r2 = vec3(r1.y, r1.y + 10., 0.);\n    vec3 r3 = vec3(5., r2.y-2., 0.), r4 = vec3(r3.y+.1, r3.y+1., 0.);\n    vec2 r1id = ring(uv/fd, r1), r2id = ring(uv/fd, r2), r3id = ring(uv, r3), r4id = ring(uv, r4);\n    vec2 p = vec2(atan(uv.y, uv.x), length(uv/fd))*vec2(1./(2.*PI), 1.);\n    float leafs = 8., flr = 18.;\n    float flower = flr*abs(fract(leafs*p.x-1./2.)-.5);\n    float fm = smoothstep(.0, .01, flower-p.y+r2.x+1.);\n    \n    vec2 uv4 = mirror(abs(uv), normalize(vec2(1., -1.)));\n    \n    vec2 r5 = ring(uv4-vec2(16., 2.)/fd, vec3(3., 7., 0));\n    vec2 r8 = ring(uv4-vec2(16., 2.)/fd, vec3(7., 8., 0));\n    vec2 r6 = ring(uv4*fd, vec3(15., 21., 0));\n    vec2 r7 = ring(uv4-vec2(31., 31.)*fdd, vec3(17., 23., 0));\n    vec2 r9 = ring(uv4-vec2(3., 30.), vec3(31., 34., 0));\n    vec2 r12 = ring(uv4-vec2(3., 30.), vec3(34., 36., 1.));\n    vec2 r10 = ring(uv4-vec2(3., 30.), vec3(29., 30., 1.));\n    vec2 r11 = ring(uv4-vec2(11.7, 10.)/fd, vec3(4., 8., 0.));\n    vec2 r13 = ring(uv4, vec3(27., 27.1, 1.));\n    vec2 r14 = ring(uv4, vec3(28., 31., 0.));\n    vec2 r15 = ring(uv4, vec3(5., r2.y-1., 0.));\n    \n    float R = 31., Rm = smoothstep(0., 0.1, R-length(uv4));\n    float m2 = step(0., dot(vec2(-sin(PI/8.), cos(PI/8.)), uv4))*Rm;\n    float nm2 = step(0., dot(vec2(sin(PI/8.), -cos(PI/8.)), uv4))*Rm;\n    \n    col = mix(col, mix(rnb(.3)*.1, rnb(.3)+.3, r11.x), r11.y*nm2);\n    col = mix(col, mix(rnb(.3)*.8, rnb(.3)*.5, r10.x), r10.y*nm2);\n    col = mix(col, mix(vec3(1.), rnb(.5), r3id.x), r3id.y*nm2);\n    col = mix(col, mix(vec3(1.), rnb(.3), r15.x),r15.y*m2);\n    col = mix(col, rnb(.8), r4id.y*nm2);\n    col = mix(col, mix(vec3(0), rnb(.5), r7.x), r7.y*m2);\n    col = mix(col, rnb(.85)*r8.x, r8.y*m2);\n    col = mix(col, mix(rnb(.2)*.9, rnb(.95), r6.x), r6.y*m2);\n    col = mix(col, mix(vec3(0.), rnb(.86), r5.x), r5.y*m2);\n    col = mix(col, mix(rnb(.3), rnb(.3)*2.1, r9.x), r9.y*nm2);\n    col = mix(col, mix(rnb(.8)*.3, rnb(.8), r12.x), r12.y*nm2);\n    col = mix(col, mix(rnb(.3), rnb(.5)*1.1, r14.x), r14.y);\n    col = mix(col, vec3(r13.x)*rnb(.8), r13.y);\n    col = mix(col, mix(rnb(.95), vec3(1.), r2id.x), fm);\n    col = mix(col, mix(vec3(1.), rnb(.3), r1id.x), r1id.y);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 58, 86, 86, 247], [248, 248, 278, 278, 322], [323, 323, 391, 391, 446], [447, 447, 465, 465, 561], [562, 562, 619, 619, 3018]], "test": "valid"}
{"id": "ssfGW7", "name": "Dipole Diffusion", "author": "tovacinni", "description": "Diffusion through scattering medium", "tags": ["diffusion"], "likes": 0, "viewed": 56, "published": "Public", "date": "1616041723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Towaki Takikawa @yongyuanxi, CC 3.0\n\n// Instructions:\n//   Click anywhere on the image on the left to change the position of the laser\n//   Set ISOWAVE to 1 to turn on isocurves of the waves being propagated\n\n// Coefficients modeling: \n// Three-Dimensional Imaging Through Scattering Media based on Confocal Diffuse Tomography\n// Lindell et. al, https://davidlindell.com/publications/cdt\n\n#define ISOWAVE 0\n\nfloat PI = 3.14159;\n\n// scattering coefficient (1/scattering radius)\n#define sr 0.382\n#define mus (1.0 / sr) \n// absorption coefficient (1/absorption radius)\n#define ar 190.114\n#define mua (1.0 / ar)\n\n// reflection coefficient (integrated from Fresnel reflection coefficients, not shown)\n#define R 0.018\n\n// transport mean free path\n#define lstar (1.0/(mua*mus))\n\n// extrapolation distance\nfloat ze = ((2.0*lstar)/3.0) * (1.+R)/(1.-R);\n\n// slab thickness\nfloat zd = 2.54;\n \n// diffusion coefficient \nfloat D = 1.0 / (3.0 * (mus + mua));\n\n// speed of light (scaled down for human scale ;)\nfloat c = 5.0;\n\n// isotropic scattering distance\nfloat z0 = 1.0 / mus; \n\nfloat pos_dipole(int i) {\n    return 2.0 * float(i) * (zd + 2.0 * ze) + z0;\n}\n\nfloat neg_dipole(int i) {\n    return 2.0 * float(i) * (zd + 2.0 * ze) - (2.0 * ze) - z0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 5.0);\n    vec2 uv = fragCoord/iResolution.x;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 laser = iMouse.xy / iResolution.x;\n    \n    float norm_factor = 1.0 / (2.0 * pow(4.0*PI*D*c, 1.5) * pow(time, 2.5));\n    float trans = exp(-mua * c * time - (distance(laser, uv)/(4.0*D*c*time)));\n    float dipole = 0.0;\n    for (int i=0; i<3; ++i) {\n        float zpos = zd - pos_dipole(i);\n        float zneg = zd - neg_dipole(i);\n        float norm = 4.0 * D * c * time;\n        dipole += zpos * exp(-pow(zpos, 2.0)/norm) - zneg * exp(-pow(zneg, 2.0)/norm);\n    }\n    vec3 col = vec3(norm_factor * trans * dipole) * 100.0;\n    \n#   if ISOWAVE\n        for (int i=0; i<50; ++i) {\n            if (abs(col.x - (float(i)*0.1)) < 0.00005) {\n                col.x = 1.0;\n            } \n        }\n#   endif\n     \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssfGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1015, 1072, 1097, 1097, 1149], [1151, 1151, 1176, 1176, 1241], [1243, 1243, 1300, 1300, 2171]], "test": "valid"}
{"id": "ssj3zD", "name": "Transparency Thing", "author": "Tater", "description": "just for fun.", "tags": ["2d", "random", "abstract"], "likes": 2, "viewed": 157, "published": "Public API", "date": "1617087362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat circle(vec2 uv, float r){\nreturn smoothstep(r,r-0.04*hash21(r).x,length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime+10.0;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    vec3 col = vec3(0.0);\n    \n    for(float i = 0.0; i<150.0; i++){\n    \n        vec3 c = vec3(hash21(i*0.3123+floor(t)),hash21(i*0.3344+floor(t)).x); //Color\n        \n        vec2 pos = + vec2(sin(hash21(i).x*t),cos(hash21(i).y*t)); //Position\n        \n        c*=vec3(circle(uv+pos,0.1+0.0002*i+0.1*hash21(i).x))*(hash21(i).x*0.7); \n        \n        col.rgb+=c;\n    }\n    col+=0.25*(1.0-smoothstep(0.1,0.102,-(abs(uv.y)-0.3-0.2*sin(t)*sin(t))+0.02*sin(uv.x*20.0+t*10.0)));\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 61, 61, 189], [190, 190, 221, 221, 275], [277, 277, 334, 334, 937]], "test": "valid"}
{"id": "ssj3zW", "name": "Lights - CGT 215", "author": "spwalters10", "description": "Changing lights", "tags": ["lights"], "likes": 5, "viewed": 93, "published": "Public", "date": "1617070583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credits: Dave_Hoskins Hash functions: https://www.shadertoy.com/view/4djSRW\n\nconst float PI = 3.141592654;\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n// returns { RGB, dist to edge (0 = edge, 1 = center) }\nvec4 disco(vec2 uv) {\n    float v = abs(cos(uv.x * PI * 2.) + cos(uv.y *PI * 2.)) * .5;\n    uv.x -= .5;\n    vec3 cid2 = hash32(vec2(floor(uv.x - uv.y), floor(uv.x + uv.y))); // generate a color\n    return vec4(cid2, v);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord / R;\n    uv.x *= R.x / R.y; // aspect correct\n\n    float t = iTime * .6; //t = 0.;\n    uv *= 8.;\n    uv -= vec2(t*.5, -t*.3);\n    \n    o = vec4(1);\n    for(float i = 1.; i <= 4.; ++i) {\n        uv /= i*.9;\n        vec4 d = disco(uv);\n        float curv = pow(d.a, .44-((1./i)*.3));\n        curv = pow(curv, .8+(d.b * 2.));\n        o *= clamp(d * curv,.35, 1.);\n        uv += t*(i+.3);\n    }\n    \n    // post\n    o = clamp(o,.0,1.);\n    vec2 N = (fragCoord / R )- .5;\n    o = 1.-pow(1.-o, vec4(30.));// curve\n    o.rgb += hash32(fragCoord + iTime).r*.07;//noise\n    o *= 1.1-smoothstep(.4,.405,abs(N.y));\n    o *= 1.0-dot(N,N*1.7);// vingette\n    o.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 111, 132, 132, 268], [269, 325, 346, 346, 546], [548, 548, 596, 596, 1307]], "test": "valid"}
{"id": "ssj3zz", "name": "Fractal impressionism", "author": "jarble", "description": "These fractal patterns reminds me of impressionist landscape paintings.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 172, "published": "Public API", "date": "1616880800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07); //looks like a carpet\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .17;\n    float scale2 = offset;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    for(int c=0;c<6;c++){\n        float scale = c1.z;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        for(int i=0;i<3;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            //scale /= scale2+col.x;\n            offset /= scale2;\n            \n            \n            \n            uv.y /= -1.0;\n            uv = uv.yx;\n            //uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [516, 747, 794, 794, 850], [852, 852, 909, 909, 1710]], "test": "valid"}
{"id": "ssjGRw", "name": "concentric wobbling circles", "author": "grevel", "description": "click to change blob's position", "tags": ["circles", "interactive", "sin", "circle", "animated", "wobbling"], "likes": 1, "viewed": 143, "published": "Public API", "date": "1617186060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159265359;\n\n    float aspR = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y /= aspR;\n    \n\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    mouseUV.y /= aspR;\n    \n    float fStar = sin(iTime*5.)*sin(2.*round(9.*(sin(iTime/5.)+1.)/2.+1.)*atan((uv.y-mouseUV.y)/(uv.x-mouseUV.x)));\n\n    float distR = 0.5 + 0.5*sin(1. -iTime*3.0 + fStar+length(uv - mouseUV)*(51.0 + 10.1*sin(iTime*5.0)));\n    float distG = 0.5 + 0.5*sin(2. -iTime*3.0 + fStar+length(uv - mouseUV)*(50.0 + 10.5*sin(iTime*5.0)));\n    float distB = 0.5 + 0.5*sin(1.5 -iTime*3.0 + fStar+length(uv - mouseUV)*(52.0 + 10.9*sin(iTime*5.0)));\n    \n    vec3 c = vec3(smoothstep(0.2, 0.8, distR), smoothstep(0.3, 0.7, distG), smoothstep(0.1, 0.9, distB));\n    \n    \n    \n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 870]], "test": "valid"}
{"id": "ssl3R8", "name": "kifs2d _6L", "author": "sus1357", "description": "colors in the current version are a bit too bright in the middle to appreciale all the beautiful inner shapes, I still have to learn a bit more about color mixing xD", "tags": ["fractal", "ifs"], "likes": 4, "viewed": 64, "published": "Public", "date": "1615849974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//here between time = 210 and 230 some organic-looking beauty\n\nvec2 DOMAIN_XY = vec2(16., 9.);   // RAZMER OBLASTI\nfloat speed = 25.;                // skorost' metamorfoz (???)\nbool strobo_on = false; //ORIG was true, and fancy was false\nbool fancy_colors_on = true; \n                                // KIFS-konstanti\nconst int N = 3;               // N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 3;    // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 8;       // WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n                         //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n                     //      funksii      kogda tut dve leviye (lol) kosiye cherti, ploho))\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n        //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n   //1d gauss, ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n  //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n\n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n// -------- initialization ----------\n    float scale = 2.;\n    \n        vec2 symm[N];                                //symm[0] = a2v(60.); symm[1] = a2v(-60.);\n    \n    symm[0] = a2v(0.);           //a2v(60. + iTime*speed); //symm[0] = a2v(-60. + iMouse.x); symm[1] = a2v(60. + iMouse.y);\n    symm[1] = a2v(45. + (5./360.)*iTime*speed); //a2v(-60.);\n    symm[2] = a2v(135.);\n    \n        float rot[N];\n    \n    rot[0] = 0.;\n    rot[1] = 90.+iTime*speed; // in mandelbulber alpha (Rotate_Z) = 90.\n    rot[2] = 0.; // 0 or 90 ???\n    \n        mat2 rot_matr[N];\n    \n    rot_matr[1][0][0] = cos(radians(rot[1])); rot_matr[1][0][1] = -sin(radians(rot[1]));\n    rot_matr[1][1][0] = sin(radians(rot[1])); rot_matr[1][1][1] = cos(radians(rot[1]));\n    \n        bool mirror[N];\n        \n    mirror[0] =\n    mirror[1] = \n    mirror[2] = false; // in mandelbulber gamma (Rotate_(X or Y)) = 180.\n    \n    \n    vec2 offset = vec2(.0,.0);                //vec2 offset = vec2(-1.+2.*iMouse.x/iResolution.x, -1.+2.*iMouse.y/iResolution.y);\n        \n        float dist[N];\n    \n    dist[0] = -1.;\n    dist[1] = -1.;\n    dist[2] = -1.;\n    \n\n\nfloat color_over_iterations = 0.;\nfloat coi_const = 1.;\n\nfloat mod_const = pow(scale, float(ITER)); // eta konstanta delaet tolschinu\n                                                  // polos, kotoraya ZAVISIT ot ITER, POSTOYANNOY\nfloat w = 0.05 * mod_const; // tolschina polosok napravlennikh vdol' osey\n\n\n// --------  algorithm  ------------- \n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            // rotate and mirror-rotate\n            if ( rot[n] != 0.0 ) {\n                uv = rot_matr[n] * uv;\n            }\n        \n          // symm vecs \n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n]; //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n        }\n        \n        // scaling\n        uv*=scale;\n        uv -= (scale - 1.) * offset;\n        \n        if(strobo_on) { // stroboscope\n            if(float(i) > mod(30.*iTime, float(ITER))) break; \n        }\n        \n        \n        float x_ = float(int( (uv.y<w)&&(uv.y>-w) ));\n        float y_ = float(int( (uv.x<w)&&(uv.x>-w) ));\n        color_over_iterations += coi_const*(x_+y_);\n        \n    }\n  // --------------------------------\n // Output to screen\n \n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue);\n    vec3 col_g = gauss(uv, .1)*white;\n   \n\n\n    //vec2 norm = fragCoord/iResolution.xy;\n    //vec3 col_ex = 0.5 + 0.5*cos(2.35+norm.xyx+vec3(0,2,4));\n    //col_ex *= step( max( mod(uv.x, mod_const), mod(uv.y, mod_const) ), 0.9*mod_const );\n    \n    \n    \n    \n\n    \n     // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n   \n    vec3 result = col_g + // mertsaniye\n                  + koltso + \n                  + koltso2\n                  ;\n    if(fancy_colors_on) {\n        //float mod_const = pow(scale, float(ITER)); // eta konstanta delaet tolschinu\n                                                  // polos, kotoraya ZAVISIT ot ITER, POSTOYANNOY\n        //float w = 0.05 * mod_const; // tolschina polosok napravlennikh vdol' osey\n    \n        vec3 x_positive = float(int((uv.x>0.0)&&(uv.y<w)&&(uv.y>-w)))*red; // osi\n        vec3 x_negative = float(int((uv.x<0.0)&&(uv.y<w)&&(uv.y>-w)))*0.2*red; \n        vec3 y_positive = float(int((uv.y>0.0)&&(uv.x<w)&&(uv.x>-w)))*(red+green);\n        vec3 y_negative = float(int((uv.y<0.0)&&(uv.x<w)&&(uv.x>-w)))*0.2*(red+green);\n        vec3 osi = x_positive + x_negative + y_positive + y_negative;\n\n        vec2 xy_examp = fragCoord/iResolution.xy;\n        vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n        \n        result += .5*(-osi*col_examp + osi + col_examp); //poloski + tsvetovoye resheniye\n    }\n    \n    vec2 xy_examp = fragCoord/iResolution.xy;\n        vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n        \n    //result = smoothstep(result, col_examp, white);\n    \n    result += (\n    1.-mod(color_over_iterations, 2.))*col_examp;\n    \n    fragColor = vec4(result ,1.0);                             \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssl3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 812, 848, 848, 891], [900, 935, 978, 978, 1017], [1021, 1092, 1113, 1113, 1160], [1163, 1196, 1253, 1322, 5829]], "test": "valid"}
{"id": "ssl3RS", "name": "IntersectionDemonstration", "author": "AmanSachan", "description": "IntersectionDemonstration", "tags": ["intersectiondemonstration"], "likes": 0, "viewed": 35, "published": "Public", "date": "1616174666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    float an = sin(iTime);\n    \n    // opSubtraction\n    {\n        vec3 q = pos;\n        float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );\n        float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); \n        float dt = opSubtraction(d1,d2);\n        d = min( d, dt );\n    }\n\n    return d;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \n        vec3 ro = vec3(0.0,4.0,8.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.8),-3.5));\n\n        float t = 7.0;\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t*rd;\n            float h = map(p);\n            if( abs(h)<0.001 || t>11.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n\n        if( t<11.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + \n                  vec3(1.00,0.9,0.80)*dif*sha;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssl3RS.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1078, 1121, 1121, 1147], [1149, 1202, 1243, 1243, 1269], [1272, 1272, 1317, 1317, 1408], [1410, 1447, 1471, 1471, 1787], [1789, 1853, 1885, 1885, 2119], [2121, 2183, 2270, 2270, 2528], [2544, 2544, 2601, 2601, 3864]], "test": "valid"}
{"id": "ssl3zH", "name": "Plotting Circles", "author": "mla", "description": "Something simple today: plotting circles and finding intersections in a way that works nicely for lines as a special case.\n\nThe mouse moves the yellow line.", "tags": ["circles", "intersection", "plotting"], "likes": 3, "viewed": 184, "published": "Public API", "date": "1615626764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Plotting circles, mla, 2021\n//\n// For given float k and unit vector r, if kp.p = p.r the locus of p is a\n// circle passing through the origin, diameter 1/k with centre at r/2k.\n//\n// This is nice as the case k=0 gives a line (with normal r) without any\n// special treatment. Also, while kp.p-p.r isn't an exact distance function\n// everywhere its gradient on the circle has magnitude 1 (its a nice \n// exercise to see why this is) so it does work as a distance function locally\n// eg. for plotting the circle as a line (and the calculation of the\n// distance function involves just one dot product).\n//\n// This should work in any number of dimensions, so sphere intersections can \n// be calculated in the same way (with a nice degeneration to the plane case).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float scale = 10.0;\n  vec2 mouse = vec2(-2,1);\n  vec2 p = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) mouse = scale*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  vec3 color = vec3(0.5,1,0.75); //vec3(smoothstep(0.0,0.01,abs(dist/ddist)));\n  vec2 r = normalize(vec2(1,1)); // Centre direction\n  float k = 0.5*tan(iTime);          // Inverse diameter\n  // kp.p-p.r == 0\n  float dist = abs(dot(p,k*p-r));\n  color = mix(vec3(0),color,smoothstep(0.1,0.15,dist)); \n\n  vec2 q = vec2(-2,-2);       // Line origin\n  vec2 t = normalize(mouse-q); // Line direction\n  q += -dot(q,t)*t; // Move q along line so q.t = 0 (helps with stability)\n  float ldist = abs(dot(p-q,vec2(t.y,-t.x)));\n  color = mix(vec3(1,1,0),color,smoothstep(0.1,0.15,ldist));\n  // Intersect q+xt with kp.p-p.r = 0\n  // k(q+xt).(q+xt) - (q+xt).r = 0\n  // k(q.q+2xq.t+x²) - q.r - xt.r = 0 (and q.t = 0)\n  // Solving Ax² - 2Bx + C = 0\n  float A = k;\n  float B = 0.5*dot(t,r);\n  float C = dot(q,k*q-r);\n  float D = B*B-A*C;\n  if (D >= 0.0) {\n    float tmp = B < 0.0 ? B-sqrt(D) : B+sqrt(D);\n    float x0 = tmp/A;\n    float x1 = C/tmp;\n    float pdist = min(distance(p,q+t*x0),distance(p,q+t*x1));\n    color = mix(vec3(1,0,0),color,smoothstep(0.3,0.35,pdist));\n  }\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssl3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 932, 988, 988, 2317]], "test": "valid"}
{"id": "sslGWS", "name": "wave practice 01", "author": "cghow", "description": "wave practice 01", "tags": ["wavepractice"], "likes": 0, "viewed": 30, "published": "Public", "date": "1616490174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec2 uv1 = abs(uv-.5);\n         uv1.y = pow(uv1.y,1.9);\n         uv1.y +=iTime*.5;\n         uv1.y = sin(uv1.y*10.)*.1;\n          \n    vec3 col = vec3(step(abs((uv+uv1.y)-.5).x,.002));\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 335]], "test": "valid"}
{"id": "sslGWX", "name": "2D Transform: check borders", "author": "csaez", "description": "Proof of concept", "tags": ["transform"], "likes": 0, "viewed": 37, "published": "Public", "date": "1616673026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float angle)\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(c, -s, s, c);\n}\n\nvec4 grid(vec2 uv, vec2 size)\n{\n    float d = floor(.05f * uv.x * size.x) + floor(.05f * uv.y * size.y);\n    vec3 c = (mod(d, 2.f) == 0.f) ? vec3(.1f) : vec3(.9f);\n    return vec4(c, 1.f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 scale = vec2(.6f + (.4f * sin(2.f * iTime)));\n    vec2 translation = vec2(cos(iTime), 0.f);\n    vec2 pivot = vec2(.9f, .5f);\n    \n    vec2 uv = fragCoord / iResolution.y;\n    vec2 p = uv - pivot;\n    p += translation;\n    p *= rotate(iTime);\n    p /= scale;\n    p += vec2(.5f, .5f);\n\n    float t = p.x < 0.f || p.x > 1.f || p.y < 0.f || p.y > 1.f ? 1.f : 0.f;\n    fragColor = mix(texture(iChannel0, p), grid(uv, iResolution.yy), t);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 101], [103, 103, 134, 134, 293], [295, 295, 350, 350, 794]], "test": "error"}
{"id": "sslGzN", "name": "test audio fft", "author": "guil", "description": "Fork from https://www.shadertoy.com/view/4lGSzy", "tags": ["fft"], "likes": 5, "viewed": 128, "published": "Public", "date": "1615742731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Fork from https://www.shadertoy.com/view/4lGSzy\n\n//https://soundcloud.com/neilbalfour/prelude-no-1-in-c-major-j-s\n//https://soundcloud.com/glennmorrison/beethoven-moonlight-sonata\n//https://soundcloud.com/awfulpianosound/yiruma-river-flows-in-you\n//https://soundcloud.com/nermeen-meawad/moonlight-sonata-beethoven\n//https://soundcloud.com/veillex01/vivaldi-four-seasons\n//https://soundcloud.com/thebestofbach/johann-sebastian-bach-chaconne\n//https://soundcloud.com/claudiocruz/max-bruch-violin-concerto-in-g\n//https://soundcloud.com/guitaristique-fr/diapason\n\n#define time iTime\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nconst float Semitone  = 1.05946309436; //12 notes between an octave, octave is 2, so a semitone is 2^(1/12)\n\nfloat KeyToFrequency(float n){\n    return pow(Semitone,(n-8.))*440./48000.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv*2.0-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    p.y+=0.5;\n    \n    vec3 col = vec3(0.0);\n    vec3 ref = vec3(0.0);\n   \n    float nBands = 64.0;\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = KeyToFrequency(i);\n    float s = texture( iChannel0, vec2(band,0.25) ).x;\n    s *= s;\n    \n    /* Gradient colors and amount here */\n    const int nColors = 4;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.0,0.0,1.0);\n    colors[1] = vec3(0.0,1.0,1.0);\n    colors[2] = vec3(1.0,1.0,0.0);\n    colors[3] = vec3(1.0,0.0,0.0);\n    \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    \n    col += vec3(1.0-smoothstep(0.0,0.01,p.y-s*1.5));\n    col *= gradCol;\n    if (p.y>1.25){\n      vec3 col1 = vec3(0.0);\n      col1 += .5*smoothstep(0.00,0.125,f);\n      if (mod(i,12.)==2.){col1 = vec3(.1);}\n      if (mod(i,12.)==4.){col1 = vec3(.1);}\n      if (mod(i,12.)==7.){col1 = vec3(.1);}\n      if (mod(i,12.)==9.){col1 = vec3(.1);}\n      if (mod(i,12.)==11.){col1 = vec3(.1);}\n      col += col1;}\n    \n    ref += vec3(1.0-smoothstep(0.0,-0.01,p.y+s*1.5));\n    ref*= gradCol*smoothstep(-0.5,0.5,p.y);\n    \n    col = mix(ref,col,smoothstep(-0.01,0.01,p.y));\n    \n    \n\n\n    col *= smoothstep(0.125,0.375,f);\n    //col *= smoothstep(0.875,0.625,f);\n    \n    float wave = texture(iChannel0, vec2(uv.x,0.75)).x;\n    \n    col += 1.0 - smoothstep(0.0, 0.01, abs(0.8*wave - uv.y - 0.3));\n\n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(p,time))*2.0/256.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 582, 605, 605, 686], [688, 688, 730, 730, 789], [830, 900, 930, 930, 977], [979, 979, 1036, 1036, 2766]], "test": "error"}
{"id": "sss3DX", "name": "Neon circuits", "author": "jarble", "description": "This fractal pattern has many overlapping and blended colors.\nFull-screen mode recommended.", "tags": ["fractal", "carpet", "rug"], "likes": 10, "viewed": 207, "published": "Public API", "date": "1616685281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 c1 = vec3(6.2,6.4,1.1); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.2,7.4,1.1);\n//vec3 c1 = vec3(8.0,8.2,1.1);\n//vec3 c1 = vec3(8.0,9.0,1.1);\n//vec3 c1 = vec3(2.0,2.7,1.07); //looks like a carpet\n//vec3 c1 = vec3(9.8,10.0,1.1);\n\n\nvec2 triangle_wave(vec2 a,float scale,vec3 h1){\n    \n    return abs(fract((a+c1.xy+h1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 1.0;\n    float offset = .16;\n    float scale2 = 1.01;\n    vec3 h1 = hash31(floor(iTime/5.0))*5.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        for(int i=0;i<6;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale,h1)+triangle_wave(uv.yx,scale,h1);\n            uv = triangle_wave(uv+col.xy,scale,h1);\n            scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            uv *= scale+offset;\n            \n        }\n     col[c] = fract((uv.x)-(uv.y));\n     col = col.yzx;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 133, 133, 218], [220, 330, 352, 352, 485], [516, 747, 794, 794, 850], [852, 852, 909, 909, 1671]], "test": "valid"}
{"id": "sss3R8", "name": "Fractal 39_gaz", "author": "gaz", "description": "i", "tags": ["fractal"], "likes": 12, "viewed": 295, "published": "Public API", "date": "1615514729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 q=vec3(2.6,2.8,2.1)+\n           vec3(cos(iTime*.6+.5*cos(iTime*.3))*.3,sin(iTime*.5)*.1,sin(iTime*1.2)*.2),\n    p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=1.,s,e,g=0.;\n        ++i<80.;\n        O.xyz+=cos(vec3(9,3,4)+log(s))*5./dot(p,p)/i\n    )\n    {\n        p=g*d-vec3(0,-.6,2.2);\n        p=R(p,normalize(vec3(1,8,0)),-iTime*.15);\n        s=2.;\n        s*=e=6./dot(p,p);\n        p*=e;\n        for(int i=0;i++<2;)\n        {\n            p=q-abs(p-q);\n            s*=e=9./min(dot(p,p),6.);\n            p=abs(p)*e;\n        }\n        g+=e=min(length(p.xz)-.2,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 723]], "test": "valid"}
{"id": "sss3RH", "name": "fractal_core_ifs", "author": "kinakomoti", "description": "I made this as an exercise for a fractal geometry by IFS. I refered to several document.", "tags": ["fractal"], "likes": 2, "viewed": 62, "published": "Public", "date": "1615533299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//refered  https://qiita.com/kaneta1992/items/21149c78159bd27e0860 by @kaneta1992\n//inspared  https://www.shadertoy.com/view/4ddfDr by Isdlive\n//refered https://neort.io/product/bvcrf5s3p9f7gigeevf0 by gaz\n\n#define repeat(p,span) mod(p,span) - 0.5 * span)\n\nconst float pi = 3.141592;\nconst float pi2 = pi * 2.;\n\nmat2 rot(float a){\n    float s = sin(a),c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p,float r){\n    float a = atan(p.x,p.y) + pi/r;\n    float n = pi2/r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\nmat3 camera(vec3 ro,vec3 ta){\n    vec3 up = vec3(0,1,0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw,up));\n    vec3 cv = normalize(cross(cu,cw));\n\n    return mat3(cu,cv,cw);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    return length(max(abs(p)- b, 0.0));\n}\n\nfloat map(vec3 p){\n    vec3 z = p;\n    z.xy = pmod(p.xy,6.);\n    float scale = 2.0;\n    float sum = scale;\n    float d = 1e5;\n    float time = abs(sin(iTime * 0.5) * 4.0);\n    float s = min(floor(time),3.0) + 1.0;\n    for(float i = 0.; i < 5.; i++){\n    p.xy = pmod(p.xy,3.);\n    p=abs(p)-.3;\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    p.xy-=.2;\n    p.xy*=rot(.5);\n    p.yz*=rot(.5);\n    }\n  float h=.5;\n  p.x-=clamp(p.x,-h,h);\n  // torus SDF\n  return length(vec2(length(p.xy)-.5,p.z))-.05;\n\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.0001,0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n    );\n\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    float dist = 0.9 + 0.9 * sin(iTime * 0.1);\n    vec3 ro = vec3(cos( 0.1 * iTime) * dist,1,sin(0.1 *iTime) * dist);\n    vec3 ta = vec3(0);\n    vec3 ray = camera(ro,ta) * normalize(vec3(uv,1.8));\n\n    vec3 p = ro;\n    float d = 0., t = 0.;\n    float counter = 0.;\n    float kaisu = 0.;\n    for(float i = 0.; i < 64.; i++ ){\n        d = map(p);\n        counter += 0.1/(0.01 + d*d);\n        kaisu = i;\n        if(d < 0.01) break;\n        p += ray * d;\n\n    }\n\n    if(d < 0.01){\n        col = mix(vec3(.6,.3,.3),vec3(0),abs(p.x * p.y) + kaisu);\n        col += .06 * counter;\n    }\n    else{\n        col = vec3(0.);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 312, 330, 330, 392], [394, 394, 420, 420, 529], [530, 530, 559, 559, 728], [730, 730, 758, 758, 800], [802, 802, 820, 820, 1334], [1336, 1336, 1356, 1356, 1532], [1534, 1534, 1587, 1587, 2329]], "test": "valid"}
{"id": "sssGWS", "name": "Fractal 43_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 286, "published": "Public API", "date": "1616492181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<80.;\n        O.xyz+=.02*abs(cos(d+log(s)*.3))*exp(-.5*i*i*e)\n    )\n    {\n        p=g*d;\n        p-=vec3(1.,.1,.1);\n        p=R(p,normalize(vec3(1,2,3)),iTime*.2);\n        q=p;\n        s=1.5;\n        for(int j=0;j++<15;s*=e)\n            p=sign(p)*(1.2-abs(p-1.2)),\n            p=p*(e=8./clamp(dot(p,p),.3,5.5))+q*2.;\n        g+=e=length(p)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 573]], "test": "valid"}
{"id": "sssGzX", "name": "Parallelogram - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a parallelogram. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "parallelogram"], "likes": 15, "viewed": 333, "published": "Public API", "date": "1616438766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a parallelogram. Probably\n// faster than central differences or automatic differentiation/dual\n// numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e = vec2(sk,he);\n    float v = 1.0;\n    if( p.y<0.0 ) { p=-p;v=-v;}\n\n    // horizontal edge\n    vec2 w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec4 dsg = vec4(dot(w,w),v*w,w.y);    \n\n    // vertical edge\n    float s = p.x*e.y - p.y*e.x;\n    if( s<0.0 ) { p=-p; v=-v; }\n    vec2  q = p - vec2(wi,0); q -= e*clamp(dot(q,e)/dot(e,e),-1.0,1.0);\n    float d = dot(q,q);\n    s = abs(s) - wi*he;\n    dsg = vec4( (d<dsg.x) ? vec3(d,v*q) : dsg.xyz,\n                (s>dsg.w) ?      s      : dsg.w );\n     \n    // signed distance\n    d = sqrt(dsg.x)*sign(dsg.w);\n    // and gradient\n    return vec3(d,dsg.yz/d); \n}\n\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n\n        // sdf(p) and gradient(sdf(p))\n        float s = sin(iTime);\n        vec3  dg = sdgParallelogram(p,0.4, 0.6,s);\n        float d = dg.x;\n        vec2 g = dg.yz;\n        \n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssGzX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1408, 1503, 1569, 1569, 2183], [2200, 2200, 2257, 2257, 3389]], "test": "valid"}
{"id": "ssX3Dl", "name": "raaaaainbows", "author": "tripzilch", "description": "rainbows", "tags": ["rainbows"], "likes": 2, "viewed": 70, "published": "Public", "date": "1616716462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n#define phi3 vec3(0.0, 2.0943951023931953, 4.1887902047863905)\n#define gamma vec3(2.2)\n#define igamma vec3(0.454545)\n\nvec3 florp(float a, float p) {\n    // this one maps the color\n    // a = brightness\n    // p = mushrooms\n    float b = clamp(2.*a - 1.,0.,1.);\n    b *= b; b *= b; b *= b;\n    vec3 res = pow(vec3(2.*a - a * a, a * a, b), gamma); // sRGB stands for stupid RGB\n    vec3 f = (1. + sin(phi3 + p)) * 0.333333333;\n    return pow(res.rgb * f.x + res.gbr * f.y + res.bgr * f.z, igamma);\n}\n\nfloat onk(vec2 uv, float t) {\n    // this one makes a wobbly function over t\n    // ranged -1 .. 1\n    float bx = uv.x * -3.13 + 2.04 * sin(uv.y * -2.3 + 1.3 * t) - 0.5* t;\n    float by = uv.y * 4.17 - 1.73 * sin(uv.x * 2.5 - 0.7 * t) + 0.9 * t;\n    return .5 * (sin(bx) + sin(by));\n}\n\nfloat unk(vec2 uv, float t) {\n    // this one ALSO makes a wobbly function over t\n    // ranged 0 .. 1\n    float cx = uv.x * 2.23 - 3.33 * sin(uv.y * -1.3 + 0.3 * t) - 0.4* t;\n    float cy = uv.y * -1.41 + 3.15 * sin(uv.x * 1.5 + 0.4 * t) + 0.1 * t;\n    return .5 + .25 * (sin(cx) + sin(cy));\n}\n\nconst vec2 cos_plz = vec2(0, 0.25); // cos ur face is 15 mins late\nconst vec2 flap = vec2(1., -1.);    // flap to flip not flop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) (??)\n    // this is how to get the pixels straight\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * aspect;\n    // and slightly bigger\n    uv *= 1.5;\n    float t = iTime * 0.5; // half speed is best speed\n    vec2 ee = vec2(4.35, -5.33); // bonus numbers\n    float c = unk(uv * vec2(0.43, -0.53), t); // weirdness amount\n    vec2 trun = sin(cos_plz + c * 8. + t * 0.61); \n    vec2 wp = uv + trun;\n    vec2 wq = uv - trun;\n    float lava = onk(wp, t) * (1. + onk((wq + ee * c) * 0.618, t * .7)); // left as exercise for the reader\n    float hi = 1.000420 + .7 * c; // how high we are \n    float a = smoothstep(-1., hi, lava); // brightness\n    float hole = smoothstep(hi + .02, hi, lava); // no more brightness\n    \n    vec3 col = florp(a, c * 12. + 2.5 * t).bgr * hole; // put everything together\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssX3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 178, 252, 527], [529, 529, 558, 627, 813], [815, 815, 844, 917, 1109], [1147, 1240, 1297, 1398, 2267]], "test": "valid"}
{"id": "ssX3WB", "name": "ray marching - v2", "author": "jezersek", "description": "ray marching ", "tags": ["raymarching"], "likes": 0, "viewed": 112, "published": "Public API", "date": "1616493074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUMBER_OF_STEPS 1000\n#define MAX_DISTANCE 40.0\n#define FOG_DISTANCE 20.0\n#define FOG_DENSITY 0.1\n#define COLLISION_THRESHOLD 0.01\n#define MAX_STEP_SIZE 1000.0\n#define EPSILON 0.001\n\n#define SHAPE_BLEND 0.9\n#define COLOR_BLEND 0.9\n\nfloat f = 1.; // focal length\nvec3 light1 = normalize(vec3(1,1,-.9));\nvec3 light2 = normalize(vec3(-1,0,-.9));\n\nfloat distance_to_wave_sphere_repeat(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(vec3(mod(ray.x+2.,2.)-1., ray.y, mod(ray.z+2.,2.)-1.), pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_wave_sphere(vec3 ray, vec3 pos, float r, float amplitude, vec3 frequency, float speed){\n    return distance(ray, pos) - r + sin(ray.x*frequency.x+iTime*speed)*amplitude + sin(ray.y*frequency.y+iTime*speed)*amplitude + sin(ray.z*frequency.z+iTime*speed)*amplitude;\n}\n\nfloat distance_to_sphere(vec3 ray, vec3 pos, float r){\n    return distance(ray, pos) - r;\n}\n\nfloat smooth_min( float d1, float d2, float s ) {\n    /*float h = clamp( 0.5 + 0.5*(d2-d1)/s, 0.0, 1.0 );\n    return mix( d2, d1, h ) - s*h*(1.0-h);*/\n    \n    float t = tanh((d1-d2)*s);\n    return ((1.+t)*d2 + (1.-t)*d1)/2.;\n}\n\nfloat safe_distance(vec3 ray, out vec3 color, out float shininess){\n    float min_distance = MAX_STEP_SIZE;\n    \n    float size = .9;\n    float k = SHAPE_BLEND;\n    \n    float d = distance_to_wave_sphere_repeat(ray, vec3(0,-4,0), 1., 0.05, vec3(5.3,3.7,4.5), 1.9);\n    float d1 = distance_to_wave_sphere(ray, vec3(0,0,6), 1.5, 0.05, vec3(5.3,3.7,4.5), .9);\n    float d2 = distance_to_sphere(ray, vec3(2.*sin(iTime*2.), 2.*sin(iTime*0.8), 6.+2.*sin(iTime*0.6)), size); \n    /*float d3 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.8), 2.*sin(iTime*0.6), 6.+2.*sin(iTime*2.)), size); \n    float d4 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.1), 2.*sin(iTime*2.), 6.+2.*sin(iTime*0.4)), size); \n    float d5 = distance_to_sphere(ray, vec3(2.*sin(iTime*0.5), 2.*sin(iTime*2.1), 6.+2.*sin(iTime*0.7)), size); */\n   \n    //min_distance = smooth_min(smooth_min(smooth_min(d1, d2, k), smooth_min(d3, d4, k), k), d5, k);\n    \n    // shape blending\n    min_distance = smooth_min(d1, d2, k);\n    min_distance = min(min_distance, d);\n    \n    // color blending\n    vec3 color1 = vec3(1,0,0);\n    vec3 color2 = vec3(.3,0,1);\n    \n    shininess = 1.;\n      \n    float t = tanh((d1-d2)*COLOR_BLEND);\n    color = ((1.+t)*color1 + (1.-t)*color2)/2.;\n    \n    // glow on intersection\n    color += vec3(1,1,1)*(pow(1.-t*t, 10.*(4.+sin(ray.y*100.)+cos(ray.x*100.)) ));\n    \n    if(d == min_distance){\n        color *= 0.3;\n        shininess = 0.;\n    }\n    \n    \n    return min_distance;\n}\n\nfloat safe_distance(vec3 ray){\n    vec3 c = vec3(0);\n    float s = 0.;\n    return safe_distance(ray, c, s);\n}\n\nvec3 normal(vec3 ray){\n    vec3 n = vec3(0,0,0);\n    vec3 epsilon = vec3(EPSILON, 0, 0);\n    \n    float x = safe_distance(ray + epsilon.xyy) - safe_distance(ray - epsilon.xyy);\n    float y = safe_distance(ray + epsilon.yxy) - safe_distance(ray - epsilon.yxy);\n    float z = safe_distance(ray + epsilon.yyx) - safe_distance(ray - epsilon.yyx);\n    \n    return normalize(vec3(x,y,z));\n}\n\nvec3 ray_march(vec3 ray){\n    vec3 color = vec3(0,0,0);\n    float shininess = 0.;\n    vec3 bodyColor = vec3(0);\n    float d = 0.; // ray length\n    float min_distance = 100000.; // infty\n    for(int j=0; j<NUMBER_OF_STEPS; j++){\n        float step_size = safe_distance(ray*d, bodyColor, shininess);\n        \n        if(step_size < COLLISION_THRESHOLD){ // collision\n            vec3 n = normal(ray*d);\n            float l1 = max(dot(n, light1), 0.);\n            float l2 = max(dot(n, light2), 0.);\n            //color = (l1 * vec3(.9,0,0.5) + l2 * vec3(.0,.5,.7));\n            //color = -n*0.5+0.5;\n            color = bodyColor*l1 + bodyColor*l2 + (vec3(0.5)*pow(l1, 30.) + vec3(.5)*pow(l2, 30.))*shininess;\n            \n            // fog in the distance\n            color /= (exp((d-FOG_DISTANCE)*FOG_DENSITY)+1.);\n            \n            return color;\n        }\n        \n        if(step_size < min_distance) min_distance = step_size;\n        \n        d += step_size;\n        \n        if(d > MAX_DISTANCE){ // decay\n           break;\n        }\n    }\n    \n    // glow\n    //color = vec3(1.,.4,.9)*pow(max(1.-min_distance,0.),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate system\n    float mind = min(iResolution.y, iResolution.x);\n    vec2 uv = (fragCoord-iResolution.xy/2.)/mind;\n\n    \n    vec3 ray = normalize(vec3(uv, f));\n    \n    vec3 color = ray_march(ray);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssX3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 351, 463, 463, 691], [693, 693, 798, 798, 976], [978, 978, 1032, 1032, 1069], [1071, 1071, 1120, 1221, 1298], [1300, 1300, 1367, 1367, 2772], [2774, 2774, 2804, 2804, 2883], [2885, 2885, 2907, 2907, 3269], [3271, 3271, 3296, 3296, 4429], [4431, 4431, 4488, 4523, 4768]], "test": "valid"}
{"id": "ssXGRf", "name": "Apollonian Conics", "author": "mla", "description": "A family of conics constructed on oblique axes, following Apollonius. Mouse moves axes, key 'f' controls display of field vectors.", "tags": ["conic", "loopless", "apollonius", "sections"], "likes": 6, "viewed": 220, "published": "Public API", "date": "1616359119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian Conics, Matthew Arcus, mla, 2021. Creative Commons Licence, etc.\n//\n// Around 200 BC Apollonius of Perga showed that any section through a oblique\n// cone could be represented, in modern terms, as a curve y² = kx² + x, with x\n// and y coordinates referred to generally oblique axes. This equation represents\n// a conic that i) passes through the origin ii) is tangent to the y axis and\n// iii) the x axis is a diameter that passes through the centre of the conic\n// and bisects all chords parallel to the y-axis.\n//\n// Mouse rotates axes. The red conic is the parabola in the family, so the\n// curves inside are ellipses, the ones outside are hyperbolas\n//\n// Loopy and loopless methods implemented. The loopless method does something\n// strange around the origin which I'm not sure how to fix.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nconst float HALFPI = 0.5*PI;\n\n// Distance to conic with parameter -1 < k < 1\n// k = 0 is straight line\n// else k = 1 or -1 is parabola\n// else k > 0 is ellipse\n// else k < 0 is hyperbola\nfloat conic(vec2 z,float k,mat2 m) {\n  k = 1.0/tan(k*HALFPI);\n  float x = z.x, y = z.y;\n  if (abs(k) > 1e4) return abs(x);\n  float t = k*x*x+x-y*y;\n  vec2 grad = vec2(2.0*k*x+1.0,-2.0*y);\n  grad = m*grad;\n  return abs(t)/length(grad);\n}\n\nfloat K = 10.0; // Show 2K conics\n// Loopless.\nvec2 conicdist0(vec2 z, mat2 m) {\n  float T = 1.0;\n  float x = z.x, y = z.y;\n  float k = atan(x*x/(y*y-x))/HALFPI;\n  float t = iTime;\n  k -= T/K*t;\n  float k0 = k;\n  k *= K; \n  k = round(k);\n  k += T*t;\n  k /= K; \n  float d = conic(z,k,m);\n  return vec2(k0,d);\n}\n\n// Loopy. Not too slow & a nicer image.\nvec2 conicdist1(vec2 z, mat2 m) {\n  float x = z.x, y = z.y;\n  float k0 = atan(x*x/(y*y-x))/HALFPI;\n  float t = iTime;\n  k0 -= t/K;\n  float d = 1e8;\n  for (float i = -K; i < K; i++) {\n    float k = (i+t)/K;\n    d = min(d,conic(z,k,m));\n  }\n  return vec2(k0,d);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return 0.75*rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\nconst int CHAR_F = 70;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int AA = 1; // This doesn't really need AA, but just in case.\n  vec3 col = vec3(0);\n  vec2 w = iTime*vec2(-0.123,0.1);\n  if (iMouse.z > 0.0) w = PI*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  mat2 m = mat2(rotate(vec2(1,0),w.x), rotate(vec2(0,1),w.y)); // Rotated axes\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      z *= 2.0;\n      vec2 z0 = z; // Untransformed coordinate\n      z *= m; // Transform to oblique coordinates (postmultiply = transpose multiply)\n      vec2 ldist = fragCoord.y < 0.5*iResolution.y ? conicdist0(z,m) : conicdist1(z,m);\n      float lmin = 0.0, lmax = max(0.02,fwidth(length(z)));\n      float h = fract(0.5*ldist.x);\n      vec3 c = 0.2+0.8*h2rgb(min(h,1.0-h)); // Field value to colour\n      // Draw axes & grid\n      vec2 uv = abs(z);\n      float d = min(uv.x,uv.y); // Show axes\n      c = mix(c,vec3(0),1.0-smoothstep(lmin,lmax,d));\n      d = abs(conic(z,1.0,m)); // Show parabola\n      c = mix(c,vec3(1,0,0),1.0-smoothstep(lmin,lmax,d));\n      if (!key(CHAR_F)) {\n        // Draw the local orthogonal vectors\n        vec2 z1 = z0-round(z0*10.0)/10.0; // Local base point\n        float x = z.x, y = z.y;\n        vec2 a = vec2(1,-2.0*x*y/(2.0*y*y-x)); // Tangent vector at local point, in oblique coords\n        a = m*a; // Tangent vector to screen space\n        a = vec2(-a.y,a.x); // Rotate 90°\n        float d = abs(dot(z1,a)/length(a)); // And find the length\n        c = mix(c,vec3(0.0),1.0-smoothstep(0.4*lmin,0.4*lmax,d));\n      }\n      // Now draw grid lines\n      uv *= 4.0;\n      uv = fract(uv);\n      uv = min(uv,1.0-uv);\n      d = min(uv.x,uv.y);\n      d /= 4.0;\n      c = mix(c,vec3(0),1.0-smoothstep(0.5*lmin,0.5*lmax,d));\n      // And finally draw conics\n      c = mix(c,vec3(1),1.0-smoothstep(lmin,0.8*lmax,abs(ldist.y)));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1038, 1195, 1231, 1231, 1431], [1449, 1480, 1513, 1513, 1742], [1744, 1784, 1817, 1817, 2045], [2047, 2047, 2068, 2068, 2206], [2208, 2239, 2269, 2269, 2314], [2409, 2409, 2461, 2461, 4453]], "test": "error"}
{"id": "ssXGRM", "name": "Planets evolution", "author": "foxes", "description": "This is still a blank for a generalized planet generator. It remains only to decorate Will be updated.\n", "tags": ["procedural", "3d", "noise", "perlin", "planet"], "likes": 13, "viewed": 479, "published": "Public API", "date": "1615664403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Panteleymonov A K 2021\n//\n\n//****************** if there are problems with the image change the hash ***********\n\n//#define hash(n) fract(mod(n*n*34.+n,289.)/289.)\n#define hash(n) fract(abs(sin(n))*1399763.5453123)\n//#define hash(n) fract(fract(n*0.31830988618379067153776752674503)*fract(n*0.15915494309189533576888376337251)*265871.1723)\n\nvec2 scroll = vec2(0.);\nint cid = 0;\nfloat cmf = 0.;\n\n//atmosfera colors\nconst vec3 catm01[6] = vec3[6](vec3(1.0,0.3,0.0),vec3(1.0,0.96,0.7),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.3,0.76,1.0),vec3(1.0,1.0,1.0));\nconst vec3 catm02[6] = vec3[6](vec3(1.0,.99,.94),vec3(1.0,0.96,0.7),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.3,0.76,1.0),vec3(1.0,1.0,1.0));\n\n//cloud colors\nconst vec3 ccl01[6] = vec3[6](vec3(0.0,0.0,0.0),vec3(0.9,0.8,0.6),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\nconst vec3 ccl02[6] = vec3[6](vec3(0.0,0.0,0.0),vec3(1.0,0.9,0.6),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7),vec3(0.7,0.7,0.7));\n\n//ground colors\nconst vec3 cps01[6]  = vec3[6](vec3(2.0,0.2,0.0),vec3(.94,.63,0.33),vec3(.94,.68,0.53),vec3(.94,.63,0.33),vec3(.94,.63,0.33),vec3(1.0,1.0,1.0));\nconst vec3 cps02[6]  = vec3[6](vec3(0.02,0.0,.0),vec3(1.0,0.85,.57),vec3(0.95,0.85,.47),vec3(1.0,0.85,.57),vec3(1.0,0.85,.57),vec3(1.0,1.0,1.0));\n\n//water and lava colors\nconst vec3 cwl01[6] = vec3[6](vec3(1.,1.,1.), vec3(1.,1.,1.), vec3(0.1,0.9,0.4), vec3(0.0,0.9,1.0), vec3(0.0,0.7,1.0), vec3(0.0,0.7,1.0));\nconst vec3 cwl02[6] = vec3[6](vec3(1.,1.,0.), vec3(.8,1.,.1), vec3(0.1,0.4,0.2), vec3(0.3,0.0,0.6), vec3(0.2,0.0,0.7), vec3(0.2,0.0,0.7));\n\nvec3 catmF01() { return mix(catm01[cid],catm01[cid+1],cmf); }\nvec3 catmF02() { return mix(catm02[cid],catm02[cid+1],cmf); }\n\nvec3 cclF01() { return mix(ccl01[cid],ccl01[cid+1],cmf); }\nvec3 cclF02() { return mix(ccl02[cid],ccl02[cid+1],cmf); }\n\nvec3 cpsF01() { return mix(cps01[cid],cps01[cid+1],cmf); }\nvec3 cpsF02() { return mix(cps02[cid],cps02[cid+1],cmf); }\n\nvec3 cwlF01() { return mix(cwl01[cid],cwl01[cid+1],cmf); }\nvec3 cwlF02() { return mix(cwl02[cid],cwl02[cid+1],cmf); }\n\nvec4 hash4( vec4 n ) { return hash(n); }\nvec3 hash3( vec3 n ) { return hash(n); }\nvec2 NC0=vec2(1.0,136.0);\nvec3 NC1=vec3(1.0,136.0,31.0);\nfloat seed = 0.0;\n\nvec2 getBL(vec3 pos) { return vec2(atan(pos.x,pos.z),atan(length(pos.xz),pos.y))/3.1415; }\nvec3 setBL(vec2 bl) { bl*=3.1415; return vec3(cos(bl.y)*cos(bl.x),sin(bl.y),cos(bl.y)*sin(bl.x)); }\n\n// Simple 2d interpolated noise for mercator projection, using local seed.\nfloat sphereNoise2Ds(vec2 bl,float scale,float seed)\n{\n    bl = vec2(fract(bl.x*0.5+0.5), bl.y*scale);\n    vec2 yc = floor(vec2(bl.y)+vec2(0.,1.));\n    vec2 xc = floor(sin(3.1415 * yc/scale)*scale*2.0);\n    vec4 p = xc.xyxy*vec4(bl.xx, fract(bl.xx+1.0/max(vec2(1.),xc)));\n    vec3 f = fract(vec3(p.xy, bl.y));\n    f=f*f*(3.0-2.0*f);\n    yc = (yc + vec2(scale)) * NC0.y;\n    vec3 fn = 1.-f;\n    vec4 n= hash4(floor(p)*NC0.x + yc.xyxy +seed);\n    return dot(n, vec4(fn.xy,f.xy)*vec4(fn.z,f.z,fn.z,f.z));\n}\n\nvec2 sphereNoise2D2s(vec2 bl,float scale,vec2 seed)\n{\n    bl = vec2(fract(bl.x*0.5+0.5), bl.y*scale);\n    vec2 yc = floor(vec2(bl.y)+vec2(0.,1.));\n    vec2 xc = floor(sin(3.1415 * yc/scale)*scale*2.0);\n    vec4 p = xc.xyxy*vec4(bl.xx, fract(bl.xx+1.0/max(vec2(1.),xc)));\n    vec3 f = fract(vec3(p.xy, bl.y));\n    f=f*f*(3.0-2.0*f);\n    yc = (yc + vec2(scale)) * NC0.y;\n    vec3 fn = 1.-f;\n    p = floor(p)*NC0.x + yc.xyxy;\n    vec4 n1= hash4(p +seed.x);\n    vec4 n2= hash4(p +seed.y);\n    p = vec4(fn.xy,f.xy)*vec4(fn.z,f.z,fn.z,f.z);\n    return vec2(dot(n1, p), dot(n2, p));\n}\n\n// Simple 2d interpolated noise for mercator projection, using global seed.\nfloat sphereNoise2D(vec2 bl,float scale) { return sphereNoise2Ds(bl,scale,seed); }\n\n// Simple 2d interpolated noise for mercator projection, using global seed animated.\nfloat sphereNoise2D(vec3 blt,float scale)\n{\n    float z = floor(blt.z)*54.0;\n    float f = fract(blt.z);\n    //f=f*f*(3.0-2.0*f);\n    return dot(sphereNoise2D2s(blt.xy,scale,seed+z+vec2(0.,54.)),vec2(1.-f,f));\n}\n\n// Simple 2d interpolated distortion noise for mercator projection, using global seed.\nfloat sphereNoise2Do(vec2 bl,float scale,float force)\n{\n    bl = bl+sphereNoise2D2s(bl,scale*2.0f,vec2(3.,20.))*force/scale;\n    bl.y = clamp(bl.y,0.0,1.0);\n    return sphereNoise2D(bl,scale);\n}\n\nfloat sphereNoise2Do2(vec2 bl,float scale,float force, float s)\n{\n    bl = bl+sphereNoise2D2s(bl,scale*s,vec2(3.,20.))*force/scale;\n    bl.y = clamp(bl.y,0.0,1.0);\n    return sphereNoise2D(bl,scale);\n}\n\nvec2 sphereIntersect(vec3 ray,vec3 pos,float r)\n{\n    float r2=r*r;\n    float cd = dot(pos,ray);\n    vec3 p = ray * cd-pos;\n    float t2 = dot(p,p);\n    if (t2>=r2) return vec2(-1.0, -1.0);\n    float d = sqrt(r2-t2);\n    return cd+vec2(- d,d);\n}\n\nfloat sphereIntersectIn(vec3 ray,vec3 pos,float r)\n{\n    float r2=r*r;\n    float cd = dot(pos,ray);\n    vec3 p = ray * cd-pos;\n    float t2 = dot(p,p);\n    if (t2>=r2) return -1.0;\n    return cd + sqrt(r2-t2);\n}\n\nvec3 sphereNormal(vec3 pos, vec3 surface)\n{\n    return normalize(surface-pos);\n}\n\nfloat spherePerlin(vec2 bl,float scale)\n{\n    return (sphereNoise2D(bl,512.0*scale)*0.8+sphereNoise2D(bl,256.0*scale)*0.8\n     +sphereNoise2D(bl,128.0*scale)+sphereNoise2D(bl,64.0*scale)\n     +sphereNoise2D(bl,32.0*scale)+sphereNoise2D(bl,16.0*scale)\n     +sphereNoise2D(bl,8.0*scale)+sphereNoise2D(bl,4.0*scale)\n     +sphereNoise2D(bl,2.0*scale)*1.2+sphereNoise2D(bl,scale)*1.2)*0.1;\n}\n\nfloat spherePerlinA(vec3 blt,float scale)\n{\n    return (sphereNoise2D(blt,16.0*scale)\n     +sphereNoise2D(blt,8.0*scale)+sphereNoise2D(blt,4.0*scale)\n     +sphereNoise2D(blt,2.0*scale)*1.2+sphereNoise2D(blt,scale)*1.2)*0.2;\n}\n\nfloat spherePerlinHalf(vec2 bl,float scale)\n{\n    return (sphereNoise2D(bl,16.0*scale)+sphereNoise2D(bl,8.0*scale)+sphereNoise2D(bl,4.0*scale)\n     +sphereNoise2D(bl,2.0*scale)+sphereNoise2D(bl,scale))*0.2;\n}\n\nfloat spherePerlinHalfs(vec2 bl,float scale, float seed)\n{\n    return (sphereNoise2Ds(bl,16.0*scale,seed)+sphereNoise2Ds(bl,8.0*scale,seed)+sphereNoise2Ds(bl,4.0*scale,seed)\n     +sphereNoise2Ds(bl,2.0*scale,seed)+sphereNoise2Ds(bl,scale,seed))*0.2;\n}\n\nvec2 spherePerlinHalf2s(vec2 bl,float scale, vec2 seed)\n{\n    return (sphereNoise2D2s(bl,16.0*scale,seed)+sphereNoise2D2s(bl,8.0*scale,seed)+sphereNoise2D2s(bl,4.0*scale,seed)\n     +sphereNoise2D2s(bl,2.0*scale,seed)+sphereNoise2D2s(bl,scale,seed))*0.2;\n}\n\n// Perlin distortion noise \nfloat spherePerlinHalfd(vec2 bl,float scale,float force)\n{\n    return (sphereNoise2Do(bl,16.0*scale,force)+sphereNoise2Do(bl,8.0*scale,force)\n     +sphereNoise2Do(bl,4.0*scale,force)\n     +sphereNoise2Do(bl,2.0*scale,force)+sphereNoise2Do(bl,scale,force))*0.2;\n}\n\n// Perlin distortion noise with increasing coefficient\nfloat spherePerlinHalfds(vec2 bl,float scale,float force)\n{\n    return sphereNoise2Do(bl,16.0*scale,force)*0.05\n    +sphereNoise2Do(bl,8.0*scale,force)*0.15+sphereNoise2Do(bl,4.0*scale,force)*0.2\n    +sphereNoise2Do(bl,2.0*scale,force)*0.25+sphereNoise2Do(bl,scale,force)*0.35;\n}\n\nvec3 wind3D(vec3 pos,float rings,float skip)\n{\n    vec3 f = fract(pos)-0.5;\n    vec3 px = floor(pos);\n    float r = length(pos);\n    vec3 wind =vec3(0.);\n\n    for (int z = -0;z<2;z++)\n    for (int y = -0;y<2;y++)\n    for (int x = -0;x<2;x++) {\n        vec3 off = vec3(float(x),float(y),float(z));\n        vec3 xyz = px + off;\n        float p = dot(xyz,NC1);\n        vec3 add = hash(vec3(p,p+30.0,p+23.0));\n        vec3 fxyz = f + add*0.8-off;\n        float ml = clamp(1.0-length(fxyz)*1.5,0.,1.);\n        vec3 wp = normalize(pos - fxyz) * r - pos;\n        float l1 = length(wp);\n        float l2 = 1.-l1;\n        vec3 w = normalize(cross(wp,pos));\n        wind +=w*ml*clamp(0.5-l1,0.,1.)*clamp(1.0-l2*l2*l2,0.,1.);\n    }\n    return wind;\n}\n\nfloat atmosphere(vec3 pos, vec3 atmosSurface, vec3 ray, vec3 lnorm, float planetRadius, float atmosRadius, float atmosDepth)\n{\n    float wall = sqrt(atmosRadius*atmosRadius - planetRadius*planetRadius);\n    float acc = clamp(atmosDepth/wall,0.0,1.0);\n    acc = acc*pow(clamp(dot(lnorm,normalize(atmosSurface-pos)),0.0,1.0),0.4);\n    acc = acc*acc;\n    acc = acc*acc;\n    \n    return acc;\n}\n\nvec3 sphereTexture(vec3 realSurface,vec3 ray, vec3 snorm,vec3 lnorm,float time)\n{\n    seed = 1.0;\n    vec2 bl = getBL(realSurface);\n\n    seed = 2.0;\n    float d = spherePerlinHalfds(bl,8.0,0.5);\n    seed = 5.0;\n    float c = spherePerlin(bl,4.0);//(c1 + c2)*0.5;\n    float canr = clamp(1.0-abs(d-0.4)*10.0,0.0,1.0);\n    float can = clamp(1.0-abs(d-0.5)*10.0,0.0,1.0) * clamp(c*5.0-1.6,0.0,1.0);\n    float can2 = can*can;\n    float can3 = can2*can;\n    float canr3 = canr*canr*canr*canr;\n    \n    float middle = (0.25 - abs(0.25-abs(0.5-bl.y)))*4.;\n    seed = 10.0;\n    float e = spherePerlinHalfds(bl,6.0,0.5);\n    float mc = clamp(e*6.0-2.4, 0.0, 1.0);\n\n    float snow = scroll.x-0.55;\n    snow = (snow*snow*snow*snow*snow+0.5)*40.0-20.3;\n    snow = clamp((snow+abs(0.5-bl.y)-e*0.3)*50.0,0.,1.);\n\n    float waterline = scroll.x-0.5;\n    waterline = clamp((waterline*waterline*waterline+0.5)*14.0-6.5, 0., 1.);\n    float beach = mix(e, e*c*2.6, 0.05) - waterline;\n    float land = clamp(clamp(beach * 200.0, 0., 1.), 0., 1.); //continents\n    land = land - mix(0.,clamp((mix(canr3,canr3*c*2.6,0.1)-1.3+waterline)*10.0, 0.0, 1.0),land*middle); //river\n\n    vec3 water = mix(cwlF02(),cwlF01(),c+mc*0.2);\n\n    float fa = (spherePerlinA(vec3(bl,time),200.0)+spherePerlinA(vec3(bl,time+2.5),200.0))*0.5;\n    \n    float f = mix(1.0-pow(1.0-c*1.7,2.0),c*1.7,0.3);\n    \n    float forest = scroll.x-0.2;\n    forest = clamp(forest*4.0, 0., 1.);\n    forest = clamp((canr+can+forest*2.-2.3+f*0.1+mc*c*0.5)*4.,0.,1.)*clamp((middle-0.5+mc*c*0.4)*8.,0.,1.);//+forest-0.5\n    forest = clamp(forest*2.,0.,1.);\n\n    float ground = scroll.x-0.2;\n    ground = clamp(ground*4.0, 0., 1.);\n    ground = clamp((canr+can+ground*2.-1.8+f*0.1+mc*c*0.5)*2.,0.,1.)*clamp((middle-0.4+mc*c*0.4)*4.,0.,1.);//+forest-0.5\n    ground = clamp(ground*2.,0.,1.);\n    \n    float rock = scroll.x-0.7;\n    rock = clamp((rock+abs(0.5-bl.y)-e*0.3)*50.0,0.,1.);\n    \n    float canl = (can3+fa-0.5);\n    f = f-can3*0.34;\n\n    float light = 1.-clamp(dot(snorm,lnorm),0.0,1.0);\n    light = 1.0-light*light;\n    float ref = clamp(dot(reflect(ray,normalize(snorm+0.6*cross(ray,snorm)*(0.5-fa))),lnorm),0.0,1.0);\n    ref = ref*0.9;\n    \n    vec3 ert = mix(cpsF01(),cpsF02(),f)*f;\n    ert = mix(ert, mix(vec3(1.0,0.5,0.0),vec3(1.0,0.8,0.33),mc), 0.2);\n    vec3 gc = mix(mix(vec3(0.3,0.3,0.0),vec3(0.5,0.5,0.3),e*f*f)*f, mix(vec3(0.3,0.2,0.0),vec3(1.0,0.8,0.33),mc), 0.5);\n    ert = mix(ert,gc, clamp(ground+forest,0.,1.));\n    ert = mix(ert, vec3(0.8)*clamp(f*2.-1.4+c,0.,1.), rock*0.7);\n    ert = clamp(mix(ert, mix(vec3(0.7,0.9,0.0),vec3(0.0,0.1,0.1),c), forest),vec3(0.,0.,0.),vec3(1.,1.,1.));\n    vec3 col = mix(water,ert,land);\n    \n    float l = (1.0-land) * pow(ref,8.0)*(fa+1.0);\n    float wl = clamp((light+pow(ref,6.0)) * (1.0-land) * mix((abs(0.5-fa)*2.0),0.0,0.3),0.0,1.0);\n       \n    vec3 lcolor = l*mix(vec3(1.0),vec3(1.0,0.9,0.8),clamp(dot(ray,lnorm),0.,1.));\n    col = clamp(mix(col*light+lcolor,vec3(1.0),wl*1.0*light),vec3(0.,0.,0.),vec3(1.,1.,1.));\n    \n    vec3 lav = mix(vec3(1.,0.0,0.),mix(cwlF02(),cwlF01(),clamp(abs(0.5-canl)*3.0,0.,1.)),clamp(canl,0.,1.));\n    float lm=clamp(scroll.x*5.0,0.,1.);\n    can3 = mix(mix(can3,can3*can3*can3*can3,lm),0.,lm);\n    col = mix(col*light,lav*2.0,can3);\n\n    vec3 snowc = clamp(mix(mix(vec3(0.1,0.3,0.7),vec3(0.6,0.6,0.6),mc),vec3(1.0,1.0,1.0),f)*f,vec3(0.,0.,0.),vec3(1.,1.,1.));\n    snowc = mix(snowc,mix(vec3(0.0,1.0,1.0),vec3(1.0,1.0,1.0),mc),0.2);\n\n    col = mix(col,snowc*light,snow);\n\n    return clamp(col,vec3(0.,0.,0.),vec3(1.,1.,1.));\n}\n\nvec2 cloudTexture(vec3 realSurface, float time)\n{\n   seed = 14.0;\n   vec2 bl = getBL(realSurface);\n\n   vec3 w = wind3D(realSurface*1.,1.5,0.);\n   w += wind3D(realSurface*2.,1.5,0.)*0.2;\n   w += wind3D(realSurface*6.,1.5,0.)*0.1;\n   vec2 t = time*vec2(0.2,0.5); \n   vec2 bld1 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.x))));\n   vec2 bld2 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.x+0.5))));\n   vec2 blc1 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.y))));\n   vec2 blc2 = getBL(normalize(realSurface-w*(1.4+0.4*fract(t.y+0.5))));\n\n   seed = 14.0+floor(t.x)*0.1;\n   float d1 = spherePerlinHalf(bld1, 6.0);\n   seed = 14.05+floor(t.x+0.5)*0.1;\n   float d2 = spherePerlinHalf(bld2, 6.0);\n   \n   seed = 14.0+floor(t.y)*2.0;\n   float c1 = spherePerlinHalf(blc1, 192.0);\n   seed = 15.0+floor(t.y+0.5)*2.0;\n   float c2 = spherePerlinHalf(blc2, 192.0);\n   vec2 fdc = abs(0.5-fract(t))*2.0;\n   float d = mix(d1,d2,fdc.x);\n   float c = mix(c1,c2,fdc.y);\n   \n   float f = clamp((d*d)*4.0-c-0.5,0.0,1.0);\n   f = 1.-f;\n   return vec2(1.-f*f,0);\n   //return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // resolution\n    float res = 1.0 / iResolution.y;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\n    \n    // bace const\n    float time=iTime*1.0;\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 col = vec3(0.0);\n    vec2 mouse = (iMouse.xy*2.0-iResolution.xy)*res;\n\n    // segments\n    scroll = iMouse.z>0.0 ? mouse : vec2(floor(p.x*2.5)*0.4+0.2,0.0);\n    scroll = clamp(scroll*0.5+0.5,vec2(0.),vec2(1.));\n    // test scroll\n    cid = int(floor(scroll.x*5.0));\n    cmf = fract(scroll.x*5.0);\n    //const vec3 pal[6] = vec3[6](vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,1.0,1.0),vec3(0.0,0.0,1.0),vec3(1.0,0.0,1.0));\n    //col = mix(pal[int(floor(scroll.x*5.0))],pal[int(floor(scroll.x*5.0))+1],fract(scroll.x*5.0));\n\n    // transforms\n    vec2 rotate = iMouse.z>0.0 ? vec2((mouse.x*5.+5.0)*3.1415,mouse.y*2.) : vec2(0.,-0.6);\n    //vec2 rotate = vec2(0.,-0.6);\n    float protate = time*0.025;\n    vec4 mcs=vec4(sin(rotate),cos(rotate));\n    vec2 pcs=vec2(cos(protate),sin(protate)); // planet rotation\n    mat3 mr=mat3(vec3(mcs.z,0.0,mcs.x),vec3(0.0,1.0,0.0),vec3(-mcs.x,0.0,mcs.z));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,mcs.w,mcs.y),vec3(0.0,-mcs.y,mcs.w))*mr;\n    mat3 pmr=mat3(vec3(pcs.x,0.0,pcs.y),vec3(0.0,1.0,0.0),vec3(-pcs.y,0.0,pcs.x));\n    \n    // object data\n    float dist=2.3;\n    float rplanet = 1.0;\n    float ratmos = 1.15;\n    float rcloud = 1.005;\n    vec3 spos = vec3(0.0,0.0,dist);\n    vec3 lpos = vec3(4.5,4.5,-9.0+dist);\n    lpos = mr*(lpos-spos) + spos;\n    vec3 lnorm = normalize(lpos - spos);\n    \n    // render calc\n    float dplanet = sphereIntersect(ray,spos,rplanet).x;\n    vec2 dcloud = sphereIntersect(ray,spos,rcloud);\n    float datmos = sphereIntersect(ray,spos,ratmos).x;\n    if (dplanet>0.0) {\n        vec3 ssurface = ray*dplanet;\n        vec3 snorm = sphereNormal(spos,ssurface);\n        vec3 lsnorm = normalize(lpos - ssurface);\n        float dcs = sphereIntersectIn(lnorm,spos-ssurface,rcloud);\n        vec3 scloud = ssurface+lnorm*dcs;\n        float cs = dot(snorm,lnorm)>0. ? clamp(1.0-cloudTexture((scloud-spos)*mr*pmr,time*0.2).x,0.0,1.0) : 1.0;\n\n        col = sphereTexture((ssurface-spos)*mr*pmr,ray,snorm,lsnorm,time);\n        col = mix(col,col*cs,0.7);\n    }\n    if (datmos>0.0) {\n        float adepth = dplanet>0.0 ? (dplanet-datmos)*1.2 : abs(dot(ray,spos)-datmos);\n        vec3 ssurface = ray*datmos;\n        float ap = atmosphere(spos, ssurface, ray, lnorm, rplanet, ratmos, adepth);\n        col = mix(col,mix(catmF01(),catmF02(),ap),ap);\n    }\n    if (dcloud.x>0.0) {\n        vec3 sback = ray*dcloud.y;\n        vec3 ssurface = ray*dcloud.x;\n        vec3 snorm = sphereNormal(spos,ssurface);\n        vec3 lsnorm = normalize(lpos - ssurface);\n        vec2 al = cloudTexture((ssurface-spos+lsnorm*0.01)*mr*pmr,time*0.2);\n        vec2 a = cloudTexture((ssurface-spos)*mr*pmr,time*0.2);\n        float emboss = a.x-al.x+0.05;\n        float light = 1.-clamp(dot(snorm,lsnorm),0.0,1.0);\n        light = 1.-light*light;\n        col = mix(col,mix(cclF01(),cclF02(),a.y)*light,clamp(a.x,0.,1.))\n            + vec3(clamp(emboss*0.2,0.,1.)+clamp(emboss*0.3*a.x+a.x*0.3*light,0.,1.))*light;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1311, 1614, 1630, 1630, 1675], [1676, 1676, 1692, 1692, 1737], [1739, 1739, 1754, 1754, 1797], [1798, 1798, 1813, 1813, 1856], [1858, 1858, 1873, 1873, 1916], [1917, 1917, 1932, 1932, 1975], [1977, 1977, 1992, 1992, 2035], [2036, 2036, 2051, 2051, 2094], [2096, 2096, 2118, 2118, 2136], [2137, 2137, 2159, 2159, 2177], [2254, 2254, 2276, 2276, 2344], [2345, 2345, 2366, 2366, 2444], [2446, 2521, 2575, 2575, 3024], [3026, 3026, 3079, 3079, 3603], [3605, 3681, 3723, 3723, 3763], [3765, 3850, 3893, 3893, 4061], [4063, 4150, 4205, 4205, 4344], [4346, 4346, 4411, 4411, 4547], [4549, 4549, 4598, 4598, 4794], [4796, 4796, 4848, 4848, 5007], [5009, 5009, 5052, 5052, 5089], [5091, 5091, 5132, 5132, 5477], [5479, 5479, 5522, 5522, 5704], [5706, 5706, 5751, 5751, 5914], [5916, 5916, 5974, 5974, 6167], [6169, 6169, 6226, 6226, 6424], [6426, 6454, 6512, 6512, 6716], [6718, 6773, 6832, 6832, 7052], [7054, 7054, 7100, 7100, 7793], [7795, 7795, 7921, 7921, 8184], [8186, 8186, 8267, 8267, 11745], [11747, 11747, 11796, 11796, 12817], [12819, 12819, 12876, 12894, 16101]], "test": "valid"}
{"id": "ssXGRS", "name": "Walk on Spheres", "author": "tovacinni", "description": "Walk on Spheres", "tags": ["sdf"], "likes": 0, "viewed": 85, "published": "Public", "date": "1616124146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// RNG functions borrowed from demofox\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nfloat left_edge = -0.75;\n\n// sdf function\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// color function\nvoid getCol(in vec2 p, out vec3 col)\n{\n    if (abs(p.x - left_edge) < 0.02) {\n        // a certain kind of blue\n        col = vec3(0.55, 0.71, 0.75);\n    } else {\n        col = vec3(1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // RNG from demofox\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + \n                    uint(fragCoord.y) * uint(9277) + \n                    uint(iFrame) * uint(26699)) | uint(1);\n    \n    // Initialize pixel color\n    vec3 col = vec3(0.0);\n    \n    // Draw boundaries\n    float sdf = sdBox(uv, vec2(0.75, 0.75));\n    if (abs(sdf) < 0.02) {\n        col.xyz = vec3(1.0);\n        getCol(uv.xy, col);\n    }\n    \n    // Do walk on spheres\n    vec2 p = uv.xy;\n    int count = 0;\n    \n    for (int j=0; j<100; ++j) { // for num samples\n        for (int i=0; i<30; ++i) { // for walk on spheres steps\n            float d = sdBox(p, vec2(0.75, 0.75));\n            if (d < 0.0 && abs(d) < 0.001) { // terminate if near boundary\n                vec3 col_sample;\n                getCol(p, col_sample);\n                col += col_sample; \n                count += 1;\n            }\n            float angle = RandomFloat01(rngState) * 3.14159 * 2.0;\n            p += vec2(cos(angle) * d, sin(angle) * d); // walk\n\n        }\n    }\n    col /= float(max(count,1));\n     \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 72, 72, 264], [266, 266, 305, 305, 358], [386, 402, 437, 437, 517], [519, 537, 575, 575, 732], [734, 734, 791, 842, 2050]], "test": "valid"}
{"id": "ssXGWX", "name": "Sphere Thingy", "author": "inspirnathan", "description": "I made this by accident while I was coding a 3D scene and thought it looked cool.", "tags": ["inspirnathan"], "likes": 1, "viewed": 29, "published": "Public", "date": "1616625010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nstruct Object {\n    float sd;\n    vec3 col;\n};\n\nObject sdSphere(vec3 p, float r, vec3 offset, vec3 col)\n{\n  float d = length(p - offset) - r;\n  return Object(d, col);\n}\n\nObject minWithColor(Object obj1, Object obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nObject sdScene(vec3 p) {\n  Object sphereOne = sdSphere(p, 1., vec3(-2.5, 0, -2), vec3(0.2, .7, .7));\n  Object sphereTwo = sdSphere(p, 1., vec3(2.5, 0, -2), vec3(1, 0.58, 0.29));\n  Object closestObj = minWithColor(sphereOne, sphereTwo);\n  return closestObj;\n}\n\nObject rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Object closestObj;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    closestObj = sdScene(p);\n    depth += closestObj.sd;\n    if (closestObj.sd < PRECISION || depth > end) break;\n  }\n  \n  return closestObj;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.001*sin(iTime);\n    float r = 1.;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  Object closestObj = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n\n  if (closestObj.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * closestObj.sd;\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2.5, 2.5, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    col = dif * closestObj.col + backgroundColor * .2;\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 231, 231, 294], [296, 296, 343, 343, 398], [400, 400, 424, 424, 658], [660, 660, 719, 719, 987], [989, 989, 1017, 1017, 1260], [1262, 1262, 1319, 1319, 1967]], "test": "valid"}
{"id": "ssXGzM", "name": "Pretty Tangents", "author": "Chosen", "description": "Some parameters at the top you can tweak.", "tags": ["2d", "simple", "lines"], "likes": 1, "viewed": 57, "published": "Public", "date": "1615688295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LINES 24.\n#define LINES_PER_SIDE 12.\n#define THICKNESS 1.\n\nvoid drawDist(out vec3 frag, float d, vec4 colour, float edge)\n{\n    frag = mix(frag, colour.rgb, smoothstep(edge, 0., d) * colour.a);\n}\n\n// Inigo Quilez - Deriving the SDF of a Line Segment\n// https://www.youtube.com/watch?v=PMltMdi1Wzg\nvoid drawSegment(out vec3 frag, vec4 uv, vec4 p1, vec4 p2, vec4 colour, float halfWidth,\n    float edge)\n{\n    vec4 v = p2 - p1;\n\n    // distance to nearest point on segment\n    float d = length(uv - mix(p1, p2, clamp(dot(uv - p1, v) / dot(v, v), 0., 1.)));\n    drawDist(frag, d - halfWidth, colour, edge);\n}\n\nvec4 hueToRGB(float hue)\n{\n    return vec4(clamp(abs(fract(hue + vec3(1, 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 uv = vec4(1.06 * fragCoord / iResolution.xy - .03, 0, 0);\n    float edge = 2. / min(iResolution.x, iResolution.y),\n        halfWidth = edge * THICKNESS / 2.;\n    vec3 frag = vec3(0);\n    float start = floor(iTime * 10.);\n\n    for (float loop = start; loop < start + LINES; ++loop) {\n        float t = mod(loop, LINES_PER_SIDE) / LINES_PER_SIDE;\n        vec4 colour = vec4(hueToRGB(t).rgb * (loop - start) / LINES, 1);\n\n        switch (int(mod(loop / LINES_PER_SIDE, 4.))) {\n            case 0:\n                drawSegment(frag, uv, vec4(0, 1.-t, 0, 0), vec4(t, 0, 0, 0),\n                    colour, halfWidth, edge);\n                break;\n            case 1:\n                drawSegment(frag, uv, vec4(t, 0, 0, 0),    vec4(1, t, 0, 0),\n                    colour, halfWidth, edge);\n                break;\n            case 2:\n                drawSegment(frag, uv, vec4(1, t, 0, 0),    vec4(1.-t, 1, 0, 0),\n                    colour, halfWidth, edge);\n                break;\n            case 3:\n                drawSegment(frag, uv, vec4(1.-t, 1, 0, 0), vec4(0, 1.-t, 0, 0),\n                    colour, halfWidth, edge);\n        }\n    }\n    fragColor = vec4(sqrt(frag), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssXGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 131, 131, 203], [205, 305, 411, 411, 613], [615, 615, 641, 641, 734], [736, 736, 791, 791, 1976]], "test": "valid"}
{"id": "tdcXzX", "name": "Basic Light Rays", "author": "RynsArgent", "description": "Inexpensive light ray shader code with fade out along the borders", "tags": ["ray"], "likes": 5, "viewed": 226, "published": "Public API", "date": "1615838876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat rayValue(in vec2 coord, in float frequency, in float travelRate, in float maxStrength)\n{\n    // Fade out along borders of fragment\n    float nx = 2.0f * (coord.x - 0.5f);\n    float nx2 = min(1.0f, 3.5f - 3.5f * nx * nx);\n    float ny = 2.0f * (coord.y - 0.5f);\n    float ny2 = min(1.0f, 3.5f - 3.5f * ny * ny);\n    \n    float xModifier = 0.5f * (cos(iTime * travelRate + coord.x * frequency) + 1.0f);\n    float yModifier = sin(coord.y);\n    return maxStrength * xModifier * yModifier * nx2 * ny2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ray1 = rayValue(uv, 28.0f, -0.7f, 0.3);\n    float ray2 = rayValue(uv, 34.0f, 0.1f, 0.4);\n    float ray3 = rayValue(uv, 16.0f, -0.05f, 0.4);\n    float ray4 = rayValue(uv, 72.0f, 0.9f, 0.1);\n    float total = ray1 + ray2 + ray3 + ray4;\n    \n    // Output to screen\n    fragColor = vec4(total, total, total, total);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 191, 285, 327, 695], [697, 697, 754, 804, 1174]], "test": "valid"}
{"id": "tdVBWV", "name": "Micro-Projet ", "author": "Mehdix92i", "description": "Micro projet synthèse d'image\nTentative motion blur et antialiasing sans succès", "tags": ["lightingraytracing"], "likes": 0, "viewed": 60, "published": "Public", "date": "1616798350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float     FLT_MAX                   = 1.0 / 0.0;    \n\nconst int       MAX_NB_BOUNCES            = 5;\n\nconst int       NB_LIGHTS                 = 2;\n\nconst int       TIME_SAMPLING_SIZE        = 5;\nconst float     TIME_SAMPLING_OFFSET_TIME = 0.075;\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n\nstruct ShaderInfo\n{\n    vec3 shaderCol;\n    float Ks;\n};\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \n    //_________________________________________________________________________________\n        \n// Camera parameters\n      vec3\t   cameraPos    = vec3(6,  3.5, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0.3,0.4,1);\t\t\t\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t\nconst vec3     planeCol2    = vec3(0.1);\t\t\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,0);\t\t\nconst vec3     light1Col     = vec3(1,1,1);\t\t// white\n      vec3     light1Pos     = vec3(8, 10, -12);\nconst float    light1Pow    = 0.8;\nconst vec3     light2Col   = vec3(1,0.4,1);    //purple\n      vec3     light2Pos    = vec3(3, 10, 1);\nconst float    light2Pow    = 0.5; \n\nLightInfo lights[NB_LIGHTS];\n\n//##############################################################################################\n\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{   \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n   \n    intersecPt = rayPos + t * rayDir;\n    \n   \n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n\n    vec3 cy = normalize(cross( cz, cx));\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n \n //Antialiasing\n    //return smoothstep( pct-0.02, pct, v) - smoothstep( pct, pct+0.02, v);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t// Move the surface point a little outward\n    \t\t\t\t\t\t\t\t\t\t// (along its normal) to ensure it is a bit\n    \t\t\t\t\t\t\t\t\t\t// above the surface.\n\n\t\n    vec3  shadowRayDir   = L;\n    \n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n    \n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, int indL, vec3 L, vec3 R, vec3 V)\n{   \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lights[indL].col * lights[indL].power *   max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lights[indL].col * lights[indL].power *   pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    light1Pos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene2(float time, float dtime)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n        // NOTE: at time=0, the sphere position is the same than the default one defined at\n        //       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene2Blur(float time, float dtime)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n        // NOTE: at time=0, the sphere position is the same than the default one defined at\n        //       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\nfloat integrate(vec2 pos1, vec2 pos2)\n{\n    vec2 D = pos2 - pos1; \n    \n    float t0 = 0.;\n    float t1 = 1.;\n    \n    \n    return 0.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 RaycastAtPixelCoord(vec2 pixCoord)\n{\n    // Set the time used for the animation\n    float time = iTime;\n    float dtime = iTimeDelta;\n    \n    \n    // Animate scene objects\n    AnimateScene2Blur(time,dtime);\n    AnimateScene2Blur(time + 10.0,dtime);\n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n\t// Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distI > 0.0)\n    {\n        // unit-vector going from the surface point toward the light and\n        // length of the segment between the two points\n\t    vec3 L = light1Pos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n\t\t// Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \treturn vec3(computePhongShading(objectCol, objectMat,\n                                             shadowFactor, normalI, 0/*light1*/,  L, R, V));\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n     \treturn vec3(skyCol);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n\n    //Set the time used for the animation\n    float time = iTime;\n    float dtime = iTimeDelta;\n    \n    \n    // Animate scene objects\n    AnimateScene2Blur(time,dtime);\n    AnimateScene2Blur(time/2.0,dtime);\n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord,rayPos, rayDir);\n    \n    ShaderInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        if (distI <= 0.0)\n        {\n            infos[nbBounces].shaderCol = skyCol;\n            infos[nbBounces].Ks        = 0.0;\n            break;\n        }\n        //AMBIANTE 1X\n        for (int i=0; i<NB_LIGHTS; i++)\n        {\n            vec3 L = lights[i].pos - intersecI;\n            float Ldist = length(L);\n            L = L / Ldist;\n            vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n            vec3 V = -rayDir;\n\n            Material objectMat;\n            vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n            float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n            infos[nbBounces].shaderCol += computePhongShading(objectCol, objectMat, shadowFactor, normalI, i, L, R, V);\n            infos[nbBounces].Ks        = objectMat.Ks;\n        }  \n        \n        rayPos = intersecI + normalI * 0.001;\n        rayDir = reflect(rayDir, normalI);\n        nbBounces ++;\n        \n    }while (nbBounces < MAX_NB_BOUNCES);\n    \n    if (nbBounces == 0) return skyCol;\n    \n    vec3 resCol = infos[nbBounces - 1].shaderCol;\n    \n    \n    for(int i = nbBounces-2; i>=0; i--)\n    {\n        resCol = resCol * infos[i].Ks + infos[i].shaderCol;\n    }\n    \n  \n    return resCol;\n}\n\n\n//##############################################################################################\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;\n\n    //vec3 resCol = RaycastAtPixelCoord(fragCoord);\n        \n    \n    vec3 resCol = RaytraceAtPixelCoord(fragCoord);\n    \n    \n    fragColor = vec4(resCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1942, 2041, 2186, 2186, 2976], [2979, 3079, 3219, 3219, 3663], [3666, 3765, 3850, 3850, 4273], [4375, 4471, 4620, 4697, 5635], [5638, 5737, 5774, 5774, 5798], [5900, 5944, 5980, 5980, 6715], [6718, 6817, 6892, 6892, 7154], [7157, 7256, 7343, 7343, 7909], [7912, 8011, 8160, 8160, 8630], [8633, 8732, 8763, 8798, 9738], [9742, 9841, 9886, 9921, 10312], [10315, 10414, 10463, 10498, 10889], [10892, 10990, 11029, 11029, 11127], [11129, 11228, 11269, 11312, 13337], [13340, 13439, 13481, 13524, 15261], [15264, 15363, 15420, 15420, 15775]], "test": "error"}
{"id": "tlcGz8", "name": "Lava Lamp Experiment", "author": "etiennecreator", "description": "lava", "tags": ["lava"], "likes": 0, "viewed": 32, "published": "Public", "date": "1617059648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float lipschitzFallOff = 1.71730020672; // http://liris.cnrs.fr/~egfr/BestPapers/Deuxieme2014_Genevaux.pdf\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 blue=vec3(0,0.0,1.0);\nconst vec3 green=vec3(0.0,1.0,0.0);\nconst vec3 pink=vec3(0.8,0.6,0.6);\nconst vec3 yellow=vec3(0.808,0.443,0.0549);\nconst vec3 fonce=vec3(0.141,0.117,0.078);\nconst vec3 clair=vec3(0.407,0.329,0.211);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 orangeFonce = vec3(0.3,0.0,0.0);\nconst vec3 blanc = vec3(0.9,0.9,0.9);\nconst vec3 noir = vec3(0.1,0.1,0.1);\nconst vec3 tenebres = vec3(0.0,0.0,0.0);\n\n\n\n\n// ----------------------------------\n// Noise\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) \n{ \n    return fract(sin(n)*43758.5453123); \n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\nfloat noiseGen(in vec3 p, float frequence)\n{\n    float b = 0.0;\n    vec3 q = frequence*p;\n    b += 0.7*noise(q); q = m*q*2.01;\n    b += 0.25*noise(q); q = m*q*2.02;\n    b/= 0.7+0.25;\n    \n    return b;\n}\n\nvec3 warp(in vec3 p)\n{\n \tfloat b = noiseGen(p, .25);\n    vec3 pprime = vec3(p.x + b, p.y + cos(b)*b, p.z + sin(b)*b);\n\n    return pprime;\n}\n\n\n// ----------------------------------\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n\n\n\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n\n\n\n// ----------------------------------\n\n\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n\n\n\n\nfloat klipschitz(float e, float R) {\n \treturn e * lipschitzFallOff / R;   \n}\n\nfloat lavaLamp(vec3 p, out float lip, out vec3 colorOut)\n{\n    lip = klipschitz(1.0, 1.5);\n    \n    //p =  rotateZ(p, 52.0);\n    \n \n \tfloat sphere1 = point(warp(p), vec3(\n        0.4 * cos(iTime), \n        ((1.0 +cos(iTime*0.4))/2.0)*6.-2., \n        0.4*sin(iTime)\n    ), 1.0, 1.5);\n   \n \tfloat sphere2 = point(warp(p), vec3(\n        0.2*sin(iTime),\n        ((1.0+cos(iTime*0.2))/2.0)*3.5-1.75, \n        0.2*cos(iTime)\n    ), 1.5, 2.0);\n  \n \tfloat sphere3 = point(warp(p), vec3(\n        0.5*sin(iTime+3546.), \n        ((1.0+cos(iTime*0.3))/2.0)*4.5-2.25, \n        0.5*cos(iTime+3546.)\n    ), 1.25, 1.75);\n    \n   \n   \n    float v = sphere1+sphere1+sphere3;\n    return v;\n    \n}\n\n// ----------------------------------\n\n\n\n\n// Potential field of the object\n// p : point\n// lip : lipschitz's constant\n// color : color of the point\nfloat object(vec3 p, out float lip, out vec3 color)\n{\n  p.z=-p.z;\n    \n    \n    vec3 aCube = vec3(-1.5,-1.5,-1.5);\n    vec3 bCube = vec3(1.5,1.5,1.5);\n    vec3 sphr1 = vec3(1.,0.0,0.0);\n    vec3 sphr2 = vec3(-1.,0.0,0.0);\n\n  \tfloat v = lavaLamp(p, lip, color);\n    \n  return v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    float lip = 0.0;\n    vec3 color;\n  float v = object(p, lip, color);\n  n.x = object( vec3(p.x+eps, p.y, p.z) , lip, color) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) , lip, color) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) , lip, color) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip = 0.0;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\n// color : color of the point\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\tfloat lip = 0.0;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, lip, color);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lip);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\n// color : color of the point\nvec3 Shade(vec3 p, vec3 n, in vec3 color)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.5*color;\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\tvec3 color;\n  float t = SphereTrace(ro, rd, hit,s, color);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n, color);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[909, 1083, 1107, 1107, 1151], [1153, 1153, 1179, 1179, 1548], [1551, 1551, 1595, 1595, 1754], [1756, 1756, 1778, 1778, 1895], [1937, 1951, 1982, 1982, 2080], [2082, 2082, 2113, 2113, 2212], [2214, 2214, 2245, 2245, 2344], [2352, 2419, 2454, 2454, 2527], [2597, 2711, 2758, 2758, 2795], [2801, 2801, 2837, 2837, 2877], [2879, 2879, 2937, 2937, 3556], [3600, 3706, 3759, 3759, 3987], [3989, 4029, 4060, 4060, 4366], [4368, 4503, 4570, 4570, 5040], [5042, 5177, 5250, 5250, 5730], [5733, 5753, 5779, 5779, 5851], [5853, 5944, 5987, 6004, 6312], [6314, 6346, 6370, 6370, 6451], [6454, 6454, 6511, 6511, 7334]], "test": "valid"}
{"id": "tlGBzK", "name": "Control Console", "author": "Plento", "description": "Another radial blur thing", "tags": ["2d", "blur"], "likes": 6, "viewed": 219, "published": "Public API", "date": "1615016514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson (Plento)\n\nvec2 R;\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define ss(a, b, t) smoothstep(a, b, t)\nfloat hsh21(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hsh11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define cl 2.3\n#define fr 3.5\n\nvec3 color(vec2 uv){\n    uv*=1.3;\n    \n    vec3 col = vec3(1);\n    float t = .5*iTime + 12.;\n    vec2 tuv = uv;\n\n    uv.x*=.7;\n    float m = clamp(exp((sin(uv.y*8. + 1.6)))*2.8 + .1, cl, fr);\n    uv.x *= m;\n    \n    uv.x += t*1.2;\n    \n\tvec2 fuv = fract(uv*4.);\n    vec2 id = floor(uv*4.);\n    \n    uv.y += .7*iTime*sin(id.x*.55);\n    id = floor(uv*4.);\n    \n    float rnd = hsh11(id.x*999.3);\n    col *= mix(1., .02, step(rnd, .3));\n    \n    float x = id.x*43.2 + id.y*22.5;\n    float sp = ss(0.25, 0.2, abs(fuv.x-0.5));\n    float chk = mod(id.y+id.x,2.0)*hsh21(id*999.) * sp;\n    col *= .5+.45*cos(vec3(.0, .7, .2)*(x + hsh11(floor(iTime*2. + x)))*10.);\n    col *= hsh11(floor(iTime + x));\n    \n    col *= sp;\n    col *= chk;\n    \n    if(m >= fr) col *= 1.5;\n    else if(m <= cl){\n        col = .011 + .04*vec3(chk);\n        col += (.5+.7*cos(uv.x*5.))*.025;\n    }\n    else col *= .5;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv.y += uv.x*.1;\n    uv.y = -abs(uv.y);\n    \n    vec3 col = color(uv);\n\tvec3 acc = vec3(0);\n    \n    float c = 0.0;\n    for(float i = 0.9; i >0.1; i-=0.04){\n        vec2 nv = uv*(i+hsh21(u)*0.15);\n        vec3 nc = color(nv);\n        acc += nc*nc*nc*2.;\n        c++;\n    }\n    \n    acc /= c;\n    \n    col += acc*.13;\n    col *= .6;\n    col *= (1.-step(.78, abs(uv.x)));\n    col = 1.-exp(-col);\n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 148, 148, 265], [267, 267, 288, 288, 373], [406, 406, 426, 426, 1315], [1318, 1318, 1358, 1358, 1875]], "test": "valid"}
{"id": "tlGfzd", "name": "Liberation of the True Self", "author": "Kali", "description": "Result of a shader coding jam with my friend JPupper", "tags": ["raymarching", "reflections"], "likes": 167, "viewed": 8260, "published": "Public", "date": "1614874565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define resolution iResolution\n#define time iTime\n\n\nvec3 objcol;\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat de(vec3 pos)\n{\n    float t = mod(time,17.);\n    float a=smoothstep(13.,15.,t)*8.-smoothstep(4.,0.,t)*4.;\n    float f=sin(time*5.+sin(time*20.)*.2);\n    pos.xz *= rot(time+.5);\n    pos.yz *= rot(time);\n    vec3 p = pos;\n    float s=1.;\n    for (int i=0; i<4; i++){\n        p=abs(p)*1.3-.5-f*.1-a;\n        p.xy*=rot(radians(45.));\n        p.xz*=rot(radians(45.));\n        s*=1.3;\n    }\n    float fra = length(p)/s-.5;\n    pos.xy *= rot(time);\n    p = abs(pos) - 2. - a;\n    float d = length(p) - .7;\n    d = min(d, max(length(p.xz)-.1,p.y));\n    d = min(d, max(length(p.yz)-.1,p.x));\n    d = min(d, max(length(p.xy)-.1,p.z));\n    p = abs(pos);\n    p.x -= 4.+a+f*.5;\n    d = min(d, length(p) - .7);\n    d = min(d, length(p.yz-abs(sin(p.x*.5-time*10.)*.3)));\n    p = abs(pos);\n    p.y -= 4.+a+f*.5;\n    d = min(d, length(p) - .7);\n    d = min(d, max(length(p.xz)-.1,p.y));\n    d = min(d, fra);\n    objcol = abs(p);\n    if (d==fra) objcol=vec3(2.,0.,0.);\n    return d;\n}\n\n\nvec3 normal(vec3 p) {\n    vec2 d = vec2(0., .01);\n    return normalize(vec3(de(p+d.yxx), de(p+d.xyx), de(p+d.xxy))-de(p));\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d = 0., td = 0., maxdist = 30.;\n    vec3 p = from, col = vec3(0.);\n    for (int i = 0; i<100; i++)\n    {\n        float d2 = de(p) * (1.-hash12(gl_FragCoord.xy+time)*.2);\n        if (d2<0.)\n        {\n            vec3 n = normal(p);\n            dir = reflect(dir, n);\n            d2 = .1;\n          \n        }\n        d = max(.01, abs(d2));\n        p += d * dir;\n        td += d;\n        if (td>maxdist) break;\n        col += .01 * objcol;\n    }\n    return pow(col, vec3(2.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / resolution.xy - .5;\n    uv.x *= resolution.x / resolution.y;\n    vec3 from = vec3(0.,0.,-10.);\n    vec3 dir = normalize(vec3(uv, 1.));\n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 85, 107, 107, 224], [226, 226, 244, 244, 310], [312, 312, 332, 332, 1283], [1286, 1286, 1307, 1307, 1410], [1413, 1413, 1446, 1446, 1933], [1936, 1936, 1993, 1993, 2220]], "test": "valid"}
{"id": "tlKBD3", "name": "ring shader", "author": "csgradle", "description": "since i made a grid shader last time, this time I'm making rings\nbreakdown:\n- noise coordinate distortion\n- rings from the center\n- one regular grid, and one rotated grid\n- horizontal particles\n- color distortion", "tags": ["rings", "ring"], "likes": 3, "viewed": 61, "published": "Public", "date": "1615228282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat ring(vec2 st, float size, float ringSize) {\n    return ringSize*abs(0.5-mod(length(st), 1./size)*size);\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0, 0.0,_scale.y);\n}\nfloat brick(vec2 st, vec2 size, float thickness) {\n    float xt = fract(st.x*size.x);\n    float yt = fract(st.y*size.y);\n    return step(1.-thickness*(size.x/size.y), xt)+step(1.-thickness,yt);\n}\n// getVal does practically everything. \n// distorts the space, creates a ring, adds two grids, \n// rotates the color, and adds horizontal particles\nvec3 getVal(vec2 uv, float difference) {\n    float distortion = noise(uv*3.)*0.3+0.5;\n    vec2 st = uv * scale(vec2(1.+distortion)*(1.+difference));\n    return vec3(ring(st*scale(vec2(0.2*sin(iTime*0.5+1.4))), 10., 3.) \n            + brick(st, vec2(10.), 0.03)\n            + brick(st*rotate2d(iTime*0.1), vec2(10.), 0.03) \n            + rotate2d(iTime)\n            + step(0.4, noise((st+ vec2(-iTime*0.2,0))*10.*scale(vec2(0.3, 10.)))));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    float colorDistortionAmount = 0.5;\n    // split into r, g, and b to distort color\n    float r = getVal(uv, -colorDistortionAmount).r;\n    float g = getVal(uv, 0.).g; // supposed to be 0 but it looks cooler with 0.5\n    float b = getVal(uv, colorDistortionAmount).b;\n    \n    vec3 col =  vec3(r,g,b);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [162, 247, 269, 269, 673], [674, 674, 702, 702, 788], [789, 789, 838, 838, 900], [901, 901, 925, 925, 972], [973, 973, 1023, 1023, 1168], [1169, 1317, 1357, 1357, 1756], [1757, 1757, 1814, 1814, 2246]], "test": "valid"}
{"id": "tlKBRc", "name": "Test dithering smoothing", "author": "z0rg", "description": "A test based on this shader technique https://www.shadertoy.com/view/tlVBWz", "tags": ["dithering"], "likes": 4, "viewed": 74, "published": "Public API", "date": "1614799836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// A small test of dithering based on time\n// Left side is using dithering\n// Right side is not\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat time;\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float t = time*10.;\n    vec2 p = uv+vec2(sin(t*.25), cos(t))*.25;\n    float c = _cir(p, .05);\n    float shp = iResolution.x*.5;\n    vec3 col = vec3(1.)*sat(c*shp);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    float t = iTime;\n    \n     // stepping the refresh rate to 20/s\n    float stp = 1./20.;\n    \n    t = floor(t/stp)*stp;\n    \n    time = t;\n    \n    // dithering here thx https://www.shadertoy.com/view/tlVBWz\n    if (uv.x < 0.)\n        time = t-sat(texture(iChannel0, fragCoord/8.).x)*stp; \n\n    vec3 col = rdr(uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[397, 540, 569, 569, 595], [597, 597, 616, 616, 802], [805, 805, 862, 862, 1280]], "test": "error"}
{"id": "tlKBWK", "name": "RotateEye", "author": "LuminousPath", "description": "Eye based on Inigo Quilez's Eye runthrough at https://www.youtube.com/watch?v=emjuqqyq_qc", "tags": ["tutorial", "experiment"], "likes": 5, "viewed": 78, "published": "Public", "date": "1615100302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float interpolate(in float a0, in float a1, in float w)\n{\n    return (a1 - a0) * w + a0;\n}\n\nvec2 randomGradient(in int ix, in int iy)\n{\n    float random = 1920.0 * sin(float(ix) * 21942.0 + float(iy) * 1324.0 + 1912.0) * cos(float(ix) * 2157.0 * float(iy) * 27832.0 + 9758.0); \n    vec2 returnvalue = vec2(0.0, 0.0);\n    returnvalue.x = cos(random);\n    returnvalue.y = sin(random);\n    return returnvalue;\n}\n\nfloat dotGridGradient(in int ix, in int iy, in float x, in float y)\n{\n    vec2 gradient = randomGradient(ix, iy);\n    \n    float dx = x - float(ix);\n    float dy = y - float(iy);\n    \n    return (dx*gradient.x + dy*gradient.y);\n}\n\nfloat perlin( in vec2 incoord)\n{\n    vec2 p1 = floor(incoord);\n    vec2 p2 = fract(incoord);\n    int x0 = int(p1.x);\n    int x1 = x0 + 1;\n    int y0 = int(p1.y);\n    int y1 = y0 + 1;\n\n    float n0 = dotGridGradient(x0, y0, incoord.x, incoord.y);\n    float n1 = dotGridGradient(x1, y0, incoord.x, incoord.y);\n    float ix0 = interpolate(n0, n1, p2.x);\n    \n    float n2 = dotGridGradient(x0, y1, incoord.x, incoord.y);\n    float n3 = dotGridGradient(x1, y1, incoord.x, incoord.y);\n    float ix1 = interpolate(n2, n3, p2.x);\n    \n    float value = interpolate(ix0, ix1, p2.y);\n    return value;\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*perlin(p);p *= 2.02;\n    f += 0.2500*perlin(p);p *= 2.03;\n    f += 0.1250*perlin(p);p *= 2.01;\n    f += 0.0625*perlin(p);p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float r = sqrt( dot(p,p) );\n    float a = atan( p.y, p.x );\n    \n    vec3 col = vec3( 1.0 );\n    \n    if( r<0.8)\n    {\n        col = vec3(0.2, 0.3, 0.4);\n        \n        float f = fbm(10.0*p);\n        col = mix (col, vec3(0.2, 0.5, 0.4), f );\n\n        f = 1.0 - smoothstep(0.2, 0.4, r);\n        col = mix(col , vec3(0.9, 0.6, 0.2), f);\n        \n        a += cos(iTime);\n        a += fbm(2.0*cos(iTime)*p);\n        \n        f = smoothstep( -0.3, 0.5, fbm( vec2(5.0*r, 10.0*a) ) );\n        col = mix( col, vec3(1.0), f);\n        \n        f = smoothstep(-0.3, 1.0, fbm(vec2(9.0*r, 10.0*a)) );\n        col *= (1.0 - f);\n        \n        f = smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n        \n        f = smoothstep(0.2, 0.24, r);\n        col *= f;\n        \n        f = 1.0 - smoothstep( 0.0, 0.3, length(p - vec2(0.1, 0.1) ) );\n        col += vec3(f);\n        \n        f = smoothstep(0.75, 0.8, r);\n        col = mix(col, vec3(1.0), f);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 90], [92, 92, 135, 135, 408], [410, 410, 479, 479, 639], [641, 641, 673, 673, 1235], [1237, 1237, 1258, 1258, 1458], [1460, 1460, 1517, 1517, 2625]], "test": "valid"}
{"id": "tlKfWV", "name": "spherical geometry", "author": "Aratelnar", "description": "equidistant azimuthal projection of spherical geometry", "tags": ["geometry", "spherical", "elliptic"], "likes": 0, "viewed": 29, "published": "Public", "date": "1615123662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 toPolar(vec2 o)\n{\n    return vec2(length(o), acos(o.x/length(o))*sign(o.y));\n}\n\nvec2 toLinear(vec2 o)\n{\n    return vec2(o.x*cos(o.y), o.x*sin(o.y));\n}\n\nvec2 dist(vec2 r, vec2 o)\n{\n    vec2 res;\n    res.x = acos(cos(r.x)*cos(o.x)+sin(r.x)*sin(o.x)*cos(r.y-o.y));\n    res.y = acos((cos(r.x) - cos(res.x)*cos(o.x))/sin(res.x)/sin(o.x));\n    res.y = o.y + res.y;\n    return res;\n}\n\nfloat line(vec2 p, vec2 o, vec2 n)\n{    \n    vec2 d = dist(p, o);\n    \n    return cos(d.y-n.y);\n}\n\nfloat square(vec2 p)\n{\n    vec2 o = vec2(0.,radians(0.));\n    \n    \n    vec2 v1 = dist(vec2(1,radians(0.  )),o);\n    vec2 v2 = dist(vec2(1,radians(90. )),o);\n    vec2 v3 = dist(vec2(1,radians(180.)),o);\n    vec2 v4 = dist(vec2(1,radians(270.)),o);\n    \n    float l1 = line(p,vec2(1,radians(0.  )+iTime),vec2(0,radians(180.)+iTime));\n    float l2 = line(p,vec2(1,radians(90. )+iTime),vec2(0,radians(270.)+iTime));\n    float l3 = line(p,vec2(1,radians(180.)+iTime),vec2(0,radians(0.  )+iTime));\n    float l4 = line(p,vec2(1,radians(270.)+iTime),vec2(0,radians(90. )+iTime));\n    return max(max(max(l1,l2),l3),l4);\n}\n\nfloat circle(vec2 p)\n{\n    vec2 o = vec2(radians(70.), iTime);\n    return dist(p,o).x-radians(90.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= 12.;\n    uv *= iResolution.xy/iResolution.x;\n    uv = toPolar(uv);\n    // Time varying pixel color\n    vec3 col = vec3(1,1,1);\n    \n    if(square(uv) < 0.) col *= vec3(.25,0,.5);\n    //col *= line(uv);\n    if(uv.x > radians(180.)) col = vec3(0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 83], [85, 85, 108, 108, 155], [157, 157, 184, 184, 381], [383, 383, 419, 419, 480], [482, 482, 504, 504, 1095], [1097, 1097, 1119, 1119, 1198], [1200, 1200, 1257, 1307, 1669]], "test": "valid"}
{"id": "tltyWN", "name": "sinesum derivative 2", "author": "Shellderr", "description": "using limit", "tags": ["sine", "derivative"], "likes": 2, "viewed": 52, "published": "Public", "date": "1615670850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265\n\n#define _b 1.6\n\nvec2 b(float t, vec2 v){\n   return abs(fract(t*v)-.5)*2.;\n}\n\nfloat ff(float n, float n2, float n3, float amp){\n return ((sin(n)+1.)*(sin(n2)*(sin(n3))+1.)+log(((sin(PI+n)+1.)*(sin(PI+n2)+1.))+1.))*amp; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float a = 10.;\n    float amp = 0.5;\n    float d = .2;\n    \n    float time = iTime*0.04;\n\n    float n = a*(time+distance(uv, _b*b(time,vec2(3.1,1.7))));\n    float n2 = a*(time+distance(uv, _b*b(time,vec2(2.4,3.15))));\n    float n3 = a*(time+distance(uv, _b*b(time,vec2(1.45,2.65))));\n    \n    float f = ff(n, n2, n3, amp);\n    float f2 = ff(n+d, n2+d, n3+d, amp);\n    \n    n = a*(time+distance(uv, b(time,vec2(1.5,3.7))));\n    n2 = a*(time+distance(uv, b(time,vec2(3.4,1.15))));\n    n3 = a*(time+distance(uv, b(time,vec2(2.45,1.65))));\n    \n    f += ff(n, n2, n3, amp);\n    f2 += ff(n+d, n2+d, n3+d, amp);\n    \n    float v = (f2-f)/d;\n\n    fragColor = vec4((1.-vec3(v*v))*vec3(0.,0.3,1.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 64, 64, 99], [101, 101, 150, 150, 244], [246, 246, 303, 303, 1106]], "test": "valid"}
{"id": "tlVBRG", "name": "Spiraling Out", "author": "dr2", "description": "Some logarithmic spiraling", "tags": ["spiral", "polar", "singular"], "likes": 6, "viewed": 207, "published": "Public API", "date": "1614607256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Spiraling Out\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  if (r > 0.01) {\n    a = atan (q.z, q.x) / pi;\n    q.xz = mod (vec2 (0.5 * (pi * log (r) + a) - 0.5 * tCur, 5. * a) + 0.5, 1.) - 0.5;\n    q.y /= sqrt (r);\n    q.y -= 0.15 - 0.01 / r;\n    d = 0.5 * r * PrRoundCylDf (q.xzy, 0.35, 0.02, 0.15);\n    DMINQ (1);\n  }\n  q = p;\n  d = max (0., q.y);\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.5, 0.5, 1., 0.2) * (0.93 + 0.07 * cos (60. * pi * qHit.y));\n    else if (idObj == 2) col4 = vec4 (0.5, 0.6, 1., 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define SHTOY 0\n\n#if SHTOY\n  vec3 iResolution;\n  vec4 iMouse;\n  float iTime;\n#endif\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.03 * pi * tCur;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, -0.07 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.5, -20.);\n  zmFac = 6.;\n  dstFar = 200.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBRG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 466, 488, 488, 889], [891, 891, 924, 924, 1108], [1110, 1110, 1131, 1131, 1386], [1388, 1388, 1423, 1423, 1964], [2093, 2093, 2149, 2149, 3176], [3178, 3178, 3235, 3235, 3310], [3312, 3312, 3348, 3348, 3554], [3556, 3556, 3586, 3586, 3699]], "test": "valid"}
{"id": "tlVBRy", "name": "Scanline Loading Screen", "author": "warptarium", "description": "A little scanline loading screen created for practice", "tags": ["loadingscreen", "practice", "scaneline"], "likes": 1, "viewed": 86, "published": "Public", "date": "1614617803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n\nfloat plot(vec2 uv, float pct)\n{    \n   return  smoothstep( pct-0.01, pct, uv.y) -\n           smoothstep( pct, pct+0.01, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;  \n    \n    //square sin to get 0 : 1 instead of 1 : -1\n    float y = pow(sin(iTime), 2.0);\n    \n    vec3 color = vec3(0);\n    \n    float line = plot(uv, y);\n\n    color = (1.0 - line) * color + line * GREEN;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 132, 132, 229], [231, 231, 288, 338, 645]], "test": "valid"}
{"id": "tlVfDG", "name": "Apollonian control", "author": "gaz", "description": "I got to this by controlling the parameters of the Apollonian.", "tags": ["fractal", "apollonian"], "likes": 11, "viewed": 264, "published": "Public API", "date": "1615001132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 3D arbitrary axis rotation\n// https://www.shadertoy.com/view/wtVyWK\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n\n// hue by FabriceNeyret2\n#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvec3 trans(vec3 p)\n{\n    return R(p,normalize(vec3(1,1,2)),iTime*.1+.5);\n}\n\nfloat apollonian(inout vec3 p)\n{\n    // Control parameters\n    //*\n    float r=2.2;\n    float x=1.;\n    float y=2.;\n    float z=2.;\n    //*/\n    \n    // Other patterns(example)\n    /*\n    float r=12.5;\n    float x=5.2;\n    float y=7.1;\n    float z=2.5;\n    //*/\n       \n    // Fine-tune with some offsets\n    // All numbers are offsets.\n    // s=2. is a number that suppresses the progress of the ray.\n    // If you see artifacts, increase the number.\n    float e,s=2.;\n    for(int i=0;i<6;i++){\n        p=abs(p-vec3(x,y,z))-vec3(x-.2,y,z);\n        //p=abs(p-vec3(x,y,z)*.05)-vec3(x,y,z-.2);\n        //p=mod(p-vec3(x,y,z),vec3(x,y,z)*2.)-vec3(x,y,z);\n        e=(r+.1)/clamp(dot(p,p),.1,r);\n        s*=e;\n        p=abs(p)*e;\n    }\n    return min(length(p.xz),p.y)/s;\n    //return length(p)/s;\n}\n\nfloat apollonian_std(inout vec3 p)\n{\n    // Control parameters\n    float r=1.;\n    float x=1.;\n    float y=1.;\n    float z=1.;\n\n    float e,s=2.;\n    for(int i=0;i<8;i++){\n        p=abs(p-vec3(x,y,z))-vec3(x,y,z);\n        //p=mod(p-vec3(x,y,z),vec3(x,y,z)*2.)-vec3(x,y,z);\n        e=r/clamp(dot(p,p),.0,r);\n        s*=e;\n        p=abs(p)*e;\n    }\n    return min(length(p.xz),p.y)/s;\n    //return length(p)/s;\n}\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    rd=normalize(vec3((C-.5*r.xy)/r.y,1)),\n    ro=vec3(0,0,-1.8);\n    \n    for(float i=1.,g=0.,e;i<99.;i++)\n    {\n        p=g*rd+ro;\n        p=trans(p);\n        // Achieves transparency with non-collision SDF\n        g+=e=apollonian(p)+.001;\n        //g+=e=apollonian_std(p)+.001;\n        O.rgb+=mix(vec3(1),hue(length(p)),.6)*.0015/e/i;\n    }\n\n#if 1\n    // Y axis\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        g+=e=length(p.xz)-.005;\n        e<.001?O.g+=.2/i:i;\n    }\n\n    // X grid\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        p.xz=fract(p.xz-.5)-.5;\n        g+=e=length(p.yz)-.005;\n        e<.001?O.r+=.2/i:i;\n    }\n\n    // Z grid\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        p.xz=fract(p.xz-.5)-.5;\n        g+=e=length(p.xy)-.005;\n        e<.001?O.b+=.3/i:i;\n    }\n\n    // Y axis point (pitch 1.0)\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=trans(p);\n        p.y=fract(p.y-.5)-.5;\n        g+=e=length(p)-.015;\n        e<.001?O+=.3/i:O;\n    }\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 206, 226, 226, 280], [282, 282, 314, 348, 1075], [1077, 1077, 1113, 1139, 1487], [1490, 1490, 1526, 1526, 2665]], "test": "valid"}
{"id": "tlVfRc", "name": "53°K", "author": "dyla", "description": "53°K", "tags": ["procedural", "noise", "fbm", "warp", "blue", "ice", "warped"], "likes": 6, "viewed": 225, "published": "Public API", "date": "1614803142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float prand(vec2 uv) {\n    return fract(sin(dot(mod(uv,153.789),vec2(12.9898,78.233)))*43758.5453) - 0.5;\n}\n\nfloat fprand(vec2 uv, float f){\n    vec2 sp = uv*f;\n    vec2 isp = floor(sp);\n    vec2 fsp = fract(sp);\n    \n    float a = prand(isp+0.5);\n    float b = prand(isp+0.5+vec2(1.0,0.0));\n    float c = prand(isp+0.5+vec2(0.0,1.0));    \n    float d = prand(isp+0.5+vec2(1.0,1.0));\n    float wx = smoothstep(0.0, 1.0, fsp.x);\n    float wy = smoothstep(0.0, 1.0, fsp.y);\n    return mix(mix(a,b,wx), mix(c,d,wx), wy);\n    \n}\n\nfloat perlin(vec2 uv, int octaves, float f0, float fmul, float v0, float vmul){\n    float val = 0.0;\n    float frq = f0;\n    float wei = v0;\n    float time = mod(iTime, 1000.0);\n    vec2 wind = vec2(1.0, 1.0)*0.0005;\n    \n    for (int i=0; i<octaves; i++) {\n        val += wei * fprand(uv+wind*float(i)*time, frq);\n        frq *= fmul;\n        wei *= vmul;\n    }\n    \n    return val;\n}\n\nfloat pdef(vec2 uv) {\n    return perlin(uv, 11, 0.8, 1.7, 1.5, 0.65);\n}\n\nfloat warped(vec2 uv) {\n    return pdef(uv+vec2(pdef(uv+pdef(uv)), pdef(uv+pdef(uv+3.145)+1.25)));\n}\n\nvec4[4] cols = vec4[4](\n    \tvec4(0.05,0.0,0.2,1.0),\n        vec4(0.2,0.4,0.75,1.0),\n    \tvec4(0.4,0.6,0.8,1.0),\n    \tvec4(1.0,1.0,1.0,1.0)\n    );\n\nvec4 getCol(float col) {\n    float lf = float(cols.length()-1);\n    float ci = floor(col * lf);\n    int cii = int(ci);\n    return mix(cols[cii], cols[cii+1], fract(col*lf));\n    //return mix(cols[cii], cols[cii+1], smoothstep(ci/lf, (ci+1.0)/lf, min(max(col,0.0), 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\n    \n    float t = mod(iTime, 1000.0);\n    float tm = 10.0;\n    float mt = mod(t, tm);\n    float transitionStart = 0.8;\n    float col2Weight = smoothstep(transitionStart,1.0,mt/tm);\n   \n    vec4 col1 = getCol(abs(warped(uv+(t-mt))));\n    vec4 col2 = col2Weight>0.0 ? getCol(abs(warped(uv+(t+tm-mt)))) : col1;\n    \n    fragColor = mix(col1, col2,  col2Weight);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 107], [109, 109, 140, 140, 524], [526, 526, 605, 605, 911], [913, 913, 934, 934, 984], [986, 986, 1009, 1009, 1086], [1236, 1236, 1260, 1260, 1509], [1511, 1511, 1568, 1568, 1994]], "test": "valid"}
{"id": "tlVfWG", "name": "Gradient Isolines", "author": "edubart", "description": "Isolines for 2D gradient", "tags": ["2d", "sdf", "gradient", "distance"], "likes": 9, "viewed": 90, "published": "Public", "date": "1614994557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst float arrow_density = 10.0;\nconst float arrow_length = .45;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*20.*arrow_density;\n}\n\nfloat fieldviz(in vec2 p, in vec2 g)\n{\n    vec2 ip = floor(p*arrow_density)/arrow_density + .5/arrow_density;   \n    float m = pow(length(g),0.5)*(arrow_length/arrow_density);\n    vec2 b = normalize(g)*m;\n    float rz = sdSegment(p, ip, ip+b);\n    vec2 prp = (vec2(-b.y,b.x));\n    rz = min(rz, sdSegment(p, ip+b, ip+b*0.65+prp*0.3));\n    return clamp(min(rz,sdSegment(p, ip+b, ip+b*0.65-prp*0.3)),0.,1.);\n}\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgVesica(vec2 p, float r, float d)\n{\n    vec2 s = sign(p); p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    \n    vec3 res;\n    if( (p.y-b)*d > p.x*b )\n    {\n        vec2  q = vec2(p.x,p.y-b);\n        float l = length(q)*sign(d);\n        res = vec3( l, q/l );\n    }\n    else\n    {\n        vec2  q = vec2(p.x+d,p.y);\n        float l = length(q);\n        res = vec3( l-r, q/l );\n    }\n    return vec3(res.x, res.yz*s );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // animate\n    float time = iTime;\n    float r1 = 0.5*cos(time+12.0);\n    float r2 = 0.2*sin(time*1.4);\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgVesica( p, 0.7, r1 );\n    float d = dg.x + r2;\n    vec2  g = dg.yz;\n\n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n    col *= 0.9 + 0.1*step(cos(100.0*d),0.0);\n    if (mod(iTime, 8.0) <= 4.0) {\n        col *= 1.0 + (pow(cos(100.0*atan(g.x,g.y))*0.5+0.5, 32.0));\n        //col *= 1.0 - max(abs(d)-0.25,0.0)*0.2*(pow(cos(200.0*atan(g.x,g.y))*0.5+0.5, 32.0));\n    }\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    float fviz = fieldviz(p, g);\n    if(mod(iTime, 8.0) >= 2.0 && mod(iTime, 8.0) <= 6.0)\n        col += (1.0-fviz)*0.5;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfWG.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1194, 1244, 1244, 1376], [1378, 1378, 1416, 1416, 1784], [1787, 1882, 1924, 1924, 2355], [2357, 2357, 2414, 2414, 3332]], "test": "valid"}
{"id": "tlVfWw", "name": "Rodarte", "author": "mhnewman", "description": "Inspired by Rodarte", "tags": ["procedural", "2d", "flower", "heart", "pattern", "fabric", "rodarte"], "likes": 17, "viewed": 103, "published": "Public", "date": "1614638010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 0.6;\nconst vec3 pink = vec3(1.0, 0.9, 0.9);\nconst vec3 red = vec3(1.0, 0.2, 0.1);\nconst vec3 petalA = vec3(1.0, 0.7, 0.8);\nconst vec3 petalB = vec3(0.7, 0.0, 0.0);\nconst vec3 green = vec3(0.1, 0.4, 0.1);\n\nvec2 rotate(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return p * mat2(c, -s, s, c);\n}\n\n// Heart shape from https://www.shadertoy.com/view/XdcyW8\nfloat heart(vec2 p) {\n    float k = 1.2 * p.y - sqrt(abs(p.x) + 0.3) + 0.7;\n    return step(p.x * p.x + k * k, 1.0);\n}\n\nfloat leaf(vec2 p) {\n    p.y = abs(p.y);\n    p -= vec2(0.5, -0.5);\n    return step(dot(p, p), 0.5);\n}\n\nvoid petal(inout vec3 color, vec2 p) {\n    float grad = 1.0 - p.x;\n    color = mix(color, mix(petalA, petalB, grad * grad), leaf(p));\n}\n\nvoid flower(inout vec3 color, vec2 p) {\n    p -= vec2(0.3, -0.1);\n    float stem = step(p.x, 0.1) * step(-1.7, p.x);\n    color = mix(color, green, step(abs(p.y + 0.2 * sin(2.0 * p.x)), 0.1 * stem));\n    petal(color, rotate(p, -0.5));\n    petal(color, rotate(p, 0.5));\n    petal(color, p);\n    p -= vec2(-0.7, 0.17);\n    color = mix(color, green, leaf(rotate(p, -1.1)));\n    color = mix(color, green, leaf(rotate(p, 1.1)));\n}\n\nvoid heartLayer(inout vec3 color, vec2 p, float t) {\n    p *= 2.0;\n    float col = floor(p.x);\n    p.x = fract(p.x);\n    p.y += 0.5 * t * (mod(col + 0.5, 2.0) - 1.0);\n    float row = floor(p.y);\n    p.y = fract(p.y);\n    p -= vec2(0.5) + 0.2 * sin(vec2(11.0, 17.0) * (row + col) + t);\n    color = mix(color, pink, smoothstep(0.25, 0.0, length(p)));\n    p = rotate(p, col + 5.0 * row + 4.0 * (mod(row + 0.5, 2.0) - 1.0) * t);\n    color = mix(color, red, heart(10.0 * p));\n}\n\nvoid flowerLayer(inout vec3 color, vec2 p, float t) {\n    p *= 2.0;\n    float col = floor(p.x);\n    p.x = fract(p.x);\n    p.y += 0.5 * t * (mod(col + 0.5, 2.0) - 1.0);\n    float row = floor(p.y);\n    p.y = fract(p.y);\n    p -= vec2(0.5) + 0.2 * sin(vec2(11.0, 17.0) * (row + col) + t);\n    color = mix(color, pink, smoothstep(0.25, 0.0, length(p)));\n    p = rotate(p, col + 5.0 * row + 4.0 * (mod(row + 0.5, 2.0) - 1.0) * t);\n    flower(color, 10.0 * p);\n}\n\nvoid heartFrame(inout vec3 color, vec2 p, float t) {\n    p.y = -abs(p.y);\n    color = mix(color, pink, smoothstep(-0.5, -1.1, p.y));\n\n    p *= 0.5;\n    p.x = fract(p.x);\n    color = mix(color, red, heart(15.0 * (p + vec2(-0.93, 0.43))));\n    \n    float smallHeart = step(p.x, 0.86);\n    p *= 10.5;\n    float wave = 4.5 + 0.3 * sin(6.283185 * floor(p.x) / 10.5 + 2.0 * t);\n    p.x = fract(p.x);\n    color = mix(color, red, heart(2.3 * (p + vec2(-0.5, wave))) * smallHeart);\n}\n\nfloat stemHeight(float x) {\n    return 0.5 * cos(0.6 * x) + 0.1 * sin(3.0 * x) + 0.04 * cos(5.3 * x);\n}\n\nfloat growth(float x, float t) {\n    float center = t + 0.4 * (iResolution.x / iResolution.y) * sin(0.3 * t) - 0.5;\n    return 1.0 - abs(center - x);\n}\n\nvoid bloom(inout vec3 color, vec2 p, float t) {\n    p += vec2(t, 0.0);\n    float center = t + sin(0.3 * t);\n    float stem = clamp(2.0 * growth(p.x, t), 0.0, 1.0);\n    color = mix(color, green, step(abs(p.y - stemHeight(p.x)), 0.006 * stem));\n    \n    float id = floor(p.x * 10.0 + 0.2) / 10.0;\n    vec2 base = p - vec2(id, stemHeight(id));\n    float g = smoothstep(0.0, 0.5, growth(id, t)) + 0.01;\n    float size = (10.0 + 4.0 * sin(13.0 * id)) / g;\n    color = mix(color, green, leaf(size * rotate(base, -1.1 * g)));\n    size = (10.0 + 4.0 * sin(17.0 * id)) / g;\n    color = mix(color, green, leaf(size * rotate(base, 1.1 * g)));\n    \n    id = floor(p.x * 3.0 + 0.4) / 3.0;\n    base = p - vec2(id, stemHeight(id));\n    g = growth(id, t);\n    size = 5.0 / (smoothstep(0.0, 0.4, g) + 0.01);\n    float dir = 1.5 * sin(10.0 * id);\n    float r = smoothstep(0.0, 0.8, g);\n    petal(color, size * rotate(base, dir - 0.9 * r));\n    petal(color, size * rotate(base, dir + 0.9 * r));\n    petal(color, size * rotate(base, dir - 0.5 * r));\n    petal(color, size * rotate(base, dir + 0.5 * r));\n    petal(color, size * rotate(base, dir));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float time = speed * iTime;\n\n    vec3 color = pink;\n    \n    heartLayer(color, rotate(3.0 * pos + vec2(time / 3.0, 0.0), 1.0), time + 10.0);\n    color = mix(color, pink, 0.2);\n    flowerLayer(color, rotate(2.5 * pos + vec2(time / 2.5, 0.0), 2.0), time + 20.0);\n    color = mix(color, pink, 0.2);\n    heartLayer(color, rotate(1.6 * pos + vec2(time / 1.6, 0.0), 2.0), time + 20.0);\n    color = mix(color, pink, 0.2);\n    flowerLayer(color, rotate(1.1 * pos + vec2(time / 1.1, 0.0), 3.0), time + 30.0);\n    heartFrame(color, pos + vec2(time, 0.0), time);\n    bloom(color, pos, time);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 255, 255, 335], [337, 395, 416, 416, 513], [515, 515, 535, 535, 616], [618, 618, 656, 656, 753], [755, 755, 794, 794, 1179], [1181, 1181, 1233, 1233, 1653], [1655, 1655, 1708, 1708, 2111], [2113, 2113, 2165, 2165, 2587], [2589, 2589, 2616, 2616, 2692], [2694, 2694, 2726, 2726, 2845], [2847, 2847, 2894, 2894, 3976], [3978, 3978, 4033, 4033, 4722]], "test": "valid"}
{"id": "tlyBW3", "name": "Prism sdf,test", "author": "mseefelder", "description": "Prism SDF, forked from: [url=http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm]http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm[/url]", "tags": ["procedural", "3d", "raymarching", "distancefields", "primitives"], "likes": 0, "viewed": 68, "published": "Public", "date": "1615466215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = normalize(cross( ba, ac ));\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat udPrism( vec3 p, vec3 a, vec3 b, vec3 c, float h )\n{\n  vec3 orig_p = p;\n  \n  vec3 ba = b - a;\n  vec3 cb = c - b;\n  vec3 ac = a - c;\n  vec3 nor = normalize(cross( ba, ac ));\n  \n  p = p - dot(p - ba, nor) * nor;\n  \n  vec3 pa = p - a;\n  vec3 pb = p - b;\n  vec3 pc = p - c;\n  \n  float dist_h = length(orig_p-p)-(h*0.5);\n\n  float dist_tri = sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n  \n  return dist_h > 0.0 ?\n    length(vec2(dist_tri, dist_h)) :\n    dist_tri;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n      res = opU(\n        res, vec2(\n          udPrism(    \n            pos-vec3(-2.0,0.25, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.0,0.0,1.0), vec3(2.0,0.0,0.0), 0.5 \n          ), 26.9 \n        ) \n      );\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBW3.jpg", "access": "shaders20k", "license": "mit", "functions": [[1540, 1609, 1634, 1634, 1653], [1654, 1654, 1679, 1679, 1698], [1699, 1699, 1735, 1735, 1763], [1765, 1765, 1817, 1817, 2325], [2327, 2327, 2385, 2385, 3095], [3097, 3167, 3197, 3197, 3230], [3332, 3402, 3427, 3427, 3697], [3699, 3767, 3818, 3818, 4023], [4025, 4025, 4065, 4065, 4875], [4877, 4939, 5017, 5040, 5427], [5429, 5493, 5525, 5525, 6095], [6097, 6097, 6139, 6139, 6448], [6450, 6526, 6590, 6611, 6844], [6846, 6846, 6911, 6930, 9005], [9007, 9007, 9059, 9059, 9236], [9238, 9238, 9295, 9295, 10672]], "test": "valid"}
{"id": "tlyBWm", "name": "Cone Traced Depth of Field", "author": "BondoGames", "description": "Drag the mouse around to change focal distance and aperture. Cone tracer with the radius changing as the distance from the camera increases to simulate depth of field. Blatant knock off of this shader: https://www.shadertoy.com/view/4scBW8\n", "tags": ["raymarching", "dof", "depthoffield", "conetracing", "conetracing", "onepass"], "likes": 14, "viewed": 176, "published": "Public", "date": "1614820974", "time_retrieved": "2021-10-01T00:00:00", "image_code": " //cone tracing explained here: https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer\n \n \n //comment this out to stop rendering the point light (it's quite expensive)\n#define renderPointLight \n //uncomment this to tonemap (reduces washed out highlights but also darkens the image)\n//#define toneMap\n //camera position and camera target\nvec3 cp=vec3(0.,4.,0);vec3 ct=vec3(2.,3.5,1);\n //max march iterations, max distance (basically far clipping plane),\n //step multiplier dampens raymarch step size to improve blur\nfloat maxI=200.,maxd=50.,stepMultiplier=.5;\n //sample offset for calculating normals\nvec2 e=vec2(0.0035,0);\n //light position\nvec3 lp,ld=normalize(vec3(-1,-1,-1));\n //colour of spheres and background (darker sphere colours help to hide artifacts),light colour\n //(dont set any of the light colour components to 0, it will look stupid),vignette colour\nvec3 sphCol=vec3(0.0,0.7,1),bg=vec3(.9),lc=vec3(1.),vc=vec3(0.,0.2,.3);\n //light brightness\nfloat plb=.7,dlb=1.;\nfloat focalDist=3.,aperture=.02;\n //sphere grid scale\nfloat grid=2.;\n //ambient light level, specular coefficient (shininess)\nfloat amb=.1,specCoeff=400.;\n //camera movement vector\nvec3 vel=vec3(1.,0.,1.);\n //speed and mag of sphere wave, speed and radius of of light rotation\nfloat waveSpeed=1.2,waveMag=.4,lightSpeed=1.,lightRad=12.,\n //height of light, magnitude and sped of light's height oscilation\nlightHeight=2.,lightOscilationMag=1.,lightOscilationSpeed=.5;\nfloat vignetteStrength=.7,fogStrength=1.;\n //trade off between noise and banding with extreme blur. Must be between 0 and 1.\nfloat sampleOffset=.2; \n\n //pseudo random number from float (between 0 and 1)\nfloat hash11(float x){\n    return fract(sin(x*835.24+132.124)*123.1433);\n}\n //pseudo random number from vec2 (between 0 and 1)\nfloat hash21(vec2 x){\n    return fract(sin(x.x*845.24+x.y*554.5243+122.124)*123.143);\n}\n\n //return the co-ordinates of the nearest sphere within the grid\n //used to animate and colour them discretely\nvec2 getID(vec3 p){\n    return vec2(floor((p.x+grid/2.)/grid),floor((p.z+grid/2.)/grid));\n}\n\n //add a random offset to a given point, with a max distance r from the original point.\n //this is used to add noise to the blur, reducing banding\nvec3 rndPt(vec3 c,float r){\n    return c+normalize(vec3(hash11(c.z)-.5,hash11(c.x)-.5,hash11(c.y)-.5))*hash11(r+iTime)*r;\n}\n\n //get distance to world\nfloat map(vec3 p){\n    float planeDist=p.y+1.;//distance to ground plane\n    p+=vel*iTime;//apply camera movement\n    vec2 id=getID(p);//get discrete co-ordinates of current sphere within grid\n    p.y+=sin(id.x+id.y+iTime*waveSpeed)*waveMag;//animate sphere heights with wave\n    p.xz=mod(p.xz+grid/2.,grid)-grid/2.;//mod function creates the infinite grid\n    return min(length(p)-1.,planeDist);//return distance to nearest sphere\n}\n\n //calculate normal vector at given point\nvec3 norm(vec3 p){\n    return normalize(vec3(map(p+e.xyy),map(p+e.yxy),map(p+e.yyx))-map(p));\n}\n\n //calculate the colour at a given point\nvec3 shade(vec3 p,vec3 rd){\n     //vector from light to point\n    vec3 lightVec=p-lp;\n     //again, find discrete co-ordinates of nearest sphere\n    vec2 id = getID(p+vel*iTime);\n     //direction to light source\n    vec3 pld=normalize(lightVec);\n     //calculate normal vector at point\n    vec3 no = norm(p);\n     //multiply light based on squared distance from light source\n    float lMult=10./dot(lightVec,lightVec);\n     //standard diffuse lighting formula\n    float dif=lMult*plb*(exp(max(0.,dot(no,-pld)))-1.);//point light\n    dif+=dlb*(exp(max(0.,dot(no,-ld)))-1.);//directional light\n     //standard specular lighting formula. \n     //hash21(..)... randomizes the specular exponent (shininess) of each sphere\n    float spec=lMult*plb*pow(max(0.,dot(-pld,reflect(rd,no))),hash21(id)*specCoeff+2.);//point light//\n    spec+=dlb*pow(max(0.,dot(-ld,reflect(rd,no))),hash21(id)*specCoeff+2.);//directional light//\n     //albedo (base colour) of closest sphere\n    vec3 al=vec3(smoothstep(.3,.7,hash21(id)))*sphCol;\n     //amount of fog based on distance from camera\n    float fog=clamp(fogStrength*smoothstep(0.,maxd,length(p-cp)),0.,1.);\n     //use all the stuff above to calculate colour\n    return mix((dif*lc+amb)*al+vec3(spec),bg,fog);\n}\n\n//responsible for rendering the visible point light.\nvec3 glow(vec3 f, vec3 rd){\n    float glow;\n    if (dot(f, lp-cp)>0.){//only needed if light is in front of camera\n        vec3 lrd = normalize(lp - cp);//ray direction to point light\n        float mind = 0.04;//this doesnt need to be accurate so we can reduce accuracy for performance\n        maxd = length(cp - lp);//distance doesnt need to go beyond distance to light\n        vec3 p=cp;float td,d=100000.;\n        for(int _=0;_<100&&d>mind&&td<maxd;_++){\n            d=map(p);td+=d;p+=lrd*d;\n        }\n        if (td>maxd){//if nothing was hit between camera and light, light is visible\n            glow = .06 / length(cross(rd, lp - cp));\n        }\n    } else{//light is behind camera, just apply glow based on distance\n        glow = .06 / length(lp - cp);\n    }\n    return glow*lc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n     //set aperture and focal distance based on mouse position\n    aperture = .1 * iMouse.x/iResolution.x;\n\tfocalDist = maxd * iMouse.y/iResolution.y;\n    lp=vec3(sin(iTime*lightSpeed)*lightRad,lightHeight+sin(iTime*lightOscilationSpeed)*lightOscilationMag,cos(iTime*lightSpeed)*lightRad);//aniamte point light\n     //pixel co-ordinates, mapped to range between -.5 and .5, then scaled by the aspect ratio in the x-axis.\n    vec2 uv = fragCoord/iResolution.xy-.5;uv.x*=iResolution.x/iResolution.y;\n     //this section calculates the ray direction of the pixel.\n    vec3 f=normalize(ct-cp);vec3 r=normalize(cross(vec3(0,1,0),f));vec3 u=normalize(cross(f,r));\n    vec3 si=cp+f+uv.x*r+uv.y*u;vec3 rd=normalize(si-cp);\n     //vertical field of view in radians, used to calculate cone radius later\n    float vfov=atan(.5);\n     //randomized\n    float startDist=hash21(uv+iTime)*map(cp);\n     //variables required for the raymarch\n     //i=total raymarch steps,d=current distance,td=total distance\n    float i,d,td=startDist;\n     //p=current point (starts at camera position) with a random offset to reduce colour banding\n    vec3 p=cp+startDist*rd;\n     //accumulated colour over all samples, alpha channel used to store amount of cone that has not yet hit the scene\n    //vec4 acc=vec4(bg,1.);\n    //acc.rgb=vec3(0.);\n    vec4 acc=vec4(0,0,0,1);\n     //radius of the cone based on width of pixel in world space\n    float rad=(2.0*tan(vfov/2.0)) /(iResolution.y);\n     //very small minimum radius to reduce aliasing at focal point\n    float minRad=4./iResolution.x;\n    for (;i<maxI;i++){ //main raymarching loop.\n        d=map(p);\n         //current radius of cone. this function makes it shrink until focal point, then grow again.\n         //max(minRad*td,...) expression prevents perfect focus to prevent aliasing.\n        float cRad=max(minRad*td,rad*td+aperture*abs(td-focalDist));\n         //add to total distance, move point\n         //step multiplier used to dampen step size, more expensive but more accurate blur.\n        td+=d*stepMultiplier;p+=rd*d*stepMultiplier;\n         //if geometry is within cone.\n        if(d<cRad){\n             //naive method of estimating the strength of the current sample .\n            float alpha = smoothstep(cRad, -cRad, d);\n             //get colour at the current position.\n             //This position is offset randomly to trade banding with noise.\n            vec3 sampleCol=shade(rndPt(p,d*sampleOffset),rd);\n             //add the sample to the cumulative colour\n             //acc.rgb=mix(acc.rgb,sampleCol,acc.a*alpha);\n            acc.rgb+=acc.a*alpha*sampleCol;\n             //reduce the remaining alpha, as some of the cone has hit the scene.\n            acc.a*=1.-alpha;\n             //if enough of the cone has hit the scene, break out of the loop.\n            if (acc.a<.001){break;}\n        }\n         //if distance is greater than the threshold distance, break out of the loop early\n        if(td>maxd){break;}//acc.a=1.;\n    }\n     //if alpha is greater than 0, the sample colour is mixed with the initial black. We therefore need \n     //to saturate the colour to remove artifacts caused by this.\n    acc.rgb*=1./max(.001,(1.-acc.a));\n     //blend between object colour and background based on alpha.\n    vec3 col=mix(acc.rgb,bg,acc.a);\n    \n    #ifdef renderPointLight\n        col += glow(f,rd);\n    #endif\n    #ifdef toneMap\n        col=1.-exp(-col);\n    #endif\n     //apply vignette. hash21(...) adds imperceptible to reduce banding.\n    col=mix(col,vc,length(uv)*vignetteStrength+hash21(uv+iTime)*.01);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1644, 1696, 1718, 1718, 1770], [1772, 1823, 1844, 1844, 1910], [1913, 2023, 2042, 2042, 2114], [2117, 2263, 2290, 2290, 2386], [2389, 2413, 2431, 2431, 2846], [2849, 2890, 2908, 2908, 2985], [2988, 3028, 3055, 3089, 4273], [4275, 4328, 4355, 4355, 5117], [5119, 5119, 5173, 5236, 8772]], "test": "valid"}
{"id": "tlyfDt", "name": "smiley shader tutorial", "author": "Tater", "description": "wow", "tags": ["firstshader"], "likes": 1, "viewed": 136, "published": "Public API", "date": "1615328712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//mostly the intro tutorials from \"The Art of Code\"\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n\n    float d = length(uv-p);\n    \n    float c = smoothstep(r, r-blur ,d);\n    return c;\n}\nmat2 Rot(float a){\nfloat s = sin(a);\nfloat c = cos(a);\nreturn mat2(c,-s,s,c);\n\n}\nfloat Smiley(vec2 uv, vec2 p, float size) \n{\n    uv/=size;\n    uv-=p; \n    \n    float mask = Circle(uv, vec2(0.), .4, .01);\n\n    mask -= Circle(uv, vec2(.1, .2), .07, .01);\n    mask -= Circle(uv, vec2(-.1, .2), .07, .01);\n    \n    float mouth = Circle(uv, vec2(0.,-0.1), .1,.01);\n    mouth -= Circle(uv, vec2(0.,0.),.1,.01);\n    mouth = clamp(mouth,0.,1.);\n    \n    mask-=mouth;\n    \n    return mask;\n}\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur,start + blur,t);\n    \n    float step2 = smoothstep(end + blur,end - blur,t);\n    \n    return step1*step2;\n    \n    \n}\nfloat remap01 (float a, float b, float t)\n{\n    return (t-a) / (b-a);\n}\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return remap01(a,b,t) * (d-c) + c;\n}\n\n\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\nfloat Band1 = Band(uv.x, left, right, blur);\nfloat Band2 = Band(uv.y, bottom, top, blur);\n\nreturn Band1*Band2;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=vec2(.5, .5); // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 uvi = uv;\n    \n\n    \n    t = (floor(t) + fract(t)*fract(t))*2.0;\n    \n    \n    uv.y+=sin(t+uv.x*20.)/10.;\n    uv.x+=sin(t+uv.y*20.)/20.;\n    \n    //spiiiiin\n    //uv*=Rot(iTime*2.); \n    \n    uv*=1.3;\n\n    vec3 col = vec3(0.);\n\n    float blur = remap(-1., 1., .01, .1, sin(t));\n    float mask = Rect(uv, -.25, .25, -.3, .3, blur);\n    \n    mask -= 0.5*Smiley(uvi, vec2(0), .5);\n    \n    col = (vec3(.5,0.,1.))*mask;\n\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 103, 103, 193], [194, 194, 212, 212, 274], [275, 275, 319, 319, 677], [678, 678, 735, 735, 895], [896, 896, 939, 939, 967], [968, 968, 1026, 1026, 1067], [1071, 1071, 1154, 1154, 1269], [1272, 1272, 1329, 1329, 1933]], "test": "valid"}
{"id": "tlyfDV", "name": "pow(The Shining, 2.0)", "author": "dean_the_coder", "description": "Another 'Shining' corridor scene, this time playing with a recursive camera path - A first for me, and fun to make!", "tags": ["3d", "raymarching", "recursion", "horror", "movie", "cineshader"], "likes": 33, "viewed": 2420, "published": "Public API", "date": "1615063068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'pow(The Shining, 2.0)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/tlyfDV\n//\n// Another 'Shining' corridor scene, this time playing\n// with a recursive camera path - A first for me, and\n// fun to make!\n//\n// My previous Shining scene here:\n//   https://www.shadertoy.com/view/3stBDf\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 20.0\n#define MAX_STEPS\t\t 64.0\n#define SHADOW_STEPS\t 30.0\n#define MAX_SHADOW_DIST  20.0\n\n#define Z0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n#define S(x) smoothstep(0., 1., x)\n\nfloat g = 0.0, // Glow.\n      bld = 1.0; // Blood.\n\n#define AA    // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d, id;\n\tvec3 uv;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\n#define HASH    p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\nfloat hash11(float p) { HASH }\nvec2 hash22(vec2 p) { HASH }\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 3.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n    // Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) {\n    // Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(hash22(h), hash22(h + s.x), p.x);\n\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdHex(vec2 p, float r) {\n\tp = abs(p);\n\treturn -step(max(dot(p, normalize(vec2(1, 1.73))), p.x), r);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat deco(vec2 p) {\n    p.xy = fract(p.xy * rot(-2.36) * 1.5);\n    return step(0.5, fract(min(p.x, p.y) * 4.0));\n}\n\nvoid splat(vec2 p, out float i, out float o) {\n\ti = max(0., -sign(sdHex(p, 1.)));\n\to = max(0., sign(sdHex(p, 2.)) - sign(sdHex(p, 3.)));\n}\n\n// Carpet texture.\nvec3 carpet(vec2 p) {\n\tp.x = mod(p.x, 7.) - 3.5;\n\tp.y = mod(p.y, 10.) - 10.;\n\n\tfloat i, o, i2, o2,\n\tc = (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y)));\n\n\tp.x = abs(p.x) - 3.5;\n\n\tc += (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y + 2.)));\n\n\tvec2 op = p;\n\n\tp.y = abs(p.y + 5.) - 5.;\n\tsplat(p, i2, o2);\n\n\top.x = mod(p.x, 7.) - 3.5;\n\top.y += 3.8;\n\tsplat(op, i, o);\n\n\ti = sign(i + i2);\n\to = sign(o + o2) * (1. - c);\n\n\treturn vec3(1, .01, .01) * i +\n\t\t   vec3(1, .1, .01) * o +\n\t\t   vec3(.05, .01, .01) * (1. - i - o);\n}\n\n#define GROUND_ID  1.\n#define WALL_ID    2.\n#define CANVAS_ID  3.\n#define FRAME_ID   4.\n#define LIGHT_ID   5.\n#define WOOD_ID    6.\n\n#define FRAME_P    vec3(2.5, 2.7, -0.12)\n#define RO         vec3(-7, 2.4, -3)\n#define LA         vec3(10, 2.4, -3)\n#define LIGHTP     vec3(3.4, 3.5, -2.6)\n\nHit map(vec3 p) {\n\tHit h = Hit(abs(p.y), GROUND_ID, p);\n    \n    float d = length(p - LIGHTP - vec3(0,1.5,0)) - 0.4;\n    minH(h, Hit(d, LIGHT_ID, p));\n    g += 0.002 / (0.001 + d * d);\n    \n    // Wallz.\n    d = min(sdBox(p - vec3(0,2.2,0), vec3(5, 3, 0.1)), -sdBox(p - vec3(0,2.4,0) - vec3(0,0,4), vec3(10, 2.5, 9.5)));\n    minH(h, Hit(min(d, max(abs(p.x) - 0.15, -sdBox(p + vec3(0,0,2.8), vec3(1, 4.5, 2.6)))), WALL_ID, p));\n\n    // Skirting.\n    d = min(sdBox(p - vec3(0, 0, 0), vec3(5, .38, 0.15)), sdBox(p - vec3(0, 0, -5.6), vec3(10, .38, 0.15)));\n    d = min(d, min(d, sdBox(p - vec3(10, 0, -5.6), vec3(.15, .38, 9))));\n    vec3 mp = p; mp.z = abs(mp.z + 2.8) - 2.65;\n    minH(h, Hit(min(d, sdBox(mp, vec3(.2, .38, .1))), WOOD_ID, p));\n\n    // Picture frame.\n    p -= FRAME_P;\n    vec3 cs = vec3(0.885, 0.5, 0.01);\n    minH(h, Hit(sdBox(p, cs), CANVAS_ID, p));\n    minH(h, Hit(max(sdBox(p, cs + 0.1), -sdBox(p, cs + vec3(0,0,1))), FRAME_ID, p));\n\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * 0.4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = Z0; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\n/**********************************************************************************/\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n    float s = 0.0, gg = g;\n\tvec3 ld = normalize(LIGHTP - p), n = N(p, d), c = vec3(0);\n         \n    if (h.id == WALL_ID) {\n        n = normalize(n + n31(h.uv * vec3(3.7, 1.7, 2.7)) * 0.08);\n        if (p.x < 9.99)\n            c = vec3(0.4);\n        else {\n            s = deco(p.zy);\n            c = (0.1 + 0.2 * s) * vec3(0.05, 0.15, 0.1);\n        }\n    } else if (h.id == GROUND_ID)\n        c = carpet(h.uv.zx * 3.5) * ((n21(p.xz * 85.0) - 0.5) * 0.4 + 0.6);\n    else if (h.id == FRAME_ID)\n        c = vec3(0.01);\n    else if (h.id == WOOD_ID)\n        c = 0.02 * mix(vec3(1.7, 1, .5), vec3(.8, .5, .3), vec3(hash11(hash31(p.yxz * vec3(0, 1, 30)))));\n    \n    if (bld > 0.0)\n        c = mix(vec3(.3,0,0), vec3(dot(c, vec3(.2, .72, .08))), sat((p.y * .5 + .5) * n31(p) / (0.1 + n31(p * vec3(9, 2, 9)))));\n\n\t// Primary light.\n\tfloat l1 = sat(.1 + .9 * dot(ld, n))\n               * (0.6 + 0.4 * shadow(p, ld)),\n\n\t// Secondary(/bounce) light.\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3\n\n    // Specular.\n\t     + pow(sat(dot(rd, reflect(ld, n))), 10.0 + s * 10.0) * (0.6 + s),\n\n\t// Combine into final color.\n\tlig = l1 + l2 * mix(ao(p, n, .2), ao(p, n, 0.5), .3);\n    g = gg;\n\treturn lig * c * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 p, vec3 rd) {\n\tfloat d = .0;\n    vec3 ro = p;\n    g = 0.0;\n\tHit h;\n\tfor (float i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST) {\n            if (h.id != CANVAS_ID) break;\n            bld = 1.0 - bld; // Toggle the blood.\n            p = RO;\n            g = d = 0.0;\n            rd = rayDir(RO, LA, h.uv.xy);\n            continue;\n        }\n\n        d += h.d;\n        if (d > MAX_DIST)\n            return vec3(0);\n\n        p += h.d * rd; // No hit, so keep marching.\n\t}\n\n\treturn g + lights(p, rd, d, h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\t// Camera.\n    float t = fract(iTime * 0.2);\n    bld = floor(mod(iTime / 5.0, 2.0));\n\tvec3 ro = mix(RO, vec3(FRAME_P.x, RO.yz), t);\n    \n    t *= .88056;\n    vec3 fp = FRAME_P + vec3(0, .1, 0);\n    vec3 lookAt = mix(LA, fp + vec3(0, -.1, 0.1), S(t * 1.5));\n\n    ro = mix(ro, fp, smoothstep(0.7, 1.0, t));\n\n    vec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = march(ro, rayDir(ro, lookAt, uv));\n\n#ifdef AA\n    if (fwidth(col.r) > 0.1) {\n        for (float dx = Z0; dx <= 1.; dx++)\n            for (float dy = Z0; dy <= 1.; dy++)\n                col += march(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - 0.5) / iResolution.xy));\n        col /= 5.;\n    }\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vig(pow(max(vec3(0), col) * sat(iTime), vec3(.45)), fc), 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[909, 1052, 1075, 1075, 1082], [1083, 1083, 1104, 1104, 1111], [1113, 1113, 1136, 1136, 1240], [1242, 1242, 1263, 1263, 1270], [1272, 1272, 1291, 1351, 1604], [1606, 1606, 1625, 1685, 1889], [1891, 1891, 1922, 1922, 1947], [1949, 1949, 1968, 1968, 2028], [2030, 2030, 2060, 2060, 2137], [2139, 2139, 2168, 2168, 2255], [2257, 2257, 2301, 2301, 2434], [2436, 2436, 2456, 2456, 2551], [2553, 2553, 2599, 2599, 2691], [2693, 2712, 2733, 2733, 3238], [3529, 3529, 3546, 3546, 4495], [4497, 4497, 4522, 4522, 4742], [4744, 4744, 4775, 4790, 4995], [4997, 5025, 5060, 5060, 5091], [5093, 5179, 5206, 5206, 5321], [5323, 5323, 5369, 5369, 6592], [6594, 6594, 6623, 6623, 7138], [7140, 7140, 7185, 7197, 7968]], "test": "valid"}
{"id": "tlyfzt", "name": "yonatan fractal", "author": "drayde", "description": "\"un-obfuscated\" version of https://twitter.com/zozuar/status/1367243732764876800", "tags": ["fractal"], "likes": 20, "viewed": 474, "published": "Public API", "date": "1614864051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"un-obfuscated\" version of \n// https://twitter.com/zozuar/status/1367243732764876800\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    o = vec4(0.);\n    vec2 r = iResolution.xy;\n    float g = 0.;\n    float k = iTime * .1; \n    for (float i = 0.; i < 99.; ++i)\n    {\n        vec3 p = vec3 (g * (fragCoord.xy - .5 * r) / r.y + .5, g - 1.);\n        p.xz *= rotate2D (k);\n        float s = 3.;\n        // fractal levels\n        for (int i=0; i < 9;i++)\n        {\n            float e = max (1., (8. - 8. * cos (k)) / dot (p, p));\n            s *= e;\n            p = vec3 (2, 4, 2) - abs (abs (p) * e - vec3 (4, 4, 2));\n        }\n        g += min (length (p.xz), p.y) / s;\n        s = log (s);\n        o.rgb += hsv (s / 15. + .5, .3, s / 1000.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyfzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 112, 112, 164], [165, 165, 201, 201, 380], [382, 382, 431, 431, 1048]], "test": "valid"}
{"id": "tsVyD1", "name": "soft_kifs", "author": "snolot", "description": "Experiment on kifs using someone code but don't remember where i borrowed it so if someone recognise his code don't hesitate to tell me i will add credits. ;)", "tags": ["raymarching"], "likes": 2, "viewed": 63, "published": "Public", "date": "1614886125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\nvec4 invertRadius(vec4 z, float radius2, float limit) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = clamp(radius2 / r2, 1., limit);\n  return z * f;\n}\n\nvec4 affine(vec4 z, float factor, vec3 offset) {\n  z.xyz *= factor;\n  z.xyz += offset;\n  z.w *= abs(factor);\n  return z;\n}\n\nvec4 mandel(vec4 z, vec3 offset) {\n  float x = z.x;\n  float y = z.y;\n\n  z.w = 2. * length(z.xy) * z.w + 1.;\n\n  z.x = x*x - y*y + offset.x;\n  z.y = 2.*x*y + offset.y;\n\n  return z;\n}\n\nvec4 invert(vec4 z, float factor) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = factor / r2;\n  return z * f;\n}\n\nvec4 rotateXY(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  return vec4(m * z.xy, z.zw);\n}\n\nvec4 rotateXZ(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  vec2 r = m * z.xz;\n  return vec4(r.x, z.y, r.y, z.w);\n}\n\nvec4 shiftXY(vec4 z, float angle, float radius) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return vec4(vec2(c, s) * radius + z.xy, z.zw);\n}\n\nfloat surface = 0.0;\nfloat sdf(vec3 p) {\n    //vec3 pmod = mod(p + 2.0, 4.0) - 2.0;\n    vec4 z = vec4(p, 1.0);\n    \n    float t = iTime * .2;\n\t\n    /*vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * 1.1;\n    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * 1.1;\n    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * 1.1;\n    */\n    z = invertRadius(z, 10.0, 1.5);\n    z = invertRadius(z, 10.0*10.0, 20.0);\n    z = rotateXZ(z, t * 1.783);\n    z = invertRadius(z, 4.0*4.0, 2.0);\n    z = mix(z, vec4(p, 1.0), .25);\n    z = rotateXY(z, t * 1.981);\n     z = fold1(z);    z = invertRadius(z, 4.0*4.0, 2.0);\n    z = mix(z, vec4(p, 1.0), .25);\n     /*z = rotateXY(z, t * .781);\n    z = fold1(z);    z = rotateXZ(z, t * .783);\n    z = fold1(z);*/\n   // z = shiftXY(z, .85, .8);\n    z = mix(z, vec4(p, 1.0), .25);\n    z = invertRadius(z, 10.0*10.0, 3.0);\n    z = fold1(z);\n    z = fold1(z);\n    z = mix(z, vec4(p, 1.0), .25);\n    z = invertRadius(z, 10.0*10.0, 2.0);\n\n    vec3 po = vec3(0.0, 0.0, 0.0);\n\n    vec3 box = abs(z.xyz);\n    \n    float d1 = (max(box.x - 2.0, max(box.y - 2.0, box.z - 10.0))) / z.w;\n    float d2 = (max(box.x - 10.0, max(box.y - .5, box.z - .5))) / z.w;\n\t\n    float d3 = min(d1, d2);\n    if (d2 == d3) {\n      surface = 1.0;\n    }\n    else {\n      surface = 0.0;\n    }\n    return d3*.8;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0001, 0.0);\n    float f = sdf(p);\n    return normalize(vec3(\n        sdf(p + e.xyy) - f,\n        sdf(p + e.yxy) - f,\n        sdf(p + e.yyx) - f\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec3 color = vec3(.03, .02, .02) * (1.5 - uv.y);\n\n    vec3 light = vec3(.577);\n    float angle = 1.0-iMouse.x * .005;   \n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 camera = mat3(\n        c,  0.0, -s,\n         0.0,  1.0, 0.0,\n        s,  0.0, c//,\n\t);\n    float fov = .5;\n\n    vec3 rd = camera * normalize(vec3(xy * fov,-1.0));\n    vec3 ro = vec3(s,0.0,c)*30.0;\n    \n    float tmax = 100.0;\n    float dmin = .001;\n    float t = 0.0;\n    float d = sdf(ro);\n    if (d < 0.0) rd = -rd;\n    for (int i = 0; i < 96; ++i) {\n        vec3 p = ro + rd * t;\n        d = sdf(p);\n        t += d;\n        if (t > tmax || d < dmin) break;\n    }\n\n    vec3 p = ro + rd * t;\n    vec3 n = normal(p);\n    if (t < tmax && d < dmin) {\n      vec3 albedo = mix(vec3(.7, .0, 0.), vec3(1.0, .5, 0.0), surface);\n  \t  float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      \n      float ao = 0.0;\n      float am = 0.0;\n      float step = .05;\n      vec3 pa = p;\n      for (int i = 0; i < 8; ++i) {\n          pa += n * step;\n          am += step;\n          ao += max(0.0, sdf(pa) / am);\n          step += .05;\n      }\n      \n      t = .1;\n      float shadow = 1.0;\n      if (diffuse > 0.0) {\n        for (int i = 0; i < 24; ++i) {\n          vec3 pb = p + light * t;\n          d = sdf(pb);\n          t += d;\n          if (d < 0.0) break;\n        }\n        \n        shadow = clamp(d, 0.0, 1.0);\n        diffuse *= shadow;\n      }\n        \n      ao = (.2 + .8 * ao / 8.0);\n      float ambient = 0.08;\n\n      vec3 sun = vec3(1.0, 1.0, .85);\n      vec3 sky = vec3(1.0, .5, .5);\n      color = 6.0 * vec3(mix(sun * diffuse, sky, ambient) * ao * ao * albedo * 5.0);\n      color = color/(1.0+color);\n    }\n    \n\tfragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 106], [108, 108, 128, 128, 226], [228, 228, 283, 283, 377], [379, 379, 427, 427, 501], [503, 503, 537, 537, 683], [685, 685, 720, 720, 795], [797, 797, 833, 833, 944], [946, 946, 982, 982, 1118], [1120, 1120, 1169, 1169, 1268], [1291, 1291, 1310, 1353, 2615], [2617, 2617, 2638, 2638, 2808], [2810, 2810, 2867, 2867, 4716]], "test": "valid"}
{"id": "ttdBDN", "name": "Boze Star", "author": "kaiware007", "description": "Boze Star", "tags": ["raymarching"], "likes": 3, "viewed": 42, "published": "Public", "date": "1617019241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n#define M_PI 3.1415926\n#define M_PI2 6.2831852\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define RAD90 (M_PI * 0.5)\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    int count;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \t0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \t0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \t0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \t0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \t0, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat easeInOutCubic(float x) {\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Basic Distance function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nsurface opS( surface d1, surface d2 )\n{\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    return surface(d, albedo, d1.count, true);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n    head.albedo = vec4(sinebow(iTime) + 0.5,1);\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n    \n    float ms = abs(sin(iTime * 2.5) * 5.);\n\n    p.y -= abs(sin(iTime*M_PI))*0.1;\n    \n    float r = easeInOutCubic(fract(iTime*1.0))*M_PI2;\n    p = rotate(p, r, vec3(0,1,0));\n    \n    p.xy = foldRotate(p.xy, 5.);\n\n    // boze\n    surface boze = sdBoze(p, vec3(0.5, 1. + sin(p.y * 20. + iTime * 5.)*0.05, 0.25), ms);\n    \n    result = opU(result, boze);\n    \n    return result;\n}\n\nvec3 norm(in vec3 position) {\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n\n        t += d;\n        pos = origin + direction * t;\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n        \n    if(hit.isHit)\n    {\n        // Lighting\n        vec3 normal = norm(pos);\n\n        //vec3 lightDir = normalize(vec3(cos(iTime), 1, sin(iTime)));\n        vec3 lightDir = normalize(vec3(0,0.5,1));\n\t\tvec3 lightColor = vec3(1.5);\n        \n        float NoL = saturate(dot(normal, lightDir));\n        \n        vec3 ambientColor = vec3(0.5);\n        \n        hit.albedo.rgb *= NoL * lightColor +  ambientColor;\n    }\n    \n    if(d <= EPS){\n        hit.isHit = true;\n        return hit;\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n    }\n}\n    \nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = vec3(0.);\n    \n    col = mat.isHit ? mat.albedo.rgb : sky;\n    \n    return col;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0.05, 0.5);\n    vec3 ta = vec3(0, 0.05, 0);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 962, 985, 985, 1058], [1060, 1060, 1091, 1091, 1164], [1166, 1389, 1435, 1435, 1491], [1493, 1493, 1543, 1543, 1661], [1663, 1663, 1700, 1700, 1789], [1791, 1791, 1861, 1861, 1995], [1997, 1997, 2061, 2061, 2178], [2180, 2180, 2225, 2225, 2654], [2656, 2656, 2681, 2681, 2747], [2749, 2790, 2830, 2830, 2958], [2960, 3017, 3054, 3054, 3137], [3139, 3139, 3172, 3172, 3194], [3196, 3196, 3235, 3235, 3344], [3346, 3346, 3395, 3395, 3616], [3618, 3618, 3661, 3661, 3761], [3765, 3993, 4014, 4014, 4153], [4179, 4179, 4211, 4211, 4324], [4326, 4326, 4358, 4358, 4498], [4500, 4500, 4533, 4533, 4662], [4664, 4664, 4687, 4687, 5258], [5260, 5260, 5285, 5285, 5446], [5448, 5448, 5491, 5491, 6549], [6550, 6768, 6789, 6789, 7208], [7210, 7210, 7239, 7284, 7476], [7478, 7478, 7557, 7557, 8539], [8545, 8545, 8585, 8585, 8779], [8781, 8781, 8823, 8823, 9001], [9004, 9004, 9061, 9061, 9385]], "test": "valid"}
{"id": "ttdfR2", "name": "Checker Board 1", "author": "elindie", "description": "Set out to create a checker. The checkers here are not of a consistent width/height.", "tags": ["checker2d"], "likes": 1, "viewed": 29, "published": "Public", "date": "1615356994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frequency = 0.05;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float c1 = round(abs(sin(fragCoord.x * frequency)) - 0.25);\n    float c2 = round(abs(sin((fragCoord.y  + (c1 * 100.0 * sin(iTime))) * frequency))-0.25);\n    \n    vec3 col1 = vec3(c2, sin(uv.x + iTime),cos(uv.y + iTime));\n\n    // Output to screen\n    fragColor = vec4(col1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdfR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 461]], "test": "valid"}
{"id": "ttGBDd", "name": "sinusoidal color chase", "author": "alalalat", "description": "proof of concept code to generate noise with noise offset. depth --> iTime", "tags": ["perlin"], "likes": 1, "viewed": 53, "published": "Public", "date": "1615407147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez + Copyright © 2021 Andrew F\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat noise4( vec2 uv )\n{\n    float f = 0.5;\n    float frequency = 1.75;\n    float amplitude = 0.5;\n    for(int i = 0; i <3; i++){\n        f += amplitude*noise( uv*frequency );\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return f;\n\n}\nfloat maximum(vec3 p)\n{\n    float max = p.x;\n    if (p.y > max)\n    max = p.y;\n    if (p.z > max)\n    max = p.z;\n    return max;\n    \n    \n}\nfloat minimum(vec3 p)\n{\n    float min = p.x;\n    if (p.y < min)\n    min = p.y;\n    if (p.z < min)\n    min = p.z;\n    return min;\n    \n    \n}\nvec3 normalize (vec3 grosscolor)\n{\n    grosscolor = (grosscolor*grosscolor);\n    float max = maximum(grosscolor);\n    float min = minimum(grosscolor);\n    return (grosscolor.xyz/(max+min*0.5));\n\n}\n\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,0.8);\n    \n    //uv -= 2.0*vec2(iResolution.x/2.0, iResolution.y/2.0);\n    vec2 roto = vec2(0.4+0.5*cos(iTime/10.0),0.4+0.5*sin(iTime/10.0));\n    \n    float interval = 10.0;\n    vec3 dblue = vec3(roto.x,roto.y,roto.y)+vec3(0, 0.2,0.8);\n    vec3 cyan = vec3(roto.x,roto.y,roto.x)+vec3(0.2, 1, 0);\n    vec3 magenta = vec3(roto.x,roto.x,roto.x)+vec3(0.4,0,0.8);\n   \n    \n    \n\t\n    float f = 1.0\t;\n    \n    vec3 color = vec3(0.2,0.1,0.2);   \n\tf = noise4( f*uv + noise4(uv)*((log(iTime+1.0))) );\n    color += f*normalize(dblue);\n    \n    f = noise4( f*uv + f*noise4(uv)*(sqrt(iTime+1.0)));\n    color += f*normalize(cyan);\n    \n    f = noise4( f*uv + f*noise4(uv)*(sqrt(iTime+1.0)));\n    color += f*normalize(magenta);\n    \n    color = normalize(color);\n    \n    \n  \n    \n \n\n\t\n\t\n   \t\n\t\n\tfragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBDd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1319, 2051, 2108, 2108, 2223], [2225, 2225, 2251, 2251, 2730], [2732, 2732, 2757, 2757, 2983], [2984, 2984, 3007, 3007, 3124], [3125, 3125, 3148, 3148, 3265], [3266, 3266, 3300, 3300, 3462], [3465, 3517, 3574, 3574, 4478]], "test": "valid"}
{"id": "ttGBRd", "name": "#Mars2020", "author": "kithy", "description": "Ground of Mars made from noise.", "tags": ["raymarching", "noise", "random", "plane"], "likes": 2, "viewed": 73, "published": "Public", "date": "1614864209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPS 1e-4\n\nfloat random(in vec2 st){\n\treturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(in vec2 st){\n\tvec2 i=floor(st);\n\tvec2 f=fract(st);\n\tfloat a=random(i);\n\tfloat b=random(i+vec2(1.0,0.0));\n\tfloat c=random(i+vec2(0.0,1.0));\n\tfloat d=random(i+vec2(1.0,1.0));\n\tvec2 u=f*f*(3.0-2.0*f);\n\treturn mix(a,b,u.x)+\n\t(c-a)*u.y*(1.0-u.x)+\n\t(d-b)*u.x*u.y;\n}\n\n#define OCTAVES 6\n\nfloat fbm(in vec2 st){\n\tfloat value=0.0;\n\tfloat amplitude=0.5;\n\tfloat frequency=0.0;\n\tfor(int i=0;i<OCTAVES;i++){\n\t\tvalue+=amplitude*noise(st);\n\t\tst*=2.0;\n\t\tamplitude*=0.5;\n\t}\n\treturn value;\n}\n\n// float ground(vec3 p){\n// \treturn dot(p,vec3(0.0,1.0,0.0))+1.0;//basic plane\n// \t//return dot(p,normalize(vec3(0.0,1.0,0.0)))-sin(p.x*1.5+iTime)+1.0;//waving plane\n// }\n\nfloat ground(vec3 p){\n\tfloat d=p.y+fbm(p.xz)+12.0*noise(p.xz*0.08-vec2(0.0,0.1));\n\treturn d;\n}\n\nfloat map(vec3 p){\n\tfloat g=ground(p);\n\treturn abs(g);\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmap(p+vec3(EPS,0.0,0.0))-map(p+vec3(-EPS,0.0,0.0)),\n\t\tmap(p+vec3(0.0,EPS,0.0))-map(p+vec3(0.0,-EPS,0.0)),\n\t\tmap(p+vec3(0.0,0.0,EPS))-map(p+vec3(0.0,0.0,-EPS))\n\t\t));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,0.0-iTime*7.0);\n\tvec3 rd=normalize(vec3(uv,-1.0));\n\tfloat d,t=0.0;\n\tvec3 rp;\n\n\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\trp=ro+rd*t;\n\t\td=map(rp);\n\t\tif(d<EPS)break;\n\t\tt+=d;\n\t}\n\n\t// vec3 n=genNormal(rp);\n\t// fragColor=vec4(n,1.0);\n\n\tvec3 col=vec3(exp(-0.4*d));\n\n\n\tfragColor=vec4(col.x*0.9,col.y*0.3,col.z*0.1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 64, 64, 133], [135, 135, 159, 159, 406], [427, 427, 449, 449, 619], [621, 793, 814, 814, 887], [889, 889, 907, 907, 945], [947, 947, 970, 970, 1163], [1165, 1165, 1218, 1218, 1606]], "test": "valid"}
{"id": "ttGfDG", "name": "yet another mandelbrot shader", "author": "arnestenkrona", "description": "A very simple mandelbrot implementation", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 54, "published": "Public", "date": "1614956022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 palette[ 8 ] = vec3[8](   vec3( 0.0, 0.0, 0.0 ),\n                                vec3( 0.5, 0.5, 0.5 ),\n                                vec3( 1.0, 0.5, 0.5 ),\n                                vec3( 0.5, 1.0, 0.5 ),\n                                vec3( 0.5, 0.5, 1.0 ),\n                                vec3( 0.5, 1.0, 1.0 ),\n                                vec3( 1.0, 0.5, 1.0 ),\n                                vec3( 1.0, 1.0, 0.5 ) );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float depth = 16.0;\n    float scale = 1.5 / pow(2.0,depth*abs(sin(iTime/depth)));\n    vec2 offset = vec2(-1.5,0.0);\n\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    float re0 = scale * 2.0 * (2.0 * (fragCoord.x /iResolution.x) - 1.0) + offset.x;\n    float im0 = scale * 2.0 * (1.0/aspectRatio) * (2.0 * (fragCoord.y /iResolution.y) - 1.0) + offset.y;\n\n\n    bool diverged = false;\n    float re = re0;\n    float im = im0;\n    int i;\n    for (i = 0; i < 200; ++i) {\n        if (re*re + im*im > 2000.0*2000.0) {\n            diverged = true;\n            break;\n        } \n        float retemp = re*re - im*im + re0;\n        im = 2.0*re*im + im0;\n        re = retemp;\n\n    }\n\n    vec3 col;\n\n    if (diverged) {\n        int nPalette = 8;\n\n        float gradScale = 1.0;\n        float smoothed = log2(log2(re*re+im*im) / 2.0);\n        float fColorIndex = (sqrt(float(i) + 10.0 - smoothed) * gradScale);\n\n        float colorLerp = fract(fColorIndex);\n        colorLerp = colorLerp*colorLerp*(3.0-2.0*colorLerp);\n        int colorIndexA = int(fColorIndex) % nPalette;\n        int colorIndexB = (colorIndexA + 1) % nPalette;\n\n        col = mix(palette[colorIndexA], palette[colorIndexB], colorLerp);\n    } else {\n        col = vec3(0,0,0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 506, 556, 1905]], "test": "valid"}
{"id": "ttGfRt", "name": "Parabola Segment - No Trig", "author": "edubart", "description": "This is an alternative version to https://www.shadertoy.com/view/3lSczz without trigonometric functions.\n", "tags": ["2d", "sdf", "distance", "parabola"], "likes": 2, "viewed": 56, "published": "Public", "date": "1614855343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Reference: http://iquilezles.org/www/articles/trisect/trisect.htm\nfloat trisect(float x) {\n\tx = sqrt(0.5+0.5*x);\n    return x*(-0.064916*x+0.564916)+0.5;\n}\n\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    \n    float h = q*q - p*p*p;\n\n    float x;\n    if (h>0.0) { // 1 root\n        float r = sqrt(abs(h));\n        float qr = q-r;\n        x = pow(q+r,1.0/3.0) + pow(abs(qr),1.0/3.0)*sign(qr);\n    } else { // 3 roots\n        float rp = 1.0/p;\n        x = 2.0*trisect(q*rp*sqrt(rp))*sqrt(p);\n        //x = 2.0*cos(acos(q*rp*sqrt(rp))/3.0)*sqrt(p);\n    }\n    \n    x = min(x,wi);\n    \n    return length(pos-vec2(x,he-x*x/ik)) * \n           sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // animate\n    float t = iTime/2.0;\n    \n\tfloat w = 0.7+0.69*sin(iTime*0.61+0.0);\n    float h = 0.4+0.35*sin(iTime*0.53+2.0);\n    \n    // sdf\n    float d = sdParabola( p, w, h );\n    \n    float ra = 0.2*(0.5+0.5*cos(1.4*iTime));\n    d = (cos(0.5*iTime)>0.0) ? abs(d) - ra : d;\n    \n    \n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    // width and height\n    d = length(p-vec2(0.0,h))-0.02;\n    d = min(d, length(p-vec2(w,0.0))-0.02);\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0,0.01,d) );\n    \n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGfRt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1147, 1171, 1171, 1236], [1238, 1238, 1297, 1297, 1889], [1891, 1891, 1946, 1946, 2718]], "test": "valid"}
{"id": "ttKBD3", "name": "kifs 2d _6 (for fullscreen)", "author": "sus1357", "description": "well, dunno wtf is that formula, but wow\n\ncan turn on/off effects (colors, 'stroboscope')\n\nthe clearest variant - everything is off", "tags": ["fractal", "ifs"], "likes": 2, "viewed": 38, "published": "Public", "date": "1615224172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 DOMAIN_XY = vec2(16., 9.);   // RAZMER OBLASTI\nfloat speed = 6.;                // skorost' metamorfoz (???)\nbool strobo_on = false;\nbool fancy_colors_on = false;\n                                // KIFS-konstanti\nconst int N = 3;               // N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 3;    // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 8;       // WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n                         //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n                     //      funksii      kogda tut dve leviye (lol) kosiye cherti, ploho))\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n        //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n   //1d gauss, ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n  //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n\n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n// -------- initialization ----------\n    float scale = 2.;\n    \n        vec2 symm[N];                                //symm[0] = a2v(60.); symm[1] = a2v(-60.);\n    \n    symm[0] = a2v(0.);           //a2v(60. + iTime*speed); //symm[0] = a2v(-60. + iMouse.x); symm[1] = a2v(60. + iMouse.y);\n    symm[1] = a2v(45.); //a2v(-60.);\n    symm[2] = a2v(135.);\n    \n        float rot[N];\n    \n    rot[0] = 0.;\n    rot[1] = 90.+iTime; // in mandelbulber alpha (Rotate_Z) = 90.\n    rot[2] = 0.; // 0 or 90 ???\n    \n        mat2 rot_matr[N];\n    \n    rot_matr[1][0][0] = cos(radians(rot[1])); rot_matr[1][0][1] = -sin(radians(rot[1]));\n    rot_matr[1][1][0] = sin(radians(rot[1])); rot_matr[1][1][1] = cos(radians(rot[1]));\n    \n        bool mirror[N];\n        \n    mirror[0] =\n    mirror[1] = false;\n    mirror[2] = true; // in mandelbulber gamma (Rotate_(X or Y)) = 180.\n    \n    \n    vec2 offset = vec2(.0,.0);                //vec2 offset = vec2(-1.+2.*iMouse.x/iResolution.x, -1.+2.*iMouse.y/iResolution.y);\n        \n        float dist[N];\n    \n    dist[0] = -1.;\n    dist[1] = -1.;\n    dist[2] = -1.;\n    \n    \n// --------  algorithm  ------------- \n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            // rotate and mirror-rotate\n            if ( rot[n] != 0.0 ) {\n                uv = rot_matr[n] * uv;\n            }\n        \n          // symm vecs \n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n]; //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n        }\n        \n        // scaling\n        uv*=scale;\n        uv -= (scale - 1.) * offset;\n        \n        if(strobo_on) { // stroboscope\n            if(float(i) > mod(30.*iTime, float(ITER))) break; \n        }\n    }\n  // --------------------------------\n // Output to screen\n \n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue);\n    vec3 col_g = gauss(uv, .1)*white;\n   \n\n\n    //vec2 norm = fragCoord/iResolution.xy;\n    //vec3 col_ex = 0.5 + 0.5*cos(2.35+norm.xyx+vec3(0,2,4));\n    //col_ex *= step( max( mod(uv.x, mod_const), mod(uv.y, mod_const) ), 0.9*mod_const );\n    \n    \n    \n    \n\n    \n     // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n   \n    vec3 result = col_g + // mertsaniye\n                  + koltso + \n                  + koltso2\n                  ;\n    if(fancy_colors_on) {\n        float mod_const = pow(scale, float(ITER)); // eta konstanta delaet tolschinu\n                                                  // polos, kotoraya ZAVISIT ot ITER, POSTOYANNOY\n        float w = 0.05 * mod_const; // tolschina polosok napravlennikh vdol' osey\n    \n        vec3 x_positive = float(int((uv.x>0.0)&&(uv.y<w)&&(uv.y>-w)))*red; // osi\n        vec3 x_negative = float(int((uv.x<0.0)&&(uv.y<w)&&(uv.y>-w)))*0.2*red; \n        vec3 y_positive = float(int((uv.y>0.0)&&(uv.x<w)&&(uv.x>-w)))*(red+green);\n        vec3 y_negative = float(int((uv.y<0.0)&&(uv.x<w)&&(uv.x>-w)))*0.2*(red+green);\n        vec3 osi = x_positive + x_negative + y_positive + y_negative;\n\n        vec2 xy_examp = fragCoord/iResolution.xy;\n        vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n        \n        result += .5*(-osi*col_examp + osi + col_examp); //poloski + tsvetovoye resheniye\n    }\n    fragColor = vec4(result ,1.0);                             \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[640, 711, 747, 747, 790], [799, 834, 877, 877, 916], [920, 991, 1012, 1012, 1059], [1062, 1095, 1152, 1221, 4946]], "test": "valid"}
{"id": "ttKBDy", "name": "gg-404 2: True Form of Boombox!", "author": "404Glaciergargamel", "description": "Sequel to GG-404, a fork/parody of [url]https://www.shadertoy.com/view/wsGczG[/url]", "tags": ["3d", "raymarching", "remix", "glitch", "robot", "fork", "experimental", "movie", "avantgarde", "avantgarde", "parody", "cineshader", "robocop", "sequel"], "likes": 0, "viewed": 1858, "published": "Public API", "date": "1615006760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//404GlaciergargamelRemix\n#define MIN_DIST      0.0005\n#define MAX_DIST      54.0\n#define MAX_STEPS     20.0\n#define SHADOW_STEPS  20.0\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow;\n#define AA 0.5\nstruct MarchData {\n    float d;\n    vec3 mat;        //RGB\n    float specPower; //30.0: Shiny\n};\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n    return mix(out1, out2, clamp((f - in1) / (in2 - in1), -0.1, 0.9));\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, -0.1)) + min(max(q.x, max(q.y, q.z)), -0.1);\n}\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n    float cube = sdBox(p, r);\n    p.xz *= rot(2.141 / 3.0);\n    r.xz *= -c / 0.41 + 0.41;\n    return max(cube, sdBox(p, r));\n}\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.766025 + p.y * 0.4, -p.y) - h.x * 0.4);\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba  = rb-ra,\n     baba = dot(b-a,b-a),\n     papa = dot(p-a,p-a),\n     paba = dot(p-a,b-a)/baba,\n     x = sqrt( papa - paba*paba*baba ),\n     cax = max(-0.1,x-((paba<0.4)?ra:rb)),\n     cay = abs(paba-0.4)-0.4,\n     k = rba*rba + baba,\n     f = clamp( (rba * (x - ra) + paba * baba) / k, -0.1, 0.9 ),\n     cbx = x - ra - f * rba,\n     cby = paba - f,\n     s = (cbx < -0.1 && cay < -0.1) ? -0.9 : 0.9;\n    return s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );\n}\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), -0.1) + length(max(d, -0.1));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), -0.1, 0.9);\n  return length(pa - ba * h) - r;\n}\nfloat sdOctogon(vec2 p, float r)\n{\n    const vec3 k = vec3(-0.8238795325, 0.2826834323, 0.3142135623);\n    p = abs(p);\n    p -= 1.0 * min(dot(vec2( k.x, k.y), p), -0.1) * vec2( k.x, k.y);\n    p -= 1.0 * min(dot(vec2(-k.x, k.y), p), -0.1) * vec2(-k.x, k.y);\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(-0.1, 0.9, -0.1), forward)),\n         up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\nMarchData minResult(MarchData a, MarchData b) {\n    if (a.d < b.d) return a;\n    return b;\n}\nvoid setBodyMaterial(inout MarchData mat) {\n    mat.mat = vec3(0.26, 0.35, 0.4);\n    mat.specPower = 20.0;\n}\nfloat legWalkAngle(float f) { return sin(edWalk * 2.141 * 5.0 * f) * 0.1; }\nfloat edZ() { return mix(4.0, -1.0, edWalk); }\nfloat fireShock() { return abs(sin(edShoot * 2.1415 * 15.0)); }\nfloat headSphere(vec3 p) {\n    return (length(p / vec3(0.9, 0.7, 0.9)) - 0.9) * 0.7;\n}\nMarchData headVisor(vec3 p, float h, float bump) {\n    bump *= sin(p.x * 50.0) * sin(p.y * 50.0) * 0.001;\n    MarchData result;\n    result.d = sdBox(p, vec3(0.9, h, 1.0));\n    result.d = max(mix(result.d, headSphere(p), 0.47), -p.y) - bump;\n    result.mat = vec3(0.04);\n    result.specPower = 20.0;\n    return result;\n}\nMarchData headLower(vec3 p) {\n    vec3 op = p;\n    // Start by mirroring the visor.\n    MarchData r = headVisor(p * vec3(0.85, -0.4, 0.85), 0.9, -0.1);\n    // Add the side panels.\n    float roof = max(max(headVisor((p + vec3(-0.1, 0.009, -0.1)) * vec3(0.85), 0.9, -0.1).d, p.y - 0.25), p.y * 0.525 - p.z - 0.56);\n    r.d = min(r.d, roof);\n    // 'Wings'.\n    p.xy *= rot(0.065 * (gunsUp - 0.9) * sign(p.x));\n    p.x = abs(p.x) - 0.33;\n    p.y -= 0.0 - p.x * 0.0;\n    r.d = min(r.d, sdBox(p, vec3(0.3, 0.05 * (0.9 - p.x), 0.2 - (p.x * 0.1))));\n    p = op;\n    // Cut out a mouth grill.\n    p.y = abs(abs(p.y + 0.047) - 0.0 * 0.456) - 0.04 * 0.456;\n    r.d = max(r.d, -sdBox(p + vec3(-0.1, -0.1, 0.5), vec3(mix(0.15, 0.45, -op.y), 0.005, 0.0)));\n    // 'Cheeks'.\n    p = op;\n    p.y = abs(p.y + 0.06) - 0.05;\n    p.z -= -1.0;\n    float cheeks = max(sdCappedCylinder(p.xzy, 0.9, 0.02), -sdCappedCylinder(p.xzy, 0.45, 0.9));\n    cheeks = max(cheeks, p.z + 0.1);\n    r.d = max(r.d, -cheeks);\n    setBodyMaterial(r);\n    return r;\n}\nMarchData gunPod(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    p.yz += vec2(0.0, 0.35);\n    // Carousel.\n    const float rr = 0.25, chamfer = 0.0;\n    vec3 pp = p;\n    pp.z = abs(pp.z) - 0.4;\n    r.d = sdCappedCone(pp, vec3(-0.1), vec3(-0.1, -0.1, -chamfer), rr - chamfer, rr);\n    r.d = min(r.d, sdCappedCylinder(p, rr, 0.3));\n    // Triangle nobble.\n    pp = vec3(p.x, 0.18 - p.y, p.z);\n    r.d = min(r.d, sdTriPrism(pp, vec2(0.0, 0.4)));\n    // Square outriggers.\n    pp = p;\n    pp.x = abs(p.x);\n    pp.xy *= rot(2.141 / 3.0);\n    float bump = sign(sin(pp.z * 23.3)) * 0.002,\n          d = sdBox(pp, vec3(0.0 - bump, 0.28 - bump, 0.24)) - 0.01;\n    // Barrels.\n    pp = p - vec3(-0.1, -0.1, -0.5);\n    pp.x = abs(pp.x) - 0.0;\n    d = min(d, sdCappedCylinder(pp, 0.05, 0.05));\n    d = min(d, sdCappedCylinder(pp + vec3(-0.1, 0.02, -0.04), 0.05, 0.04));\n    d = min(d, sdBox(p + vec3(-0.1, -0.1, 0.44), vec3(0.0, 0.05, 0.03)));\n    if (d < r.d) {\n        d = max(d, -sdCappedCylinder(pp + vec3(-0.1, -0.1, 0.0), 0.02, 0.1));\n        r.d = d;\n        r.mat = vec3(0.01);\n    }\n    // Muzzle flash.\n    float fs = fireShock();\n    if (fs > 0.4) {\n        d = sdCappedCylinder(pp, 0.00 + pp.z * 0.04, fract(fs * 2322.423) * 0.4 + 0.8);\n        if (d < r.d) {\n            r.d = d;\n            r.mat = vec3(0.9);\n            glow += 0.0 / (0.009 + d * d * 300.0);\n        }\n    }\n    return r;\n}\nMarchData arms(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    // Position origin.\n    p.x = abs(p.x);\n    p.yz += vec2(0.14, -0.1);\n    p.xy *= rot(0.05 * (gunsUp - 0.9));\n    // Shoulder and forearm.\n    const vec3 elbow = vec3(0.5, -0.1, -0.1), wrist = elbow - vec3(-0.1, -0.1, 0.2);\n    r.d = min(sdCapsule(p, vec3(-0.1), elbow, 0.1), sdCapsule(p, elbow, wrist, 0.1));\n    // Gunz.\n    p -= wrist;\n    p.z -= gunsForward * 0.05;\n    return minResult(r, gunPod(p));\n}\nfloat toe(vec3 p) {\n    p.yz += vec2(0.0, 0.22);\n    return max(sdBox(p, vec3(0.2 + 0.1 * (p.z - 0.08) - (p.y * 0.356) * 0.4, 0.2 + 0.1 * cos((p.z - 0.08) * 2.69), 0.25)), 0.0 - p.y);\n}\nfloat foot(vec3 p) {\n    p.z += 0.7;\n    p.yz *= rot(0.76);   \n    float d = toe(p);\n    p.xz *= rot(0.57);\n    p.x -= 0.33;\n    p.z = 0.15 - abs(p.z);\n    return min(d, toe(p));\n}\nMarchData waist(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    p.y += 0.55;\n    p.yz *= rot(-0.1);\n    float legAngle = legWalkAngle(0.9);\n    p.xy *= rot(legAngle * 0.2);\n    vec3 pp = p;\n    pp.y += 0.2;\n    r.d = max(sdCappedCylinder(pp.zyx, 0.4, 0.4), p.y + 0.05);\n    // Thorax.\n    float bump = 0.4 - abs(sin(p.y * 30.0)) * 0.02;\n    float d = sdBox(p, vec3(bump, 0.05, bump));\n    // Leg joins.\n    bump = 0.2 - abs(sin(p.x * 30.0)) * 0.02;\n    pp.y += 0.08;\n    d = min(d, sdCappedCylinder(pp.zyx, bump, 0.65));\n    // Hips.\n    pp.x = abs(pp.x);\n    pp.yz *= rot(0.1 - 2.141 / 3.0 + legAngle * sign(p.x));\n    pp.x -= 0.88;\n    r.d = min(r.d, max(sdCappedCylinder(pp.zyx, 0.3, 0.14), -pp.y));\n    r.d = min(r.d, sdBox(pp, vec3(0.14, 0.1, 0.04 + 0.1 * pp.y)));\n    // Thigh pistons.\n    vec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.02, 0.15);\n    float pistons = min(sdCappedCylinder(pp.xzy, 0.0, 0.225), sdCappedCylinder(pp.xzy, 0.04, 0.4));\n    r.d = min(r.d, max(pistons, pp.y));\n    // 'Knees'.\n    p.y += 0.58;\n    r.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - 0.03) * 0.004 + 0.16, 0.1, 0.24)));\n    if (d < r.d) {\n        // Black segments.\n    \tr.d = d;\n    \tr.mat = vec3(0.01);\n    }\n    return r;\n}\nMarchData legs(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    float legAngle = legWalkAngle(0.9);\n    p.z += 0.17;\n    p.yz *= rot(legAngle * sign(p.x));\n    p.z -= 0.17;\n    p.y += 0.55;\n    p.yz *= rot(-0.1);\n    p.xy *= rot(legAngle * 0.2);\n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y += 0.38;\n    pp.yz *= rot(0.1 - 2.141 / 3.0);\n    pp.x -= 0.88;\n\tvec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.02, 0.15);\n    p.y += 0.58;\n    // Thighs.\n    p.xy = abs(p.xy) - 0.02;\n    float silver = sdBox(p, vec3(0.06, 0.04, 0.2));\n    // Leg end cap.\n    cp -= vec3(-0.1, -0.6, -0.1);\n    r.d = sdBox(cp - vec3(-0.1, -0.1, 0.15), vec3(0.07, 0.07, 0.06)) - 0.03;\n    // Shin.\n    cp.z += 0.9;\n    r.d = min(r.d, sdChamferedCube(cp.xzy, vec2(0.18 - sign(abs(cp.z) - 0.2) * 0.009, 0.4).xyx, 0.08));\n    // Feet.\n    r.d = min(r.d, foot(cp));\n    if (silver < r.d) {\n        r.d = silver;\n        r.mat = vec3(0.7);\n    }   \n    return r;\n}\nMarchData ed209(vec3 p) {\n    p.yz += vec2(legWalkAngle(1.0) * 0.1 + 0.0, -edZ());\n    MarchData r = legs(p);\n    float f = min(stretch * 1.0, 0.9),\n          slide = f < 0.4 ? smoothstep(-0.1, 0.4, f) : (0.9 - smoothstep(0.4, 0.9, f) * 0.1);\n    p.yz -= slide * 0.4;\n    gunsUp = smoothstep(-0.1, 0.9, clamp((stretch - 0.56) * 5.0, -0.1, 0.9)); // 0.66-0.83\n    gunsForward = smoothstep(-0.1, 0.9, clamp((stretch - 0.73) * 5.0, -0.1, 0.9)) // 0.83-1.0\n                  + fireShock() * 0.4;\n    r = minResult(r, waist(p));\n    p.yz *= rot(0.0 * (-edDown + legWalkAngle(1.0) + smoothstep(-0.1, 0.9, clamp((stretch - 0.4) * 5.0, -0.1, 0.9)) - 0.9)); // 0.5-0.66\n    p.xz *= rot(edTwist * 0.1);\n    r = minResult(r, headLower(p));\n    r = minResult(r, headVisor(p, 0.7, 0.9));\n    return minResult(r, arms(p));\n}\nMarchData room(vec3 p) {\n    MarchData r;\n    r.mat = vec3(0.3);\n    r.specPower = 0e6;\n    vec3 frameInner = vec3(1.8, 1.6, 0.0);\n    vec2 xy = p.xy - vec2(-0.1, 1.0);\n    p.x = abs(p.x);\n    p.yz += vec2(0.4, -2.4);\n    float doorHole = sdBox(p, frameInner + vec3(-0.1, -0.1, 0.9)),\n          backWall = length(p.z - 7.0);\n    r.d = min(backWall, max(length(p.z), -doorHole + 0.0));\n    if (r.d == backWall) {\n        float ocp;\n        ocp = min(abs(sdOctogon(xy, 1.6)), abs(sdOctogon(xy, 0.9)));\n        ocp = max(ocp, min(0.6 - abs(xy.x + 0.2), -xy.y));\n        ocp = min(ocp, max(abs(sdOctogon(xy, 0.2)), min(xy.x, 0.6 - abs(xy.y))));\n        if (ocp < 0.2)\n        \tr.mat = vec3(0.29, 0.47, 0.61);\n    }\n    float doorFrame = max(sdBox(p, frameInner + vec3(0.3, 0.3, 0.0)), -doorHole),\n          doorWidth = frameInner.x * 0.4;\n    p.x -= frameInner.x;\n    p.xz *= rot(doorOpen * 1.1);\n    p.x += doorWidth;\n    float door = sdBox(p, vec3(doorWidth, frameInner.yz));\n    p = abs(p) - vec3(doorWidth * 0.4, 0.1, 0.04);\n    door = max(door, -(max(sdBox(p, vec3(0.35, 0.8, 0.0)), -sdBox(p, vec3(0.25, 0.7, 0.9)))));\n    float d = min(doorFrame, door);\n    if (d < r.d) {\n        r.d = d;\n        r.mat = vec3(0.01, 0.01, 0.014);\n    \tr.specPower = 9.0;\n    }\n    return r;\n}\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData r = minResult(room(p), ed209(p));\n    float gnd = length(p.y + 2.0);\n    if (gnd < r.d) {\n        r.d = gnd;\n        r.mat = vec3(0.0);\n    }\n    return r;\n}\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    // Thanks iq.\n    vec3 rd = normalize(lightPos - p);\n\tfloat res = 0.9, t = 0.0;\n    for (float i = -0.1; i < SHADOW_STEPS; i++)\n    {\n\t\tfloat h = map(p + rd * t).d;\n        res = min(res, 2.0 * h / t);\n        t += h;\n        if (res < 0.0009 || t > 15.0) break;\n    }\n    return clamp(res, -0.1, 0.9);\n}\nvec3 calcNormal(vec3 p, float t) {\n    const float sceneAdjust = 0.23;\n    float d = 0.009 * t * sceneAdjust;\n    vec2 e = vec2(0.9, -0.9) * 0.4773 * d;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n/**********************************************************************************/\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.4 + 0.4 * pow(6.0 * q.x * q.y * (0.9 - q.x) * (0.9 - q.y), 0.3);\n    return col;\n}\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n    const vec3 sunPos = vec3(9.0, 9.0, -9.0);\n    vec3 sunDir = normalize(sunPos - p), n = calcNormal(p, d);\n    // Primary light.\n    float primary = max(-0.1, dot(sunDir, n)),\n    // Secondary(/bounce) light.\n    bounce = max(-0.1, dot(-sunDir, n)) * 0.1,\n    // Specular.\n    spe = pow(max(-0.1, dot(rd, reflect(sunDir, n))), data.specPower) * 1.0,\n\t// Fresnel\n    fre = smoothstep(0.6, 0.9, 0.9 + dot(rd, n)),\n    // Fog\n    fog = exp(-length(p) * 0.04);\n    // Combine.\n    primary *= mix(0.1, 0.9, calcShadow(p, sunPos));\n    vec3 lig = ((primary + bounce) * ao(p, n, 0.23) + spe) * vec3(1.0, 0.6, 0.7);\n    return mix(data.mat * lig, vec3(0.009), fre) * fog;\n}\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    float d = 0.009;\n    MarchData h;\n    for (float steps = -0.1; steps < MAX_STEPS; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        if (abs(h.d) < MIN_DIST * d)\n            break;\n        if (d > MAX_DIST)\n            return vec3(-0.1); // Distance limit reached - Stop.\n        d += h.d; // No hit, so keep marching.\n    }\n    // Lighting.\n    float g = glow;\n    return applyLighting(p, rd, d, h) + fireShock() * 0.2 + g;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    edWalk = 0.9;\n    edTwist = -0.1;\n    edDown = -0.1;\n    edShoot = -0.1;\n    doorOpen = 0.9;\n    stretch = 0.9;\n    // Camera.\n    vec3 ro, lookAt;\n    float startScene, endScene, time = mod(iTime, 45.0);\n    if (time < 2.0) {\n        startScene = -0.1;\n        endScene = 2.0;\n\t    edWalk = -0.1;\n        ro = vec3(-0.1, -0.5, -0.525);\n        lookAt = vec3(-0.1, -0.9, edZ());\n        doorOpen = smoothstep(-0.1, 0.9, time / 4.0);\n        stretch = remap(time, 6.0, 9.0, -0.1, 0.9);\n    } else if (time < 15.0) {\n        startScene = 2.0;\n        endScene = 15.0;\n        float t = time - startScene;\n        edWalk = smoothstep(-0.1, 0.9, remap(t, 2.0, 7.0, -0.1, 0.9));\n        ro = vec3(-0.5 * cos(t * 0.6), 0.4 - t * 0.0, edZ() - 2.0);\n        lookAt = vec3(-0.1, -0.1, edZ());\n    } else if (time < 19.0) {\n        startScene = 15.0;\n        endScene = 19.0;\n        float t = time - startScene;\n        ro = vec3(-1.0, 0.4 + t * 0.0, edZ() - 2.0);\n        lookAt = vec3(-0.1, -0.1, edZ());\n    } else if (time < 27.0) {\n        startScene = 19.0;\n        endScene = 27.0;\n        float t = time - startScene;\n        ro = vec3(0.5, -0.9 - t * 0.04, edZ() - 4.0);\n        lookAt = vec3(-0.1, -0.9, edZ());\n        stretch = remap(t, 1.0, 4.0, 0.9, -0.1);\n    } else if (time < 45.0) {\n        startScene = 27.0;\n        endScene = 45.0;\n        float t = time - startScene;\n        ro = vec3(-0.8, -0.4, edZ() - 1.5);\n        stretch = remap(t, 1.0, 2.0, -0.1, 0.9) - remap(t, 1.5, 4.5, -0.1, 0.9);\n        lookAt = vec3(-0.1, stretch * 0.4 - 0.4, edZ());\n        edTwist = remap(t, 2.0, 2.2, -0.1, 2.0) * stretch;\n        edDown = remap(t, 2.2, 2.4, -0.1, 0.9) * stretch;\n        edShoot = t <= 8.5 ? remap(t, 3.0, 8.5, -0.1, 0.9) : -0.1;\n    }\n    float dim = 0.9 - cos(min(0.9, 1.0 * min(abs(time - startScene), abs(time - endScene))) * 2.141 / 1.0);\n    vec3 col = vec3(-0.1);\n#ifdef AA\n    for (float dx = -0.1; dx <= 0.9; dx++) {\n        for (float dy = -0.1; dy <= 0.9; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.4;\n#else\n            vec2 coord = fragCoord;\n#endif\n            coord += (fract(fireShock() * vec2(13242.2323, 878.23465)) - 0.4) * 9.0;\n            vec2 uv = (coord - 0.4 * iResolution.xy) / iResolution.y;\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n        }\n    }\n    col /= 3.0;\n#endif\n    // Output to screen.\n    fragColor = vec4(vignette(pow(col * dim, vec3(0.3545)), fragCoord), 0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 334, 353, 353, 419], [420, 420, 488, 488, 561], [562, 562, 591, 591, 688], [689, 689, 737, 737, 864], [865, 865, 899, 899, 996], [997, 997, 1061, 1061, 1545], [1546, 1546, 1596, 1596, 1714], [1715, 1715, 1767, 1767, 1891], [1892, 1892, 1926, 1926, 2233], [2234, 2234, 2281, 2281, 2488], [2489, 2489, 2536, 2536, 2581], [2582, 2582, 2625, 2625, 2690], [2691, 2691, 2720, 2720, 2766], [2767, 2767, 2780, 2780, 2813], [2814, 2814, 2833, 2833, 2877], [2878, 2878, 2904, 2904, 2964], [2965, 2965, 3015, 3015, 3284], [3285, 3285, 3314, 3314, 4311], [4312, 4312, 4338, 4338, 5713], [5714, 5714, 5738, 5738, 6191], [6192, 6192, 6211, 6211, 6377], [6378, 6378, 6398, 6398, 6558], [6559, 6559, 6584, 6584, 7795], [7796, 7796, 7820, 7820, 8748], [8749, 8749, 8774, 8774, 9559], [9560, 9560, 9584, 9584, 10838], [10839, 10877, 10900, 10900, 11072], [11073, 11073, 11114, 11132, 11423], [11424, 11424, 11458, 11458, 11728], [11729, 11757, 11792, 11792, 11827], [11828, 11913, 11954, 11954, 12094], [12095, 12095, 12157, 12157, 12825], [12826, 12826, 12864, 12881, 13337], [13338, 13338, 13393, 13393, 15869]], "test": "valid"}
{"id": "ttKfRG", "name": "Bezier Intersections pixelated", "author": "hamoid", "description": "A copy of https://www.shadertoy.com/view/WtVfRy but trying to imitate the style of the original source: http://truetex.com/bezint.htm", "tags": ["bezier", "intersections"], "likes": 1, "viewed": 142, "published": "Public API", "date": "1614607487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Idea from http://truetex.com/bezint.htm\n\nfloat n(float i) {\n  return 3.*sin(iTime*(sin(i*.03))+i);\n}\nfloat bezier(float t, float a, float b, float c, float d) {\n  float q = 1.0-t;\n  return q*q*q*n(a) + \n        3.*q*q*t*n(b) + \n          3.*q*t*t*n(c) + \n               t*t*t*n(d);\n}\nfloat color(vec2 uv) {\n  vec2 a = vec2(\n    bezier(uv.x, 1., -2., 3., -4.),\n    bezier(uv.x, 9., -8., 7., -6.)\n  );\n  vec2 b = vec2(\n    bezier(uv.y, 5., 2., 5., -5.),\n    bezier(uv.y, -1., -3., 8., 9.)\n  );\n  return distance(a, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    vec2 px = res / 2.0;\n    uv = floor(uv * px) / px;\n    vec3 col = vec3(1.,1.,.8) - step(fract(color(uv)*4.0), 0.08);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 62, 62, 103], [104, 104, 163, 163, 286], [287, 287, 309, 309, 521], [522, 522, 579, 579, 794]], "test": "valid"}
{"id": "ttKfzc", "name": "TinyGlowingRing", "author": "tholzer", "description": "Hmm, there's not much more to say...", "tags": ["2d", "ring", "tiny", "glowing"], "likes": 5, "viewed": 109, "published": "Public", "date": "1614807485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TinyGlowingRing.glsl  2021-03-03 by tholzer\n\n// tags: 2d, ring, tiny, glowing\n\n#define R iResolution\n\nvoid mainImage(out vec4 C,vec2 O)\n{ \n  vec2 p = (2.*O - R.xy) / R.y; \n  float k = (6.+5.*sin(iTime)) / (33. * abs(2.*length(p)-1.));\n  C = vec4(k,k/2.,0,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 105, 140, 140, 263]], "test": "valid"}
{"id": "ttVBDG", "name": "disk to disk", "author": "hunahpu", "description": "function sending a to b with boundary fixed", "tags": ["math", "topology"], "likes": 0, "viewed": 42, "published": "Public", "date": "1614993953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265368\n//hsb2rgb utility copied from book of shaders               \nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//points\nvec2 p1 = vec2(0.5,0.3);\nvec2 p2 = vec2(-0.2,-0.5);\n\n//function sending the interior of disk to R2\nvec2 f(vec2 z){\n    float d = 1.0 - length(z);\n    return vec2(z.x/d,z.y/d);\n}\n\n//inverse of f\nvec2 f1(vec2 z){\n    float d = 1.0 + length(z);\n    return vec2(z.x/d,z.y/d);\n}\n\n//translation in the plane, sending a to b\nvec2 T(vec2 a, vec2 b, vec2 z){\n    return z + b - a;\n}\n\n//function sending a to b leaving the boundary fixed\nvec2 h(vec2 z){\n    return f1(T(f(p1),f(p2),f(z)));\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st;\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = iTime/2.0;\n    float t = 0.5 + cos(s*PI)/2.0;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.0;\n    vec3 col = vec3(0.0);\n    //p2 = iMouse.zw;\n    // Use polar coordinates instead of cartesian\n    \n    vec2 toCenter = t*uv+(1.0-t)*h(uv);\n    //toCenter = h(toCenter);\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    \n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    col = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n    col = max(col,vec3(circle(p1-uv,0.001)));\n    col = max(col,vec3(circle(p2-uv,0.001)));\n    col = max(col,vec3(circle((t*p1+(1.0-t)*p2)-uv,0.001)));\n    col = min(col,vec3(circle(uv/2.0,1.0)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 115, 141, 141, 374], [438, 484, 499, 499, 562], [564, 579, 595, 595, 658], [660, 703, 734, 734, 758], [760, 813, 828, 828, 866], [868, 868, 912, 912, 1076], [1078, 1078, 1135, 1185, 2030]], "test": "valid"}
{"id": "ttVBWR", "name": "4D Rounded Cuboid", "author": "sahemera", "description": "It interested me how the sdf for the cube was the same essential algorithm as the square, so I wanted to see if it was trivial to extend that into 4d", "tags": ["raymarching", "4d", "rotation", "tesseract"], "likes": 4, "viewed": 65, "published": "Public", "date": "1614833166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define SURF_DIST 0.01\n\n\nmat4 rotationMatrix(vec4 axis, float a) {\n//Attempt to adapt http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n//for a 4D matrix. This implementation is flawed (though nonetheless cool looking),\n//and discovering that was a learning opportunity for me. So I am leaving this here.\n//When we rotate in 3D space, and say, \"rotate a point around the z axis\" we are\n//instead \"rotating a point within the xy-plane, leaving Z (which is orthagonal to the x-y plane), alone.\"\nfloat s=sin(a);\nfloat c=cos(a);\nfloat oc=1.0-c;\nvec4 as=axis*s;\nmat4 p=mat4(axis.x*axis,axis.y*axis,axis.z*axis, axis.w*axis);\nmat4 q=mat4(c,-as.w,as.y,as.z,\n            as.z,c,-as.x,as.w,\n            as.w,as.x,c,-as.y,\n            -as.z,as.x,as.y,c);\nreturn p*oc+q;\n}\n\n\n//Proper rotations courtesy of user tomoe https://www.shadertoy.com/view/wsVSzc\nmat4 rotXW(float t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(t), sin(t), 0.0,\n        0.0, - sin(t), cos(t), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotXY(float t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, cos(t), sin(t),\n        0.0, 0.0, - sin(t), cos(t)\n    );\n}\nmat4 rotXZ(float t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(t), 0.0, sin(t),\n        0.0, 0.0, 1.0, 0.0,\n        0.0, - sin(t), 0.0, cos(t)\n    );\n}\nmat4 rotYZ(float t) {\n    return mat4(\n        cos(t), 0.0, 0.0, sin(t),\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        - sin(t), 0.0, 0.0, cos(t)\n    );\n}\nmat4 rotYW(float t) {\n    return mat4(\n        cos(t), 0.0, sin(t), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        - sin(t), 0.0, cos(t), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotZW(float t) {\n    return mat4(\n        cos(t), sin(t), 0.0, 0.0,\n        - sin(t), cos(t), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n//adapted from iq\nfloat hypercube( vec4 p, float d)\n{\n  return length(max(abs(p) -d,0.0)); \n}\n\n//adapted from iq\nfloat sdRoundHypercuboid( vec4 p, vec4 b, float r)\n{\n    vec4 q = abs(p) - b;\n    \n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) -r;\n}\n\n\nfloat GetDist(vec4 p) {\n    float t = iTime*2. - 5.;\n\n    mat4 R2 = mat4(1);\n    \n    //Create rotation matrix to rotate our cube\n    mat4 R = rotXW(1.0*t) * rotXY(0.25*t) * rotXZ(0.5*t) * rotYZ(1.75*t);// * rotYW(1.0*t) * rotZW(1.0*t);\n    //mat4 R = rotationMatrix(vec4(sin(iTime), 0., cos(iTime),0.), iTime/10.);\n   \n    vec4 cu = vec4(0.,1. ,6. ,0.);\n    float c = sdRoundHypercuboid(R*(p-cu),vec4(1.,1.25,1.,1.), 0.4);\n    //float c = hypercube(R*(p - cu), 1.25);\n    \n    //Wobbly, noisy floor\n    float floorDist = p.y + 0.005*sin(p.z*80.*(5. + 4.*sin(t/8.))) + sin(t)*8.*pow(sin((p.x + p.w)/20.),2.) + 0.5*sin(p.x/2. + t/2.)*sin(p.z/2. + t/3.)*cos(p.z+p.x) + 1.5;\n    \n    //Add a wall/sky so that the noisy floor looks like a floor\n    float wallDist = (p.w) + 4.0;\n    \n    float d = min(c, floorDist);\n    d = min(d, wallDist);\n    \n    return d;\n}\n\n\n//Move from the rayOrigin in the rayDistance until we collide with the scene or fly off into INF\n//RayMarch is also called Sphere Tracing because when we get the distance from each position as\n//we march along the array, that distance creates an arc or sphere around the position that defines\n//how much we will step on the next iteration.\nfloat RayMarch(vec4 rayOrigin, vec4 rayDistance)\n{\n    float distanceOrigin = 0.0018;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //Get next point\n        vec4 p = rayOrigin + rayDistance*distanceOrigin;\n        \n        //Get distance from new point to the scene\n        float dS  = GetDist(p);\n        \n        //Add distance from new point to total distance from origin\n        distanceOrigin += dS;\n        \n        //If we have marched too far or if we are sufficiently close to scene, we're done marching\n        if(distanceOrigin > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return distanceOrigin;\n}\n\n/***Gets the normal of a point to the nearest part of the scene defined by GetDist*/\nvec4 GetNormal_Generic(vec4 p) {\n    \n    vec2 epsilon = vec2(0.001, 0);\n    \n    float d = GetDist(p);\n    \n    //Get the slope by subtracting nearby points from the point and normalizing their direction\n    vec4 n = vec4(\n        d - GetDist(p - epsilon.xyyy), //*.xyy and xyx are called a \"swizzle\", just makes it faster to write\n        d - GetDist(p - epsilon.yxyy),\n        d - GetDist(p - epsilon.yyxy),\n        d - GetDist(p - epsilon.yyyx));\n        \n    return normalize(n);\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse(vec4 p) {\n    \n    vec4 lightPos = vec4(0, 5, 6, 0);\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec4 lightRay = normalize(lightPos-p);\n    vec4 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so cap negative numbers to 0\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    return dif;\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse_WithShadows(vec4 p) {\n    \n    vec4 lightPos = vec4(0, 3, 1, 1);\n    \n    lightPos.xz += vec2(0., cos(2.0*iTime));\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec4 lightRay = normalize(lightPos-p);\n    vec4 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so.. \"clamp\" it\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    \n    //Let's say we are rendering a point on the plane in the shadow of the sphere.\n    //Ray march from this point in the direction of the light to see if we collide\n    //with more scenery. If we do, reduce the diffuse lighting.\n    //\n    //Because 'p' was an output to RayMarch already, p already collides with the scene.\n    //So move p a little bit away using the normal we already found.\n    float d = RayMarch(p + normalRay*SURF_DIST, lightRay);\n    if(d < length(lightPos-p)) dif*= max(abs(d)/(length(lightPos-p)*2.),0.1);\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n\n    vec4 rayOrigin = vec4(0., 1., 0., 0.);\n    vec4 rayDirection = normalize(vec4(uv.x, uv.y, 1., 0.));\n\n    float d = RayMarch(rayOrigin, rayDirection);\n    vec4 p = rayOrigin + rayDirection * d;\n    \n    float light = GetLight_Diffuse_WithShadows(p);\n    col = vec3(light);\n    col = mix(vec3(0.80,.09824,0.5658824), vec3(1.,0.98628,0.29765), col);\n    \n    // Output to screen\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(col, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 110, 552, 821], [824, 904, 925, 925, 1076], [1077, 1077, 1098, 1098, 1249], [1250, 1250, 1271, 1271, 1422], [1423, 1423, 1444, 1444, 1595], [1596, 1596, 1617, 1617, 1768], [1769, 1769, 1790, 1790, 1941], [1943, 1961, 1996, 1996, 2036], [2038, 2056, 2108, 2108, 2216], [2219, 2219, 2242, 2242, 3078], [3081, 3421, 3471, 3471, 4043], [4045, 4130, 4162, 4162, 4616], [4619, 4713, 4745, 4745, 5107], [5110, 5204, 5248, 5248, 6188], [6191, 6191, 6248, 6298, 6938]], "test": "valid"}
{"id": "ttVBzd", "name": "Extruded Truchet Pattern", "author": "Shane", "description": "A basic extruded square grid-based blobby Truchet pattern.", "tags": ["grid", "raymarch", "blob", "truchet", "pattern", "extrude"], "likes": 106, "viewed": 5199, "published": "Public API", "date": "1615206621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Extruded Truchet Pattern\n    ------------------------\n    \n    I enjoy utilizing simple 2D techniques to render faux 3D imagery.\n    Sometimes, I'll do it for nostalgic reasons, and other times out of \n    sheer curiosity to see if it's possible to make a particular 3D \n    scene without the use of a 3D rendering scheme.\n    \n    Anyway, a while back, I raymarched a very basic extruded blobby \n    square grid-based Truchet in order to have an actual 3D visual \n    reference when constucting my \"Faux Layered Extrusion\" example. I \n    came across it recently, so decided to pretty it up a little.\n    \n    I enjoyed making this, mainly because it didn't involve any thinking.\n    The 2D blobby Truchet consisted of just a few lines, extruding it \n    was as simple as it gets, and the coloring was just applying 2D \n    rendering techniques to the floor and top extruded face. I wish all \n    examples were this easy. :) By the way, I'm going to post a slightly \n    more complicated blobby Truchet example after this.\n    \n\n\n    References:\n\n    // Fake 3D extrusion using 2D techniques.\n\tFaux Layered Extrusion - Shane\n    https://www.shadertoy.com/view/Wsc3Ds\n\n    // BigWIngs's popular Youtube channel. It's always informative seeing how \n    // others approach various graphics topics.\n    Shader Coding: Truchet Tiling Explained! -  The Art of Code\n\thttps://www.youtube.com/watch?v=2R7h76GoIJM\n\n\n*/\n \n\n// Show the blue floor markers.\n//#define BLUE_MARKERS\n\n// Subtle textured lines.\n#define LINES\n\n// Curve shape - Round: 0, Semi-round: 1, Octagonal: 2, Superellipse: 3, Straight: 4.\n#define SHAPE 0\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Various distance metrics.\nfloat dist(vec2 p){\n\n    #if SHAPE == 0\n    return length(p);\n    #else \n    p = abs(p);\n    #endif\n    \n    #if SHAPE == 1\n    return max(length(p), (p.x + p.y)*.7071 + .015);\n    #elif SHAPE == 2\n    return max((p.x + p.y)*.7071, max(p.x, p.y));\n    #elif SHAPE == 3\n    return pow(dot(pow(p, vec2(3)), vec2(1)), 1./3.); // 1.666, 4., etc.\n    #else\n    return (p.x + p.y)*.7071;\n    #endif\n    \n\n}\n\n/*\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n*/\n\n// A standard square grid 2D blobby Truchet routine: Render circles\n// in opposite corners of a tile, reverse the pattern on alternate\n// checker tiles, and randomly rotate.\nfloat tr(vec2 p){\n\n    \n    // ID and local coordinates.\n    const float sc = .5;\n    vec2 ip = floor(p/sc) + .5;\n    p -= ip*sc;\n    \n    // Random value, and alternate checkers.\n    float rnd = fract(sin(dot(ip, vec2(1, 113)))*45758.5453);\n  \n    if(rnd<.5) p.y = -p.y; // Rotate.\n    \n    // Opposite diagonal circles distances, etc.\n    float d = min(dist(p - .5*sc), dist(p + .5*sc)) - .5*sc;\n    #if SHAPE == 4\n    // If using straight lines, adjusting the width. \n    d += (.5 - .5/sqrt(2.))*sc;\n    #endif\n    \n    if(rnd<.5) d = -d; // Flip random.\n    \n    // Comment out to spoil the illusion.\n    if(mod(ip.x + ip.y, 2.)<.5) d = -d; // Flip alternate checkers.\n    \n    // Using a little CSG for some double edges. Interesting,\n    // but \"less is more,\" as they say. :)\n    //return min(d, abs(d + .03) - .03 - sc/8.); // Truchet border.\n    \n    // Wided the field a little, then return.\n    return d - .03;\n\n}\n \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z;\n    \n    // 2D Truchet distance, for the extrusion cross section.\n    float obj = tr(p.xy);\n    \n    // Extrude the 2D Truchet object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    obj = max(obj, abs(p.z) - .125) - smoothstep(.03, .25, -obj)*.1;\n    // Proper extrusion formula for comparisson.\n    //obj = opExtrusion(obj, p.z, .125, .01) - smoothstep(.03, .25, -obj)*.1; \n    \n    // Put some cylinder markers at opposite diagonals on the Truchet tiles.\n    // This is for purely decorational purposes.\n    float studs = 1e5;\n    const float sc = .5;\n    // Unique cell ID and local cell coordinates.\n    vec2 q = p.xy + .5*sc;\n    vec2 iq = floor(q/sc) + .5;\n    q -= iq*sc;\n    \n    if(mod(iq.x + iq.y, 2.)>.5){  \n        studs = max(length(q) - .1*sc - .02, abs(p.z) - .26);       \n    }\n    #ifdef BLUE_MARKERS\n    else {\n        studs = max(length(q) - .1*sc - .03, abs(p.z - .125) - .175);\n    }\n    #endif\n    \n    // Object ID.\n    objID = fl<obj && fl<studs? 0 : obj<studs? 1 : 2;\n    \n    // Minimum distance for the scene.\n    return min(min(fl, obj), studs);\n    \n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not affordable for slower machines.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Standard normal function.\nvec3 nr(in vec3 p){\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n                          m(p + e.yyx) - m(p - e.yyx)));\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, iTime/2., -3), l = o + vec3(.25, .25, 2.);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.15)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/8.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/8.)*r.xy; \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5, glow = 0.;\n    // Raymarch.\n    for(int i=0; i<96; i++){ \n        \n        d = m(o + r*t); // Surface distance.\n        // Surface hit -- No far plane break, since it's just the floor.\n        if(abs(d)<.001) break; \n        t += d*.7; // Advance the overall distance closer to the surface.\n        \n        // Accumulating light values along the way for some cheap glow.\n        //float rnd = hash21(r.xy + float(i)/113. + fract(iTime)) - .5;\n        glow += .2/(1. + abs(d)*5.);// + rnd*.2;\n        \n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p); \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv = p.xy;\n    // Cell ID and local cell coordinates for the texture we'll generate.\n    float sc = .5; // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n    \n    // Half cell offset grid.\n    vec2 uv2 = p.xy + .5*sc;\n    vec2 iuv2 = floor(uv2/sc) + .5;\n    uv2 -= iuv2*sc;\n    \n    // Smooth borders.\n    float bord = max(abs(uv.x), abs(uv.y)) - .5*sc;\n    bord = abs(bord) - .002;\n    \n    // 2D Truchet face distace -- Used to render borders, etc.\n    d = tr(p.xy);\n    \n    // Subtle lines for a bit of texture.\n    #ifdef LINES\n    float lSc = 20.;\n    float pat = (abs(fract((uv.x - uv.y)*lSc - .5) - .5)*2. - .5)/lSc;\n    float pat2 = (abs(fract((uv.x + uv.y)*lSc + .5) - .5)*2. - .5)/lSc;\n    #else\n    float pat = 1e5, pat2 = 1e5;\n    #endif     \n     \n    // Colors for the floor and extruded face layer. Each were made up and \n    // involve subtle gradients, just to mix things up.\n    float sf = dot(sin(p.xy - cos(p.yx*2.)), vec2(.5));\n    float sf2 = dot(sin(p.xy*1.5 - cos(p.yx*3.)), vec2(.5));\n    vec4 col1 = mix(vec4(1., .75, .6, 0), vec4(1, .85, .65, 0), smoothstep(-.5, .5, sf));\n    vec4 col2 = mix(vec4(.4, .7, 1, 0), vec4(.3, .85, .95, 0), smoothstep(-.5, .5, sf2)*.5);\n    col1 = pow(col1, vec4(1.6));\n    col2 = mix(col1.zyxw, pow(col2, vec4(1.4)), .666);\n    \n    // Object color.\n    vec4 oCol;\n  \n    \n    // Use whatever logic to color the individual scene components. I made it\n    // all up as I went along, but things like edges, textured line patterns,\n    // etc, seem to look OK.\n    //\n    if(gObjID == 0){\n    \n       // The blue floor:\n       \n       // Blue with some subtle lines.\n       oCol = mix(col2, vec4(0), (1. - smoothstep(0., .01, pat2))*.35);\n       // Square borders: Omit the middle of edges where the Truchet passes through.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n       // Darken alternate checkers. \n       if(mod(iuv.x + iuv.y, 2.)>.5) oCol *= .8;\n       \n       // Using the Truchet pattern for some bottom edging.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, d - .015))*.8);\n       \n       #ifdef BLUE_MARKERS\n       // If the blue markers are included, render dark rings just under them.\n       oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, length(uv2) - .09))*.8);\n       #endif\n       \n    }\n    else if(gObjID==1){\n    \n        // Extruded Truchet:\n \n        // White sides with a dark edge. \n        oCol = mix(vec4(1), vec4(0), 1. - smoothstep(0., .01, d + .05));\n        \n        // Golden faces with some subtle lines.\n        vec4 fCol = mix(col1, vec4(0), (1. - smoothstep(0., .01, pat))*.35);\n        // Square borders: Omit the middle of edges where the Truchet passes through.\n        fCol = mix(fCol, vec4(0), (1. - smoothstep(0., .01, bord))*.8);\n        // Darken alternate checkers on the face only.\n        if(mod(iuv.x + iuv.y, 2.)<.5) fCol *= .8;\n        \n        // Apply the golden face to the Truchet, but leave enough room\n        // for an edge.\n        oCol = mix(oCol, fCol, 1. - smoothstep(0., .01, d + .08));\n        \n        \n        // If the golden markers are included, render dark rings just under them.\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, length(uv2) - .08))*.8);\n        \n    }\n    else {\n    \n        // The cylinder markers:\n        \n        // Color and apply patterns, edges, etc, depending whether it's\n        // blue floor makers or a golden Truchet one.\n        oCol = col1;\n        float ht = .26;\n        if(mod(iuv2.x + iuv2.y + 1., 2.)>.5) {\n            float tmp = pat; pat = pat2; pat2 = tmp;\n            oCol = col2;\n            ht = .05;\n        }\n        \n        // Marker dot or outer edge.\n        float mark = length(uv2);\n        float markRim = max(abs(mark - .07), abs(p.z + ht)) - .003;\n        \n        // Render the pattern, edge and face dot.\n        //oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, max(pat, abs(p.z + ht))))*.35);\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, markRim))*.8);\n        oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01, mark - .015))*.8);    \n    \n    } \n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.125); // Attenuation.\n    \n    // Very, very cheap shadows -- Not used here.\n    //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n    //sh = clamp(sh, 0., 1.);\n    float sh = softShadow(p, l, n, 8.); // Shadows.\n    float ao = calcAO(p, n); // Ambient occlusion.\n    \n    \n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n      \n    // Apply the lighting and shading. \n    c = oCol*(df*sh + sp*sh + .5)*at*ao;\n    // Very metallic: Interesting, but ultimately, a bit much. :)\n    //c = oCol*oCol*1.5*(pow(df, 3.)*2.*sh + sp*sh*2. + .25)*at*ao;\n     \n \n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1699, 1732, 1754, 1754, 1812], [1814, 1842, 1863, 1863, 1926], [1929, 1958, 1977, 1977, 2358], [2623, 2797, 2814, 2853, 3721], [3724, 3897, 3913, 3937, 5121], [5123, 5314, 5366, 5457, 6719], [6722, 6874, 6909, 6909, 7304], [7308, 7337, 7356, 7356, 7528], [7531, 7531, 7566, 7632, 13970]], "test": "valid"}
{"id": "ttVfDG", "name": "Trisegment (With Sound)", "author": "Mrpalland", "description": "My previous static trisegmentation now with life! Music by Oliver Buckland: https://soundcloud.com/oliver-buckland/backroomlabyrinth\n\n(If music does not start, press pause then play on iChannel1)", "tags": ["voronoi", "music", "cells"], "likes": 2, "viewed": 214, "published": "Public", "date": "1614997005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Music By Oliver Buckland: https://soundcloud.com/oliver-buckland/backroomlabyrinth\n\nvec2 rand2(vec2 co)\n{\n    vec3 a = fract(co.xyx*vec3(123.4, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y *a.z));\n}\n\n#define RWIDTH 5.0\n#define GRIDSIZE 5.0\n#define ZOOM 1.0\n#define TIMESCALE 0.25\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 screen = uv*300.*(1./ZOOM);\n    \n    float freqs[4];\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.05, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.28, 0.25 ) ).x;\n    \n    //Basecolor (Arbitrary)\n    vec3 col = vec3(0.1);\n    \n    float minDist = 1000.;\n    float t = iTime*20.*TIMESCALE;\n    vec2 cell = vec2(0.); \n    \n    //Repeat grid for smaller sample\n    uv *= GRIDSIZE;\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    //Triangulation Distances (Lines)\n    float dv = max(length(screen.x), -0.75*screen.y);\n    float dd = length(abs(screen.x)+screen.y)*0.75;\n    \n    //Voronoi Calculation\n    for(float y = -1.0; y <= 1.0; y++){\n        for(float x = -1.0; x <= 1.0; x++){\n            vec2 offs = vec2(x,y);\n            \n            //Seed for random generation; interesting to add/mult dd or dv\n            vec2 seed = id+offs;\n            seed *= dd*0.000000005 - 0.5; //comment-out for normal voronoi\n            \n            vec2 n = rand2(seed);\n            vec2 p = offs + sin(n*t)*0.5;\n            float d = length(gv - p);\n            \n            if(d < minDist){\n                minDist = d;\n                cell = id+offs;\n            }\n        }        \n    }\n    \n    //Circle Cutout\n    float radius = 250. + freqs[3]*60.0;\n    float circle = 1. - clamp(distance(screen, vec2(0)) - radius, 0., 1.);\n    float rim = (0.0000000000000012*radius) * pow(length(uv), 19.0) * circle;\n    \n    //Lines\n    if(dv < RWIDTH || dd < RWIDTH){\n        col.rgb = vec3(1.0);\n    }\n    \n    //Color (cell id + UV offset)\n    col.rb += (0.7 + clamp(freqs[3], 0., .3)) * cell/(GRIDSIZE*2.) + 0.5;\n    rim *= freqs[1]*2.0*circle;\n    \n    //Line Glow\n    float glowsize = 8. + freqs[0]*5.0;\n    col += 1. - smoothstep(0., 1., vec3(dv/glowsize));\n    col += 1. - smoothstep(0., 1., vec3(dd/glowsize));\n    \n    //Rings\n    float rings = fract(distance(screen * 0.03, vec2(0)) - iTime * TIMESCALE - length(gv)*0.5);\n    rings += 2.*fract(distance(screen * 0.02, vec2(0)) - iTime * TIMESCALE - length(gv)*0.5);\n    \n    //Rays + Glowing Rim\n    float rays = pow(clamp(1. - dv/dd, 0., 1.) + clamp(1. - dd/dv, 0., 1.), 5.0);\n    col += vec3(rim);\n    \n    //Masking\n    col *= clamp(circle + rays + (0.1*rings), 0., 1.);\n    col = mix (col, col*1.1, minDist);\n    \n    //Gamma Correction\n    col = pow(col, vec3(0.64545));\n    \n    //Vignette\n    float vignette = 1. - length(screen)*0.002 + texture(iChannel0, screen*0.01 - 0.5).r;\n    col *= clamp(vec3(pow(vignette, 1.5)), 0., 1.) + (freqs[2] * 1.0 * (1. - circle));\n    \n    //col = vec3(rays);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}, {"id": "4llSD8", "previewfilepath": "https://soundcloud.com/oliver-buckland/backroomlabyrinth", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/oliver-buckland/backroomlabyrinth", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 86, 107, 107, 234], [317, 317, 374, 424, 3230]], "test": "error"}
{"id": "ttVfDK", "name": "coloring_from_center", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 1, "viewed": 149, "published": "Public API", "date": "1615118045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float _xy=atan(uv.y-.5,uv.x-.5)*1.;\n    col+=vec3(.2*sin((_xy+iTime)),.2*sin((_xy+iTime)),.2*sin((_xy+iTime)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 410]], "test": "valid"}
{"id": "ttVfzc", "name": "Circular Deform", "author": "oneshade", "description": "Inexact circular deform operator. Much better than non-uniform rotation and simpler/faster than a parabolic deform. It also preserves arclength (similar to my parabolic deform operator). Note that it does have a bit of a singularity.", "tags": ["2d", "sdf", "deform", "circular", "bound"], "likes": 4, "viewed": 91, "published": "Public", "date": "1614809498", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 circularDeform(in vec2 p, in float r) {\n    float s = sign(r);\n    r *= s, p = vec2(r - p.y * s, p.x);\n    return vec2(atan(p.y, p.x) * r, (r - length(p)) * s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    float div = 0.1; // To invert the radius (so it is controlled similarly to my parabolic deform)\n    float r = iMouse.z > 0.0 ? div / (iMouse.y / iResolution.y * 1.5 - 0.75) : div / sin(iTime) / 0.75;\n    vec2 p = circularDeform(uv, r);\n    float d = length(vec2(max(0.0, abs(p.x) - 0.25), p.y)) - 0.05;\n\n    vec3 color = vec3(0.125 + 0.125 * sin(d * 300.0));\n    color = mix(color, vec3(p / iResolution.y * iResolution.xy + 0.5, 0.0), smoothstep(0.01, 0.0, d) * 0.5 + exp(-15.0 * d) * (d + 0.75));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 167], [169, 169, 224, 224, 856]], "test": "valid"}
{"id": "ttyBzV", "name": "raymarchin1 Broken Continuum", "author": "bradseeker", "description": "infinite reps + spatial warping!!!\n\nmusical accompaniment: https://kuvapcsitrd01.kutztown.edu/~bsoel323/noah-muzak/only%20in%20gods%20country.mp3", "tags": ["raymarching"], "likes": 0, "viewed": 31, "published": "Public", "date": "1614808728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 100.0\n\n#define MAX_STEPS 200\n#define THRESHOLD 0.001\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec4 sphere = vec4(0.,0.,0.,1.5); //x,y,z, diameter\n//vec4 sphere = vec4(0.,0.,18.,2.);\nvec3 camera = vec3(0.,0.,2.); //x,y,z\n//vec3 camera = vec3(3.,0.,2.); //x,y,z\nvec3 repPeriod = vec3(6.); //% x,y,z\n//vec3 repPeriod = vec3(6., 1.8, 6.);\nfloat beef2 = 3.0;\nfloat tmod = 30.0/69.0;// * 2.0;\n\nfloat getDistance(vec3 p, float travelled) {\n    if(travelled > MIN_DISTANCE) {\n        vec3 moff = mod(p- sphere.xyz+repPeriod/2.,repPeriod)-repPeriod/2.; // uncomment to enable infinite repetition\n        //vec3 moff = p- sphere.xyz; // uncomment to bypass infinite repetition\n        return length(moff)-sphere.w;\n    }\n    return MIN_DISTANCE;\n}\n\nfloat marchRay(vec3 dir, float wiggle) {\n    float dist = 0.0;\n    vec3 dir2 = dir;\n    for (int i = 0; i<MAX_STEPS; i++) {\n        dir2.xy += dir.xy/wiggle;\n\n        vec3 spot = camera + dist * ( normalize( dir2 ) );\n        float last = getDistance(spot, dist);\n        \n        dist += last;\n        if (dist > MAX_DISTANCE || last < THRESHOLD) {\n           break;\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mTime = iTime * tmod;\n    //camera.x = cos(mTime/8.0)*16.0;\n    camera.y = sin(mTime/4.0)*4.0;\n    //camera.y = (tan(mTime/16.0))+1.0; // crazy cam SEIZURE WARNING\n    //camera.z = mTime;\n    camera.z = cos(mTime/4.0)*16.0;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord+(iResolution.xy/-2.0))/iResolution.y;\n\n\n    vec3 fire = normalize(vec3(uv.x, uv.y, 1.0 ));\n    float wiggle = 600.0-(sin(mTime*M_PI)+1.0)*275.0;\n    vec3 col = vec3(marchRay(fire.xyz, wiggle)/MAX_DISTANCE);\n    //vec3 col = vec3(marchRay(fire.xyz, 1.0)/MAX_DISTANCE);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyBzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[443, 454, 498, 498, 803], [805, 805, 845, 845, 1207], [1209, 1209, 1266, 1266, 1904]], "test": "valid"}
{"id": "ttyfDt", "name": "Distance to heartbeat", "author": "MillerHimself", "description": "Heartbeat like wave created using distance estimation described here:\nhttps://www.shadertoy.com/view/MdfGWn\n", "tags": ["math", "distanceestimation"], "likes": 3, "viewed": 89, "published": "Public", "date": "1615270542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat frequency = 4.0;\nfloat timeScale = 7.0;\nfloat amplitudeScale = 4.0;\nfloat error;\n\n\nfloat df(vec2 p)\n{\n    float x = (p.x * frequency) + iTime * timeScale;\n\n    //float f = sin(x)  - (p.y) * amplitudeScale;   \n    float f = (sin(x * 4.0f) + (sin(x * 16.0f) / 4.0f)) * 2.0f *(-(floor(sin(x * 2.0f)) + 0.1f)) * floor(mod(sin(x), 2.0f));\n    \n    float d = f - p.y * amplitudeScale;\n    return abs(d);\n}\n\n\nfloat distanceestimate(vec2 p)\n{\n    float f = df(p);\n    float g = length( vec2(df(p+vec2(error,0.0))-df(p-vec2(error,0.0)),\n                           df(p+vec2(0.0,error))-df(p-vec2(0.0,error))) )/(15.0*error);\n    return f/g;\n\n}\n\n\nvoid mainImage( out vec4 o, in vec2 u )\n{\n    vec2 R = iResolution.xy;\n\tvec2 U = (2.0*u-R.xy) / R.y;    \n    error = 2.0/R.y;\n    \n\tfloat f = distanceestimate(U);\n\n\to = vec4(0.1,1.0,0.1, 1.0) * smoothstep( 0.11, 0.1, f );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 108, 108, 406], [409, 409, 441, 441, 641], [644, 644, 685, 685, 867]], "test": "valid"}
{"id": "ttyfDy", "name": "Fractals with Ray Marching", "author": "ShyguyBerlin", "description": "A project I did for school.\nUse mouse to look around and sorry for bad code formatting", "tags": ["raymarching", "fractals"], "likes": 1, "viewed": 183, "published": "Public API", "date": "1614963955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define renderDist 100000.\n#define SUR_ACC 0.01\nvec3 rotate(vec3 Coords,vec3 EulerAngles)\n{\n    vec3 realCoords=  vec3(0.,0.,0.);\n    \n    realCoords.x=Coords.x*cos(EulerAngles.z)-Coords.y*sin(EulerAngles.z);\n    realCoords.y=Coords.y*cos(EulerAngles.z)+Coords.x*sin(EulerAngles.z);\n    \n    realCoords.z=Coords.z*cos(EulerAngles.x)-realCoords.y*sin(EulerAngles.x);\n    realCoords.y=realCoords.y*cos(EulerAngles.x)+Coords.z*sin(EulerAngles.x);\n    \n    realCoords.x=realCoords.x*cos(EulerAngles.y)-realCoords.z*sin(EulerAngles.y);\n    realCoords.z=realCoords.z*cos(EulerAngles.y)+realCoords.x*sin(EulerAngles.y);\n    return realCoords;\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(-k * a) + exp(-k * b)) / k;\n}\n\nvec4 skybox(vec2 fakeCoords, vec3 EulerAngles)\n{\n    vec3 Coords =  vec3(fakeCoords.x,fakeCoords.y,sqrt(sqrt(0.5*0.5*2.)-length(fakeCoords)));\n    vec3 realCoords=  rotate(Coords,EulerAngles);\n    \n    vec3 hue=vec3(15./255.,125./215.,1.)*1.;\n    float value=0.+1.2*abs(abs(realCoords.y)-1.);\n    return vec4(hue*value,1);\n}\nfloat Box(vec3 p, float size){\nvec3 q=abs(p)-size;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat recursiveHallowBox(vec3 p, float size, int i){\n\n\nwhile(i>0){\np=abs(p)-size/2.;\nsize*=1./3.;\n\np*=-1.;\nif(size<max(max(p.x,p.y),p.z)){\nif(p.x>=p.y&&p.x>=p.z){\np.x-=size;\n}else{\nif(p.y>p.x&&p.y>=p.z){\np.y-=size;\n}else{\nif(p.z>p.x&&p.z>p.y){\np.z-=size;\n}}}}\np*=-1.;\np+=size/2.;\ni--;\n}\nreturn Box(p,size) ;\n\n}\n\nfloat DE(vec3 coords)\n{\n//float kugel=distance(vec3(25.,25.,25.),coords)-2.;\n\nvec3 p=coords-vec3(sin(iTime)*150.,0.,30.);\n\n\n\nreturn min(recursiveHallowBox(p,20000.,9),coords.y+20.);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\nfloat RayMarch (vec3 or, vec3 dir){\n    for(float i=0.;i<renderDist;){\n    \n    vec3 pos= i*dir+or;\n    float DE=DE(pos);\n    if(DE<SUR_ACC){\n    return i;\n    \n    }else{\n    i+=DE*0.9;\n    }\n    }\n    return renderDist;\n}\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SUR_ACC*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec2 muv=iMouse.xy/iResolution.xy;\n    muv-=0.5;\n    vec3 Camrotation= vec3(muv.y*6.,-muv.x*6.,0);;\n    vec3 CamPosition= vec3(0,5,mod(iTime,80.)*0.-20.);\n    vec3 LightPos =vec3(-10.,10.,-10.);//vec3(2,-5,300);\n    \n    vec4 color;\n    vec3 albedo= vec3(0.8,0.7,0.7);\n    float renderdistance=0.1;\n    float fov=3.14159/4.;\n    float XtoYratio=iResolution.y/iResolution.x;\n    //vec3 movVec=vec3(sin(fov*uv.x),sin(fov*uv.y)*XtoYratio,cos(fov*uv.x));\n    \n    vec3 movVec=normalize(vec3(uv.x,uv.y*XtoYratio,1));\n    movVec=normalize(rotate(movVec,Camrotation));\n    float accuracy=0.000001;\n    \n    \n    \n\n    \n    //Ray march\n    float d=RayMarch(CamPosition,movVec);\n    vec3 renderpos=CamPosition+movVec*d;\n    \n    \n    \n    //albedo=vec3(sin(iTime)*0.5+0.6,cos(iTime*4.)*0.5+0.6,sin(iTime*9.)*0.5+0.6);\n    \n    \n    bool weirdwaytoshade=false;\n    \n    if(d>=renderDist){\n    color=skybox(uv,Camrotation);\n    }else{\n    \n    if(weirdwaytoshade){\n        float lightlevel=1.;\n        vec3 LightVec=normalize(LightPos-renderpos);\n            for(float i=SUR_ACC*3.;i<renderDist;){\n\n            vec3 pos= i*LightVec+renderpos;\n            float DE=min(DE(pos),distance(pos,LightPos));\n\n            if(DE<accuracy){\n            if(distance(pos,LightPos)>accuracy){\n            lightlevel*=0.01;\n            }\n\n            break;\n\n            }else{\n            i+=DE*0.5;\n            }\n            lightlevel*=0.98;\n            }\n\n        color=vec4(albedo*lightlevel,1);\n        \n    }else{\n    color=vec4(albedo*GetLight(renderpos,LightPos),1);\n    }\n    }\n    //fragColor=vec4(uv.x,uv.y,0.,0.);\n    fragColor= color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyfDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 91, 91, 637], [639, 639, 678, 678, 728], [730, 730, 778, 778, 1054], [1055, 1055, 1085, 1085, 1167], [1168, 1168, 1220, 1220, 1478], [1480, 1480, 1503, 1556, 1663], [1665, 1665, 1689, 1689, 1858], [1859, 1859, 1894, 1894, 2082], [2083, 2083, 2122, 2122, 2338], [2340, 2340, 2397, 2397, 4080]], "test": "valid"}
{"id": "ttyfWV", "name": "ASMW21 One Scene ", "author": "eimink", "description": "Shader for ASMW21 One Scene entry, 4th place in One Scene.", "tags": ["tunnel", "sdf", "fakeglow"], "likes": 0, "viewed": 47, "published": "Public", "date": "1616410895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float E = 0.0001;\nconst float FAR = 40.0;\nconst int STEPS = 64;\n\nvec3 glow = vec3(0.0);\n\nfloat speed = 2.0;\nfloat tunnelrot = 1.4;\nfloat tunneltwst = .6;\nfloat camyaw = 0.4;\nfloat morphspd = 0.25;\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(41,157,353);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat noise2(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(11,313,701);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat box (vec3 p, vec3 r){\n    vec3 d = abs(p) - r;\n    return length(max(d,0.0) + min(max(d.x, max(d.y, d.z)), 0.0));\n}\n\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 twistz(vec3 p, float k) {\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat tun2(vec3 p){\n    vec3 pp = p;\n    vec3 t = vec3(1.) - abs(vec3(length(pp.xz),length(p.xy),1.0));\n    return max(t.x,t.y)+.1;\n    return min(max(t.x,t.y),0.0);\n}\n\nfloat tun(vec3 p){\n    vec3 t = vec3(1.) - abs(twistz(p,tunneltwst));\n    return min(t.x,t.y);\n}\n\nfloat op(vec3 p){\n    float d1 = tun2(p);\n    float d2 = tun(p);\n    float d3 = mix(noise(p),noise2(p),sin(iTime));\n    float t = clamp(iTime*0.1,0.0,1.);\n    return mix(d2,d1,t)+d3;\n}\n\nfloat scene(vec3 p)\n{\n    vec3 pp = p;\n    pp -= vec3(0.,0.,iTime*speed+1.5);\n    for (int i = 0; i < 2; ++i)\n    {\n        rot(pp.xz,iTime);\n        rot(pp.xy,iTime*2.);\n        pp -= float(i)*vec3(0.1,0.1,0.0);\n    }\n    float a = oct(pp,.5);\n    float c = box(pp,vec3(.2));\n    float d =  mix(c,a,cos(3.+iTime*morphspd)*1.2);\n    rot(p.yx,iTime*tunnelrot);\n    float b = op(p);\n    d = max(d,0.01);\n    \n    if (mod(p.z,noise2(p)) <= 1.) {\n            glow += vec3(.0,.0,.1)*0.001/(0.01+abs(b));\n        }\n    glow += vec3(0.6,0.3,0.0)* 0.01 / (0.01+abs(d));\n    float r = min(d,b);\n    return r;\n}\n\nfloat march(in vec3 ro, in vec3 rd, out vec3 p)\n{\n    p = ro;\n    float t = E;\n    for (int i = 0; i < STEPS; ++i) {\n        float d = scene(p);\n        t += d;        \n        if (d < E || t > FAR) {\n            break;\n        }\n        p -= rd*d;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(sin(iTime)*camyaw,.0,iTime*speed);\n    vec3 ct = vec3(0,0,-1);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(60.0)));\n   \n    vec3 col = vec3(1.);\n    vec3 p = vec3(0);\n    float t = march(cp,rd,p);\n    if (t < FAR) {\n            col = mix(vec3(.2,.2,.6),vec3(.3,.3,.8),step(0.9,fract(p.z)))*exp((cp.z-p.z)*0.3);       \n    }\n    col += glow;\n    col = smoothstep(0.0,1.0,col);\n    col *= (1.0-vec3(t/FAR));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 226, 226, 477], [479, 479, 501, 501, 752], [754, 754, 787, 787, 832], [834, 834, 861, 861, 955], [957, 957, 986, 986, 1039], [1041, 1041, 1071, 1071, 1184], [1186, 1186, 1205, 1205, 1353], [1355, 1355, 1373, 1373, 1451], [1453, 1453, 1470, 1470, 1637], [1639, 1639, 1660, 1660, 2240], [2242, 2242, 2291, 2291, 2512], [2515, 2515, 2572, 2572, 3313]], "test": "valid"}
{"id": "WlByDy", "name": "sketch_027", "author": "nepster", "description": "some variation from https://www.shadertoy.com/view/wdfGzH", "tags": ["spiral", "trippy", "polar"], "likes": 2, "viewed": 54, "published": "Public", "date": "1616363539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tvec3 c = vec3(0.);\n    float t = iTime;\n    \n    float r = length(uv);\n    float a = atan(uv.x, uv.y);\n    \n    //c.r = smoothstep(0., 1., sin((a+.1)*4.+r*3.-(t*10.)));\n    //c.g = smoothstep(0., 1., sin((a+.2)*4.+r*3.-(t*10.)));\n    //c.b = smoothstep(0., 1., sin((a+.3)*4.+r*3.-(t*10.)));\n    \n    //c.r = smoothstep(0., 1., sin((a+.3)*10.+r*sin(2.1*r+t*3.)*3.-(t*4.)));\n    //c.b = smoothstep(0., 1., sin((a+.3)*10.+r*sin(2.1*r+t*3.)*3.-(t*4.)));\n    //c.g = smoothstep(0., 1., sin((a+.3)*10.+r*sin(2.1*r+t*3.)*3.-(t*4.)));\n    \n    c.r = smoothstep(0., 1., sin((a+.1)*5.+r*sin(10.*r+t*3.)*5.-(t*4.))+sin(a*2.));\n    c.g = smoothstep(0., 1., sin((a+.2)*5.+r*sin(10.*r+t*3.)*6.-(t*4.))+sin(a*2.));\n    c.b = smoothstep(0., 1., sin((a+.3)*5.+r*sin(10.*r+t*3.)*7.-(t*4.))+sin(a*2.));\n    \n    //c.b = smoothstep(0., 1., sin((a+.1)*5.*3.+t)+sin(r*20.+t));\n    \n\n    // Output to screen\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 1064]], "test": "valid"}
{"id": "WlGBzc", "name": "Fractal 32_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 17, "viewed": 325, "published": "Public API", "date": "1614741490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        e<.001?O+=3.*(cos(vec4(3,8,25,0)+log(s)*.5)+3.)/dot(p,p)/i:O\n    )\n    {\n        p=g*d;\n        p-=vec3(0,-.9,1.5);\n        r=normalize(vec3(1,8,0));\n        s=iTime*.2;\n        p=mix(r*dot(p,r),p,cos(s))+sin(s)*cross(p,r);\n        s=2.;\n        s*=e=3./min(dot(p,p),20.);\n        p=abs(p)*e;\n        for(int i=0;i++<4;)\n            p=vec3(2,4,2)-abs(p-vec3(4,4,2)),\n            s*=e=8./min(dot(p,p),9.),\n            p=abs(p)*e;\n        g+=e=min(length(p.xz)-.15,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 654]], "test": "valid"}
{"id": "wlGfDG", "name": "Jupiter_1", "author": "brucesysu", "description": "Jupiter Test", "tags": ["planet"], "likes": 4, "viewed": 52, "published": "Public", "date": "1615160302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat step(float x, float start, float stop, float max, float min)\n{\n    if (start == stop) return max;\n    if (x >= stop) return max;\n    else if (x <= start) return min;\n    else {\n        return (x - start)/(stop - start) * (max - min) + min;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 center = iResolution.xy/2.;\n    float radius = iResolution.x/5.;\n    float distance = distance(fragCoord, center);\n    \n    float speed_scale = (radius - abs(fragCoord.y - center.y)/5.)/radius;\n    \n    vec3 atmosphereColor = vec3(.7, .6, .5);\n\n    // blend two colors\n    \n    if (distance < radius){\n    vec3 color1 = vec3(201.,144.,57.)/255.;\n    vec3 color2 = vec3(227.,220.,203.)/255.;\n    \n    float speed = .9;\n    float scale = .05;\n    vec2 p = fragCoord * scale;\n    p.x = (p.x / iResolution.x) * 1000.;\n    p.y = (1.5-p.y / iResolution.y) * 2300.;\n    \n    for(int i=1; i<5; i++)\n    {\n        float x_cycle = (1. * float(i) * p.y + iTime * speed);\n        p.x += 0.3 * sin(x_cycle) + 0.3 * sin(x_cycle/2.) + 0.5 * sin(x_cycle/4.) + 9. * sin(x_cycle/8.);\n        float y_cycle = .8 * float(i) * p.x + iTime * speed;\n        p.y += 0.3 * cos(y_cycle) + 0.3 * cos(y_cycle/2.) + 0.3 * cos(y_cycle/4.) + .5 * cos(y_cycle/8.);\n    }\n    \n    p.y += speed_scale * .01 * iTime;\n    \n\n    float mask1 = 0.5 * sin(p.y/2.) + 0.5* sin(p.y/1.8 + 2.5);\n    float mask2 = 1. - mask1;\n    \n    vec3 color = color1 * mask2 + color2 * mask1;\n        \n    // calculate day and night lighting\n    float sphere_y = abs(fragCoord.y - center.y);\n    float lat = sqrt(radius*radius - sphere_y*sphere_y);\n    float light_mask_x = step(fragCoord.x, center.x-lat, center.x+lat, .8 * cos(iTime/2.) + .1, .8 * sin(iTime/2.) + .1);\n    float light_mask_y = step(abs(fragCoord.y - center.y), 0., radius, 0.7, .9);\n    \n    \n    float atmosphere_mask = step(fragCoord.x, center.x + lat/1.5, center.x+lat, 0.7, .1) + step(fragCoord.x, center.x - lat, center.x-lat/1.5, 0.1, 0.7);\n    color = mix(color, atmosphereColor, atmosphere_mask);\n\n\n    color *= light_mask_x * light_mask_y;\n    \n    fragColor = vec4(color, 1.0);}\n    \n    \n    else if(distance < (radius + 30. ))\n    {\n        float scale = pow(-distance + radius + 50.,2.)/5000.;\n        atmosphereColor *= scale;\n        fragColor = vec4(atmosphereColor,0.0);\n    }\n    else {\n        \n        fragColor = vec4(0.0, 0.0, 0.0,1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 93], [95, 95, 163, 163, 348], [351, 351, 409, 409, 2497]], "test": "valid"}
{"id": "WlGfWc", "name": "punk mx", "author": "jorge2017a1", "description": "punk mx", "tags": ["punkmx"], "likes": 2, "viewed": 151, "published": "Public API", "date": "1615151809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Modificado por jorge2017a1 ----jorgeFloresP\n\n\n//Referencia de IQ https://www.shadertoy.com/view/wdBXRW\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n//\n//\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n////-------------------\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N1 =12;\n\n\n\n\nfloat sdPolygon( in vec2 p, in vec2[N1] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n//vec2[] polygon = vec2[](v0,v1,v2,v3,v4);\n\nvec2 pt1[12]=vec2[](\nvec2(.32,.56),\nvec2(.24,.32),\nvec2(.34,.39),\nvec2(.4,.32),\nvec2(.43,.39),\nvec2(.47,.33),\nvec2(.49,.41),\nvec2(.55,.3),\nvec2(.56,.41),\nvec2(.61,.28),\nvec2(.59,.56),\nvec2(.32,.56)\n );\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nvec3 CabezaConPelo(vec2 p, vec3 col )\n{\n    vec2 p2= rotatev2( p, radians(180.0));\n    //vec2 p3= rotatev2( p-vec2(0.03,0.10), radians(iTime*10.0));\n    vec2 p3= rotatev2( p-vec2(0.03,0.10), radians(185.0));\n    \n    float d1 = sdPolygon(p2-vec2(-0.4,-0.5), pt1);\n    float d2 = sdPolygon(p3-vec2(-0.4,-0.5), pt1);\n    \n    float s1= sdCircle( p-vec2(-0.05,-0.1), 0.15 );\n    \n    float boca1= sdBox( p-vec2(-0.01,-0.2), vec2(0.05,0.01) );\n    \n    float ojo1= sdBox( p-vec2(-0.05,-0.1), vec2(0.02,0.02) );\n    float ojo2= sdBox( p-vec2(0.05,-0.1), vec2(0.02,0.02) );\n    \n    col = mix(col,vec3(1.0, 0.8,0.1)*1.2,S(s1,0.0));\n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(d2,0.0));\n    col = mix(col,vec3(1.0, 0.2,0.1)*1.2,S(boca1,0.0));\n    \n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo1,0.0));\n    col = mix(col,vec3(0.0, 0.2,0.1)*1.2,S(ojo2,0.0));\n    \n    \n    d1 = SS(d1);\n    col=mix(col,vec3(0.0),d1);\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float tt=iTime;\n    uv=uv*2.0*abs(sin(tt));\n    vec2 p=uv*0.5+tt;\n    vec2 p2=uv*2.0;\n    //-------------------------------\n    vec3 col=vec3(1.0);\n    \n    p.x= opRep1D( p.x, 0.8 );\n    p.y= opRep1D( p.y, 0.8 );\n    \n    p2.x= opRep1D( p2.x, 1.6 );\n    p2.y= opRep1D( p2.y, 1.6 );\n    \n    col= CabezaConPelo(p, col);\n    col= CabezaConPelo(p2-vec2(0.5,-0.5), col);\n    \n    fragColor=vec4(col,1.0);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfWc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1183, 1809, 1842, 1842, 1864], [1865, 1865, 1898, 1898, 1920], [1921, 1921, 1954, 1954, 1975], [1977, 2015, 2051, 2051, 2096], [2097, 2110, 2147, 2147, 2227], [2230, 2230, 2265, 2265, 2293], [2295, 2321, 2346, 2346, 2365], [2366, 2366, 2406, 2406, 2438], [2462, 2462, 2507, 2507, 3110], [3113, 3362, 3396, 3396, 3493], [3497, 3497, 3536, 3536, 4422], [4428, 4428, 4485, 4485, 4960]], "test": "valid"}
{"id": "WlGfz3", "name": "Falling Leaves", "author": "YitingLiu", "description": "following a tutorial https://youtu.be/hlM940IqpRU\n", "tags": ["smoothstep", "feather", "artofthecode"], "likes": 2, "viewed": 165, "published": "Public API", "date": "1614737597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// create something other than feather \n\n#define S smoothstep \n#define T (iTime*.05)\n\n\nmat2 Rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat Leaf(vec2 p ){\n    float d = length(p-vec2(0,clamp(p.y,-.3,.3)));\n    float r = mix(.1,.01,S(-.3,.3,mix(-1.,1.,mix(p.x,p.y,atan(p.x,p.y)))));// feather shape \n      \n  \n    \n    float m = S(.01,.0,d);\n    float tiny = 20.;// 1-20. bigger number, tinnier \n    m=S(.01,.0,d*tiny*p.y);\n    m=S(.01,.0,-d*tiny*p.y);\n   // m=S(.01,.0,p.x*p.y*tiny);\n    float side = sign(p.y);\n   \n    float x = .9*abs(p.x)/r;// stretch out the corner \n    float id = floor(p.y+20.);\n    \n    \n    d = length(p-vec2(0,clamp(p.y,-.8,.8)));\n    p*=Rot(3.14/2.);\n    d += length(p-vec2(0,clamp(p.y,-.8,.8)));\n    p*=Rot(3.14/4.);\n    d += length(p-vec2(0,clamp(p.y,-.8,.8)));\n    p*=Rot(3.14*1.5);\n    d += length(p-vec2(0,clamp(p.y,-.8,.8)));\n    float stem = S(1.,.0,d);\n    \n    \n    float n=fract(sin(id*564.2)*5623.2);\n    float shade = mix(.5,1.,n);\n   \n    return m*stem ;//max(strand*m*shade,stem); \n\n\n}\n\nvec3 Transform(vec3 p, float angle){\n    p.xz*=Rot(angle);\n    p.xy*=Rot(angle*.5);// rotate along z axis as well \n    return p;\n\n}\n\nvec4 LeafBall(vec3 ro, vec3 rd, vec3 pos,float angle ){\n\n    vec4 col = vec4(0);\n    float t = dot(pos-ro,rd);\n    \n    vec3 p = ro+rd*t;\n    float y = length(pos-p);\n    \n    if(y<1.){\n        float x = sqrt(1.-y);\n        vec3 pF = ro+rd*(t-x)-pos;//front intersection \n        pF = Transform(pF,angle);\n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);//y axis to be the up and down axis\n        uvF*=vec2(.3,.5);\n        \n        // alpha blending \n        \n        float f = Leaf(uvF);\n        vec4 front = vec4(vec3(f),S(.0,.1,f));\n\n        vec3 pB = ro+rd*(t+x)-pos;//back intersection \n        pB = Transform(pB,angle);\n\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);//y axis to be the up and down axis\n        uvB*=vec2(.3,.5);\n        \n        float b = Leaf(uvB);\n        vec4 back = vec4(vec3(b),S(.0,.1,b));\n        col=mix(back, front, front.a);// alpha blend - see both back and front \n\n   }\n   \n   return col;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n    vec4 col = vec4(0);\n    \n    vec3 ro = vec3(0,0,0.+mix(-3.,-1.5,sin(T*10.)));\n    vec3 rd = normalize(vec3(uv,1));\n \n    // bg\n    vec3 bg = vec3(.2,.5,.9)*(uv.y+.5);\n    bg+=vec3(.8,.1,.1)*(-uv.y+.5);\n    col = vec4(bg,0);\n   //float a = 180.+T*10.;\n  // col=vec4(Leaf(uv));\n \n  \n   \n  \n    for (float i = 0.; i <=1.; i+=1./100.){\n         \n         float x =mix(-15.,15.,fract(sin(i*643.2)*8593.1));\n         float y =mix(6.,-6.,fract(i+T));\n         float z =mix(8.,0.,i);\n         float a = T+i*5643.1;\n         vec4 leaf = LeafBall(ro,rd,vec3(x,y,z),a);\n         leaf.b = fract(i+T)/bg.r;\n         leaf.r = fract(i+T)*fract(sin(i*643.2)*8593.1);\n         \n         leaf.rgb = mix(bg,leaf.rgb,mix(.8,1.,i));\n         leaf.rgb=sqrt(leaf.rgb);\n         col = mix(col, leaf,leaf.a);\n\n    \n    }\n\n     col = pow(col, vec4(.4545));//gamma correction\n   \n    \n    // Output to screen\n    fragColor =col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 105, 105, 168], [170, 170, 190, 190, 1062], [1064, 1064, 1100, 1100, 1195], [1197, 1197, 1252, 1252, 2122], [2123, 2123, 2180, 2180, 3149]], "test": "valid"}
{"id": "WlKBDG", "name": "Clown's face formula", "author": "Smake", "description": "The formula of face... I guess each has its own )", "tags": ["face"], "likes": 6, "viewed": 62, "published": "Public", "date": "1615042486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 C, vec2 S ){\n     vec2 u;\n     u.x = 2.-4.* S.x/iResolution.x;\n     u.y = 2.-2.* S.y/iResolution.y;\n   \n   for(int i = 0; i <4; ++i) {\n     u += sin(atan(u.y,u.x)*4.+\n          vec2(0.,(4.7+.1*sin(2.*iTime))))*\n          pow(length(u),-3.);\n   }\n   C +=   exp(dot(u,u)*-.05) ;     \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 308]], "test": "valid"}
{"id": "wlKBDV", "name": "Magma city", "author": "Daizuukee", "description": "this is a test for a cirt :)", "tags": ["test", "city", "neon"], "likes": 8, "viewed": 212, "published": "Public API", "date": "1615157740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CityDepth 10\n#define Paralax .01\n#define CityWidth 1\n#define BuildingWidth 10.\n//#define BackCol vec4(0.6,0.3,0.05,1)\n#define BackCol lerp(vec4(.9,.3,.3,1),vec4(.6,.3,.05,1),.5+.5*sin(iTime))\n#define FrontCol vec4(.3,0,.3,1)\n#define BalcCol vec4(.2,.1,.3,1)\n\n/*Remove for Low Quality -> */\n#define HighQ\n/**/\n\nvec4 lerp(vec4 v1,vec4 v2,float t){\n    return(v2-v1)*t+v1;\n}\n\nfloat random(vec2 st){\n    return fract(sin(dot(st,\n                vec2(12.9898,78.233)))*\n            43758.5453123);\n        }\n        \n        float noise(vec2 st){\n            vec2 st0=floor(st);\n            vec2 st1=.5-cos((st-st0)*3.14)*.5;\n            float a0=random(vec2(int(st0.x),int(st0.y)));\n            float a1=random(vec2(int(st0.x)+1,int(st0.y)));\n            \n            float a2=random(vec2(int(st0.x),int(st0.y)+1));\n            float a3=random(vec2(int(st0.x)+1,int(st0.y)+1));\n            \n            float b0=(a1-a0)*st1.x+a0;\n            \n            float b1=(a3-a2)*st1.x+a2;\n            return(b1-b0)*st1.y+b0;\n        }\n        \n        bool isBuilding(vec2 uv){\n            for(int j=-CityWidth;j<=CityWidth;j++){\n                for(int n=0;n<5;n++){\n                    float h=float(n)*.01+(random(vec2(floor(uv.x*BuildingWidth+float(j)),n))-.5)/2.+.25;\n                    if(h>=uv.y&&\n                        fract(uv.x*BuildingWidth)-.5-float(j)*1.5<float(CityWidth+1)*1.-float(n)/7.+fract(floor((h-uv.y)*100.*random(vec2(floor(uv.x*BuildingWidth))))/2.)*.1&&\n                        fract(uv.x*BuildingWidth)-.5-float(j)*1.5>-float(CityWidth-2)*float(n)/7.-fract(floor((h-uv.y)*100.*random(vec2(floor(uv.x*BuildingWidth))))/2.)*.1){\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            \n            bool isBalc(vec2 uv){\n                return fract((uv.x+iTime*.3)*3.)<.1||\n                uv.y<.3||\n                (uv.y<.4&&uv.y>.37)||\n                (uv.y<.4&&fract((uv.x+iTime*.35)*10.)<.2);\n            }\n            \n            void mainImage(out vec4 fragColor,in vec2 fragCoord)\n            {\n                fragColor = vec4(0);\n                vec2 uv=fragCoord/iResolution.xy;\n                vec2 sv=uv;\n                uv+=noise(uv*10.+iTime)*.002;\n                uv.x+=iTime/10.-947.2984;\n                if(isBalc(uv)){\n                    if(isBalc(uv+vec2(.005,0))){\n                        if(isBalc(vec2(uv.x+(sv.x-.5)*(sv.y-.3),.5-uv.y))||uv.y>.2)\n                        fragColor=BalcCol;\n                        else\n                        fragColor=lerp(BackCol,BalcCol,.5-uv.y/.5);\n                    }\n                    else\n                    fragColor=BackCol;\n                }\n                else{\n                    bool broke=false;\n                    for(int i=0;i<CityDepth;i++){\n                        float mult=iTime*Paralax*float(CityDepth-i);\n                        if(isBuilding(uv+vec2(mult,0))){\n                            fragColor+=lerp(BackCol,FrontCol,1./float(i+1));\n                            broke=true;\n                            break;\n                        }\n                        if(broke){\n                            break;\n                        }\n                        else{\n                            #ifdef HighQ\n                            vec4 c=lerp(BackCol,FrontCol,1./float(i+1));\n                            fragColor+=c*2.*max(0.,.7+.3*noise(vec2(uv.x+mult,float(i)*292.293))-sv.y);\n                            if(fract(uv.x+mult+.2723)<.1){\n                                fragColor+=vec4(0,0,.1,0)*max(0.,(8.-uv.y*10.));\n                            }\n                            #endif\n                        }\n                        uv.x*=1.1;\n                        uv.y-=1./float(CityDepth)/4.;\n                    }\n                    if(!broke){\n                        fragColor+=lerp(vec4(.9,.5,.2,1),vec4(.01,.01,.2,1.),uv.y);\n                        float f=noise(vec2(iTime*10.,0)+sv*iResolution.xy*.5);\n                        if(f>.95&&noise(vec2(iTime*10.,0)+sv*50.)>.5)\n                        fragColor+=(f-.9)/.1;\n                    }\n                }\n            }\n            ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 318, 353, 353, 379], [381, 381, 403, 403, 510], [528, 528, 549, 549, 1031], [1049, 1049, 1074, 1074, 1803], [1829, 1829, 1850, 1850, 2041], [2067, 2067, 2133, 2133, 4210]], "test": "valid"}
{"id": "WlKBR3", "name": "Distance to Regular Polygon", "author": "oneshade", "description": "Exact distance to a regular n-sided polygon.", "tags": ["2d", "sdf", "distance", "polygon", "regularpolygon", "regular", "exact"], "likes": 5, "viewed": 95, "published": "Public", "date": "1614767719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdRegularPolygon(in vec2 p, in float r, in float n) {\n    float a = 6.28 / n, ha = 0.5 * a, hr = 0.5 * r, c = cos(a), s = sin(a);\n    float e = hr * length(vec2(c - 1.0, s)), er = hr * length(vec2(c + 1.0, s));\n    p = sin(mod(atan(p.y, p.x) + ha, a) - ha + vec2(1.57, 0.0)) * length(p);\n    return length(vec2(p.x -= er, max(0.0, abs(p.y) - e))) * sign(p.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float r = mix(0.2, 0.3, 0.5 + 0.5 * cos(iTime));\n    float n = mix(3.0, 12.0, 0.5 + 0.5 * sin(iTime));\n    float d = sdRegularPolygon(uv, r, n);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 367], [369, 369, 424, 424, 1052]], "test": "valid"}
{"id": "wlKBWK", "name": "Mythic Bird Attractor", "author": "Mrpalland", "description": "Exploration of rendering the 'Mythic Bird' iterative function.", "tags": ["fractal", "interactive", "demo", "attractor", "graph", "function", "iterative"], "likes": 2, "viewed": 140, "published": "Public", "date": "1615161303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Evan Nave 2021\n// Iterative Functions in GLSL: https://www.shadertoy.com/view/MtBGDW\n// Iterative Function Guide: https://www.shadertoy.com/view/3tyfWt\n// 'Mythic Bird' Graph: http://www.atomosyd.net/spip.php?article98\n#define SCALE 20.0\n#define ITERATION 80\n#define PI 3.14159265359\n\nfloat g(float x, float u){\n    return u*x + ((2.*(1. - u)*pow(x, 2.)) / (1. + pow(x, 2.)));\n}\n\n//Mythic Bird\nvec2 mythicEQ(vec2 c,float t){\n\tvec4 z = vec4(c.x*1.6, -c.y, 0.0, 0.0);\n\tvec3 zi = vec3(0.0);\n    vec4 ms = iMouse / iResolution.x;\n    \n    float a = 0.0009;\n    float b = 0.005 - 0.5;\n    float u = -0.801;\n    \n    //Animation\n    u += cos(t*0.1 + 15.7)*0.25 + 0.25;\n    \n    if(ms.z > 0.0){ u =  -0.801 + cos(ms.x*PI*2.0 + 15.7 + PI)*0.25 + 0.25; }\n    \n    float m = -3.5;\n    \n\tfor(int i=0; i<ITERATION; i++){\n\t\tzi.x = z.y + g(z.x, u) + a*z.y*(1. - b*pow(z.y, 2.) + m);\n\t\tzi.y = -z.x + g(zi.x, u);\n        if(length(zi.xy)>80.0)break;\n\t\tz.w++;\n\t\tz.xyz=zi;\n\t}\n\tz.w/=float(ITERATION);\n\treturn 1.0-z.wx;\n}\n\nmat2 rotate2D(float x){\n    return mat2(cos(x), -sin(x), sin(x), cos(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0.);\n    float rt = -iTime*0.1 + 0.5;\n    \n    //Grid UVs and offset correction for Mythic Bird rotation\n    vec2 gv = fract(uv*2.0*rotate2D(rt)) -0.5;\n    vec2 rc = vec2(cos(rt)*0.1, sin(rt)*0.1);\n    \n    //Mythic Bird\n    float mb = mythicEQ(rotate2D(rt)*(uv + rc)*SCALE,iTime).x;\n    \n    mb = 1.0 - mb;\n    mb = smoothstep(0.00, 1., mb);\n    mb = pow(mb, 1.0);\n    mb *= 1.0 - length(uv*0.9) + mb*0.5;\n    \n    col = vec3(mb*0.1, mb*0.5, mb*0.9);\n    \n    //Radial Mask\n    float cm = length(uv) + 0.1 - 0.2*mb/0.005;\n    cm = smoothstep(0., 3., cm);\n    col = mix(col, vec3(0.1, 0.5, 0.5), cm + 0.2 - mb*mb);\n    \n    //Dots to make it pretty\n    float circles = 1.0 - smoothstep(0., 0.02, length(gv) - 0.2 + (1.0 - length(uv*0.6)) - 0.2);\n    col = mix(col, col*1.1, circles);\n    \n    //Gamma\n    col = pow(col, vec3(0.64545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 288, 314, 314, 381], [383, 397, 427, 427, 1004], [1006, 1006, 1029, 1029, 1081], [1083, 1083, 1140, 1140, 2092]], "test": "valid"}
{"id": "wlKBWV", "name": "coloring_from_center1", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 0, "viewed": 162, "published": "Public API", "date": "1615120456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float lx=distance(uv.x,.5)*20.;\n    float ly=distance(.5,uv.y)*20.;\n    float dir=atan(uv.x-.5,uv.y-.5)*10.;\n    \n    vec3 col = 0.5 + 0.3*cos(iTime+uv.xyy+vec3(0,2,4));\n    col+=vec3(.5*cos(lx+dir+iTime),.5*cos(lx+dir+iTime),.5*cos(lx+dir+iTime));\n    col+=vec3(.5*sin(ly+dir+iTime),.5*sin(ly+dir+iTime),.5*sin(ly+dir+iTime));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 464]], "test": "valid"}
{"id": "wlKfWG", "name": "2D Metaballs testing", "author": "Walters", "description": "simple metaballs shader.", "tags": ["metaballs"], "likes": 3, "viewed": 49, "published": "Public", "date": "1614988280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BALL_COUNT 16\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 bgCol = vec3(0.0, 0.0, 0.2);\n    float hWidth = (iResolution.x) * 0.5;\n    float hHeight = (iResolution.y) * 0.5;\n    float scale = max(iResolution.x, iResolution.y) * 0.1;\n    float t = iTime * 0.004;\n    vec2 ballPos[BALL_COUNT] = vec2[BALL_COUNT](\n         vec2(t * 9.0 + 0.0, t * 6.0 + 0.0),\n         vec2(t * 2.0 + 0.0, t * 7.0 + 1.0),\n         vec2(t * 6.0 + 0.0, t * 8.0 + 2.0),\n         vec2(t * 6.0 + 0.0, t * 9.0 + 3.0),\n         vec2(t * 6.0 + 1.0, t * 6.0 + 0.0),\n         vec2(t * 6.0 + 1.0, t * 7.0 + 1.0),\n         vec2(t * 2.0 + 1.0, t * 8.0 + 2.0),\n         vec2(t * 6.0 + 1.0, t * 9.0 + 3.0),\n         vec2(t * 6.0 + 2.0, t * 6.0 + 0.0),\n         vec2(t * 6.0 + 2.0, t * 7.0 + 1.0),\n         vec2(t * 6.0 + 2.0, t * 8.0 + 2.0),\n         vec2(t * 2.0 + 2.0, t * 9.0 + 3.0),\n         vec2(t * 6.0 + 3.0, t * 6.0 + 0.0),\n         vec2(t * 6.0 + 3.0, t * 7.0 + 1.0),\n         vec2(t * 6.0 + 3.0, t * 8.0 + 2.0),\n         vec2(t * 6.0 + 3.0, t * 9.0 + 3.0));                           \n    float ballSize[BALL_COUNT] = float[BALL_COUNT](5.0, 3.0, 2.0, 1.0,\n                                                   1.0, 5.0, 3.0, 2.0,\n                                                   2.0, 1.0, 5.0, 3.0,\n                                                   3.0, 2.0, 1.0, 5.0);    \n    float ballFactor = 0.0;\n    for(int i = 0; i < BALL_COUNT; i++)\n    {\n        vec2 pos = vec2(hWidth + sin(ballPos[i].x) * hWidth, \n                        hHeight + sin(ballPos[i].y) * hHeight);\n        float newDist = min(length(pos - fragCoord), ballSize[i] * scale);\n        newDist = 1.0f - newDist / (ballSize[i] * scale);\n        ballFactor += newDist * newDist;\n    }\n    ballFactor = min(ballFactor, 1.0);\n    float glow = ballFactor * 0.25;\n    ballFactor = smoothstep(-1.5*fwidth(ballFactor), 0.0, ballFactor - 0.5);\n    glow = max(0.0, glow - ballFactor);\n    col = bgCol + (col - bgCol) * ballFactor + (col - bgCol) * glow;  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 2254]], "test": "valid"}
{"id": "WllcR4", "name": "GenNoiseWindows", "author": "legavroche", "description": "Exercises for testing noise", "tags": ["noise"], "likes": 4, "viewed": 56, "published": "Public", "date": "1616089716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Threshold(vec3 col, float threshold)\n{\n    if (col.r < threshold)\n    {\n     \treturn 0.0f;\n    }\n    return 1.0f;\n}\n\nfloat Random(float t)\n{\n \treturn fract(sin(t) * 1e4);   \n}\n\n// Returns a pseudorandom value from [0,1]\nfloat Random(vec2 uv)\n{    \n\treturn fract(sin(dot(uv, vec2(12.313, 53.34))) * 100000.0f);\n    //return fract(sin(dot(uv, vec2(12.313, 53.34))) * 10000.0f);\n}\n\n//Gradient of rows/column\nvec3 GradientColor(float x, float y)\n{\n\treturn vec3(\n        x,\n        y,\n        1.0f\n   \t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 grid = vec2(100.0f, 50.0f);    \n    vec2 ipos = uv * grid;      \n   \t\n    float shiftFactor = iTime * 20.0f * Random(floor(ipos.y))*0.5f + 0.5f;\n    if (mod(floor(ipos.y), 2.0f) == 0.0f)\n    \tipos.x -= shiftFactor;\n    else\n    \tipos.x += shiftFactor;\n    \n    ipos.x -= shiftFactor;\n    \n    ipos = floor(ipos);\n            \n    vec3 col = vec3(Random(ipos));\n    col = vec3(Threshold(col, 0.3f));\n   \n    // generate margins\n    vec2 fpos = fract(uv * grid);\n    \n    col *= step(0.2f, fpos.y);    \n    \n    float pctX = smoothstep(0.5f-0.005f, 0.5f, uv.x) - smoothstep(0.5f, 0.5f+0.005f, uv.x);\n    float pctY = smoothstep(0.5f-0.01f, 0.5f, uv.y) - smoothstep(0.5f, 0.5f+0.01f, uv.y);\n    \n    //col *= GradientColor(uv.x, uv.y);\n    // Diff color for each window  \n    if (uv.x < 0.5f && uv.y > 0.5f)\n    {\n      \tcol *= vec3(1.0f, 0.5f, 0.5f);\n    }\n    else if (uv.x < 0.5f && uv.y < 0.5f)\n    {\n       \tcol *= vec3(0.5f, 0.5f, 1.0f);\n    }\n    else if (uv.x > 0.5f && uv.y < 0.5f)\n    {\n       \tcol *= vec3(1.0f, 1.0f, 0.5f);\n    }\n    else if (uv.x > 0.5f && uv.y > 0.5f)\n    {\n       \tcol *= vec3(0.5f, 1.0f, 0.5f);\n    }\n    \n    col = (1.0f-pctX)*col;\n    col *= (1.0f-pctY)*col;\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 121], [123, 123, 146, 146, 181], [183, 226, 249, 249, 383], [385, 411, 449, 449, 507], [509, 509, 566, 616, 1917]], "test": "valid"}
{"id": "Wlt3Wn", "name": "sunset -- therealjoe", "author": "TheRealJoe24", "description": "sunset", "tags": ["sun"], "likes": 2, "viewed": 26, "published": "Public", "date": "1615170461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 gradient(vec3 col1, vec3 col2, vec3 col3, float t1, float t2) {\n\treturn mix(mix(col1, col2, t1), col3, t2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = gradient(vec3(1, 0, 0), vec3(0, 0, 0), vec3(1, 1, 0), uv.y+0.25, uv.y+1.);\n    \n    float d = length(uv+vec2(0, cos(iTime)));\n    d = smoothstep(d, 0., 0.1);\n    col -= d;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlt3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 114], [116, 116, 173, 173, 455]], "test": "valid"}
{"id": "wltfz2", "name": "Open End Tube (Test Tube) SDF", "author": "oneshade", "description": "Branchless and exact test tube SDF without trig.", "tags": ["3d", "raymarching", "sdf", "exact", "openendtube", "testtube", "notrig"], "likes": 4, "viewed": 60, "published": "Public", "date": "1616087697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// a: position of the tube opening\n// b: position of the tube base\n// r: tube radius\n// t: tube thickness\nfloat sdHalfTube(in vec3 p, in vec3 a, in vec3 b, in float r, in float t) {\n     vec3 pa = p - a, ba = b - a;\n     float h = length(ba), hh = 0.5 * h;\n     vec2 p2 = vec2(length(pa - ba * dot(pa, ba) / dot(ba, ba)), dot(pa, ba) / h);\n     float tube = length(vec2(p2.x - r, max(0.0, abs(p2.y - hh) - hh))) - t;\n     float base = max(p2.y, abs(length(p2) - r) - t);\n     return mix(base, tube, step(0.0, p2.y));\n}\n\nvec2 mapScene(in vec3 p) {\n    float t1 = iTime * 0.75, t2 = iTime * 1.25, t3 = iTime * 1.5;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(c3, 0.25 + 0.75 * s2, c1) * 2.0;\n    vec3 b = vec3(c2, 0.25 + 0.75 * s1, s3) * 2.0;\n    float r = 0.75 + 0.375 * sin(iTime);\n    float t = 0.125 + 0.0625 * cos(iTime);\n\n    float tube = sdHalfTube(p, a, b, r, t);\n    float da = length(p - a) - 0.125;\n    float db = length(p - b) - 0.125;\n\n    return tube < min(da, db) ? vec2(tube, 0) : da < db ? vec2(da, 1) : vec2(db, 2);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0;\n    for (int i=0; i < 250; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            int id = int(d.y);\n\n            float diff = sqrt(max(0.0, dot(-rd, n)));\n            if (id == 0) {\n                fragColor.rgb = vec3(diff);\n            }\n\n            if (id == 1) {\n                fragColor.rgb = vec3(0.0, 0.0, diff);\n            }\n\n            if (id == 2) {\n                fragColor.rgb = vec3(diff, 0.0, 0.0);\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n\n    // Ground plane\n    if (rd.y != 0.0) {\n        float tPlane = -(2.0 + ro.y) / rd.y;\n        if (tPlane > 0.0 && (t < 20.0 ? tPlane < t : true)) {\n            vec3 iPlane = ro + rd * tPlane;\n            vec3 planeColor = vec3(1.0);\n\n            // Grid\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.x + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(0.0, 0.0, 1.0), smoothstep(0.025, 0.0, abs(mod(iPlane.z + 0.25, 0.5) - 0.25)));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.x) - 0.01));\n            planeColor = mix(planeColor, vec3(1.0, 0.0, 0.0), smoothstep(0.025, 0.0, abs(iPlane.z) - 0.01));\n\n            planeColor -= exp(-mapScene(iPlane).x);\n            planeColor /= max(1.0, 0.2 * tPlane); // Fade (can hide a bit of aliasing too)\n\n            fragColor.rgb = mix(fragColor.rgb, planeColor, 0.6);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 106, 181, 181, 518], [520, 520, 546, 546, 1123], [1125, 1125, 1152, 1152, 1411], [1413, 1413, 1468, 1468, 3766]], "test": "valid"}
{"id": "WlVBWV", "name": "strobo nights", "author": "sus1357", "description": "newbie's shit", "tags": ["stroboscopic"], "likes": 2, "viewed": 56, "published": "Public", "date": "1615076582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float a = 5.*iTime+uv.x;\n    float b = 1.*iTime+uv.x+2.*uv.y;\n    float c = 10.*iTime+uv.x-2.*uv.y;\n    \n    vec3 black = vec3(0,0,0);\n    vec3 red = vec3(1,0,0);\n    vec3 skyblue = vec3(0,0.5,1);\n    vec3 grey = vec3(0.2,0.3,0.5);\n    \n    vec3 col = red*cos(20.*a)\n                    +\n               skyblue*cos(b)+cos(2.*b)+0.5*cos(5.*b)\n                    +\n               grey*sin(c);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 585]], "test": "valid"}
{"id": "WlVBWy", "name": "Test face", "author": "brosty", "description": "face", "tags": ["face"], "likes": 2, "viewed": 39, "published": "Public", "date": "1614978287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n  \n  float d = length(uv-p); \n  float c = smoothstep(r,r-blur,d);\n  return c;\n\n}\n\nfloat Band(float t, float start, float end, float blur){\n\n    float step1 = smoothstep(start-blur, start+blur,t);\n    float step2 = smoothstep(end+blur, end-blur,t);\n    return step1*step2;\n\n}\n\nfloat Rect(vec2 uv, vec2 center, float size, float left, float right, float bottom, float top, float blur){\n    uv-= center;\n    uv/= size;\n\nfloat band1 = Band(uv.x, left, right, blur);\nfloat band2 = Band(uv.y, bottom, top, blur);\nreturn band1*band2;\n}\n\nmat2 rotationMat(float a){\n    float c= cos(a);\n    float s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat Smiley(vec2 uv, vec2 p, float rot, float size){\n\n    uv -= p; //translate coordinate system\n    uv/= size; //scale coord sys\n    uv=  rotationMat(rot)*uv; \n// anticlock wiste uv*= rotationMat(rot);\n\n  float mask = Circle(uv,vec2(0,0), .4, .05);\n   \n   mask -= Circle(uv,vec2(-.13,.075), .08, .02); //eyes\n   mask -= Circle(uv,vec2(.13,.075), .08, .02); //eyes\n   \n  float mouth = Circle(uv, vec2(0.,-0.02), .27, .025);\n     mouth -= Circle (uv, vec2(0.,.025*sin(iTime*5.)+.14),.36,.03);\n     mask -= clamp(mouth, 0., 1.);\n   \nreturn mask;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord/iResolution.xy;   // Normalized pixel coordinates (from 0 to 1)\n    \n    uv-= .5; // -0.5 to .5\n    uv.x*= iResolution.x/iResolution.y; //ratio fix\n    \n   // uv*=  rotationMat(0.25); \n  \n float movingCenter = .05*sin(iTime*5.);  \n float SmileyFace = Smiley(uv, vec2(0.25,.15*cos(iTime*5.)),iTime*-2.5,.5);\n float SmileyFace2 = Smiley(uv, vec2(-0.25,.15*sin(iTime*5.)),iTime*3.5,.6);\n // float rectangle = 0.;\n//  rectangle = Rect(uv,vec2(-.2,.2*sin(iTime*5.)),.5, -.2, .2,-.3,.3, .01);\n   vec3 col = vec3(0);\n   col = vec3(0.,1.,0.)*SmileyFace + vec3(1.,0.,0.)*SmileyFace2;\n   fragColor = vec4(col,1.);\n   \n}\n\n\n\n//if(d<.3)c=1.; else c=0.;", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVBWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 52, 52, 133], [135, 135, 191, 191, 327], [329, 329, 436, 436, 581], [583, 583, 609, 609, 679], [681, 681, 734, 734, 1227], [1231, 1231, 1288, 1288, 1925]], "test": "valid"}
{"id": "wlVfD3", "name": "RasterizerTesting", "author": "CoderHusk", "description": "Following this tutorial https://www.youtube.com/watch?v=dKA5ZVALOhs&t=228s", "tags": ["rasterization"], "likes": 0, "viewed": 40, "published": "Public", "date": "1615228299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float evaluateMagnitude(vec3 rayOrigin, vec3 rayDirection, vec3 location) {\n    return length(cross(location-rayOrigin, rayDirection))/length(rayDirection);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - 0.5;\n    uv.x = uv.x * iResolution.x/iResolution.y;\n\n    vec3 camOrigin = vec3(0, 0,-2);\n    vec3 camDirection = vec3(uv.x, uv.y, 0) - camOrigin;\n    vec3 loc = vec3(cos(iTime)*4.0,sin(iTime)/2.0,10.0);\n    float magnitude = evaluateMagnitude(camOrigin, camDirection, loc);\n    magnitude = smoothstep(0.5, 0.0, magnitude);\n    fragColor = vec4(magnitude);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 75, 75, 158], [159, 159, 216, 216, 628]], "test": "valid"}
{"id": "WlVfRy", "name": "direct volume rendering", "author": "wuerzig", "description": "platform for direct volume rendering experiments", "tags": ["volumerendering"], "likes": 4, "viewed": 118, "published": "Public", "date": "1614683782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Created by wuerzig 2021\n * Based on https://www.shadertoy.com/view/4ddXW4 (noise, hash, mainImage) \n * by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n */\nconst float FOV = 0.9;\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n    // clamp volume to +- 10.0\n    if (abs(x.x) > 10.0)\n        return 0.0;\n\tif (abs(x.y) > 10.0)\n        return 0.0;\n\tif (abs(x.z) > 10.0)\n        return 0.0;\n\n\n\t// scale volume frequency\n    x = x * vec3(.6);\n\n    vec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\t\n\n    return mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nmat3 rotationY(float angle) {\n\treturn mat3(\tcos(angle),\t\t0,\t\tsin(angle),\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle));\n}\n\n\nvec3 emission(float voxelValue) {\n    vec3 result = vec3(voxelValue, voxelValue, voxelValue);\n    if (voxelValue > 0.7) {\n        result = result * vec3(0.98f, 0.52f, 0.32f);\n    } else {\n        \n        if (voxelValue > 0.3) {\n            // 0.3..0.7\n            result = result * vec3(0.98f, 0.84f, 0.4f);\n        \n        } else {\n            // 0..0.3\n            result = result * vec3(0.16f, 0.71f, 0.79f) * vec3(2.0);\n        }\n        \n    }\n    \n    return result;\n}\n\nfloat transmittance(float density) {\n    return exp(-density);\n}\n\n\nfloat raymarch_max(vec3 ro, vec3 rd, float t) {\n    \n    float raymarchStep = 0.1;\n    int raymarchMaxStep = 400;\n    int step = 0;\n    float accumulator = 0.0;\n    vec3 y = vec3(0.0);\n    float voxelMax = 0.0;\n    while (step < raymarchMaxStep) {\n        step++;\n        \n        y = ro + t*rd;\n        float voxelValue = noise(y);\n        \n        if (voxelValue > voxelMax)\n            voxelMax = voxelValue;\n        \n        t += raymarchStep;\n    }\n    \n    return voxelMax;\n}\n\n\n\nfloat raymarch_density(vec3 ro, vec3 rd, float t) {\n    \n    float raymarchStep = 0.1;\n    int raymarchMaxStep = 400;\n    int step = 0;\n    float accumulator = 0.0;\n    vec3 y = vec3(0.0);\n    while (step < raymarchMaxStep) {\n        step++;\n        \n        y = ro + t*rd;\n        float voxelValue = noise(y);\n        \n        // scale so avg. density is 0.5 per unit length\n        // 0.5 because the noise is uniform and 0..1\n        accumulator += voxelValue * raymarchStep;\n        \n        t += raymarchStep;\n    }\n    \n    return accumulator;\n}\n\nvec3 raymarch_classify(vec3 ro, vec3 rd, float t) {\n    \n    vec3 result = vec3(0.0f);\n    float raymarchStep = 0.1;\n    int raymarchMaxStep = 400;\n    int step = 0;\n    float accumulator = 0.0;\n    vec3 y = vec3(0.0);\n\n    while (step < raymarchMaxStep) {\n        step++;\n        \n        y = ro + t*rd;\n        float voxelValue = noise(y);\n\n        accumulator += voxelValue * raymarchStep;\n        result = result + emission(voxelValue)*transmittance(accumulator) * 0.1; // mu_a\n\n        t += raymarchStep;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = ( 2.*fragCoord -  iResolution.xy )  / iResolution.y;\n\tcoord *= FOV;\n\n    //swap lines to stop rotation\n    //vec3 ro = vec3(15.0, 15.0, 15.0);\n    vec3 ro = vec3(12.0, 12.0, 12.0) * rotationY(iTime);\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(target - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 upOrtho = normalize(up - dot(dir, up) * dir);\n    vec3 right = normalize(cross(dir, upOrtho));\n    vec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\n\n    vec3 col;\n    if ((fragCoord.x/iResolution.x) > 0.65) {\n        float density = raymarch_density(ro, rd, 0.0);\n        col = vec3(1.0-transmittance(density * 0.3)); // mu_a\n    } else {\n        if ((fragCoord.x/iResolution.x) > 0.35) {\n            col = raymarch_classify(ro, rd, 0.0);\n        } else {\n            float maxValue = raymarch_max(ro, rd, 0.0);\n            col = vec3(maxValue);\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVfRy.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[0, 275, 296, 296, 337], [339, 339, 360, 391, 925], [927, 927, 956, 956, 1059], [1062, 1062, 1095, 1095, 1538], [1540, 1540, 1576, 1576, 1604], [1607, 1607, 1654, 1654, 2088], [2092, 2092, 2143, 2143, 2643], [2645, 2645, 2696, 2696, 3186], [3188, 3188, 3245, 3245, 4199]], "test": "valid"}
{"id": "wlVfWG", "name": "Circular plasma", "author": "Chosen", "description": "Hi guys! Few minutes and achieved what I wanted to. :-)", "tags": ["circleplasma"], "likes": 5, "viewed": 53, "published": "Public", "date": "1614991152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 motionFunction (float i) {\n  float t = iTime;\n\n  return vec2(\n    (cos(t * .31 + i * 3.) + cos(t * .11 + i * 14.) + cos(t * .78 + i * 30.) + cos(t * .55 + i * 10.)) / 4.,\n    (cos(t * .13 + i * 33.) + cos(t * .66 + i * 38.) + cos(t * .42 + i * 83.) + cos(t * .9 + i * 29.)) / 4.\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.x;\n    \n    float alias = 100. + 40. * motionFunction(7.).x;\n    uv = floor(uv * alias) / alias;\n    vec2 uv1 = uv + motionFunction(1.);\n    vec2 uv2 = uv + motionFunction(2.);\n    vec2 uv3 = uv + motionFunction(3.);\n    vec3 col1 = .5 + .5 * cos(length(uv1) * 20. + uv1.xyx + vec3(0, 2, 4));\n    vec3 col2 = .5 + .5 * cos(length(uv2) * 10. + uv2.xyx + vec3(0, 2, 4));\n    vec3 col3 = .5 + .5 * cos(length(uv3) * 10. + uv3.xyx + vec3(0, 2, 4));\n    vec3 col = col1 - col2 + col3;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 290], [292, 292, 349, 349, 925]], "test": "valid"}
{"id": "wlVfWV", "name": "Somthing_1", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 1, "viewed": 161, "published": "Public API", "date": "1615204316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define al .5;\n#define al_1 .98;\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 out_rect(vec2 coord, vec2 loc, vec2 size){\n    vec2 sw=loc-size/2.;\n    vec2 ne=loc+size/2.;\n    vec2 pct=smoothstep(sw,sw+.04,coord);\n    pct-=smoothstep(ne-.04,ne,coord);\n    \n    return vec3(pct.x * pct.y);\n}\n\nvec3 cir(vec2 coord, vec2 loc,  float ln){\n    float d=1.-distance(coord,loc);\n    d=smoothstep(ln*.85,ln,d);\n    d*=al;\n    return vec3(d+ 0.1*cos(-iTime+coord.yxy+vec3(0,2,4)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= fragCoord.x/iResolution.x;\n    uv.y *= fragCoord.x/iResolution.y;\n    for(float i=0.; i<5.;i++){\n    uv=abs(uv*2.-1.);\n    }\n    \n    uv*=.8+.3*sin(iTime*1.2);\n    uv*=Rot(3.141592/3.*sin(iTime*.5));//(50.+25.*sin(iTime*.7)));\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col*=cir(uv,vec2(.5),.3);\n    //col*=out_rect(uv,vec2(.5),vec2(.6));\n    col+=cir(uv,vec2(.5),.7);\n    \n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 53, 53, 112], [114, 114, 161, 161, 330], [332, 332, 374, 374, 513], [516, 516, 573, 573, 1050]], "test": "valid"}
{"id": "wlVfzt", "name": "Baby's First Raymarch", "author": "plinky", "description": "You must give a description to your shader", "tags": ["raymarch"], "likes": 0, "viewed": 160, "published": "Public API", "date": "1614913116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURF_DIST 0.1\n\nfloat getSphere(vec3 point) {\n    // leftright, above ground plane, away from camera, radius\n    vec4 sphere = vec4(0, sin(iTime), 6, 1);\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat getPlane(vec3 point) {\n    return point.y;\n}\n\nfloat getDist(vec3 point) {\n    return min(\n        getSphere(point),\n        min(\n            getPlane(point),\n            getSphere(point) + 0.001\n        )\n    );\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDistance) {\n    float dO = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 marchLocation = rayOrigin + rayDistance * dO;\n        float ds = getDist(marchLocation);\n        dO += ds;\n        if(dO > MAX_DISTANCE || ds < SURF_DIST) {\n            break;\n        }\n    }\n    \n    return dO;\n}\n\n\nvec3 getNormal(vec3 point) {\n    float distance = getDist(point);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = distance - vec3(\n        getDist(point - e.xyy),\n        getDist(point - e.yxy),\n        getDist(point - e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nfloat getLight(vec3 point) {\n    vec3 lightPosition = vec3(0, 5, 6);\n    lightPosition.xz += vec2(sin(iTime), cos(iTime)) * 10.0;\n    vec3 light = normalize(lightPosition - point);\n    vec3 normal = getNormal(point);\n\n    float shadow = 1.0;\n    float d = rayMarch(point + normal * SURF_DIST * 2.1, light);\n    if(d < length(lightPosition - point)) {\n        shadow = 0.5;\n    }\n    \n    return shadow * clamp(dot(normal, light), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float distance = rayMarch(rayOrigin, rayDirection);\n    \n    vec3 point = rayOrigin + rayDirection * distance;\n    float diffuseLighting = getLight(point);\n    \n    vec3 col = vec3(distance);\n    col = vec3(diffuseLighting);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 101, 164, 261], [263, 263, 291, 291, 313], [315, 315, 342, 342, 482], [484, 484, 534, 534, 823], [826, 826, 854, 854, 1098], [1100, 1100, 1128, 1128, 1542], [1544, 1544, 1601, 1651, 2106]], "test": "valid"}
{"id": "WlyBRd", "name": "Trig-less Hash", "author": "Rugged", "description": "Hash function with no trig function. ", "tags": ["noise", "hash", "sinless"], "likes": 1, "viewed": 64, "published": "Public", "date": "1614922972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//summary: hash3 is barely slower but gives noise with all values\n//         from 0. to 1. (hash3 = better)\n\n\n\n//this hash doesn't have every value 0. to 1. but still works if you need noise\n//next hash has all numbers 0. to 1.\nfloat hash(vec2 xy){\n    xy = mod(xy, 0.19) + 0.5;\n    float h = dot(xy.yyx, xy.yxy + vec3(.013, 27.15, 2027.3));\n    h *= h;\n    \n    return fract(h);\n}\n\n\n//this hash gives good noise and has all numbers 0. to 1., \n//it is very slightly slower\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(vec3(hash3(uv + iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyBRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 228, 248, 248, 381], [384, 473, 494, 494, 630], [633, 633, 690, 690, 785]], "test": "valid"}
{"id": "wlyBWc", "name": "Pine Background", "author": "Buccellato", "description": "Topography background for poweredbypine.com", "tags": ["noise", "lines", "perlin", "map", "contours", "smooth", "topography", "topology"], "likes": 5, "viewed": 282, "published": "Public", "date": "1615170616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///\n/// A topographic background for www.poweredbypine.com\n/// Optimized for mobile hardware. Should run at 60+ on newer phones now. YMMV.\n/// (Values are tuned for a browser view size so it looks a little fuzzier in the shadertoy preview)\n///\nfloat topologize(float noise) // Turn the Perlin(ish) Noise into Topography(ish) Noise\n{\n    float smoothFloor = noise*12.0;\n    vec2 fracU = vec2(smoothFloor,fwidth(smoothFloor)*1.3);// Screen-Space Derivative Anti-Aliasing  \n    fracU.x = fract(fracU.x);\n    fracU += (1.0 - 2.0*fracU)*step(fracU.y,fracU.x);\n    smoothFloor = smoothFloor - clamp(1.0 - fracU.x/fracU.y,0.0,1.0);  // Smooth-Fract Shenanigans \n    return noise*0.25 + smoothFloor*0.75/11.0; //Setting # of Divisions\n}\n\nvec3 hash33(vec3 p) // iq - \"replace this by something better. really. do\"\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/*vec3 hash33(vec3 p) // Hash Function for random weights\n{\n    float n = sin(dot(p,vec3(7.0,157.0,113.0)));\n    return fract(32768.0*n*vec3(64.0,8.0,1.0))*2.0 - 1.0;\n}*/\n\nfloat tetraNoise(vec2 o) // Perlin(ish) Noise Function adapted from Stefan Gustavson's 'Simplex Noise Demystified' (Math)\n{\n    vec3 p = vec3(o.x + 0.008*iTime, o.y + 0.004*iTime,0.005*iTime);\n    vec3 i = floor(p + dot(p, vec3(0.33333,0.33333,0.33333)));\n    p -= i - dot(i, vec3(0.16666,0.16666,0.16666));\n    vec3 i1 = step(p.yzx, p);\n    vec3 i2 = max(i1, 1.0-i1.zxy);\n    i1 = min(i1, 1.0-i1.zxy);\n    vec3 p1 = p - i1 + 0.16666, p2 = p - i2 + 0.33333, p3 = p - 0.5;\n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.0)));\n    float n = clamp(dot(d,v*v*v*8.)*1.732 + 0.5, 0., 1.);\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) //Meta-structure adapted from Shane - https://www.shadertoy.com/view/ldscWH (Thank you!)\n{\n    vec2 p = (fragCoord.xy*2.5 - iResolution.xy)/(iResolution.y/2.0 + iResolution.x/2.0);// Convert Coords\n    vec2 e = vec2(10.0/(iResolution.y+iResolution.x),0.0); // Sample Distance for Four Samples\n    float fxl = topologize(tetraNoise(p + e.xy)); // Left\n    float fxr = topologize(tetraNoise(p - e.xy)); // Right\n    float fyu = topologize(tetraNoise(p + e.yx)); // Up\n    float fyd = topologize(tetraNoise(p - e.yx)); // Down\n    float weight =  clamp((max(abs(fxl-fxr),abs(fyu - fyd))-0.01)*12.0,0.0,1.0); // Edge Detection Weight\n    fragColor = mix(vec4(0.11,0.11,0.11,1),vec4(0.18,0.18,0.18,1),weight); // Lerp between colors based off weighting. In this case, gray and gray.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 244, 332, 332, 728], [730, 730, 806, 806, 999], [1001, 1173, 1296, 1296, 1913], [1915, 1915, 2061, 2061, 2750]], "test": "valid"}
{"id": "wlyBWy", "name": "AODOFractal", "author": "efairbanks", "description": "MouseX: change depth of field\nMouseY: morph fractal\n\nFork of DOFractal /w global-illum-based ambient occlusion. Runs @ ~40FPS on an NVidia GTX2060.", "tags": ["raymarching", "fractal", "dof", "kifs"], "likes": 1, "viewed": 66, "published": "Public", "date": "1614962672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    p+=10.;\n    float r=fract(fract(dot(p.x*1.3242413, p.y*3.346346)*342.23523523)*232.23423)*2.-1.;\n    return r*r;\n}\nfloat cube(vec3 p, float s) {\n    p=abs(p);\n    return max(p.x,max(p.y,p.z))-s;\n}\nvec2 c2p(vec2 p) {return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(vec2 p) {return vec2(cos(p.x),sin(p.x))*p.y;}\nfloat map(vec3 p) {\n    vec3 ac=p;\n    vec3 sc=p;\n    float my=iMouse.y/iResolution.y;\n    for(int i=0;i<9;i++) {\n        ac.xy=p2c(c2p(ac.xy)+vec2(mix(0.3,1.6,my),0.));\n        ac.xz=p2c(c2p(ac.xz)+vec2(mix(2.0,.4,my),0.));\n        ac=abs(ac)-0.1;\n        sc.xy=p2c(c2p(sc.xy)+vec2(mix(2.3,.6,my),0.));\n        sc.xz=p2c(c2p(sc.xz)+vec2(mix(0.1,1.2,my),0.));\n        sc=abs(sc)-0.15;\n    }\n    return max(cube(ac,0.2),-cube(sc,0.14));\n}\nvec3 gradient(vec3 p) {\n    vec2 e=vec2(0.,0.01);\n    return normalize(vec3(\n                map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy)\n            ));\n}\nvec3 pixel(vec2 p, vec3 o) {\n    vec3 t=vec3(0.);\n    vec3 fwd=normalize(t-o);\n    vec3 right=cross(fwd,normalize(vec3(0.,-1.,0.)));\n    vec3 up=cross(fwd,right);\n    vec3 r=normalize(fwd+right*p.x+up*p.y);\n    // focal stuff\n    vec3 fp=o+r*mix(1.,3.,iMouse.x/iResolution.x);\n    o=o+(sin(rand(p.xy*1.235313)*3.145)*right+sin(rand(p.yx*0.82352332)*3.145)*up)*0.06;\n    r=normalize(fp-o);\n    // bounce\n    float dt;\n    float dtt=0.;\n    vec3 absorb=vec3(0.89,0.93,0.95);\n    for(int b=0;b<4;b++) {\n        dt=0.01;\n        for(int i=0;i<90;i++) {\n            float d=map(o+r*dt);\n            if(d<0.005) {dtt+=dt;absorb*=absorb;break;};\n            dt+=d*0.85;\n        }\n        o=o+r*dt;\n        r=reflect(r,gradient(o));\n    }\n    return vec3(absorb*2.)/pow(2.,dtt);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    if(length(uv)>0.9) {fragColor=vec4(0.5);return;}\n    vec3 col = vec3(0.);\n    int ssaa=4;\n    for(int i=0;i<ssaa;i++) {\n        vec2 offset=vec2(rand(uv)+float(i),rand(uv*vec2(1.234324,0.943534)+vec2(7.345346,11.346443)+float(i)*0.57458));\n        col+=pixel(uv+offset*0.5/iResolution.xy, vec3(cos(iTime),sin(iTime*0.7)*0.8,sin(iTime))*2.2)/float(ssaa);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 139], [140, 140, 169, 169, 221], [222, 222, 240, 240, 278], [279, 279, 297, 297, 333], [334, 334, 353, 353, 771], [772, 772, 795, 795, 994], [995, 995, 1023, 1023, 1767], [1768, 1768, 1825, 1825, 2307]], "test": "error"}
{"id": "wlyBzc", "name": "Haru86_Quaternion Juria", "author": "Haru86_", "description": "Haru86_Quaternion Juria", "tags": ["raymarching"], "likes": 7, "viewed": 120, "published": "Public", "date": "1615296115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x - a.z * b.w + a.w * b.z,\n        a.x * b.z + a.y * b.w + a.z * b.x - a.w * b.y,\n        a.x * b.w - a.y * b.z + a.z * b.y + a.w * b.x\n    );\n}\n\nvec2 pmod(vec2 p,float n)\n{\n    float a=(2.0*PI)/n;\n    float t=atan(p.x,p.y)-PI/n;\n    t=mod(t,a)-PI/n;\n    return vec2(0.75*length(p)*cos(t),0.75*length(p)*sin(t));\n}\n\n\n#define ITERATIONS 16\nfloat deQuaternionJuliaSet(vec4 p, vec4 c) {\n    vec4 z = p;\n    vec4 dz = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 pz, pdz;\n    float r = 0.0, dr = 1.0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        pz = z;\n        z = qmul(pz, pz) + c;\n        pdz = dz;\n        dz = 2.0 * qmul(pz, pdz);\n        r = length(z);\n        dr = length(dz);\n        if (r > 4.0) break;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat de(vec3 p) {\n    return deQuaternionJuliaSet(vec4(p, 0.0), vec4(-1.0, 0.2, 0.0, 0.0));\n}\n\nfloat Cube(vec3 p,vec3 s)\n{\n    p=abs(p);\n    return length(max(p-s,0.0));\n}\n\nfloat sdCross(vec3 p,float s)\n{\n    p=abs(p);\n    float dxy=max(p.x,p.y);\n    float dyz=max(p.y,p.z);\n    float dzx=max(p.z,p.x);\n    return min(dxy,min(dyz,dzx))-s;\n}\n\nfloat menger(vec3 pos)\n{\n    float d=Cube(pos,vec3(0.95));\n    \n        //!!!!!!!!!!!!!!  1.0-4.0\n            float s=3.;\n\n        //!!!!!!!!!!!!!!!! 1.0-2.0\n        float scale=1.0;\n\n        for(int h=0;h<3;h++)\n        {\n            //!!!!!!!!!1.0-2.0\n            float k=2.; \n\n            pos=mod(pos*s,k)-k*0.5;\n            //pos.xz=pf(p.xz,4.0);\n            pos=1.0-scale*abs(pos);\n            s*=scale;\n             //!!!!!!!!!!!!!!!!! 0.5-1.0\n            d=max(d,sdCross(pos,\n            .7)/s);  \n\n        }\n\n    return d;\n}\n\n\nfloat map(vec3 p)\n{\n    \n    vec3 pos=p;\n    float d=length(pos)-0.45;\n    d=1000.0;\n    pos.xy*=rot(PI/2.0);\n    float j=2.0;\n    pos.x=mod(pos.x,j)-j*0.5;\n    pos.x=abs(pos.x);\n    float d1=de(pos);\n    \n    \n    ////////////////////////////////////////////\n   \n   vec3 pos2=p;\n   pos2.xy*=rot(PI/2.0);\n \n    for(int i=0;i<6;i++)\n    {\n         float cvalue=1.5;\n       vec3 c=vec3(\n            (rand(vec2(float(i),0.321)))*cvalue,\n            (rand(vec2(float(i),0.654)))*cvalue,\n            (rand(vec2(float(i),0.987)))*cvalue\n        );\n       pos2.z=abs(pos2.z)-c.x;\n       pos2=abs(pos2)-c.y;\n       \n       \n        vec3 b=vec3(\n            (rand(vec2(float(i),0.321)))*4.0*PI-2.0*PI,\n            (rand(vec2(float(i),0.654)))*4.0*PI-2.0*PI,\n            (rand(vec2(float(i),0.987)))*4.0*PI-2.0*PI\n        );\n        pos2.xy*=rot(b.x);\n        pos2.xz*=rot(b.y);\n        pos2.yz*=rot(b.z);\n        \n      \n        \n    }\n      pos2.z=abs(pos2.z)-1.;\n    float s=0.2;\n    pos2=abs(pos2)-10.0*s;\n    pos2=abs(pos2)-2.0*s;\n    pos2=abs(pos2)-3.0*s;\n    pos2=abs(pos2)-6.0*s;\n   \n    float d2=menger(pos2);\n\n   return min(d1,d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)\n    /min(iResolution.x,iResolution.y);\n    \n    vec3 col=vec3(0.0);\n    \n    \n   \n   float radius=.9;\n   float speed=-.25;\n    vec3 ta=vec3(0.);\n    vec3 ro=vec3(cos(iTime*speed)*radius,sin(iTime*0.5)*0.25,sin(iTime*speed)*radius);\n    \n    vec3 cDir=normalize(ta-ro);\n    vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n    vec3 cUp=cross(cDir,cSide);\n    float depth=1.;\n    vec3 rd=vec3(uv.x*cSide+uv.y*cUp+cDir*depth);\n    \n    float d,t,acc=0.0;\n    for(int i=0;i<128;i++)\n    {\n        d=map(ro+rd*t);\n        if(d<0.001||t>100.0)break;\n        t+=d*0.75;\n        acc+=exp(-3.0*d);\n    }\n    \n    //vec3(exp(-2.5*t))+\n    col=vec3(1.,0.5,0.5)*acc*0.03;\n    col+=vec3(1.,.5,0.5)*acc*exp(-6.*t);\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 94, 94, 164], [167, 167, 194, 194, 439], [441, 441, 468, 468, 609], [634, 634, 678, 678, 1040], [1042, 1042, 1060, 1060, 1136], [1138, 1138, 1165, 1165, 1214], [1216, 1216, 1247, 1247, 1383], [1385, 1385, 1409, 1409, 1917], [1920, 1920, 1939, 1939, 3053], [3055, 3055, 3112, 3112, 3887]], "test": "valid"}
{"id": "WlyfDc", "name": "kifs 2d _4 (interactive)", "author": "sus1357", "description": "just look at that sweet boi\npause to play with non-strobo version, or don't pause (unless u have epilepsy maybe)", "tags": ["fractal", "interactive", "ifs"], "likes": 3, "viewed": 41, "published": "Public", "date": "1615158417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    // ekrannaya konstanta - RAZMER OBLASTI CHISEL(a chto esli NE konstanta?...)\nvec2 DOMAIN_XY = vec2(8., 5.);\n\n    // KIFS-konstanti\nconst int N = 2;// N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 2; // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 3;// WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n    //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n    //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n    //1d gauss\n    // ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n    //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n \n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n    // initialization\n    float scale = 2.;\n    \n    vec2 symm[N];// // = (, );\n    //symm[0] = a2v(60. + iTime*6.); symm[1] = a2v(-60.);\n    symm[0] = a2v(60. + iMouse.x); symm[1] = a2v(-60. + iMouse.y);\n    \n    vec2 offset = vec2(.0, .0);\n    vec2 dist = vec2(-1.,-1.);\n    \n    \n    \n    // algoritm\n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n];\n                //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n            uv*=scale;\n            uv -= (scale - 1.) * offset;\n        }\n        if(float(i) > mod(30.*iTime, float(ITER))) break;\n    }\n\n // Time varying pixel color\n    vec3 col = 0.5 + 0.1*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue); // monstr\n    vec3 col_g = gauss(uv, .1)*white;\n\n // Output to screen\n\n    vec2 norm = fragCoord/iResolution.xy;\n   // vec3 col_ex = 0.5 + 0.5*cos(iTime+norm.xyx+vec3(0,2,4));\n   // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n    fragColor = vec4(col_g+koltso+koltso2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 491, 527, 527, 570], [575, 610, 653, 653, 692], [697, 774, 795, 795, 842], [847, 880, 937, 1003, 2530]], "test": "valid"}
{"id": "WlyfDG", "name": "Loop Noise bw", "author": "supah", "description": "b/w", "tags": ["loopnoi"], "likes": 0, "viewed": 39, "published": "Public", "date": "1614939235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 box (vec2 sizes, vec2 uv) {\n    \n    float w = sizes.x / 2.;\n    float h = sizes.y / 2.;\n    float blur = .01;\n    \n    vec3 col = vec3(1.);\n    col -= vec3(smoothstep(-w, -w - blur, uv.x));\n    col -= vec3(smoothstep(w, w + blur, uv.x));\n    col -= vec3(smoothstep(h, h + blur, uv.y));\n    col -= vec3(smoothstep(-h, -h - blur, uv.y));\n    return col;\n}\n\n#define pi 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    \n    float loopDuration = 10.;\n    float speed = .1;\n    \n    float time = mod(iTime * speed / loopDuration, 1.);\n    float playhead = .5 * sin(time * pi * 2.) + 2.;\n    \n    float s = sin(time * 2. * pi) + 1.;\n    float c = cos(time * 2. * pi) + 1.;\n    \n    float zoom = 1.;\n    vec2 uvNoise = uv * zoom;\n    \n    float n1 = cnoise(vec3(uvNoise, s));\n    float n2 = cnoise(vec3(uvNoise, c));\n    \n    vec3 col = vec3(mix(n1, n2, playhead));\n    \n    vec3 t2 = vec3(.94, .94, .94);    \n    vec3 t1 = vec3(.92, .92, .92);   \n    t2 += mod(col, 0.5);\n    t1 += mod(col, 0.5);\n    \n    col = mix(t1, t2, col);\n        \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [190, 190, 209, 209, 245], [247, 247, 268, 268, 2540], [2542, 2542, 2574, 2574, 2901], [2926, 2926, 2983, 3034, 3760]], "test": "valid"}
{"id": "wlyfWK", "name": "Pencilvester's orthodoodle", "author": "evvvvil", "description": "Pencilvester's orthodoodle - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["2d", "cute", "demoscene", "plane", "isometric", "pattern", "orthographic", "clipping", "extrude", "twitch", "far", "extrusion"], "likes": 28, "viewed": 952, "published": "Public", "date": "1615050569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pencilvester's orthodoodle - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"Rick, I'm Pencilvester. Listen to that name. You can't kill me.\" - Pencilvester\n\nfloat t,tt,bb,g;vec2 z,v,e=vec2(.00035,-.00035);vec3 np,bp,pp,op,po,no,cp,al,ld;\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat bo(vec2 p,vec2 r){p=abs(p)-r;return max(p.x,p.y);}\nfloat box(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat ex(vec3 p,float sdf,float h){vec2 w=vec2(sdf,abs(p.y)-h);return min(max(w.x,w.y),0.0)+length(max(w,0.0));}\nconst float[] ca = float[4](-0.785,-0.6154,-0.8,-0.6154);\nconst float[] cb = float[4](1.57,-.785,4.185,-.785);\nconst float[] cc = float[4](7.,9.,8.,10.);\nvec2 mp( vec3 p,float ga)\n{  \n  p.yz*=r2(ca[int(bb)]);\n  p.xz*=r2(cb[int(bb)]);  \n  op=p;\n  p.x=mod(p.x-tt-1.0,10.)-5.;\n  vec2 t=vec2(1000,5),h=vec2(1000,3);\n  float glo=1000.,sinner=sin(op.x)*.2;\n  p.yz*=r2(.785);\n  pp=p;  \n  pp.yz=abs(pp.yz)-4.2+sinner;\n  pp.yz*=r2(.785);\n  vec3 u=vec3(pp.xz,1);\n  np=pp;\n  float cla=clamp(sin(pp.y*.5),-.25,.25);\n  for(int i=0;i<6;i++){\n    float I=float(i);\n    u.xy=abs(u.xy)-1.5-0.5*cla;\n    u.xy*=r2(.785*mod(I,2.));\n    u*=1.55;\n    t.x=min(t.x,ex(pp,abs(bo(u.xy,vec2(.5,2.0/u.z*.7))/u.z)-.02,4.-I*.5));        \n    h.x=min(h.x,ex(pp,bo(u.xy,vec2(.2,1.5/u.z*.75))/u.z,5.-I*.5));    \n    if(i<3&&ga>0.)glo=min(glo,ex(pp,abs(bo(u.xy,vec2(.3,1.7/u.z*.75))/u.z)-.0,4.-I*.5));        \n  }   \n  float sp=-(length(op.yz)-3.+sinner);\n  t=t.x<h.x?t:h;//t.x*=0.9;\n  t.x=max(t.x,op.y);\n  t.x=max(t.x,sp);\n  pp=op+vec3(0,13.5,0);pp.z=abs(pp.z)-8.5;\n  h=vec2(box(pp,vec3(20,10,5)),6);\n  h.x=min(h.x,box(pp-vec3(0,4,4.2-sinner),vec3(20,10,5)));\n  if(ga>0.){\n    glo=max(glo,op.y);\n    glo=max(glo,sp);\n    g+=0.1/(0.1+glo*glo*400.);  \n    h.x=min(h.x,glo);  \n  }  \n  t=t.x<h.x?t:h;  cp=p;\n\treturn t;\n}\nvec2 tr( vec3 ro,vec3 rd)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n  h=mp(ro+rd*t.x,1.);\n    if(h.x<.0001||t.x>18.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>18.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.8)+5.0;\n  bb=mod(floor(tt*.2),4.);\t\n  vec3 ro=vec3(uv*cc[int(bb)],-8.),\n  rd=vec3(0.,0.,1.),co,fo;\n  co=fo=vec3(.1)-length(uv)*.1;\n  ld=normalize(vec3(-.5,.5,-.3));\n  z=tr(ro,rd);t=z.x;  \n  if(z.y>0.){   \n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    al=vec3(.1,.2,.4)-ceil(abs(sin(np.y*15.))-.1)*.1;\n    if(z.y<5.) al=vec3(0)-ceil(cos(np.x*100.0));\n    if(z.y>5.) al=vec3(1),no-=0.2*ceil(abs(cos((cp)*5.2))-.05),no=normalize(no);    \n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);\n    co=mix(sp+al*(a(0.1)+.2)*(dif+s(.5)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.0001*t*t*t));\n  }\n  co=mix(co,co.xzy,length(uv*.7));\n  fragColor = vec4(pow(co+g*.2*mix(vec3(1.,.5,0.),vec3(1.),sin(t)*.5-.2),vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 364, 381, 381, 424], [425, 425, 449, 449, 481], [482, 482, 507, 507, 548], [549, 549, 584, 584, 661], [816, 816, 843, 843, 1945], [1946, 1946, 1973, 1973, 2137], [2233, 2233, 2290, 2290, 3250]], "test": "error"}
{"id": "wlyfWV", "name": "DJ Visuals with broken sdf", "author": "eimink", "description": "Destroying signed distance fields for nice visuals.", "tags": ["raymarching", "sdf", "fakeglow"], "likes": 0, "viewed": 102, "published": "Public API", "date": "1615063096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float E = 0.0001;\nconst float FAR = 40.0;\nconst int STEPS = 64;\n\nvec3 glow = vec3(0.0);\n\nfloat speed = 2.0;\nfloat tunnelrot = 1.4;\nfloat tunneltwst = .6;\nfloat camyaw = 0.4;\nfloat morphspd = 0.25;\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    float s1 = smoothstep(41.,41.+(iTime*0.01),sin(iTime));\n    float s2 = smoothstep(157.,157.+(iTime*0.01),cos(iTime));\n    float s3 = smoothstep(353.,353.+(iTime*0.01),sin(iTime));\n    vec3 s=vec3(s1,s2,s3);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat noise2(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(11,313,701);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat box (vec3 p, vec3 r){\n    vec3 d = abs(p) - r;\n    return length(max(d,0.0) + min(max(d.x, max(d.y, d.z)), 0.0));\n}\n\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 twistz(vec3 p, float k) {\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat tun2(vec3 p){\n    vec3 pp = p;\n    vec3 t = vec3(2.) - abs(vec3(length(pp.xz),length(p.xy),1.0));\n    return max(t.x,t.y)+.1;\n    return min(max(t.x,t.y),0.0);\n}\n\nfloat tun(vec3 p){\n    vec3 t = vec3(2.) - abs(twistz(p,tunneltwst));\n    return min(t.x,t.y);\n}\n\nfloat op(vec3 p){\n    float d1 = tun2(p);\n    float d2 = tun(p);\n    float d3 = mix(noise(p),noise2(p),-1.);\n    float t = clamp(iTime*0.1,0.0,1.);\n    return mix(d2,d1,t)+d3;\n}\n\nfloat scene(vec3 p)\n{\n    vec3 pp = p;\n    //pp -= vec3(0.,0.,iTime*speed+1.5);\n    for (int i = 0; i < 5; ++i)\n    {\n        rot(pp.xy,iTime*0.01);\n        rot(pp.xz,cos(iTime*0.2));\n        rot(pp.yz,sin(iTime*0.2));\n        pp = twistz(abs(pp) - float(i)*vec3(.1,.2,.0),.1);\n        \n    }\n    float a = oct(pp,2.5);\n    float c = box(pp,vec3(1.2,1.2,1.2));\n    float d =  mix(c,a,cos(3.+iTime*morphspd)*1.2);\n    rot(p.yx,iTime*tunnelrot);\n    float b = op(pp);\n    d = max(d,0.01);\n    \n    if (mod(p.z,noise2(p)) <= 1.) {\n            glow += vec3(.6+cos(iTime*2.)*0.3,.0,.6+sin(iTime)*0.2)*0.001/(0.01+abs(b));\n        }\n    glow += vec3(0.7,0.3,0.0)* 0.01 / (0.01+abs(d));\n    float r = min(b,max(c,a));\n    return abs(r);\n}\n\nfloat march(in vec3 ro, in vec3 rd, out vec3 p)\n{\n    p = ro;\n    float t = E;\n    for (int i = 0; i < STEPS; ++i) {\n        float d = scene(p);\n        t += d;        \n        if (d < E || t > FAR) {\n            break;\n        }\n        p -= rd*d;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(sin(iTime)*camyaw,.0,-3.);//iTime*speed);\n    rot(cp.xz,sin(iTime*0.001));\n    vec3 ct = vec3(0,0,-1);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(60.0)));\n   \n    vec3 col = vec3(1.);\n    vec3 p = vec3(0);\n    float t = march(cp,rd,p);\n    if (t < FAR) {\n            col = mix(vec3(.2,.2,.6),vec3(.3,.3,.8),step(0.9,fract(p.z)))*exp((cp.z-p.z)*0.3);       \n    }\n    col *= glow;\n    col = smoothstep(0.0,1.0,col);\n    col *= (1.0-vec3(t/FAR));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 226, 226, 659], [661, 661, 683, 683, 934], [936, 936, 969, 969, 1014], [1016, 1016, 1043, 1043, 1137], [1139, 1139, 1168, 1168, 1221], [1223, 1223, 1253, 1253, 1366], [1368, 1368, 1387, 1387, 1535], [1537, 1537, 1555, 1555, 1633], [1635, 1635, 1652, 1652, 1812], [1814, 1814, 1835, 1835, 2545], [2547, 2547, 2596, 2596, 2817], [2820, 2820, 2877, 2877, 3658]], "test": "valid"}
{"id": "wlyfWw", "name": "Pseudo Refraction", "author": "Shane", "description": "Pseudo refractive metaballs.", "tags": ["metaballs", "refraction", "effect", "blob", "glow", "truchet"], "likes": 35, "viewed": 512, "published": "Public API", "date": "1614779323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Pseudo Refraction\n    -----------------\n    \n    For all intents and purpose, this is a rough reproduction of a cheap \n    pseudo refraction technique that Nusan used in his \"Drop of Distortion\" \n    shader. There's not much to it: Code up something blob-like above a \n    plane, take the intersection point, cast the refracted ray down to the \n    plane, then use the resultant XY position to index into whatever \n    texture you decide to use to cover the back plane.\n    \n    Back in the day, multiple refractive bounces weren't really an option, \n    so this was the next best thing. It definitely won't fool you into \n    believing it's a fully fledged refractive blobby material floating \n    above a plane, but it's visually interesting and has a refractive feel. \n    In addtion, Nusan added some glow, which I thought looked pretty cool, \n    so I put some of that in as well.\n    \n    Metaballs are one my favorite oldschool effects. When raymarching \n    wasn't a feasible option, it was necessary to use the marching cubes \n    algorithm. Ironically, achieving the oldschool polygonized faceted look \n    would be quite difficult in a pixel shader, but at some stage, I'm \n    going to attempt that... or wait for someone else on here to do it. \n    Whichever comes first. :)\n    \n\n\n    // Based on the following:\n    \n    Drop of Distortion - Nusan\n    https://www.shadertoy.com/view/WdKXWt\n\n\n*/\n\n// Background pattern: Truchet checkers: 0, Circle checkers: 1.\n#define PAT 0\n\n// Colored glow.\n#define COLOR\n\n// Subtle textured lines.\n#define LINES\n\n\n// Object ID: Either the back plane or the metaballs.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// Exponential based smooth minimum: Nicer, but more expensive.\nfloat smin(float a, float b, float k){\n    \n    k *= 12.;\n    return -log(exp(-a*k) + exp(-b*k))/k;\n}\n*/\n\n// Standard metaball routine: Either determine the overall potential of \n// multiple spherical charges at a given point, or take the smooth \n// minimum between multiple spheres. Regardless of the route you take, \n// the result will resemble an isofield surface at the zero potential mark.\nfloat meta(vec3 p){ \n\n    float d = 1e5; // Start with .5, if using the potential version. \n\t\n    for (int i = 0 ; i < 5 ; i++){\n        // Move the spheres around.\n\t\tvec3 a = p - sin(vec3(1, 2, 5)*float(i) + iTime)/vec3(2, 2, 4);\n\t\t//d -= .2/dot(a, a); // Potential between balls.\n        d = smin(d, length(a) - .2, .5); // Smooth minimum.\n\t}\n    \n\treturn d; // Return the distance.\n}\n\n// Distance function.\nfloat m(vec3 p){\n    \n    // Back plane.\n    float fl = -p.z + .25;\n    \n    // Rotate the metaballs as a whole.\n    p.xy = rot2(-iTime/4.)*p.xy;\n    // Metaball distance.\n    float obj = meta(p);\n   \n    // Object ID.\n    objID = fl<obj? 0 : 1;\n    \n    // )verall minimum distance.\n    return min(fl, obj);\n    \n}\n  \n// Standard normal function.\nvec3 nr(in vec3 p){\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n                          m(p + e.yyx) - m(p - e.yyx)));\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n\n    //u += (hash21(u*57. + fract(iTime)) - .5)*5.;\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(0, 0, -2), l = vec3(.25, .25, -1.5);\n    \n    // Rotating the camera about the XY plane.\n    r.xy = rot2(iTime/8.)*r.xy;\n    //r.xz = rot2(.1)*r.xz;\n    \n \n  \n    \n    // Standard raymarching setup.\n    float d, t = hash21(r.xy*57. + fract(iTime))*.5, glow = 0.;\n    // Raymarch.\n    for(int i=0; i<96; i++){ \n        \n        d = m(o + r*t); // Surface distance.\n        if(d<.005) break; // Surface hit.\n        t += d*.5; // Advance the overall distance closer to the surface.\n        \n        //float rnd = hash21(r.xy + float(i)/113. + fract(iTime)) - .5;\n        glow += .2/(1. + abs(d)*5.);// + rnd*.2;\n        \n         \n    }\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Very basic lighting.\n    // Hit point and normal.\n    vec3 p = o + r*t, n = nr(p);\n    \n    \n    \n    // UV texture coordinate holder.\n    vec2 uv;\n    \n    // If we've hit the metaball surface, refract the ray and \n    // calculate the UV coordinates.\n    if(gObjID==1){\n    \n        // Refractive ray at the surface: I'm pretending the blobs are\n        // filled with something gelatinous, which has a rough refractive\n        // index of 1.5... Sounds good anyway. :D\n        vec3 ref = refract(r, n, 1./1.5);\n        float flDist = 2.25; // Floor distance from camera.\n        \n        // Starting at the surface, cast a ray in the refracted direction\n        // then get the XY component of the resultant back plane hit point.\n        // This will be your UV components, which you'll use to index into\n        // a texture. In this case, we'll generate a texture pattern with\n        // the coordinates.\n        uv = p.xy*flDist/(t*ref.z); \n \n    }\n    else uv = p.xy; // Back XY plane texture coordinates.\n    \n \n    \n    \n    // Cell ID and local cell coordinates for the texture we'll generate.\n    //\n    float sc = 1./3.; // Scale: .5 to about .2 seems to look OK.\n    vec2 iuv = floor(uv/sc) + .5; // Cell ID.\n    uv -= iuv*sc; // Local cell coordinates.\n    \n    // Construct a simple background texture. It doesn't need to be too fancy,\n    // but a small amount of detail can help bring out the refractive effect\n    // a little more. These simple patterns took less than five minutes, and\n    // were made up on the spot.\n    //\n    #if PAT == 0\n    float rnd = hash21(iuv); // Random threshold number.\n    if(rnd<.5) uv.y = -uv.y; // Flip random cell coordinates.\n    d = min(length(uv - .5*sc), length(uv + .5*sc)) - .5*sc; // Two diagonal circles.\n    float arc = abs(d) - .005; // Make a Truchet arc.\n    d = min(d, (length(uv) - .02)); // Add some little circles.\n    if(rnd<.5) d = -d; // Reverse the field for each random threshold.\n    //if(mod(iuv.x + iuv.y, 2.)<.5) d = -d; // Reversing checkers.\n    // Double up on some lines.\n    d = min(d + .02, abs(d));\n    #else\n    d = length(uv) - sc*.25;\n    if(mod(iuv.x + iuv.y, 2.)<.5) d = -d;// + .02;\n    d = min(d + .02, (abs(d) + .0));\n    #endif\n  \n    \n    \n    // Begin rendering the background texture. \n    vec4 oCol = mix(vec4(.05), vec4(1), 1. - smoothstep(0., .01, d));\n    \n    // Save the current color.\n    vec4 svCol = oCol; \n    \n    // Smooth borders.\n    float bord = max(abs(uv.x), abs(uv.y)) - .5*sc;\n    bord = abs(bord) - .001;\n    // Omit the middle of edges where the Truchet passes through.\n    oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, bord));\n    \n    #ifdef LINES\n    // Subtle lines for a bit of texture.\n    vec2 luv = uv;\n    float pat = abs(fract((luv.x + luv.y)*40. + .5) - .5)*2. - .25;\n    vec4 lCol = mod(iuv.x + iuv.y, 2.)<.5? vec4(.25) : vec4(.125);\n    oCol = mix(oCol, lCol, (1. - smoothstep(0., .01*40., pat))*.35);\n    #endif\n    \n    #if PAT == 0\n    // Render the background arcs.\n    oCol = mix(oCol, vec4(0), (1. - smoothstep(0., .01*8., arc - .01))*.5);\n    oCol = mix(oCol, vec4(0), 1. - smoothstep(0., .01, arc - .005));\n    oCol = mix(oCol, svCol, 1. - smoothstep(0., .01, arc)); \n    #endif\n\n\n    // Basic point lighting.   \n    vec3 ld = l - p;\n    float lDist = length(ld);\n    ld /= lDist; // Light direction vector.\n    float at = 1./(1. + lDist*lDist*.75); // Attenuation.\n    float df = max(dot(n, ld), 0.); // Diffuse.\n    float sp = pow(max(dot(reflect(r, n), ld), 0.), 32.); // Specular.\n    \n      \n    // Apply the lighting. \n    c = oCol*(df/4. + vec4(1)*sp*2. + .75); // Coloring, diffuse plus ambience.\n    \n    // Cheap edging. \n    // Used for cheap edging. It only works for particular objects.\n    float edge = dot(r, n);\n    c = mix(c, vec4(0), (1. - smoothstep(0., .1, -.35 - edge))*.5);\n    c = mix(c, vec4(1), (1. - smoothstep(0., .05, -.2 - edge))*.5);\n    \n     \n \n    #ifdef COLOR\n    vec4 gCol = vec4(4, 2, 1, 0);\n    #else\n    vec4 gCol = vec4(2);\n    #endif\n    // Coloring the glow, which is not to be confused with applying\n    // the glow.\n    c *= mix(mix(vec4(1), gCol, min(glow/4., 1.)), \n         vec4(1), float(1 - gObjID)*(1. - smoothstep(0., 1., glow - 1.5)));\n    \n\n    // Laying down something slightly shadowy looking -- Totally fake.\n    c *= (max(1. - glow/2., .0))*1.5 + .2;\n \n    // Very very cheap shadows -- Not used here.\n    //c *= max(min(min(m(p + ld*.1), m(p + ld*.2)), m(p + ld*.3))/.1, 0.) + .15;\n    \n  \n    // Reverse, of sorts.\n    //c = pow((1. - c.zyxw), vec4(8));\n\n    // Applying the glow and attenuation, then applying some fake\n    // spotlight attenuation for a bit more atmosphere.\n    c *= glow*at*(1. - smoothstep(0., 1.5, length(p.xy) - .5)*.85);\n    \n    \n    // Time based color transition.\n    //c = mix(c.yxzw, c, smoothstep(-.05, .05, sin(iTime/4. + .2)));\n   \n    \n    // Mixing the color a bit more.\n    c = mix(c, c.xzyw, length(u));\n    c = mix(c.zyxw, c, smoothstep(-.15, .15, u.y));\n    \n        \n    // Just the diffuse metaballs. \n    //float fr = pow(max(1. + dot(r, n), 0.), 5.);\n    //c = vec4(1)*(df + fr); \n\n\n    // Rough gamma correction.\n    c = sqrt(max(c, 0.));  \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1637, 1670, 1692, 1692, 1750], [1752, 1780, 1801, 1801, 1864], [1867, 2090, 2128, 2128, 2205], [2380, 2669, 2688, 2688, 3055], [3057, 3079, 3095, 3119, 3394], [3398, 3427, 3446, 3446, 3618], [3621, 3621, 3656, 3774, 9862]], "test": "valid"}
{"id": "wslSDM", "name": "Blobbie", "author": "rmdms", "description": "...", "tags": ["workshop"], "likes": 1, "viewed": 30, "published": "Public", "date": "1616169780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n|--------------------------------------------------------------------------\n| V3\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\n\n#define S(v)  smoothstep( 2./R.y, 0., v ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         P = ( u - .5* R ) / R.y;\n         P += sin(iTime * 5. + P.yx * 25.) * .01;\n\n    float l = length(P),\n          a = S( l - .15 ),\n          b = S( l - .25 );\n\n    O = vec4( mix(a,1.-a, b) );\n}\n\n\n/*\n|--------------------------------------------------------------------------\n| V2\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Variables\n    float t = iTime;\n    \n    // Coordonate\n    vec2 coord = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n    coord += sin(t * 5. + coord.yx * 25.) * .01;\n    \n    // Color\n    fragColor = vec4( smoothstep(.25, .25-2./iResolution.y, length(coord) ) );\n    \n    // Shape\n    float size = 0.25;\n    float shape = smoothstep( 2./iResolution.y, 0., length(coord)- .15);\n    // .:. add color\n    fragColor = mix(fragColor,1.0-fragColor, shape);\n}\n*/\n\n/*\n|--------------------------------------------------------------------------\n| V1\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Variables\n    float t = iTime;\n    \n    // Coordonate\n    vec2 coord = fragCoord / iResolution.xy;\n    \t// .:. center origin\n    \tcoord -= 0.5;\n    \tcoord.x *= iResolution.x / iResolution.y;\n    \t// .:. add distortion\n    \tcoord.x += sin(t * 5.0 + coord.y * 25.0) * 0.01;\n    \tcoord.y += sin(t * 5.0 + coord.x * 25.0) * 0.01;\n    \n    // Color\n    float r = step(length(coord), 0.15);\n    float g = step(length(coord), 0.15);\n    float b = step(length(coord), 0.15);\n    float a = 1.0;\n    \t// .:. add color\n    \tfragColor = vec4(r,g,b,a);\n    \n    // Shape\n    float size = 0.25;\n    float shape = step(length(coord), size);\n    \t// .:. add color\n    \tfragColor = mix(fragColor,1.0-fragColor, shape);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslSDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 219, 257, 257, 487]], "test": "valid"}
{"id": "WtdBRS", "name": "Moon - distance 2D", "author": "iq", "description": "Exact distance to a moon shape", "tags": ["2d", "sdf", "moon", "distance"], "likes": 24, "viewed": 692, "published": "Public API", "date": "1616567072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D moon shape\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n        return length(p-vec2(a,b));\n    }\n\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.3;\n    m *= 1.3;\n    \n    float ra = 1.0;\n    float rb = 0.8;\n    float di = 1.2*cos(iTime+3.9);\n    \n\tfloat d = sdMoon( p, di, ra, rb );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(100.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdMoon(m, di, ra, rb );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBRS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1117, 1269, 1321, 1321, 1610], [1612, 1612, 1669, 1669, 2406]], "test": "valid"}
{"id": "WtGBWm", "name": "Ray Marching w/ Blinn-Phong", "author": "Parcle", "description": "Ray Marching w/ Blinn-Phong \nJust a graphics knowledge test to see how far I could get without external reference.\nThough I did have to google using pow for the specular piece of Blinn-Phong shading. I forgot and it didn't quite look right without it...", "tags": ["raymarching"], "likes": 1, "viewed": 57, "published": "Public API", "date": "1614632506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 120\n#define MISS_DIST 200.0\n// HIT_DIST should be treated as a non-inclusive max\n#define HIT_DIST 0.001\n#define SHADOW_RAY_SURFACE_ESCAPE_VECTOR_LENGTH 0.5\n#define NUM_SPHERES 7\n\nstruct hit_result {\n    vec3 hitPos;\n    float dist;\n    int iterations;\n    bool hit;\n};\nconst vec3 missColor = vec3(0.1, 0.1, 0.1);\nvec3 hitColor = vec3(0.8, 0.3, 0.5);\nconst float pi = 3.141592;\nconst float tau = pi * 2.0;\n\nfloat sdSphere(vec3 rayPos);\nfloat sdXZQuad(vec3 rayPos);\nfloat sdScene(vec3 rayPos);\nvec3 calcColor(vec3 rayOrigin, vec3 rayDir);\nvec3 calcLighting(vec3 hitPos);\nvec3 getNormal(vec3 hitPos);\nmat2 rotate(float rads);\nmat3 lookAt(vec3 origin, vec3 focus);\nhit_result castRay(vec3 rayOrigin, vec3 rayDir);\n\nvec3 cameraPos = vec3(0.0, 0.0, 100.0);\n \nvec4 spheresPosAndScale[NUM_SPHERES] = vec4[](\n                        vec4(0.0, 0.0, 0.0, 3.0),\n                        vec4(0.0, 0.0, 10.0, 4.5),\n                        vec4(0.0, 0.0, -10.0, 3.0),\n                        vec4(10.0, 0.0, 0.0, 4.5),\n                        vec4(-10.0, 0.0, 0.0, 3.0),\n                        vec4(0.0, 10.0, 0.0, 4.5),\n                        vec4(0.0, -10.0, 0.0, 3.0)\n                    );\nconst float xzPlaneYValue = -15.0;\nconst float xzPlaneScale = 35.0;\nconst float xzPlaneScaleInverse = 1.0 / xzPlaneScale;\nconst vec3 xzPlaneNormal = vec3(0.0, 1.0, 0.0);\n         \nconst float defaultSphereRadius = 1.0f;\nconst float rotationCyclesPerSecond = 0.10;\n\n\nconst vec3 lightColor = vec3(1.0);\nconst float ambientLightFactor = 0.3;\nconst float specularLightFactor = 0.3;\nconst float directionalLightFactor = 1.0 - ambientLightFactor - specularLightFactor;\nvec3 directionalLightDir;\n\nconst vec3 worldUp = vec3(0.0, 1.0, 0.0);\n\nmat3 lookAt(vec3 origin, vec3 focus) {\n    vec3 zBasis = normalize(origin - focus); // from focus to origin, as we look down the negative z axis\n    vec3 xBasis = normalize(cross(worldUp, zBasis));\n    vec3 yBasis = normalize(cross(zBasis, xBasis));\n    return mat3 (\n                    xBasis,\n                    yBasis,\n                    zBasis\n                );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - (iResolution.xy * 0.5);\n    uv /= iResolution.y;\n    uv *= 2.0;\n    \n    float tSin = sin(iTime * 0.5);\n    float tCos = cos(iTime * 0.5);\n    hitColor += vec3(0.0, hitColor.y * tSin, hitColor.z * tCos);\n    \n    // directional lights don't have a \"position\", it is simply useful to temporarily think of it this way to manipulate the direction\n    vec3 directionalLightPos = vec3(0.0, 50.0 + (25.0 * tSin), -100.0);\n    directionalLightDir = normalize(directionalLightPos - vec3(0.0)); // direction the light is coming from, NOT the direction the light \"flows\"\n    \n    // offset the spheres as a unit to orbit y axis\n    vec3 sphereOffsets = vec3(10.0 * tSin, 0.0, 10.0 * tCos);\n    \n    mat2 rotateMatrix = rotate(tau * iTime * rotationCyclesPerSecond);\n    \n    for(int i = 0; i < NUM_SPHERES; ++i) {\n        // adjust sphere scales\n        float sinScaleFactor = (sin(iTime + (float(i) * pi * 0.7)) + 1.0) * 0.5;\n        spheresPosAndScale[i].w = mix(1.0, spheresPosAndScale[i].w, sinScaleFactor);\n        \n        // adjust sphere positions through rotation\n        spheresPosAndScale[i].xy = rotateMatrix * spheresPosAndScale[i].xy;\n         \n        // offset all spheres as a unit (orbiting y-axis)\n        spheresPosAndScale[i].xyz += sphereOffsets;\n    }\n    \n    \n    float cameraYFactor = (sin(iTime * 0.3) + 1.0) * 0.5;\n    cameraPos.y = cameraYFactor * 100.0;\n    vec3 rayOrigin = cameraPos;\n    const float cameraToPlaneZValue = -5.0;\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, cameraToPlaneZValue));\n    vec3 focus = vec3(0.0, 0.0, 0.0);\n    mat3 lookAtMat = lookAt(cameraPos, focus);\n    rayDir = lookAtMat * rayDir;\n    \n    vec3 color = calcColor(rayOrigin, rayDir);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n// note ray direction is expected to be normalized\nvec3 calcColor(vec3 rayOrigin, vec3 rayDir) {\n    hit_result hitResult = castRay(rayOrigin, rayDir);\n    return hitResult.hit ? calcLighting(hitResult.hitPos) : missColor;\n}\n\nhit_result castRay(vec3 rayOrigin, vec3 rayDir) {\n    hit_result hitResult;\n    hitResult.hit = false;\n    hitResult.iterations = 0;\n    hitResult.dist = 0.0;\n    while(hitResult.dist < MISS_DIST && hitResult.iterations < MAX_STEPS) {\n        vec3 currRayPos = rayOrigin + (hitResult.dist*rayDir);\n        float currDist = sdScene(currRayPos);\n        if(currDist < HIT_DIST) { // hit!\n            hitResult.hit = true;\n            hitResult.hitPos = currRayPos;\n            break;\n        }\n        hitResult.dist += currDist;\n        ++hitResult.iterations;\n    }\n    \n    return hitResult;\n}\n\nfloat sdScene(vec3 rayPos) {\n    float minDist = sdXZQuad((rayPos - vec3(0.0, xzPlaneYValue, 0.0)) * xzPlaneScaleInverse) * xzPlaneScale;\n    for(int i = 0; i < NUM_SPHERES; ++i) {\n        minDist = min(minDist, sdSphere((rayPos - spheresPosAndScale[i].xyz) / spheresPosAndScale[i].w)  * spheresPosAndScale[i].w);\n    }\n\n    return minDist;\n}\n\nfloat sdSphere(vec3 rayPos) {\n    float signedDist = length(rayPos) - defaultSphereRadius;\n    return signedDist;\n}\n\nfloat sdXZQuad(vec3 rayPos) {\n    rayPos = abs(rayPos);\n    rayPos.xz -= vec2(1.0, 1.0);\n    rayPos.xz = max(rayPos.xz, 0.0);\n    return length(rayPos);\n}\n\nvec3 calcLighting(vec3 hitPos) {\n    vec3 normal = getNormal(hitPos);\n    \n    // ambient\n    vec3 ambientContribution = ambientLightFactor * lightColor * hitColor;\n    \n    // diffuse\n    float normalLightDirAlignment = dot(normal, directionalLightDir);\n    vec3 diffuseContribution = normalLightDirAlignment * directionalLightFactor * lightColor * hitColor;\n    \n    // specular\n    vec3 viewDir = normalize(cameraPos - hitPos); // from hit position to camera pos\n    vec3 halfwayVector = normalize(directionalLightDir + viewDir);\n    float normalHalfwayAlignment = dot(normal, halfwayVector);\n    float specularStrength = pow(max(normalHalfwayAlignment, 0.0), 32.0); // NOTE: one line where I \"cheated\" and didn't pull from memory\n    vec3 specularContribution = specularStrength * lightColor * specularLightFactor; // ignore hit color for specular lighting\n    \n    // shadow\n    bool inShadow = castRay(hitPos + (SHADOW_RAY_SURFACE_ESCAPE_VECTOR_LENGTH * normal), directionalLightDir).hit;\n    \n    return (normalLightDirAlignment < 0.0 || inShadow) ? ambientContribution : ambientContribution + diffuseContribution + specularContribution;\n}\n\n// Note: normal is returned normalized\nvec3 getNormal(vec3 hitPos) {\n    int closestIndex = 0;\n    float closestDist = sdSphere((hitPos - spheresPosAndScale[0].xyz) / spheresPosAndScale[0].w)  * spheresPosAndScale[0].w;\n    for(int i = 1; i < NUM_SPHERES; i++) {\n        float dist = sdSphere((hitPos - spheresPosAndScale[i].xyz) / spheresPosAndScale[i].w)  * spheresPosAndScale[i].w;\n        if(dist < closestDist) {\n            closestDist = dist;\n            closestIndex = i;\n        }\n    }\n    \n    return closestDist > HIT_DIST ? xzPlaneNormal : normalize(hitPos - spheresPosAndScale[closestIndex].xyz);\n}\n\nmat2 rotate(float rads) {\n    float sinTheta = sin(rads);\n    float cosTheta = cos(rads);\n    return mat2 ( \n                    cosTheta, sinTheta,\n                    -sinTheta, cosTheta\n                );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 1732, 1770, 1770, 2103], [2105, 2105, 2161, 2161, 3936], [3938, 3989, 4034, 4034, 4162], [4164, 4164, 4213, 4213, 4758], [4760, 4760, 4788, 4788, 5102], [5104, 5104, 5133, 5133, 5219], [5221, 5221, 5250, 5250, 5375], [5377, 5377, 5409, 5409, 6523], [6525, 6564, 6593, 6593, 7137], [7139, 7139, 7164, 7164, 7348]], "test": "error"}
{"id": "WtGBz3", "name": "Out for a Swim", "author": "oneshade", "description": "Animation of a fish swimming.", "tags": ["deform", "animation", "25d", "fish", "swimming", "parabolic"], "likes": 10, "viewed": 84, "published": "Public", "date": "1614728496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Map to coordinates on a circle while preserving arclength\nvec2 circularDeform(in vec2 p, in float r) {\n    float s = sign(r);\n    r *= s, p = vec2(r - p.y * s, p.x);\n    return vec2(atan(p.y, p.x) * r, (r - length(p)) * s);\n}\n\n// 2D SDFs from Inigo Quilez's distance function article (https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm)\nfloat sdUnevenCapsule(in vec2 p, in float r1, in float r2, in float h) {\n    p.x = abs(p.x);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(p, vec2(-b, a));\n    if (k < 0.0) return length(p) - r1;\n    if (k > a * h) return length(p - vec2(0.0, h)) - r2;\n    return dot(p, vec2(a, b)) - r1;\n}\n\nfloat sdIsosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                 vec2(dot(b, b), s * (p.y - q.y)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// Fish texture\nvec3 fishColor(in vec2 uv, in float unit) {\n    vec3 color = vec3(0.0);\n\n    // Red scales\n    vec2 uv2 = mod(uv + vec2(0.035, 0.0175), vec2(0.07, 0.035)) - vec2(0.035, 0.0175);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv2) - 0.014));\n\n    // Yellow scales\n    vec2 uv3 = mod(uv + vec2(0.085, 0.0175), vec2(0.07, 0.035)) - vec2(0.035, 0.0175);\n    color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, length(uv3) - 0.014));\n\n    // Eyes\n    float eyes = length(vec2(uv.x + 0.03, abs(uv.y) - 0.035)) - 0.0175;\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, eyes));\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(eyes)));\n\n    // Fins\n    float c = cos(0.25), s = sin(0.25);\n    vec2 uv4 = vec2(uv.x, abs(uv.y) - 0.125) * mat2(c, -s, s, c);\n    vec2 uv5 = uv4 * mat2(c, s, -s, c) * mat2(c, s, -s, c);\n    vec3 finColor = vec3(0.35 + 0.35 * sin(uv5.y * 500.0), 0.0, 0.0);\n    color = mix(color, finColor, smoothstep(unit, 0.0, max(uv4.x - 0.2, abs(uv4.y) - 0.04)));\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Moving background\n    vec2 uv2 = uv * iResolution.y / iResolution.xy + 0.5;\n    uv2 += vec2(0.0, iTime * 0.4);\n    fragColor = texture(iChannel0, uv2);\n\n    // Deform along circle\n    float bend = sin(iTime * 3.0);\n    float osc = -sin(iTime * 3.0) * 0.05;\n\n    vec2 uv3 = uv.yx * vec2(-1.0, 1.0) - vec2(-0.075, osc);\n    vec2 p = circularDeform(uv3, 0.5 / bend) + vec2(0.1, 0.0);\n\n    vec2 uv4 = uv.yx * vec2(-1.0, 1.0) - vec2(-0.025, 0.08 + osc);\n    vec2 p2 = circularDeform(uv4, 0.5 / bend) + vec2(0.1, 0.0);\n\n    // Fish distance\n    float c = cos(0.15), s = sin(0.15);\n    mat2 rmat = mat2(c, s, -s, c);\n\n    float body = sdUnevenCapsule(p.yx, 0.075, 0.0, 0.35);\n    float d = sdUnevenCapsule(p.yx, 0.075, 0.0, 0.35);\n    d = min(d, sdIsosceles(p.yx - vec2(0.0, 0.325), vec2(0.05, 0.15)));\n    d = min(d, sdIsosceles(vec2(abs(p.y) - 0.06, p.x) * rmat, vec2(0.075, 0.15)));\n\n    float d2 = sdUnevenCapsule(p2.yx, 0.075, 0.0, 0.35);\n    d2 = min(d2, sdIsosceles(p2.yx - vec2(0.0, 0.325), vec2(0.05, 0.15)));\n    d2 = min(d2, sdIsosceles(vec2(abs(p2.y) - 0.06, p2.x) * rmat, vec2(0.075, 0.15)));\n\n    // Fish's shadow\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(unit * 15.0, 0.0, d2 + 0.02));\n\n    // Fish texture (the mapping works so nicely!)\n    fragColor.rgb = mix(fragColor.rgb, fishColor(p, unit), smoothstep(unit, 0.0, d));\n\n    // Lighting\n    fragColor.rgb += 0.075 * exp(-38.0 * body);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.9));\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 105, 105, 228], [230, 365, 437, 437, 689], [691, 691, 732, 732, 1052], [1054, 1070, 1113, 1113, 2116], [2118, 2118, 2173, 2173, 3754]], "test": "error"}
{"id": "wtGfD3", "name": "ifs strobo2 (epilepsy warning)", "author": "sus1357", "description": "you can adjust speed of morphing (float speed)", "tags": ["fractal", "ifs", "stroboscopic"], "likes": 5, "viewed": 50, "published": "Public", "date": "1615168510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    // ekrannaya konstanta - RAZMER OBLASTI CHISEL(a chto esli NE konstanta?...)\nvec2 DOMAIN_XY = vec2(16., 9.);\nfloat speed = 6.;\n\n    // KIFS-konstanti\nconst int N = 2;// N - kol-vo vektorov simmetrii\nconst int N_but_fancy = 2; // esli hochu uzaty tol'ko chasty vektorov\nconst int ITER = 10;// WHYYY IT MUST BE CONSTANT, STUPID GLSL LOOPS\n\n    //colors constants\nvec3 white = vec3(1.,1.,1.);\nvec3 black = vec3(0.,0.,0.);\nvec3 red   = vec3(1.,0.,0.);\nvec3 blue  = vec3(0.,0.,1.);\nvec3 green = vec3(0.,1.,0.);\n\nfloat gauss(in vec2 p, in float s) {return exp( -(p.x*p.x+p.y*p.y)/(2.*s*s) );}\n    //tupoy 2d gauss s centrom v (0,0)\nfloat gauss_1d(float x, float m, float s) {return exp( -((x-m)*(x-m))/(2.*s*s) );}\n    //1d gauss\n    // ne delil na sigmu (s), no pohuy ( return (1/.s)*exp(...) )\nvec2 a2v(in float a){return vec2(cos(radians(a)), sin(radians(a)));}\n    //gradus -> vektor simmetrii\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n // sozdal prostranstvo (uv) razmerom v DOMAIN s tsentrom v (0,0)\n    vec2 uv = fragCoord*DOMAIN_XY/iResolution.xy - .5*DOMAIN_XY;\n \n \n \n                         //  | | |\n // KIFS KIFS KIFS KIFS KIFS v v v\n    // initialization\n    float scale = 2.;\n    \n    vec2 symm[N];// // = (, );\n    //symm[0] = a2v(60.); symm[1] = a2v(-60.);\n    symm[0] = a2v(60. + iTime*speed); symm[1] = a2v(-60.);\n    //symm[0] = a2v(-60. + iMouse.x); symm[1] = a2v(60. + iMouse.y);\n    \n    //vec2 offset = vec2(-1.+2.*iMouse.x/iResolution.x, -1.+2.*iMouse.y/iResolution.y);\n    vec2 offset = vec2(.0,.0);\n    float dist[N]; dist[0] = -1.; dist[1] = -1.;\n    \n    \n    \n    // algoritm\n    for(int i=0; i<ITER; i++) {\n        for(int n=0; n<N_but_fancy; n++) {\n            float len = dot(uv, symm[n]);\n            if( len < dist[n] ) {\n                uv -= 2.0*(len - dist[n])*symm[n];\n                //uv -= 2.0*(len - dist[i])*symm[i]\n            }\n        }\n        uv*=scale;\n            uv -= (scale - 1.) * offset;\n        if(float(i) > mod(30.*iTime, float(ITER))) break; // stroboscope\n    }\n // Output to screen\n \n    vec3 koltso  = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime) , 1. ) * red;\n    vec3 koltso2 = gauss_1d ( sqrt(dot(uv, uv)), sin(iTime)+1.5*sin(.6*iTime)+3. , 1.5 )\n                        *\n                   (.9*green + .2*blue);\n    vec3 col_g = gauss(uv, .1)*white;\n   \n\n\n    vec2 norm = fragCoord/iResolution.xy;\n   vec3 col_ex = 0.5 + 0.5*cos(2.35+norm.xyx+vec3(0,2,4));\n   float mod_const = pow(scale, float(ITER));\n   col_ex *= step( max( mod(uv.x, mod_const), mod(uv.y, mod_const) ), 0.9*mod_const );\n   \n\n    float w = 0.05 * mod_const;\n    \n    vec3 x_positive = float(int((uv.x>0.0)&&(uv.y<w)&&(uv.y>-w)))*red;\n    vec3 x_negative = float(int((uv.x<0.0)&&(uv.y<w)&&(uv.y>-w)))*0.2*red; \n    vec3 y_positive = float(int((uv.y>0.0)&&(uv.x<w)&&(uv.x>-w)))*(red+green);\n    vec3 y_negative = float(int((uv.y<0.0)&&(uv.x<w)&&(uv.x>-w)))*0.2*(red+green);\n    vec3 osi = x_positive + x_negative + y_positive + y_negative;\n\n   vec2 xy_examp = fragCoord/iResolution.xy;\n    vec3 col_examp = 0.5 + 0.5*cos(iTime+xy_examp.xyx+vec3(0,2,4));\n   // col_ex *= .75*sin(iTime)+.5;\n    //fragColor = vec4(col+col_g+koltso,1.0);\n   // fragColor = vec4(col_g+koltso+koltso2+col_ex,1.0);\n    fragColor = vec4(col_g+koltso+koltso2 + .5*(osi*col_examp + osi + col_examp),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 511, 547, 547, 590], [595, 630, 673, 673, 712], [717, 794, 815, 815, 862], [867, 900, 957, 1023, 3329]], "test": "valid"}
{"id": "WtGfRK", "name": "Lightroom", "author": "josemorval", "description": "Single pass GI with fractal-like thing", "tags": ["raymarching", "gi"], "likes": 11, "viewed": 147, "published": "Public", "date": "1614630914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nvec3 randomsphere(float seed){float a = 2.*3.1415*hash(seed);float b = 3.1415*hash(11.3*seed+0.4);return vec3(cos(a)*cos(b),sin(b),sin(a)*cos(b));}\n\n\n#define sph(p,s) length(p)-s\n#define box(p,s) max(max(abs(p.x)-s.x,abs(p.y)-s.y),abs(p.z)-s.z)\nfloat mat;\nfloat map(vec3 p){\n    float d = 1000.;\n    float s = 0.;\n    mat = 0.;\n    \n\n    vec3 q = p;\n    float angle=1.*time;\n    mat2 rot = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    for(int i=0;i<5;i++){\n        q=abs(q)-0.1*float(i);\n        q.xy*=rot;\n        q.yz*=rot;\n        \n    }\n    d = abs(box(q,0.1*vec3(1.)))-0.2;    \n    d = mix(sph(p,1.),d,1.-sin(3.14*fract(0.1*time)));\n    \n      \n    s=-box(p,vec3(6.));\n    if(s<d){\n        mat = 1.;\n        d=s; \n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e=0.01*vec2(1.,-1.);\n    float m = map(p+e.xxx);\n    return normalize(vec3(m-map(p+e.yxx),m-map(p+e.xyx),m-map(p+e.xxy)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 ro,rd,fw,ri,up;float fov=0.8;\n\n    \n    vec3 accumcol = vec3(0.);\n    \n    const float num =50.;\n    \n    //render: raymarching with some bounces\n    for(float k=0.;k<num;k+=1.){\n    \n        col = vec3(0.);\n        ro=vec3(5.*cos(0.2*time),0.5,5.*sin(0.7*time));\n        fw=normalize(-ro); up = normalize(vec3(0.,1.,0.)); ri = cross(fw,up); up=cross(ri,fw);\n        rd = normalize(mat3(ri,up,fw)*vec3(uv,fov));\n        \n        \n        //raymarching part\n        for(float j=0.;j<4.;j+=1.){\n            float t = 0.;\n            float m = -1.;        \n            for(int i=0;i<32;i++){\n                float d = map(ro+rd*t);\n                if(abs(d)<0.001*t){\n                    m=mat;\n                    break;\n                }\n                t+=d;\n            }\n            \n            vec3 pos = ro+rd*t; vec3 n = normal(pos);\n            \n            float s=0.;\n            s += smoothstep(0.995,1.,sin(0.1*pos.y-floor(0.5*pos.x+0.*time)*floor(0.5*pos.z+1.3*floor(0.5*pos.y+2.*time))));\n            s += smoothstep(0.995,1.,sin(0.3*pos.x+floor(0.1*pos.y+time)*floor(0.01*pos.x+1.3*floor(0.5*pos.z+2.*time))));\n            \n            vec3 rdir = randomsphere(0.133*pos.x+0.31*pos.y+0.51*pos.z+5.11*float(j)+3.411*float(k+2.1)+0.1+time);\n            rd = normalize(mix(reflect(rd,n),rdir*sign(dot(rdir,n)),0.5+0.3*sin(0.3*pos.x+time)));\n            ro=pos+0.01*n;\n           \n           if((s>0. && m==1.) ||m==2.){        \n                col +=2.*vec3(0.5-0.1*pos.y,0.4,0.8-0.01*pos.x);\n                break;\n            }else{\n                col *= 0.;\n            }\n            \n        }\n        \n        accumcol+=col;\n    }\n    \n    col=accumcol/num;\n    \n    \n    \n    //some gamma correction\n    float gamma = 0.45;\n    col.r = pow(col.r,gamma);\n    col.g = pow(col.g,gamma);\n    col.b = pow(col.b,gamma);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 71], [72, 72, 102, 102, 219], [328, 328, 346, 346, 828], [830, 830, 850, 850, 984], [987, 987, 1044, 1044, 3057]], "test": "valid"}
{"id": "wtGfWc", "name": "Fractal Julia set", "author": "matlabman", "description": "fractal test...\nJulia set. Change const r and i to get different set.\nSource code from taichi examples.\nTaichi forum: https://forum.taichi.graphics/", "tags": ["fractal"], "likes": 5, "viewed": 68, "published": "Public", "date": "1615174767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float r = 0.355;\nconst float i = 0.355;\n\nvec2 Complex_sqr( vec2 z )\n{\n    return vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n}\n\nfloat getNorm ( vec2 z )\n{\n    return sqrt(dot(z, z));\n}\n\nfloat GetColor( float t, vec2 pixels )\n{\n    vec2 c = vec2(r, cos(t) * i);\n    vec2 z = pixels;\n    float iterations = 0.0;\n    while ( getNorm(z) < 20.0 && iterations < 300.0 )\n    {\n        z = Complex_sqr(z) + c;\n        iterations += 1.0;\n    }\n    return 1.0 - iterations * 0.004; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 pixel = vec2((fragCoord/iResolution.xy) * 2.0 - 1.0) * 1.2;\n    pixel.x *= aspectRatio;\n    float color = GetColor(iTime, pixel);\n    // Output to screen\n    //fragColor = vec4(vec3(color), 1.0);\n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGfWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 75, 75, 135], [137, 137, 163, 163, 193], [195, 195, 235, 235, 483], [485, 485, 542, 542, 833]], "test": "valid"}
{"id": "WtGfWm", "name": "N-Sided Pyramid", "author": "sahemera", "description": "Attempt at N-sided pyramid. I'm unsatisfied that the height of the pyramid seems to change depending on the number of sides but I don't understand where that is coming from. If you have the time and understand why I would appreciate a pointer!", "tags": ["raymarching", "sdf", "pyramid"], "likes": 3, "viewed": 75, "published": "Public", "date": "1614756675", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n#define TAU 6.283185\n\n\n//Returns distance from point to a plane defined by its origin and its normal\n//Credit goes to decrooks\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n    return dot(p - origin,normal);   \n}\n\n//First assemble a 4-sided pyramid\nfloat pyramid(vec3 p, float d) {\n    float dn =1.0/sqrt(4.0);\n    //The tetrahedran is the intersection of four planes:\n    float sd1 = plane(p,vec3(d,0.,0.), vec3(dn,dn,0.)) ;\n    float sd3 = plane(p,vec3(0.,0.,d), vec3(0,dn,dn)) ;\n    float sd2 = plane(p,vec3(-d,0.,0.), vec3(-dn,dn,0.)) ;\n    float sd4 = plane(p,vec3(0.,0.,-d), vec3(0,dn,-dn)) ;\n\n    float sd5 = plane(p,vec3(0.,-d,0.), vec3(0,-1,0)) ;\n\n    return max(max(sd1,sd2),max(sd3,max(sd5,sd4)));\n}\n\n//Generalized n-sided pyramid. \nfloat nPyramid(vec3 p, float d, int sides) {\n    float sidesf = float(sides);\n    float dn = 1.0/sqrt(3.0 + 1.0);\n    float sdf = plane(p,vec3(0.,-d,0.), vec3(0,-1,0));\n    \n    \n    //Use points around a circle in the center of the pyramid to define the planes\n    float arcAdd = TAU / sidesf;\n    \n    //The 3-sided pyramid is much bigger than the other pyramids\n    //because we're defining by planes instead of vertices,\n    //so attempt to scale the size so that the size hopefully\n    //remains the saaame or close enough between numbers of sides\n    d *= cos(arcAdd/2.);\n    \n    //Intersect planes until we have the pyramid\n    for(int side = 0; side < sides; side++)\n    {\n        float az = arcAdd*float(side);\n        float sdn = plane(p,vec3(d*cos(az),0,d*sin(az)), vec3(dn*cos(az),dn,dn*sin(az)));\n        \n        ////max intersects shapes\n        sdf = max(sdf, sdn);\n    }\n\n    return sdf;\n}\n\n\n\nfloat GetDist(vec3 p) {\n    float time = iTime;\n    \n    float planeDist = p.y+0.3;\n    float planeDist2 = p.y+0.5;\n    \n    float tetra = nPyramid(p - vec3(0.,2.,0.), 1., 3 + int(mod(time*2.16,8.)));\n\n    //Return whichever distance is closer\n    float d = max(planeDist,sin(p.x*p.x/5. - time + sqrt(p.z*p.z  ))*cos(p.z + p.x + time/4.)/4.);\n    d = min(d, planeDist2);\n    d = min(d,tetra);\n    \n    return d;\n}\n\n\n//Move from the rayOrigin in the rayDistance until we collide with the scene or fly off into INF\n//RayMarch is also called Sphere Tracing because when we get the distance from each position as\n//we march along the array, that distance creates an arc or sphere around the position that defines\n//how much we will step on the next iteration.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDistance)\n{\n    float distanceOrigin = 0.02;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //Get next point\n        vec3 p = rayOrigin + rayDistance*distanceOrigin;\n        \n        //Get distance from new point to the scene\n        float dS  = GetDist(p);\n        \n        //Add distance from new point to total distance from origin\n        distanceOrigin += dS;\n        \n        //If we have marched too far or if we are sufficiently close to scene, we're done marching\n        if(distanceOrigin > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return distanceOrigin;\n}\n\n/***Gets the normal of a point to the nearest part of the scene defined by GetDist*/\nvec3 GetNormal_Generic(vec3 p) {\n    \n    vec2 epsilon = vec2(0.01, 0);\n    \n    //Get the distance from scene to the point\n    float d = GetDist(p);\n    \n    //Get the slope by subtracting nearby points from the point and normalizing their direction\n    vec3 n = vec3(\n        d - GetDist(p - epsilon.xyy), //*.xyy and xyx are called a \"swizzle\", just makes it faster to write\n        d - GetDist(p - epsilon.yxy),\n        d - GetDist(p - epsilon.yyx));\n        \n    return normalize(n);\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6); //arbitrary position in space\n    \n    lightPos.xz += vec2(2.*sin(4.0*iTime), 2.*cos(4.0*iTime));\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so cap negative numbers to 0\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    return dif;\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse_WithShadows(vec3 p, vec3 lightPos) {\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec3 lightRay = normalize(lightPos-p);\n    vec3 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so.. \"clamp\" it\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    \n    float ldif = length(lightPos - p);\n    \n    //Let's say we are rendering a point on the plane in the shadow of the sphere.\n    //Ray march from this point in the direction of the light to see if we collide\n    //with more scenery. If we do, reduce the diffuse lighting.\n    //\n    //Because 'p' was an output to RayMarch already, p already collides with the scene.\n    //So move p a little bit away using the normal we already found.\n    float d = RayMarch(p + normalRay*SURF_DIST, lightRay);\n    if(d < ldif) dif*= max(abs(d)/ldif,0.1);\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0, 0.007, 0.02);\n    vec3 rayOrigin;\n    vec3 rayDirection;\n    if( mod(time,19.) < 8.5)\n    {\n        rayOrigin = vec3(-0.16 , 10. + 1.*sin(time/2.),-0.2);\n        rayDirection = normalize(vec3(uv.x, -1.0, uv.y));\n    }\n    else\n    {\n        rayOrigin = vec3(-3. + 0.3*sin(time/4.),2.7, 8.2 + 0.26*cos(time/4.));\n        rayDirection = normalize(vec3(uv.x + 0.25, uv.y - 0.1, -1.));\n    }\n\n    float d = RayMarch(rayOrigin, rayDirection);\n    vec3 p = rayOrigin + rayDirection * d;\n    \n    //White light\n    vec3 lightPos = vec3(0, 7, 4);\n    lightPos.xz += vec2(0., cos(2.0*time)/2.);\n    float light = GetLight_Diffuse_WithShadows(p, lightPos);\n    col = col + vec3(light)*0.9;\n    \n    //Blue light\n    lightPos = vec3(18, 5, -13);\n    lightPos.xz += vec2(0.,  0.5);\n    light = GetLight_Diffuse_WithShadows(p, lightPos);\n    col = col + vec3(0.,light*0.01,light)/8.;\n    \n    //Light underneath\n    lightPos = vec3(0, 1., 0);\n    lightPos.xz += vec2(0., cos(2.0*time));\n    light = GetLight_Diffuse_WithShadows(p, lightPos);\n    col = col + pow(sin(time/5.),4.)*vec3(light,light/1.2,0.0) / 1.3;\n    \n    // Output to screen\n    float screenGamma = 2.0;\n    vec3 colorGammaCorrected = pow(col, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 194, 241, 241, 282], [284, 319, 351, 351, 780], [782, 814, 858, 858, 1721], [1725, 1725, 1748, 1748, 2138], [2141, 2481, 2531, 2531, 3101], [3103, 3188, 3220, 3220, 3678], [3681, 3775, 3807, 3807, 4259], [4262, 4356, 4415, 4503, 5273], [5276, 5276, 5333, 5333, 6761]], "test": "valid"}
{"id": "WtKBDK", "name": "Influencia", "author": "ChemaSerrano", "description": "....", "tags": ["1"], "likes": 0, "viewed": 41, "published": "Public", "date": "1615067937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define CH iTime=0.60\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0*(0.5 * iResolution.xy - fragCoord.xy) / iResolution.xy;\n\tfloat angle = atan(p.x, p.y);\n\tfloat turn = (angle + TAU) / PI+TAU;\n\tfloat radius = sqrt(p.x*p.x + p.y*p.y);\n\t\n\tfloat rotation = 0.04 * TAU * iTime;\n\tfloat turn_1 = turn + rotation;\n\t\n\tfloat n_sub = 15.0;\n\t\n\tfloat turn_sub = mod(float(n_sub) * turn_1, float(n_sub));\n\t\n\tfloat k_sine = 0.1 * sin(3.0 * iTime);\n\tfloat sine = k_sine * sin(0.5 * (pow(radius, 0.1) - 0.4 * iTime));\n\tfloat turn_sine = turn_sub + sine;\n\n\tint n_colors = 10;\n\tint i_turn = int(mod(float(n_colors) * turn_sine, float(n_colors)));\n\t\n\tint i_radius = int(1.5/pow(radius*TAU/PI, 10000.6) + 1500.0 * iTime*PI);\n\t\t\n\tint i_color = int(mod(float(i_turn + i_radius*5), float(n_colors)));\n\t\n\tvec3 color;\n\tif(i_color == 0) { \n\t\tcolor = vec3(1.9, 0.0, 1.8);\t\t  \n\t} else if(i_color == 1) {\n\t\tcolor = vec3(2.8, 9.0, 2.7);\t\n\t} else if(i_color == 2) {\n\t\tcolor = vec3(3.7, 8.0, 3.6);\t\n\t} else if(i_color == 3) {\n\t\tcolor = vec3(4.6, 7.5, 4.5);\t\n\t} else if(i_color == 4) {\n\t\tcolor = vec3(5.5, 6.0, 5.5);\t\n\t} else if(i_color == 5) {\n\t\tcolor = vec3(6.4, 5.0, 6.5);\t\n\t} else if(i_color == 6) {\n\t\tcolor = vec3(7.3, 4.0, 7.4);\t\n\t} else if(i_color == 7) {\n\t\tcolor = vec3(8.2, 3.0, 8.3);\t\n\t} else if(i_color == 8) {\n\t\tcolor = vec3(9.1, 2.0, 9.2);\t\n\t} else if(i_color == 9) {\n\t\tcolor = vec3(0.0, 1.0, 0.1);\t\n\t}\n\t\n\tcolor -= pow(radius*TAU, 0.35)*4.0;\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKBDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 138, 138, 1541]], "test": "valid"}
{"id": "wtKBDy", "name": "A cubic marble", "author": "I_am_6r1d", "description": "I saw a \"Playing marble\" shader by S. Guillitte and decided to change its code a bit. I think there's some result.\n\nI also want to know how to make an octahedron intersection function. If someone can tell, that'll be great!", "tags": ["3d", "fractal", "volumetric"], "likes": 4, "viewed": 138, "published": "Public", "date": "1615007489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A fork of \"Playing marble\" by S. Guillitte 2015.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (original: https://www.shadertoy.com/view/MtX3Ws)\n\n// Uses a box intersection function by iq and animates the fractal part.\n\n// I wish I knew how to make an octahedron intersection function, too!\n// Aand I lost my train of thought long ago, anyway.\n\nconst float PI = 3.14159265;\n\nfloat zoom=1.5;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(max(tN,0.0), tF);\n}\n\nfloat map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {    \n        p =.7*abs(p)/dot(p,p) -.7;\n        p=p.zxy;\n        res += exp(-33. * abs(dot(p,0.65*c)));        \n\t}\n\treturn res;\n}\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    vec3 col= vec3(0.);\n    float c = 0.;\n    for( int i=0; i<128; i++ )\n\t{\n        t+=exp((-sin(2.*iTime)+sin(iTime+PI))*c);\n        if(t>tminmax.y) break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(ro+t*rd);               \n        \n        col = .99*col+ .08*vec3(c*c*c, c*c, c);\n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m.x-=.5;\n    m.y+=.4;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(1.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    vec2 tmm = iBox( ro, rd, vec3(1.5,1.5,1.5) );\n\n\t// raymarch\n    vec3 col = raymarch(ro, rd, tmm);\n    // texture(iChannel0, rd).rgb\n    if (tmm.x<0.) col = vec3(0.0);\n\t\n\t// shade\n    \n    col = .8*(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBDy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[267, 439, 469, 469, 524], [525, 525, 547, 547, 596], [599, 599, 618, 618, 665], [667, 667, 717, 755, 989], [991, 991, 1013, 1013, 1211], [1213, 1213, 1265, 1265, 1630], [1633, 1633, 1690, 1690, 2530]], "test": "valid"}
{"id": "wtKBWw", "name": "Distance to Parabola", "author": "oneshade", "description": "I worked out the distance to a parabola!", "tags": ["2d", "sdf", "distance", "cubic", "parabola"], "likes": 2, "viewed": 77, "published": "Public", "date": "1614656005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThe idea is to find the x coordinate on the parabola that minimizes the\ndistance between the point and the parabola.\n\nFirst set up the distance-for-x-coordinate function:\nd(x) = (x - p.x)^2 + (hx^2 - p.y)^2\n\nNow we need to minimize it! How though?\nWe can't answer that directly, but we can narrow it down to a finite\ncollection of points and then test each one.\n\nThe idea behind how to figure out where potential minimums are is\nto realize that if it IS a minimum, then the function must be increasing\naway it, other wise there has to be something smaller. If its increasing away\nfrom it, then coming in from the left, the function must be decreasing, and\ngoing out on the right, the function must be increasing. Somewhere in between,\nit must not be increasing or decreasing at all.\n\nTo figure out how much a function is increasing and decreasing we need\ncalculus. Specifically, the derivative. Then, knowing that we have simply\nto solve for where its derivative is zero (the function is not increasing\nor decreasing).\n\nSo I'll wrap up the maths (d'(x) means derivative of d(x)):\nd'(x) = 2(x - p.x) + 4(hx^2 - p.y)hx\n\nd'(x) = 0\n2(x - p.x) + 4(hx^2 - p.y)hx = 0\n2h^2x^3 + (1 - 2p.yh)x - p.x = 0\n\nWhich is a cubic equation, one of whose roots is the minimum.\n*/\n\n#define eta 1.0471975512 // pi/3\nfloat sdParabola(in vec2 p, in float h) {\n    if (abs(h) < 1e-3) return p.y;\n    p.x = abs(p.x);\n\n    float d0 = (1.5 / h - 3.0 * p.y) / h, d1 = 13.5 * p.x / (h * h);\n    float q = d1 * d1 + 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 c = vec2(step(0.0, q) * j - d1, step(0.0, -q) * j);\n    if (abs(c.x) + abs(c.y) < 1e-3) c = vec2(-j - d1, 0.0);\n    float t = atan(c.y, c.x) / 3.0, r = pow(0.25 * dot(c, c), 1.0 / 6.0);\n\n    float w = d0 / r - r;\n    float x = max(w * cos(t), -w * cos(t - eta)) / 3.0;\n    return length(p - vec2(x, h * x * x)) * sign(h * p.x * p.x - p.y) * sign(h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float a = sin(0.25 * iTime) * 16.0;\n    float b = cos(0.25 * iTime);\n    float c = 0.25 * sin(0.5 * iTime);\n\n    float d = sdParabola(uv + vec2(0.5 * b / a, 0.25 * b * b / a - c), a);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1297, 1338, 1338, 1887], [1889, 1889, 1944, 1944, 2543]], "test": "valid"}
{"id": "wtKBzy", "name": "Sine Contrast", "author": "luketrenaman", "description": "A wavy shader using negative space.", "tags": ["2d"], "likes": 0, "viewed": 30, "published": "Public", "date": "1614622975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/vec2(iResolution.y,iResolution.y)*4.0;\n    st.x += iTime/2.0+sin(st.y*3.0);\n    st.y += iTime/2.0+sin(st.x*.25);\n    vec3 color;\n    color=floor(vec3(mod(st.x,1.0) + mod(st.y,1.0))/(sin(iTime)/2.0+1.0));\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 323]], "test": "valid"}
{"id": "wtKfDG", "name": "Mandelbrot set 4316", "author": "csgradle", "description": "learning how to make a mandelbrot set", "tags": ["mandelbrot"], "likes": 2, "viewed": 51, "published": "Public", "date": "1615221220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision lowp float;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0, 0.0,_scale.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv *= scale(vec2( 3./(pow(2., iTime)) ));\n    uv += vec2(0.351099, 0.509458);\n    vec2 st = vec2(0.);\n    int iter = 0;\n    int maxIter = 1000;\n    for(int i = 0; i < maxIter; i++) {\n        st = vec2(st.x*st.x - st.y*st.y + uv.x, 2.*st.x*st.y + uv.y);\n        iter++;\n        if(st.x*st.x + st.y*st.y > 4.) {\n            break;\n        }\n    }\n   \n    vec3 col = hsv2rgb(vec3(float(iter)/80.+0.5, 1., 1.))*step(0.8, float(maxIter-iter));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 45, 45, 376], [377, 377, 399, 399, 568], [570, 570, 594, 594, 641], [642, 642, 699, 699, 1267]], "test": "valid"}
{"id": "wtKfDV", "name": "Project R-26 B prototype", "author": "eimink", "description": "Prototype of shader used in 4k intro \"Project R-26 B\" @ Assembly Winter '21. 1st place in intro compo.", "tags": ["sdf", "fakeglow"], "likes": 2, "viewed": 71, "published": "Public", "date": "1616410644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float E = 0.0001;\nconst float FAR = 40.0;\nconst int STEPS = 64;\n\nvec3 glow = vec3(0.0);\n\nfloat speed = 2.0;\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    float s1 = smoothstep(41.,41.+(iTime*0.01),sin(iTime));\n    float s2 = smoothstep(157.,157.+(iTime*0.01),cos(iTime));\n    float s3 = smoothstep(353.,353.+(iTime*0.01),sin(iTime));\n    vec3 s=vec3(s1,s2,s3);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat noise2(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(11,313,701);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat box (vec3 p, vec3 r){\n    vec3 d = abs(p) - r;\n    return length(max(d,0.0) + min(max(d.x, max(d.y, d.z)), 0.0));\n}\n\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat scene(vec3 p)\n{\n    vec3 pp = p;\n    vec3 ppp = p;\n    for (int i = 0; i < 4; ++i)\n    {\n        rot(pp.yz,2.);\n        rot(pp.xy,1.);\n        rot(pp.xz,1.);\n        pp = abs(pp) - float(i)*vec3(1.,1.,1.);\n        \n    }\n    float a = oct(pp,1.0);\n    float b = box(pp,vec3(1.,2.,1.));\n    rot(ppp.xz,iTime-17.);\n    float c = box(ppp,vec3(.2,.2,.2));\n    float d = oct(ppp,.2);\n    float e = mix(c,d,cos(3.+iTime*0.25));\n    e = max(e,0.001);\n    float r = 0.;\n    glow += vec3(.0,.2,.6)*0.01/(0.9+abs(noise2(ppp)));\n    if (iTime < 17.) {\n    glow += vec3(0.7,0.3,0.0)* 0.01 / (0.09+abs(a));\n     r = min(a,abs(b))-noise2(pp);\n    }\n    else {\n    glow += vec3(.6+cos(iTime*2.)*0.3,.0,.6+sin(iTime)*0.2)*0.01/(0.9+abs(d));\n    glow += vec3(0.7,0.3,0.0)* 0.01 / (0.09+abs(a));\n    r = min(e,min(a,abs(b))-noise2(pp));\n    }\n    return abs(r);\n}\n\nfloat march(in vec3 ro, in vec3 rd, out vec3 p)\n{\n    p = ro;\n    float t = E;\n    for (int i = 0; i < STEPS; ++i) {\n        float d = scene(p);\n        t += d;        \n        if (d < E || t > FAR) {\n            break;\n        }\n        p += rd*d;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cp;\n    if (iTime < 23.) {\n        cp = vec3(0.,1.0,22.-(iTime));\n        rot(cp.xy,iTime);\n    }\n    else {\n        cp = vec3(0.,1.0,-1.);\n        rot(cp.xz,iTime);\n        rot(cp.xy,iTime);\n    }\n    vec3 ct = vec3(0,0,-1);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n\n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(45.0)));\n   \n    vec3 col = vec3(1.);\n    vec3 p = vec3(0);\n    float t = march(cp,rd,p);\n    if (t < FAR) {\n            col = vec3(.2,.4,.8)*length(dot(cp,p))*0.01;       \n    }\n    \n    \n    col += glow;\n    float outs;\n    float ss = modf(iTime,outs);\n    if (mod(ss,2.) < 0.05){\n        col += glow;\n    }\n    col = smoothstep(0.0,1.0,col);\n    col *= (1.0-vec3(t/FAR));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 137, 137, 570], [572, 572, 594, 594, 845], [847, 847, 880, 880, 925], [927, 927, 954, 954, 1048], [1050, 1050, 1079, 1079, 1132], [1134, 1134, 1155, 1155, 1985], [1987, 1987, 2036, 2036, 2257], [2260, 2260, 2317, 2317, 3261]], "test": "error"}
{"id": "wtlBDr", "name": "Foraminifera", "author": "romeosoft", "description": "Foraminifera, these native organisms are an ancient and fascinating mini shells.", "tags": ["shell", "foraminifera", "plankton"], "likes": 4, "viewed": 63, "published": "Public", "date": "1616044142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float pi = 3.1415926;\nconst vec3 \n    c1 = vec3(0.25, 0.25, 0.25),\n\tc2 = vec3(.58, .58,.58);\n\nfloat time;\nvec3 light;\nfloat R = 0.8;\n//--------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n//--------------------------------------------------------------\n// 坐标变换\nvec3 transform(vec3 p)\n{\n    ROT(p.xz, (0.1) * (iTime + 15.0));\n    \n    return vec3(p.x,p.y,p.z);\n}\nvec3 transform2(vec3 p)\n{\n    vec2 pp = p.xz;\n    ROT(pp, (2.01) * p.y);\n    \n    return vec3(pp.x,p.y,pp.y);\n}\n// 单体\nfloat sphere(vec3 p, vec3 o, float r)\n{\n    p *= mix(0.8, 1.25, p.y);\n    // vec3 pp = p + vec3(0.25 * noise(p*8.));\n        \n    float f1 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.+0.5),floor(p.z*8.+0.5)));\n\tfloat f2 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.-0.5),floor(p.z*8.-0.5)));\n\tfloat f3 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.-0.5),floor(p.z*8.+0.5)));\n\tfloat f4 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.+0.5),floor(p.z*8.-0.5)));\n\tfloat f5 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.-0.5),floor(p.z*8.+0.5)));\n\tfloat f6 = length(p*8.-vec3(floor(p.x*8.+0.5),floor(p.y*8.-0.5),floor(p.z*8.-0.5)));\n\tfloat f7 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.+0.5),floor(p.z*8.-0.5)));\n    float f8 = length(p*8.-vec3(floor(p.x*8.-0.5),floor(p.y*8.+0.5),floor(p.z*8.+0.5)));\n    \n    \n\t\n    float f = min(min(f7, f8),min(min(f5, f6), min(min(f1, f2), min(f3, f4))));\n    f = abs(1./(0.0001 + f+f) - 1./(f1+f2+f3+f4+f5+f6+f7+f8));\n    f =f*f;\n    if(f > 0.7)\n        return 0.;\n    \n    float dop = (length(p-o+vec3(0.,0.5 * R,0.)) + length(p-o+vec3(0.,-0.5,0.))) / 2.0;\n\tdop += f*0.1;\n    \n    if(dop < r && dop > r * 0.95)\n        return dop;\n    return 0.;\n}\n// 阴影\nbool shadow(vec3 p)\n{\n    vec3 v=light;\n    for(int i = 0; i < 30; i ++)\n    {\n        p -= v;\n        float f1 = sphere(p, vec3(0.0,0.0,0.),R);\n        if(f1 > 0.0)\n            return true;\n    }\n    return false;\n}\n// 上色\nvec3 shade(vec3 p, float v)\n{\n    vec3 cor = mix(c1,c2,noise(p*20.));\n    cor = mix(cor,vec3(0.), dot(normalize(p),normalize(light)));\n    if(shadow(p))\n        return cor * 0.5;\n    return cor;\n}\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 1.25;\n    float eyea = -(iMouse.x / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.0 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    float dt = 0.01;\n    vec3 cor = vec3(0.0);\n   \n    light = vec3(0.,-0.02,0.02);\n    for(int i = 0; i < 1000; i ++)\n    {\n        vec3 pp = transform(p);\n        \n\t\tfloat r = length(pp);\n        float f = sphere(pp, vec3(0.0,0.0,0.),R);\n        \n        if(f > 0.)\n        {\n            cor = shade(pp, f);\n            break;\n        }\n        \n        dt = mix(0.001, 0.0025, smoothstep(0.,0.3,abs(R-f)));\n        \n        p += v*dt;\n    }\n    fragColor = vec4(cor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 858, 886, 886, 1435], [1437, 1437, 1466, 1466, 1714], [1716, 1716, 1743, 1743, 1994], [1996, 1996, 2016, 2016, 2162], [2163, 2228, 2250, 2250, 2566], [2568, 2568, 2590, 2590, 2750], [2752, 2752, 2775, 2775, 2811], [2812, 2812, 2835, 2835, 3204], [3206, 3287, 3311, 3311, 3387], [3388, 3388, 3413, 3413, 3499], [3500, 3510, 3549, 3549, 4715], [4716, 4726, 4747, 4747, 4942], [4943, 4953, 4982, 4982, 5149], [5150, 5215, 5272, 5272, 6329]], "test": "valid"}
{"id": "wttBz2", "name": "2d Water", "author": "elindie", "description": "A simple water with some floating balls. ", "tags": ["2dwater"], "likes": 3, "viewed": 47, "published": "Public", "date": "1615356904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sampleWaves(in float x, in float time)\n{\n    // Big Wave\n    float t = sin(x / 400.0 + time) + 1.0;\n    float t1 = t * t;\n      \n    // Med Wave\n    float t2 = sin(x / 100.0 + time) + 2.1;\n    \n    // Small Wave\n    float t3 = sin(x / 3.9) * 0.2;\n    \n    float terrUnion = t1 + t2 + t3 * 0.2;\n    \n    return terrUnion;\n}\n\nbool sampleSphere(in vec2 center, in float radius, in vec2 samplePos) \n{\n    vec2 sphereLocation = vec2(0.34 * iResolution.xy);\n    sphereLocation.y = sampleWaves(sphereLocation.x, iTime) * 50.0;\n    \n    float distance = length(samplePos.xy - center.xy);\n    \n    return distance < radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float gradient = sin(uv.y) + 0.2;\n\n    // Time varying pixel color\n    vec3 col = vec3(0,0, 0.5 + 0.5 * sin(uv.x)) * gradient;\n    vec3 skyCol = vec3(0.5,0.2,0) / gradient + 0.5;\n\n    float terrUnion = sampleWaves(fragCoord.x, iTime);\n    \n    float waterHeight = max((fragCoord.y - terrUnion * 50.0), 0.0);\n    vec3 col1 = waterHeight < 0.1 ? col : skyCol;\n  \n  \n    vec2 sphere1 = vec2(0.34 * iResolution.xy);\n    sphere1.y = sampleWaves(sphere1.x, iTime) * 50.0;\n    \n    vec2 sphere2 = vec2(0.31 * iResolution.xy);\n    sphere2.y = sampleWaves(sphere2.x, iTime) * 50.0;\n    \n    vec2 sphere3 = vec2(0.30 * iResolution.xy);\n    sphere3.y = sampleWaves(sphere3.x, iTime) * 50.0;\n    \n    vec2 sphere4 = vec2(0.28 * iResolution.xy);\n    sphere4.y = sampleWaves(sphere4.x, iTime) * 50.0;\n    \n    bool isSphere = sampleSphere(sphere1, 20.0, fragCoord)||\n                    sampleSphere(sphere2, 4.0, fragCoord) ||\n                    sampleSphere(sphere3, 8.0, fragCoord) ||\n                    sampleSphere(sphere4, 10.0, fragCoord);\n    \n    col1.xyz = isSphere ? vec3(1,0,0) : col1.xyz ;\n\n\n    // Output to screen\n    fragColor = vec4(col1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 62, 328], [330, 330, 402, 402, 622], [625, 625, 682, 732, 1928]], "test": "valid"}
{"id": "WtVBRK", "name": "RGB flow", "author": "LevAsmanov", "description": "That's my first shader.", "tags": ["rgb", "rainbow"], "likes": 3, "viewed": 73, "published": "Public", "date": "1614680127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#define time iTime\n#define frame iFrame\n#define resolution iResolution\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n//uniform vec2 resolution;\n//uniform float time;\n//uniform float frame;\nfloat bruh(float iTime, float diff, in vec2 fragCoord){\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nreturn sin(uv.y*uv.x*10.+time/2.+diff);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\nvec2 uv = gl_FragCoord.xy / resolution.xy;\nfloat dif = 45.;\nfragColor = vec4(vec3(\nbruh(time,-dif,gl_FragCoord.xy),\nbruh(time,0.,gl_FragCoord.xy),\nbruh(time,dif,gl_FragCoord.xy)\n),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVBRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 300, 355, 355, 440], [441, 441, 497, 497, 685]], "test": "valid"}
{"id": "WtVBRy", "name": "Light rays[SC]", "author": "Beshelmek", "description": "Test", "tags": ["lightrays"], "likes": 8, "viewed": 127, "published": "Public", "date": "1614606799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI = 3.141592654;\nconst float side = 0.3;\nconst float angle = PI*1.0/3.0;\nconst float sinA = 0.86602540378;\nconst float cosA = 0.5;\nconst vec3 zero = vec3(0.0);\nconst vec3 one = vec3(1.0);\n\n// generates the colors for the rays in the background\nvec4 rayColor(vec2 fragToCenterPos, vec2 fragCoord) {\n\tfloat d = length(fragToCenterPos);\n\tfragToCenterPos = normalize(fragToCenterPos);\n\t\t\n\tfloat multiplier = 0.0;\n\tconst float loop = 60.0;\n\tconst float dotTreshold = 0.90;\n\tconst float timeScale = 0.75;\n\tconst float fstep = 10.0;\n\t\n\t// generates \"loop\" directions, summing the \"contribution\" of the fragment to it. (fragmentPos dot direction)\n\tfloat c = 0.5/(d*d);\n\tfloat freq = 0.25;\t\t\n\tfor (float i = 1.0; i < loop; i++) {\n\t\tfloat attn = c;\n\t\tattn *= 1.85*(sin(i*0.3*iTime)*0.5+0.5);\n\t\tfloat t = iTime*timeScale - fstep*i;\n\t\tvec2 dir = vec2(cos(freq*t), sin(freq*t));\n\t\tfloat m = dot(dir, fragToCenterPos);\n\t\tm = pow(abs(m), 4.0);\n\t\tm *= float((m) > dotTreshold);\n\t\tmultiplier += 0.5*attn*m/(i);\n\t}\n\n\t// radius for the rings around the triforce\n\tconst float r0 = 0.345;\n\tconst float r1 = r0 + 0.02;\n\tconst float r2 = r1 + 0.005;\n\t\n\t// \"f\" controls the intensity of the ray color\n\tfloat f = 1.0;\n\t//if (d < r0) f = smoothstep(0.0, 1.0, d/r0);\n\t//else if (d < r1) f = 0.75;//(d - r0) / (r1 - r0);\n\t//else if (d < r2) f = 1.2;\n\t\t\n\n\tconst vec4 rayColor = vec4(0.9, 0.7, 0.3, 1.0);\n\t\t\n\t// Applies the pattern\n\tfloat pat = abs(sin(10.0*mod(fragCoord.y*fragCoord.x, 1.5)));\n\tf += pat;\n\tvec4 color = f*multiplier*rayColor;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aspect = iResolution.x / iResolution.y;\t\n\tvec3 pos = vec3(fragCoord.xy / iResolution.xy, 1.0);\n\tpos.x *= aspect;\n\t\n\tvec2 fragToCenterPos = vec2(pos.x - 0.5*aspect, pos.y - 0.5);\n\tvec4 rayCol = rayColor(fragToCenterPos,fragCoord);\n\t\n\t// barycentric coordinates of pos with respect to the triangle of the triforce it lies inside\n\tfloat u, v, w;\n\t//float c = insideTriforce(pos, aspect, u, v, w);\t\n\n\tfloat lim = 0.075;\n\t\n\tvec3 normal = vec3(0.0, 0.0, 1.0);\n\tvec3 uNormalContrib = vec3(0.0);\n\tvec3 vNormalContrib = vec3(0.0);\n\tvec3 wNormalContrib = vec3(0.0);\n\t\t\n\t// on the edge of each triangle, \"bend\" the normal in the direction of the edge\n\tif (u < lim) {\n\t\tfloat uNorm = u/lim;\n\t\tfloat offset = cos(0.5*PI*uNorm);\n\t\toffset *= offset;\n\t\tuNormalContrib = vec3(0.0, -offset, 0.0);\n\t}\n\tif (v < lim) {\n\t\tfloat vNorm = v/lim;\n\t\tfloat offset = -cos(0.5*PI*vNorm);\n\t\toffset *= offset;\n\t\tvNormalContrib = vec3(offset*cosA, offset*sinA, 0.0);\n\t}\n\tif (w < lim) {\n\t\tfloat wNorm = w/lim;\n\t\tfloat offset = cos(0.5*PI*wNorm);\n\t\toffset *= offset;\n\t\twNormalContrib = vec3(-offset*cosA, offset*sinA, 0.0);\n\t}\n\t\n\t// sums all the contributions to form the normal\n\tnormal += uNormalContrib + vNormalContrib + wNormalContrib;\n\tnormal = normalize(normal);\n\t\n\t// generate a position for the view: on a circle around the center of the screen\n\tfloat freq = 1.5*iTime;\n\tvec3 view = vec3(0.5, 0.5, 0.0) + vec3(sin(freq), cos(freq), 2.0);\n\tview = normalize(view);\n\t\n\t// Apply lambertian light\n\tfloat light = dot( view, normal );\n\t\n\t// when the barycentric coordinate falls into the [minW, maxW] interval, shade with a lighter tone\n\tfloat minW = mod(1.15*iTime, 4.0);\n\tfloat maxW = minW + 0.3;\n\tfloat s = 1.0;\n\tif (w > minW && w < maxW)\n\t\ts += 0.1;\n\n\tfragColor = rayCol;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVBRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 303, 356, 356, 1588], [1590, 1590, 1647, 1647, 3398]], "test": "valid"}
{"id": "wtVBWK", "name": "BW golfed variant of Golf Style", "author": "FabriceNeyret2", "description": "simplied variant of my golfing of iapafoto's [url]https://shadertoy.com/view/tlVBzV[/url]", "tags": ["city", "golf", "almost1tweet"], "likes": 12, "viewed": 277, "published": "Public API", "date": "1615103338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simplied variant of my golfing of iapafoto's https://shadertoy.com/view/tlVBzV\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float l = .2;\n    vec3 R = iResolution,\n         P = vec3(iTime,3,0)*7.,\n         D = vec3( ( U - .5*R.xy ) / R.y + l*cos(.5*iTime) , 1 );\n      // D = vec3( ( U - .5*R.xy ) / R.y                   , 1 ); // 1 tweet version\n    for( D.yz *= mat2(4,-3,3,4)*l; \n         l > .1; \n         l = min( P.y - 8.* fract( sin(dot(ceil(P).xzz,R)) * 4e5 ), .11 )\n       ) P += l*D;\n    O += P.y/P.z * length(step(.1,fract(P))) -O;\n}\n\n\n\n\n\n\n/* // 276 chars  simplied variant of my golfing of iapafoto's shader\n\n#define N(v) fract( sin(dot(v,R)) * 4e5 )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float l = .2;\n    vec3 R = iResolution,\n         P = vec3(iTime,3,0)*7.,\n         D = vec3( ( U - .5*R.xy ) / R.y + l*cos(.5*iTime) , 1 );\n    for( D.yz *= mat2(4,-3,3,4)*l; l > .1; l = min( P.y - 8.*N(ceil(P).xzz), .11) )\n        P += l*D;\n    O += P.y/P.z * length(step(.1,fract(P))) -O;\n}\n\n\n\n\n\n\n/*  // 346 chars golfed version of  4997chars iapafoto. https://shadertoy.com/view/tlVBzV\n\n\n#define N(v) fract( sin(dot(v,R)) * 4e5 )\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    float a = .2;\n    vec3 R = iResolution, i,\n         p = vec3(iTime,3,0)*7.,\n         d = vec3( ( U - .5*R.xy ) / R.y + a*cos(.5*iTime) , 1 );\n    for( d.yz *= mat2(4,-3,3,4)*a; a > .1; a = min(p.y-a,.11) )\n        p += a*d,\n        i = ceil(p*.5),\n        a = 4.*mod(i.x*i.z,3.) * N(i.xzz);\n        O.rgb =  sqrt(p.y/p.z) \n               * exp( .4*cos(.1*p) *(N(ceil(p))-.5) )\n               * length(step(.1,fract(p)));\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 84, 120, 120, 546]], "test": "valid"}
{"id": "WtVBzK", "name": "Fractal 31_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 9, "viewed": 204, "published": "Public API", "date": "1614691029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        e<.001?O+=mix(vec4(1),cos(vec4(1,2,3,0)+log(s))*5.,.3)/length(p)/i:O\n    )\n    {\n        p=g*d;\n        p-=vec3(0,-.9,1.5);\n        p=R(p,normalize(vec3(1,8,0)),iTime*.2);   \n        s=3.;\n        s*=e=6./min(dot(p,p),2.);\n        p=abs(p)*e;\n        for(int i=0;i++<2;){\n            p.x =1.-abs(p.x-5.2);\n            p.y =3.6-abs(p.y-4.3);\n            p.z =1.8-abs(p.z-2.5);\n            s*=e=8./min(dot(p,p),9.);\n            p=abs(p)*e;\n        }\n        g+=e=min(length(p.xz)-.3,p.y)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 731]], "test": "valid"}
{"id": "WtVfRy", "name": "Bezier intersections", "author": "hamoid", "description": "Visualizes the intersections of two morphing 2D cubic Bézier curves.\n\nAfter a minute or two it crashes Chromium. And my Firefox seems to have some performance issue as it runs very slow. Maybe not using the GPU? I'm on Ubuntu with a GTX1060.", "tags": ["bezier"], "likes": 2, "viewed": 205, "published": "Public API", "date": "1614599033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Idea from http://truetex.com/bezint.htm\n\nfloat n(float i) {\n  return 3.*sin(iTime*(1.+2.*sin(i*.01))+i);\n}\nfloat bezier(float t, float a, float b, float c, float d) {\n  float q = 1.0-t;\n  return q*q*q*n(a) + \n        3.*q*q*t*n(b) + \n          3.*q*t*t*n(c) + \n               t*t*t*n(d);\n}\nfloat color(vec2 uv, float off) {\n  vec2 a = vec2(\n    bezier(uv.x, 1., -2. + off, 3., -4.),\n    bezier(uv.x, 9., -8., 7., -6.)\n  );\n  vec2 b = vec2(\n    bezier(uv.y, 5., 2., 5., -5.),\n    bezier(uv.y, -1., -3., 8., 9.)\n  );\n  return distance(a, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = vec3(color(uv, .0), color(uv, .01), color(uv, .02));  \n    vec3 col = vec3(1.0/(1.0+c*8.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 62, 62, 109], [110, 110, 169, 169, 292], [293, 293, 326, 326, 544], [545, 545, 602, 602, 782]], "test": "valid"}
{"id": "WtyBDt", "name": "Circles background", "author": "elykkralc", "description": "Circles overlapping each other", "tags": ["circles"], "likes": 4, "viewed": 58, "published": "Public", "date": "1615245449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - .5) / vec2(iResolution.y / iResolution.x, 1.0);\n    uv *= 10.;\n    vec2 ouv = uv;\n    float c = cos(.785);\n    float s = sin(.785);\n    uv *= mat2(c, -s, s, c);\n    // Time varying pixel color\n    vec2 guv = fract(uv*5.)-.5; // grid uv\n    vec2 id = floor(uv*5.); // grid uv\n    float circle = 0.;\n    float g = (ouv.y + (sin(iTime/2.)+1.)*45. + 5.) / 10.;\n    \n    for(float y = -1.0; y <= 1.; y++)\n    for(float x = -1.0; x <= 1.; x++)\n    {\n        vec2 off = vec2(x, y);\n        float d = length(guv - off);\n        float dist = length(id + off) * 0.30;\n        float r = mix(.3, 0.5, g);\n        circle += smoothstep(r,r*.9,d);\n    }\n    vec3 col = mix(vec3(1.0,.1,.5), vec3(.1,.1,.5), mod(circle, 2.0));\n    //col += vec3(1, 0, 0) * (mod(circle+1., 2.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 968]], "test": "valid"}
{"id": "wtyBDV", "name": "Fork Treasure NikolaErce 943", "author": "NikolaErceg", "description": "treasure", "tags": ["fractal", "rarmarching"], "likes": 3, "viewed": 56, "published": "Public", "date": "1615060961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = acos(-1.);\n\nvec2 pmod(vec2 p,float n){\n  float np = 0.5*PI/n;\n  float r = atan(p.x,p.y)-1.5*np;\n  r = mod(r,np)-0.1*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n}\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;       \n        z *= scale;\n        z.xyz += offset*(1.0-scale);\n    }\n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\n\nfloat bpm = 128.;\nvec4 dist(vec3 p,float t){\n    p.xy *= rot(PI);\n    p.xz = pmod(p.xz,48.);\n    p.x -= 9.1;\n    p.xy *= rot(9.3);\n    p.xz *= rot(7.25*PI);\n    p.yz *= rot(PI*2.5);\n\n    float s =1.;\n    p.z = abs(p.z)-3.;\n    p = abs(p)-s*8.;\n    p = abs(p)-s*4.;\n    p = abs(p)-s*2.;\n    p = abs(p)-s*0.5;\n\n    vec4 sd = tetcol(p,vec3(1),8.8,vec3(0.));\n    float d= sd.w;\n    vec3 col = 1.-0.1*sd.xyz-0.3;\n    col *= exp(-2.5*d)*2.;\n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*4.;\n    p.y *= iResolution.y/iResolution.x;\n   \n    float rsa =0.1+mod(iTime*0.43,16.);\n    float rkt = iTime*0.+0.5*PI+1.05;\n    vec3 of = vec3(0,0,0);\n    vec3 ro = of+vec3(rsa*cos(rkt),-3.2,rsa*sin(rkt));\n    vec3 ta = of+vec3(0,-1.3,0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.4*cdir);\n  \n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    float ep = 0.0001;\n    for(int i = 0;i<96;i++){\n        vec4 rsd = dist(ro+rd*t,t);\n        d = rsd.w;\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n\n    vec3 col = vec3(0.025*ac);\n \n    if(col.r<0.1&&(col.b<0.1&&col.g<0.1)) col =vec3(0.);\n\tfragColor = vec4(col, 8.0 );\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 49, 49, 175], [176, 176, 194, 194, 265], [266, 266, 292, 292, 395], [396, 396, 449, 449, 766], [786, 786, 812, 812, 1228], [1230, 1230, 1287, 1287, 2094]], "test": "valid"}
{"id": "wtyBzK", "name": "Fractal 30_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 7, "viewed": 243, "published": "Public API", "date": "1614666311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e,s;\n        ++i<99.;\n        e<.001?O.xyz+=500.*abs(cos(vec3(3,2,1)+log(s)))/length(p)/i/i:p\n    )\n    {\n        p=g*d;\n        p.z-=16.;\n        p=R(p,normalize(vec3(0,10,1)),iTime*.5);   \n        s=3.;\n        p.y=abs(p.y)-1.8;\n        p=clamp(p,-3.,3.)*2.-p;\n        s*=e=6./clamp(dot(p,p),1.5,50.);\n        p=abs(p)*e-vec3(0,1.8,0);\n        p.xz =.8-abs(p.xz-2.);\n        p.y =1.7-abs(p.y-2.);\n        s*=e=12./clamp(dot(p,p),1.0,50.);\n        p=abs(p)*e-vec2(.2,1).xyx;\n        p.y =1.5-abs(p.y-2.);\n        s*=e=16./clamp(dot(p,p),.1,9.);\n        p=abs(p)*e-vec2(.3,-.7).xyx;\n        g+=e=min(\n            length(p.xz)-.5,\n            length(vec2(length(p.xz)-12.,p.y))-3.\n            )/s;\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyBzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 910]], "test": "valid"}
{"id": "WtyfDV", "name": "Neural Video", "author": "okdalto", "description": "Siren based neural video.\nThank you to Isabelle Knott and blackle mori for sharing the base code that I can play with on the google colab.\nI don't know why the blue channel does not have any value. It works well on the other OpenGL program,", "tags": ["video", "neural", "siren"], "likes": 13, "viewed": 244, "published": "Public", "date": "1615044185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getColor(vec3 uv){\nvec4 f0_0=sin(uv.x*vec4(-11.8,-6.478,6.318,-3.448)+uv.y*vec4(2.717,-4.767,5.891,-1.75)+uv.z*vec4(-2.342,4.005,3.262,1.942)+vec4(-11.65,.543,-12.39,-9.902));vec4 f0_1=sin(uv.x*vec4(9.182,-3.87,-4.772,-6.506)+uv.y*vec4(2.506,-6.885,-7.498,-.8788)+uv.z*vec4(-3.01,.3712,5.532,1.363)+vec4(-10.79,5.732,-10.57,.4026));vec4 f0_2=sin(uv.x*vec4(.5399,8.378,-3.166,-.4398)+uv.y*vec4(-6.052,1.634,2.425,-5.285)+uv.z*vec4(-6.12,5.202,-1.616,1.492)+vec4(.1202,11.67,-13.19,-11.36));vec4 f0_3=sin(uv.x*vec4(3.919,-7.5,4.391,3.521)+uv.y*vec4(-.5446,4.731,-2.739,-3.067)+uv.z*vec4(-.9406,-4.179,-2.756,1.004)+vec4(-10.37,12.37,-7.289,14.06));vec4 f0_4=sin(uv.x*vec4(3.106,4.324,-9.447,-4.617)+uv.y*vec4(-7.38,3.102,-.8453,3.348)+uv.z*vec4(.2021,-.717,2.157,5.775)+vec4(6.164,2.114,.5251,-2.362));vec4 f0_5=sin(uv.x*vec4(-4.932,.2235,-9.505,9.035)+uv.y*vec4(.4852,.5908,.6851,3.414)+uv.z*vec4(3.196,.07228,4.528,1.684)+vec4(2.498,-3.135,.7676,2.314));vec4 f0_6=sin(uv.x*vec4(4.594,-11.39,-8.989,9.752)+uv.y*vec4(-4.846,7.923,3.442,6.9)+uv.z*vec4(-7.16,4.566,5.438,5.208)+vec4(-14.46,-7.53,15.73,-12.7));vec4 f0_7=sin(uv.x*vec4(-1.891,5.863,4.571,4.242)+uv.y*vec4(-1.182,-3.945,3.776,-2.092)+uv.z*vec4(6.653,6.014,-4.965,4.893)+vec4(-.8263,17.33,5.567,.3524));vec4 f0_8=sin(uv.x*vec4(-2.2,5.507,-7.976,-11.31)+uv.y*vec4(2.454,-1.672,1.563,-5.438)+uv.z*vec4(.4295,3.906,-4.803,4.584)+vec4(-13.82,7.957,-12.08,-4.295));vec4 f0_9=sin(uv.x*vec4(5.384,-9.703,-7.578,-4.503)+uv.y*vec4(7.644,-6.819,4.937,-7.676)+uv.z*vec4(7.41,-1.341,-5.184,-4.594)+vec4(-5.61,-2.934,1.097,12.9));vec4 f0_10=sin(uv.x*vec4(8.734,8.048,3.811,11.04)+uv.y*vec4(6.148,6.494,7.045,4.408)+uv.z*vec4(6.321,-.7238,3.412,4.566)+vec4(1.936,15.52,11.29,-10.62));vec4 f0_11=sin(uv.x*vec4(-3.184,-1.582,-9.168,-.6256)+uv.y*vec4(4.104,-3.425,5.905,-4.867)+uv.z*vec4(.6865,-4.845,3.924,4.958)+vec4(7.872,-13,-5.959,4.952));vec4 f0_12=sin(uv.x*vec4(6.613,9.317,9.893,6.742)+uv.y*vec4(.8804,2.405,5.966,-3.521)+uv.z*vec4(-3.57,-4.488,-1.306,-1.339)+vec4(5.148,12.77,-5.539,-1.146));vec4 f0_13=sin(uv.x*vec4(11,-4.417,-.5812,-6.85)+uv.y*vec4(-.7683,-2.286,8.112,.6485)+uv.z*vec4(-2.879,-1.69,.5794,2.432)+vec4(6.73,-16.7,13.58,-13.32));vec4 f0_14=sin(uv.x*vec4(6.375,-8.483,-8.608,1.061)+uv.y*vec4(-7.073,-3.599,2.956,-5.402)+uv.z*vec4(-1.583,1.207,5.454,-2.049)+vec4(-.9021,-2.279,-7.984,1.834));vec4 f0_15=sin(uv.x*vec4(2.786,-8.371,-3.488,8.828)+uv.y*vec4(-5.741,-6.795,4.968,-2.408)+uv.z*vec4(2.934,-9.372,-6.82,1.408)+vec4(13.77,-5.894,-9.795,-6.679));vec4 f1_0=sin(mat4(1.102,1.695,.2694,1.672,.7081,.05151,-.06598,.08331,.2579,.1058,.1761,.4178,.04194,.2878,.6709,.1946)*f0_0+\nmat4(-.04107,.1737,-.7183,-.122,-.1917,.09183,.4327,-.4065,-.1014,.0761,-.6087,-.1118,.1158,-.2795,.9012,.2348)*f0_1+\nmat4(.04823,-.04338,-.3495,-.1703,-.7957,-.7197,-.4845,-.7314,-.07448,-.7252,-.6381,-.1593,-.01541,-.3457,-.4423,-.3561)*f0_2+\nmat4(1.3,.09912,-.7885,-.1898,-.01088,.03224,-.3231,.3318,.8228,-.1002,-.5825,-.08515,.4132,-.1008,-.2644,.02269)*f0_3+\nmat4(.623,.1891,.3658,.007564,-.515,-.2274,-.4952,.2315,-.8654,.9027,.7673,.5685,.06854,-.0552,-.1856,.7132)*f0_4+\nmat4(-.1689,-.7662,-.3373,-.0008182,1.234,.3155,.6421,-.3532,.3487,.7093,.116,-.1767,.4246,-1.064,.6483,-.6092)*f0_5+\nmat4(.2049,.2966,-.3556,.2743,.148,.3094,.4392,-.2667,.2179,.1632,-.04249,.1009,.003471,-.1264,-.03726,-.01776)*f0_6+\nmat4(.4749,.3752,.09178,.009694,-.05522,-1.111,-.6681,.1003,.5401,.04152,.2477,.05909,.2446,.3873,-.525,.184)*f0_7+\nmat4(-.5024,.095,-.1178,-.4714,.5003,.8772,.1235,-.2446,-.3244,.494,.6447,-.07414,-.05994,-.761,.2077,.04185)*f0_8+\nmat4(.007995,.3941,.07869,.08687,-.07871,.2545,-.07168,.1571,-.3476,-.6316,.4542,-.3258,-.1987,.06736,.3267,.03052)*f0_9+\nmat4(.5353,.01932,-.08251,-.007838,-.0636,.1172,-.06553,-.47,.4167,.02703,.02512,-.09331,.2687,-.1563,-.05934,.0963)*f0_10+\nmat4(-.1085,-.3372,.4723,-1.021,-.7281,-.2842,-.1415,.1851,.7841,.4257,-.1844,-.01202,.08466,-.1579,-.2548,-.6741)*f0_11+\nmat4(-.6323,.3004,-.4548,-.7819,-.2748,-.9845,1.143,-.7103,-.2258,-.3188,.1569,.3514,-.6079,-.3351,-.01559,-.4475)*f0_12+\nmat4(.1559,1.003,.867,.9119,.6334,.3459,-.207,.3924,-.3955,-.2122,.05216,.09576,.183,.8492,-.5279,.3296)*f0_13+\nmat4(-.2471,-.03553,-.1332,-.1652,-.1138,.03807,.009573,1.286,.1794,.2871,-.4129,-.3695,-.3157,-.2371,-.3875,.5441)*f0_14+\nmat4(-.1095,-.02842,-.5928,-.01371,.01453,.1016,.03314,-.02105,.08851,.4194,.2421,-.06831,-.2122,1.83,.2807,-.3334)*f0_15+\nvec4(-2.887,1.822,-3.239,-1.699));vec4 f1_1=sin(mat4(-2.607,.706,1.502,-.372,-.5367,.08019,.3993,.3969,-.4877,.1253,.6217,.02192,-.11,-.2601,-.1237,-.2693)*f0_0+\nmat4(-.06392,.5149,.3203,.5249,-.04821,-.09149,.1881,-.06311,-.02209,.1851,-.2171,.0428,.9202,.008305,-.06218,-.08048)*f0_1+\nmat4(-.1282,.0413,.1056,.1901,.07717,.345,.1091,-.7135,-.008348,.4862,.4271,.4938,-.1151,.08667,-.1552,-.1921)*f0_2+\nmat4(.05183,-.2846,-.5299,.2004,.02545,.1155,-.6046,.2778,-.03304,-.7064,.2061,-.5749,.7014,.9223,.113,.3286)*f0_3+\nmat4(.09916,-.3967,-.1752,.05513,-.1319,.02802,.425,-.04866,-.5625,.635,.7835,-.3062,-.3864,.03621,-.1949,-.1561)*f0_4+\nmat4(-.1407,-.1436,-.4574,-.5599,.2161,1.048,-.2476,.3763,-.3723,.528,.288,-.4308,-.4939,.01026,-.1101,-.08255)*f0_5+\nmat4(.1304,.01137,-.047,.2073,-.03129,-.09606,-.1881,-.1277,-.6467,-.1182,.09684,.07478,-.1718,.1089,-.1813,-.0277)*f0_6+\nmat4(-.2358,-.2507,.1896,.03187,.1864,-.3894,-.3024,-.5799,-.06973,-.01645,.7384,-.0789,.2831,-.4069,.4704,-.3137)*f0_7+\nmat4(.4347,-.5259,-1.211,.05008,.4273,.1306,-.03541,-.231,-.5567,-.1113,1.032,.5861,.1412,-.01189,.1216,.04207)*f0_8+\nmat4(.3284,.2029,-.1397,.272,-.0451,-.06112,.1218,-.1799,-.112,-.2753,-.1666,-.1317,.06767,-.2488,.1544,-.05301)*f0_9+\nmat4(.3661,.01713,-.3887,.02769,.5783,.3422,.3834,-.00511,-.2219,.1957,.2647,-.07337,.3963,-.1265,-.03872,.7151)*f0_10+\nmat4(.0505,-.1755,.231,-.1385,-.234,.1826,-.1381,-.006602,-.09,.04212,-.1341,.5043,-.1705,.03306,.2646,-.1351)*f0_11+\nmat4(.6065,-.2621,.3242,-.9399,-.2892,-.4385,.007762,-.6583,-.2745,-.3118,.6726,-.04279,-.313,.1984,.3315,-.7388)*f0_12+\nmat4(-2.188,.6005,.8659,-.2546,-.4125,.3348,-1.3,.5083,.2081,.3984,.07179,-.1938,-.5391,.351,-.3541,-.8151)*f0_13+\nmat4(-.1048,.7982,.1315,.01314,-.6244,-.4517,.04007,.3799,.2405,-.4376,-.6347,.07656,-.1082,-.5584,-.04085,-.04629)*f0_14+\nmat4(-.07501,.8043,-.07862,.2531,.1264,.006946,.183,-.05294,-.06145,.4745,.3473,.1951,-1.265,.3954,1.708,-1.057)*f0_15+\nvec4(.953,.87,3.191,.4461));vec4 f1_2=sin(mat4(-.08696,.1915,-.796,-2.624,.02233,.4882,.1771,-.04949,-.2673,.4708,.1213,-.1606,.6055,.167,.03601,.04518)*f0_0+\nmat4(-.002016,.1815,-.5048,.6871,-.2758,.1316,-.04277,.6021,.2277,.01535,-.4012,.1115,-.465,.6718,-.1199,.6509)*f0_1+\nmat4(-.1831,.05072,-.1641,-.3408,-.6596,.2587,-1.087,.01962,.549,.1515,-.9275,.2894,-.1864,-.001665,-.1468,.2897)*f0_2+\nmat4(.5287,.4062,-1.085,.4325,-.2786,-.1328,.1918,.1244,.343,-.2477,.4572,-.288,-.05107,.2188,-.4526,-.2424)*f0_3+\nmat4(-.07323,.1126,.1143,-.3951,.6832,1.006,-.2062,.5315,-.02164,.01697,.6564,-2.621,-.2275,.3354,.2661,.5102)*f0_4+\nmat4(.001267,.2217,.06373,-.3489,-.1303,.3908,.5265,-1.657,.2002,-.569,.978,.2164,.2832,-.264,-1.2,-.6963)*f0_5+\nmat4(.06442,-.1023,.1826,-.3357,.2891,.3116,.02901,.05076,-.1815,.1476,.7481,.1071,-.1866,.1685,.0577,.2934)*f0_6+\nmat4(-.1306,-.03264,-.01056,.0814,.1896,.1133,-.5196,-.6732,-.2582,.1922,.4845,.1282,-.04925,.08248,1.012,-.1163)*f0_7+\nmat4(.3707,-.5528,-.12,.09565,.427,-.03301,.303,.2976,.4233,-.1195,-.2052,-.1823,.1174,.3454,.03007,.3429)*f0_8+\nmat4(.2455,.03914,-.1765,-.2137,-.1517,.1166,.1417,-.065,.2241,.3139,-.1944,.3076,-.357,.161,.257,.2297)*f0_9+\nmat4(.1415,-.123,-.3192,-.1344,.08453,-.3331,-.1454,.1382,-.06216,-.05652,.168,.3255,.3375,-.1054,.03168,.405)*f0_10+\nmat4(-.7507,.1425,.4222,-.2103,-.2162,-.3998,-.2122,-.5889,.2549,-.1187,-.1488,-.5721,.197,.3628,.07614,-.2936)*f0_11+\nmat4(-1.016,.1228,-1.295,.3431,-.5602,-.07763,-.6651,-.4095,.07082,.05936,-.1935,-.03913,-.06541,-.3041,-.02367,.01852)*f0_12+\nmat4(.3949,.1669,-.1771,-1.019,-.6153,.8906,.6958,.5059,.09115,-.0524,-.01955,.02486,.3951,.7283,-1.061,.09309)*f0_13+\nmat4(.07951,.3608,.03377,.1714,-.3462,-.06146,.1548,-.4852,.2224,-.2226,.2524,.006574,.3705,.03057,-.1774,.1379)*f0_14+\nmat4(-.2157,-.2669,-.2721,-.08942,.06138,.1129,-.1305,-.00692,.03635,.2102,.4686,.1006,.08387,.02571,-1.142,-1.195)*f0_15+\nvec4(-1.022,-1.725,.261,-3.241));vec4 f1_3=sin(mat4(.5347,-.05409,-1.384,.1781,.3514,.03061,-.09455,-.03501,.1853,.4105,.2336,-.03099,-.1118,-.06079,-.04502,-.3252)*f0_0+\nmat4(.2214,.5041,-.01103,.18,-.04068,-.7156,-.1139,-.8258,-.2589,.2171,-.09951,-.0767,-.1895,.05714,-.2752,.0984)*f0_1+\nmat4(.1827,-.009042,.4425,-.2358,-.9991,.5023,.08238,-.07278,.2023,.3615,.4418,.2438,-.0166,-.4776,-.3296,-.4686)*f0_2+\nmat4(.04946,-.0844,-.2018,1.122,.3762,.2866,-.7845,-.0174,-.8008,-.8772,-.243,.613,-.3168,-.2029,.08961,-.8261)*f0_3+\nmat4(-.1564,.204,.06312,.1538,.9823,-.4714,.1154,.2139,-.00704,-1.216,-1.687,.043,-.07462,.4341,-.235,-.1541)*f0_4+\nmat4(.4588,-.1363,-.6838,.1729,-.2808,-.4756,.161,1.939,-.1517,.0577,.4314,-.1756,-.574,.3916,-1.145,-.2496)*f0_5+\nmat4(-.2501,-.15,.3704,.05343,-.1307,-.07327,.2832,.5273,-.4908,-.03456,-.1381,.4195,.5527,.188,-.1577,.481)*f0_6+\nmat4(-.2291,.00416,-.0161,.07387,.22,-.2663,-.2154,.2398,.4127,-.01903,-.2325,-.7285,-.2729,-.3461,-.06882,.1635)*f0_7+\nmat4(.5617,.05765,.3098,-.4271,.1245,.2643,.2117,-.4983,1.202,.4571,-.03821,-.2378,.03681,.2881,-.2858,.3167)*f0_8+\nmat4(-.1083,-.1459,-.2315,-.1489,.09953,-.1778,-.01327,.3783,.02419,-.06745,.2776,-.006475,.05932,-.1667,-.1438,-.4124)*f0_9+\nmat4(-.361,-.3202,.04936,.2859,-.4238,.1254,-.03094,-.7509,.3684,.2205,.2503,.2589,.02207,-.1833,.006791,-.1565)*f0_10+\nmat4(.618,.02322,-.8014,-.3032,.09504,-.2064,-.1232,.02016,.3476,-.1636,.7023,-.4166,.2669,.02101,-.05987,-.02794)*f0_11+\nmat4(-.8282,.1517,.7913,-.3248,.07693,.1886,-.9987,-.523,.5097,.006437,.1491,.0489,.824,.7081,-.1874,-.7815)*f0_12+\nmat4(.2012,-.3289,-.6234,-.1115,-.2436,-.7195,-.007061,.06678,-.1082,.005482,-.05655,-.03243,.2148,.3712,.4789,-.639)*f0_13+\nmat4(.1047,-.5299,.1685,.2587,-.3811,-.8942,-.2276,.1571,.01303,.5074,-.3446,.7325,-.08998,.1669,.1196,.6599)*f0_14+\nmat4(.3568,-.6026,-.1025,-.5166,-.2289,-.04408,-.3095,-.1532,-.1298,-.3477,.05965,-.1463,-.02834,-.5249,.3059,-.2356)*f0_15+\nvec4(-2.379,-1.792,.00329,-2.33));vec4 f1_4=sin(mat4(1.356,-.07262,-.2681,-2.059,-.0462,.1858,-.01312,.1199,-.09256,-.1736,.01541,.7326,-.7886,.03341,.9035,.03395)*f0_0+\nmat4(-.08188,.0676,.4267,.02452,.08603,-.2377,.03713,.1806,-.2143,-.04383,.2326,.1579,-.5439,-.07952,.2024,-.3195)*f0_1+\nmat4(-.08807,-.02092,.08865,.09539,.5335,-.1157,.472,.8644,-.3109,.388,-.1039,-.4526,-.2148,-.2413,.3841,.1091)*f0_2+\nmat4(-1.376,.5364,-.5354,-.1463,.7308,-.03705,.4356,-.02326,.3564,.2542,-.5386,.6314,.4084,.07248,-.4924,-.2245)*f0_3+\nmat4(.1897,.4652,-.1037,-.1913,-.6916,-.1538,-.5557,-.6967,-.05473,.09021,-.2679,-.9361,.2497,.1182,-.1338,.4963)*f0_4+\nmat4(.2906,-.2782,-.3211,.9606,1.415,1.593,-1.49,.1763,-.3844,-.1136,-.2767,-.3569,.05961,-.008247,-.1252,.4592)*f0_5+\nmat4(.01923,.003538,-.3702,-.1028,.03972,.01875,.3127,.2946,.5511,.04905,-.1136,.3673,-.2358,.01485,-.03844,.2559)*f0_6+\nmat4(-.02853,-.1322,.027,.3985,.2812,.00258,-.02312,-.4681,-.01478,-.009419,.6071,-.3608,-.2399,-.0687,.3004,-.1304)*f0_7+\nmat4(-.1155,1.088,.002498,.06551,-.6796,-.1463,.2354,-.2426,-.2987,-.03399,-.03846,.08506,.3869,.009537,.2752,.1767)*f0_8+\nmat4(.04586,-.01681,.157,-.01905,.2093,.0113,-.02856,.157,-.1917,.008071,.1384,-.2663,-.05453,-.0004306,.01242,-.06812)*f0_9+\nmat4(.1881,.03405,.4048,-.2072,.04029,-.02482,-.7625,.1571,-.004687,-.04471,-.1618,-.07533,-.6362,.04019,-.6717,-.04235)*f0_10+\nmat4(.349,.4559,.8662,-.1713,.2951,-.0827,.231,.03574,-.1063,-.08734,-.2327,.2061,-.0761,-.1502,.2175,-.3888)*f0_11+\nmat4(.07266,-.1652,-.5087,.4645,.8425,-.1594,.452,-.2666,.2946,.04205,-.2954,.1482,-.5516,.1742,.3847,-.4304)*f0_12+\nmat4(.9204,-.08209,.09185,-.9868,.1079,-.3471,-.09086,.1093,-.147,.0716,-.3968,.2342,-.3322,.0767,-.05679,.779)*f0_13+\nmat4(-.3853,.1265,-.07091,-.1201,.8816,.1011,-.09497,-.5814,-.0116,.01608,.1655,-.1397,.03683,.2323,.1619,.003059)*f0_14+\nmat4(-.3862,-.05294,-.3391,.3158,.07811,.0146,.2466,-.06479,-.2788,-.08047,.1193,-.1276,-.1586,.03182,-1.046,.3096)*f0_15+\nvec4(-2.277,2.788,3.078,-1.612));vec4 f1_5=sin(mat4(-.4259,.2152,.1111,2.083,.1153,-.1767,-.1114,.175,.3289,.1835,-.268,.4115,-.2905,-.346,.4667,-.3407)*f0_0+\nmat4(.08365,.5303,.1378,.1748,.1918,-.41,.01286,-.2011,-.3683,.04607,.1257,.2105,-.1712,-.7684,.7162,1.017)*f0_1+\nmat4(-.03839,-.05381,-.2536,-.3169,-.668,.8395,-.07992,.6664,-.4322,.2113,.9528,-.3473,.3664,-.04859,-.1184,.3146)*f0_2+\nmat4(.6706,-.2905,-.2123,-.4904,.09445,.02106,.08712,.3407,-.06506,-.136,.0911,.07639,.03305,.5591,-.1785,.6293)*f0_3+\nmat4(-.3341,.2452,-.3052,-.02098,.475,-.6247,.7085,.4193,-.383,-.5343,.7103,-1.266,-.01574,-.07582,-.001263,.2574)*f0_4+\nmat4(.2261,-.01186,.1307,-.3066,-.5918,-.223,-.7408,.4216,.0946,-.2736,.8586,-.3142,.2264,-.2138,.732,1.118)*f0_5+\nmat4(.05504,-.08482,.2939,-.1257,-.01918,.08161,-.3366,.2146,.1187,-.1645,-.1576,.4168,-.168,-.3755,-.3336,.1322)*f0_6+\nmat4(-.09524,-.05183,.006233,.1139,.03092,-.2859,.141,.1225,.4351,.2894,-.287,.6244,.1648,-.5175,.4486,.2212)*f0_7+\nmat4(-.01865,-.08902,-.2324,-.4306,.0003411,-.7269,.1391,-.09856,.9377,-.8962,.1053,-.2479,.2583,.4871,-.1368,.06706)*f0_8+\nmat4(-.01073,-.2799,.1565,.1419,-.00786,-.02262,-.4119,-.1024,.02581,-.3098,.04057,.006897,.3943,.3466,-.5423,-.004023)*f0_9+\nmat4(-.02451,-.2715,.2724,-.027,.6152,.1404,-.2549,.4123,.2225,.4798,-.07558,.199,.06417,.0891,1.107,-.1643)*f0_10+\nmat4(-.6091,-.7597,-.4676,-.2347,.2456,-.2963,-.2965,.4268,-.1689,-.188,.005495,.1482,.2257,-.166,-.5594,.2286)*f0_11+\nmat4(.3499,.6238,.5394,-.2399,.7947,.3042,-.3945,.4178,.1305,.3102,.2473,-.5891,.2159,.7628,-.0393,-.4708)*f0_12+\nmat4(.04506,.4211,-.3004,1.999,.03369,.2158,.3676,.1022,.3242,.1986,.1232,.04677,-.6393,.7591,-.04809,-.04408)*f0_13+\nmat4(.02689,-.5499,.3021,.01058,.6163,.001107,-.1306,-.08812,.1607,.1812,.4051,.01615,.005316,.6357,.0461,-.02071)*f0_14+\nmat4(.4017,-.6988,-.02347,-.1562,-.14,-.1758,.3271,-.1167,.1739,-.3766,-.03177,-.5037,-.4276,-.4179,1.18,-1.242)*f0_15+\nvec4(-2.678,-1.205,1.184,1.389));vec4 f1_6=sin(mat4(-1.133,.1287,-.1683,.2725,-.1906,-.2491,-.577,.6547,.8419,.3104,-.2638,-.2566,-.1817,.3867,.08165,.7232)*f0_0+\nmat4(-.008684,.6021,-.2343,.02671,-.5639,.2848,.04945,-.4815,-.2431,-.1128,-.03741,.1301,-.5179,-.6015,.1949,-.2811)*f0_1+\nmat4(-.2892,.1339,.147,.46,.1102,-.03386,.9359,.2501,-.6367,-.4491,-.1125,-.9354,-.09306,.06949,-.2682,-.1933)*f0_2+\nmat4(.724,.4792,-.08223,-.004603,.1896,.4898,-.07484,.9052,.2447,-.2679,-.2445,-.6069,-.112,.2253,-.2179,-.5066)*f0_3+\nmat4(.2569,.187,.05012,-.256,.3654,-.6734,-.0837,.1401,-2.063,-.7854,-1.169,-.2055,-.202,.3779,-.5352,-.1094)*f0_4+\nmat4(.532,-.187,-.2522,-.4588,.07057,-.07154,.4043,-.4592,.1864,.2384,-.4531,.2585,-.8711,.5263,.6688,-1.015)*f0_5+\nmat4(.01037,.2187,-.003458,-.09701,-.3044,.364,.1963,-.2168,-.2145,.842,.5699,-.4371,.06708,.3583,-.1115,-.5419)*f0_6+\nmat4(-.1159,-.1904,.2819,-.114,-.3359,-.1503,-.3033,-.05188,-.4788,.04454,-.08457,.2984,-.2233,-.7502,.2944,.2788)*f0_7+\nmat4(.9618,-.8875,.5257,.4123,.006224,-.1639,-.6154,.01134,.1823,.6264,-1.366,1.308,-.0802,.0178,.1722,-.2295)*f0_8+\nmat4(-.02038,-.05634,-.0744,.4221,.1702,.2265,-.292,-.02865,-.274,.2995,-.0002442,.2159,-.1123,.2235,-.0133,-.1721)*f0_9+\nmat4(.3149,-.3111,-.06311,-.1104,.396,.81,.4488,-.3117,.04915,.5956,-.0568,-.4216,-.2707,-.2759,-.006933,-.7957)*f0_10+\nmat4(.08356,-.4952,.1036,-.1095,.3704,-.1639,.2682,.4556,-.2873,-.2023,-.02594,-.02723,-.1106,.01696,-.2323,-.1328)*f0_11+\nmat4(.1547,-.5976,.3602,-.362,-.6951,-1.149,.5591,-.5105,.4539,.0867,-.4164,-.4809,.7302,.7819,.2874,.5199)*f0_12+\nmat4(-.9499,.268,.1386,-.1015,-.7997,-.1834,.4449,-.3013,.2013,.272,-.2521,-.08787,1.167,-.02725,.08022,.2169)*f0_13+\nmat4(.06929,-.1757,.3437,.0874,.1809,-.2491,.1032,-.286,-.4701,-.0113,.1349,-.4494,.2841,.2416,.1083,.03235)*f0_14+\nmat4(.4166,.09949,.002554,-.1114,.05894,-.03343,.3225,.07461,-.02713,.314,-.08729,.06973,-.6964,.08611,-.5003,1.073)*f0_15+\nvec4(-.9944,-3.542,-1.193,-1.442));vec4 f1_7=sin(mat4(.5962,1.493,-.03577,-1.433,-.09739,-.09784,-.1431,.2861,-.1956,-.4831,.1148,-.04439,-.05278,.2109,.3678,-.3361)*f0_0+\nmat4(.2187,-.7991,.117,1.223,-.06137,-.07028,-.1207,-.4196,.006415,-.1829,.3767,.1579,.3654,-.2476,.71,-1.08)*f0_1+\nmat4(-.1202,.3242,-.2108,-.1276,.7474,-.3512,.7929,-.2699,.1096,.3349,-.03531,-.2837,.2985,.1242,-.2078,.03793)*f0_2+\nmat4(-.04427,-.6524,.6962,-.02401,.6076,.6003,-.2287,.1619,.301,-.2231,.2172,-.3905,.8813,-.8358,.1262,-.5421)*f0_3+\nmat4(-.09396,-.1168,.3095,-.2661,.1231,.6333,.6345,-.04073,-.5698,-.4891,-.3172,-.7101,-.102,-.7512,-.01208,-.205)*f0_4+\nmat4(-.2128,-.1382,.3574,.1381,-.9825,.2086,.1297,-1.033,-1.017,-.3536,-.2051,.3835,.4518,-.03047,-.08921,.3809)*f0_5+\nmat4(-.1092,.0273,-.3503,.04178,.08097,.04403,.8114,-.3382,.1851,.09452,-.3477,.2911,.07089,.2562,-.01006,.1579)*f0_6+\nmat4(.1257,.4165,-.9387,-.09768,.1909,.07153,.2734,.1644,.2227,.325,.7043,-.009253,.6106,.07048,.02278,.3382)*f0_7+\nmat4(.708,-.4044,.224,-.05828,.8467,-.03689,.6666,.7924,-.08889,.02988,.7686,.9263,.4214,.1323,-.7246,.3763)*f0_8+\nmat4(.006762,-.6308,.05136,-.1228,.1038,.1147,-.1193,.1267,-.3393,.4523,.795,.4617,.1495,.06788,-.3352,-.1927)*f0_9+\nmat4(.3811,-.06007,.06713,.1043,.07813,.4388,.1662,-.1597,-.04612,.221,.04778,-.1286,-.2899,.2291,-.887,.4765)*f0_10+\nmat4(-.1106,-.06115,.3371,.3248,.6042,.2306,-.2655,-.3256,.312,-.1222,-.1409,.2345,-.1038,.3017,.3909,.1666)*f0_11+\nmat4(.04241,-.9432,-.9299,-1.282,.3766,.7476,-1.13,.1551,-.06914,-.1309,-.4195,.2314,-.7199,-.1257,-.3046,.714)*f0_12+\nmat4(.6723,.775,.02725,-.5926,.6212,-.6718,-.5134,.248,-.1445,-.2577,-.2769,.189,-1.499,.3855,-.863,.07975)*f0_13+\nmat4(.01308,-.3337,.1514,-.5058,-.0004392,.4708,-.6522,-.2272,.4048,-.5426,.08544,.5436,.0035,-.3228,-.4676,-.04476)*f0_14+\nmat4(.1307,.1392,.1456,.03826,-.04178,-.1024,-.0182,.1917,-.2818,.09196,.5549,.4475,-.8147,.64,-2.605,1.294)*f0_15+\nvec4(2.179,-2.073,2.453,.1605));vec4 f1_8=sin(mat4(.3705,-1.125,.2005,1.092,.09537,-.5476,.3826,.1812,-.213,-.1047,-.1739,-.5923,.254,-.09792,-.5528,-.9873)*f0_0+\nmat4(-.4361,-.2811,.2022,.3517,-.02942,-.004887,.05917,-.1811,.03068,.1775,-.1569,.1894,.442,.56,.3238,-.3457)*f0_1+\nmat4(.2337,.0009582,-.1119,.15,-.31,.385,.2455,-.7718,.3761,-.6281,.7056,-.1329,-.1474,.3623,.02104,.2021)*f0_2+\nmat4(.03526,.8104,.2195,.02209,.5256,.1401,.1721,.2536,-.8388,.8305,-.1913,-.4018,-.3513,.1809,.3067,.3362)*f0_3+\nmat4(-.1325,.2455,.0911,-.00804,.783,-.08033,.3836,.3252,-1.238,-.386,.5961,.5832,.02037,.1461,.1058,.1124)*f0_4+\nmat4(-.02584,-.05064,.4648,.2685,-.5596,.1428,.726,-.9014,-.5214,-.8355,-.1445,-.9244,.8301,.3359,-.2061,.1562)*f0_5+\nmat4(.01599,-.2104,-.337,.3232,.07734,-.1189,-.08745,.01446,-.03378,-.1806,-.3035,.6042,.27,-.01598,.01294,.1031)*f0_6+\nmat4(-.1171,-.1335,.1373,.3624,.2806,.8584,.0846,.677,.2998,.006183,.1824,-.1281,.6332,-.1759,.163,-.3452)*f0_7+\nmat4(-.5622,-.01563,-.3343,.3568,.6002,-.3214,-.2185,-.7421,1.468,-.05718,-.4007,-.1174,.178,-.01634,.2979,-.1706)*f0_8+\nmat4(.2104,-.1847,-.3049,.1744,-.2258,-.2126,.2819,.2093,.3331,.2691,.216,-.5918,.1097,.03987,.3772,.1115)*f0_9+\nmat4(.1584,-.009608,-.3392,.06721,.6198,-.06769,.1469,.3853,-.2754,.07391,.08518,-.1671,.6294,-.04236,.07573,-.2281)*f0_10+\nmat4(-.2826,.06093,-.1292,.9638,-.1551,.1815,.09073,.2071,.8557,.5452,-.02139,-.159,-.5926,.005627,.1827,-.4266)*f0_11+\nmat4(-.02197,.1143,.04648,-.6039,-.0799,.1949,.0472,-.2461,-.3045,-.1987,1.09,.1076,-.5661,-.1168,.2961,.01767)*f0_12+\nmat4(.5142,-.7863,-.5175,1.332,-.03487,.01658,.05125,-.2392,.08893,-.06461,.1332,-.1212,.2847,-.4854,.2749,.07068)*f0_13+\nmat4(.1394,-.09989,-.1917,-.1902,-.1218,-.7038,-.5866,.2327,-.05329,-.3234,.1074,-.1213,-.1979,.2009,.2358,-.01822)*f0_14+\nmat4(-.02949,.2407,.1699,.2759,-.2025,-.009587,-.09448,-.03826,-.3336,-.09119,-.1728,-.1541,.04799,-.4797,-.297,.682)*f0_15+\nvec4(-1.178,-3.78,4.302,-.729));vec4 f1_9=sin(mat4(-2.742,.3549,1.934,-1.338,.3802,-.02485,.188,-.5741,-.2223,.0635,.3921,.2778,.5999,.7634,-.3125,.3053)*f0_0+\nmat4(.4831,.1117,-.2836,-.3554,.1726,.2379,-.3378,.293,-.2494,-.3187,-.2098,-.07131,.04543,-.8872,.9186,-.8671)*f0_1+\nmat4(.1227,-.319,-.04497,-.06406,.1903,.8484,-.22,.3722,1.017,.261,1.062,.3747,-.04955,.1461,-.2592,-.2952)*f0_2+\nmat4(.1241,.7259,1.066,-.06804,.4059,.5742,-.2104,-.6709,-.0661,-.4812,.09962,.1193,-.149,-.5274,-.2147,-.9556)*f0_3+\nmat4(.2099,-.05109,-.02215,.2092,-.5766,.3533,.2661,-.4362,-.5526,-2.036,.5353,-.5907,.02938,.7818,.1885,-.1075)*f0_4+\nmat4(.006468,-.6344,.2119,.4356,-.02607,-.6698,.1949,.1107,.1643,.04837,-.2817,-.06613,-.427,.5104,.4676,-.3936)*f0_5+\nmat4(-.1924,.1014,-.1539,-.2924,.05226,-.6352,-.1772,-.2443,-.05318,-.03901,-.2017,-.419,.2162,-.2025,-.1202,-.09855)*f0_6+\nmat4(-.1625,.2231,-.08594,.01383,-.2197,-.4017,.1113,.392,.3405,-.447,.7815,-.1655,.08308,.3981,-.04108,-.8958)*f0_7+\nmat4(.1271,-.8088,-.395,-.2446,-.127,-.9141,-.4712,-.06179,-.04513,-.1027,.1558,-.2804,.6917,-.03706,.03389,.4884)*f0_8+\nmat4(-.1011,.2601,-.07452,-.2578,-.05692,-.1654,.2753,-.03062,-.3496,.0806,-.3806,.5361,.05019,.1636,-.05589,.532)*f0_9+\nmat4(-.07794,.1547,.1627,-.5505,-.04397,.6321,-.2574,.1113,-.09545,.003161,.1837,.06042,.4723,.7549,.4905,.01429)*f0_10+\nmat4(.04131,-.1803,1.048,.5406,.03524,-.3578,-.1245,-.07878,.1795,.1055,-.009109,-.01685,-.02968,-.4411,.4267,-.5195)*f0_11+\nmat4(-.07917,.6724,.331,-.05104,.3297,-.2478,.924,.006354,.3502,-.1444,.7829,.2262,.2405,.03795,-.5635,-.125)*f0_12+\nmat4(-1.771,.2883,1.37,-.8592,.4523,-.366,.2418,-.8871,-.2902,.2517,-.3965,.1289,.822,.5253,-.03803,-.8634)*f0_13+\nmat4(-.08076,.2904,-.01145,-.3267,.2303,.3909,.7805,.2889,.1171,-.2255,-.2976,.4537,.2167,.4468,-.4834,.02692)*f0_14+\nmat4(-.3801,-.01866,.02004,-.4322,-.0145,.3274,.2046,-.09246,-.3572,-.4924,.3507,-.0913,.468,-1.022,.1613,-.6718)*f0_15+\nvec4(1.849,-2.242,-3.023,-3.107));vec4 f1_10=sin(mat4(-1.179,2.025,.4664,-.4929,-.1776,.2534,.3328,.2157,-.3552,.1681,.6844,.2413,-.2451,-.9657,.2595,.6009)*f0_0+\nmat4(1.376,.4631,.5988,.1717,.04793,.1988,.5312,-.1376,.2119,.3472,.1503,-.02171,.6634,.9163,.2757,-.07276)*f0_1+\nmat4(-.02033,-.02206,-.2802,-.4788,.4481,-.7859,.1607,-.4182,-1.434,-.08992,-.4561,-.1351,-.08061,-.1327,.3641,.7259)*f0_2+\nmat4(-.8465,.6185,-.4184,.1726,.3568,-.6038,-.06929,.2078,-.3302,.2447,.8888,-.2627,.4527,-.2039,-.1903,.03111)*f0_3+\nmat4(-.03808,.1197,-.1321,.2567,-.4627,.3772,.07368,-.2089,-.4373,.7931,-.5538,.09825,-.05365,-.04882,.2331,-.1463)*f0_4+\nmat4(-.519,.4149,.8437,-.658,.6401,.5207,-2.006,-1.478,.1132,-.06617,.1496,-.3542,.03244,.819,-.04142,.05108)*f0_5+\nmat4(-.07574,-.1721,-.2838,-.05596,-.2341,-.4103,-.1382,-.1303,-.09216,.1314,.8682,.09767,.1921,-.198,-.01012,.2428)*f0_6+\nmat4(-.3978,-.03975,.2489,-.01786,.2689,.5609,-.5596,.1957,-.04773,.4005,.09999,.08203,.03843,.004375,-.5005,.1608)*f0_7+\nmat4(.6679,-.7265,.04747,-.04982,-.5499,.4986,.1261,-.5007,-.3485,.2943,-.9887,.1055,-.1416,-.4759,.2793,.3542)*f0_8+\nmat4(-.007157,.0517,.3239,-.1793,-.1087,-.01354,-.03979,-.07804,.2666,.2615,-.4888,-.2055,-.126,-.2192,.153,.2267)*f0_9+\nmat4(-.0685,-.01752,-.403,.0857,.09793,-.5524,.2446,-.04793,-.3946,-.2086,.04631,.3018,.6195,.6154,.1498,.2914)*f0_10+\nmat4(-.162,-.3336,-.9256,-.06959,.1957,-.1547,-.09262,.09217,.1535,-.05244,.1629,-.1351,.176,.1839,-.07581,-.2859)*f0_11+\nmat4(-.2638,-.3256,.9381,-.2979,.2356,-.312,-.1825,-.09803,.08108,.4747,-.3705,-.1341,.6362,-.8286,.2248,-.3782)*f0_12+\nmat4(-.3322,.9999,.7949,-.2077,-.3857,-.1304,1.25,.5058,.09131,-.01138,-.3349,.361,-.3124,-.2153,.5322,.1916)*f0_13+\nmat4(.348,-.16,.3704,-.02338,-.3527,-.1318,.5407,.0009157,.129,.161,.03358,.1862,-.1115,.08574,.6421,-.2861)*f0_14+\nmat4(.1326,.2661,.4357,-.2188,-.1061,-.06199,-.1821,-.2547,.1791,.0474,-.1138,.06734,-.3725,-1.445,.7224,-.6403)*f0_15+\nvec4(-1.82,-.7379,-.3141,3.019));vec4 f1_11=sin(mat4(-.06109,.4145,.3546,-1.93,.05967,-.05724,.3522,.3132,-.05829,-.1637,-.2159,-.05162,.1635,-.9439,-.09905,-.457)*f0_0+\nmat4(-.1093,1.028,.4716,-.4158,.1117,.04343,.25,-.6375,.01389,.05051,-.07812,-.09372,-.1868,-.03637,.2162,.4523)*f0_1+\nmat4(.01815,-.2497,.2734,.02894,.05043,.142,.2119,.6474,.3782,-.7981,.1996,-.07707,.03898,.1522,.4088,-.6541)*f0_2+\nmat4(.4222,-.09762,.3345,.2962,-.006988,.7143,-.7529,-.9754,-.282,.1556,-.02191,.2558,-.4023,-.7095,-.6329,.1497)*f0_3+\nmat4(-.2284,.02571,.4833,-.1951,.536,.02667,-.04119,-.5797,.1737,-.5634,.118,.0207,.02157,-.2495,-.0696,.2134)*f0_4+\nmat4(-.1738,-.3626,.003571,.3278,-2.481,.2022,.2594,.4099,-.13,.2057,-.01577,-.7317,-.08891,-1.179,-.2319,.9474)*f0_5+\nmat4(-.02331,-.1527,-.222,-.02262,.01041,.8207,.3187,-.1526,-.05939,-.7087,.04563,.3578,.07154,-.01271,.1338,-.1108)*f0_6+\nmat4(-.1193,-.01384,.141,.1995,-.04679,-.3969,-.1706,-.0315,-.06316,-.6446,.4779,-.6782,-.3777,-.567,-.3845,.4255)*f0_7+\nmat4(-.7231,.6273,.5029,-.356,-.2138,-.3695,.1699,.1074,-.2162,.02244,-.4964,-.801,-.001672,-.1536,.5848,.2939)*f0_8+\nmat4(-.1063,.3526,-.103,.3361,.0485,.1557,.2241,-.2935,-.04486,-.2154,.3547,.3831,.001055,.1165,-.1469,-.397)*f0_9+\nmat4(-.05924,.07682,.04627,.06253,-.121,.4582,.7805,-.001737,.03002,-.4432,.1746,-.4119,.06303,-1.027,-.2958,.5209)*f0_10+\nmat4(-.4547,.7103,.1796,-.6839,-.01366,.6107,-.1876,-.2567,-.04626,-.1217,.2091,-.5178,-.1456,-.8028,.6361,.4427)*f0_11+\nmat4(-.2847,.2362,.3759,.4007,.04965,-.3399,-.5629,-1.087,-.1211,-.8054,-.5796,.2602,.2237,.7506,-.1539,-1.834)*f0_12+\nmat4(.08016,.593,.1706,-1.725,-.244,-1.047,-.1538,.37,.02278,.09387,-.2367,.4212,.1584,-.4871,-.4026,.2132)*f0_13+\nmat4(.05505,.1994,-.1913,-.3748,.01099,-.2079,-.4842,1.105,-.04012,.2161,-.3268,.6099,.2367,.2937,.2727,.4508)*f0_14+\nmat4(-.01748,.502,.04542,.4833,.02205,-.1801,-.1087,-.1388,-.09801,-.2219,-.114,-.06706,.2733,.6521,.2094,-.9079)*f0_15+\nvec4(-3.216,1.746,3.828,-.2072));vec4 f1_12=sin(mat4(.4148,1.413,-1.982,1.068,.2746,.2149,.1543,.07175,.4161,-.3106,-.6209,.2683,-.4819,-.1377,-.1902,.3025)*f0_0+\nmat4(.01547,.165,-.1055,.7881,-.1271,.2902,.2002,.2809,.2115,-.01572,-.08852,-.07953,.07839,-.398,-.3034,-.3199)*f0_1+\nmat4(.5088,-.2786,-.0584,.0758,.9969,-.2375,-.4751,.9151,-1,-.2821,.2982,.3641,-.3085,.2764,-.3581,.08748)*f0_2+\nmat4(.2951,.532,-.3451,-.7719,.1415,.2133,.05013,.4811,.3878,.2191,-.3482,-.4474,-.3535,-.3485,.5314,.2551)*f0_3+\nmat4(.498,.1831,-.01548,.0005439,.1151,-.5706,.7207,.2056,-1.446,-.674,-.954,.0148,-.4348,.05713,.03265,-.1694)*f0_4+\nmat4(-.141,-.02714,.4944,-.2266,.2091,-.6699,.2478,-1.479,-.3366,-.06372,.02363,.4653,.2724,-.811,-.5276,.5887)*f0_5+\nmat4(.09877,.2203,-.252,.1134,-.1564,-.06829,.3828,.4134,.3733,.4992,-.3724,-.04318,-.02242,-.4357,.01781,-.07656)*f0_6+\nmat4(.2856,.07884,-.1634,-.03009,-.07283,-.1897,.1697,-.7522,.3689,.1861,.4979,.2756,-.4204,-.2312,.6043,-.2076)*f0_7+\nmat4(.05496,.3683,-.1534,.3191,-.2528,-.3853,.9476,-.3902,-.4228,.01584,.8604,.1444,-.2804,.1826,.139,-.3675)*f0_8+\nmat4(.135,.1048,.04909,.1691,.4575,-.02204,-.002569,.2347,.3759,-.09199,-.1617,-.128,.341,.1399,-.03002,.1042)*f0_9+\nmat4(.04168,-.286,.1791,-.1954,.383,.2518,.3365,.221,-.08211,-.2957,.0603,.04172,.2905,-.2029,-.5071,-.1028)*f0_10+\nmat4(.1197,.6894,-.4426,-.5949,.3558,.07773,-.5317,.5304,.8426,-.07773,.1173,-.2855,.1677,.01944,.5174,.4274)*f0_11+\nmat4(-.8108,-.1668,.5828,-.2112,-.07446,-.1323,.25,.04263,.1021,.1481,.2018,-1.608,-.373,.9175,.2138,-.334)*f0_12+\nmat4(.6672,1.775,-1.649,.9189,-.1642,.2514,.05159,.3775,-.4018,.2375,-.07828,-.2531,.1447,-.8502,-.08757,.7168)*f0_13+\nmat4(-.01951,-.3833,.3768,-.008219,-.2914,.4483,.2238,-.05236,.7437,-.1519,.07898,.1987,-.1227,.1037,-.2003,.065)*f0_14+\nmat4(.04005,-.104,.004021,.2396,.2126,.08765,.1816,-.001349,.1709,.321,.02025,.7131,-.5822,-.9318,-.4802,.01589)*f0_15+\nvec4(-2.347,.5008,1.036,1.699));vec4 f1_13=sin(mat4(-.3769,1.142,-.3506,-1.3,.2311,.1766,.363,-.08768,-.0678,-.0891,.08535,.3012,1.05,-.5599,-.2923,.3374)*f0_0+\nmat4(.2194,1.018,-1.118,1.239,.7731,.433,.06925,.3768,.3805,.1968,.2968,-.1311,.5637,-.3362,-.1962,.06079)*f0_1+\nmat4(.223,-.006177,-.2562,-.3844,-.4629,.5511,-.09968,.9587,.7208,-.8793,.05658,-.09979,.5391,.8963,.3925,.3993)*f0_2+\nmat4(.5408,.7186,.3899,-.04309,.4574,-.5261,1.186,.6028,.3972,.3906,-.11,.5744,.02563,-.4187,.1803,-.6715)*f0_3+\nmat4(-.1405,-.08841,-.3667,-.4394,.4547,.1687,.3105,.9787,-.242,-.2078,-.6504,-.9674,-.6199,-.2198,-.355,.01084)*f0_4+\nmat4(-.02467,.07243,.04966,-.09812,.07743,.06044,.2653,-.8323,.008009,-.7683,.5982,.158,-1.057,-.742,-.1415,-.9393)*f0_5+\nmat4(-.1756,.4029,.11,.1255,.1787,.3911,.2762,.3218,-.1208,.1697,-.3466,-.09868,.1727,.178,-.03372,-.307)*f0_6+\nmat4(.06357,.3732,.3392,-.2846,.2727,.3244,.2043,.09519,.7122,-.3333,.4073,-.2025,.2472,-.5781,.02712,.4481)*f0_7+\nmat4(.5878,-.2286,.6847,.007173,.3712,-.1384,.3097,.3782,.4803,-.1018,.8062,-.3814,-.1123,.1509,-.3118,.199)*f0_8+\nmat4(-.04404,-.04498,.03,.09197,-.08254,.1558,-.0731,-.1243,.3393,.4805,.04041,.7524,.2389,.07495,-.2691,-.2362)*f0_9+\nmat4(-.3272,.1038,.0006236,.2124,-.4358,.2392,.079,-.534,.2397,.3774,-.01989,.8136,-.1992,-.969,.136,.2212)*f0_10+\nmat4(.1588,-.4845,.1511,.749,-.1142,.2423,-.3069,-.2441,.3507,-.09842,.3942,-.5045,.4792,-.3768,-.4426,.04795)*f0_11+\nmat4(-.8245,-.3432,-.6415,-.5191,-.007669,-.6094,.5324,-.04458,-.3687,.1902,-.251,-.6698,.1138,1.071,1.009,.05312)*f0_12+\nmat4(-.02267,1.033,-.3936,-.5518,-.07801,.2258,-.277,-.944,-.07607,.258,-.2399,-.2852,-.6063,-.2078,.07339,.5122)*f0_13+\nmat4(.5433,.3651,.06488,.3689,-.02205,-.7016,-.5046,-.9256,.71,-.07817,.5783,-.2149,-.04958,.2342,.1799,-.7824)*f0_14+\nmat4(.2323,.3407,-.2006,-.8279,-.1009,-.06594,-.05985,.1615,.2767,-.5545,-.2093,.2108,-.4513,.7806,-1.02,-.6852)*f0_15+\nvec4(-1.686,-1.442,-1.416,-4.048));vec4 f1_14=sin(mat4(-.3522,-.1957,.7563,.5056,-.3507,-.1902,.4517,.005393,.8376,.5128,.1977,-.07527,.4343,-.5855,.5158,-.4444)*f0_0+\nmat4(-.6398,-.01875,-1.513,-.1401,.08453,.01103,.2259,-.2715,-.02766,.2821,.1108,.07685,.8395,-1.031,-.3103,.4288)*f0_1+\nmat4(.2723,-.011,-.3455,.1582,.2274,-.3477,-.7846,.4192,.3874,.3898,-.1364,-.02231,-.04194,.5357,.1887,.2479)*f0_2+\nmat4(-.05568,.5976,-.3357,.2364,-.1947,-.606,-.1797,-.243,-.4027,.2348,.3907,.187,.532,.1382,-.6391,.7034)*f0_3+\nmat4(.3115,-.3958,-.02093,-.2614,-.8897,.3768,.5941,-.3343,-1.371,-.2516,1.364,.8813,-.2465,-.05659,-.02803,-.2836)*f0_4+\nmat4(.4782,.45,.4844,.02438,1.098,1.532,-.1457,.05793,-.2024,.3357,-.06808,-.599,.3208,.9611,-.7042,.184)*f0_5+\nmat4(.3937,.2082,-.1905,.07404,.3391,-.3748,.09377,-.1166,.4505,.6188,-.3475,-.04367,.2353,.4907,.3982,-.09231)*f0_6+\nmat4(.4098,-.5634,-.176,.3836,-.4981,.1013,.06908,.2432,.7358,-.6907,.9096,.4609,.6403,-.5311,-.4419,.4026)*f0_7+\nmat4(-1.021,-.5313,.1859,.4336,-.1324,.6158,-.6807,-.2894,.1571,.9105,-.6029,-.7116,.2659,-.4821,.09954,-.03677)*f0_8+\nmat4(.273,-.1269,.1228,-.1434,-.1527,.1079,.009637,-.2872,.04808,1.004,.5021,.1794,.5276,.05488,.2655,-.1115)*f0_9+\nmat4(-.0679,.236,-.003473,-.1197,.5591,-.7547,.04437,-.26,-.1729,.2318,-.1488,.02311,-.4664,.1897,-.1864,-.2727)*f0_10+\nmat4(-1.049,.1842,-.4653,-1.102,.3945,.02279,.3424,.1013,.2942,.1085,.4235,.0732,-.2858,-.04572,.2365,.2625)*f0_11+\nmat4(-.4429,-.2362,-.3842,-.3401,-.2166,-.5472,-.3678,.5768,-.664,-.4222,-.6421,-.01799,-.03618,-1.145,-.3839,-.4529)*f0_12+\nmat4(-.1853,-.1315,.06961,.7134,-.1819,.2487,-.5504,-.1385,.4776,-.1051,.07007,-.003803,.3103,-.09423,-.3224,.3357)*f0_13+\nmat4(-.6314,-.09183,-.3988,.3758,-.4752,.6337,-.3171,-.4509,.1705,.04193,-.2984,.06924,-.3583,-.3194,-.1221,.4903)*f0_14+\nmat4(-.07131,.3382,.02812,-.01212,-.1566,-.1762,-.01414,-.02261,-.09993,.4073,.395,-.3271,-.7023,.01253,-.7936,-.5775)*f0_15+\nvec4(.7468,-2.487,-2.531,-.0247));vec4 f1_15=sin(mat4(.446,1.308,-.09785,2.171,.4593,.1776,.12,.7445,-.3443,.06107,.06127,.2284,.9473,.05028,-.01734,.0473)*f0_0+\nmat4(-.7349,-.08376,.002071,-.002243,-.1532,-.4051,.1869,.3434,-.07177,-.05962,-.1015,-.2364,-.1986,-.04212,-.1409,-.3045)*f0_1+\nmat4(-.302,-.1526,-.08891,-.1643,.3369,-.8219,-.1151,.0215,-.09219,-.2222,.1454,.1058,.2326,-.1008,-.04898,-.01014)*f0_2+\nmat4(-.07066,.2679,-.2133,.2567,.3999,.05223,.129,.00837,.3382,-.1418,-.06788,-.06448,-.5094,.2148,-.366,.08716)*f0_3+\nmat4(-.251,-.1314,.1557,-.1239,.006565,.5701,.2151,.4825,.8976,.7636,-.1043,.9485,.1298,.5227,.0628,.1739)*f0_4+\nmat4(-.07671,.4576,-.02049,.2347,-.4726,-.3273,2.09,.1049,.3189,.5872,.2465,.9157,-.5075,.4341,-.01042,-.02141)*f0_5+\nmat4(.3471,.07965,.05331,-.1321,.3325,.2316,.02063,-.07174,.0791,-.1561,-.02686,.1405,-.3348,-.07108,.02359,-.08746)*f0_6+\nmat4(.1496,-.008471,.07456,-.3835,.2361,-.1648,-.1177,-.2063,-.1024,.1139,-.02229,-.1229,-.4686,-.301,-.1684,-.4983)*f0_7+\nmat4(-.3615,-.1436,.8201,.3287,-1.548,.3874,-.326,-.2934,-.3457,.7973,-.01051,-.06356,.02301,-.2901,-.01689,.001718)*f0_8+\nmat4(-.02589,.4941,-.05039,-.2642,.3293,.1727,.1455,.1611,-.1025,.1713,.04576,-.3946,.07396,-.2059,-.02639,.05132)*f0_9+\nmat4(-.08694,.3232,.007244,-.06891,.2768,.7549,-.165,.1247,-.1482,-.8217,.2498,.3961,-.9574,.2162,.03808,.331)*f0_10+\nmat4(.1608,-.4538,-.2066,.08229,-.1204,-.3421,-.1383,.3773,-.04515,-.2954,-.1128,-.286,.1534,-.329,.1904,-.04454)*f0_11+\nmat4(.4978,.04,.07852,.1465,.5687,-.273,.159,-.5202,-.3182,.3316,-.03375,.202,.6539,.3576,.1468,.7075)*f0_12+\nmat4(.2646,-.402,.04038,.9889,.07827,-.8584,-.004612,.1598,.07524,.382,-.1703,.07286,-.1054,-.754,-.3466,.5327)*f0_13+\nmat4(.07888,-.1993,.02885,.1061,.2051,-.3072,-.00815,.07685,.1131,-.1726,.1004,-.03975,-.3467,.215,.5698,-.2603)*f0_14+\nmat4(-.584,.1778,-.07415,.1446,-.08808,.3256,-.04046,-.01762,-.1952,.3288,.05595,.04047,.7146,.1323,.04551,1.853)*f0_15+\nvec4(2.383,3.358,-2.869,3.238));vec4 f2_0=sin(mat4(-.25,-.1903,-.3117,-.096,-.4535,.4061,1.818,-.3935,.2149,-.5592,-.7087,-.04166,-.2067,.2977,.5091,.115)*f1_0+\nmat4(.2981,-.2846,.3927,.07471,-.03347,.2532,.9438,.3669,.4721,-.231,.5671,-.0666,-.553,.03478,-.2875,.7256)*f1_1+\nmat4(.4457,.4664,.2021,-.2966,.2008,.2646,-.3696,-.6009,.0777,.9145,-.4562,.219,-.3526,-.3967,.06528,-.179)*f1_2+\nmat4(.6305,-.1464,-.2486,-.1171,.1881,-.09591,-.2335,.03685,.4137,.4036,-.006225,-.06955,-.06798,-.09627,.4001,.01785)*f1_3+\nmat4(-.1115,-.1085,.6986,-.04754,.08387,.05796,-.2681,-.09254,-.2465,-.2508,.08826,-.1751,.1023,-.6352,-.7171,-.1768)*f1_4+\nmat4(-.03165,-.4066,.2802,-.3677,.05918,-.1611,.4363,.05,-.4276,.3224,.5693,-.01237,-.2549,.2894,1.126,-.2656)*f1_5+\nmat4(.2252,.001728,.247,.3216,-.05278,.6034,-.1444,.5343,-.01577,-.3009,-.364,.3512,-.01127,.06267,.0819,-.3472)*f1_6+\nmat4(.4177,.3621,.451,.2411,.3369,-.04429,.3483,-.2888,.129,.1003,.6725,-.09539,.0009181,-.1289,-.8492,.02649)*f1_7+\nmat4(.03145,.2193,-.02783,.2749,.3353,-.1891,1.169,-.195,.1143,.05548,-.01818,.2281,-.6567,-.004555,-.329,-.05743)*f1_8+\nmat4(.2067,.442,.5791,.1723,-.2403,.1439,1.294,-.4009,.293,.5072,-.02618,-.007645,-.3801,.1663,-.09906,.2672)*f1_9+\nmat4(.2058,.106,.5878,.03247,-.1197,-.2286,-.1159,.2781,-.02518,.04559,.2186,-.01577,-.3307,-.001262,.7089,-.04848)*f1_10+\nmat4(.3035,.4656,.2542,.2672,.7022,.3299,.2672,.1374,.1512,.0422,-.2494,.0355,.007559,.2712,.267,-.1581)*f1_11+\nmat4(-.1249,-.1522,-.5527,-.3344,-.1945,.1653,.6098,-.03763,-.4643,.1356,-.4946,.252,-.1746,.1105,.1731,.07357)*f1_12+\nmat4(-.4216,.02754,.9118,.005476,.172,.2871,.835,-.2435,.122,.1149,.08753,.2315,.08894,.005693,-.1862,-.001272)*f1_13+\nmat4(.009677,-.4076,-.1109,.3009,-.3186,-.6356,-.3524,.07667,.09617,.3906,.1462,.3901,.1465,-.8056,-.5061,-.3412)*f1_14+\nmat4(.1564,-.02475,.2211,.3638,.001068,-.07154,.1264,-.09642,-.09754,.3395,.02643,.1609,-.5784,-.2383,.7391,-.2321)*f1_15+\nvec4(.2956,-3.029,4.035,-2.213));vec4 f2_1=sin(mat4(-.3672,-.01906,-.2809,.2084,.006381,.4183,.5647,.04508,-.5706,-.1137,-.3636,-.08773,.01666,.09847,.8446,.04301)*f1_0+\nmat4(-.1997,-.02033,-.3296,-.2222,-.2803,.1908,-.03511,.2484,.2258,.02884,-.2247,-.0778,.6046,.03575,.2738,-.03968)*f1_1+\nmat4(.7339,-.03872,.1542,-.2339,.6111,.1229,.1109,.05782,.1725,-.1419,-.05994,-.2754,.2073,-.2046,.1277,.1688)*f1_2+\nmat4(.2119,-.05283,-.103,-.4927,.3654,.04104,.1649,-.1235,-.1007,-.2655,-.2089,.1619,-.03782,.09529,.1387,.1055)*f1_3+\nmat4(.2135,.3389,-.1606,-.19,-.04741,-.2526,.1287,.3394,.3183,.7991,-.00488,-.1705,-.09514,-.02452,-.326,.22)*f1_4+\nmat4(.2264,-.2704,-.433,.08802,.5634,-.3985,.06772,-.1539,.1442,.01122,-.2272,-.1673,-.1675,.01226,.7044,.1392)*f1_5+\nmat4(-.1704,.001145,-.1388,.0007341,-.05073,.3388,-.4718,.3421,-.03728,-.04769,-.5169,.1212,.2418,.2132,-.44,-.03762)*f1_6+\nmat4(.172,-.09302,-.01169,.235,.003463,-.2147,-.3057,-.04988,.1089,-.4346,-.351,-.004,-.256,.2607,-.5817,.2342)*f1_7+\nmat4(.05262,.1174,.02402,.141,.3846,-.5952,-.3888,-.1372,-.4858,-.5772,-.4623,-.7565,-.3333,-.2077,.006749,-.2061)*f1_8+\nmat4(.07207,-.2422,1.46,-.1313,.1024,-.112,-.0412,.2733,-.1228,-.1722,-.9039,.1141,.04206,.274,.2176,.02853)*f1_9+\nmat4(.05736,.1427,-.4149,-.2894,.1768,-.2518,-.4172,.1188,.02487,.05487,-.1427,-.2756,-.3956,-.1971,.2127,.187)*f1_10+\nmat4(.5913,.1191,.2874,.1296,.2253,.07848,-.005225,.2054,-.215,-.1707,-.3001,-.1114,-.1876,-.05619,-.4476,.2605)*f1_11+\nmat4(.4951,.07017,-.5282,-.1387,.7292,-.2416,-.3142,-.06347,.03002,.2423,.1917,.09359,.1248,.2345,.4924,-.1492)*f1_12+\nmat4(-.1157,.03823,.1391,.00495,-.2738,-.2079,.397,.4533,.08748,-.2961,-.6077,.1396,.08828,-.1381,.1222,.2391)*f1_13+\nmat4(-.3989,.1072,.1725,-.06575,.2647,-.2511,.03811,-.04852,.2831,-.1702,-.1978,-.4709,.4231,-.2746,.3221,-.3043)*f1_14+\nmat4(-.2597,-.04716,.04111,.1394,-.2947,-.08589,-.1968,.1928,-.2699,.07433,-.3245,-.2335,-.1678,.224,.01554,-.387)*f1_15+\nvec4(1.962,.1775,-2.213,-2.74));vec4 f2_2=sin(mat4(-.3229,.2695,-.06599,-.534,-.0575,.06654,-.6125,.1738,.6103,-.4629,-.1199,.09619,.07458,.3506,-.4959,-.4762)*f1_0+\nmat4(1.042,-.02685,.8807,-.05049,.1711,-.1435,.008374,.4791,-.2984,.05026,-.06642,-.05394,-.3406,.4316,-.2737,.7205)*f1_1+\nmat4(.1245,.2228,-.1687,.1141,-.5205,.3775,-.01376,.3547,-.1401,-.00672,-.1139,.8949,.4968,-.2879,-.5766,-.1614)*f1_2+\nmat4(.2975,-.2023,.02359,-.1664,.6826,-.07243,-.04137,-.2297,-.5196,.2273,-.232,.6408,-.3572,-.3329,.3283,-.2407)*f1_3+\nmat4(-.2202,-.4267,-.4011,.6898,.8962,.4021,.3661,-.3524,.4249,.1676,.4334,-.3551,.4613,-.1953,-.04382,-.4516)*f1_4+\nmat4(.3917,-.08312,-.3656,-.6633,.6256,.1561,-.36,-.04982,-.2666,.1826,.01285,.4482,-.131,.415,-.7834,-.3985)*f1_5+\nmat4(-.4193,-.03674,-.2107,-.2928,-.5996,.7433,-.2504,-.1373,-.03908,-.4358,.1979,-.1168,.4356,.5952,-.06601,.2046)*f1_6+\nmat4(-.2814,.3078,-.6824,-.5689,.2998,.03434,.2867,.1134,-.5312,.1964,-.3939,.0705,.2728,.00624,.217,-.2056)*f1_7+\nmat4(-.1309,-.04228,-.1356,-.5849,.02901,.3624,.5965,.06742,-.0059,.4853,.4858,.09414,.4905,.09424,.0639,.4676)*f1_8+\nmat4(.502,-.2072,-.5149,-.4125,.5924,-.1771,-.1997,-.1347,-.06682,.002045,.092,.2962,-.4874,.2471,.06808,.2584)*f1_9+\nmat4(.226,-.361,-.5872,1.417,.431,-.01297,.4002,.2759,-.1894,.2067,-.1795,.4016,.6474,-.467,.3167,-.208)*f1_10+\nmat4(-.08793,-.3717,-.07,.3739,-.1073,-.5368,-.1188,-.1461,-.256,.0102,.05755,1.14,-.4819,.1614,-.09704,.2612)*f1_11+\nmat4(-.1726,.2442,.2574,.00639,-.3662,.6333,-.3758,.06939,.4565,-.08275,.1621,-.1746,.5848,.3301,.02928,-.009901)*f1_12+\nmat4(.2402,.004284,-.6722,-.2053,-.0152,-1.031,-.3729,-.09302,-.07339,.1529,.05654,-.4152,-.08721,.2019,-.4161,.5147)*f1_13+\nmat4(-.063,.06312,-.0938,.3252,.4022,-.8324,.1534,.1895,-.401,.5447,.2734,-.4733,-.5686,-.3295,.03414,.04742)*f1_14+\nmat4(-.6622,-.1392,-.6396,-.05593,.2487,-.3423,.2044,.2119,-.3987,-.3845,.1197,.01048,-.2159,-.07046,-.7499,.2248)*f1_15+\nvec4(-1.552,3.718,4.398,2.242));vec4 f2_3=sin(mat4(.2707,.3594,.5624,.2745,.668,-.2408,.3852,-.168,.445,.06988,-.1007,.1802,-.3164,.2697,.3916,.05966)*f1_0+\nmat4(.2453,-.1288,.4499,-.287,.08441,.5025,.2767,-.5331,-.4972,.07247,.1096,-.4624,-.003173,-.2996,-.789,.3469)*f1_1+\nmat4(.08218,.05421,-.1824,-.171,-.5188,1.012,-.4119,-.0206,.4874,.2168,-.8911,-.8476,.1965,.04918,1.014,.2445)*f1_2+\nmat4(-.07992,.02764,.5483,.4845,.06476,.2353,.08192,-.01906,.09694,.3431,-.1646,-.5496,-.3688,.3699,-.3271,-.3158)*f1_3+\nmat4(-.3549,.5886,.6638,.06483,.5254,.2,-.1331,-.1555,-.4098,.02397,-.1077,-.5688,-.1112,-.09917,.8433,.9789)*f1_4+\nmat4(-.6747,-.2353,.2669,-.3262,-.2218,.4831,.03482,.1396,.4427,-.01747,-.4328,.02023,-.213,-.3913,1.114,-.7918)*f1_5+\nmat4(-.2599,-.2858,.04819,-.3857,.4673,.003728,-.04444,-.6209,.3229,.1697,-.5655,-.007584,-.06539,-.533,-.02816,.1128)*f1_6+\nmat4(-.4876,.1724,.7978,7.048e-05,-.02736,.07715,-.4318,-.1267,-.01561,.3783,.09754,-.7241,.7799,-.2281,-.2111,-.1241)*f1_7+\nmat4(-.2141,.0284,-.3776,.1246,.00193,-.4585,.2572,-.2152,-.3728,.3177,.372,-.6831,.5189,.4694,-.04707,.5442)*f1_8+\nmat4(.006679,-.3302,1.154,-.2033,-.1505,-.2906,.2447,-.8523,.4308,.2369,-.1101,.1716,-.0935,.1684,-.1605,.1743)*f1_9+\nmat4(.475,-.1045,.3223,-.58,-.2459,-.2579,-.3043,-.4863,.04428,.06276,-.1294,-.3141,.1941,-.4346,-.3401,.1065)*f1_10+\nmat4(.1662,-.1382,-.1149,-.4291,-.3214,-.149,.2643,-.02469,-.4165,.4719,-.05166,.3753,.2074,.08344,.09805,-.8476)*f1_11+\nmat4(-.2775,-.0892,-.5626,.4403,.8631,.1333,.1017,-.6578,-.4008,.2231,-.4559,.1831,-.2841,-.0889,.6145,.5895)*f1_12+\nmat4(.1131,-.1338,.3001,.0561,-.3778,.2441,.5987,-.2937,-.2209,.3996,-.05287,-.05452,-.07346,.2941,-.0348,-.02598)*f1_13+\nmat4(.382,-.2731,-.1353,-.1855,.1611,-.3016,-.3484,.7892,.1178,.1836,-.1012,-.1903,-.0843,-.3134,-.007319,.4209)*f1_14+\nmat4(.4819,.01179,.4735,.2683,.3078,.5727,-.234,-.5775,-.04185,.04016,.1486,.3431,-.02452,.8711,-.252,-.5118)*f1_15+\nvec4(3.656,1.736,1.315,2.305));vec4 f2_4=sin(mat4(-.173,.05222,.4366,.02267,1.093,.4887,.5772,-.1017,-.1201,.1809,-.1422,-.6516,-.3108,.1059,.02487,.6799)*f1_0+\nmat4(-.9518,-.08918,-.4105,-.09392,-.1645,-.5233,-.143,.4336,-.2218,.5265,.4662,.02915,.3017,.04346,-.2676,.02065)*f1_1+\nmat4(.2481,.1309,-.1052,-.4348,.2036,.2752,.05184,-.02448,.4614,.3055,-.208,-.4871,-.1976,.0873,-.7106,-.1134)*f1_2+\nmat4(-.3088,.002707,-.01941,.3097,.01005,-.008181,.1174,.06136,.532,-.5581,.2061,-.4285,-.02624,-.08106,-.06395,.2755)*f1_3+\nmat4(-.156,.7295,-.303,.1102,-.1002,.2235,.3165,.1819,-.4521,-.7356,-.0175,.06054,.08468,.1202,-.4114,-.5069)*f1_4+\nmat4(-.1357,.3818,.281,.2461,.03448,.1693,.01402,.1877,.2565,.4437,.5084,-.1358,-.1107,.8493,.7085,.7586)*f1_5+\nmat4(.6586,-.8723,.154,.5359,-.1553,.2588,-.2313,.2312,-.5379,-.4528,-.5467,.6692,-.8695,.02219,.05121,-.01867)*f1_6+\nmat4(-.07378,.1987,.1987,.5952,-.06017,.1784,.169,.1904,.3535,.2592,.3174,.1993,-.2678,.1857,-.3123,-.2615)*f1_7+\nmat4(-.192,-.08902,-.1811,-.4242,.4049,-.2323,-.1648,.07136,-.3558,.1993,.03033,.232,.3663,-.124,-.05621,-.2259)*f1_8+\nmat4(-.457,-.3555,.4184,.301,-.01672,-.2146,.6405,-.215,.0857,-.04698,-.1063,.3366,-.7621,-.3994,.5221,.2367)*f1_9+\nmat4(-.03586,.6272,-.2681,-.2808,-.2128,.5287,.4857,.4387,.2725,.3102,-.2786,-.2609,.4801,-.2801,-.4436,-.3485)*f1_10+\nmat4(-.03168,-.02457,.06276,.1991,.4876,.04331,.5207,.1666,.01613,.1316,.3805,-.3063,.7198,.8449,-.07429,.7499)*f1_11+\nmat4(-.807,.3281,-.01166,.1697,-.7453,.82,.03451,-.1409,-.3326,-.08472,.3418,.8772,-.3351,.7225,-.2241,.4944)*f1_12+\nmat4(-.09258,.1552,-.06562,.07778,.7556,-.1862,-.3032,.4037,.4072,-.1909,-.0825,.6736,.6024,.2634,.1727,.6943)*f1_13+\nmat4(.5273,-.008585,.5153,-.4832,-.2794,-.696,.07915,-.5391,-.1761,-.08389,.3501,-.1863,.1673,.0324,.4237,.4742)*f1_14+\nmat4(.6566,.0115,-.006451,-.1802,-.07796,.4839,.6685,.6067,-.435,-.1433,.03044,.7079,.38,.02731,-.1645,.5303)*f1_15+\nvec4(1.775,1.996,1.657,-.1305));vec4 f2_5=sin(mat4(.3358,.5053,-.1132,-.2175,-.3679,-.2373,-.1752,-.01528,.6468,.06049,.2769,-.002758,-.5582,.1808,-.5015,.1869)*f1_0+\nmat4(.1343,-.1161,-.5504,-.2909,-.2848,.2023,-.1689,-.7594,.1676,.4837,.27,-.4576,-.3893,-.00282,-.1661,.0789)*f1_1+\nmat4(-.4297,.2371,-.04458,.2271,.2008,.01537,-.3313,.3328,-.06017,-.3054,-.121,.2522,-.4185,.6092,.1688,-.2292)*f1_2+\nmat4(.07844,.349,.3149,.007963,-.06713,.001755,.15,.06972,.1284,.2197,-.2119,.08755,.2044,-.09707,-.2455,-.05197)*f1_3+\nmat4(.09746,-.1052,-.3754,.03548,.2138,.1251,.7288,-.4357,-.1699,.2486,-.3718,-.06101,.7243,-.136,.07115,-.01046)*f1_4+\nmat4(.1921,.4121,-.01841,.06398,-.3247,.3435,.2561,.813,.1728,-.1389,.1505,.065,-.8901,-.151,.4283,.2619)*f1_5+\nmat4(-.06911,-.2477,-.2678,-.1629,.2344,-.1651,.1711,-.3333,.211,.004207,.3036,-.2592,-.2704,.614,-.4337,-.286)*f1_6+\nmat4(.03169,.4371,-.03945,-.1596,-.4476,.06133,-.09526,.1854,-1.052,-.3308,-.09917,.3393,.32,.03622,-.4004,.1404)*f1_7+\nmat4(-.08035,.1809,.3306,-.3053,-.03358,-.4656,-.4276,-.3366,.7219,-.2635,.3913,.05125,.1072,-.0952,-.02853,-.3224)*f1_8+\nmat4(-.8978,-.1563,.4172,.05456,.2581,.2146,.2768,-.2499,.1905,.1369,-.1618,-.157,-.6229,-.102,-.5801,.2227)*f1_9+\nmat4(-.157,.3406,-.1595,.2395,.3048,.4459,-.4435,.2728,.209,.3993,.03216,.33,.5504,-.02602,.1591,-.1605)*f1_10+\nmat4(.3753,-.1519,.3589,-.2214,-.1501,-.1146,-.1772,.1345,.3429,.1776,.5664,-.006402,-.09314,-.2895,-.1823,.09567)*f1_11+\nmat4(.2624,.5514,-.1465,.1092,-.3382,.08438,.8689,.2607,.0415,.002527,-.6468,-.07855,.4179,-.0111,-.1432,-.2457)*f1_12+\nmat4(-.07518,-.06822,.388,.2113,-.2874,-.01438,-.06405,.2521,-.1296,.0905,.2104,.1795,.01378,.09319,-.07132,.3968)*f1_13+\nmat4(.218,-.264,-.1233,-.231,-.4185,-.1224,-.1855,.4416,-.3387,-.2128,-.3298,-.08513,-.351,-.6439,.2664,-.2133)*f1_14+\nmat4(.1223,-.4563,-.2978,.3608,-.3961,.03233,.4136,-.8045,-.06851,-.1918,-.04026,-.2166,-.6097,.4617,.7615,.252)*f1_15+\nvec4(-1.489,2.36,1.223,2.885));vec4 f2_6=sin(mat4(-.4581,-.1817,.5186,.01434,-.2066,.2573,.1768,-.009968,.3349,.1425,-.3762,-.01956,-.5905,-.7096,-.1616,-.03141)*f1_0+\nmat4(.6129,-.1542,-.1661,-.002622,.02491,-.3779,-.07828,.005535,-.8714,-.04044,.2232,.01404,-.03221,.02139,.1461,.008832)*f1_1+\nmat4(-.06459,-.03252,.1157,-.0585,-.0819,.7847,-.2668,-.01631,-.3544,.183,.4628,-.00166,.3708,.1465,-.08572,.005676)*f1_2+\nmat4(.3417,-.02902,-.2742,-.04396,-.2151,-.0107,-.1631,-.01608,-.3076,.03558,-.3307,.01532,-.4693,-.1279,.09322,-.008594)*f1_3+\nmat4(.6185,.3445,-.05164,.006253,.2877,-.4358,.4855,-1.214,-.05193,-.02979,-.2765,.02461,-.1307,.4749,-.05612,.003941)*f1_4+\nmat4(-.3141,-.5137,.5746,.07519,-.451,.2565,.1992,-.03698,-.3057,-.02741,.01996,.01976,-.04158,-.1822,.2973,.008493)*f1_5+\nmat4(-.4009,-.0889,.1513,-.01741,-.05373,-.03281,.1585,-.007661,-.07486,.1944,.2383,.005366,.2897,-.03988,.1122,-.009583)*f1_6+\nmat4(-.4371,-.1182,.201,-.007944,.08244,-.08894,-.09034,-.001209,.1954,-.3549,-.145,-.008464,.8295,-.07347,.08156,-.02192)*f1_7+\nmat4(-.3776,-.2864,-.08514,.01965,.3557,-.2964,.169,.01402,.4092,.2373,-.4871,.01809,-.2037,.1728,-.07597,-.01558)*f1_8+\nmat4(.06589,-.6535,-.0006331,.006451,-.3915,.04912,.1558,.02136,-.7101,-.4113,.4037,.02029,-.03547,-.4076,-.09363,-.01636)*f1_9+\nmat4(-.08812,-.1596,.2493,-.02743,-.746,-.3258,.5383,-.01575,-.1629,-.1012,-.0443,-.02395,.3715,-.1274,.1128,.04039)*f1_10+\nmat4(-.1605,-.3555,-.1378,.5125,.4682,-.4423,-.6058,.003976,-.4293,.666,-.7362,-.1097,-.4481,.1631,-.1705,.0003192)*f1_11+\nmat4(.2943,.03407,-.2712,-.01479,.5703,-.4147,.08134,-.01726,-.6782,.3401,.005477,.01445,-.3846,.3336,-.2489,-.01845)*f1_12+\nmat4(-.2854,-.1201,.6388,.003681,-.2139,-.4614,.04445,.0137,-.1433,-.06107,-.4562,-.01618,.06923,.09167,.1622,.008156)*f1_13+\nmat4(.03264,.03186,-.299,-.005277,-.02642,.2142,-.1652,-.007355,.4526,-.3786,-.4213,.004085,.354,-.21,.2337,-.009493)*f1_14+\nmat4(.4324,.4379,-.716,-.03083,-.1246,.1732,.1211,.001477,.07478,-.5028,-.2284,-.4227,-1.066,.3092,.3718,-.0008547)*f1_15+\nvec4(3.227,2.576,.5459,-.4636));vec4 f2_7=sin(mat4(.1856,-.4505,-.03696,.1043,-.03207,-.3869,-.04424,-.1096,-.2004,-.04102,.001494,.2277,.3877,-.1573,.03458,-.5622)*f1_0+\nmat4(.1526,.7836,-.007796,.6444,-.6308,-.4068,-.005431,-.4207,-.2542,-.06922,-.02872,-.3448,-.2632,-.401,.04032,.2667)*f1_1+\nmat4(.264,.6254,-.04317,-.02014,.06992,-.07146,-.03815,-.3824,-.7142,.08698,-.05013,.1265,.3704,.5906,-.002448,-.013)*f1_2+\nmat4(.5661,-.3225,.07491,-.5204,-.3563,-.1507,.1814,-.5071,-.7955,-.1203,.06249,-.1472,.2969,.1271,.02802,.3618)*f1_3+\nmat4(-.3024,-.3838,.03295,.1368,.1396,.09122,.3056,-.4909,.2296,.08717,-.05197,.23,-.6138,.297,-.005467,-.2008)*f1_4+\nmat4(.3607,.4305,.1254,-.189,-.194,.4528,.04451,-.2752,-.2424,-.1599,.01634,.04181,.3777,.03045,-.04542,-.3615)*f1_5+\nmat4(.05168,-.002546,.06667,-.2224,.0846,.111,.02765,-.3255,-.1802,.2025,.004196,-.3143,.005631,.2961,-.005025,.06571)*f1_6+\nmat4(-.4989,-.195,-.0633,-.06196,.224,.2103,.02007,.03138,-.3733,.152,.02923,-.236,-.2202,.1101,.005708,-.04718)*f1_7+\nmat4(.5623,.1825,-.01962,.07675,-.08392,-.2694,-.01918,-.08242,.06697,.4668,.117,-.1878,-.1498,.1193,-.01157,-.1198)*f1_8+\nmat4(.1403,-.1321,-.01577,-.186,-.04265,-.05298,.02594,-.03117,.2378,.5507,.01096,-.5932,-.2928,.2647,.0231,-.5262)*f1_9+\nmat4(.2412,.401,.03386,.1883,.4473,.374,.02946,-.444,-.06465,.1961,.06955,.4672,-.4264,.1696,.1478,.1719)*f1_10+\nmat4(.771,-.1664,.7797,.1413,.1702,.02375,-.02668,-.04382,-.5097,.3955,.003946,-.3256,.03211,-.1486,.004931,-.2145)*f1_11+\nmat4(.6208,.2822,-.01813,.2057,.463,.0127,.002953,-.6782,.3107,.193,.02192,.1306,.3215,.1608,-.0329,.09244)*f1_12+\nmat4(.582,.2421,.1053,.7514,-.2034,-.357,-.01299,.2662,.1943,-.6099,.02771,-.06163,-.3336,.5864,.01003,-.1455)*f1_13+\nmat4(.5214,.1854,-.0388,.3825,-.07692,.2027,-.01022,.009033,.1606,-.09779,-.03808,-.5154,.1894,.4097,.05744,-.006819)*f1_14+\nmat4(.1253,-.03511,.09555,.3352,.2288,-.336,.004486,-.2572,.1404,.2218,-.8506,-.1019,.05041,.4303,-.06355,-.26)*f1_15+\nvec4(1.779,1.886,-2.998,-2.266));vec4 f2_8=sin(mat4(.1465,-.2383,.5337,.09257,-.02776,-.3244,-.5775,-.1754,.09599,.1523,.6498,-.04414,-.109,-.07793,-.2983,.1443)*f1_0+\nmat4(-.09154,.2339,-.2004,.2126,.1097,-.1061,-.08453,-.5573,.1245,.5077,-.03242,.1159,-.05729,-.2102,-.245,-.5792)*f1_1+\nmat4(.04311,.2085,-.1132,.0764,-.4303,-.1031,-.1244,.2655,.06804,.3634,-.1323,.3092,.1063,-.6047,-.09287,.05311)*f1_2+\nmat4(-.05569,.3449,.3197,.1313,-.2103,.3426,.1531,.2492,-.1606,-.04793,.4968,-.5356,.1712,-.3188,-.4806,.1347)*f1_3+\nmat4(-.1731,.06717,-.09428,-.341,.1346,.1096,-.05383,-.2231,-.2492,-.7916,-.1105,.3938,.05928,.1532,.4319,-.01197)*f1_4+\nmat4(-.1211,-.4424,.4138,.01015,-.1725,.4165,-.4006,.1035,-.2729,.03915,.2039,-.3395,.06084,.6057,-.3392,-.1649)*f1_5+\nmat4(-.05805,.03215,-.06394,.003631,.09969,-.3624,-.0919,.2501,-.0288,.2056,-.2661,-.3563,-.1034,-.1933,-.06977,-.1121)*f1_6+\nmat4(.1438,-.5343,.3406,-.2723,-.08734,-.2171,-.3402,-.4022,-.1345,-.04543,-.374,-.4094,.001202,-.3345,.07269,.3864)*f1_7+\nmat4(.2047,-.3639,.04205,.3962,.1199,-.4358,-.1068,.4842,.03831,-.2945,.1453,.1698,.02085,-.522,.3029,.4843)*f1_8+\nmat4(.08665,.1585,-.3051,-.7141,-.05118,-.3382,.08832,-.3658,-.005151,-.2558,-.1552,.3451,-.00996,.8636,-.5882,-.3613)*f1_9+\nmat4(.122,.01404,-.2417,-.8798,-.06513,.2077,-.1438,-.235,.05068,-.2466,-.12,-.5317,.5132,.2337,.7432,-.2327)*f1_10+\nmat4(.5833,.3031,.1533,.1348,.1107,.5423,-.2925,.348,.1964,.6829,.3091,-.01055,.03216,-.3754,-.3608,.1529)*f1_11+\nmat4(.2171,-.1326,.04086,.1086,.0374,.3344,-.4095,.3369,-.09386,-.6547,-.07203,-.3274,-.03748,.1598,.2782,.1073)*f1_12+\nmat4(.1399,-.1594,.4013,-.2305,-.08239,-.3743,-.09815,-.6233,.01577,.004284,.5048,-.3626,.02127,.2404,-.1871,-.4019)*f1_13+\nmat4(.1777,-.5736,.188,-.257,-.2599,.7596,-.1025,.5549,.07295,-.1141,-.417,-.3192,-.1611,.2986,-.4695,.003994)*f1_14+\nmat4(-.0306,-.08522,.1591,-.1098,.06987,-.04615,.3844,.3556,-.2236,-.08052,-.3664,.1036,.1025,-.5426,-.2051,-1.001)*f1_15+\nvec4(-2.448,-.9483,3.092,1.931));vec4 f2_9=sin(mat4(.1437,-.5397,-.4691,.3298,-.3873,.0001672,-.2175,-1.134,.1562,.3644,-.3436,.3971,-.609,.556,.2811,-.003195)*f1_0+\nmat4(.6586,.1353,-.1226,-.3196,-.4514,.472,-.3048,-.5339,.5259,-.1254,-.02997,.07759,-.2796,-.08906,.01978,-.6133)*f1_1+\nmat4(-.1307,.3454,-.1271,.3758,-.3834,-.1381,.2523,.2356,.116,.1829,.1063,-.552,-.5527,.3235,-.3304,-.5138)*f1_2+\nmat4(.6326,-.456,-.1065,.05518,-.3508,-.03423,.2452,-.186,.7062,.1655,-.1443,.1002,-.1102,-.003328,-.06565,.1516)*f1_3+\nmat4(-.05641,-.003952,-.1603,-.546,.2888,.1246,-.09308,-.3649,.2631,.446,-.492,-.1944,-.318,.02961,-.589,-.7511)*f1_4+\nmat4(.3621,.1309,-.1244,.05255,.1774,.5218,.08814,.1683,-.1131,-.2758,.3118,-.3644,-.1393,.4248,.1769,.7656)*f1_5+\nmat4(.1609,.4332,.1695,-.1666,.07044,.0958,-.2809,.2686,.1807,-.1065,-.1847,-.4949,.07928,-.2129,-.4811,-.1644)*f1_6+\nmat4(.2054,.1379,-.4167,-.1185,.5997,.02655,.1108,.2037,-.03194,-.3478,-.2078,-.2965,.5814,.1323,.01619,.1801)*f1_7+\nmat4(-.6507,-.02368,-.2643,.2913,.1052,-.02199,.1562,.2241,-.04922,.2113,-.458,.6924,-.1393,.2575,.05795,-.2061)*f1_8+\nmat4(-.7746,.0134,.01642,.8216,.6388,.545,.01975,.005721,.5726,-.8711,-.07526,.3822,-.7918,-.4144,.4949,-.5386)*f1_9+\nmat4(.2159,.3363,-.04243,-.9382,.5859,.4951,.5609,-.5261,.1308,-.1977,.2314,-.2932,-.04717,.2771,-.3047,-.07123)*f1_10+\nmat4(.2725,-.5972,-.02808,-.1827,-.1522,.3319,-.005401,-.331,-.09179,.1287,-.1943,-.1318,.5221,-.02648,-.04465,-.2315)*f1_11+\nmat4(-.66,-.6881,.03923,-.7131,-.3603,.0669,-.2439,-.2547,-.3093,-.4798,-.1895,-.4776,-.1524,.3901,.09001,-.2118)*f1_12+\nmat4(-.1286,.4681,.2736,.3224,.354,.9531,.001951,-.1863,.6554,.1921,.1375,.1952,.4651,.2768,.007098,-.1815)*f1_13+\nmat4(.2706,.1919,.3164,.5864,-.006523,.5869,.4784,-.1088,-.3589,-.558,.4313,.1181,.349,-.2526,.4335,.3357)*f1_14+\nmat4(.3957,.2891,-.0375,.3281,.2749,-.5911,-.01042,.273,.0484,-.2637,.3386,.02734,-.1432,.5145,.3754,-1.037)*f1_15+\nvec4(-1.337,-3.832,1.856,.7312));vec4 f2_10=sin(mat4(-.1256,-.2003,.1984,-.1032,.1659,-.4957,.2268,.6232,.0007513,.1126,-.4873,-.01729,.1961,.04985,.2236,.7362)*f1_0+\nmat4(.3913,.8559,.565,-.2878,.1837,-.438,-.399,-.2562,-.1346,.6859,.9613,-.06486,.2333,-.1476,-.5796,-.2377)*f1_1+\nmat4(-.1445,-.3939,-.2496,.1154,.1341,.1838,.06957,-.3607,.06186,-.1284,.006451,-.2273,-.007641,-.8743,-.1318,.729)*f1_2+\nmat4(.2355,-.08585,.3241,.4347,.05523,-.06638,.3632,.1309,-.07772,.2877,-.2324,-.07249,.3443,-.1641,.2022,.3417)*f1_3+\nmat4(.3052,-.3735,-.4609,-.0464,.1999,.3551,.03507,-.2901,-.03985,.01029,-.2759,-.1255,-.2348,-.118,.5708,-.1277)*f1_4+\nmat4(.2704,-.319,.05149,.7482,-.4447,-.5357,-.8698,.6532,.2232,-.3195,-.2329,-.01603,-.136,-.2844,-.1289,.5868)*f1_5+\nmat4(-.297,-.06167,.2911,-.004503,.2928,.08759,.4316,.0473,-.1361,-.5947,.1503,-.2509,.1439,.2197,-.3209,.07036)*f1_6+\nmat4(.02145,.2292,-.06489,-.1085,-.04244,-.3897,-.1331,-.4798,-.2565,-.06738,-.0881,.2179,.142,-.00502,-.02096,.1361)*f1_7+\nmat4(.274,-.02506,.09569,-.03113,.328,-.1299,-.3375,.9784,-.3547,-.1794,.02239,.06093,.1377,.1397,.0538,.7766)*f1_8+\nmat4(-.05921,-.4377,-.5892,.7696,-.1479,.365,.265,-.3685,.3893,.405,.2552,-.05234,.1823,.4274,.08632,.3084)*f1_9+\nmat4(.5115,.127,.003804,-.1258,-.1009,.4897,.7788,.1807,-.04851,-.2881,-.4362,-.2052,.1469,-.3131,.2057,-.07032)*f1_10+\nmat4(.6409,-.4931,.009639,.07177,-.1413,.3331,.5827,-.5198,-.3524,-.2093,-.2029,-.2534,.07706,.2312,.5327,-.004097)*f1_11+\nmat4(-.1622,-.2574,.4972,-.0516,-.1677,-.6518,.8437,1.34,-.1028,.2759,-.3785,-.0008397,-.08077,-.7191,.4998,.2801)*f1_12+\nmat4(-.09686,-.7516,.1391,.1624,-.06254,-.5244,-.08156,-.6603,-.2077,-.931,-.2714,.2635,-.2881,.3792,.03737,-.2192)*f1_13+\nmat4(-.1071,-.02423,-.3384,-.1038,-.2541,-.09917,.1028,.08758,.002552,-.4875,.1372,.419,-.1892,.3334,.7122,-.8112)*f1_14+\nmat4(-.1095,-.118,-.1029,-.4178,.4343,-.0248,.3968,.3119,.4697,-.2152,-.4146,-.05752,-.3197,-.4706,.153,-.4607)*f1_15+\nvec4(1.44,-2.313,4.016,1.844));vec4 f2_11=sin(mat4(-.1343,-.05212,.03919,.2064,.3442,.1415,.7857,-.1047,-.2237,.07352,-.5692,.1295,-.2328,-.578,.3141,-.07818)*f1_0+\nmat4(-1.273,.1079,-.1651,-.007112,.8233,.3309,-.2306,-.06956,-.004481,.004687,.3198,.2372,.2856,.09343,.537,-.2408)*f1_1+\nmat4(.5319,-.2327,.005822,.03712,-.2658,.245,.06799,-.2499,.4809,-.1935,.3939,.1116,.009034,.01402,-.4895,-1.005)*f1_2+\nmat4(-.4165,.3313,.02646,-.1264,.1404,-.04582,-.07083,-.7263,-.05525,-.3546,.5584,.6663,-.05609,.2017,.2753,.5264)*f1_3+\nmat4(-.1353,.6442,.5685,-1.133,-.1266,-.4272,-.2542,.1918,.6115,.02303,.08483,.1228,-.1417,-.05639,-.6024,-.5757)*f1_4+\nmat4(-.2841,-.1512,-.08415,-.04934,-.1027,-.07465,.085,.3799,.3313,.08023,.2875,.04826,.455,-.2515,-.4375,1.505)*f1_5+\nmat4(-.1554,-.1576,.2594,-.3828,-.1176,.2463,-.1159,-.215,.04323,.2662,-.1287,-.579,-.3073,.2158,.1467,.2302)*f1_6+\nmat4(.1601,-.1293,-.2524,.4992,-.0695,-.1088,-.4982,-.1347,.3774,-.3079,.6499,-.0396,-.02919,.1216,-.5707,-.3705)*f1_7+\nmat4(-.2332,.02226,.1749,.6373,-.2779,-.2054,-.1804,-.08376,.2859,-.4265,.2425,.07604,-.5975,.06824,-.03779,.03301)*f1_8+\nmat4(.8636,-.2824,-.3434,.4855,-.008381,-.2427,.4076,.1871,-.0772,.05702,-.4493,.5544,-.2523,.2885,.5792,-.471)*f1_9+\nmat4(.1215,-.3626,.3502,-.4178,-.04472,.2232,-.1831,-.05339,-.04701,.348,.4358,-.1191,-.1333,.2199,-.1678,.03315)*f1_10+\nmat4(-.2846,1.012,-.04079,-.2627,.2053,.2214,-.06023,.1066,-.1188,-.04264,-.08186,-.2039,.2238,.5213,.7783,.1212)*f1_11+\nmat4(-.6723,.3512,.3412,-.4244,.1776,.3371,-.3868,-.2542,-.517,-.04812,.5961,-.07275,-.202,-.1124,.1582,-.348)*f1_12+\nmat4(.2209,.1086,.4116,.2748,.01244,-.1654,.4631,.3585,-.1452,.2069,.04071,.09364,-.1511,-.4905,-.08116,.1104)*f1_13+\nmat4(-.1379,.3721,-.1645,.2978,.007935,.3429,-.1846,.06848,-.4722,.4104,.08048,-.6255,-.167,.143,-.3803,-.4649)*f1_14+\nmat4(-.01213,-.003701,.007171,-.407,.5559,.3421,.1424,-.2796,.01859,.423,-.3534,.06439,.5001,.1827,.6266,-.8983)*f1_15+\nvec4(-2.84,2.053,-1.25,-2.007));vec4 f2_12=sin(mat4(.1967,-.3513,-.01272,.3028,.3123,-.2162,-.3556,-.9895,-.1075,.1008,.6999,-.1296,.302,-.05965,-.2822,-.07367)*f1_0+\nmat4(-.9552,.2169,1.189,.01077,.277,-.1352,-.3649,.04516,.02576,-.05681,-.2259,.2348,-.1283,.3878,-.351,.4076)*f1_1+\nmat4(-.5674,-.2197,.3744,.4893,.07144,.3096,.1217,.3441,.4657,-.2327,-.02091,.3578,-.06235,-.1069,-.2304,-.5059)*f1_2+\nmat4(-.0399,.04814,.1684,.09259,-.3207,.5308,.4276,.3721,.1522,.09171,-.1896,-.06543,-.1053,-.1652,-.2684,-.1805)*f1_3+\nmat4(-.7178,.1284,.09497,-.6258,.07047,.2907,.4034,-.7465,.007978,-.1444,-.05561,-.2683,.2359,.03574,.1516,-.3412)*f1_4+\nmat4(-.2053,.2103,-.1658,.05209,-.09412,.1875,.384,-.132,-.5222,-.1782,.2824,.09179,1.137,.08965,.4664,-1.147)*f1_5+\nmat4(.01365,-.2368,.1747,-.1721,.4411,-.03352,-.443,.08732,-.4618,.3496,.1394,.215,-.07066,-.06882,.1005,.231)*f1_6+\nmat4(1.126,.1751,-.1712,-.5901,-.2669,-.0517,.2522,-.7404,-.2559,.08303,-.1154,-.428,-.5346,-.1222,.009946,.5616)*f1_7+\nmat4(.0145,-.09934,-.3403,.7531,.1354,-.3987,-.3423,-.5008,-.1456,.04504,.5955,.04424,.08526,-.3602,-.1357,.1053)*f1_8+\nmat4(.8098,.2277,.3348,-.547,-.3154,.05236,-.5042,-.03561,-.000639,.167,-.6843,-.04903,.1757,-.04303,-.3654,.34)*f1_9+\nmat4(-.4274,.07457,.3356,-.4654,-.1398,-.1604,.4292,.28,-.05485,.059,-.07545,.008097,-.06891,-.08073,.08454,.07482)*f1_10+\nmat4(.05314,.1176,-.2911,-.1156,-.4805,.3441,.2933,-.4566,.5153,.0381,.1715,.2267,-.07532,-.2536,-.28,-.2248)*f1_11+\nmat4(-.4813,-.2582,.08129,.699,.4959,.03219,.02511,-.2062,-1.069,.4037,-.07615,.7617,-.4979,.2489,-.2545,-.6547)*f1_12+\nmat4(.2515,.3104,-.3474,-.01164,-.4916,-.2053,.3173,-.7931,-.4935,.2714,.07694,-.2939,-.1899,.2113,.006415,-.788)*f1_13+\nmat4(-.04675,.1704,-.03608,-.1497,.2303,-.09542,-.4776,-.2878,-.009578,.2045,-.05038,.5333,.2456,.06494,.2431,.1596)*f1_14+\nmat4(-.03436,-.06171,.04611,-.5433,.07274,-.005865,-.1441,.3102,.178,.07019,-.05857,.2334,-.3015,.04195,-.1354,.0527)*f1_15+\nvec4(-1.923,-.5317,-2.615,-3.363));vec4 f2_13=sin(mat4(-.1321,.02559,-.2848,.05448,-.1049,-.8609,.3278,-.05352,-.2575,-.006698,-.6339,.07582,.2113,-.06364,-.6531,.11)*f1_0+\nmat4(.05491,.03497,-.195,-.02424,-.7253,-.9122,.07417,-.1562,.1042,.2245,.314,-.05238,.001619,-.2769,.9252,.08584)*f1_1+\nmat4(-.2835,-.1115,-.4226,-.3282,-.3277,-.09835,-.3645,-.05352,.7919,-.5352,.766,.1093,-.4707,.4717,-1.136,-.03105)*f1_2+\nmat4(-.0607,.6167,-.4058,-.06991,-.2267,.1788,-.4944,.02352,.2392,-.3594,.6683,-.03303,-.2903,.1452,-.4781,.2999)*f1_3+\nmat4(-.002745,-.4781,.103,-.3545,.2758,.3848,-.8745,-.08635,-.001367,.373,-.5848,-.2541,.09438,.3961,-.6774,-.0696)*f1_4+\nmat4(-.9948,-.011,-.8055,.2173,-.453,-.3964,-.3714,.05709,.4712,-.7725,-.04044,.02296,-.3561,-.3153,.1138,.02429)*f1_5+\nmat4(-.2923,-.5941,.1376,.01052,.7501,.4917,-.01042,.02582,.09916,-.1945,.01506,.07195,-.1967,-.09533,.4016,.07399)*f1_6+\nmat4(.09602,-.3133,.45,-.03643,-.08001,-.5256,.03486,.07534,.04068,.7332,.165,.05409,.02112,.4695,-.4018,.05087)*f1_7+\nmat4(-.1069,.2462,-.5586,-.1279,.1892,-.5512,.3016,-.1317,.3689,.2404,-.2803,-.01998,.5787,-.1647,-.1754,.1331)*f1_8+\nmat4(-.6372,-.2492,.06117,-.008649,-.2496,.9816,-.1014,-.03121,.3629,-.0509,-.0246,-.04897,-.0347,-.02026,.5296,-.1235)*f1_9+\nmat4(.7095,-.3744,-.07323,-.03285,.5206,-.2659,-.1828,.03118,.231,-.5932,.4052,-.07886,-.1386,-.769,-.356,-.153)*f1_10+\nmat4(-.01103,-.02801,.2079,.4788,.2095,-.4407,-.1923,-.03174,.2793,.1427,.2688,-.08171,.2915,.09918,-.16,-.009508)*f1_11+\nmat4(.3156,-.2977,.3753,-.1338,.5624,-.5512,-.02721,.006423,.06744,.7994,-.6512,-.02842,-.3504,-.5835,-.9843,.1472)*f1_12+\nmat4(.009,.6305,-.142,.1322,-.05509,.1312,-.7265,.0203,-.1265,-.2228,-.02148,.07491,.2541,-.4043,.08179,.0006189)*f1_13+\nmat4(.1759,-.73,.08734,.08362,-.01982,.4709,.3962,-.01658,-.1187,-.136,.2175,.06776,.07241,.4255,.09055,-.3637)*f1_14+\nmat4(.365,.01041,.3038,.149,.3772,.06293,-.09569,.1113,-.5933,.1184,-.3741,.6205,.3071,-.5525,.9252,-.02692)*f1_15+\nvec4(1.635,.1006,-2.442,.3687));vec4 f2_14=sin(mat4(-.1791,-.1918,.06229,.6531,.5844,-.2493,-.4014,.6417,.2733,-.02378,-.2862,.01708,.09647,-.2135,.07045,-.1349)*f1_0+\nmat4(-.03458,.4337,.5298,.9372,-.1989,-.4734,-.2154,.03833,-.2093,.07936,.4764,-.1385,-.2822,-.4758,-.4609,-.02284)*f1_1+\nmat4(.1693,-.2289,-.6479,.02428,.06905,-.1189,.114,-.1663,-.9315,-.2664,-.1625,-.2037,.7558,-.08502,.6248,-.3038)*f1_2+\nmat4(.8607,.0009937,-.9037,.09133,.1345,.07244,.44,-.1641,-.6501,.2818,-.4367,-.06352,-.03115,-.2697,.1509,.2364)*f1_3+\nmat4(.4256,.03896,-.1654,.0174,-.4223,-.1391,-.3131,-.499,-.6325,-.3589,-.1098,.08261,.4451,.4546,.2193,-.6091)*f1_4+\nmat4(.7236,-.03894,.3052,-.09156,-.1742,.3492,-.5933,.1162,-.1012,-.1158,.08563,.1057,.3715,-.02514,.3242,.1188)*f1_5+\nmat4(-.3019,-.5405,-.7226,-.3874,.008411,-.0347,.03625,-.5213,.2305,-.3973,.4469,-.1992,-.5655,-.1726,-.2781,-.1039)*f1_6+\nmat4(-.196,-.1801,-.0878,.008726,.0004424,.04024,.01208,.5194,.7249,.2822,.05032,.3051,-.2363,-.5409,.5107,-.4513)*f1_7+\nmat4(-.07548,.1299,-.06537,.07819,.2651,-.03437,.3805,-.1706,.02613,-.2709,.3244,.4525,.07928,.04963,.273,-.7894)*f1_8+\nmat4(.05084,-.8393,-1.02,.4372,.1247,.6681,-.09677,.572,.172,-.1637,.163,.05142,.05274,.5349,.006024,-.048)*f1_9+\nmat4(.8849,.4694,.67,-.0006226,.1835,-.289,.7587,.1116,-.4451,.3465,-.2084,-.2212,.2937,-.1309,.2211,.1522)*f1_10+\nmat4(.4959,-.05646,.1409,-.0694,-.234,.2979,-.4635,.06372,.4562,.1727,.2036,-.2216,.1749,-.1125,.2228,.2364)*f1_11+\nmat4(.4783,-.158,.1955,-.08853,.7032,-6.61e-05,1.08,-.9319,-.05475,-.5483,.6188,.4575,.1852,-.2783,-.2959,.2042)*f1_12+\nmat4(.3074,-.2002,-.1414,.7351,-.319,.3007,-.6327,.7516,.1973,.5387,-.2176,.00523,-.3887,.4405,.1652,-.6508)*f1_13+\nmat4(-.04905,.3455,-.1958,.09931,-.428,.05624,-.297,-.3941,.1569,-.2225,.4137,-.1926,.6032,.3772,.5198,.02478)*f1_14+\nmat4(.09541,.6352,-.2184,.1295,.6288,-.003724,-.5367,.33,.1759,-.0394,-.1977,.1396,.2603,-.5689,1.349,.1413)*f1_15+\nvec4(-4.018,1.924,-2.44,-.4692));vec4 f2_15=sin(mat4(.0447,-.2801,-.3918,-.2778,-.3406,.1826,-.2882,-.173,-.01477,.4076,.08875,-.3606,.8548,-.5637,-.08832,-.1923)*f1_0+\nmat4(.875,.4566,.1486,-.3374,.4413,.5336,.1997,.002934,.2945,.4064,.2241,-.045,-.2445,-.2451,.008916,.1059)*f1_1+\nmat4(.2261,-.1985,.04404,-.8907,.06507,-1.09,.02315,.207,-.09895,.2049,-.2742,.3603,-.8405,.1111,-.2628,.033)*f1_2+\nmat4(-.2593,.1752,.2266,-.1231,.25,-.3849,.3903,.05903,.1632,-.7668,-.1091,.5236,.3248,-.3267,.2043,.0345)*f1_3+\nmat4(-.5739,-.2392,.1457,.1555,.09363,-.01735,-.532,-.03903,.3374,-.2657,-.00724,-.1176,-.07816,.07092,.03183,.01172)*f1_4+\nmat4(-.4243,.3064,-.02284,-.152,.4458,.2507,.07735,.3274,.07401,-.07626,.05353,.1954,-.2518,.3629,.4951,-.257)*f1_5+\nmat4(.3841,.7096,-.05424,-.09754,.01237,.3167,.08163,-.1474,-.04379,-.5005,.2898,.2688,.2387,-.3959,.1407,.05582)*f1_6+\nmat4(.4877,.36,-.283,.5331,-.31,.2935,.2091,-.1213,-.0387,.1613,.07713,-.0631,-.5429,-.4517,.3752,.09463)*f1_7+\nmat4(-.4114,-.2392,.1121,-.3501,-.09928,-.5846,.5705,-.03654,.3508,-.2298,-.3487,.13,-.2614,-.2687,-.2792,.1437)*f1_8+\nmat4(-.3079,-.4124,-.2561,-.09639,.06637,.02774,.2347,-.1383,.06528,-.05586,-.3998,.05776,.513,.01069,-.2878,-.3301)*f1_9+\nmat4(.7341,.1933,.5566,-.05975,.2478,.3211,-.01413,.004886,.2538,-.02244,.1456,.0301,.4274,.1394,.4151,.1097)*f1_10+\nmat4(.1779,-.004313,-.1868,.163,.2186,-.03806,-.02122,-.1566,.1222,-.4192,.3396,.1931,.05932,-.5276,.0008555,.09119)*f1_11+\nmat4(.2471,.1102,-.08923,.09439,-.1022,.4638,.0947,.156,.3832,-.09051,-.3798,-.2933,.1394,-.03885,-.01028,-.08633)*f1_12+\nmat4(-.3503,.3178,.1912,.1144,-.02879,-.1001,-.02696,-.2475,-.01088,-.5754,.2578,-.05071,-.1415,.08733,.09046,-.05707)*f1_13+\nmat4(.3682,.2068,.0287,-.1028,-.7271,.3801,-.07397,.09546,.08357,-.04258,.1017,-.06018,-.3692,.3772,.2824,-.6845)*f1_14+\nmat4(-.07267,.03345,.7486,-.01432,-.6172,.1724,-.2301,-.2616,-.1934,.458,-.2067,-.1006,.2666,-.1012,-.3424,.256)*f1_15+\nvec4(-.6204,-2.824,-4.387,-3.084));vec4 f3_0=sin(mat4(-.003473,-.03756,-.5573,-.3074,-.008324,-.3815,.6393,-.2922,.01969,-.1064,-.3207,-.2404,-.00169,-.6396,-.7082,-.005471)*f2_0+\nmat4(-.006038,.3904,-.6497,-.4389,.03038,.06223,-.272,.7567,-.008981,-.2463,-.3751,.603,-.02102,-.2317,.3961,-.0151)*f2_1+\nmat4(.01366,.09226,-.3126,.01576,-.001272,-.1075,.3756,.02128,-.01694,-.1489,-.0344,.4553,-.01429,.007241,.4571,.05489)*f2_2+\nmat4(.01627,-.104,-.5721,.184,-.02155,-.1733,.2849,.221,.01232,.1222,.5283,-.2854,.009651,-.0533,-.3066,-.1858)*f2_3+\nmat4(.01,-.06431,.2541,-.3978,-.001539,.02975,-.06699,-.05634,-.0008002,.07773,-.2626,.1185,-.002605,.2189,-.05608,-.5336)*f2_4+\nmat4(.002855,-.1352,.1577,.2475,-.01782,-.06728,.1628,.2895,-.004386,-.1898,.2856,.01288,-.01165,.2457,.4506,.3491)*f2_5+\nmat4(-.01787,-.1254,.4485,.1094,-.001866,.1216,.08892,-.2346,.01125,-.3595,-.1987,-.3483,-1.732,-.1151,1.436,.04049)*f2_6+\nmat4(-.02103,-.01575,.008189,-.02464,.01973,-.1307,-.04225,.3337,-.03394,.1856,-.3104,-.3141,.008723,.4497,.4705,-.004944)*f2_7+\nmat4(.06504,-.6203,-.09853,.09731,.01594,-.2636,.2618,-.1236,-.0085,.03133,-.6222,.3266,-.01002,-.0604,-.5133,.05622)*f2_8+\nmat4(-.0307,-.1946,-.1094,.2111,.006017,.1358,-.3541,-.1726,-.03009,.3711,-.4785,.03863,.0237,-.09832,-.1995,.0312)*f2_9+\nmat4(.01287,-.352,.1791,.1896,-.03221,-.1109,.2158,-.2623,.02723,-.09912,-.1949,.3685,.02369,.1324,.2995,-.427)*f2_10+\nmat4(.009226,-.09,-.2927,-.1282,-.0338,.1188,.1802,-.4895,-.03051,-.1804,-.5589,.5188,-.01251,-.3434,.3767,.3171)*f2_11+\nmat4(.005515,-.3582,.01247,-.5177,.02555,-.08106,.1211,-.2686,-.02344,-.2765,-.005816,-.09253,.002622,-.01305,.04075,-.06617)*f2_12+\nmat4(-.01462,.1579,-.1381,.04795,.001999,-.3867,.08232,.000977,-.02255,-.07267,-.1645,.1955,-.09902,.1128,.591,.2738)*f2_13+\nmat4(.01286,-.1893,-.02599,.05312,.007795,.2392,.1337,.4455,.001859,.1263,.1874,.2384,-.04365,-.1681,.1986,.2426)*f2_14+\nmat4(-.008616,.2588,-.3144,-.2345,-.009067,-.4358,-.08777,-.4452,-.0156,.1031,-.3029,-.03594,.005288,-.1452,.07198,-.1116)*f2_15+\nvec4(-2.823,-2.318,-3.041,4.644));vec4 f3_1=sin(mat4(1.492,.3716,-.1227,.1124,.4701,.48,-.1617,-.8139,-.06162,.2984,-.07187,.4942,-.07808,.2652,-.4157,.1905)*f2_0+\nmat4(-.4309,-.03965,.07455,-.008243,-.6699,-.2448,.4001,.2812,-.6798,-.03144,.05331,-.4699,.529,-.2851,-.3909,.5089)*f2_1+\nmat4(-.04971,.0516,-.4347,-.1636,-.613,-.05457,-.09264,-.2647,1.087,.2939,.479,.01568,.5991,-.05784,.02198,-.1287)*f2_2+\nmat4(-.02068,-.3133,.4026,-.06103,.1808,.04199,-.1413,.4265,-.2008,.1398,.3488,-.3488,.05511,.05357,.125,-.2706)*f2_3+\nmat4(.05737,-.296,-.02179,.1584,-.07956,.2797,.0937,.4937,-.2594,.3425,.4842,-.1548,.2531,.2178,.1377,.3439)*f2_4+\nmat4(.2395,-.08269,-.3053,-.5221,.1976,.4211,.4641,.1824,-.08812,-.1944,.3026,-.3198,-.2331,.1234,-.2891,.02142)*f2_5+\nmat4(.6348,.1121,.2564,-.3362,-.8877,.1952,-.2173,-.03554,-.07724,.3274,.3496,-.4833,-.6031,.3188,-.09421,.2038)*f2_6+\nmat4(-.2036,-.07937,.4024,-.5298,-.2778,.018,.1858,.2095,.3288,.5881,-.1063,-.5312,.06485,-.02826,.007819,.2249)*f2_7+\nmat4(-.5501,.03387,.4442,-.7724,-.1123,.09724,.3077,.1579,.1824,-.5659,-.2582,-.02922,.2279,-.1076,-.2866,.3635)*f2_8+\nmat4(.4059,.1056,-.3481,-.2308,-.1592,-.0705,-.2577,.3423,.2278,.1826,.7607,.3773,.2246,-.1582,.03299,-.02223)*f2_9+\nmat4(-.5923,-.3889,-.3388,.2806,.3852,.1436,-.2563,-.2542,.5603,.05583,.2163,-.0007421,.4525,-.4873,-.08165,.1292)*f2_10+\nmat4(-.4915,-.06578,-.006072,.02551,.6894,-.2641,.09457,-.2445,-.0137,.4108,-.2003,.001728,.1516,-.01606,-.1649,-.2382)*f2_11+\nmat4(.05144,.237,-.6005,-.2636,.05125,-.07575,-.3809,-.4175,.4201,-.1047,.02099,.4249,.001389,-.07789,.2336,.2748)*f2_12+\nmat4(.08474,-.1291,-.03792,-.6064,.2183,-.166,-.1897,.238,.2391,.2729,.3569,.02039,-.455,-.9266,.09524,.5521)*f2_13+\nmat4(.3353,.1217,-.2045,-5.187e-05,-.363,.05258,.2308,-.5042,-.03665,-.2522,-.2728,.009958,.348,.4945,-.009741,-.01057)*f2_14+\nmat4(-.1933,-.1974,.3822,-.03162,.1982,-.05095,-.4372,-.1713,-.6493,.09692,.1623,-.2192,.03862,-.07567,.1005,-.2409)*f2_15+\nvec4(-5.215,3.985,1.07,.6943));vec4 f3_2=sin(mat4(-.02615,.2145,.001264,-.247,.02455,.7684,.4505,.02124,-.004264,.02119,.227,.08109,-.01054,-.4322,.4148,.2838)*f2_0+\nmat4(-.09593,.3176,.079,.06451,-.04145,.6074,-.2109,-.576,-.002314,.1762,.4081,.07969,.002591,.3688,.5574,-.07141)*f2_1+\nmat4(-.0317,-.3368,-.3256,.01292,.04528,.2956,-.03642,.09306,-.005902,-.3294,-.3085,-.2024,-.02673,.3689,-.7658,-.1057)*f2_2+\nmat4(-.01612,-.04513,.5322,.05654,.02601,-.7438,-.6184,-.03581,-.0254,.333,-.1722,.1535,-.02046,-.3179,-.1029,.02763)*f2_3+\nmat4(.001525,-.5814,.2069,-.08395,-.007949,-.1564,-.2709,-.1187,.02859,.4703,-.4255,-.1472,-.002828,-.3395,.3775,-.03587)*f2_4+\nmat4(-.004602,.05549,-.1972,.07177,.006294,.05393,-.8182,-.01381,-.008718,.009222,.04636,.1082,-.00936,-.08508,-.1979,.2388)*f2_5+\nmat4(-.00653,-.1152,-.005208,.08145,-.01837,.1472,-.4313,.08397,.003856,-.1901,-.2834,.2214,.2952,-.7598,.6531,.5053)*f2_6+\nmat4(-.02508,.5921,-.6123,.1321,.03333,.1184,-.05084,-.233,-1.186,.7167,-.1938,.6531,-.02556,-.6026,.3563,.0009875)*f2_7+\nmat4(-.377,.5982,.1303,-.3937,.03593,-.7045,.5122,.1389,-.03385,-.1885,.4123,-.1328,-.0006776,.2511,-.07959,-.01282)*f2_8+\nmat4(.005383,.2929,-.406,.06277,-.04752,.1771,.4616,-.07646,-.05006,.2267,-.1959,-.09157,.01798,.2265,-.003598,.02373)*f2_9+\nmat4(.07761,.3732,-.1767,-.1608,.02294,-.2147,-.1828,-.09291,-.01074,-.1627,-.4178,-.001017,-.02381,-.01838,-.01817,-.04455)*f2_10+\nmat4(-.002497,-.01579,.3907,.1444,-.01536,-.3363,.2807,.000411,.0007557,.01038,-.2911,-.1074,.01431,-.154,-.203,.055)*f2_11+\nmat4(.006951,-.4947,-.3523,.1172,.06021,-.09583,.301,.5378,.01193,-.03152,.8742,.1294,-.008995,.05398,-.01534,.1539)*f2_12+\nmat4(-.05652,.4692,.05456,-.1336,-.01766,.06697,.1958,.09478,-.0001444,-.1648,.3755,-.02562,.4528,-.1775,-.2075,-.3833)*f2_13+\nmat4(-.0234,-.3531,-.3979,.04018,.005171,.2482,-.3129,.01839,-.01388,.2138,.04423,-.1669,.006993,-.2572,.3745,.2891)*f2_14+\nmat4(.01234,.2609,.2104,-.2121,.01971,.6461,.1963,-.2835,-.03101,.2676,-.09407,-.4329,-.09999,-.09696,-.6251,.3451)*f2_15+\nvec4(-2.828,-2.819,1.199,-4.343));vec4 f3_3=sin(mat4(-.4841,-.1077,.2518,.5218,-.06429,.6443,-.05828,-.3294,.1517,.684,-.1665,-.4577,.2321,-.09764,-.3422,-.499)*f2_0+\nmat4(.3305,-.3569,.07798,-.0755,.1433,-.153,.1355,.1698,.06525,.2357,.2846,.3724,.006052,-.5513,-.1907,.2399)*f2_1+\nmat4(-.3182,.0269,-.2525,-.05203,.2667,.08266,-.3124,.1551,.4247,-.7033,.2687,-.02493,.4722,.2276,.3679,-.1647)*f2_2+\nmat4(.658,-.08331,-.2145,-.1343,.1532,-.02301,-.1655,-.008155,-.3555,.1839,.1642,-.1568,.04293,-.06969,.1937,.06682)*f2_3+\nmat4(.3411,-.235,.4046,.1546,-.1392,-.5366,-.2241,.1076,-.4239,-.00248,.06346,.7153,.09008,-.5915,.738,.3513)*f2_4+\nmat4(.2198,.308,-.02442,.1232,-.3528,.2656,-.05928,-.08237,.04809,-.2813,.0196,.4252,.6501,.02402,.06299,.2797)*f2_5+\nmat4(-.3654,-.4631,.4156,.4145,-.8254,-.0813,.3294,.1903,-.6393,-.3778,.1547,.2936,.5383,-.0653,-.4601,-.7735)*f2_6+\nmat4(.09801,-.2342,-.2457,-.04881,.1048,.6325,.06925,.007634,-.1989,-.3256,.1999,-.4072,-.5171,1.386,.3294,-.0682)*f2_7+\nmat4(-.8033,.6655,.2073,.4383,-.3358,-.07482,-.275,-.4098,-.1222,-.5909,.2973,.4894,-.03514,.9772,-.04239,-.0623)*f2_8+\nmat4(-.1272,.5407,.2395,-.1035,-.00702,-.1617,.01197,-.03034,6.398e-05,.07783,.4362,.3538,-.2581,.2874,.2898,-.1969)*f2_9+\nmat4(.0998,.0358,-.6759,.3668,.315,.2068,-.02004,-.5932,.4722,.3294,.002225,-.1178,.5478,.2413,.1384,-.07498)*f2_10+\nmat4(-.2801,1.093,-.2647,.01426,.6668,.005027,.3029,-.2603,.1535,.2913,.09108,-.1429,.3085,.1119,-.03623,.1703)*f2_11+\nmat4(-.546,.008794,.223,.1045,-.03934,-.2306,-.4668,-.3271,-.518,-.04695,.5744,.1176,-.01088,.6799,-.1234,-.03403)*f2_12+\nmat4(.04813,.1709,.06875,-.04031,-.06924,.4835,-.06204,-.1186,.3487,.1675,.722,.19,.0005223,.005236,-.1317,.1802)*f2_13+\nmat4(-.08991,-.5453,.4257,-.3943,.06001,.2578,-.03176,.1594,-.3027,-.9682,.5545,-.08751,.6113,.1463,.4836,-.1695)*f2_14+\nmat4(-.4205,.05608,-.005573,-.1117,-.1417,.2715,.001382,.1871,.3645,-.7405,.08294,.3797,.3373,.573,-.01931,-.8804)*f2_15+\nvec4(-1.349,2.187,-1.172,-2.985));vec4 f3_4=sin(mat4(-.1536,.5652,.2985,.06033,-.03041,-.1255,-.4051,.04501,.04102,-.129,.03879,.01092,-.2296,-.7957,-.4771,.1237)*f2_0+\nmat4(-.08139,-.4031,-.681,.1154,.1481,.275,-.3443,-.1881,.1335,-.06587,-.06119,-.05175,-.1726,-.7156,-.1515,.1299)*f2_1+\nmat4(.02793,.01652,.2735,-.0172,.04081,-.2738,-.4031,.02382,.0248,.4612,-.8454,-.02028,-.05714,-.04013,.1596,-.00603)*f2_2+\nmat4(-.05259,-.1888,.06836,.08519,.1011,-.4131,.08289,-.0256,-.1052,-.05399,-.1597,.07766,-.07814,-.1231,.4381,-.002515)*f2_3+\nmat4(-.1002,.06664,.01445,.05582,.02742,.6585,.2802,-.05479,.09127,.06445,-.09036,-.04604,-.025,-.008876,.9816,-.01247)*f2_4+\nmat4(.0777,.2061,-.2461,-.0009524,.08076,-.1298,.3255,-.05572,.03772,.1716,.2731,.02361,.2145,-.06034,-.1291,-.1655)*f2_5+\nmat4(.05061,.3601,.1802,-.06159,.1502,-.01584,.2087,-.02457,.1093,-.4021,.22,-.083,-1.1,.1997,.6797,-.8595)*f2_6+\nmat4(-.02113,-.4586,.1065,.002392,.081,-.4715,-.7263,-.06147,.2545,.5662,.8783,1.043,-.07216,.4614,-.284,.03591)*f2_7+\nmat4(-.02202,-.1542,-.0216,.3837,-.06668,-.5809,-.09008,.08843,-.07904,.3655,-.07943,.05355,-.1216,-.477,.3397,.006475)*f2_8+\nmat4(.1005,.2592,-.0009251,-.05859,-.07827,.2946,-.07773,.0106,.1638,.5878,.3414,-.05437,-.1326,-.212,.1296,.01023)*f2_9+\nmat4(.06184,.1404,-.03293,-.04116,.03475,.06069,.00892,-.03219,.2355,-.04877,.5581,-.07614,-.06506,.3446,.1783,.05936)*f2_10+\nmat4(-.09343,-.1202,.1997,.05432,.007103,-.2464,-.3904,.06632,.1623,-.01174,-.6206,-.06485,.1589,.1646,.08696,-.02574)*f2_11+\nmat4(.09541,-.4763,.2316,.02454,-.3154,-.3032,.478,.0387,.2009,.365,.8994,-.1323,-.03008,-.8381,.3859,-.0152)*f2_12+\nmat4(-.1191,.07865,-.1511,.05859,.0464,-.3438,.3436,-.0145,.01955,.1623,-.139,.002033,.0461,-.3797,.1769,.3788)*f2_13+\nmat4(.01124,.1835,.09636,-.002009,.15,-.405,.1499,-.1155,.04364,.1518,.4006,-.01534,.1531,-.2139,-.5498,-.01151)*f2_14+\nmat4(-.01765,-.2309,-.6039,.02894,-.05146,.2573,-.4264,.01142,.2732,.2357,-.008684,-.06184,.08362,.3529,.3948,-.1244)*f2_15+\nvec4(-.8719,4.442,-1.333,.5109));vec4 f3_5=sin(mat4(-.4597,1.028,.4938,.3487,-.111,-.7403,-.2658,-.2387,.1607,-.09499,.03798,-.5304,-.09465,-.04066,-.4666,-.5364)*f2_0+\nmat4(.1484,-.1421,.131,-.03028,.07933,-.6629,-.1947,.1381,.1782,-.1551,-.06003,.6577,.1852,.3789,-.5485,.3381)*f2_1+\nmat4(-.1243,.1419,.4095,.2801,-.07727,-.414,-.2984,.1487,.1828,.07723,.2215,.2655,-.006426,.3507,-.2649,-.09668)*f2_2+\nmat4(-.2375,-.06748,.2914,-.08403,.05521,-.156,.2235,-.2115,-.3813,.2831,-.2152,.3906,-.06279,.2444,.2327,-.1546)*f2_3+\nmat4(.125,.3998,-.05513,-.3703,.05811,.01042,.3134,-.2651,.1844,.004471,-.115,.4056,.04821,-.2459,.2377,-.5232)*f2_4+\nmat4(.06262,-.2433,-.8301,-.2247,.2218,-.08465,-.04053,.1828,.06339,.7923,-.2058,.3249,.06488,.1414,.4367,-.2772)*f2_5+\nmat4(.01181,-.3686,.4211,-.8581,-.0621,.1041,.07355,.1699,.1176,.3632,.2538,-.1128,-.08157,-.1122,.4039,.5151)*f2_6+\nmat4(.09402,.5792,-.3374,-.1092,.006739,-.3204,.2949,1.049,-.001736,-.3335,-.3046,.1394,-.017,-.447,-.1095,-.2384)*f2_7+\nmat4(.237,.7897,-.0837,.4085,-.1188,.1761,-.03904,.005973,-.1574,-.03274,.5493,-.6319,-.1982,.3301,.003105,-.1982)*f2_8+\nmat4(.2417,-.2006,-.3416,-.1722,-.01455,-.2001,.1143,.0887,.253,-.5888,.2627,.2499,-.282,.5301,-.1559,-.1559)*f2_9+\nmat4(-.1794,-.8708,-.1159,-.05169,.08932,.05201,.3377,-.5043,.1995,.2185,.2563,.2555,-.1083,.4332,-.3806,.3896)*f2_10+\nmat4(-.167,.3847,-.6244,.2518,.1309,.1249,-.09276,-.08567,.2072,-.01668,.1811,-.08081,.4787,-.2862,-.201,.1713)*f2_11+\nmat4(.173,-.09117,.2517,-.1026,-.5873,.1327,.4653,-.2224,.1604,-.1123,.2357,.1112,-.04527,.3038,-.3145,.4084)*f2_12+\nmat4(-.04822,-.1426,-.1962,.2726,.0941,-.1305,.1568,-.5327,-.1798,-.2349,-.02761,-.02219,-.09766,.06604,-.02621,-.478)*f2_13+\nmat4(-.2253,-.02927,-.3124,-.2059,.2496,-.0175,.6088,.03003,.02506,.3096,.7193,-.0009022,.0545,-.7971,-.07761,-.741)*f2_14+\nmat4(.06705,.07288,-.4286,-.03806,-.1854,-.3398,.003259,-.4649,-.06008,-.4173,-.2395,-.279,.1993,.05714,-.1378,.07289)*f2_15+\nvec4(4.212,-4.703,-.5786,1.295));vec4 f3_6=sin(mat4(.198,.2173,-.1563,.05211,-.02777,-.8501,.1209,.6027,-.4002,.1784,-.608,-.2831,-1.278,-.07886,.4361,.4317)*f2_0+\nmat4(-.0481,-.3317,-.2953,.09485,.1068,-.5147,-.4327,-.2599,-.01775,-.3225,.06751,-.01192,-.7034,.6791,-.06864,.1925)*f2_1+\nmat4(.04512,-.1683,-.3139,.3461,.2272,-.3718,-.003875,-.5916,.0141,-.1263,.9972,-.1656,-.03773,.05257,.1869,.2351)*f2_2+\nmat4(-.0955,-.04044,-.06662,-.1074,.3414,-.4847,.1102,-.2909,.3378,-1.31,.3863,-.7224,-.2272,-.07361,-.1728,.2753)*f2_3+\nmat4(-.2156,.08925,.3841,.09285,.6703,-.0197,.3745,.09324,-.5261,.3561,.2516,-.6905,.4705,-.3154,-.2952,.05261)*f2_4+\nmat4(-.009371,-.3494,-.4148,-.2409,.2003,.04344,-.1964,-.4303,-1.046,-.2127,-.3028,.05166,.3766,.06319,-.123,.4699)*f2_5+\nmat4(-.06542,.4056,.1585,.1034,-.3476,-.08895,-.09608,.1144,.05638,-.02712,.2992,-.2664,-.007587,-.3939,.02448,-.2598)*f2_6+\nmat4(.6735,-.011,.292,.1506,-.4505,.2958,.09781,.2349,.1468,.465,-.1642,-.1433,-.3493,-.4149,-.227,.2914)*f2_7+\nmat4(-.6817,-.1691,.3286,-.4124,.5149,.1333,.4375,.4487,.5169,.151,.06336,-.02273,.1438,.1677,.1795,-.1872)*f2_8+\nmat4(.1052,-.2914,-.07389,-.2759,-.3425,-.3154,.4684,.8638,.5908,-.6976,.05609,-.5448,.703,-.2662,.5233,.08109)*f2_9+\nmat4(.9674,.4043,.7194,-.2633,-.02484,-.403,.1634,.209,-.3635,-.02631,.00309,-.9772,-.08356,-.0145,-.005349,.02867)*f2_10+\nmat4(-.4168,-.09567,.1256,.1537,.2167,-.02456,-.003613,.03387,-.1281,.1748,-.3975,.004258,.07609,.1908,-.2747,.402)*f2_11+\nmat4(.09399,.07508,-.4011,.1816,-.5048,-.4932,-.5053,-.4808,-.7023,-.09524,-1.323,-.06674,-.4872,-.3621,.0383,-.394)*f2_12+\nmat4(.3476,-.9795,-.0691,-.4216,-.191,-.05785,-.5328,.2327,-.3489,-.04024,-.7261,.2249,.1703,-.464,.05711,.115)*f2_13+\nmat4(.1873,-.6408,.0936,.04893,.7866,-.01861,.4489,.02176,.6841,-.5099,-.3415,-.1778,-.1618,-.1636,-.3147,.6879)*f2_14+\nmat4(-.0255,-.3076,-.3635,-.2474,.2573,-.439,.2136,-.2323,-.1007,-1.002,.7898,-.434,.5012,-.08377,.007536,.1907)*f2_15+\nvec4(.1933,1.492,-.8265,2.712));vec4 f3_7=sin(mat4(-.04187,-.05999,-.2954,-.721,-.006779,.1356,-.3076,.2357,-.04199,-.076,-.05959,.06321,.02692,.1317,.09182,-.3601)*f2_0+\nmat4(-.1249,-.4369,-.5861,.04942,-.2262,-.1697,-.6416,.1129,.07213,.05099,.1372,.1613,-.1961,-.3112,.1897,-.2797)*f2_1+\nmat4(-.098,.1495,.3158,.1153,-.06981,.4349,.2683,-.05255,.1369,.02287,-.716,-.01171,-.0104,.07321,.6953,-.0902)*f2_2+\nmat4(-.0514,-.09989,.4352,-.06793,-.1388,-.09056,.01557,.01359,-.0269,-.2823,-.08514,-.08265,-.05743,-.218,.9271,-.04596)*f2_3+\nmat4(-.02429,-.04777,-.2245,-.423,-.02179,.1228,-.277,-.06558,.00827,-.1588,-.1761,.1447,.09152,-.1906,.1323,-.04959)*f2_4+\nmat4(-.09966,.245,-.04694,.1124,.04393,.1748,-.4336,.09163,-.0119,.204,.6151,.02001,.1514,-.2621,-.06734,.229)*f2_5+\nmat4(.02419,-.4286,-.0953,.1214,-.1188,-.476,-.3587,.007759,.01493,-.04134,.3787,.1328,-.9102,.3969,-.3056,-.02208)*f2_6+\nmat4(.03602,-.2496,.6809,-.02237,.1037,-.283,.006899,-.2078,-.5755,-.2039,.2072,.1404,-.08148,-.9147,.7902,-.08475)*f2_7+\nmat4(-.7135,.4055,.1076,-.3999,-.001052,-.1293,.0976,.02493,-.0004691,-.5168,-.06396,-.2806,.1435,.1316,.7533,-.2417)*f2_8+\nmat4(.02773,.03851,.6485,.1479,-.01611,-.4205,-.16,-.05025,.04574,-.1369,-.2612,-.145,.01742,.2215,.005205,-.1444)*f2_9+\nmat4(.1815,.6448,-.2655,.3508,-.02382,-.2606,.5971,.05407,.05324,-.2426,.1482,.131,-.1133,.03861,.1279,-.1364)*f2_10+\nmat4(.01139,.5723,.1981,-.04435,-.06152,.06908,-.04459,-.06353,-.008647,-.01873,.1539,.09604,.03893,-.02123,.0876,.3495)*f2_11+\nmat4(-.004766,.02478,.2102,-.05473,.1833,-.06591,.07296,.144,.0623,-.2132,.343,.181,.05926,.4886,.6802,-.2487)*f2_12+\nmat4(-.1023,.4141,.4154,-.2068,.04559,.3942,.2465,.0147,-.001455,-.007543,.04983,-.1346,-.0006544,.1426,-.5133,.187)*f2_13+\nmat4(.02603,-.3347,-.228,-.08392,-.01661,-.2219,.6956,.1463,-.04537,-.2348,.2834,-.08225,.1107,.5349,.381,.3729)*f2_14+\nmat4(.01803,.04201,-.06921,.03062,-.01294,.2026,-.2685,-.02797,-.1972,.1456,-.2763,.01106,-.2046,.08176,.7053,-.01044)*f2_15+\nvec4(-2.282,1.751,-1.323,.03683));vec4 f3_8=sin(mat4(.1226,-.2659,-.3295,.3317,.5265,-.3374,-.5892,.3567,-.1138,-.06141,-.1336,-.2262,.4427,-.2646,-.6095,-.7956)*f2_0+\nmat4(.6805,.3937,-.3084,-.08926,-.2788,.4048,.7265,.07887,.01502,-.05932,-.6354,.3202,-.5162,-.6608,-.2744,.6186)*f2_1+\nmat4(.3863,-.4324,-.3869,-.1075,.5279,.3959,.2778,-.4144,.09335,.09654,-.284,-1.372,.2958,-.1694,.002329,.4028)*f2_2+\nmat4(-.3581,-.1289,-.2256,-.4474,.06834,.2074,.1532,-.01178,.2301,.08135,.05107,-.2016,-.1512,.09504,.7858,.7257)*f2_3+\nmat4(-.3583,-.1301,-.0933,.9042,-.3793,.03633,.2433,.003714,.2649,-.1648,.1834,-.3427,.08151,.2302,.06954,.03548)*f2_4+\nmat4(.03685,.3541,-.5062,.6538,-.6382,-.00851,.2779,-.4553,-.188,-.6433,.3391,.151,-.03032,.1948,.1301,.2666)*f2_5+\nmat4(.3513,.2129,.3704,.101,-.3518,-.3155,-.05138,.8138,-.02754,-.1747,.4255,.6643,-.2233,-.4305,-.3905,-.2108)*f2_6+\nmat4(-.2059,-.3995,.5329,-.215,-.3761,.5994,-.00726,-.5352,-.1051,-.1342,.1429,-.006634,-.1347,.0715,.3724,.4282)*f2_7+\nmat4(.1518,-.03188,-.0001341,.1287,-.1787,.02563,-.3324,-.4628,-.3471,.08097,.0895,.02716,-.4331,-.1372,.05714,-.2757)*f2_8+\nmat4(-.7466,-.5744,.1918,.00642,.02637,-.2716,.2633,.1317,-.06309,-.06539,.1408,-.5396,-.454,-1.129,-.2343,.0969)*f2_9+\nmat4(-.2466,-.1118,.1271,-.1903,-.3454,.1974,-.2102,.01273,.8399,-.01997,-.3271,-.2615,-.3859,.3801,-.3999,.5263)*f2_10+\nmat4(-.08648,-.6397,-.5857,.23,-.7213,.06299,-.05276,-.4329,-.0824,.3692,.04703,.5012,-.2429,-.1578,-.03503,-.01101)*f2_11+\nmat4(-.06864,-.1909,-.3753,-.3218,.3095,.1554,-.0199,-1.365,.9443,-.4062,.4874,-.06128,-.1057,.05963,.2573,-.3211)*f2_12+\nmat4(-.1913,.004564,.4116,.2216,-.2792,-.2726,-.00479,-.133,-.1098,-.2435,.1905,-.1946,-.2606,-.3285,.2155,.8217)*f2_13+\nmat4(-.7189,.1053,-.1306,-.1516,-.09748,.0005305,.2629,-.4386,-.1134,.2574,-.09636,.2489,.2955,-.258,-.3833,-.3254)*f2_14+\nmat4(-.7514,-.01144,.03127,-.1259,-.00722,-.093,.1444,.2121,.2882,-.5535,.0683,.359,-.04177,-.08011,-.4152,-.4231)*f2_15+\nvec4(-3.397,.9733,3.02,3.569));vec4 f3_9=sin(mat4(.2645,.08719,-.4067,-.04371,.1336,.02739,.1405,.08315,-.01287,-.0001704,.2771,-.1582,.2986,.1015,.2658,.1251)*f2_0+\nmat4(-.3751,.1716,-.5553,-.5537,.5505,-.09353,.2396,.3845,-.04978,-.04221,.4075,-.4389,-.2829,.1999,-.8624,.3284)*f2_1+\nmat4(-.1521,.01826,-.2965,-.06477,-.0968,-.04379,.1967,.07883,.5812,-.09846,-.4081,-.3603,.1529,.03349,-.4272,-.1412)*f2_2+\nmat4(-.3394,.06126,-.5181,-.1432,.7695,-.08019,.09703,-.06892,.2941,-.004841,.001103,.2818,.1634,-.02435,-.3397,-.3468)*f2_3+\nmat4(.3454,.03605,-.3328,.07127,.6294,-.04358,-.07234,-.2065,.3086,-.058,-.2669,.4691,-.3473,-.03508,-.1318,.04682)*f2_4+\nmat4(-.138,-.01988,.4814,.09555,.06384,-.129,.2932,-.4152,-.1461,-.04917,-.6575,.335,.6253,-.08655,.2255,-.5945)*f2_5+\nmat4(-.1185,-.07404,-.3469,-.1433,-.1297,.05311,-.2914,-.431,-.1213,.001732,-.1519,-.05712,-.8895,-.3229,.2374,-.2876)*f2_6+\nmat4(-.2579,-.01092,.3969,.5184,-.1321,.05424,-.6955,-.2831,-.1955,-.9912,-.04714,-.8182,-.4203,-.05069,.1626,.5346)*f2_7+\nmat4(-.6009,-.2435,.1493,.7966,-.03147,.03048,.04666,-.06459,-.5874,-.005241,-.3573,-.2157,.9075,.07218,.02853,.4184)*f2_8+\nmat4(.4639,-.05407,-.07052,-.08873,-.3872,.06419,-.01424,-.2472,.152,.02994,-.4522,.2636,.4767,.03889,-.7506,-.2067)*f2_9+\nmat4(.04579,.09246,.4253,-.06765,-.4433,-.02201,-.09238,.3671,.3398,-.09646,.0006716,-.1113,-.1716,.03104,.3008,.24)*f2_10+\nmat4(.04966,.09601,-.5189,-.003438,-.4402,.2657,.4625,-.4247,-.5432,-.06705,.1949,-.7354,.1911,-.03131,.4022,.2061)*f2_11+\nmat4(-.3806,-.02944,.2117,-.4369,-.6383,-.09274,.1728,-.004478,.4891,-.1117,.4703,.06171,-.1012,-.0141,.02495,-.007257)*f2_12+\nmat4(-.04668,.06257,-.4741,-.07159,-.6011,-.02819,-.05003,-.6408,-.1452,.0008736,-.5435,-.1437,-.7574,-.775,-.6631,.328)*f2_13+\nmat4(-.3903,.01366,.1442,.7058,.03053,-.1025,-.04512,.05753,.3483,-.0005917,-.06957,-.1448,.3813,-.08636,.003416,.04521)*f2_14+\nmat4(-.459,.1287,-.1159,.1803,.1581,.03622,-.276,.3638,-.5864,.003498,.1371,-.513,.01472,.08863,-.5888,.1779)*f2_15+\nvec4(4.355,2.615,2.698,.2427));vec4 f3_10=sin(mat4(-.1729,-.09268,.02242,1.16,.03269,-.247,-.0102,-.008632,-.3171,-.04665,-.2932,-.4874,.6054,.01517,.048,-.5938)*f2_0+\nmat4(-.04646,-.004051,.7884,-.2828,.7238,-.08351,.04913,-.008856,-.06155,.2776,-.2995,-.1932,.09413,.8338,-.4434,.141)*f2_1+\nmat4(-.2623,-.5456,.09813,.1802,-.2226,.6086,-.01911,.6909,-.04348,.8489,.3597,.02539,-.836,-.05179,-.09029,-.15)*f2_2+\nmat4(-.1274,.05015,-.012,.02476,.05982,.2526,-.2211,.1106,.1616,.3778,.006792,.5167,-.6882,-.3311,-.1281,.2932)*f2_3+\nmat4(.2666,.2703,-.1136,-.2729,-.1471,.01207,.5812,-.03777,-.2708,.3547,.07992,.2014,-.4262,.1985,-.1161,-.0002922)*f2_4+\nmat4(-.2913,.1531,-.5534,-.3471,.5945,-.3812,.4115,-.4531,.5743,-.3317,-.4172,.02735,-.07909,.4933,-.7556,-.3899)*f2_5+\nmat4(.1373,.1139,.07671,.3108,.3884,-.4766,-.2749,.472,-.5267,.2652,.05187,.2058,-1.115,.02896,-.02414,.2337)*f2_6+\nmat4(.5059,-.3421,.1098,.02525,.1414,-.3649,.9664,.3304,-.02347,-.6425,-.08572,-.2486,.3451,.4469,-.5717,.4492)*f2_7+\nmat4(.9994,.4922,-.3773,-.2069,-.2907,.3741,-.124,-.02665,.03371,-.2051,-.1668,.4769,.397,.3056,-.2272,.2013)*f2_8+\nmat4(-.09901,.3151,-.6375,-.3978,.4885,.8044,.2863,.1303,-.1099,.4941,-.02166,-.06693,.2469,.5443,-.1374,.15)*f2_9+\nmat4(-.03227,-.2059,.04707,.2411,.2971,-.01681,.6575,-.3628,-.6325,.2431,-.1505,-.4689,-.03357,.2099,.2234,-.394)*f2_10+\nmat4(.2799,-.1822,-.4937,.2068,.5249,.2944,.5625,.2566,.07487,.1443,.01152,-.2326,.3757,.4134,-.1212,.4185)*f2_11+\nmat4(-.6157,.0207,.3643,.03638,-.7074,-.1692,.3601,-.765,-.41,-.8121,.05814,-.3697,-.1423,.7694,-.1147,.1788)*f2_12+\nmat4(.182,.0003302,.5822,.02418,.0133,.2117,-.1147,-.3934,.0468,-.2537,-.08802,.1324,.5922,-.4259,.1644,.02189)*f2_13+\nmat4(-.08081,-.4442,-.5229,.2245,.2034,.2186,.08027,.1211,.02664,-.1686,.8534,-.0559,.001841,.2055,-.4428,.6049)*f2_14+\nmat4(-.112,.0304,-.3407,.3697,.03035,-.3333,.5027,-.0003742,.2903,.2511,.1814,.3948,-.3546,.3539,.1614,.6427)*f2_15+\nvec4(-2.945,-.7592,2.767,1.517));vec4 f3_11=sin(mat4(.1343,.4602,-.2434,.1411,-.04762,-.06232,-.3621,.1293,.03619,.1766,.2955,-.07928,.281,-.6932,-.1072,.0785)*f2_0+\nmat4(-.03664,.3119,.08992,.1421,-.198,.8149,.9543,-.01443,-.1047,.06113,-.1131,-.1808,.4358,-.2792,-.001455,.1872)*f2_1+\nmat4(.02515,.2616,-.1401,-.03141,-.08281,-.3699,-.5155,-.09955,-.02857,.4074,-.01967,-.17,-.05775,-.2063,-.3149,.1258)*f2_2+\nmat4(.07429,.03313,-.09073,.1347,-.00811,.2973,-.1992,-.1089,.0312,-.1479,.6772,.1301,-.001214,.4288,.2101,.0914)*f2_3+\nmat4(.1118,.174,.1626,.01124,.03837,.2129,.07803,-.1156,-.04595,.5223,.2231,.000469,.03147,.07872,-.2067,.1172)*f2_4+\nmat4(-.02655,-.3295,.4424,-.03618,-.05974,.04414,-.6935,-.1547,.07288,.4031,-.3112,-.01633,-.107,.1938,.5316,-.1652)*f2_5+\nmat4(-.03363,-.4242,-.3194,-.2356,-.1119,.5244,.4621,-.1388,-.002785,-.09021,-.2982,-.1259,.06709,-.07201,-.2375,-.2138)*f2_6+\nmat4(-.1235,.2022,.4407,-.06955,.01586,-.7626,.188,.04549,.08723,-.0937,-.2001,.1633,.05947,-.2254,.3046,-.0945)*f2_7+\nmat4(.3596,-.4468,.06129,.2415,-.01748,-.4206,-.7907,.1,.02454,.4883,.2322,-.005352,.03267,-.003698,.1687,.1807)*f2_8+\nmat4(-.04079,.2733,-.3213,-.169,-.01359,-.1463,.04258,.02422,-.00716,-.07383,.847,-.08404,.07624,-.1913,.2833,.0747)*f2_9+\nmat4(-.3105,.3241,.3211,.03854,-.1409,-.1772,-.7506,-.05015,-.05913,-.005294,-.1743,-.1463,.1221,-.1997,.31,.1967)*f2_10+\nmat4(-.01573,.3412,-.2516,.1577,-.1343,-.07396,.7131,.1122,-.1375,-.05576,.3311,-.226,.01769,-.1101,-.8705,-.1407)*f2_11+\nmat4(-.06652,.4302,-.2663,-.2726,.02068,.01628,.5094,.3007,-.002596,.3164,.03368,-.1715,.04553,.03208,.3356,.1213)*f2_12+\nmat4(-.02102,-.3372,-.5891,.1179,-.003741,.4545,-.1524,-.1257,-.03348,-.852,-.5774,.05931,-.1811,.04467,-.2746,-.08985)*f2_13+\nmat4(-.08348,.361,.2431,.02191,-.07812,.3022,-.1075,-.172,-.008828,-.04265,.1489,-.1162,-.1923,.1279,-.02505,-.2233)*f2_14+\nmat4(-.02814,-.373,-.05232,.1336,-.01064,-.375,-.1995,.05429,-.2337,-.2288,.325,-.2039,.05058,.2221,-.09684,-.05695)*f2_15+\nvec4(2.705,2.266,2.033,-.1019));vec4 f3_12=sin(mat4(.2295,-.4916,.1109,.428,.3161,-.2901,-.1954,-.06669,.103,-.1902,-.1036,.04318,.005103,-.04101,-.3592,.5458)*f2_0+\nmat4(.5175,-.06956,.2626,-.04434,.01035,.1851,.8159,-.6017,-.2251,.1512,-.06503,-.1082,-.5244,-.1171,.1001,.08041)*f2_1+\nmat4(.01848,.0718,.1296,.1529,.02749,.2421,.1407,-.4379,-.2187,.9338,-.1275,.02465,.1253,.07918,-.2434,-.2689)*f2_2+\nmat4(.9369,.3972,.08385,.2647,-.535,.08028,.2275,-.237,-.1937,-.01259,.3065,.3174,.04762,.4982,-.1787,.2566)*f2_3+\nmat4(-.03704,.02026,-.2883,-.2051,.1905,.2115,.1588,.01098,-.006849,.04821,.5109,.146,.03954,.05448,.2342,.02169)*f2_4+\nmat4(-.1837,-.5129,-.5102,-.2392,-.5535,.2906,.7668,.3289,-.1237,-.1087,.2607,-.1021,-.009019,.1209,.2433,.1416)*f2_5+\nmat4(-.2796,-.1567,.05341,-.08862,-.08338,-.3411,-.5371,.1591,.1536,-.2066,-.1924,.1544,-.147,-.06265,.7651,.02871)*f2_6+\nmat4(.2339,.02179,.397,-.529,-.101,.6016,.523,-.0008939,.4421,-.4712,.159,-.03596,-.06722,-1.24,.4085,-.07645)*f2_7+\nmat4(.1902,-.2231,-.6491,.03826,-.04643,-.1132,-.4424,-.1769,.3002,.3496,-.4069,.2059,-.1714,-.4006,.2308,.533)*f2_8+\nmat4(-.06532,-.3987,-.08157,-.5159,-.2015,.4302,-.2897,-.2688,.04979,.08783,.3236,-.07502,-.07944,.1919,-.5299,-.2352)*f2_9+\nmat4(.318,.07148,-.02016,-.2764,-.2375,.5509,.1145,-.1251,-.15,.07226,.04482,.08353,-.4686,-.3212,-.06528,.3088)*f2_10+\nmat4(.277,-.3061,-.475,-.004807,-.0596,.1278,-.2038,-.2967,.2491,-.09794,.05745,-.09491,.09498,-.1488,-.2272,.0166)*f2_11+\nmat4(.6869,.5649,.5946,.4787,.52,-.07269,.579,.3041,.2092,.2781,.4489,-.02833,-.3003,-.5419,.3845,.164)*f2_12+\nmat4(.2262,.6192,.7104,.1539,-.09935,.219,.1005,.1733,.1178,-.0389,.2395,.09295,.2574,.3257,.2645,.1343)*f2_13+\nmat4(-.725,-.2077,.1989,.2837,.0497,.5293,-.08014,.02261,.461,.592,-.2083,.1448,-.1382,-.1025,-.7098,-.1732)*f2_14+\nmat4(.08732,.2214,-.03699,-.09679,.2209,-.03556,.5797,-.1348,-.3334,.5288,.4311,-.01905,-.04604,-.3182,.1117,.4394)*f2_15+\nvec4(-3.131,2.007,-.04556,-2.4));vec4 f3_13=sin(mat4(.4567,.1195,.05421,-.4614,-.01528,-.2024,.04324,.1055,.02867,-.1291,-.02965,.3747,-.5159,.1573,-.2207,.1509)*f2_0+\nmat4(-.4176,-.455,-.3373,.7369,.03354,-.547,-.148,-.4195,-.1652,.1727,.1445,.1689,-.1324,.09366,-.2356,.5377)*f2_1+\nmat4(.1246,.02105,.3369,.4547,.1068,-.3084,.2901,-.1213,-.1289,.3184,.1813,-.411,.06908,.2506,-.0307,-.4907)*f2_2+\nmat4(-.2072,.608,-.2817,-.001862,.05361,.2712,.371,-.3152,.2522,.1308,.04737,-.2661,.4866,-.1321,-.04477,-.04062)*f2_3+\nmat4(.3087,.223,-.2427,-.1355,.1418,-.04238,.1394,.05186,.05179,.03904,.1254,-.2307,.1,.07022,-.3065,.1313)*f2_4+\nmat4(-.03099,.1338,-.04163,.05691,.1938,-.1227,.2982,.3127,.06132,.008264,.5957,-.2448,.2576,-.3348,.4591,.2602)*f2_5+\nmat4(.01577,-.007709,.007759,.1409,.3501,-.07602,.1493,-.2918,.08934,-.004904,.2625,-.7294,.1708,.3918,.1445,.866)*f2_6+\nmat4(-.1069,.2904,.3831,.4762,.05731,-.3366,.3526,-.3464,.04192,.3385,-.06248,-.1028,.2251,.3377,-.4083,.5414)*f2_7+\nmat4(-1.494,-.1964,-.1474,.7068,.1889,.08643,-.3757,-.3564,-.2546,-.2129,-.1484,.3585,-.006706,.3682,-.1466,-.5256)*f2_8+\nmat4(-.28,.02592,.5245,.07511,-.2533,-.03399,-.189,-.6424,.3869,-.1784,.1836,.006432,-.4164,.2492,-.02993,-.1221)*f2_9+\nmat4(-.2317,-.07025,.02555,-.1249,-.3937,.2612,.03904,-.2594,.0655,-.171,.5557,-.1609,-.316,.02312,-.5833,.2039)*f2_10+\nmat4(.3016,.08494,-.1897,-.1346,.2144,-.176,-.09517,-.1886,-.08405,.1717,.287,.207,.007236,.4359,-.06957,.116)*f2_11+\nmat4(.1831,.3047,.3657,.06674,.5536,.176,-.2046,.2753,.1009,-.6926,.1707,.1255,.232,-.06216,-.1242,.1108)*f2_12+\nmat4(.258,.09737,-.1871,-.0355,.133,-.0447,.09443,.108,-.1283,.3137,.01256,-.4126,.4185,-.1561,-.1153,.3329)*f2_13+\nmat4(.01445,.03106,.008225,-.3454,-.1114,-.3597,.4416,-.06984,.02275,.166,.1659,.1565,.1766,-.2944,.2667,.1716)*f2_14+\nmat4(.2681,.4278,-.282,-.08501,.1369,.3846,-.00608,-.05377,.3556,-.4641,.4741,.1476,-.3475,.1497,.1845,-.483)*f2_15+\nvec4(-1.968,2.612,-1.606,.4035));vec4 f3_14=sin(mat4(-.1166,-.3283,-.2168,-.3058,.9779,.3033,-.03975,.02107,.09751,-.005665,.43,.0257,-.4593,-.4718,-.02012,.3459)*f2_0+\nmat4(.169,-.1762,-.343,.178,-.3669,.5037,-.5349,-.4881,1.05,.2906,-.1266,.3518,.1801,-.8639,-.465,-.6868)*f2_1+\nmat4(.06152,.3244,.2824,.3073,.2272,.124,-.218,-.109,-.01312,.1748,-.03624,-.2855,-.1336,.08905,.1737,.6139)*f2_2+\nmat4(.5078,.1504,.788,-.5162,.1881,.4972,-.4857,-.02424,.2995,.1718,-.3264,-.8116,.04571,.4699,.1827,-.003224)*f2_3+\nmat4(.6028,-.004993,.1336,-.2334,.3054,-.4457,.4602,-.2579,.06016,-.06623,-.5688,-.004717,.3608,-.316,.3548,.3025)*f2_4+\nmat4(-.4858,.1092,-.1891,.4889,-.3397,.03336,-.1952,.7599,-.3815,-.2119,-.2481,.2137,.2802,.1046,.08951,-.2699)*f2_5+\nmat4(-.1061,-.7462,.07841,-.05459,.5714,.1521,-.2794,.08851,-.6093,.03515,.1451,.3318,.3803,.8924,-.1083,.3303)*f2_6+\nmat4(.2685,.3769,-.722,-.53,.1614,.3453,-.1453,.1172,.1017,.07156,-.1232,.06195,.1087,-.4466,-.3795,.2382)*f2_7+\nmat4(-.325,-.1708,.1406,-1.011,-.1486,-.2829,.1998,.03013,.2784,-.424,-.05706,-.2076,.07643,.1162,.0134,-.152)*f2_8+\nmat4(-.5394,-.2293,.1819,-.2253,.3407,-.1613,-.2072,.06752,-.5083,-.004809,.4902,-.4118,-.4986,.04271,.3704,-.03026)*f2_9+\nmat4(-.1511,.466,.3809,.1304,.1644,.2621,-.1101,-.493,.9173,.1593,-.2077,-.182,-.1431,-.3043,-.06224,.02351)*f2_10+\nmat4(.1051,.02868,.8415,-1.083,-.4521,-.2876,-.3026,-.1742,-.06363,.3167,-.145,.1413,-.1873,-.06346,-.2776,.09073)*f2_11+\nmat4(.1137,-.01526,-.02286,-.0109,-.6299,.3817,.3572,-.09097,.6818,.01002,.3867,.06991,-.2703,-.1041,-.09602,.03918)*f2_12+\nmat4(.03519,-.1862,-.08099,.4354,-.04202,.3019,.2155,-.3153,.6328,-.8458,-.06795,.2055,.1488,-.5589,.2179,.265)*f2_13+\nmat4(-.102,.1228,.2837,-.2692,-.1336,-.06795,-.2454,.3186,.09386,-.5553,-.002636,.04264,.3701,.5965,.1491,.1335)*f2_14+\nmat4(-.1344,.3483,.6076,.4603,-.402,.3054,.1352,.2624,-.1097,-.02186,-.5506,-.2539,-.1136,-1.208,.3207,.1916)*f2_15+\nvec4(-.2412,-1.589,-1.035,-1.153));vec4 f3_15=sin(mat4(-.5053,.2999,.4826,.283,.09302,-.03038,-.06754,-.03027,.2783,-.4441,-.5783,.09874,.2121,.02119,.5876,.5278)*f2_0+\nmat4(.4134,.3145,.1304,-.1833,-.2007,.02139,.1821,-.4139,.03366,-.4615,-.2329,-.1265,-.8406,-.08421,.7484,.9868)*f2_1+\nmat4(.269,.06914,.1088,.1098,.1204,.1639,-.3894,-.1183,.5528,-.187,-.0668,-.08255,-.2257,-.06931,-.1088,-.1763)*f2_2+\nmat4(.02733,-.06792,.3616,.1569,.1898,-.01496,-.2555,-.02618,-.01413,.3883,.2184,.1412,.2316,.1694,-.04042,-.04989)*f2_3+\nmat4(-.3672,.3074,-.1079,.2143,.1377,.007457,.02776,.07233,-.02215,.05598,.1628,-.07534,.4316,.2494,-.2335,.009459)*f2_4+\nmat4(-.2409,-.1936,-.06388,-.02239,.4664,.0792,.1412,-.18,.3225,-.1705,-.1723,.1638,-.3393,-.1441,-.372,-.155)*f2_5+\nmat4(.4675,-.4604,-.1693,-.03533,.2142,.02396,-.2011,-.2425,-.1662,-.252,-.0794,.05858,-.7296,-.1866,.03889,.1567)*f2_6+\nmat4(-.06043,.007288,-.2504,-.1767,.04759,.2584,-.2629,.06399,-.0874,-.09328,-.066,.1753,-.06512,-.02426,.1231,.1072)*f2_7+\nmat4(.3005,.312,.02412,.732,-.2411,-.1673,.1004,-.004023,-.8024,.1585,.3015,-.02399,-.05691,.4318,.3227,.06018)*f2_8+\nmat4(.1853,-.3838,-.293,-.02832,-.2767,-.05382,-.1219,-.02172,.02441,-.0985,-.2257,-.05355,.1558,.06968,.1466,.155)*f2_9+\nmat4(.2892,.01193,-.5803,-.6449,-.03413,-.1405,-.2298,-.2383,.06701,-.1841,-.1989,-.1487,-.1117,.2825,.3899,.1378)*f2_10+\nmat4(-.3768,-.09488,-.005652,-.04185,-.1932,.1229,.06545,-.3161,-.2173,-.4847,-.1871,-.1808,-.3344,-.6346,-.2614,.03654)*f2_11+\nmat4(-.3068,-.3457,-.2011,-.1021,-.5971,-.1086,.1194,.02114,.1961,-.1549,-.1384,.04136,.2567,.3894,-.02587,.1242)*f2_12+\nmat4(-.1516,.2776,.3182,-.1207,.5198,-.08266,.0254,-.01703,-.03024,.1449,.2009,-.06856,-.4064,-.1043,-.1746,-.3961)*f2_13+\nmat4(.00404,.009389,.5023,-.1881,.1796,-.2185,.1214,-.123,-.08021,.06809,.3419,-.05182,-.1255,-.5956,-.4715,-.2975)*f2_14+\nmat4(-.2129,.1249,.2268,-.1567,.3613,.09261,.01888,-.116,-.3732,-.05083,-.01637,-.4157,.2598,-.1723,-.01129,.1864)*f2_15+\nvec4(-2.056,-3.405,2.007,.7749));vec4 f4_0=sin(mat4(-1.755,-.1131,-.01367,-1.618,-.1246,.06792,-.01372,-.0262,-.03579,-.1774,-.01286,.000587,.03033,.05153,.04502,-.03424)*f3_0+\nmat4(.04341,.1071,-.03266,-.02533,.009073,.0977,.006698,-.05693,-.05157,-.1548,.04646,.08675,-.03127,-.198,.0005635,.00419)*f3_1+\nmat4(.0429,.1123,-.004097,.0838,.0451,.3452,.01551,.01948,-.03456,.1696,-.02715,-.01434,.08276,.3937,-.009686,-.01775)*f3_2+\nmat4(-.03534,-.1412,-.06439,.05674,.009227,-.1424,.009095,.002817,-.0293,.0635,.003835,.01817,.04257,.05651,.03234,.0128)*f3_3+\nmat4(-.01173,-.1601,-.0009064,-.04651,.02336,.1434,.01567,-.03095,.02126,-.1396,.01699,.007693,-.1782,.05282,-.01951,-.01338)*f3_4+\nmat4(.07971,-.0952,.0205,.008371,.01314,-.15,-.01009,.01644,.04494,-.06986,.03195,.04067,-.01168,.03344,-.009058,.03349)*f3_5+\nmat4(-.04559,.07094,.001926,-.04143,.06346,-.0816,.02702,-.01443,-.02449,.0106,.04034,.04494,-.0163,.01419,.03427,.007895)*f3_6+\nmat4(.01261,.1684,.009971,.07474,.02091,-.1885,.04134,.01447,-.03349,.1223,.01334,-.005366,.004816,.3682,.02359,.02336)*f3_7+\nmat4(.07196,.1465,-.001835,-.008484,-.001281,-.07869,.009429,.04432,-.03227,.02308,-.009253,.01041,-.03305,-.08685,-.05662,.02026)*f3_8+\nmat4(-.01309,.1246,-.005647,-.08506,.09144,.04448,.02008,-.003679,-.03837,-.113,.02215,-.02402,-.01304,-.0435,-.008907,-.001196)*f3_9+\nmat4(.007066,.3375,.002349,-.01988,-.007517,.0132,-.008938,.007151,-.04574,-.07934,.03985,.004666,.004724,.01022,.004873,.07899)*f3_10+\nmat4(1.216,.7561,.01383,.004288,.04755,-.06615,-.006774,-.0253,-.0003827,.08445,.02997,.01342,.1041,-.3402,.03106,.02396)*f3_11+\nmat4(-.02125,-.2628,.04741,-.04647,.004785,.1041,.01182,-.03591,.03436,-.2302,.04953,.004774,-.03635,-.04972,-.05404,-.0035)*f3_12+\nmat4(-.01432,-.4216,.01587,-.01425,-.07789,-.2697,-.007503,.01924,.0159,.235,.01271,-.029,-.04041,-.3398,.002753,-.04241)*f3_13+\nmat4(-.02372,-.08438,-.02344,.04514,.01234,.00551,.03139,-.01396,.05069,.1353,.0009118,.006931,.0006361,-.08699,-.003729,.03778)*f3_14+\nmat4(.03812,.1118,.01651,-.0113,.06446,-.2901,.0009355,.03173,-.02859,.03029,.002686,.008419,.4644,.8194,.0342,-.003404)*f3_15+\nvec4(.9666,-.2063,-3.129,-1.459));vec4 f4_1=sin(mat4(.01518,.03616,1.498,-1.125,-.009714,.05446,-.08865,.05191,-.0644,.02102,-.03387,-.02621,-.02335,.01062,-.05877,.009313)*f3_0+\nmat4(-.02371,.01489,.06838,-.06842,.05561,.01456,.05457,-.007437,-.004137,.01026,-.008496,.01032,.0006764,-.01813,-.05791,.04675)*f3_1+\nmat4(-.007521,.02159,.0182,-.2086,.0008515,.009609,.05005,-.1388,.04198,-.01857,-.02371,-.003343,.02987,-.02178,-.05699,-.1219)*f3_2+\nmat4(.01064,-.004457,.03082,-.01782,.01277,.01065,.05616,.04758,-.01259,.0365,-.03673,-.01106,-.01589,-.008284,-.05169,.09485)*f3_3+\nmat4(.01988,.04866,-.1191,.5336,-.02558,-.003789,-.04726,.04405,.0174,-.03825,.04571,.04046,.03396,-.02767,-.05942,.3452)*f3_4+\nmat4(.01927,.004132,.02831,-.009772,.03752,-.0584,.07631,.008744,.009192,-.0028,.1022,-.0485,.02769,-.006421,.03462,-.06435)*f3_5+\nmat4(-.01442,-.0001708,-.06371,.0458,-.002294,.0403,.06199,.02667,.03626,.02684,-.1038,.002555,.02275,.01559,-.004754,-.00414)*f3_6+\nmat4(.02974,.005582,-.02974,-.2579,.0004146,.03383,-.04111,.134,-.0389,.008913,-.04017,-.05103,-.05009,.03371,.07104,-.1765)*f3_7+\nmat4(.02368,-.02548,-.03414,-.04824,.006095,-.001728,.02464,.05841,-.0291,-.01704,-.0131,.01388,-.02851,.02112,.03774,.0287)*f3_8+\nmat4(.03758,-.01722,-.03288,-.06761,.03442,-.004442,-.03899,-.445,.007306,.04015,.07542,.03623,.002382,.02856,-.03185,.01694)*f3_9+\nmat4(-.006493,-.02875,-.01376,-.04345,-.02537,-.01329,-.01252,-.03688,-.01242,.023,.09148,.02985,.01319,-.02473,.02349,-.019)*f3_10+\nmat4(.0008609,.01291,-1.825,.9398,-.02928,.01546,-.03851,-.01141,-.007832,.01651,.01858,-.004957,.004237,.001328,-.07007,.1529)*f3_11+\nmat4(.004301,.0331,-.003893,.006832,-.03782,.03309,-.03599,-.02425,-.01818,-.003647,.07421,.00157,-.04166,-.02744,.052,.007619)*f3_12+\nmat4(-.03841,-.02221,-.01313,.03575,-.0136,-.007269,-.0009831,.07428,-.009835,.01224,-.03623,-.01676,-.02492,.01426,.01594,.07778)*f3_13+\nmat4(-.00293,-.02634,.004386,-.03323,-.01384,.008857,.01015,-.03008,-.01981,-.005534,-.007318,.005948,.0207,.03351,.04709,-.002519)*f3_14+\nmat4(.002824,.01005,.009762,-.01281,.04553,.02435,-.05109,.1312,.01116,.000891,.01527,.07485,.003022,-.00713,-.6514,.4029)*f3_15+\nvec4(-.004958,-3.133,2.586,1.102));vec4 f4_2=sin(mat4(-.006085,-.001161,.337,.02942,-.007184,-.00172,-.04594,.008663,-.004182,.004797,-.07524,.03751,-.008556,-.01794,-.05797,-.04316)*f3_0+\nmat4(.002311,-.03908,.0788,-.002709,.0006428,.01582,.04071,-.02639,-.002114,.01541,.003072,-.002142,.002052,.0005133,-.03978,-.01153)*f3_1+\nmat4(.006068,-.02294,-2.301,.02731,-.0249,.02647,.04102,.003827,-.01699,.0289,-.007547,-.03241,.003059,-.02869,.1681,.01392)*f3_2+\nmat4(-.008485,-.003208,.005646,.02719,.0035,-.04385,.03307,.02061,-.007029,.04856,-.02905,-.01801,.005208,-.001163,-.01644,.01595)*f3_3+\nmat4(.01156,.05136,.3318,.001113,.02489,.03685,.03119,.02325,.002828,.0001398,.04169,-.01387,-.0197,-.02518,.5308,.03916)*f3_4+\nmat4(-.009483,-.01491,.03314,-.006414,.02002,.01028,.02612,.02816,.008042,-.01935,.03723,-.02351,-.0007186,-.001017,.04452,.01305)*f3_5+\nmat4(-.00639,-.003039,-.04676,-.02322,-.0128,.01009,.01796,-.008884,.003159,.04087,-.008284,-.01264,.01394,.001143,-.007996,-.02478)*f3_6+\nmat4(.01789,.05462,-.6022,.02123,.01213,-.01608,.0848,.03658,-.008466,.002018,-.02451,.01812,-.006358,-.02626,-.1297,-.01355)*f3_7+\nmat4(.006146,.02287,.04686,-.0001407,.002486,.01551,-.06123,-.02874,.005597,.004618,-.01823,.007435,-.01979,.001061,-.001563,.006891)*f3_8+\nmat4(.006634,.01377,.04221,.02581,.01254,.01398,-.1123,-.0239,.000599,-.01328,.01852,-.01951,.003467,.002507,.02549,-.01383)*f3_9+\nmat4(-.002638,.0002538,-.03896,.01182,-.009409,.01022,.002029,.05168,-.005035,.01755,.00625,.002319,-.01105,-.02041,-.009361,-.006768)*f3_10+\nmat4(.008569,.009173,.2753,-.005023,-.01365,.01665,-.02002,.00462,.01069,-.002219,-.02316,-.001025,.0115,.003846,-.03193,-.01647)*f3_11+\nmat4(.002435,.0007113,.1596,.004926,-.005263,-.0176,-.006804,-.01349,.004362,-.01338,.01366,.007545,-.000137,-.01769,-.04285,.024)*f3_12+\nmat4(-.01728,-.006071,.01447,-.001785,.01188,.02246,.1052,-.02396,-.01054,.01853,.1083,.002616,.01157,-.01214,.01458,.009824)*f3_13+\nmat4(.01353,-.02444,.02017,-.02878,-.00445,-.001173,-.04165,.03274,.006998,-.01121,.02436,-.01083,.01736,.01836,.04534,-.04545)*f3_14+\nmat4(-.007711,.003087,.03553,-.005767,.01084,.0515,-.1169,.01052,-.003758,-.0251,-.03856,-.007196,-.008219,-.03339,-.004822,-.03704)*f3_15+\nvec4(-4.734,.0236,.7411,.01395));vec4 f4_3=sin(mat4(.1584,-1.673,-.007415,.1342,-.2436,-.00893,.007878,-.3884,-.03663,-.007702,-.03126,-.1693,-.1927,-.01196,-.01473,-.1725)*f3_0+\nmat4(.05543,-.001294,-.003111,.06197,-.1446,-.03708,.006965,-.01041,.116,.04454,.02502,.1182,.08682,.03626,-.03912,.1018)*f3_1+\nmat4(-.3716,.03545,-.03636,.05042,-.09757,.03235,.01433,.1608,-.001329,-.09459,.03546,-.09793,.187,-.01513,-.008005,-.5122)*f3_2+\nmat4(.04675,-.005285,.01135,.03445,.04161,.01919,.01198,.05318,-.1514,-.004449,.01396,-.08827,-.07376,.05044,-.01324,-.2845)*f3_3+\nmat4(.4665,-.04295,.02892,-.4508,-.09375,.01103,.0409,-.08264,.05505,-.04077,-.009641,.1282,-.1731,-.009903,-.03654,.5013)*f3_4+\nmat4(-.278,-.008892,-.02695,-.3907,.1033,-.004632,.01845,.1753,.1041,.03296,-.02999,.05491,.06987,-.02219,.04039,.241)*f3_5+\nmat4(-.0708,-.01471,-.01248,-.04216,.07692,.003491,.02671,.005736,-.1003,.006825,.0162,-.06417,.08107,.08858,-.008487,.1589)*f3_6+\nmat4(-.1227,.02159,.02569,.3245,.04608,-.01007,.02039,.02463,-.03644,.008589,.03444,-.04987,.1571,.04092,-.02818,.4608)*f3_7+\nmat4(-.1299,-.01333,-.01432,-.0176,.1345,.01061,.02446,.01898,-.1156,-.05847,-.008241,.01189,.05407,-.01289,-.02967,.03022)*f3_8+\nmat4(-.1137,.01628,-.01289,.01168,.2618,-.01825,.04289,-.02262,.1077,-.01533,.03345,-.04424,-.06304,.01233,-.01244,-.305)*f3_9+\nmat4(-.05933,.0445,-.004097,.0817,.1004,.04738,-.003859,.0941,.1066,.02138,-.02376,.07719,.1416,.06028,.00556,.03293)*f3_10+\nmat4(1.977,.02388,-.0009059,1.451,-.08259,.01244,-.001559,-.0365,-.07378,.0008863,.008884,-.08731,-.3035,-.01232,.03989,-.6698)*f3_11+\nmat4(.07895,.02654,-.04508,.03333,-.06804,-.01736,-.006156,-.1498,.1235,.005144,-.006283,.01851,.3058,.02625,.02677,.1827)*f3_12+\nmat4(-.00134,.01517,-.009843,-.05559,.1358,-.09051,-.008662,-.01651,-.2478,.007974,-.03366,.05572,-.008354,.02888,-.02616,.1177)*f3_13+\nmat4(.02013,.03559,-.02225,.1393,-.1334,-.01785,.02815,-.15,-.1187,.03128,-.0234,.03546,.09452,.01289,.009663,-.009074)*f3_14+\nmat4(-.08901,.03898,-.03491,-.09751,-.3176,.02156,.0337,-.4416,.1784,-.03771,-.01668,.1018,.4513,.002903,.01472,.3511)*f3_15+\nvec4(3.281,4.808,3.15,-1.822));vec4 f4_4=sin(mat4(.1784,-.08072,.002455,1.149,-.1509,-.03492,-.008581,.02746,.1747,.03093,-.005265,.02455,-.05502,-.0005764,-.02278,.002665)*f3_0+\nmat4(-.08202,.04282,.002641,-.04054,-.154,.004094,.009057,-.06848,.2371,-.06822,.03249,.03155,.1928,-.008392,-.007218,.03917)*f3_1+\nmat4(-.159,-.06411,.04569,.1443,-.3791,.09471,.03326,-.007762,-.2338,-.01954,-.03425,.009541,-.3281,.01435,-.01151,.07874)*f3_2+\nmat4(.175,-.04639,-.01352,.03716,.1815,.003451,-.02208,-.03608,-.1328,-.0247,-.00101,-.001009,-.1022,-.01452,-.0006508,.01465)*f3_3+\nmat4(.3837,.02594,-.01319,-.2358,-.1316,-.03313,.03983,-.02607,.1687,-.000336,.003197,-.006337,-.09982,-.1173,-.00935,-.4476)*f3_4+\nmat4(.007219,.006029,.0009461,-.05134,.1789,.02449,.0278,-.01714,.1476,.008156,.03219,-.02922,-.004488,-.06246,-.01714,-.004559)*f3_5+\nmat4(-.07925,-.0006368,-.01518,.03578,.1194,-.01585,-.03004,-.01685,-.01012,-.03715,.03521,.02967,.02918,-.01207,-.0009192,-.01401)*f3_6+\nmat4(-.2057,.03126,-.002372,-.1166,.2449,-.0144,-.01058,.01147,-.1828,-.01485,-.04938,.0331,-.3669,-.008478,-.03789,.06567)*f3_7+\nmat4(-.1798,.06094,-.004205,-.00677,.09607,-.06443,-.01243,.01213,-.09482,-.04557,-.0364,.01392,.1364,.002152,-.03035,-.0002524)*f3_8+\nmat4(-.1993,.03959,-.004361,-.004659,-.02437,.06611,-.004075,-.1249,.1243,.001718,-.007553,-.001013,.03326,-.0273,-.01335,-.003286)*f3_9+\nmat4(-.3732,-.002289,.01055,.03993,.04703,.007972,.02534,-.009477,.1195,-.006721,.03722,-.0344,-.01374,-.01465,-.0005926,.01949)*f3_10+\nmat4(.4717,1.614,.0317,.4508,.05497,.01572,.01505,.04339,-.08956,-.02131,.01938,-.01921,.1732,.05034,.0002183,-.1443)*f3_11+\nmat4(.3081,.002356,.03013,-.003755,-.1417,-.02179,-.02132,.006572,.2667,-.05669,.0237,-.0197,.1081,.002845,.005147,.02071)*f3_12+\nmat4(.4433,-.05612,-.01543,-.01649,.3544,-.00079,-.00198,.03652,-.339,-.0482,.02036,-.03901,.3799,-.0004552,-.01753,-.03763)*f3_13+\nmat4(.1042,-.08679,-.03462,.002815,-.03988,.02368,.006964,-.01003,-.1718,.02446,-.0003868,-.02378,.1396,.04073,-.03317,-.03202)*f3_14+\nmat4(-.151,.02242,.04044,-.01394,.1867,-.015,.04063,-.09381,.0005528,.001305,-.01607,.0008924,-.5088,.5907,.0003585,.1657)*f3_15+\nvec4(5.08,5.236,.007272,-2.133));vec4 f4_5=sin(mat4(-.2271,-.09992,-.006337,.4399,.4142,.1348,.0008563,.1896,.18,.04729,.01691,-.04405,.2971,.1184,.02946,.08652)*f3_0+\nmat4(-.09325,-.02205,-.05045,-.101,.2291,.08217,-.05359,.1625,-.3239,-.1076,-.01319,-.1945,-.2488,-.08992,-.008005,-.135)*f3_1+\nmat4(-.1427,-.1353,.005459,1.404,.16,.07247,.1774,-.09036,.2105,.06766,.06053,.02212,.03441,.02107,-.02661,-.125)*f3_2+\nmat4(-.1796,-.0544,.0005722,-.08461,-.2205,-.08988,.001395,-.002068,.2391,.07634,.02301,.02375,.213,.06717,-.02369,.1855)*f3_3+\nmat4(-.5429,-.2104,.06642,.3793,.2483,.08833,.04079,.1655,-.2703,-.09047,-.01854,-.0005235,.0944,.01421,-.06655,.3526)*f3_4+\nmat4(.5742,.2077,-.004004,.4004,-.199,-.07448,.01133,-.007387,-.2827,-.08825,.04403,-.1111,-.1289,-.04944,.005111,-.07888)*f3_5+\nmat4(.1683,.06128,-.01047,.1125,-.1931,-.06932,-.07128,.0006972,.1727,.07127,.03733,.05058,-.1782,-.06558,-.01528,-.09604)*f3_6+\nmat4(-.1263,-.1296,.0164,.369,-.2601,-.09373,.02725,.05849,.1683,.06602,.04904,-.03008,-.01165,.07259,-.01473,-.4042)*f3_7+\nmat4(.225,.08247,.01734,.07499,-.2576,-.08419,.01468,-.1454,.203,.04957,-.01442,.1267,-.167,-.05824,-.007055,-.03505)*f3_8+\nmat4(.2263,.07962,-.0211,.1204,.01242,.002325,.0337,-.2754,-.3201,-.1302,-.0275,-.07042,.1894,.0618,.02359,.09038)*f3_9+\nmat4(.1617,.08114,.003008,.003487,-.2001,-.07375,-.02491,-.1171,-.245,-.09308,-.03018,.02584,-.1844,-.07567,-.002229,-.1316)*f3_10+\nmat4(-.1733,.2701,1.595,.4507,.2523,.09434,-.006195,.0711,.2366,.08787,.0007222,.0644,.9939,.2913,.04539,.9072)*f3_11+\nmat4(-.3179,-.1262,-.03133,-.01074,.3031,.1171,-.008876,.004389,-.2674,-.1092,-.03318,-.05707,-.4164,-.1347,-.01373,-.1901)*f3_12+\nmat4(-.07118,-.05167,-.07768,.09405,-.3574,-.1391,.01267,-.03459,.4123,.1461,-.01041,.1472,-.1146,-.07377,-.04413,.1054)*f3_13+\nmat4(-.2153,-.06933,-.04021,-.07014,.2154,.06484,.02591,.007977,.2347,.07521,.02801,.1647,-.206,-.05885,.01237,-.01265)*f3_14+\nmat4(.2494,.08346,.008166,.1436,.3494,.08793,-.04273,.1914,-.271,-.08447,-.03569,-.05673,.2727,.1935,.5551,.2316)*f3_15+\nvec4(-5.536,-1.202,-.9757,-3.254));vec4 f4_6=sin(mat4(.1371,-.0005547,.01692,-.06239,.748,.008011,.0136,.01148,.4788,-.04158,.03111,-.02758,.4562,.02242,-.06908,.005735)*f3_0+\nmat4(-.2292,-.00492,-.004016,.01306,.5828,.01582,-.04319,-.01831,-.4386,.01973,.02271,-.00299,-.2777,.0152,-.02029,.01411)*f3_1+\nmat4(-.5476,.001553,.007549,-.09447,-.03619,.003629,.003111,-.04998,.5095,-.04896,.0003463,.02614,-.3094,-.02225,-.02216,.01858)*f3_2+\nmat4(-.5453,-.0185,.01765,.02601,-.2173,.03185,-.01616,.01513,.4779,-.03514,.008437,-.0186,.404,.03754,.03118,-.01685)*f3_3+\nmat4(-.2075,.00827,-.01009,-.04225,.3241,.004755,-.02012,-.03391,-.3252,.001482,.005203,.03092,.2299,-.01286,.002074,.01602)*f3_4+\nmat4(.906,.009212,-.01523,-.02912,-.224,-.001844,.04451,-.04599,-.5145,-.00305,.01211,-.05282,-.2917,-.009037,.0618,.002015)*f3_5+\nmat4(.407,.05665,-.004797,.03336,-.2561,-.005967,-.05094,.05723,.3499,.01913,.0001136,.000272,-.4035,.01148,-.01574,.04356)*f3_6+\nmat4(-.02097,-.01431,-.003011,-.01619,-.3947,.02639,.0041,-.005161,.3147,-.03258,-.06413,.01879,-1.192,.01972,-.008598,.00535)*f3_7+\nmat4(.3099,-.002475,-.006568,.03487,-.506,.04637,.011,-.005429,.4559,-.005278,.01868,.02157,-.3386,.01729,.03353,.01618)*f3_8+\nmat4(.274,-.04613,-.0426,.02118,-.22,-.04079,-.001937,.03153,-.435,-.03672,-.009279,.01359,.3985,-.003505,-.05313,-.04023)*f3_9+\nmat4(.07879,-.01631,.0281,-.07343,-.3789,.05497,.02239,-.01239,-.4281,.004954,.06227,.01827,-.2694,.01496,-.004415,-.004735)*f3_10+\nmat4(.2908,.009394,-.009993,-1.653,.509,.02505,-.01173,.007497,.2204,-.0498,.02534,.04868,2.313,-.01802,.00932,-.01885)*f3_11+\nmat4(-.2176,.04677,.001281,.04573,.5236,-.03129,-.02825,.02831,-.2956,.005221,.01905,.01556,-.8202,-.03047,.001321,.006745)*f3_12+\nmat4(.4276,-.005252,-.02099,.03806,-.4535,.003624,-.009622,.03498,.3919,-.002123,.02945,-.03038,.2586,.004716,-.04776,.05957)*f3_13+\nmat4(-.3319,-.009099,-.01049,.02108,.3906,-.04873,.02743,-.01305,.561,.02969,.03081,.026,-.3911,.006434,-.02906,.004108)*f3_14+\nmat4(.45,.06273,.01177,-.02242,.4325,.01493,.031,.0006462,-.5311,.003595,-.01207,.01146,.4134,.008634,-.02028,-.5894)*f3_15+\nvec4(.5547,-3.161,3.139,-2.2));vec4 f4_7=sin(mat4(.9018,.01584,-.008659,.6124,-.01403,.04015,.0006009,-.07494,-.02881,-.09827,.005838,-.009132,-.05684,-.1477,.01162,-.01879)*f3_0+\nmat4(.03265,.004897,.007678,.03198,-.06144,.1589,.005143,-.05036,.06997,-.01196,-.01129,.02147,.06462,.07472,-.00707,.02042)*f3_1+\nmat4(.2305,.195,-.005329,-.4305,-.07984,.01066,-.02307,.02657,-.02776,-.09848,-.008145,-.01064,-.2571,-.1764,-.02306,.05187)*f3_2+\nmat4(-.04909,.04939,-.01618,.02978,.01124,.004507,-.005017,-.004891,-.07899,-.1148,.002112,-.01746,-.01533,-.08799,-.007143,-.04971)*f3_3+\nmat4(.04015,.02545,.006259,-.2219,-.02599,-.04727,.003921,-.03637,.0228,.1347,.01169,.01009,2.238,.04944,-.007677,-.2425)*f3_4+\nmat4(-.02426,-.09162,-.004401,-.06573,.01574,.02947,.004396,.01188,-.07321,.03393,-.002887,.02829,.01857,-.007313,.006697,.03879)*f3_5+\nmat4(.01912,-.04482,.001712,-.03891,.03476,.007571,.003831,-.009536,.03488,-.1159,-.001588,-.02626,-.001062,.04701,.0007712,.01203)*f3_6+\nmat4(.3224,.04437,.008141,.04182,.1077,.07507,-.01083,-.01534,.02822,-.0318,.009594,.004494,-.1292,-.00313,.007658,.1208)*f3_7+\nmat4(-.03231,-.02521,-.0118,-.009648,.03341,.0008929,.001251,.001229,-.05979,-.01767,.009431,-.02931,.04655,.01049,-.004689,.01081)*f3_8+\nmat4(-.04024,.06045,.01593,-.006872,1.507,-.04884,.01219,.1493,-.01642,.06457,.009577,.01434,-.00875,.005245,-.00144,-.009681)*f3_9+\nmat4(-.04227,.02272,.003858,.007082,.03671,.1153,.001706,.01473,.00588,.08069,-.005291,.01596,.02254,-.09918,.01016,.02041)*f3_10+\nmat4(.7612,-2.383,-.005306,-.1109,-.05581,-.05908,.001538,-.008657,-.008468,-.01673,.01077,-.0193,.06958,-.000149,.01154,-.2963)*f3_11+\nmat4(-.02031,.09472,-.005041,.01289,.04608,-.108,.002611,-.02109,-.02211,.04532,-.01098,.00913,.05057,.01744,-.002156,.03273)*f3_12+\nmat4(.1315,.07536,-.001789,-.02706,.07354,.01217,-.008794,.002035,-.06003,-.03233,-.01576,-.03314,.03447,.02337,.007837,-.03076)*f3_13+\nmat4(.03333,.06262,-.00245,.02755,-.04783,.06241,.0007911,.002504,-.003032,-.007207,-.0125,-.03214,.0373,.1453,-.006665,.009985)*f3_14+\nmat4(-.05565,-.008603,.0004669,-.02035,.07252,.05797,.003554,-.05912,.07128,-.06703,-.001991,.02337,.2265,-.7669,-.001988,-.1086)*f3_15+\nvec4(.3762,-1.437,1.569,2.613));vec4 f4_8=sin(mat4(.00797,1.7,-.03922,.01792,-.01017,.0128,.008108,.003048,-.02443,.02248,-.000869,-.01368,.0394,-.01496,-.01223,-.009838)*f3_0+\nmat4(.01936,.02348,.01514,-.01154,-.01138,.01107,.01042,-.04547,-.008151,-.02612,.02517,-.03097,.01165,-.02772,.008485,.002132)*f3_1+\nmat4(.01025,-.04949,.07226,-.001497,-.009004,.04504,.00484,.01744,.06518,-.04659,.01677,.01118,-.008871,-.001367,.03576,-.02075)*f3_2+\nmat4(.01707,.0003828,.01074,-.02182,.04527,.04918,-.00773,.01284,-.00877,-.002899,-.01646,-.005996,.05084,-.004394,-4.932e-05,-.02718)*f3_3+\nmat4(-.00531,.06895,-.03776,.03492,.0593,.02482,-.002159,-.009542,-.0317,-.02898,-.007958,-.03872,.0165,.03578,-.02698,-.03252)*f3_4+\nmat4(.00838,.05734,.02306,-.0411,-.01255,-.02217,-.02007,.0109,.03413,.01553,-.01016,-.02837,.002923,.01776,.01359,.006385)*f3_5+\nmat4(.02981,.02866,.007662,.02512,-.005244,.01448,-.005778,.01711,-.008408,.02892,-.004545,.04514,-.04255,.02161,-.02196,-.02298)*f3_6+\nmat4(-.0157,-.01165,.1131,.0274,.04435,-.1181,.01331,-.02323,.0606,.03509,-.00808,-.01621,-.00493,-.03324,-.008769,-.004609)*f3_7+\nmat4(-.03243,.04835,.007495,.03827,.05162,-.007928,.01105,.0001834,.004232,-.01016,-.005341,-.006492,-.004125,.00108,-.004209,.0228)*f3_8+\nmat4(.00915,-.05339,-.01348,-.04008,.03566,.007762,-.00415,-.01138,.004447,.03996,-.01113,-.02259,.003734,.03609,-.02047,-.01783)*f3_9+\nmat4(-.02298,-.01907,-.0169,.01976,-.01519,.01618,.005044,.03611,-.05796,-.05209,-.001693,.001285,-.01108,.01255,.003917,.02833)*f3_10+\nmat4(.02193,.02556,.05119,-.004437,-4.697e-05,.04826,.002728,.008102,-.0467,-.004808,-.0005255,.005182,-.02836,-.01875,-.000722,.006941)*f3_11+\nmat4(-.02982,.03146,-.001271,.008296,-.04641,-.04427,-.003909,.008818,-.006,.03761,-.002298,-.0514,.04466,.02276,.01119,-.008228)*f3_12+\nmat4(.0009862,-.06908,.02467,-.01638,.01873,.02049,-.004134,-.008848,-.009757,.009324,-.00816,-.02071,.04444,-.003346,.005384,.002717)*f3_13+\nmat4(.01611,-.02571,-.007686,.004682,.02466,-.04819,-.008959,.01979,-.03177,-.009825,.007539,.01489,.01982,-.00918,-.01452,-.008696)*f3_14+\nmat4(-.01139,-.0102,.001747,-.0002484,-.09285,-.0138,.009121,-.006614,.007626,-.01863,.02379,.0006299,-.01036,-.005197,-.007445,.01712)*f3_15+\nvec4(-.01997,-4.809,1.607,-3.121));vec4 f4_9=sin(mat4(-.04266,.0008886,-.005224,-.2461,.04554,-.003483,.006849,-.1745,.01218,-.008252,.00224,.09862,.01375,-.002582,-.005781,-.07173)*f3_0+\nmat4(-.0265,.01145,-.006483,-.06402,-.000656,.004229,-.01556,-.2644,.03751,-.001881,-.00482,.03777,-.002198,.006619,.00286,.09322)*f3_1+\nmat4(-.01871,-.007599,.003387,.5676,.008535,-.01131,-.01138,-.1401,-.0249,.006705,-.01036,.00674,-.0256,-.00746,-.004661,-.2158)*f3_2+\nmat4(-.02293,.002692,-.001166,.0003532,.0101,.008632,.002769,.118,-.0033,-.01154,.01032,-.04302,.0298,-.005762,-.005798,-.1538)*f3_3+\nmat4(.005349,.005315,-.001517,.1097,.03383,.002745,-.01953,-.03114,-.02522,-.0009863,.002651,.03466,.007144,-.005164,.004583,-.4934)*f3_4+\nmat4(.009149,-.000965,.003943,-.1599,.02153,.01033,.00139,.09033,-.004533,.0008605,.01082,-.06549,-.04844,.003237,.007121,.05936)*f3_5+\nmat4(.01675,.007237,-.007208,.0002574,-.0007484,.006972,.007544,.01445,.02673,-.003009,-.00578,-.06862,.007819,-.009452,.002654,-.02682)*f3_6+\nmat4(.001517,-.007137,-.001798,.3628,.01916,.001276,.002896,.1022,.004928,-.005465,-.00465,-.00299,.01951,.006001,-.001119,-.02799)*f3_7+\nmat4(.01627,-.008196,-.001039,-.08031,-.0147,-.01721,.004377,.05488,-.006174,.01052,-.004184,.04516,.005759,-.005092,-.004845,.02712)*f3_8+\nmat4(-.0154,.002856,-.01775,-.1455,.01146,.02152,.00722,-.1274,-.07445,.02079,-.006,-.01388,-.006496,-.01665,-.01396,-.0853)*f3_9+\nmat4(-.02055,.007528,-.003091,-.148,.06194,-.01234,.01262,-.0886,-.0002121,.006614,.01186,-.01458,.005676,-.001494,.0007002,.04953)*f3_10+\nmat4(.01021,.0008591,-.006297,.1674,.003499,.006006,-.004543,-.0589,-.03337,.00601,.01228,-.01612,-.03527,-.01525,.0006668,-.3352)*f3_11+\nmat4(.06421,.003494,-.00435,.08228,-.01419,-.008921,-.006337,-.04039,.01059,.001567,-.002056,.04997,.04626,.005146,-.008693,.1782)*f3_12+\nmat4(.04234,-.005459,-.0007453,.3183,-.01625,-.01171,.01276,.24,-.0005918,-.001044,.01191,-.3571,.02405,.004485,-.006047,.09889)*f3_13+\nmat4(-.01918,-.01397,-.008618,.05327,-.01579,-.001279,.01147,-.04677,-.003751,.005217,-.003918,-.1103,.009035,-.01104,.005343,.06039)*f3_14+\nmat4(.01643,-.003663,.008444,-.1499,.009444,.01912,-.007831,-.02058,-.02694,.006759,-.007039,.1375,-.0005932,.00654,-.002684,-.2994)*f3_15+\nvec4(3.136,-4.721,1.568,2.483));vec4 f4_10=sin(mat4(.2217,-.02813,.01226,.006026,.01673,-.002017,-.00129,.009317,-.03211,-.02722,.004435,-.03421,.03474,.004297,.008123,.01847)*f3_0+\nmat4(.005867,-.0006599,.01207,-.004928,.04769,-.006111,.007533,.02454,.09338,-.0002583,.003667,-.01475,.02759,-.005312,-.04801,-.009258)*f3_1+\nmat4(.07566,-.01355,.001803,-.03588,-.08854,-.008052,.03174,-.02216,-.02113,.0004052,.007831,.01847,-.1653,-.0179,-.02287,-.008887)*f3_2+\nmat4(-.02118,.007866,.004358,-.03176,.001224,.001719,-.01155,.003918,.001226,-.01875,.01858,.05107,.04404,.01119,-.005474,.02989)*f3_3+\nmat4(-.219,.007083,.02215,.02672,.02945,7.908e-05,-.02343,.06711,-.06282,.005083,-.03666,.05912,3.561,-.01543,-.0321,-.005086)*f3_4+\nmat4(-.01672,-.01059,-.01784,.0149,-.05037,-.006487,-.002326,.03473,.05406,.002179,-.02252,-.009207,.04429,-.00353,-.004743,.0339)*f3_5+\nmat4(-.05177,-.0004699,-.007722,.0231,.005923,.01185,.03539,.008214,-.002277,.005556,-.01323,.02229,-.04334,.0009541,-.008774,.001851)*f3_6+\nmat4(.05697,-.006863,.006393,.0289,.05937,-.001131,.01032,.05144,.004899,.001405,-.02442,.01418,-.1495,.01768,-.01467,.01933)*f3_7+\nmat4(.01887,-.001195,-.01719,-.02739,.00872,.007972,-.01016,.03455,-.05037,.01037,-.01239,.007432,.07265,-.005502,-.0528,.01657)*f3_8+\nmat4(.005633,.02918,.02428,-.00497,.0944,.004522,-.03241,.0232,-.003252,.01347,-.004659,-.001736,.05943,-.002075,-.008116,.00697)*f3_9+\nmat4(-.04713,.01138,-.0007158,-.01181,.01356,-.002689,-.04524,.01421,.02863,.01967,.0431,-.04137,-.01623,-.01184,.02724,.02323)*f3_10+\nmat4(2.062,.02038,.02933,-.001409,.008993,.002883,.01003,.02756,.04771,.004048,.04053,-.003102,.05954,.02073,-.02576,.01902)*f3_11+\nmat4(-.1375,.002995,-.02567,.02558,.03542,.008704,.04205,-.03415,-.08737,-.007113,-.009964,.02895,-.04355,-.003562,-.02003,-.03232)*f3_12+\nmat4(-.000452,-.009932,.03783,-.03452,-.02451,.009208,-.02492,.03841,-.03449,.004428,.02106,.05555,-.05348,.006958,-.04577,.01129)*f3_13+\nmat4(-.005936,-.004101,-.008991,-.01638,-.06711,.009253,.006213,.03809,-.02666,-.02392,.006036,-.008043,.01555,.01071,.02342,-.002786)*f3_14+\nmat4(-.05769,-.01633,.03026,.001694,.09329,-.01887,.02042,.01153,-.0481,-.01372,.03184,-.003383,.682,-.006156,-.02694,-.04709)*f3_15+\nvec4(2.067,-1.6,-.01258,-6.277));vec4 f4_11=sin(mat4(.001891,.003843,1.623,-.2371,.00524,.001728,.01586,.7758,.004671,.03082,-.02737,.2833,.005105,-.005467,-.0005568,.5208)*f3_0+\nmat4(-.006382,-.001084,.01742,-.2123,.005459,-.01844,.01164,.382,.001741,.001851,-.005162,-.5769,-.01184,.005783,.0132,-.3771)*f3_1+\nmat4(.001203,.01332,.03683,-.1408,.004722,.01068,-.05179,.2074,-.01901,-.006659,-.004313,.3694,-.01734,-.01657,.006527,.05554)*f3_2+\nmat4(.00519,-.001124,-.002005,-.3702,-.007585,-.008795,.03695,-.3292,.007228,-.009834,.007094,.3627,-.009824,.006586,.02242,.4232)*f3_3+\nmat4(.01518,-.002438,-.01053,-.8158,.01172,.005567,.0225,.402,.001233,-.007308,.0307,-.4052,-.01761,.008202,-.0153,.1546)*f3_4+\nmat4(.01399,-.006626,-.02761,.9506,-.005632,.003754,.02162,-.3256,-.003617,.009589,-.02321,-.5362,-.00545,.002107,-.0307,-.1774)*f3_5+\nmat4(-.004153,.006291,.04454,.2566,-.005505,-.00282,.03754,-.3588,.005743,.002294,-.02206,.2839,-.004279,.001857,-.005898,-.2574)*f3_6+\nmat4(.005984,.02463,-.1324,-.08874,.01358,-.007629,.03737,-.4215,.01534,.003829,.002558,.3195,-.003551,-.0008033,-.01188,-.1206)*f3_7+\nmat4(-.01499,-.005483,-.02323,.3629,.0002522,.01082,-.01763,-.4024,-.007027,.006987,.01915,.3874,.003736,.002529,.02667,-.2551)*f3_8+\nmat4(-.002316,.01269,-.001145,.3699,-.014,.007185,.09615,.06943,.01502,.005132,.06493,-.501,-.005281,.001056,-.006313,.3136)*f3_9+\nmat4(-.005213,-.009123,-.02011,.2623,.008348,.006225,-.01832,-.3418,.009525,.003883,-.04246,-.4429,-.007744,.007492,-.04134,-.3058)*f3_10+\nmat4(-.003712,-.00196,.02092,-.6297,-.002269,.01117,.07974,.3994,.01833,.004393,-.02613,.3879,-.008321,-.01244,-.005355,1.785)*f3_11+\nmat4(-.01002,.0007135,.04487,-.5378,.001697,-.003579,-.04585,.4697,.003684,-.008726,.01758,-.3525,-.01229,.007857,.03753,-.7156)*f3_12+\nmat4(-.007075,.008539,.02899,-.04979,-.0003216,.01101,.05284,-.5027,-.01318,-.009051,-.03359,.6913,-.006091,-.003215,.03635,-.06846)*f3_13+\nmat4(-.004101,.004719,-.03018,-.3205,.002705,.00062,.02012,.3935,.00129,-.0007655,-.05162,.3458,-.004692,.006972,-.01056,-.3795)*f3_14+\nmat4(-.002198,.006921,-.008499,.4172,.003478,-.003194,-.06443,.68,.01204,.006474,.006494,-.4681,-.0008709,-.007387,.02066,.3874)*f3_15+\nvec4(1.583,1.578,1.308,-6.429));vec4 f4_12=sin(mat4(3.161,-.01155,.1989,1.676,-.06661,.004937,-.002608,-.01316,-.05783,-.02981,-.02802,.02284,-.0962,-.02464,-.003976,-.0008791)*f3_0+\nmat4(-.0119,.02112,.02397,-.02188,-.04989,.04317,-.01507,.07641,.0224,-.04589,-.0223,-.04521,.04301,-.01242,.0273,-.0136)*f3_1+\nmat4(.05797,-.02756,-.03246,-.03336,.006959,-.01275,-.05172,-.03262,-.05786,-.01936,-.005912,.02443,-.04635,.01856,-.1015,.01167)*f3_2+\nmat4(.03809,-.01511,-.03993,-.05723,.05102,.02011,.05454,-.03703,-.02759,-.04185,.009795,-.04618,-.004608,.01866,.01922,.03799)*f3_3+\nmat4(-.9185,.02921,.09494,.04555,-.009973,-.008002,-.001318,-.03703,-.03427,.02357,-.005708,-.01392,-2.806,-.04931,.1369,.05075)*f3_4+\nmat4(-.142,-.02617,.05548,.02233,-.01461,.01377,-.01145,-.03753,.04412,-.01998,-.01316,-.001761,-.003373,.01426,-.03362,.02084)*f3_5+\nmat4(-.03066,.01083,.02257,-.008332,-.06283,.03407,.02878,.02999,-.02002,-.01711,-.02722,-.01053,-.001987,-.04386,-.01115,-.05161)*f3_6+\nmat4(-.4615,-.01539,.04605,-.01875,.06822,-.02078,-.00891,-.05498,-.04973,-.03628,.05986,.0309,.05758,-.007313,.01166,-.02027)*f3_7+\nmat4(.002478,-.009314,-.03402,-.0159,.02856,.00806,.02056,.05056,.01046,.02829,-.04023,-.006948,.06941,.03578,-.008961,-.01295)*f3_8+\nmat4(-.05488,-.01178,-.01585,.01677,.03993,.01449,-.02913,.09272,-.06356,.01191,.04715,.03399,.02139,-.01569,-.01971,.04545)*f3_9+\nmat4(-.03699,-.01991,-.0519,.03668,.01961,.02894,.03505,.0001553,.02412,-.0155,.0151,.06463,-.06786,.02341,-.02299,.02669)*f3_10+\nmat4(-.2474,-.01989,-.3619,.00514,-.06165,.0002126,.005436,-.04977,-.0141,-.009234,-.01741,-.01656,-.3821,.02949,.03256,-.0001314)*f3_11+\nmat4(.07176,.007207,.005109,-.04807,-.0567,-.02341,-.006773,.05864,-.01342,-.01583,-.01601,-.001769,.0332,.02444,.04262,.01253)*f3_12+\nmat4(-.0238,.004549,-.007763,-.0162,.04383,-.02354,-.01302,.01194,-.08294,-.01989,.01936,.01444,.04235,.01285,.009238,.008859)*f3_13+\nmat4(.04795,-.01211,.004972,-.01209,-.05926,-.0111,.005928,-.04269,.01548,.02019,-.02341,.04416,.03875,.01495,.004379,-.04259)*f3_14+\nmat4(-.0491,.0004063,-.01688,-.03663,-.07261,.03735,.01776,-.03276,.03863,-.011,.02627,-.007598,-.2484,.0101,-.09943,.06872)*f3_15+\nvec4(-.7498,-.0006414,.3979,1.44));vec4 f4_13=sin(mat4(.1878,.002461,.1443,.03243,.4523,.02897,-.02883,.0191,.3059,.01401,-.004453,-.0363,.2684,.009511,.07076,-.00833)*f3_0+\nmat4(-.1459,.02725,.07583,.04674,.3545,.007748,-.1576,-.02058,-.2128,.02754,-.02261,.002403,-.1252,-.01002,-.007406,-.01158)*f3_1+\nmat4(-.3056,.006896,-.3942,.03271,-.06739,.00891,.1298,.006637,.2382,-.02681,.09703,.01812,-.2351,-.03446,.638,.0005451)*f3_2+\nmat4(-.3058,.03457,-.0277,.001932,-.1123,.03454,-.02169,-.001941,.2832,-.0153,-.05561,-.02894,.2176,-.02816,.05756,-.01745)*f3_3+\nmat4(-.01621,.03144,.4047,-.008364,.2078,.01263,.05972,-.02069,-.2038,-.01803,-.03308,-.01998,.1941,-.03719,-.07225,-.004137)*f3_4+\nmat4(.5444,-.0109,-.1237,.02832,-.1133,.01655,-.05831,.02571,-.3037,.03157,.01075,.02841,-.2097,-.03724,-.0283,.0007118)*f3_5+\nmat4(.207,-.01174,.0172,-.04576,-.1272,-.0003894,-.03503,.02907,.2149,-.007125,.01275,-.0335,-.2439,-.0407,.06449,-.000872)*f3_6+\nmat4(-.001397,.01269,-.2633,-.01117,-.2118,.009119,-.04641,.0407,.1629,-.03515,.01608,.01784,-.8223,.00402,.06306,.006063)*f3_7+\nmat4(.1707,.01709,.07056,-.01737,-.2841,.02783,.06184,.0002316,.2989,-.01226,-.07482,-.0267,-.216,.001677,.04716,.01676)*f3_8+\nmat4(.1336,-.009096,-.04556,-.02087,-.1608,-.01067,.3061,-.01563,-.2768,.02458,.004361,.01843,.2158,-.007381,-.04474,-.02162)*f3_9+\nmat4(-.03534,-.02278,.07187,-.02676,-.2081,-.009452,.03922,-.001827,-.265,-.03938,-.06237,.02252,-.168,-.01686,.04129,.00325)*f3_10+\nmat4(-.08074,.002013,1.682,.02518,.3341,.02071,-.08579,-.009642,.1392,.02365,.02343,-.02149,1.536,.01868,-.1436,.02573)*f3_11+\nmat4(-.06598,-.02803,-.0747,.0004127,.2419,.00505,.02933,.03446,-.173,.01071,.005072,.01612,-.477,-.002332,.1082,.02997)*f3_12+\nmat4(.287,.002072,-.2354,-.001524,-.2673,-.01228,.01241,-.02835,.2538,.04399,-.2021,-.02182,.158,-.02935,-.2054,-.01575)*f3_13+\nmat4(-.2085,.006466,-.004283,-.01817,.2282,.009947,.01591,-.004434,.277,-.008547,-.02415,.01008,-.2633,-.03314,.01765,-.003189)*f3_14+\nmat4(.2467,.0108,.02562,-.003812,.3329,.0578,-.1742,-.00979,-.3441,.001337,.1601,.01696,.1019,-.02137,.7372,-.003281)*f3_15+\nvec4(-4.329,3.141,1.001,3.144));vec4 f4_14=sin(mat4(1.683,-.001916,.2655,.02202,.03148,.01608,.0887,-.01131,.01055,.00472,.03394,.02199,-.01089,.003503,.02886,-.008261)*f3_0+\nmat4(.01386,-.005038,-.03086,-.01528,.08655,.009789,.05315,-.007585,-.03397,.01986,-.033,.04974,-.007913,-.003454,-.005075,-.03342)*f3_1+\nmat4(.01421,.002257,.171,.03782,.005571,.01882,-.01135,-.0014,.01722,-.02257,-.008704,-.001959,-.06813,-.02919,-.08992,-.002184)*f3_2+\nmat4(-.1031,-.0008933,-.01309,-.03593,-.02569,-.005371,-.01305,-.04546,.02327,.02772,.02583,.03959,.01913,.01925,.02421,.00123)*f3_3+\nmat4(.005395,.007483,-.1028,-.01933,-.07648,.04647,.004739,-.06986,-.0007488,-.008086,-.02199,.003103,.03044,-.01366,-.04301,.03653)*f3_4+\nmat4(-.004133,-.006646,.1104,-.006045,-.06954,-.02471,-.02497,-.01348,.05764,-.01805,-.04605,.01646,-.009245,-.04118,-.03138,.005692)*f3_5+\nmat4(.03271,.0003722,.01432,-.01267,.01408,.006345,-.01499,.00661,.02234,.01086,.01578,.005617,-.01241,-.01253,-.04908,.01585)*f3_6+\nmat4(-.04959,-.03978,.09898,.01475,.06305,-.03631,-.0128,-.02101,-.04952,.02518,.01608,-.006844,-.002438,-.0009535,-.08945,-.01348)*f3_7+\nmat4(.01607,.01257,.006297,.03017,.07655,-.0111,-.0541,-.0153,-.006583,-.05029,.05106,-.03546,.02031,-.02163,-.03696,-.002593)*f3_8+\nmat4(.01945,-.02259,.0314,-.03005,.03636,-.01488,-.008375,-.0008691,-.03022,-.01567,-.02652,-.03026,.05941,.01526,.05458,.00852)*f3_9+\nmat4(-.03996,-.03095,-.01252,.003951,-.03858,.03769,-.0452,-.03717,-.003887,-.0159,-.02325,.05019,.002041,.0142,-.04487,.005571)*f3_10+\nmat4(-.02605,.01862,-.6844,.0004946,-.001239,.05098,.03165,.02337,-.01314,-.02525,.01446,.02796,-.06459,-.007165,.1563,-.02077)*f3_11+\nmat4(-.01295,.04438,-.00348,.05515,.05462,-.003534,.02018,-.003506,-.06355,-.03812,-.02455,.01377,-.03411,.02968,-.06637,.0003205)*f3_12+\nmat4(-.01191,.008936,.07315,.003294,.008609,-.01072,.001208,-.005518,-.05016,.006275,.02571,-.03783,.04344,.006738,.03449,-.004474)*f3_13+\nmat4(.0267,-.008739,-.009041,-.01009,-.004737,-.04124,.04032,-.02611,.02057,-.0197,.01347,.00391,-.01455,-.01476,-.01234,.01102)*f3_14+\nmat4(.05402,-.03581,.01287,.01796,-.03823,-.002086,.1039,.02554,.0006233,-.0504,-.05717,-.04562,.05403,.007856,-.2067,-.005313)*f3_15+\nvec4(4.658,.003905,-5.321,3.133));vec4 f4_15=sin(mat4(-.09226,-.3715,2.556,.1008,-.169,.1852,.929,.08168,-.1086,.09115,.193,.01268,-.0901,.09428,-.5664,.009838)*f3_0+\nmat4(.05332,-.054,2.672,-.08304,-.1294,-.07288,-2.214,-.169,.06668,-.002318,.6996,.09937,.04606,-.03437,-3.466,-.01959)*f3_1+\nmat4(.05691,-.03637,-1.812,-.4075,.02993,-.06113,-1.499,-.09961,-.08785,.00629,-.3009,-.1071,.07298,.3976,1.07,.4028)*f3_2+\nmat4(.1019,-.01531,-.3928,.04524,.03843,-.0392,3.605,.02726,-.0899,.02945,-1.466,-.0537,-.08384,.1869,-3.273,.1721)*f3_3+\nmat4(.03659,.2149,-1.319,.4033,-.06728,.02832,-1.43,-.003697,.07341,-.09409,-4.342,-.06944,-.07742,-.4595,-3.204,-.2016)*f3_4+\nmat4(-.1896,.1635,-1.566,.02989,.04605,-.09836,-3.37,-.04567,.1038,-.04553,-3.087,-.03687,.07414,-.1019,-1.238,.01461)*f3_5+\nmat4(-.07756,.02273,-2.042,-.003385,.04041,.006981,.2438,.114,-.06785,.04746,.2582,.02403,.08111,-.0627,-.322,-.0152)*f3_6+\nmat4(-.04074,-.1102,-.9293,-.2356,.06381,-.04757,2.435,.03326,-.04265,.005126,-.1172,-.0639,.2898,-.1497,2.023,.002318)*f3_7+\nmat4(-.06172,-.00631,1.206,-.1048,.08933,-.02846,-2.797,-.007572,-.09979,-.002217,-5.534,-.004926,.0712,-.02312,5.444,-.008396)*f3_8+\nmat4(-.04979,-.03377,-3.548,-.1124,.04414,.05785,-.7324,.3091,.09105,.01602,.4039,.08768,-.06121,.141,.6165,.08569)*f3_9+\nmat4(.02597,-.09308,.6531,-.1476,.08516,-.07416,-.2225,-.1037,.0964,-.02702,1.097,.03049,.06033,-.03428,-1.516,.0002597)*f3_10+\nmat4(.1165,.1346,1.658,1.032,-.1095,.03207,-.1734,-.02239,-.0501,.04419,3.788,.00106,-.5418,.2026,-1.22,-.09768)*f3_11+\nmat4(.03495,-.006208,.3636,.006101,-.08618,.1006,1.035,.03611,.05131,.002264,-.6461,-.009265,.1688,-.0431,2.584,.1)*f3_12+\nmat4(-.1069,.008138,.9903,.04885,.09174,.08061,2.302,.2947,-.09242,-.105,-1.543,-.1967,-.06185,-.05537,2.521,-.00771)*f3_13+\nmat4(.07536,-.06542,.03975,-.05713,-.07909,.06409,-.2906,-.05198,-.08382,-.02031,-1.065,-.09864,.09293,-.02654,-.9472,.01038)*f3_14+\nmat4(-.07365,.03816,.7638,-.07289,-.1274,.1276,-.5323,-.05895,.1075,.0515,1.045,.1858,.003846,.1245,-1.772,.5305)*f3_15+\nvec4(.3539,3.033,3.885,1.619));float f_0=dot(f4_0,vec4(-.004477,.0234,.004441,.005176))+\ndot(f4_1,vec4(.003718,.00424,.006092,.01191))+\ndot(f4_2,vec4(-.3013,-.002883,-.007379,-.001747))+\ndot(f4_3,vec4(-.01702,.0005229,.002228,.011))+\ndot(f4_4,vec4(.01579,.004955,-.006172,-.01551))+\ndot(f4_5,vec4(-.01996,.05838,.0005587,-.01022))+\ndot(f4_6,vec4(-.00431,.002204,.002098,.001629))+\ndot(f4_7,vec4(-.005981,-.01236,-.4833,.08989))+\ndot(f4_8,vec4(.01064,-.003149,-.2348,-.006448))+\ndot(f4_9,vec4(.00928,-.4536,-.4871,-.01329))+\ndot(f4_10,vec4(-.004328,.2252,-4.604e-06,.002274))+\ndot(f4_11,vec4(-.5341,-.4454,.003705,-.00541))+\ndot(f4_12,vec4(-.007873,.003621,-.001249,.002997))+\ndot(f4_13,vec4(-.01464,.005952,.02432,-.001779))+\ndot(f4_14,vec4(.001264,-.003932,-.07091,.0007294))+\ndot(f4_15,vec4(-.07946,-.06042,-.0001624,.01941))+\n0.559;float f_1=dot(f4_0,vec4(.003064,-.02512,-.001927,.002377))+\ndot(f4_1,vec4(-.002957,-.009708,-.001528,-.007958))+\ndot(f4_2,vec4(-.04101,.002111,.008615,.006842))+\ndot(f4_3,vec4(.002982,.005199,.006667,-.00849))+\ndot(f4_4,vec4(-.01988,-.005316,.01135,.009356))+\ndot(f4_5,vec4(.02688,-.09064,.001896,.00877))+\ndot(f4_6,vec4(.005818,.0007324,.0005591,.005907))+\ndot(f4_7,vec4(.0008962,-.002662,.05319,-.08604))+\ndot(f4_8,vec4(-.005083,.001638,.01752,.002901))+\ndot(f4_9,vec4(-.002699,-.006423,-.07807,.006198))+\ndot(f4_10,vec4(.001682,.01068,.0005979,-.005395))+\ndot(f4_11,vec4(-.06259,-.004349,.002901,.007112))+\ndot(f4_12,vec4(.00283,-.005606,.0005118,.0006825))+\ndot(f4_13,vec4(.02857,-.007248,-.01427,.003058))+\ndot(f4_14,vec4(.0009199,.008178,-.006257,-.003111))+\ndot(f4_15,vec4(.1597,.04266,.0001892,-.01896))+\n-0.333;float f_2=dot(f4_0,vec4(-.001012,.01653,.00221,.003381))+\ndot(f4_1,vec4(.004096,-.0002568,-.006656,.01092))+\ndot(f4_2,vec4(.03667,-.00128,-.007747,-.001185))+\ndot(f4_3,vec4(.003332,-.006564,.0006442,.006004))+\ndot(f4_4,vec4(.01463,-.001147,-.00532,.006456))+\ndot(f4_5,vec4(-.02397,.08399,-.001454,-.006339))+\ndot(f4_6,vec4(-.00635,.0002009,.0002035,-.002612))+\ndot(f4_7,vec4(.00304,.007834,.1476,.07714))+\ndot(f4_8,vec4(.001324,-.002518,.03721,-.002909))+\ndot(f4_9,vec4(.003068,.09604,.04338,-.002977))+\ndot(f4_10,vec4(.0004287,-.04593,.0007897,.003951))+\ndot(f4_11,vec4(.07179,.09424,.008251,-.006852))+\ndot(f4_12,vec4(-.001396,.007335,.0002797,.005059))+\ndot(f4_13,vec4(-.03085,.00338,-.001996,-.005324))+\ndot(f4_14,vec4(-.002137,-.005443,.05237,.0002683))+\ndot(f4_15,vec4(-.167,-.01757,-.0001672,.01278))+\n-3.352;\n    return (\n        sin(\n        vec3(\n            f_0 + 4.4,\n            f_1,\n            f_2 + 4.4\n        ) \n        + 1.0) * 0.5\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y*2.5;\n    uv.y = 1.0 - uv.y - 1.0;\n    // Time varying pixel color\n    vec3 col =vec3(0.0);\n    \n    \n    col = getColor(vec3(mod(iMouse.x/iResolution.x + iTime * 0.1, 1.0), uv.yx));\n    col = pow(col, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 134080], [134082, 134082, 134139, 134189, 134522]], "test": "valid"}
{"id": "XllSWl", "name": "Printing numbers and coordinates", "author": "Piperoman", "description": "Based on: https://www.shadertoy.com/view/4sBSWW", "tags": ["mouse", "number", "print"], "likes": 4, "viewed": 82, "published": "Public", "date": "1616745737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vColour = vec3(0.0);\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;\n\t\n    \n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(8.0, 15.0);\n    \n    // Plot Mouse Pos\n\tfloat fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n    \n    // Print Shader Time\n\tvec2 vPixelCoord1 = vec2(96.0, 5.0);\n\tfloat fValue1 = iTime;\n\tfDigits = 6.0;\n\tfloat fIsDigit1 = PrintValue(fragCoord, vPixelCoord1, vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n\n\t// Print Date\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0, 5.0), vFontSize, iDate.x, 4.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0 + 48.0, 5.0), vFontSize, iDate.y + 1.0, 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0 + 72.0, 5.0), vFontSize, iDate.z, 2.0, 0.0));\n\n\t// Draw Time\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, vec2(184.0, 5.0), vFontSize, mod(iDate.w / (60.0 * 60.0), 12.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, vec2(184.0 + 24.0, 5.0), vFontSize, mod(iDate.w / 60.0, 60.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(fragCoord, vec2(184.0 + 48.0, 5.0), vFontSize, mod(iDate.w, 60.0), 2.0, 0.0));\n\t\n    if(iMouse.x > 0.0)\n\t{\n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-52.0, 6.0);\n\t\tfloat fValue2 = iMouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = 3.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = iMouse.y / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    fragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 190], [192, 192, 369, 369, 1423], [1425, 1425, 1482, 1482, 3605]], "test": "error"}
