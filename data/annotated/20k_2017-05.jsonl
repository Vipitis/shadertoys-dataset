{"id": "4d2cDt", "name": "4ANT", "author": "oportocala", "description": "hello", "tags": ["ant"], "likes": 1, "viewed": 116, "published": "Public", "date": "1494372552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 b = vec4(0., 0., 0., 1.);\nvec4 w = vec4(1., 1., 1., 1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    \n    vec2 c = vec2(0.5, 0.5);\n\t\n    float bandHeight = 0.5;\n    \n    vec2 samplePoint = vec2(st.x, .1);\n    float maxR = 200.0;\n    float v = texture(iChannel0, samplePoint).x;\n    float R = v * maxR;\n    \n    float r =  R;\n    float d = distance(fragCoord.xy, iResolution.xy / 2.0);\n    \n    \n    if (d + 1. < r){\n        fragColor = 1.0/w + mix(vec4(d/R, 0.6, 0.5, 1), vec4(0.5, d/R, 0.5, 1), 0.3);\n        return;\n    }\n    \n    if (d - 2. < r) {\n    \tfragColor = 1.0/w + mix(vec4(d/R, 0.6, 0.5, 1), vec4(0.5, d/R, 0.5, 1), 0.3);\n        fragColor.g = 0.5;\n        return;\n    }\n    \n    if (d - 3. < r) {\n    \tfragColor = 1.0/w + mix(vec4(d/R, 0.6, 0.5, 1), vec4(0.5, d/R, 0.5, 1), 0.3);\n        fragColor.r = 0.5;\n        return;\n    }\n    \n\tfragColor = w * vec4(st.y+0.2, st.x  + (sin(iTime)/2.0), v + (sin(iTime)), 0.2);\n}\n", "image_inputs": [{"id": "XdfSRH", "previewfilepath": "https://soundcloud.com/fergatron/antorange-tonight-fergatron-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/fergatron/antorange-tonight-fergatron-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2cDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 1042]], "test": "error"}
{"id": "4d2cWd", "name": "Splitting DNA", "author": "BigWIngs", "description": "DNA. See comments for details. Hope you like!", "tags": ["raymarching", "dna", "molecule"], "likes": 80, "viewed": 3955, "published": "Public", "date": "1495084406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Splitting DNA by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Its still a little slow. I tried a bunch of things to optimize:\n// Using raytracing, instead of marching:  works, is significantly faster but I couldn't get rid of artifacts. \n// Using bounding volumes: makes it a little bit faster, though not nearly as much as I had hoped.\n// Only calculating the color once in the end: should save a ton of mix-es, not noticably faster\n// Skipping to the next strand when marching away from current one: works, makes it a little faster\n// Mirroring the backbone: doesn't have any noticable effect\n//\n// Took me a loong time to figure out the atomic structure of the bases, its not easy to figure \n// out from 2d pictures, I might very well have made a mistake.\n//\n// Use the mouse to look around a little bit.\n//\n// Anyways, worked on this for too long already, gotta ship it. Hope you like!\n\n\n#define INVERTMOUSE -1.\n\n// comment out to see one basepair by itself\n#define STRANDS\n\n#define MAX_INT_STEPS 100\n\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 1000.\n#define RAY_PRECISION .1\n\n#define OPTIMIZED\n#define USE_BOUNDING_VOLUMES\n// set to -1 to see bounding spheres\n#define SHOW_BOUNDING_VOLUMES 1.  \n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nfloat smth = .6;\nfloat hr = 1.;\t\t\t\t\t// radii of atoms\nfloat nr = 2.264;\nfloat cr = 2.674;\nfloat or = 2.102;\nfloat pr = 3.453;\n\nvec3 hc = vec3(1.);\t\t\t\t// colors of atoms\nvec3 nc = vec3(.1, .1, 1.);\nvec3 cc = vec3(.1);\nvec3 oc = vec3(1., .1, .1);\nvec3 pc = vec3(1., .75, .3);\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 bg = vec3(.1, .5, 1.); // global background color\n\nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n    float m; \t// material\n    vec3 col;\n    \n    vec3 id;\n    float spread;\n    // shading parameters\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n    vec3 nor;\t\t// the world-space normal of the fragment\n    vec3 rd;\n    float fresnel;\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n    vec3 c;\t\t// the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\n\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return vec2(mix( b, a, h ) - k*h*(1.0-h), h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s)*.9; }\n\n\nvec3 background(vec3 r) {\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    return bg*(1.+y);\n}\n\nvec4 Adenine(vec3 p, float getColor) {\n   #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(29.52, 6.64, 3.04), 11.019);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n    \n    float h =  sdSphere(p, vec3(22.44, 13.63, 3.04), hr);\n    h = min(h, sdSphere(p, vec3(21.93, 0.28, 3.04), hr));\n    h = min(h, sdSphere(p, vec3(26.08, -1.19, 3.04), hr));\n    h = min(h, sdSphere(p, vec3(39.04, 3.98, 3.04), hr));\n    \n    float n =  sdSphere(p, vec3(23.18, 7.49, 3.04), nr);\n    n = min(n, sdSphere(p, vec3(28.39, 11.95, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(24.43, 0.75, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(32.79, 2.79, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(34.93, 8.83, 3.04), nr));\n    \n    float c =  sdSphere(p, vec3(24.50, 11.22, 3.04), cr);\n    c = min(c, sdSphere(p, vec3(25.75, 4.47, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(29.65, 5.2, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(30.97, 8.93, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(36.06, 5.03, 3.04), cr));\n    \n    \n        vec3 col = vec3(0.);\n        float d;\n\n        if(getColor!=0.) {\n            vec2 i = smin2(h, n, smth);\n            col = mix(nc, hc, i.y);        \n\n            i = smin2(i.x, c, smth);\n            col = mix(cc, col, i.y);\n\n            d = i.x;\n        } else\n            d = smin(c, smin(h, n, smth), smth);\n\n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\nvec4 Thymine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(12.96, 5.55, 3.04), 10.466);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n    float o =  sdSphere(p, vec3(18.171, -.019, 3.04), or);\n    o = min(o, sdSphere(p, vec3(15.369, 13.419, 3.04), or));\n    \n    float h =  sdSphere(p, vec3(19.253, 7.218, 3.04), hr);\n    h = min(h, sdSphere(p, vec3(12.54, -3.449, 4.534), hr));\n    h = min(h, sdSphere(p, vec3(7.625, -1.831, 4.533), hr));\n    h = min(h, sdSphere(p, vec3(10.083, -2.64, 0.052), hr));\n    \n    float n =  sdSphere(p, vec3(16.77, 6.7, 3.04), nr);\n    n = min(n, sdSphere(p, vec3(10.251, 8.846, 3.04), nr));\n    \n    float c =  sdSphere(p, vec3(10.541, -1.636, 3.04), cr);\n    c = min(c, sdSphere(p, vec3(11.652, 2.127, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(15.531, 2.936, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(9.012, 5.082, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(14.13, 9.655, 3.04), cr));\n    \n\n        vec3 col = vec3(0.);\n        float d;\n\n        if(getColor!=0.) {\n            vec2 i = smin2(h, n, smth);\n            col = mix(nc, hc, i.y);        \n\n            i = smin2(i.x, c, smth);\n            col = mix(cc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n\n            d = i.x;\n        } else\n            d = smin(o, smin(c, smin(h, n, smth), smth), smth);\n\n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\n\n\n\nvec4 Cytosine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(14.556, 5.484, 3.227), 10.060);\n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n        \n        float c = sdSphere(p, vec3(11.689, 1.946, 3.067), cr);\n        c = min(c, sdSphere(p, vec3(15.577, 2.755, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(14.176, 9.474, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(9.058, 4.9, 3.067), cr));\n\n        float n = sdSphere(p, vec3(18.412, 0.342, 3.067), nr);\n        n = min(n, sdSphere(p, vec3(16.816, 6.519, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(10.297, 8.665, 3.067), nr));\n\n        float h = sdSphere(p, vec3(6.526, 3.015, 3.067), hr);\n        h = min(h, sdSphere(p, vec3(10.61, -1.045, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(18.805, -2.297, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(20.95, 0.584, 3.067), hr));\n\n\n        float o = sdSphere(p, vec3(15.415, 13.237, 3.067), or);\n\n        vec3 col = vec3(1.);\n\n        float d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, n, smth);\n            col = mix(nc, cc, i.y);        \n\n            i = smin2(i.x, h, smth);\n            col = mix(hc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(o, smin(h, smin(c, n, smth), smth), smth);\n        \n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\nvec4 Guanine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(29.389, 8.944, 3.227), 12.067);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n        \n        float c = sdSphere(p, vec3(24.642, 11.602, 3.067), cr);\n        c = min(c, sdSphere(p, vec3(31.111, 9.311, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(29.79, 5.576, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(25.893, 4.854, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(36.19, 5.409, 3.067), cr));\n\n        float n = sdSphere(p, vec3(22.56, 14.31, 3.067), nr);\n        n = min(n, sdSphere(p, vec3(23.32, 7.867, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(28.538, 12.325, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(32.934, 3.164, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(35.07, 9.209, 3.067), nr));\n\n        float h = sdSphere(p, vec3(20.044, 14.723, 3.04), hr);\n        h = min(h, sdSphere(p, vec3(22.852, 16.965, 3.04), hr));\n        h = min(h, sdSphere(p, vec3(20.856, 7.404, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(39.187, 4.352, 3.067), hr));\n\n\n        float o = sdSphere(p, vec3(24.7, 1.893, 3.067), or);\n\n        vec3 col = vec3(1.);\n        \n        float d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, n, smth);\n            col = mix(nc, cc, i.y);        \n\n            i = smin2(i.x, h, smth);\n            col = mix(hc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(o, smin(h, smin(c, n, smth), smth), smth);\n        \n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\n\nvec4 Backbone(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(0., 7.03, 0.), 10.572);   \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif       \n        float c = sdSphere(p, vec3(1.391, 8.476, -0.708), cr);\n        c = min(c, sdSphere(p, vec3(5.173, 9.661, -0.708), cr));\n        c = min(c, sdSphere(p, vec3(6.342, 10.028, 3.061), cr));\n        c = min(c, sdSphere(p, vec3(0.222, 8.109, 3.061), cr));\n        c = min(c, sdSphere(p, vec3(0.658, 4.4, 4.8871), cr));\n\n        float h = sdSphere(p, vec3(-5.853, 0., 2.213), hr);\n        h = min(h, sdSphere(p, vec3(5.4512, 12.437, -2.216), hr));\n        h = min(h, sdSphere(p, vec3(6.986, 7.541, -2.216), hr));\n        h = min(h, sdSphere(p, vec3(-1.726, 10.517, 4.39), hr));\n        h = min(h, sdSphere(p, vec3(3.203, 2.519, 4.691), hr));\n        h = min(h, sdSphere(p, vec3(-1.619, 3.162, 3.063), hr));\n\n        float o = sdSphere(p, vec3(-4.918, 1.599, 0.344), or);\n        o = min(o, sdSphere(p, vec3(-1.471, 0.995, -5.1), or));\n        o = min(o, sdSphere(p, vec3(-0.836, 6.288, -1.438), or));\n        o = min(o, sdSphere(p, vec3(3.282, 9.068, 5.391), or));\n        o = min(o, sdSphere(p, vec3(-6.286, 5.299, -4.775), or));\n        \n        float ph = sdSphere(p, vec3(-3.377, 3.544, -2.742), pr);\n\t\t\n        #ifdef STRANDS\n        o = min(o, sdSphere(p, vec3(-6.286, 5.299, 6.558), or));\n        ph = min(ph, sdSphere(p, vec3(-3.377, 3.544, 8.592), pr)); // extra so it tiles better\n        #endif\n        \n        vec3 col = vec3(1.);\n\t\tfloat d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, h, smth);\n            col = mix(hc, cc, i.y);        \n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n\n            i = smin2(i.x, ph, smth);\n            col = mix(pc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(ph, smin(o, smin(c, h, smth), smth), smth);\n        \n        return vec4(col, d);\n  #ifdef USE_BOUNDING_VOLUMES      \n    }\n  #endif  \n}\n\n\n\n\nvec4 map( vec3 p, vec3 id, float spread, float getColor ) {\n    \n    p.z += 2.4;// offset so it tiles better\n    vec4 col;\n    \n    vec3 bp = p;    \n    bp.x = 22.5-bp.x;\n    float side = sign(bp.x);\n    bp.x = 22.5-abs(bp.x)+spread;\n    bp.z = bp.z*side - min(0., side)*5.;\n    vec4 b = Backbone(bp, getColor);\n    \n    vec4 c = vec4(1000.);\n    vec4 g = vec4(1000.);\n    vec3 cp = p;\n    vec3 gp = p;\n    \n    float n = N3(id);\n    \n    if(n<.5) {\n    \tcp.xz = -cp.xz + vec2(46., 6.);\n    \tgp.xz = -gp.xz + vec2(46., 6.);\n    }\n    cp.x += spread;\n    gp.x -= spread;\n    \n    if(mod(floor(n*4.), 2.)==0.) {\n    \tc = Cytosine(cp, getColor);\n    \tg = Guanine(gp, getColor);\n    } else {    \n    \tg = Adenine(gp, getColor);\n    \tc = Thymine(cp, getColor);\n    }\n  \n    col.a = min(b.a, min(c.a, g.a));\n  \n    if(getColor!=0.) {\n        if(col.a==b.a)\n            col.rgb = b.rgb;\t\n        else if(col.a==c.a)\n            col.rgb = c.rgb;\n        else\n            col.rgb = g.rgb;\n    }\n    \n    return col;\n}\n\n\nde castRay( ray r ) {\n    float t = iTime*.3;\n    \n    de o;\n    o.m = -1.0;\n    vec2 cbd = vec2(MIN_DISTANCE, MAX_DISTANCE);\n    vec2 bbd = cbd;\n    \n    vec4 col_pos;\n    \n    vec3 p = vec3(0.);\n    \n    float d = MIN_DISTANCE;\n    rc q;\n    vec3 center = vec3(19.12, 7.09, 3.09);\n    float spread;\n    \n    vec3 grid = vec3(180., 180., 11.331);\n    \n    #ifdef STRANDS\n    for( int i=0; i<MAX_INT_STEPS; i++ ) {\n        p = r.o+r.d*d;\n        float oz = p.z;\n        \n        q = Repeat(p, grid);\n        float sd = length((q.c.xy-center.xy));\n            \n        p.z += t*200.*S(800., 100., sd);\n        float n = N2(q.id.x, q.id.y);\n        \n        p.y += sin(n*twopi + p.z*.003+t)*50.*S(300., 500., sd);\n        \n        q = Repeat(p, grid);\n\t\t\n       \n        float z = oz*.05;\n        float z2 = smax(0., abs(oz*.03)-6., 2.);\n        float s = sin(z2);\n        float c = cos(z2);\n        \n        oz *= .012;\n        spread = max(0., 6.-oz*oz);\n        spread *= spread;\n        spread *= S(250., 1., length(q.id.xy*grid.xy+q.h.xy-r.o.xy));\n            \n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n        float dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n        \n       \n        \n        float dS = MAX_DISTANCE;\n        \n        #ifdef OPTIMIZED\n        vec2 bla = q.p.xy-center.xy;\n        if(dot(bla, r.d.xy)>0. && length(bla)>50.)\t// if we are stepping away from the strand and we are already far enough\n        \tdC = min(rC.x, rC.y)+1.;\t\t\t\t// then we won't hit this strand anymore and we can skip to the next one\n        else {\n            #endif \n             q.p-=center;\n        mat2 m = mat2(c, -s, s, c);\n        q.p.xy *= m;\n        q.p+=center;\n            \n        \tdC = rC.z +.01;\n            dS = map( q.p, q.id, spread, 0. ).a;\n        #ifdef OPTIMIZED\n        } \n        #endif\n        \n            \n        if( dS<RAY_PRECISION || d>MAX_DISTANCE ) break;      \n        \n        d+=min(dS, dC);\t// move to distance to next cell or surface, whichever is closest\n    }\n    \n    #else\n\tq.id = vec3(0.);\n    spread = 0.;\n     for( int i=0; i<MAX_INT_STEPS; i++ ) {\n        p = r.o+r.d*d;\n         \n        col_pos = map( p, vec3(0.), 0., 0. );\n        float dS = col_pos.a;\n        if( dS<RAY_PRECISION || d>MAX_DISTANCE ) break;      \n       \n        d+=dS;\n    }\n    #endif\n    \n    if(d<MAX_DISTANCE) { \n        o.m=1.;\n        o.d = d;\n        o.id = q.id;\n        o.spread = spread;\n        #ifdef STRANDS\n        o.pos = q.p;\n        #else\n        o.pos = p;\n        #endif\n        \n        o.d = d;\n    }\n    return o;\n}\n\nvec4 nmap( de o, vec3 offs ) {\n   \n    return map(o.pos+offs, o.id, o.spread, 0.);\n}\n\nde GetSurfaceProps( de o )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 p = o.pos-eps.yyx;\n    vec4 c = map(p, o.id, o.spread, 1.);\n    o.col = c.rgb;\n    \n    vec3 nor = vec3(\n\t    nmap(o, eps.xyy).a - nmap(o, -eps.xyy).a,\n\t    nmap(o, eps.yxy).a - nmap(o, -eps.yxy).a,\n\t    nmap(o, eps.yyx).a - c.a );\n\to.nor = normalize(nor);\n    \n    return o;\n}\n\nvec3 AtomMat(de o, vec3 rd) {\n    o = GetSurfaceProps( o );\n    \n    vec3 R = reflect(cam.ray.d, o.nor);\n    vec3 ref = background(R);\n    \n    float dif = dot(up, o.nor)*.5+.5;\n    dif = mix(.3, 1., dif);\n    \n\tvec3 col = o.col*dif;\n    \n    float t = iTime*50.+length(o.col)*10.;\n\n    float fresnel = 1.-sat(dot(o.nor, -rd));\n    fresnel = pow(fresnel, .5);\n          \n    \n    \n    #ifdef STRANDS\n    float up = dot(rd, vec3(0., 1., 0.));\n    col = mix(col, ref, fresnel*.5*S(.8, .0, up));\n    col *= S(.9, .2, up);\n    #else  \n    col = mix(col, ref, fresnel*.5);\n    #endif\n    \n    col = mix(col, bg, S(0., 1000., o.d));\n\n    return col;\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    // outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = castRay(camRay);\n   \n    if(o.m>0.) {\n        col = AtomMat(o, cam.ray.d);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tfloat t = iTime;\n    \n   if(m.x==0.&&m.y==0.) m = vec2(.5, .5);\n    \n    \n    #ifdef STRANDS\n    float camDist = -4.;\n    \n    t = t * .2;\n    \n    float y = t*.5;;\n    float x = t;\n    vec3 camPos = vec3(-60.+sin(t)*180., -80.+sin(y)*250., 0.);\n    \n    m -= .5;\n    vec3 pos = vec3(-(cos(x)+m.x)*3., -(cos(y)+m.y)*3., camDist);//*rotX;\n    #else\n    \n    float turn = (.1-m.x)*twopi+t*.0;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  0., s, 0., 1., 0., s,  0., -c);\n    \n    float camDist = -100.;\n    vec3 camPos = vec3(19., 0., 0.);\n    \n    vec3 pos = vec3(0., INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n    #endif\n    \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n   \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "Mlf3WB", "previewfilepath": "https://soundcloud.com/free-tracks-downloads/gus-gus-selfoss-deepfunks", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/free-tracks-downloads/gus-gus-selfoss-deepfunks", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2cWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2043, 2043, 2061, 2061, 2079], [2080, 2080, 2098, 2098, 2116], [2118, 2118, 2139, 2139, 2173], [2174, 2174, 2202, 2202, 2232], [2234, 2234, 2252, 2252, 2347], [2349, 2349, 2368, 2404, 2576], [3811, 3811, 3843, 3843, 4021], [4041, 4041, 4108, 4108, 4604], [4606, 4606, 4648, 4648, 4670], [4739, 4739, 4780, 4780, 4873], [4875, 4875, 4916, 4916, 5018], [5020, 5020, 5061, 5061, 5150], [5152, 5152, 5197, 5197, 5228], [5231, 5231, 5256, 5256, 5343], [13603, 13603, 13662, 13662, 14611], [17236, 17236, 17266, 17266, 17320], [17322, 17322, 17350, 17350, 17671], [17673, 17673, 17702, 17702, 18318], [18320, 18320, 18369, 18392, 18568], [18570, 18570, 18627, 18627, 19561]], "test": "ok"}
{"id": "4dByWc", "name": "mand 0.2 timeSamp", "author": "NNenov", "description": "learning glsl, test AA and MotionBlur, wip\nall thanks to https://www.shadertoy.com/user/lycium", "tags": ["mandelbrot"], "likes": 2, "viewed": 107, "published": "Public", "date": "1494005469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float scale = 1.25;\nconst float mscale = 3.0;\nconst float escape= 2.0;\nconst float bAmt = 0.1; // moblur amount\n\nint fSamples = 6;\n\nint fib(int f)\n{\n  int n0 = 1;\n  int n1 = 1;\n  int fi = 0;\n    \n  for (int i = 0; i < f - 2; i++) \n  {\n    fi = n0 + n1;\n    n0 = n1;\n    n1 = fi;\n  }\n    \n  return fi;\n}\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 rotate(vec2 v, float t)\n{\n    float tx = cos(t)*v.x-sin(t)*v.y;\n    float ty = sin(t)*v.x+cos(t)*v.y;\n    return vec2(tx,ty);\n}\n\nvec2 squared(vec2 a)\n{\n  \n    float sqrz_x = a.x * a.x - a.y * a.y;\n    float sqrz_y = 2.0 * a.x * a.y;\n    \n    return vec2(sqrz_x,sqrz_y);\n}\n\nvec2 mandel(vec2 Z, vec2 c)\n{\n    \n \tvec2 md = squared(Z);\n    \n    return (md+c);\n    \n}\n\n\nfloat pxFunc(vec2 px, float t)\n{\n    \n    vec2 st = -scale / 2.0 + ( px / iResolution.xy ) * scale;\n    \n    //vec4 m = mscale/2.0 -(iMouse / iResolution.xxxx)*mscale;\n\n    st += vec2(-0.8, 0.);\n\tst = rotate(st, t);\n    vec2 z = vec2(sin(t * 0.35)*sin(t * 0.85)*0.8, cos(t * 0.35)*cos(t * 0.75)*0.8);\n\t\n    z = rotate(z, t*0.1);\n    \n    int iters = 32;\n\tint k = 32;\n\n  \tfor(int j = 0; j < iters; j++)\n    {\n\n        z = mandel(z,st);\n        \n        if(z.x * z.x + z.y * z.y > escape) \n        {\n           k = j;\n           break;\n        }\n     }\n  \t\n    return 1.0-(float(k)/float(iters)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    int fN = fib(fSamples);\n\n    int fk = fib(fSamples-1);\n\t\n    \n    float sum = 0.0;\n    float colMap;\n    float timeMap;\n    \n    float r = rand(gl_FragCoord.xy / iResolution.xy); // not sure how to best generate a random number\n    \n    for (int i = 0; i < fN; i++) \n    {   \t\n        float fx = ( float(i) / float(fN) );\n \n        float fyf = float(fk) * ( float(i) / float(fN) );\n        \n        float fy = fyf-float(int(fyf)); //modulo\n        \n        \n        vec2 samp = vec2(fx, fy);\n        \n        timeMap = (float(i) + r) / float( fN );\n        \n        colMap = pxFunc( gl_FragCoord.xy + samp , iTime + timeMap*bAmt);\n    \n        sum += colMap;\t\n    }\n\n    float colNorm = sum / float(fN);\n    \n    vec3 color = vec3( colNorm-timeMap*0.01 , colNorm-timeMap*0.05 , colNorm-timeMap*0.08 );\n    \n\n    fragColor = vec4(color,1.0);\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dByWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 154, 154, 308], [310, 310, 332, 332, 400], [402, 402, 432, 432, 534], [536, 536, 558, 558, 678], [680, 680, 709, 709, 769]], "test": "ok"}
{"id": "4dfBDN", "name": "0x576861743f", "author": "slerpy", "description": "Those are some cubes, which are stuck inside each other while rotating independently from each other, with a glitched background and an interesting screen effect...\n\nYeah...", "tags": ["3d", "cube", "wtf"], "likes": 4, "viewed": 182, "published": "Public", "date": "1496158032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n\n#define FAR 32.\n#define ITER 128\n#define QUA .001\n\n#define NORK 5e-4\n#define SMNK 1.\n\n#define GRDW 2.\n#define CDIST 8.\n#define NCBS 3\n\n///// Utility\n\nfloat rand(vec2 co){\n    return cos(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat3 rx(float a){ float sa = sin(a), ca = cos(a); return mat3(1.,0.,0.,0.,ca,sa,0.,-sa,ca); }\nmat3 ry(float a){ float sa = sin(a), ca = cos(a); return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca); }\nmat3 rz(float a){ float sa = sin(a), ca = cos(a); return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.); }\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\n///// Map\n\nfloat randBox(vec3 p, float seed)\n{\n    vec3 axis = vec3(rand(vec2(seed,1.)),rand(vec2(seed,2.)),rand(vec2(seed,3.)));\n    float ctime = .5 * rand(vec2(seed,4.)) * iTime + rand(vec2(seed,5.));\n    p = abs(p*rx(axis.x*ctime)*ry(axis.y*ctime)*rz(axis.z*ctime));\n    return max(max(p.x,p.y),p.z) - 1.0;\n}\n\nfloat map(vec3 p)\n{\n    float d = FAR;\n    for (int i=0; i<NCBS; i++)\n    \td = smin(d, randBox(p, float(i)), SMNK);\n\treturn d;\n}\n\n///// Rendering\n\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p);\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tm - map(p - e.yxx),\n\t\tm - map(p - e.xyx),\n\t\tm - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t || t > FAR) break;\n        t += d;\n    } \n    return t;\n}\n\n///// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    bool alt = fract(fragCoord.y / GRDW) < .5;\n    if (alt) uv.x = -uv.x;\n    \n\tvec3 ro = vec3(vec2(0.), -CDIST);\n    vec3 rd = normalize(vec3(uv,2));\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n    \n\tvec3 sn = normal(sp,NORK);\n    vec3 ld = normalize(vec3(vec2(1.),-2.));\n\tfloat a = dot(sn,ld);\n    \n    vec3 col = vec3(1.);\n    col *= (1.+a)/2.;\n    col -= .5 * pow(t/FAR, 3.);\n    \n    if (t < FAR) col.r = alt ? 1.0 : 0.0;\n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 197, 197, 267], [269, 269, 286, 286, 362], [363, 363, 380, 380, 456], [457, 457, 474, 474, 550], [552, 552, 591, 591, 671], [684, 684, 719, 719, 985], [987, 987, 1006, 1006, 1115], [1134, 1134, 1164, 1164, 1304], [1306, 1306, 1338, 1338, 1512], [1526, 1526, 1583, 1583, 2118]], "test": "ok"}
{"id": "4dfBRN", "name": "quadratic", "author": "zardoru", "description": "procedural pattern out of sines, pows and colors", "tags": ["2d"], "likes": 0, "viewed": 77, "published": "Public", "date": "1494963596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415;\n    float tau = 2. * pi;\n    float xt = iTime * 0.25;\n\tvec2 uv = abs(fragCoord.xy / iResolution.xy - .5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float z = 1.5 - 1.5 * dot(uv, uv) + .1;\n    uv /= z;\n    \n    float fx =  .4 * (cos(tau * xt) * sin(tau * uv.x) + \n        sin(tau * (cos(tau * xt) * uv.x * uv.y) / 2.))\n        * (cos (pow(uv.y, 2.) * tau) + tan(tau * xt));\n    float f = 1. - step(0.5,  abs(uv.y * uv.x - fx));\n    float fv = 1. - step(0.5,  abs(pow(uv.y * uv.x, 2.) - fx));\n    float fw = 1. - step(0.2,  abs(uv.y - fx));\n    \n    \n\tfragColor = (f * vec4(0.3, 0.6, 0.8, 1.) +\n        \t    fv * fw * vec4(0.6, 0.5, 0.2, 1.)) * (1. - f) +\n        \t\t(1. - fv) * vec4(0.6, 0.1, 0.4, 1.) + \n        \t\t(1. - fw) * vec4(0.2, 0.1, 0.4, 1.) + \n        \t\t(f * fv * fw) * vec4(1., .3, 0.3, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 899]], "test": "ok"}
{"id": "4dfBWN", "name": "OJ - Ljusfärd, scene 5", "author": "rammoskar", "description": "Full demo: https://www.youtube.com/watch?v=-helx-SxnJo\nCurrently missing music and fxaa", "tags": ["3d", "reflection", "morph"], "likes": 15, "viewed": 743, "published": "Public API", "date": "1496152401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TIME mod(iTime, 31.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n#define LPOS vec3(0, 0, -2)\nvec4 laser(vec3 p) {\n\tfloat music = drum; \n\tvec3 lightCol = vec3(1.0 * ( 1.0 + sin(TIME))*0.5, 0.5, 0.5);\n\tfloat visible = smoothstep(9.2,9.3, TIME);\n\tfloat dis = sdCylinder(p.xzy,  0.1 * (1.5 * music + 0.5));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = (1.5 * music + 0.5) * lightCol * 100.0/(distanceToL*distanceToL);\n\n\treturn vec4(point * visible, distanceToL);\n}\n\nvec4 mirror(vec3 p) {\n\tfloat music = drum;\n\tfloat s = 15.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tfloat h = clamp( TIME - 2.0, 0.0, 10.0);\n\tvec3 lightCol = vec3(0.5, 0.5, 1.0);\n\tfloat dis = sdCappedCylinder(q.zxy - vec3(-1.0 - h, 0.0, 0.0), vec2(0.01, 2.0));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = (1.5 * music + 0.5) * lightCol * 40.0/(0.1*distanceToL + 0.3*distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 l = laser(pos);\n\tvec4 m = mirror(pos);\n\tdis = min(l.w, m.w);\n\treturn l.xyz + m.xyz;\n}\n\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\tvec3 lpos = LPOS;\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 70.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.01*dis*dis);\n\tfloat tmp = 0.0;\n\tcolor =  color * (0.2 + 0.8*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\nfloat smin( float a, float b)\n{\n\tfloat k = 2.0;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\n\n#define SIZE 8.0\n#define PI 3.1415\n\n#define MAT_SPIN 1.0\n#define MAT_GROUND 2.0\n#define MAT_PILLAR 3.0\n\nvec2 spin(vec3 p) {\n\tp.x = p.x == 0.0 ? 0.00001 : p.x;\n\tfloat angle = atan(p.y, p.x);\n\tfloat numParts = 12.0;\n\tfloat partSize = PI / numParts;\n\tangle += PI;\n\tangle = mod(angle + TIME * 0.2, partSize) + partSize * 0.5 * max(0.0, numParts - 1.0);\n\tfloat len = length(p.xy);\n\tfloat lenSize = 7.0;\n\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\tfloat lenPart = floor(len / lenSize);\n\tfloat s = 0.5;\n\tif(lenPart == 0.0){\n\t\ts = 0.1 + 0.7 * drum; \n\t}\n\tvec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\treturn vec2(sdCappedCylinder(newPos, vec2(s, 2.5)), MAT_SPIN);\n}\n\nvec2 gel(vec3 p) {\n\tfloat mt = 10.0;\n\tfloat t = TIME;\n\tfloat t1 = smoothstep(mt*0.0, mt*1.0, t);\n\tfloat t2 = smoothstep(mt*1.0, mt*2.0, t);\n\n\tfloat a = length(p - vec3(0.0, 0.0, -10.0 + t)) - 0.0 - t*t;\n\tfloat b = spin(p).x;\n\tfloat mdis = a*(1.0-t1) + b*t1*(1.0-t2) + t2*b;\n\treturn vec2(mdis, MAT_SPIN);\n}\n\nvec2 ground(vec3 p) {\n\tfloat s = 1.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tfloat d = udRoundBox(q, vec3(s * 0.3), s * 0.3);\n\treturn vec2(d, MAT_GROUND);\n}\n\nvec2  pillars(vec3 p) {\n\tfloat s = 15.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tfloat d = udRoundBox(q, vec3(2.0,0.2, clamp( TIME - 2.0, 0.0, 10.0)), 0.2);\n\treturn vec2(d, MAT_PILLAR);\n}\n\nvec2 map(vec3 p) {\n\tvec2 g = gel(p - vec3(0, 0, 0));\n\tvec2 solid = sun(pillars(p - vec3(0, 0, 0)), ground(p - vec3(0, 0, 2)));\n\tvec2 res = sun(g, solid);\n\treturn res;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz).x - map(p - ep.xyz).x;\n    normal.y = map(p + ep.yxz).x - map(p - ep.yxz).x;\n    normal.z = map(p + ep.yzx).x - map(p - ep.yzx).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal)\n{\n\tfloat o = 2.0*map(p + normal * 0.5).x;\n\treturn 0.2 + 0.8*o;\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 finalPos, vec3 eye) {\n\tfloat t = 0.0;\n\tconst int maxIter = 100;\n\tconst float maxDis = 200.0;\n\tfloat d = 0.0;\n\tvec3 p = vec3(-1.0, -1.0, -1.0);\n\tvec3 col = vec3(0);\n\tconst int jumps = 3;\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tfor (int j = 0; j < jumps; j++) {\n\t\tfor (int i = 0; i < maxIter; i++) {\n\t\t\tp = ro + rd * t;\n\n\t\t\t\tvec2 res = map(p);\n\t\t\t\td = res.x;\n\t\t\t\tfloat fogAmount = 0.0025;\n\t\t\t\tfloat lightDis = -1.0;\n\t\t\t\tvec3 light = evaluateLight(p, lightDis);\n\t\t\t\td = min(min(d, 1.0), max(lightDis, 0.05));\n\t\t\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\t\t\tscatteredLight += transmittance * lightIntegrated;\n\t\t\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\t\t\tt += d;\n\t\t\t\tfloat m = res.y;\n\t\t\t\tbool end = i == maxIter - 1 ||t > maxDis;\n\t\t\t\tif (d < 0.01 || end) {\n\t\t\t\tvec3 c = vec3(1);\n\t\t\t\tvec3 normal = getNormal(p);\n\t\t\t\tif (m == MAT_SPIN) {\n\t\t\t\t\tfloat angle = atan(p.y, p.x);\n\t\t\t\t\tfloat numParts = 12.0;\n\t\t\t\t\tfloat partSize = PI / numParts;\n\t\t\t\t\tangle += PI;\n\t\t\t\t\tfloat part = floor((angle + TIME * 0.2) / partSize);\n\t\t\t\t\tfloat len = length(p.xy);\n\t\t\t\t\tfloat lenSize = 7.0;\n\t\t\t\t\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\t\t\t\t\tfloat lenPart = floor(len / lenSize);\n\t\t\t\t\t part = part + lenPart * 10.0;\n\t\t\t\t\t vec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\t\t\t\t\tc = vec3(0.4 + 0.4 * sin(part), 0.4 + 0.4 * sin(part * 0.5 + 1.0), 0.4 + 0.4 * sin(part * 0.25 + 2.0));\n\t\t\t\t\tc*=3.0;\n\n\t\t\t\t} else if (m == MAT_GROUND) {\n\t\t\t\t\tc = vec3(0.5);\n\t\t\t\t} else if (m == MAT_PILLAR) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t}\n\t\t\t\tc *= occlusion(p, normal);\n\t\t\t\taddLightning(c, normal, eye, p);\n\t\t\t\tif (end) {\n\t\t\t\t\ttransmittance = 0.0;\n\t\t\t\t}\n\t\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\t\t\t\tif (m == MAT_PILLAR && p.z < -0.0 && p.z > -9.0) {\n\t\t\t\t\tref = 1.0;\n\t\t\t\t} else {\n\t\t\t\t\tref = 0.0;\n\t\t\t\t}\n\t\t\t\trd = reflect(rd, getNormal(p));\n\t\t\t\tro = p + rd*0.02;\n\t\t\t\tt = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t > maxDis) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ref < 0.1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinalPos = p;\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n    \n    float t = TIME;\n    vec3 eye = vec3(0.0, -20.0 - TIME*2.0 , -30.0 + TIME);\n\tvec3 tar = vec3(0, -15, 0); \n\tvec3 lol = vec3(0, 1, 0);\n\tif (t > 20.0) {\n\t\teye = vec3(3.0, 3.0 , 40.0 - (t + 4.0) * 2.3);\n\t\ttar = vec3(2, 0, 0); \n\t\tlol = vec3(0,0,-1);\n\t\teye.xy = vec2(3,3) + smoothstep(30.0,30.8, t) * (vec2(0) - vec2(3,3));\n\t} else if (t > 17.0) {\n\t\teye = vec3(5.0 - t, 3.0 + t , -20.0);\n\t\ttar = eye + vec3(0,0.1, 1); \n\t\tlol = vec3(0,0,-1);\n\t} else if (t > 8.0) {\n\t\teye = vec3(15.0 - t, 13.0 , -12.0);\n\t\ttar = vec3(2, 0, 0); \n\t\tlol = vec3(0,0,-1);\n\t}\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(lol, dir));\n\tvec3 up = cross(dir, right);\n\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, finalPos, eye);\n\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 105, 105, 134], [136, 136, 181, 181, 221], [223, 223, 265, 265, 364], [366, 366, 403, 403, 430], [432, 432, 496, 496, 621], [651, 651, 671, 671, 1026], [1028, 1028, 1049, 1049, 1469], [1471, 1471, 1518, 1518, 1610], [1613, 1613, 1683, 1683, 2046], [2048, 2048, 2079, 2079, 2188], [2190, 2190, 2232, 2232, 2325], [2326, 2326, 2352, 2352, 2483], [2485, 2485, 2521, 2521, 2680], [2788, 2788, 2807, 2807, 3363], [3365, 3365, 3383, 3383, 3670], [3672, 3672, 3693, 3693, 3833], [3835, 3835, 3858, 3858, 4026], [4028, 4028, 4046, 4046, 4196], [4198, 4198, 4222, 4222, 4463], [4465, 4465, 4503, 4503, 4566], [4568, 4568, 4632, 4632, 6649], [6651, 6651, 6706, 6706, 7840]], "test": "ok"}
{"id": "4dfBz8", "name": "4/100.", "author": "yahe", "description": "4/100", "tags": ["rotate"], "likes": 1, "viewed": 308, "published": "Public API", "date": "1494733672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    st = rotate2D(st,PI*0.25*iTime*3.0);\n\n    fragColor = vec4(sin(st.x)+0.6,0.96, sin(st.y)+0.6,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dfBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 213], [215, 215, 271, 271, 448]], "test": "ok"}
{"id": "4dffzN", "name": "7/100", "author": "yahe", "description": "7/100", "tags": ["noise", "wave"], "likes": 25, "viewed": 840, "published": "Public API", "date": "1494979668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // use josemorval paper sheet for reference\n    float dist,dist1,mask,l,final = 1.0;\n\t//This parameter controls how many sheets are in the picture\n    float s = 0.01;\n\t\n    float amp,freq;\n\tuv.y -=iResolution.y/iResolution.x;\n    \n    float value = fractalNoise2d(uv)*5.;\n    \n    //This parameter controls when the algorithm stop drawing sheets (-1 is no sheet, 1 all sheets)\n    float factorSheets = iResolution.y/iResolution.x;\n    \n    for(float f = -iResolution.y/iResolution.x; f < factorSheets; f+=s){\n        uv.y += s;\n        //This parameter controls the frequency of the waves, modulated by an exp along the x-axis \n        freq = 5.0*exp(-10.0*(f*f)) + value*sin(iTime);\n        //This parameter controls the amplitude of the waves, modulated by an exp along the x-axis \n        amp = 0.12*exp(-10.0*(f*f)) + value / 20. *cos(iTime);\n        dist = amp*pow(sin(freq*uv.x + iTime + 100.0),2.0)*exp(-5.0*uv.x*uv.x)-uv.y;\n        mask = 1.0-smoothstep(0.0,0.005,dist);\n\n        //Draw each line of the sheet\n        dist1 = abs(dist);\n        dist1 = smoothstep(0.0,0.01,dist1);\n\t\t\n        final = mix(dist1, -dist1*final,mask);\n\t}\n\n\tfragColor = vec4(final*2.,final,final*uv.y*3., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dffzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 144], [146, 225, 249, 249, 779], [781, 854, 885, 885, 1262], [1264, 1264, 1321, 1321, 2627]], "test": "ok"}
{"id": "4djyD3", "name": "Understanding Perlin Noise 1D", "author": "fscur", "description": "Understanding Perlin Noise 1D", "tags": ["perlin"], "likes": 10, "viewed": 657, "published": "Public API", "date": "1494114132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//http://flafla2.github.io/2014/08/09/perlinnoise.html\n//https://web.archive.org/web/20160530124230/http://freespace.virgin.net/hugo.elias/models/m_perlin.htm\n//http://eastfarthing.com/blog/2015-04-21-noise/\n//https://www.youtube.com/watch?v=Or19ilef4wE\n//https://www.youtube.com/watch?v=MJ3bvCkHJtE\n\n//https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE1 .1031\n#define HASHSCALE1 443.8975\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nfloat noise(float p)\n{\n\tfloat i = floor(p);\n    float f = fract(p);\n    \n    float t = f * f * (3.0 - 2.0 * f);\n    \n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\n\nfloat fbm(float x, float persistence, int octaves) \n{\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for(int i=0; i<octaves;++i)\n    {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return (total/maxValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    x += iTime * 0.1;\n    \n\tfloat y = (fbm(x, 0.5, 4) + 0.5) * iResolution.y;\n    \n    float contour = 1.0 - smoothstep(0.0, 2.0, abs(fragCoord.y - y));\n    \n    vec3 color = vec3(contour);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4djyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[397, 397, 420, 420, 538], [540, 540, 579, 579, 606], [608, 608, 630, 630, 790], [792, 792, 845, 845, 1175], [1177, 1177, 1234, 1234, 1519]], "test": "ok"}
{"id": "4djyWc", "name": "shipping", "author": "lennyjpg", "description": "sdfsdf", "tags": ["2dee"], "likes": 2, "viewed": 425, "published": "Public API", "date": "1494129256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.y, s = vec2(.0),c = vec2(.0);\n    vec3 pixel = vec3(1.2);\n    float t = iTime * 0.0037,d = 0.0,r = 0.0;\n\tfor(float i=0.0; i<37.0; i+=1.0) {\n       s = vec2(t + fract(sin(i*0.9)*37.0),t + fract(cos(i*2.5)*37.0));\n       c.x = fract(cos(i*42.9 + s.x)*2.551) * 4.0 - 1.0;\n       c.y = fract(sin(i*13.44 + s.y)*0.987) * 3.0 - 1.0;\n       r = fract(sin((i*0.6))*5.0) * 0.67;\n       d = length(uv - c);\n       pixel[int( mod(i,3.0))] -= smoothstep(d*0.05,d,r*r)*0.67;\n    }\n    fragColor = vec4(pixel.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4djyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 600]], "test": "ok"}
{"id": "4dlBDn", "name": "how many sides?", "author": "nshelton", "description": "glorious raymarching artifacts", "tags": ["tunnel", "raymarch", "kaleidoscope"], "likes": 17, "viewed": 11431, "published": "Public API", "date": "1495694433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat time = 0.1;\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat map(vec3 p)\n{\n\n    vec3 q = p;\n\n    vec3 c = vec3(0.2);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n\n    \n    vec3 p_s;\n    \n    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), sin(floor(q.z * 10.0) * 10.0) * 4.0 + 0.1 * (time));\n    \n    float bars = 1000.0;\n    int sides = 9; // not really sides\n    float angle = 3.1415 * 2.0 / float(sides) + sin(iTime/10.0)+ 1.0;\n    \n    for ( int i = 0; i < sides; i ++)\n    {\n        \n        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));\n        \n       \tp_s += vec3(\n            sin(30.0 * floor(q.z))* 0.5 + 1.0, \n            cos(iTime + sin(q.z* 9.0)), \n            0.0);\n        \n        vec3 boxdim = vec3(\n        \t0.05 + 0.05 * sin(q.z*5.0 + iTime* 2.0), \n            sin(q.z * 10.0) * 0.5  + 0.5, \n            0.01 + pow(sin(iTime), 0.5)\n        );\n     \t\n        \n        bars = min(bars, sdBox(p_s, boxdim));  \n    }\n\n        \n    \n    float result = bars;   \n    return result;\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = time;\n   // ro.x -= sin(iTime) 2.0;\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx) - map(p-e.yxx),\n\t\t\t\t\tmap(p+e.xyx) - map(p-e.xyx),\n\t\t\t\t\tmap(p+e.xxy) - map(p-e.xxy)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.5;\n    vec2 _p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 40; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n        float ratio = 0.2;\n\t\tdepth += d * ratio;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 40.0);\n\t\n    \n    \n    col = pow(col, vec3(\n        0.5,\n         0.1 + sin(iTime - p.z * 3.6)* 0.4 + 0.5,\n        0.1 + sin(iTime - p.z * 10.0)* 0.4 + 0.5));\n\n    \n    \n    fragColor = vec4(col, hit? length(p.xy) : 0.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 137], [139, 139, 172, 172, 198], [201, 201, 246, 246, 718], [720, 720, 739, 739, 1662], [1665, 1665, 1711, 1711, 1760], [1763, 1763, 1795, 1795, 1970], [1973, 1973, 2030, 2030, 2858]], "test": "ok"}
{"id": "4dlBWr", "name": "Boringo Sphere", "author": "saggn", "description": "Really a boring shape.", "tags": ["sphere", "circle", "float"], "likes": 0, "viewed": 65, "published": "Public", "date": "1495968653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfRes = iResolution.xy / 2.0;\n    vec2 updatedFragCoord = fragCoord + vec2(cos(iTime * 2.0) * 70.0, sin(iTime * 2.0) * 70.0);\n    float dist = distance(updatedFragCoord, halfRes);\n    vec2 final = (1.0 - (dist / halfRes));\n    fragColor = vec4(final.y, final.y, final.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlBWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 347]], "test": "ok"}
{"id": "4dlfR7", "name": "12/100", "author": "yahe", "description": "12/100", "tags": ["particle"], "likes": 16, "viewed": 1235, "published": "Public API", "date": "1495402718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_PARTICLES 200.0\n#define GLOW 0.5\n\nvec3 Orb(vec2 uv, vec3 color, float radius, float offset)\n{        \n    vec2 position = vec2(sin(offset * (iTime+30.)),\n                         cos(offset * (iTime+30.)));\n    \n    position *= sin((iTime ) - offset) * cos(offset);\n     \n    //offset = pModPolar(position,2.);\n    \n    radius = radius * offset;\n    float dist = radius / distance(uv, position);\n    return color * pow(dist, 1.0 / GLOW);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel = vec3(0.0, 0.0, 0.0);\n   \tvec3 color = vec3(0.0, 0.0, 0.0);\n    \n \tcolor.r = ((sin(((iTime)) * 0.55) + 1.5) * 0.4);\n    color.g = ((sin(((iTime)) * 0.34) + 2.0) * 0.4);\n    color.b = ((sin(((iTime)) * 0.31) + 4.5) * 0.3);\n    \n    float radius = 0.005;\n    \n    for\t(float i = 0.0; i < NUM_PARTICLES; i++)\n        pixel += Orb(uv, color, radius, i / NUM_PARTICLES);\n\n    \n    fragColor = mix(vec4(uv,0.8+0.5*sin(iTime),1.0), vec4(pixel, 1.0), 0.8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 105, 105, 451], [453, 453, 510, 510, 1056]], "test": "ok"}
{"id": "4dlfW4", "name": "Lava plasma", "author": "Lovax", "description": "Additive plasma with horizontal, vertical & radial gradient", "tags": ["procedural", "2d", "plasma"], "likes": 11, "viewed": 484, "published": "Public", "date": "1496216074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EXP 2.71828182846\n\nfloat w1 = 3.0;\nfloat w2 = 1.0;\nfloat w3 = 20.0;\nfloat A = 1.0;\nfloat R = 3.0;\n\nfloat horizontal(in vec2 xy, float t)\t{\n    float v = cos(w1*xy.x + A*t);\n\treturn v;\n}\n    \nfloat diagonal(in vec2 xy, float t)\t{\n    float v = cos(w2*(xy.x*cos(t) + 5.0*xy.y*sin(t)) + A*t);\n    return v;\n}\nfloat radial(in vec2 xy, float t)\t{\n    float x = 0.3*xy.x - 0.5 + cos(t);\n    float y = 0.3*xy.y - 0.5 + sin(t*0.5);\n    float v = sin(w3*sqrt(x*x+y*y+1.0)+A*t);\n    return v;\n}\n\nfloat map(float a,float b,float c,float d,float x) {\n    return ((x-a)*(d-c)/(b-a))+c;\n}\n\nfloat log_map(float a,float b,float c,float d,float x) {\n    float x1 = map(a,b,1.0,EXP,x);\n    return log(x1)*(d-c)+c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t{\n    float t = iTime;\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    float v = horizontal(xy,t);\n    v += diagonal(xy,t);\n    v += radial(xy,t);\n    v /= 3.0;\n    float r = map(-1.0,1.0,   0.75,1.0,sin(PI*v));\n    float g = map(-1.0,1.0,   0.0,0.8,sin(PI*v));\n    g += log_map(-1.0,1.0,   0.0,0.1,cos(PI*v));\n    float b = map(-1.0,1.0,   0.0,0.1,sin(PI*v));\n    fragColor = vec4(pow(r,R),pow(g,R),pow(b,R),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 171, 171, 218], [224, 224, 261, 261, 338], [339, 339, 374, 374, 517], [519, 519, 571, 571, 607], [609, 609, 665, 665, 730], [732, 732, 789, 789, 1202]], "test": "ok"}
{"id": "4dsBWn", "name": "cosmic tripping", "author": "kalin", "description": "cosmic trip", "tags": ["cosmictrip"], "likes": 1, "viewed": 86, "published": "Public", "date": "1495667702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 col(float r, float g, float b) { return vec3(r / 255.0, g / 255.0, b / 255.0); }\nvec3 col(int r, int g, int b) { return vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0); }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    float bpm = 95.1;\n    float t = iTime;\n\tfloat bt = t * 1.0 / 60.0 * 95.1;\n    float pi = 3.1415926535;\n    float st = sin(t);\n    \n    float r = sqrt(nuv.x * nuv.x + nuv.y * nuv.y);\n    float theta = atan(nuv.y, nuv.x);\n\n    vec3 col0 = col(161, 243, 114);\n    vec3 col1 = col(223, 153, 179);\n    vec3 col2 = col(116, 100, 206);\n    vec3 col3 = col(52, 118, 245);\n    vec3 col4 = col(231, 179, 141);\n    vec3 col5 = col(255, 255, 255);\n    \n    float w0 = abs(sin(theta * 1.0 + (bt + 0.0) * 1.0)) / pi;\n    float w1 = abs(sin(theta * 1.0 + (bt + 2.0) * 1.1)) / pi;\n    float w2 = abs(sin(theta * 2.0 + (bt + 4.0) * 1.2)) / pi;\n    float w3 = abs(sin(theta * 4.0 + (bt + 6.0) * 1.3)) / pi;\n    float w4 = abs(sin(theta * 4.0 + (bt + 8.0) * 1.4)) / pi;\n    float w5 = abs(sin(theta * 3.0 + bt));\n    \n    w5 = step(w5, 0.15);\n\n    fragColor.xyz = col0 * 0.2;\n    fragColor.xyz += col0 * w0;\n    fragColor.xyz += col1 * w1;\n    fragColor.xyz += col2 * w2;\n    fragColor.xyz += col3 * w3;\n    fragColor.xyz += col4 * w4;\n        \n    float fft = texture(iChannel0, vec2(0.25, 0.2)).x;\n    float beat = pow(fft, 3.5);\n    \n    float hue = theta / pi + fract(bt * 0.3) + 0.01 * beat;\n    float sat = 0.4 + 0.3 * beat;\n    float val = 1.0 + 0.5 * beat;\n\n    \n    fragColor.xyz = hsv2rgb(vec3(hue, sat, val));\n    fragColor.xyz = mix(fragColor.xyz, vec3(1,1,1), step(0.99 - 0.1 * beat, pow(sin(theta * 3.0 + bt), 4.0)));\n    \n    float wave0 = sin(bt);\n    float wave1 = sin(bt * 0.2);\n    \n    vec2 wavehead = vec2(sin(bt * 0.75) * 0.01, sin(bt * 0.25) * 0.03);\n    vec2 wavebody = vec2(sin(bt * 1.25 + 2.0) * 0.01, sin(bt * 1.25 + 2.0) * 0.05);\n    vec2 wavebody2 = vec2(sin(bt * 1.25 + 3.0) * 0.01, sin(bt * 1.25 + 3.0) * 0.05);\n\n    \n    float shead = 1.0 - step(0.2, pow(length(nuv * vec2(0.8, 0.9) + wavehead), 1.03));\n    float sbody = 1.0 - step(0.2, pow(length(nuv * vec2(1.1, 1.3) + wavebody), 1.35));\n    float sbody2 = 1.0 - step(0.2, pow(length(nuv * vec2(1.1, 1.3) + wavebody2), 1.6));\n    float smouth = 1.0 - step(0.1, length(nuv * vec2(0.8, 1.5) + vec2(0.0, +0.05) + wavehead));\n    float shandl = 1.0 - step(0.1, length(nuv * vec2(0.9, 1.0) + vec2(-0.4, 0.1) + wavebody));\n\tfloat shandr = 1.0 - step(0.1, length(nuv * vec2(0.9, 1.0) + vec2(+0.4, 0.1) + wavebody));\n    float seyel = 1.0 - step(0.03, length(nuv * vec2(1.0, 1.0) + vec2(-0.175, -0.02) + wavehead));\n\tfloat seyer = 1.0 - step(0.03, length(nuv * vec2(1.0, 1.0) + vec2(+0.175, -0.02) + wavehead));\n    float seye2l = 1.0 - step(0.03, length(nuv * vec2(1.0, 3.75) + vec2(-0.175, -0.09) + wavehead + wavebody));\n    float seye2r = 1.0 - step(0.03, length(nuv * vec2(1.0, 3.75) + vec2(+0.175, -0.09) + wavehead));\n    \n    vec3 swirl = fragColor.xyz;\n    \n    vec3 botwhite = col(240, 220, 200);\n    vec3 botwhiteface = col(255, 240, 220);\n    vec3 botorange = col(254, 122, 35);\n    vec3 botmouth = botwhite * 0.25 + botwhite * pow(texture(iChannel1, uv * 32.0 + sin(bt) * 0.5).x, 3.0);\n    vec3 boteye = col(32, 32, 32);\n    vec3 boteye2 = col(17, 234, 217);\n\n    fragColor.xyz = mix(fragColor.xyz, botwhite, sbody2);\n    fragColor.xyz = mix(fragColor.xyz, botorange, sbody);\n    fragColor.xyz = mix(fragColor.xyz, botwhiteface, shead);\n\tfragColor.xyz = mix(fragColor.xyz, botmouth, smouth);\n    fragColor.xyz = mix(fragColor.xyz, botorange, shandl);\n\tfragColor.xyz = mix(fragColor.xyz, botorange, shandr);\n\tfragColor.xyz = mix(fragColor.xyz, boteye, seyel);\n\tfragColor.xyz = mix(fragColor.xyz, boteye, seyer);\n\tfragColor.xyz = mix(fragColor.xyz, boteye2, seye2l);\n\tfragColor.xyz = mix(fragColor.xyz, boteye2, seye2r);\n\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "MssXz7", "previewfilepath": "https://soundcloud.com/emeenz/psychout-67", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/emeenz/psychout-67", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 85], [86, 86, 117, 117, 186], [188, 188, 210, 210, 379], [381, 381, 438, 438, 4108]], "test": "error"}
{"id": "4dsBz4", "name": "Hex Voxel Scene", "author": "Shane", "description": "Testing out Mattz's hexagonal prismatic voxel traversal formula.", "tags": ["voxel", "hexagon"], "likes": 64, "viewed": 3817, "published": "Public API", "date": "1496244714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    hex voxels, by mattz\n    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    Idea: raytrace through stacked hexagonal boxes, based on Shane's comment\n    in hexwaves - https://www.shadertoy.com/view/XsBczc\n\n\tHex Voxel Scene\n\t---------------\n\n\tTesting out Mattz's hexagonal prismatic voxel traversal formula on a basic scene.\n\n\tI've always been curious as to what a simple scene would look like using a non-standard\n\tvoxel traversal, especially the hexagonal box one, but have never got around to putting\n\tit into effect. Thankfully, Mattz is a more efficient coder than myself and wrote a \n\thexagonal prismatic voxel traversal (thanks for the technical term, IQ) not too long ago. \n\tOn a side note, he wrote it in what seemed to be a couple of hours, at most. It takes me  \n    that long just to choose a texture. :)\n\n\tThere are numerous standard cubic voxel examples around, but not too many featuring other \n\tkinds. Mattz's \"hex voxel\" example is the first hexagonal box voxel traversal I've seen \n\tin shader form.\n\n\tAnyway, most of this is Mattz's work. I simply plugged a different scene in, rearranged \n\tthings in a hurry, and changed a few settings here and there, so if the code looks patched \n\ttogether, that's because it is. :)\n\n    Hopefully, it'll work well enough, but it needs a tidy up. In addition, I put it together \n\ton a pretty fast machine, so am not yet aware of the frame rate on slower machines. Having\n\tsaid that, I tried to choose a simplistic scene with cheap operations, so hopefully, there \n\twon't be too many issues.\n\n\t\n\tBased On:\n\t\n\t// The original this is based on. Much neater code. :)\n\thex voxels - mattz\n\thttps://www.shadertoy.com/view/ldBcDd\n\n\t// Cool 2D hexagon traversal.\n\thexwaves - mattz\n\thttps://www.shadertoy.com/view/XsBczc\n\n*/\n\n\n#define FAR 100. // Maximum ray distance. Analogous to the far plane.\n\n// Fabrice's succinct, 2D rotation formula. Apparently slower than the standard one, but\n// only used for its compactness here.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\nfloat objID, svObjID; // Object ID \n\n\n// square root of 3 over 2\nconst float hex_factor = 0.8660254037844386;\n\n// ratio of cell height to hex radius\nconst float cell_height = 1.75;\n\n// relationship between integer grid cells & sizes\nconst vec3 cell_size = vec3(hex_factor, 1.0, cell_height);\n\n// ambient occlusion falloff - smaller is darker\nconst float ao_falloff = 3.5;\n\n// ambient occlusion strength - bigger is darker\nconst float ao_strength = 0.65;\n\n// higher resolution discretizes more finely but needs more grid steps to render\nconst float resolution = 1.5;\n\n// number of steps to take to render\nconst int grid_steps = 160;\n\n// light direction\n//vec3 light_dir;\nvec3 lp;\n\n\n#define HEX_FROM_CART(p) vec2(p.x / hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n\n//////////////////////////////////////////////////////////////////////\n// Used to draw top borders\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Given a 2D position, find integer coordinates of center of nearest\n// hexagon in plane.\n\nvec2 nearestHexCell(in vec2 pos) {\n    \n    // integer coords in hex center grid -- will need to be adjusted\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    // adjust integer coords\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    // difference vector\n    vec2 gdiff = gpos - hex_int;\n\n    // figure out which side of line we are on and modify\n    // hex center if necessary\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Flip normal if necessary to have positive dot product with d\n\nvec2 alignNormal(vec2 h, vec2 d) {\n    return h * sign(dot(h, CART_FROM_HEX(d)));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Intersect a ray with a hexagon wall with normal n\n\nvec3 rayHexIntersect(in vec2 ro, in vec2 rd, in vec2 h) {\n    \n    //return vec3(0); \n\n    vec2 n = CART_FROM_HEX(h);\n\n    // solve for u such that dot(n, ro+u*rd) = 1.0\n    float u = (1.0 - dot(n, ro)) / dot(n, rd);\n    \n    // return the \n    return vec3(h, u);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Choose the vector whose z coordinate is minimal\n\nvec3 rayMin(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Straight path.\n    return vec2(sin(z*.085)*8., cos(z*.085)*6.); // Windy path.\n    \n}\n\n\n\n\n// The terrain setup up.\nfloat map(vec3 p){\n     \n    // The original uses a different coordinate system, so this is a quick hack\n    // to enable me to drop in a \"Z into the page\" coordinate system.\n    p = p.yzx; \n    \n    // A gyroid-like perturbation to add to a plane. I'm doing it prior to the\n    // wrapping the objects around the path, but there's no rule saying you can't\n    // wrap this as well.\n    float trSf = dot(sin(p*3.14159/16. - cos(p.yzx*3.14159/12.)), vec3(8));\n \n    p.xy -= path(p.z); // Wrap the object (to follow) around the path.\n\n   \n    // Add the perturbation to the plane, then carve out a tunnel. I named the resultant object\n    // \"surr\" for surroundings - I was in a hurry. :)\n    float surr = smax(4. - length(p.xy*vec2(1, .75)), p.y - 4. + (.5 - trSf), 2.);\n    float rail = max(abs(abs(p.x) - 4.) - 1., p.y + 2.); // Some rails for the path below.\n    \n    // Attaching the rails to the surroundings - instead of the path - for color reasons.\n    surr = min(surr, rail); \n    \n    // A windy path - Everything above a certain height is omitted.\n    float path = max(abs(p.x) - 3.5, p.y + 4.); \n\n    objID = step(surr, path); // Object ID - Surrounding or path floor.\n\n    return min(surr, path); // Return the minimum hit point.\n \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n     \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Just for coloring the sky\n\nvec3 sky(vec3 ro, vec3 rd) {\n    \n    float s = 0.5*dot(normalize(lp - ro), rd) + 0.5;\n    return mix(vec3(1, .8, .7), vec3(.75, .92, 1), s)*vec3(1.35, 1.2, 1);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Surface shading function. hit_nt holds normal and ray distance,\n// bdist holds distance to voxel edge, ndist holds distance to \n// neighbors (useful for AO).\n\nvec3 shade(vec3 ro, vec3 rd, vec4 hit_nt, float bdist, float ndist, float diffuse) {\n    \n    // Surface point.\n    vec3 p = ro + rd*hit_nt.w;\n    \n    // get the normal\n    vec3 n = hit_nt.xyz;\n    \n    // Light direction vector.\n    vec3 ld = normalize(lp - p);\n    \n\n    // gotta deal with borders\n\n    // need to antialias more far away\n    float border_scale = 3.0/iResolution.y;\n    float border_size = 0.01;\n    float border = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n    \n    border_scale = 4.0/iResolution.y;\n    border_size = 0.01*3.;\n    float border2 = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n\n\n\n    // diffuse + ambient term\n    diffuse = min(diffuse, clamp(dot(ld, n), 0.0, 1.0));\n    float spec = pow(max( dot( reflect(-ld, n), -rd ), 0.0 ), 32.0);\n    \n    //float atten = 3./(1. + hit_nt.w*.1);\n    \n    //float fres = clamp(1. + dot(rd, n), 0., 1.);\n    \n    float ao = 1.0 - ao_strength*exp(-ao_falloff*ndist); // Ambient occlusion.\n\n    // Surface color.\n    vec3 color = (tex3D(iChannel0, p/4., n)*.66+tex3D(iChannel0, p/2., n)*.34);\n    color *= vec3(1, .8, .6)*1.5;\n    \n    float gr = dot(color, vec3(.299, .587, .114));\n   \n    // Color the path and the surrounds slightly different colors.\n    if(svObjID == 0.) { // Path.\n        color = mix(color*vec3(1, 1.5, 1), vec3(1)*gr, .35)*1.5;//*vec3(1, .7, .4); // Terrain.\n        color *= vec3(1.5, 1.25, 1); \n        //color = color.xxx;\n    }\n    else { // Surrounds.\n         \n        color = mix(color*vec3(1, 1.5, 1), vec3(1)*gr, .5);\n        color *= vec3(1.5, 1.25, 1); \n        //color = color.xxx;\n    }\n  \n    // Fake reflection. Doesn't really work well here.    \n    //vec3 ref = tex3D(iChannel1, (p + reflect(rd, n)*2.)/64., n).xyz;//*vec3(.5, .7, 1)*.2;\n    //color += ref*.25;      \n    \n    // add in border color\n    color = mix((color*2.5 + gr*.75), color, border2);\n    color *= border*.97 + .03;\n \n    \n    // multiply by diffuse/ambient\n    color = color*(diffuse + 0.25*ao + vec3(.5, .7, 1)*spec*2.);// + color*fres*fres*ao*.125;\n\n\n    // consider AO\n    color *= ao;\n    \n\n\treturn color;\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Compute min distance between point on vertical side of a hexagon \n// and corners of occupied cells. This checks just the four cells \n// needed.\n\nfloat vertEdgeDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n \n    // Get difference on integer hex grid\n    vec3 cell_diff = prev_cell - hit_cell;\n    \n    // Normal direction across cell boundary\n    vec2 n = CART_FROM_HEX(cell_diff.xy);\n    \n    // Perpendicular vector, scaled to correct length to check corners\n    vec2 np = vec2(-n.y, n.x) * 0.5 / hex_factor;\n        \n    // Coordinates of cell center\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // We only care about difference from center when measuring distances\n    p -= cell_pos;\n    \n    // These are \"rotation\" matrices that rotate directions on the\n    // integer hex grid.  \n    const mat2 M0 = mat2(0.5, 0.75, -1.0, 0.5);\n    const mat2 M1 = mat2(0.5, -0.75, 1.0, 0.5);\n    \n    // Get directions to left and right neighbors, along with sign\n    // for perpendicular to normal\n    vec3 h[2];\n    h[0] = vec3(M0 * cell_diff.xy, 1.0);\n    h[1] = vec3(M1 * cell_diff.xy, -1.0);\n    \n    // Initialize distance to large value\n    float rval = 1e5;\n    \n    // For each neighbor direction\n    for (int i=0; i<2; ++i) {\n        \n        // Check below and above on grid\n        for (float d=-1.0; d<=1.0; d+=2.0) {\n            \n            // Get the neighbor cell\n            vec3 neighbor_cell = hit_cell + vec3(h[i].xy, d);\n            vec3 neighbor_pos = neighbor_cell * cell_size;\n            \n            // If it's occupied\n            if (map(neighbor_pos/resolution) < 0.0) {\n                \n                // Get corner with this neighbor                  \n                vec3 corner = 0.5*(vec3(np*h[i].z, cell_height*d) - cell_diff*cell_size);\n                \n                // Check distance to corner\n                rval = min(rval, length(p - corner));\n                \n            }\n        }\n    }\n    \n    return rval;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Get minimum distance to all eight connected neighbors across a \n// face, except for the occupied one (which would have\n// distance of zero).\n\nfloat neighborDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n            \n    // Get cell center position\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // Only care about distances relative to center\n    p -= cell_pos;\n    \n    // Cancel out some multiplication that will happen down below\n    p.z *= 2.0/cell_height;\n    \n    // Set up four neighbors and distances to walls\n    vec4 h[4];\n    \n    h[0] = vec4(0.0,  1.0, 0.0, 1.0);\n    h[1] = vec4(1.0,  0.5, 0.0, 1.0);\n    h[2] = vec4(1.0, -0.5, 0.0, 1.0);\n    h[3] = vec4(0.0,  0.0, 0.5, 0.5*cell_height);\n    \n    // Initialize return value to large number\n    float rval = 1e5;\n   \n    // For each neighbor direction...\n    for (int i=0; i<4; ++i) {\n        \n        // ...and its opposite direction\n        for (float s=-1.0; s<=1.0; s+=2.0) {\n            \n            // Get the neighbor integer grid coords\n            vec3 neighbor_cell = prev_cell + 2.0*s*h[i].xyz;\n            \n            // Ignore the one we already know is occupied\n            if (neighbor_cell != hit_cell) {\n                \n                // Get neighbor center position\n                vec3 neighbor_pos = neighbor_cell * cell_size;\n                \n                // If occupied...\n                if (map(neighbor_pos/resolution) < 0.0) {\n                \n                    // Get normal\n                    vec3 n = s * h[i].xyz * cell_size;\n                    \n                    // Update using distance to neighbor along normal\n                    rval = min(rval, h[i].w - dot(n, p));\n                \n                }   \n            }\n        }\n    }\n    \n    // Return minimum distance\n    return rval;\n    \n}\n\n \n\n//////////////////////////////////////////////////////////////////////\n// Return the normal and intersection distance for ray with origin\n// ro and direction rd.\n\nvoid raytrace(in vec3 ro, in vec3 rd,\n              out vec4 hit_nt, \n              out vec3 prev_cell,\n              out vec3 cur_cell) {\n    \n \n    \n    // find nearest hex cell center to ray origin    \n    cur_cell = vec3(nearestHexCell(ro.xy), floor(ro.z/cell_height + 0.5));\n    \n    // we also will care about the cell we entered in from\n    prev_cell = cur_cell;\n    \n    // current cell center\n    vec3 cur_center = cur_cell * cell_size;\n\n    // see if ray is pointed up or down\n    float dz = rd.z < 0.0 ? -1.0 : 1.0;\n\n    // get the three candidate wall directions for this ray (i.e. the\n    // three hex side directions that correspond to normals with positive\n    // dot products to ray direction)\n    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);\n    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);\n    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);\n\n\t// have we hit a hex yet?    \n    bool hit = false;\n    \n    // initialize normal to zero and intersection distance to negative\n    hit_nt = vec4(0, 0, 0, -1.0);    \n\n    // march along ray, one iteration per cell\n    for (int i=0; i<grid_steps; ++i) {\n        \n        // once we hit we're good\n        if (hit) { continue; }\n        \n        // distance from ray origin to current cell center\n        vec3 rdelta = ro-cur_center;\n        \n        // first, test intersections with sides:\n        // after three tests, ht.xy holds the direction, ht.z holds the\n        // ray distance parameter with intersecting sides\n        vec3 ht = rayHexIntersect(rdelta.xy, rd.xy, h0);\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h1));\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h2));\n        \n        // next, test intersection with top/bottom \n        float tz = (0.5*dz*cell_height - rdelta.z) / rd.z;\n        \n        // now we will need to figure out how to update the current cell\n        // either horizontally or vertically.\n        \n        // stash the previous cell\n        prev_cell = cur_cell;        \n\n        // variable to hold return value if we do hit\n        vec4 new_nt;\n \n        // check whether we hit top/bottom before side\n        if (tz < ht.z) {\n            \n            // hit top/bottom first, so march vertically\n            cur_cell.z += dz;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(0, 0, -dz, tz);\n            \n        } else {\n            \n            // hit side first, so march horizontally\n            cur_cell.xy += 2.0*ht.xy;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(-CART_FROM_HEX(ht.xy), 0, ht.z);\n            \n        }\n        \n        // we updated the current cell, now update the cell center position\n        cur_center = cur_cell * cell_size;\n            \n        // see if the new cell center is occupied\n        if (map(cur_center/resolution) < 0.0) {\n            hit = true;\n            hit_nt = new_nt;\n        }\n        \n        \n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Return the color for a ray with origin ro and direction rd\n\nvec3 ray_shade(in vec3 ro, in vec3 rd) {\n    \n    // handle resolution scaling\n    ro *= resolution;\n\n    // hit_nt will hold normal and distance\n    vec4 hit_nt;\n    \n    // prev_cell and hit_cell store cell before and after intersection\n    vec3 prev_cell, hit_cell;\n    \n    // do raytrace\n    raytrace(ro, rd, hit_nt, prev_cell, hit_cell);\n    \n    svObjID = objID;\n    \n    // output color\n    vec3 color = vec3(0);\n    \n    //vec3 light_dir = normalize(lp - ro);\n    vec3 sk = sky(ro, rd);\n    color = sk;\n    \n    // if ray hit\n    if (hit_nt.w >= 0.0) {\n        \n        // get the cell center where it hit\n        vec3 cell_center = hit_cell * cell_size;\n        \n        // get the intersection point\n        vec3 pintersect = ro + rd * hit_nt.w;\n        \n        // store distance to border, to neighbor cell\n        float bdist, ndist;\n        \n        // see if we hit top/bottom or side\n        if (abs(hit_nt.z) > 0.0) {\n            \n            // was top/bottom\n            bdist = hexDist(pintersect.xy - cell_center.xy);\n            ndist = neighborDist(prev_cell, hit_cell, pintersect); \n            \n        } else {\n            \n            // was side\n            vec2 n = hit_nt.xy;\n            bdist = abs(fract(pintersect.z/cell_height)-0.5)*cell_height;\n                    \n            vec2 p = pintersect.xy - cell_center.xy;\n            p -= n * dot(p, n);\n            bdist = min(bdist, abs(length(p) - 0.5/hex_factor));\n            \n            ndist = neighborDist(prev_cell, hit_cell, pintersect);\n            ndist = min(ndist, vertEdgeDist(prev_cell, hit_cell, pintersect));\n\n        }\n        \n        // default case: assume shadow - note for \"realism\" we would set 0.0 here\n        float diffuse = 0.05;\n        \n        // A distant point light, so it's almost directional, but it still has a\n        // slight point light feel... if that makes any sense. :)\n        vec3 light_dir = normalize(lp - pintersect);\n        \n        // see if on lit side\n        if (dot(hit_nt.xyz, light_dir) > 0.0) {\n            \n            // shadow ray\n            vec4 shadow_nt;\n            raytrace(pintersect + 0.001*hit_nt.xyz, light_dir, \n                     shadow_nt, prev_cell, hit_cell);\n            \n            // full light if shadow ray missed\n            if (shadow_nt.w < 0.0) { diffuse = 1.0; }\n\n            \n        }\n        \n        // shade the hit point\n        color = shade(ro, rd, hit_nt, bdist, ndist, diffuse);\n\n        \n    } \n    \n    color = mix(color, sk, smoothstep(0., .95, hit_nt.w*.6/100.));\n    \n\treturn color;\n\t\n}\t\n \n\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\t\n\tconst float yscl = 800.0;\n\tconst float f = 450.0;\n\t\n    vec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 uv = uvn*yscl;\n    \n    \n    vec3 rd = normalize(vec3(uv, f));\n    rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.15)); // Subtle lens distortion.\n\t\n\tvec3 ro = vec3(0, 0, iTime*5.);\n\tvec3 tgt = ro + vec3(0, 0, .25);\n\tvec3 up = vec3(0, 0, 1);\n    \n    \n    \n    lp = ro + vec3(FAR*.24, FAR*.52, FAR*.78);\n    \n\n\n    vec2 sw = path(tgt.z);\n    \n    ro.xy += path(ro.z);\n\ttgt.xy += sw;\n     \n    // The original uses a different coordinate system, so this is a quick hack\n    // to enable me to drop in a \"Z into the page\" coordinate system.\n    ro = ro.zxy;\n    tgt = tgt.zxy;\n    lp = lp.zxy;    \n\t\n\tvec3 rz = normalize(tgt - ro);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n    \n    mat3 R = mat3(rx,ry,rz);\n     \n\n    \n\tfloat thetax = sw.y/32.;\n\tfloat thetay = 0.; // sw.x/64.\n\n/*  \n    // Mouse camera direction overide.\n\tif (iMouse.y > 10.0 || iMouse.x > 10.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * -1.25/iResolution.y;\n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * 6.28/iResolution.x; \n\t}\n*/ \n    \n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(cx, 0, -sx, 0, 1, 0, sx, 0, cx);\n    mat3 Ry = mat3(cy, -sy, 0, sy, cy, 0, 0, 0, 1);\n\t\n    ro = Ry*Rx*(ro-tgt) + tgt;\n    rd = Ry*Rx*R*rd;\n\n    rd.yz *= r2(-sw.x/64.);\n\n    \n    vec3 color = ray_shade(ro, rd);\n    \n    // Some post processing. Wasn't used.\n    //color = mix(color, color.xxx, .8);\n    //color = mix(color.xxx, pow(color.xxx, vec3(1, 2, 3)), .35);\n    \n   \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    color *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    \n\tcolor = sqrt(color);\n\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsBz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1887, 2015, 2033, 2033, 2101], [2990, 2990, 3013, 3013, 3089], [3254, 3254, 3288, 3362, 3896], [4034, 4034, 4068, 4068, 4117], [4244, 4244, 4301, 4329, 4510], [4635, 4635, 4664, 4664, 4696], [4699, 4748, 4786, 4786, 4881], [4883, 4916, 4955, 4955, 5051], [5053, 5153, 5175, 5217, 5288], [5293, 5318, 5336, 5492, 6563], [6566, 6632, 6680, 6680, 7184], [7287, 7287, 7315, 7315, 7449], [7685, 7685, 7769, 7796, 9822], [10045, 10045, 10104, 10148, 11858], [12076, 12076, 12135, 12180, 13742], [13910, 13910, 14048, 14114, 16905], [17041, 17041, 17081, 17119, 19617], [19695, 19695, 19752, 19752, 21609]], "test": "error"}
{"id": "4dScDt", "name": "Noise Thing", "author": "DonKarlssonSan", "description": "I just added some noise to my very simple Circle Thing: https://www.shadertoy.com/view/XdScDt", "tags": ["noise", "simplex"], "likes": 1, "viewed": 76, "published": "Public", "date": "1494267476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex 2D noise\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = cos(iTime);\n    float y = sin(iTime);\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x += x;\n    p.y += y;\n    float n = snoise(p + iTime);\n\tfloat radius = sqrt(p.x * p.x + p.y * p.y) + n; \n\tfragColor = vec4(radius*0.5, 0.3*radius, 1.0-radius, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dScDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 111, 111, 150], [152, 152, 173, 173, 993], [997, 997, 1054, 1054, 1336]], "test": "ok"}
{"id": "4dScWK", "name": "outline macro, 2D distfunc", "author": "nexor", "description": "macro magic", "tags": ["2d", "distancefunction", "macro"], "likes": 1, "viewed": 212, "published": "Public", "date": "1493731992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// OutLine\n#define OL(v,p,f,w) f;{v+=(1.-(f));p*=(1.+w);v+=(f);}\n\n#define sin1(a) (sin(a)*.5+.5)\n\nfloat circle(vec2 p, float r)\n{\n    return smoothstep(1.,.975,length(p/r));\n}\n\nfloat rect(vec2 p, float w, float h)\n{\n \tp=abs(p/vec2(w,h));\n    return smoothstep(1.,.975,max(p.x,p.y));\n}\n\nfloat rect(vec2 p,float a)\n{\n    return rect(p,a,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.+2.*uv;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(.0);\n    \n    float v = 0.;\n    float w = OL(v,p,max(circle(p,1.),rect(p,.9)),sin1(iTime)*.15);\n    \n    col += mix(\n        w*mix(vec3(1.,.0,.0),vec3(.0,1.,.0),v),\n        vec3(w),step(uv.x,.5));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dScWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 129, 129, 175], [177, 177, 215, 215, 284], [286, 286, 314, 314, 340], [342, 342, 399, 399, 755]], "test": "ok"}
{"id": "4dScWV", "name": "My First Signed-Distance-Func", "author": "loolo78", "description": "My first \"signed-distance-function\" shader. It's a cube!\n\nThank you to http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions for teaching me.", "tags": ["sdf", "cube"], "likes": 4, "viewed": 149, "published": "Public", "date": "1493765536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    // Start depth\n    float depth = start;\n    // Keep looking for where the marching ray hits a surface\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        // Get the distance from marching ray point to surface of box\n        float dist = boxSDF(eye + marchingDirection * depth, vec3(0.5));\n        // If we've hit near the surface, return this distance\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        // Didn't find anything, let's go to where we found something\n        depth += dist;\n        // We're at the end, stop\n        if (depth > end)\n        {\n            return end;\n        }\n    }\n    // Ran out of steps before we hit the end, just return end\n    return end;\n}\n\n/**\n    fov:         Field of View of camera\n    screen_size: Screen size\n    fragCoord:   Screen coord of pixel\n    return:      Direction of rendering ray of the projection camera\n */\nvec3 rayDirection(float fov, vec2 screen_size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - screen_size / 2.0;\n    float z = (screen_size.y / 2.) / tan(radians(fov) / 2.);\n    return normalize(vec3(xy,-z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 march_dir = rayDirection(60., iResolution.xy, gl_FragCoord.xy);\n    float dist = shortestDistanceToSurface(\n        vec3(\n                cos(iTime) * 1.,\n                0,\n                (sin(iTime)+2.) * 2.\n            ), \n        march_dir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    fragColor = vec4(2./dist);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dScWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 157, 157, 195], [197, 197, 288, 307, 1012], [1014, 1200, 1264, 1264, 1404], [1406, 1406, 1463, 1463, 1862]], "test": "ok"}
{"id": "4dsfDN", "name": "Random dithering experiments", "author": "theGiallo", "description": "My intuitive idea for dithering. I had to try. Now I can study literature :D", "tags": ["noise", "dithering"], "likes": 3, "viewed": 176, "published": "Public", "date": "1496257179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#if 0\n#define COLOR_TOP vec3(1.0,0.0,1.0)\n#define COLOR_BOTTOM vec3(0.0,1.0,0.0)\n#else\n#define COLOR_TOP vec3(1.0,0.0,0.0)\n#define COLOR_BOTTOM vec3(1.0,1.0,0.0)\n#endif\n\n/*\n From left to right:\n       Gradient     |    round    | texture noise | pseudo blue noise | cheap gaussian noise\n*/\n\n\nfloat mask(vec2 p) // see https://www.shadertoy.com/view/ldyXDd\n{\n#define T(l) textureLod(iChannel1,U/256.,l)\n#define DMUL  8.12235325   \n#define SIZE  5.5\n    vec2 U = floor(p/SIZE)*SIZE;\n    p += ( T(0.).xy - .5 ) *DMUL;\n    return fract( p.x*1.705 + p.y*.5375 ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float p = 0.5 + dot( uv - vec2( ceil( uv.x * 3.0 ) / 3.0 - 0.16666, 0.5), vec2(sin(iTime), 1.0));\n    fragColor = vec4( mix( COLOR_TOP, COLOR_BOTTOM, p ), 1.0 );\n\n    if ( uv.x > 0.333333 )\n    {\n        float m =\n           uv.x < 0.5 ? 0.5 :\n         ( uv.x < 0.666 ? texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r :\n         ( uv.x < 0.8333 ? mask( fragCoord ) :\n         ( texture(iChannel1, fragCoord.xy/iChannelResolution[0].xy).r +\n           texture(iChannel1, fragCoord.xy/iChannelResolution[0].xy).g +\n           texture(iChannel1, fragCoord.xy/iChannelResolution[0].xy).b ) / 3.0\n            ) );\n         \n\t\tfragColor.rgb = m > p ? COLOR_TOP : COLOR_BOTTOM;\n    }\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 357, 357, 560], [562, 562, 619, 619, 1356]], "test": "error"}
{"id": "4dsfRr", "name": "Sketch_TriLattice2", "author": "cexlearning", "description": "TriLattice2，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 4, "viewed": 78, "published": "Public", "date": "1494642635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 hue2rgb(float h)\n{\n    h = fract(h) * 6.0 - 2.0;\n    return clamp(vec3(abs(h - 1.0) - 1.0, 2.0 - abs(h), 2.0 - abs(h - 2.0)), 0.0, 1.0);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float sxf = fract(sx);\n    float offs = step(fract(1.0 - uv.y), sxf);\n    return vec2(floor(sx) * 2.0 + sxf + offs, uv.y);\n}\n\nvec3 tri(vec2 uv)\n{\n    vec2 p = floor(uv2tri(uv));\n    float h = rand(p + 0.1) * 0.2 + iTime * 0.2;\n    float s = sin((rand(p + 0.2) * 3.3 + 1.2) * iTime) * 0.5 + 0.5;\n    return hue2rgb(h) * s + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n\n    float t1 = iTime / 2.0;\n    float t2 = t1 + 0.5;\n\n    vec3 c1 = tri(uv * (8.0 - 4.0 * fract(t1)) + floor(t1) * 4.0);\n    vec3 c2 = tri(uv * (8.0 - 4.0 * fract(t2)) + floor(t2) * 4.0 + 2.0);\n\n    fragColor = vec4(mix(c1, c2, abs(1.0 - 2.0 * fract(t1))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [93, 93, 116, 116, 236], [238, 238, 260, 260, 435], [437, 437, 456, 456, 640], [642, 642, 699, 699, 1038]], "test": "ok"}
{"id": "4dsfz4", "name": "Raymarching test FC", "author": "FractalCurious", "description": "My first attempt at implementing ray marching (following a tutorial). Attempting to implement shadows on my own.", "tags": ["raymarching"], "likes": 1, "viewed": 68, "published": "Public", "date": "1495097385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Based on this tutorial: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415;\n\nstruct object {\n\tfloat sdf;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nvec3 lightPos;     \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    \n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    \n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat checker(float x, float y) {\n    return mod(mod(x, 1.) + mod(y, 1.), 2.);\n}\n\nfloat regularPoints(float x)\n{\n    return mod(x, 1.);\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat squareSDF(vec3 p, vec3 center, vec3 dimensions) {\n    \n    vec3 d = abs(p - center) - dimensions / 2.;\n    \n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nobject cylinderX(vec3 samplePoint, float radius) {\n    \n    vec3 p = samplePoint;\n    p.x = 0.;\n    \n\treturn object(length(p) - radius, vec3(1., 1., 1.) * regularPoints(samplePoint.x), vec3(1.));\n}\n\nobject cylinderY(vec3 samplePoint, float radius) {\n    \n    vec3 p = samplePoint;\n    p.y = 0.;\n    \n\treturn object(length(p) - radius, vec3(1., 1., 1.) * regularPoints(samplePoint.y), vec3(1.));\n}\n\nobject cylinderZ(vec3 samplePoint, float radius) {\n    \n    vec3 p = samplePoint;\n    p.z = 0.;\n    \n\treturn object(length(p) - radius, vec3(1., 1., 1.) * regularPoints(samplePoint.z), vec3(1.));\n}\n\nobject behindPlane(vec3 p) {\n    \n    vec3 color = vec3(0., 1.1, .99) * (0.3 + 0.7 * mod((p.x - 2.) + (p.y - 2.) * (p.x - 2.) + iTime / 9., 1.));\n    \n\treturn object(p.z + 3., color, vec3(1.));\n}\n\nfloat polarCheckers(vec2 xy) {\n    float r = length(xy) - mod(iTime, 2.);\n    float a = atan(xy.y / xy.x) + iTime;\n    \n    return mod(mod(r, 1.) + mod(a, 2. * 3.1415 / 32.), 2.);\n}\n\nobject leftPlane(vec3 p) {\n    \n    vec3 diffColor = vec3(0., 1., 0.) * polarCheckers(p.yz * 2.);\n    \n\treturn object(p.x + 3., diffColor, vec3(1.));\n}\n\nobject rightPlane(vec3 p) {\n    vec3 diffColor = vec3(0., 1., 0.) * polarCheckers(p.yz * 2.);\n    \n\treturn object(3. - p.x, diffColor, vec3(1.));\n}\n\nobject belowPlane(vec3 p) {\n    \n    vec3 diffColor = vec3(.9, .5, .9) * checker(-p.x, p.z);\n    \n\treturn object(2. + p.y, diffColor, vec3(1.));\n}\n\nobject abovePlane(vec3 p) {\n    float sdf = 2. + .3 * sin(iTime) - p.y;\n    \n    vec3 diffColor = vec3(.9, .5, .9) * checker(p.x, p.z);\n    \n\treturn object(sdf, diffColor, vec3(1.));\n}\n\nobject oUnion(object o1, object o2) {\n    \n    float sdf1 = o1.sdf;\n    float sdf2 = o2.sdf;\n    \n    vec3 diffColor = mix(o1.diffColor, o2.diffColor, step(EPSILON, sdf1));\n    \n\treturn object(min(sdf1, sdf2), diffColor, vec3(1.));\n}\n\nfloat triangleWave(float x) {\n\treturn abs(mod(x, 2.) - 1.);\n}\n\nobject axes(vec3 p) {\n    \n    float radius = 0.03;\n    \n    object xAxis = cylinderX(p, radius);\n    object yAxis = cylinderY(p, radius);\n    object zAxis = cylinderZ(p, radius);\n    \n\treturn oUnion(oUnion(xAxis, yAxis), zAxis);\n}\n\nfloat sphericChecker(vec3 p) {\n\tfloat a = atan(p.z / p.x) + iTime;\n    float b = atan(p.z / p.y) + iTime;\n    \n    return mod(mod(a, 2. * PI / 32.) + mod(b, 2. * PI / 32.), 2.);\n}\n\nobject sphere2(vec3 p) {\n    \n    float cx = -2.5 + 5. * triangleWave(iTime * 15. / 32. + 2.4387);\n    float cz = -0.5 + 13. * triangleWave(iTime * 13. / 32.);\n    \n    vec3 center = vec3(cx, -1.5, cz);\n    \n    float sdf = sphereSDF(p, center, .5);\n    \n    vec3 diffColor = vec3(.9, .8, .3) * sphericChecker(p - center);\n    \n    return object(sdf, diffColor, vec3(1.));\n}\n\n\nvec3 rotateX(vec3 p, float angle) {\n\tvec3 result = p;\n    \n    result.y = p.y * cos(angle) - p.z * sin(angle);\n    result.z = p.y * sin(angle) + p.z * cos(angle);\n    \n    return result;\n}\n\nobject scene(vec3 p) {\n    \n    object light = object(length(lightPos - p) - .03, vec3(1.), vec3(1.));\n    \n    object rightAndLeftWalls = oUnion(leftPlane(p), rightPlane(p));\n    object floorAndCeiling = oUnion(belowPlane(p), abovePlane(p));\n    \n    object walls = oUnion(behindPlane(p), oUnion(rightAndLeftWalls, floorAndCeiling));\n    \n    float sphere1SDF = sphereSDF(p, vec3(0., 0., 0.), 1.);\n    object sphere1 = object(sphere1SDF, vec3(1., 1., 0.), vec3(1.));\n    \n    object sphere2Obj = sphere2(p);\n    \n    object axesObj = axes(p);\n    \n    vec3 square1Coord = rotateX(p - vec3(2., 0., 0.), iTime * 5.);\n    \n    object square1 = object(squareSDF(square1Coord, vec3(0.), vec3(.5)), vec3(.8), vec3(1.));\n    \n    object spheres = oUnion(sphere1, sphere2Obj);\n    \n    object scene = oUnion(oUnion(spheres, walls), oUnion(square1, axesObj));\n    \n    return object(scene.sdf, scene.diffColor, vec3(1.));\n}\n\nfloat sceneSDF(vec3 p) {\n\tobject sceneObj = scene(p);\n    \n    return sceneObj.sdf;\n}\n\nvec3 estimateNormal(vec3 p) {\n\treturn normalize(vec3(\n    \tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n    \nvec3 phongShading(vec3 diffColor, vec3 specColor, vec3 surfPoint, vec3 surfNorm, vec3 lightPos, vec3 eyePos)\n{\n    vec3 visionDir = normalize(eyePos - surfPoint);\n    vec3 lightVec = lightPos - surfPoint;\n    vec3 lightDir = normalize(lightVec);\n    float lightDist = length(lightVec);\n    \n    // =================== Figure out if light is occluded by obstacles ====================//\n    \n    float distToObstacle = shortestDistanceToSurface(\n        surfPoint,\n        normalize(lightVec),\n        EPSILON * 20.,\n        lightDist\n    );\n    \n    if (distToObstacle < lightDist) {\n    \treturn vec3(0.); // No dice. We're in the shadow.\n    }\n   \n    // ================= Good, we're not in the shadow! compute light intensity =============//\n    \n    float diffDot = dot(lightDir, surfNorm);\n    float specDot = dot(normalize(visionDir), normalize(reflect(-lightDir, surfNorm)));\n    \n    if (diffDot < 0.) {\n    \treturn vec3(0.);\n    }\n    \n    vec3 diffIntensity = diffColor * diffDot;\n    \n    if (specDot < 0.) {\n    \treturn diffIntensity;\n    }\n    \n    return diffIntensity + 0.5 * specColor * pow(specDot, 10.);\n}\n\nvec3 handleLights(vec3 diffColor, vec3 specColor, vec3 surfPoint, vec3 surfaceNormal, vec3 eyePos) {\n    float light1PosRadius = 2.8;\n    float light1PosAngle = iTime * 2. / 10.;\n    \n    vec3 light1Pos = vec3(\n        light1PosRadius * cos(light1PosAngle),\n        1.5 * sin(iTime / 1.74327623 / 10.),\n        light1PosRadius * sin(light1PosAngle)\n    );\n    \n    vec3 color = phongShading(\n        diffColor,\n        specColor,\n        surfPoint,\n        surfaceNormal,\n        light1Pos,\n        eyePos\n    );\n    \n    vec3 light2Pos = vec3(-1., 1., 1.);\n    \n    color += phongShading(\n        diffColor,\n        specColor,\n        surfPoint,\n        surfaceNormal,\n        light2Pos,\n        eyePos\n    );\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.2, 12.0);\n    \n    float eyeTargetX = sin(1. * iMouse.x / iResolution.x - .5);\n    float eyeTargetY = sin(1. * iMouse.y / iResolution.y - .5);\n    \n    vec3 eyeTargetPos = eye + vec3(eyeTargetX, eyeTargetY, -1.);\n    \n    mat4 viewToWorld = viewMatrix(eye, eyeTargetPos, vec3(0., 1., 0.));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float lightPosRadius = 2.8;\n    float lightPosAngle = iTime * 2. / 2.;\n    \n    lightPos = vec3(\n        lightPosRadius * cos(lightPosAngle),\n        1.5 * sin(iTime / 1.74327623 / 2.),\n        lightPosRadius * sin(lightPosAngle)\n    );\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 surfPoint = eye + dist * worldDir;\n    \n    object sceneObj = scene(surfPoint);\n    \n    vec3 surfaceNormal = estimateNormal(surfPoint);\n    \n    vec3 color = handleLights(\n        sceneObj.diffColor,\n        sceneObj.specColor,\n        surfPoint,\n        surfaceNormal,\n        eye\n    );\n    \n    fragColor = vec4(.5 * color + 0.1, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dsfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 418, 418, 560], [563, 563, 612, 612, 799], [801, 801, 834, 834, 881], [883, 883, 913, 913, 938], [940, 940, 992, 992, 1034], [1036, 1036, 1091, 1091, 1216], [1218, 1218, 1268, 1268, 1415], [1417, 1417, 1467, 1467, 1614], [1616, 1616, 1666, 1666, 1813], [1815, 1815, 1843, 1843, 2010], [2012, 2012, 2042, 2042, 2193], [2195, 2195, 2221, 2221, 2346], [2348, 2348, 2375, 2375, 2495], [2497, 2497, 2524, 2524, 2643], [2645, 2645, 2672, 2672, 2829], [2831, 2831, 2868, 2868, 3064], [3066, 3066, 3095, 3095, 3127], [3129, 3129, 3150, 3150, 3360], [3362, 3362, 3392, 3392, 3541], [3543, 3543, 3567, 3567, 3917], [3920, 3920, 3955, 3955, 4108], [4110, 4110, 4132, 4132, 5025], [5027, 5027, 5051, 5051, 5112], [5114, 5114, 5143, 5143, 5446], [5448, 5448, 5539, 5539, 5845], [5851, 5851, 5961, 5961, 6974], [6976, 6976, 7076, 7076, 7711], [7713, 7713, 7770, 7770, 9030]], "test": "ok"}
{"id": "4dSyWK", "name": "Speed lines", "author": "Hadyn", "description": "A somewhat accidental spinoff from a new shader I'm working on, which is in itself a more intentional spinoff of an idea I had whilst working on the blue flame shader.", "tags": ["2d"], "likes": 8, "viewed": 469, "published": "Public", "date": "1493727401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n * Created by Hadyn Lander \n * 3D noise from Nikita Miropolskiy, nikat/2013 https://www.shadertoy.com/view/XsX3zB\n * That basically includes all of this neat looking code up top:\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n/*\n* The following is all my mess:\n*/\n\n#define RADIUS 1.45\n#define EDGE 0.55\n#define NOISEBIGNESS 0.1 \n#define NIGHTSPEEDBONUS 1.25 \t\t\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 28.22+NIGHTSPEEDBONUS*iTime;\n    float bignessScale = 1.0/NOISEBIGNESS;\n\tvec2 p = fragCoord.xy / iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 positionFromCenter = p-vec2(0.5*aspect, 0.5);\n    \n    p = vec2(0.5*aspect, 0.5)+normalize(positionFromCenter)*min(length(positionFromCenter)+0.00, 0.05);\n        \n    // Noise:\n    vec3 p3 = bignessScale*0.25*vec3(p.x, p.y, 0.0) + vec3(0.0, 0.0, time*0.025);\n    float noise = simplex3d(p3*32.0);// simplex3d_fractal(p3*8.0+8.0);\n\tnoise = 0.5 + 0.5*noise;\n\t\n    float distanceFromCenter = clamp(length(positionFromCenter)/RADIUS, 0.0, 1.0)*(noise);    \n    \n    float falloffMask = 2.0*distanceFromCenter-1.0;\n    falloffMask = 1.0-pow(abs(falloffMask), 4.0);\n    \n    float thinnerMask = 2.0*distanceFromCenter-1.0;\n    thinnerMask = pow(1.0-abs(thinnerMask), 4.0);\n    float steppedValue = smoothstep(EDGE,EDGE+0.1, noise*falloffMask);\n    \n    float finalValue = steppedValue;\n    //finalValue = falloffMask;\n    // uncomment the above line for a softer effect.\n    \n    finalValue = smoothstep(EDGE,EDGE+0.1, noise*finalValue);       \n    \n    vec3 finalColor = vec3(1.0)*finalValue;    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 261, 283, 283, 456], [563, 586, 611, 864, 1781], [2051, 2118, 2151, 2151, 2298], [2462, 2462, 2519, 2519, 3735]], "test": "ok"}
{"id": "4dSyWV", "name": "Julia Fractal Morph By Lissajous", "author": "DonKarlssonSan", "description": "A Lissajous curve guides us through different Julia Fractal shapes.", "tags": ["fractal", "julia"], "likes": 1, "viewed": 77, "published": "Public", "date": "1493757380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nconst float a = 5.0;\nconst float b = 4.0;\nconst float w = PI / 2.0;\nvec2 lissajous() {\n    float t = iTime/10.0+222.19;\n    float x = sin(a * t + w);\n    float y = sin(b * t);\n\treturn vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float xmin = -2.0;\n    float ymin = -1.4;\n    float xmax = 2.0;\n    float ymax = 1.4;\n    float xDelta;\n    float yDelta;\n    xDelta = (xmax - xmin) / iResolution.x;\n    yDelta = (ymax - ymin) / iResolution.y;\n    int iteration = 0;\n    int max_iteration = 300;\n    vec2 l = lissajous();\n    float x = xmin + fragCoord.x * xDelta;\n    float y = ymin + fragCoord.y * yDelta;\n    while (x*x + y*y < 64.0 && iteration < max_iteration) {\n        // Multiplication of complex numbers:\n        // (a+bi) (c+di) = (ac-bd) + (bc+ad)i\n        // c^2 = (x+yi) (x+yi) = (xx-yy) + (yx+yx)i = (xx-yy) + (2xy)i\n        float xtemp = x * x - y * y + l.x;\n        y = 2.0 * x * y + l.y;\n        x = xtemp;\n        iteration++;\n    }        \n    float c = 1.0 - float(iteration) / float(max_iteration)*6.0;\n    fragColor = vec4(c, c, c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 109, 109, 220], [222, 222, 279, 279, 1111]], "test": "ok"}
{"id": "4dXBD4", "name": "Basic raymarching with comments", "author": "Hitokage", "description": "Just my first raymarching attempt with some basic lights, fog and simple models.", "tags": ["3d", "raymarching", "sphere", "models", "fog", "scene"], "likes": 2, "viewed": 521, "published": "Public API", "date": "1496134020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//links\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n//https://gamedev.stackexchange.com/questions/67719/how-do-raymarch-shaders-work\n//http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//https://learnopengl.com - for lighting, matrices, camera theory etc.\n\n//constants\n//raymarching\nconst float EPSILON = 0.001;\nconst int MAX_STEPS = 150;\n//camera\nconst float NEAR = 0.0;\nconst float FAR = 300.0;\n//fog\nconst float FOG_START = 1.0;\nconst float FOG_END = 10.0;\n\nstruct light\n{\n    vec3 position;\n    vec3 color;\n    float ambientCoef;\n    float attenuation;\n};\n\nstruct material\n{\n    vec3 color;\n    vec3 specularColor;\n    float shininess;\n};\n\nlight light0 = light(vec3(0.8,0.5,1.8), vec3(0.5,0.5,0.5), 0.02, 0.02);\n\nmaterial material0 = material(vec3(0.0,1.0,0.0), vec3(1.0,1.0,1.0), 10.0);\n\n//environment\nvec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\nfloat fov = 45.0;\n\n//distance functions for the primitives\nfloat sphereDist (vec3 point, float radius)\n{\n    return length(point)-radius;\n}\n\nfloat boxDist( vec3 point, vec3 dimensions )\n{\n    return length(max(abs(point)-dimensions,0.0));\n}\n\n//gets the minimal distance of the whole scene\n//the scene is specified here\n//transformations are done by transforming the point\nfloat sceneMinDist (vec3 point)\n{\n    return min(sphereDist(point,1.0),\n               boxDist(point+vec3(0.0,-1.0,0.0), vec3(60.0,0.1,60.0)));\n}\n\n//view matrix\nmat4 lookAt(vec3 cam, vec3 focusPoint, vec3 up) {\n    //we need to create the new coord system\n    vec3 z = normalize(focusPoint-cam);\n    vec3 x = cross(z, up);\n    vec3 y = cross(z,x);\n    //simply make a matrix of this system\n    return mat4(vec4(x, 0.0),vec4(y, 0.0),vec4(-z, 0.0),vec4(0.0, 0.0, 0.0, 1));\n}\n\n\n//aproximates the normal based on the gradient change, gradient tells us which direction is the fastest growth of function, direction to the object is negative so gradient = normal\n//gradient is calculated as partial derivation by x,y,z for each element of f(x,y,z), approximation by nearby points gives us this function:\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n                         sceneMinDist(vec3(p.x + EPSILON, p.y, p.z)) - sceneMinDist(vec3(p.x - EPSILON, p.y, p.z)),\n                         sceneMinDist(vec3(p.x, p.y + EPSILON, p.z)) - sceneMinDist(vec3(p.x, p.y - EPSILON, p.z)),\n                         sceneMinDist(vec3(p.x, p.y, p.z  + EPSILON)) - sceneMinDist(vec3(p.x, p.y, p.z - EPSILON))\n                     ));\n}\n\n//raymarching function, returns the distance to the closest surface\n//gets the cam position, direction of the marching ray and near and far clipping params\nfloat closestDistance(vec3 cam, vec3 direction, float near, float far)\n{\n    float t=near;\n\n    //TODO: recognize object and return the correct material\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 ray=cam+direction*t;\n        float minDistance = sceneMinDist(ray);\n        if (minDistance<EPSILON)\n            return t;\n\n        t +=minDistance;\n\n        if (t >= far)\n            return far;\n    }\n    return far;\n}\n\nvec3 blinnPhong(vec3 cameraPos,light light0, vec3 point)\n{\n    //blinn-phong lighting model\n    vec3 normal = getNormal(point);\n    vec3 surfaceToLight = normalize(light0.position - point);\n\n    //ambient aka when there is no light at all\n    vec3 ambient = light0.ambientCoef*material0.color;\n    ambient *= light0.color;\n\n    //diffuse - that normal shading\n    //cosine of the angle of incidence = dot(x,y)/(|x|*|y|) where lengths are 1 - normalized\n    float diffuseCoef = max(0.0,dot(normal, surfaceToLight));\n    vec3 diffuse = diffuseCoef*light0.color*material0.color;\n\n    //specular - shiny stuff\n    //if it was a mirror, how much would the reflection from the light go to the camera?\n    //incidence vector = -surfaceToLight\n    vec3 specular = vec3(0.0,0.0,0.0);\n    if (diffuseCoef > 0.0)\n    {\n        vec3 surfaceToCamera = normalize(cameraPos - point);\n        //normal phong calculates the cos of angle between vector to camera and reflection\n        //vec3 reflection = reflect(-surfaceToLight, normal);\n        //blinn adds the halfway vector\n        vec3 halfway = normalize(surfaceToLight+surfaceToCamera);\n        float cosAngle = max(0.0, dot(normal,halfway));\n        float specularCoef = pow(cosAngle,material0.shininess);\n        specular = specularCoef*material0.specularColor*light0.color;\n    }\n\n\n    //attenuation - loss of light over distance from the light source\n    float distanceToLight = length(light0.position - point);\n    float attenuation = 1.0/(1.0 + light0.attenuation * pow(distanceToLight,2.0));\n    vec3 linearColor = ambient + attenuation*(diffuse+specular);\n    \n    return linearColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cameraPos=vec3(0.0,0.0,5.0);\n\n    //let's normalize the point on the view plane to -1-1 coordinates, center is 0,0\n    vec2 planeCoord = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n    //we need to fix one dimension\n    planeCoord.x *= iResolution.x/iResolution.y;\n\n    //x,y of the current plane point, the z is based on the right triangle where tan = A/B (right angle at center of screen, A-half of screen, B is Z), - sign defines the direction of Z\n    //since we have -1 to 1 plane, half is 1.0\n    vec3 rayDirection = vec3(planeCoord.xy, -(1.0 / tan(radians(fov))));\n    rayDirection = normalize(rayDirection);\n    \n    //animation of the camera\n    //sin and cos are related to the unit circle, polar coordinates r*cos/sin+center\n    cameraPos.x = 2.0*cos(iTime);\n    cameraPos.z = 2.0*sin(iTime);\n    //calculate the rotation for the camera direction\n    //creates the view->world matrix\n    mat4 rrr = lookAt(cameraPos,vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0));\n    //apply it to the rays that are coming out of it, result in world space\n    rayDirection = (rrr*vec4(rayDirection,0.0)).xyz;\n\n    //raymarching\n    float dist = closestDistance(cameraPos, rayDirection, NEAR, FAR);\n    //the ray went too far, nothing\n    vec3 linearColor = backgroundColor.xyz;\n    //the ray hit something, get the color then\n    if (dist-EPSILON < FAR)\n    {\n        //get the point in world space\n        vec3 point = cameraPos+rayDirection*dist;\n        linearColor = blinnPhong(cameraPos, light0, point);\n    }\n    \n    //now let's get the fog factor using simple linear fog\n    float fogFactor = (FOG_END-dist)/(FOG_END - FOG_START); \n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    linearColor = mix(vec3(0.7,0.7,0.7), linearColor, fogFactor);\n    \n    //gamma correction - transform the linear rgb to more natural one for human eye (CRT style)\n    vec3 gamma = vec3(1.0/2.2);\n    fragColor = vec4(pow(linearColor,gamma), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[923, 963, 1008, 1008, 1043], [1045, 1045, 1091, 1091, 1144], [1146, 1276, 1309, 1309, 1421], [1423, 1437, 1486, 1531, 1748], [1751, 2073, 2097, 2097, 2499], [2501, 2657, 2729, 2729, 3084], [3086, 3086, 3144, 3177, 4721], [4724, 4724, 4780, 4780, 6711]], "test": "ok"}
{"id": "4dXBRN", "name": "Framed Duck", "author": "dr2", "description": "Semi-monocoque duck", "tags": ["raymarch", "shadow", "structure"], "likes": 10, "viewed": 464, "published": "Public API", "date": "1494962363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Framed Duck\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrEllips2Df (vec2 p, vec2 r);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir, lbPos;\nfloat dstFar, tCur;\nbool doSh;\nint idObj;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, r3;\n  vec2 r2;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dMin, dMinO, dMinI, d, h, ws, wf;\n  dMinO = dstFar;\n  dMinI = dstFar;\n  wf = 0.98;\n  h = 0.5;\n  r2 = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  d = PrEllips2Df (p.xz, r2);\n  d = min (max (d, abs (p.y) - h), length (vec2 (d, p.y)) - h);\n  dMinO = min (d, dMinO);\n  d = PrEllips2Df (p.xz, wf * r2);\n  d = min (max (d, abs (p.y) - wf * h), length (vec2 (d, p.y)) - wf * h);\n  dMinI = min (d, dMinI);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  h = 0.07;\n  r2 = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  d = PrEllips2Df (q.yz, r2);\n  d = min (max (d, abs (q.x) - h), length (vec2 (d, q.x)) - h);\n  dMinO = SmoothMin (d, dMinO, 0.05);\n  d = PrEllips2Df (q.yz, wf * r2);\n  d = min (max (d, abs (q.x) - wf * h), length (vec2 (d, q.x)) - wf * h);\n  dMinI = SmoothMin (d, dMinI, 0.05);\n  r3 = vec3 (0.4, 0.35, 0.5);\n  q = p - vec3 (0., 0.75, -0.4);\n  dMinO = SmoothMin (PrEllipsDf (q, r3), dMinO, 0.1);\n  dMinI = SmoothMin (PrEllipsDf (q, wf * r3), dMinI, 0.1);\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r2 = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  dMinO = SmoothMin (max (PrEllCylDf (q, r2, h),\n     - PrEllCylDf (q - vec3 (0., 0., 0.9 * h), r2 - 0.02, 2. * h)), dMinO, 0.01);\n  ws = 0.02;\n  q = abs (mod (p + ws, 2. * ws) - ws) - 0.15 * ws;\n  dMin = 0.9 * max (max (dMinO, - dMinI), min (min (q.x, q.z), q.y));\n  idObj = 1;\n  if (! doSh) {\n    d = PrSphDf (p - lbPos, 0.04);\n    if (d < dMin) { dMin = d;  idObj = 2; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float lbDist)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.002;\n  for (int j = 0; j < 100; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += 0.01 * (1. + d);\n    if (sh < 0.02 || d > lbDist) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ld;\n  float d, wGlow;\n  wGlow = 0.;\n  ld = lbPos - ro;\n  d = length (ld);\n  ld /= d;\n  if (d < dstHit) wGlow += pow (max (dot (rd, ld), 0.), 1024.);\n  return clamp (0.7 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, vn, col, lbDir;\n  float dstObj, sh, att, lbDist;\n  dstFar = 20.;\n  doSh = false;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    lbDir = normalize (lbPos - ro);\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      doSh = true;\n      sh = ObjSShadow (ro, ltDir, dstFar);\n      col = vec3 (0.2, 0.5, 0.8);\n      col = 0.1 * col + sh * (0.6 * col * max (0., dot (vn, ltDir)) +\n         0.5  * vec3 (1.) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.));\n    } else {\n      col = max (0.6 + 0.4 * dot (rd, - vn), 0.) * vec3 (1., 1., 0.5);\n    }\n  } else {\n    col = vec3 (0.1, 0.15, 0.1) * (0.5 + 1.5 * rd.y);\n    if (rd.y < 0.) {\n      ro -= ((ro.y + 0.51) / rd.y) * rd;\n      lbDir = lbPos - ro;\n      lbDist = length (lbDir);\n      att = 1. / (1. + dot (lbDir, lbDir));\n      lbDir /= lbDist;\n      doSh = true;\n      col = mix (col, att * vec3 (1., 1., 0.5) * ObjSShadow (ro, lbDir, lbDist),\n         smoothstep (0.1, 0.2, att));\n    }\n  }\n  col = mix (col, vec3 (0.7, 0.7, 0.4), GlowCol (roo, rd, dstObj));\n  col = pow (clamp (col, 0., 1.), vec3 (0.9));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n    el = clamp (el, -0.27 * pi, -0.01 * pi);\n  } else {\n    az -= 3.5 * pi * sin (0.014 * pi * tCur);\n    el -= 0.12 * pi * sin (0.2 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.5));\n  ro = vuMat * vec3 (0., 0., -5.);\n  ro.y += 0.25;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  lbPos = vec3 (0., 0.1, 0.);\n  fragColor = vec4 (ShowScene (ro, rd), 1);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllips2Df (vec2 p, vec2 r)\n{\n  return (length (p / r) - 1.) * min (r.x, r.y);\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXBRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[432, 432, 454, 454, 2192], [2194, 2194, 2227, 2227, 2404], [2406, 2406, 2427, 2427, 2637], [2639, 2639, 2690, 2690, 2941], [2943, 2943, 2991, 2991, 3187], [3189, 3189, 3224, 3224, 4355], [4357, 4357, 4413, 4413, 5336], [5338, 5338, 5371, 5371, 5398], [5400, 5400, 5435, 5435, 5497], [5499, 5499, 5535, 5535, 5586], [5588, 5588, 5632, 5632, 5707], [5709, 5709, 5754, 5754, 5857], [5859, 5859, 5890, 5890, 5954]], "test": "ok"}
{"id": "4dXBzN", "name": "pruebas_04", "author": "ps", "description": "raymarching \n", "tags": ["raymarching"], "likes": 0, "viewed": 70, "published": "Public", "date": "1494968883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// iluminación de iq http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo parte de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 100.0\n#define PI 3.14159265359\nfloat rand(vec2 co){\n\t// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise2f( in vec2 p )\n{\n\tvec2 ip = vec2(floor(p));\n\tvec2 u = fract(p);\n\t// http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n\tu = u*u*(3.0-2.0*u);\n\t//u = u*u*u*((6.0*u-15.0)*u+10.0);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),  rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),   rand(ip+vec2(1.0,1.0)),u.x),\n\t\tu.y)\n\t;\n\treturn res*res;\n\t//return 2.0* (res-0.5);\n}\n// define el terreno (signed distanced function) dada unas coordenadas x y z devuelve si ha colisionado o no\nfloat terrainSDF (vec2 posxz){\n  float x=posxz.x;\n    float  z=posxz.y;\n    return 3.2 + 0.1*sin(20.0*x)*cos(20.0*z);\n}\nfloat terrain2SDF (vec2 posxz){\n  float x=posxz.x;\n    float  z=posxz.y;\n    float i;\n\tz = 3.5f;\n\tfor( i=0.; i<20.; i+=1. )\n{\n    float nx = x*x-z*z - 0.745f;\n    float nz = 2.0f*x*z + 0.186f;\n    if( nx*nx+nz*nz>4.0f ) break;\n    x = nx;\n    z = nz;\n}\n  //  return 2.;\nreturn 4.f + sqrt(sqrt(sqrt(i*0.001f)));\n}\n\nfloat terrain3SDF (vec2 posxz){\n     float x=posxz.x;\n    float  z=posxz.y;\nfloat f;\nf = 0.5000000f*noise2f( posxz);\nf += 0.2500000f*noise2f( posxz);\nf = 0.5f+0.5f*f;\nf = f*f*(3.0f-2.0f*f);\nf = f*f*(3.0f-2.0f*f);\nf = 2.5f + 1.5f*f;\nreturn f;\n}\n\n\n\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n  return terrain3SDF(posxz);\n}\n/*float scene(vec3 p){\n    vec2 posxz=p.xz;\n    //return terrainSDF(posxz);\n     return sphereSDF(p);\n}*/\n// \nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = tmin;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - scene( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2  eps = vec2( 0.0001 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 makeFog(in vec3 realColor, vec3 fogColor, float distancia, float fogDensity){\n    float theE = 2.718281828459045235360;\n\tfloat res = 1.0/(pow(theE,((distancia*fogDensity)*(distancia*fogDensity)*(distancia*fogDensity))));\n    return mix(fogColor,realColor,res);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    /*vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n  //  vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(10.0 * sin(iTime),  2.0,10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;*/\n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    //Sfactor=pow(Sfactor,length(nor));\n    Sfactor = max(dot(R,V),0.0001)*0.001;\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n}\n\nfloat fogAngleFixer(vec3 angle){\n\treturn clamp(-angle.y*2.0+0.1,0.0,1.0);   \n}\nvec3 getBackground(vec3 angle){\n    float heigh = clamp(angle.y*2.0+0.2,0.0,1.0);\n    return vec3(0.3*(1.0-heigh),0.5*heigh*0.5+0.5,1.0*heigh/2.0+0.5);\n}\nvec3 getColor(vec3 pos, vec3 norm){\n    float col1=0.0,col2 = 0.0, col3 = 0.0;\n    col1 = clamp((pos.y-3.6) * 10.0, 0.0, 1.0);\n    col2 = (clamp(abs((pos.y-3.6) * 10.0), 0.0, 1.0) * -1.0) + 1.0;\n    col3 = 1.0 - col1 - col2;\n    return\n        col1 * vec3(1.0,1.0,1.0) +\n        col2 * vec3(0.2,0.9,0.3) +\n        col3 * vec3(0.7,0.5,0.1);\n}\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n    float fogDensity = 0.1;\n    fogDensity*=fogAngleFixer(rd);\n    vec3 fogColor = vec3(1.0,1.0,1.0);\n    //return vec4(fogDensity);\n \n    \n    \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n\n        //draw background\n        col = getBackground(rd);// colorBackground;\n        t = -1.0;\n        col = makeFog(col, fogColor, tmax, fogDensity);\n        \n    \n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        //vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos, t );\n        vec3 matGround=getColor(pos,nor);\n        // return vec4 (nor,1. ); //descomentar para mostrar las normales\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        //vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_d = matGround;\n        vec3 K_s = vec3(0.2, 0.2, 0.2);\n        float shininess = 1.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        //return vec4(color,1.0);\n\t\tcol = makeFog(color, fogColor, t*3.0, fogDensity);\n        \n    }\n\treturn vec4(col,t);\n}\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\t//vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    //vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n   \n    vec2  m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\ndir.xz = rot2D(dir.xz, 180. * m.x);\n    \n    vec3 ro = vec3(0.0, 4.8, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,dir); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[606, 606, 626, 699, 768], [770, 770, 798, 798, 1152], [1153, 1262, 1292, 1292, 1381], [1382, 1382, 1413, 1413, 1694], [1696, 1696, 1727, 1727, 1939], [1943, 2011, 2035, 2035, 2066], [2067, 2177, 2250, 2250, 2447], [2450, 2450, 2491, 2491, 2720], [2722, 2722, 2753, 2753, 2976], [2978, 2978, 3060, 3060, 3245], [3247, 3247, 3387, 3387, 3973], [3975, 4345, 4449, 5306, 6270], [6272, 6272, 6304, 6304, 6350], [6351, 6351, 6382, 6382, 6504], [6505, 6505, 6540, 6540, 6846], [6847, 6847, 6882, 6882, 8208], [8209, 8209, 8242, 8242, 8367], [8369, 8369, 8426, 8521, 9072]], "test": "ok"}
{"id": "4dXfD4", "name": "Deep Dive", "author": "dr2", "description": "Jellyfish (use mouse to observe)", "tags": ["raymarch", "jellyfish"], "likes": 6, "viewed": 543, "published": "Public API", "date": "1496141689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Deep Dive\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Motivation from \"Luminescence\" by BigWings\n\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 Hashv3f (float p);\nfloat Hashfv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vpHit, cId, qHit, ltDir;\nconst vec3 jRep = vec3 (6., 30., 6.);\nfloat dstFar, tCur, qRnd;\nint idObj;\nconst float pi = 3.14159;\n\nfloat JFishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dc, hr, a, r;\n  p -= (Hashv3f (qRnd) - 0.5) * jRep * vec3 (0.5, 0.7, 0.5);\n  hr = -1.2 + 3. * SmoothBump (0.2, 0.7, 0.2, mod (0.2 * tCur + qRnd, 1.));\n  p.y -= 2. + 0.5 * hr;\n  p.xz *= 1. + 0.2 * hr;\n  dc = SmoothMax (PrSphAnDf (p, 1., 0.03), -0.2 - p.y, 0.1);\n  dMin = dc;\n  idObj = 1;\n  p.xz += Rot2D (vec2 (0.3 * sin (p.y + 2. * tCur + 2. * pi * qRnd) *\n     (1. - smoothstep (-2., 0.5, p.y)), 0.), 2. * pi * qRnd);\n  qHit = p;\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (7. * a + 0.5) / 7.);\n  q.xy += vec2 (0.3, 3.2);\n  d = PrCylDf (q.xzy, (0.045 + 0.01 * q.y) * (1. +\n     0.3 * (sin (24. * q.y) + sin (40. * q.y))), 4.);\n  if (d < dMin) idObj = 2;\n  dMin = min (dMin, SmoothMin (dc, d, 0.1));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (25. * a + 0.5) / 25.);\n  q.xy += vec2 (0.84, 2.);\n  d = PrCylDf (q.xzy, (0.035 + 0.02 * q.y) * (1. + 0.1 * sin (100. * q.y) *\n     (1. - smoothstep (-1., 0., p.y))), 2.);\n  if (d < dMin) idObj = 3;\n  dMin = min (dMin, SmoothMin (dc, d, 0.07));\n  return 0.7 * dMin;\n}\n\nfloat JFishRay (vec3 ro, vec3 rd)\n{\n  vec3 p, h, rdi;\n  float dHit, d;\n  ro.y -= tCur;\n  dHit = 0.;\n  rdi = 1. / (rd + 0.0001);\n  for (int j = 0; j < 250; j ++) {\n    p = ro + rd * dHit;\n    cId = floor (p / jRep);\n    h = (jRep * (cId + step (0., rd)) - p) * rdi;\n    p -= jRep * (cId + 0.5);\n    qRnd = Hashfv3 (cId);\n    d = (qRnd < 0.7 && length (cId.xz) > 2.) ? JFishDf (p) : dstFar;\n    d = min (d, abs (min (min (h.x, h.y), h.z)) + 0.1);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  vpHit = p;\n  return dHit;\n}\n\nvec3 JFishNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (JFishDf (p + e.xxx), JFishDf (p + e.xyy),\n     JFishDf (p + e.yxy), JFishDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjDf (vec3 p)\n{\n  p.xz = Rot2D (p.xz, 2. * pi * (floor (16. *\n     ((length (p.xz) > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.)) + 0.5) / 16.);\n  p.z = abs (p.z);\n  return max (PrCapsAnDf (p.xzy, 1., 0.005, 0.3),\n     SmoothMin (abs (mod (p.y, 0.2) - 0.1) - 0.003,\n     dot (p.xz, vec2 (sin (0.02 * 2. * pi / 32.), cos (0.02 * 2. * pi / 32.))), 0.003));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.00005, -0.00005, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.25, 0.4, 1.) * (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) *\n     (1. + gd * 0.05);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float k = 1.; k <= 7.; k ++) {\n    tt = t * (1. + 1. / k);\n    a1 = tt - qq;\n    a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, bg;\n  float dstObj, dstCage, a;\n  dstObj = JFishRay (ro, rd);\n  dstCage = ObjRay (ro, rd);\n  if (dstCage < min (dstObj, dstFar)) {\n    dstObj = dstCage;\n    idObj = 4;\n  }\n  bg = BgCol (rd);\n  if (dstObj < dstFar) {\n    if (idObj != 4) {\n      vn = JFishNf (vpHit);\n      a = atan (qHit.x, qHit.z);\n      col = HsvToRgb (vec3 (mod (qRnd + sin (0.2 * tCur), 1.), 0.6, 0.8));\n      if (idObj == 1) col = mix ((bg + 0.1) * (2. + vn.y), 1.2 * col,\n         SmoothBump (0.4, 0.6, 0.05, mod (4. * qHit.y +\n         sign (qRnd - 0.5) * a / pi + 0.1 * sin (8. * a) +\n         2. * tCur + qRnd, 1.)) * SmoothBump (-0.1, 0.9, 0.1, qHit.y));\n      else if (idObj == 2) col = mix (0.6 * col + 0.1, vec3 (1.),\n         SmoothBump (0.2, 0.7, 0.1, 0.5 + 0.5 * sin (qRnd +\n         3. * (1. + qRnd) * qHit.y + 4. * (1. + 0.5 * qRnd) * tCur)) *\n         SmoothBump (0.07, 0.93, 0.03, mod (0.3 * tCur + 3. * qRnd, 1.))) *\n         (1. - 0.3 * smoothstep (-2., 0., qHit.y));\n      else if (idObj == 3) col = mix (col, (bg + 0.1) * (2. + vn.y),\n         smoothstep (-0.5, 0., qHit.y));\n      col = mix (mix (bg, col, max (0., - dot (vn, rd))), bg,\n         smoothstep (0.6, 1., min (dstObj / dstFar, 1.)));\n      col += 0.3 * TurbLt (0.05 * vpHit, abs (vn), 0.3 * tCur) *\n         smoothstep (-0.3, -0.1, vn.y);\n    } else {\n      ro += dstObj * rd;\n      vn = VaryNf (500. * ro, ObjNf (ro), 0.5);\n      col = vec3 (0.6, 0.7, 0.6) * (0.2 + 0.6 * max (dot (vn, ltDir), 0.)) +\n         0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    }\n  } else col = bg;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 20.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (1. * pi * mPtr.y, -0.3 * pi, 0.3 * pi);\n  } else {\n    az = pi * (-1. + 2. * SmoothBump (0.25, 0.75, 0.25, mod (0.003 * tCur, 1.)));\n    el = 0.2 * pi * (-1. + 2. * SmoothBump (0.25, 0.75, 0.25, mod (0.019 * tCur, 1.)));\n  }\n  ro = vec3 (0., 0., -0.7);\n  zmFac = 4.2;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * ro;\n  ltDir = vuMat * normalize (vec3 (0., 2., -1.));\n  dstFar = 120.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, cHashA3)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  vec3 b;\n  float d;\n  p.z = abs (p.z);\n  b = vec3 (0.);\n  b.z = min (p.z, h + w);\n  d = length (p - b);\n  b.z = min (p.z, h - w);\n  return max (d - r, - length (p - b) + r) - w;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXfD4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[725, 725, 749, 749, 1869], [1871, 1871, 1906, 1906, 2407], [2409, 2409, 2432, 2432, 2655], [2657, 2657, 2679, 2679, 3018], [3020, 3020, 3053, 3053, 3230], [3232, 3232, 3253, 3253, 3470], [3472, 3472, 3494, 3494, 3869], [3871, 3871, 3911, 3911, 4373], [4375, 4375, 4410, 4410, 6008], [6010, 6010, 6066, 6066, 7041], [7164, 7164, 7188, 7188, 7290], [7292, 7292, 7316, 7316, 7368], [7370, 7370, 7394, 7394, 7441], [7443, 7443, 7468, 7468, 7667], [7669, 7669, 7698, 7698, 7910], [7912, 7912, 7951, 7951, 8146], [8148, 8148, 8193, 8193, 8296], [8298, 8298, 8343, 8343, 8381], [8383, 8383, 8440, 8440, 8523], [8525, 8525, 8555, 8555, 8613], [8615, 8615, 8659, 8659, 8696], [8698, 8698, 8740, 8740, 8791], [8793, 8793, 8847, 8847, 9028], [9030, 9030, 9054, 9054, 9190]], "test": "error"}
{"id": "4dXfR7", "name": "Daily 2017-05-19", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 5, "viewed": 485, "published": "Public API", "date": "1495230700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318531\n\nfloat rand(float x){return fract(sin(x)*1e4);}\nfloat rds(float x){return -1.+2.*step(.5,rand(x));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    float r=length(uv)*50.;\n    float ri=floor(r);\n    float sg=floor(10.+rand(ri)*10.0);\n    float sp=rds(ri*15.)*(.1+.4*rand(ri*70.));\n    float a=floor(fract(atan(uv.y,uv.x)/TAU+iTime*sp)*sg);\n    float c=step(.7,rand(a+ri*40.));\n    c*=smoothstep(-.9,-.85,sin(iTime*rand(ri*85.)));\n    c*=step(.2,fract(r));\n    c*=step(2.,ri)-step(20.,ri);\n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 70], [71, 71, 90, 90, 122], [124, 124, 181, 181, 611]], "test": "ok"}
{"id": "4dXfz4", "name": "Pruebas_02", "author": "ps", "description": "raymarching borrador anterior", "tags": ["raymarching"], "likes": 0, "viewed": 74, "published": "Public", "date": "1494958855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// iluminación de iq http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo paret de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\n// define el terreno (signed distanced function) dada unas coordenadas x y z devuelve si ha colisionado o no\nfloat terrainSDF (vec2 posxz){\n    float x=posxz.x;\n    float  z=posxz.y;\n    return 3.2 + 0.1*sin(20.0*x)*cos(20.0*z);\n}\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n    return terrainSDF(posxz);\n}\n// \nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = tmin;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - scene( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2  eps = vec2( 0.0001 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n    \n}\n\n\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n        //draw background\n         col = colorBackground;\n         t = -1.0;\n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos, t );\n        return vec4(nor,1.0);\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        return vec4(color,1.0);\n\n        vec3 col=color;   \n        // gamma correction (se supone que asi se ve mejor)\n        col = pow( col, vec3(1.0/2.2) );\n        //col= colorGround;\n    }\n\treturn vec4(col,t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 5.0, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,rd); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[606, 715, 745, 745, 836], [837, 905, 929, 929, 961], [962, 966, 1039, 1039, 1236], [1239, 1239, 1280, 1280, 1509], [1511, 1511, 1542, 1542, 1765], [1767, 1767, 1907, 1907, 2493], [2495, 2865, 2969, 2969, 3896], [3899, 3899, 3934, 3934, 5001], [5002, 5002, 5059, 5087, 5396]], "test": "ok"}
{"id": "4dXfzr", "name": "+++", "author": "lennyjpg", "description": "sfdgsgs", "tags": ["2d"], "likes": 1, "viewed": 406, "published": "Public API", "date": "1494536287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor , in vec2 fragCoord  )\n{\n    float t = iTime * .137;\n    vec2 v = (fragCoord  / iResolution.y - .5) * 2.;  \n    float m = mod(t * -.02 - length(v) * .137,1.);\n    if(v.y < 0.) m = mod(t*.02-length(v) * .37,1.);  \n    float n = smoothstep(m, m + 1.0, 1.) ;\n    if(v.y <  0. ) n = 1. - n;   \n    fragColor  = vec4( mix( vec3(1., .337, .11), vec3(.75, .79, .72), n), 1.);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dXfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 408]], "test": "ok"}
{"id": "4s2cDK", "name": "Space Glider", "author": "Tup", "description": "Experimenting with a way to draw planets in a \"low poly\" game. ", "tags": ["2d"], "likes": 3, "viewed": 178, "published": "Public", "date": "1493862662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float RADIUS = 0.4; // normalized window\nfloat AA     = 2.0;  // pixels\n\nvec4 SURFACE    = vec4(0.0, 0.75, 0.0, 1.0);\nvec4 SPACE      = vec4(0.0, 0.0 , 0.0, 0.0);\nvec4 ATMOSPHERE = vec4(0.0, 0.75, 1.0, 0.5);\n\nfloat DARK  = 0.5;  // Minnaert parameter\n\nfloat TERM  = 0.05; // width of terminator (as percentage of planet radius)\n\nfloat HAZE = 0.25; // radius of atmospheric haze (as percentage of planet radius)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tscale = 5.0;\n    float ct     = cos(iTime / tscale);\n    float st     = sin(iTime / tscale);\n\tvec3  LIGHT = normalize(vec3(ct, st/5.0, st));\n\n    float rez    = min(iResolution.x, iResolution.y);\n    vec2  center = iResolution.xy / 2.0;\n    vec2  v      = (fragCoord.xy - center) / rez;\n    float l      = length(v);\n    float diff   = l - RADIUS;\n\n    float pixels = AA / rez;\n    float aa     = 1.0 - smoothstep(-pixels, 0.0, diff);\n\n    vec3 n = vec3(v / RADIUS, 0.0);\n    vec4 s;\n    if (length(n) < 1.0) {\n    \tn = vec3(n.xy, sqrt(1.0 - n.x*n.x - n.y*n.y));\n    \n\t\tfloat lambert  = dot(n, LIGHT);\n\t\tfloat minnaert = pow(lambert, DARK);\n\t\tfloat toon     = smoothstep(-TERM, TERM, minnaert - 0.5);\n        \n\t    s = aa*mix(0.10*SURFACE, SURFACE, toon);\n    }\n    else {\n        s = SPACE;\n    }\n\n    vec3 p = vec3(v / RADIUS, 0.0);\n    vec4 a;\n    if (length(p) < 1.0)\n    \tp = vec3(p.xy, sqrt(1.0 - p.x*p.x - p.y*p.y));\n    else\n    \tp = normalize(p);\n\n    p = p - vec3(0.0, 0.0, RADIUS + HAZE*RADIUS);\n    \n    float haze      = smoothstep(0.0, HAZE*RADIUS, diff);\n    float backlight = dot(p, LIGHT);\n        \n\ta = clamp(backlight, 0.0, 1.0)*mix(ATMOSPHERE.w*ATMOSPHERE, SPACE, haze);\n    \n    fragColor =  s+a;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 470, 470, 1701]], "test": "ok"}
{"id": "4s2cWV", "name": "SDF Setup", "author": "kosmonaut", "description": "Circle-circle intersection test for my blog entry.\n\nOn the lower left the simple approximation is used (distance to SDF, plus sample), on the right I use the technique described in the blog with circle circle intersection to find the correct vector.", "tags": ["signeddistancefields"], "likes": 4, "viewed": 821, "published": "Public API", "date": "1494335379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define SD_POINT\n//else we have a box\n\nvec2 point = vec2(0.5f, 0.7f);\n\n/*\n\nInterpolating outside of a distance field, basic 2d setup.\n\n*/\n\nfloat sdFunc(vec2 fragPos)\n{\n\n    #ifdef SD_POINT\n    \n    return length(point * iResolution.xy - fragPos);\n    \n    #endif\n    \n    float sdf_angle = 1. + iTime / 10.;\n    \n    fragPos -= point * iResolution.xy;\n    fragPos *= mat2(cos(sdf_angle),-sin(sdf_angle),sin(sdf_angle),cos(sdf_angle)); \n    vec2 d = abs(fragPos) - vec2(110.,20.);\n \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sd = sdFunc(fragCoord);\n    \n    float thrshld = 0.4f * iResolution.y;\n    \n    float slider = (iMouse.z > 0. ? iMouse.x : 0.5 * iResolution.x) ;\n    \n    if((fragCoord.y < thrshld && fragCoord.x > slider && fragCoord.x < slider+1.) || (fragCoord.y > thrshld && fragCoord.y < thrshld + 1.))\n    {\n         fragColor = vec4(1.,0.,0.,1.);\n           return;\n    }\n    \n    if(fragCoord.x < slider)\n    {\n    \tif(fragCoord.y < thrshld) \n    \t{\n        \tsd = abs(fragCoord.y - thrshld) + sdFunc(vec2(fragCoord.x, thrshld));\n    \t}\n    }\n    else\n    {\n        if(fragCoord.y < thrshld) \n    \t{\n            \n            //let's do with circles\n            vec2 vec_to_limit = vec2(0, thrshld - fragCoord.y);\n            \n            float d = 1.;\n            vec2 p0 = vec2(fragCoord.x, thrshld);\n            vec2 p1 = vec2(fragCoord.x, thrshld + d);\n            float r0 = sdFunc(p0);\n            float r1 = sdFunc(p1);\n            \n            float h = 0.5 + (r0*r0 - r1*r1) / (2. * d*d);\n            \n            float r_i = sqrt(abs(r0*r0 - h*h*d*d));\n            \n            vec2 p2 = p0 + (p1-p0)*h;\n            \n            vec2 p3 = p2 + vec2(p1.y-p0.y, p1.x-p0.x) * r_i;\n            \n            sd = length(fragCoord - p3);\n    \t}\n    }\n    \n    fragColor = vec4( fract(sd / max(iResolution.x, iResolution.y) * 20.) );\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2cWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 169, 169, 541], [543, 543, 600, 600, 1955]], "test": "ok"}
{"id": "4s2yDt", "name": "Fire Plant", "author": "leon", "description": "Experimenting shapes and colors", "tags": ["raymarching"], "likes": 21, "viewed": 445, "published": "Public", "date": "1494380108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// training for modeling shapes\n// using koltes code as base https://www.shadertoy.com/view/XdByD3\n// using iq articles\n// using Mercury library\n// using Sam Hocevar stackoverflow answer\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\nstruct Info { float dist; vec4 color; };\nInfo info;\nmat2 rz2 (float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat lfo (float o, float s) { return .5+.5*sin(t*s+o); }\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cyli (vec3 p, float r, float h) { return max(length(p.xz)-r, abs(p.y)-h); }\nfloat iso (vec3 p, float r) { return dot(p,normalize(sign(p)))-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\nfloat scol (float a, float b, float r) { return clamp(.5+.5*(b-a)/r,0.,1.); }\nfloat smin (float a, float b, float r) { float h = scol(a,b,r); return mix(b,a,h)-r*h*(1.-h); }\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 moda (vec2 p, float c) {\n    float ca = TAU/c;\n    float a = atan(p.y,p.x)+ca*.5;\n    float ci = floor(a/ca);\n    a = mod(a,ca)-ca*.5;\n    return vec3(vec2(cos(a),sin(a))*length(p), ci);\n}\n\nfloat leaf (vec3 p, float radius, float cycle, float index, vec2 scale) {\n    p.xz *= rz2(index*.5);\n    p.xz *= scale+lfo(index*5.,1.);\n    p.y -= sin(p.z*1.5)*.3;\n    p.z -= radius;\n    p.y -= sin(abs(p.x)*3.)*.1;\n    p.y = mod(p.y,cycle)-cycle*.5;\n    return cyli(p, radius, 0.01);\n}\n\nvec3 torsade (vec3 p, float offset, float scale) {\n    p.xz *= rz2(t+offset);\n    float a = p.y * scale;\n    p.xz -= vec2(cos(a),sin(a));\n    return p;\n}\n\nfloat map (vec3 p) {\n    \n    float wave1 = lfo(p.y*.2,1.);\n    vec3 pball = p;\n    vec3 pk = p;\n    \n    p.yz *= rz2(sin(t*.5)*.5);\n    p.xz *= rz2(t*.3);\n    \n    vec3 mosaic = moda(p.xz, 7.);\n    mosaic.z *= 5.;\n    float torsadeScale = (0.1 + lfo(mosaic.z,0.)) * wave1;\n    p.xz = mosaic.xy;\n    p.x -= 8.- 4.*wave1;\n    //float cyclem = 5.;\n    //p.x = mod(p.x-t, cyclem)-cyclem*.5;\n    \n    // leaves\n    float radius = 1.*wave1;\n    float cycle = 1.;\n    float index = 0.;\n    vec2 scale = vec2(1.2,.75);\n    float offset = mosaic.z;\n    index = floor(p.y/cycle) + mosaic.z;\n   \tvec3 pleaves = torsade(p,offset, torsadeScale)+vec3(0,.5,0);\n    float leaf1 = leaf(pleaves, radius, cycle, index, scale);\n    float leaf2 = leaf(pleaves, radius, cycle, index+4., scale);\n    float leaf3 = leaf(pleaves, radius, cycle, index+8., scale);\n    float leaves = min(leaf1, min(leaf2, leaf3));\n    \n    // rod\n    vec3 p2 = torsade(p,offset, torsadeScale);\n    float rod = cyl(p2.xz, .05+.05*lfo(p.y*4.,0.));\n    \n    // ball\n    float cycleb = 1.9;\n    float cycled = 1.55;\n    float speedb = 1.;\n    float indexb = floor((pball.y+t*speedb)/cycleb);\n    pball.y = mod(pball.y+t*speedb, cycleb)-cycleb*.5;\n    pball.xz *= rz2(pball.y*.6);\n    vec3 pdots = mod(pball,cycled)-cycled*.5;\n    float ball = cyl(pball.xz, .5+5.*(1.-wave1));\n    ball = mix(max(ball, -sphere(pdots, 1.)), ball, smoothstep(.0,0.5,wave1));\n    ball = max(ball, -cyl(pball.xz, 5.*(1.-wave1)));\n    \n    // red ball\n    float redb = cyl(pball.xz, 4.*(1.-wave1));\n    \n    // iso\n    vec3 mosab = moda(pball.xz, 15.);\n    pball.xz = mosab.xy;\n    pball.x -= 4.*(1.-wave1);\n    pball.xy *= rz2(t*.3+indexb);\n    pball.yz *= rz2(t*.6+indexb*5.);\n    pball.xz *= rz2(t*.9+indexb*10.);\n    pball.y = mod(pball.y+t*5., cycleb)-cycleb*.5;\n    float iso1 = iso(pball, 0.75*(1.-wave1));\n    iso1 = max(-iso1, redb);\n    \n    // colors\n    vec4 red = vec4(hsv2rgb(vec3(.0,.9,1.)),1);\n    vec4 green = vec4(hsv2rgb(vec3(.25,.7,.8)),1);\n    vec4 green2 = vec4(hsv2rgb(vec3(.25,.5,.3)),1);\n    vec4 blue = vec4(hsv2rgb(vec3(.5,.3,.9)),1);\n    vec4 orange = vec4(hsv2rgb(vec3(.12,.5,.8)),1);\n    info.color = mix(green2, green, scol(leaves, rod, .1));\n    \n    float scene = smin(leaves, rod, .1);\n    info.color = mix(info.color, orange, scol(ball, scene, .1));\n    \n    scene = min(scene, ball);\n    info.color = mix(info.color, red, scol(iso1, scene, .1));\n    scene = min(scene, iso1);\n    \n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv,-15.-5.*lfo(0.,0.3))+vec3(0,.5,0), rd = vec3(uv,1), mp = ro;\n    int ri = 0;\n    for (int i=0;i<50;++i) {\n        ri = i;\n        float md = map(mp);\n        if (md < 0.01) {\n            break;\n        }\n        mp += rd*md*.5;\n    }\n    float l = length(mp);\n    \n    float r = float(ri)/50.;\n\tfragColor = info.color;\n    fragColor *= 1.-r;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 312, 312, 362], [363, 363, 393, 393, 420], [421, 421, 453, 453, 475], [476, 476, 505, 505, 527], [528, 528, 567, 567, 609], [610, 610, 639, 639, 677], [678, 678, 707, 707, 742], [743, 743, 783, 783, 820], [821, 821, 861, 861, 916], [917, 917, 939, 939, 1099], [1100, 1100, 1129, 1129, 1293], [1295, 1295, 1368, 1368, 1581], [1583, 1583, 1633, 1633, 1736], [1738, 1738, 1758, 1758, 4205], [4207, 4207, 4264, 4264, 4689]], "test": "ok"}
{"id": "4s2yDV", "name": "Spzktshow-MyFirstShader", "author": "spzktshow", "description": "Its My FirstShader", "tags": ["firstshader"], "likes": 0, "viewed": 458, "published": "Public API", "date": "1493883598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 1.0;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv += noise(uv); \n    float time = 0.0;\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    //p = vec3(0.0, 0.0, 1.0);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n    \n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n    \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = vec4(uv, 1.0, 1.0);\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 513, 513, 859], [861, 861, 883, 883, 963], [965, 965, 991, 991, 1292], [1294, 1306, 1344, 1344, 1386], [1387, 1387, 1433, 1433, 1537], [1539, 1546, 1572, 1572, 1661], [1663, 1670, 1711, 1711, 1882], [1884, 1884, 1903, 1903, 2347], [2349, 2349, 2377, 2377, 2821], [2823, 2823, 2886, 2886, 3381], [3383, 3394, 3429, 3429, 3620], [3622, 3622, 3678, 3678, 4190], [4192, 4192, 4249, 4249, 5061]], "test": "ok"}
{"id": "4s2yWc", "name": "Watermelons Floating Around", "author": "Koltes", "description": "Done in 30 minutes during the shader showdown at Leon[https://www.shadertoy.com/user/leon]'s place.", "tags": ["shadershowdown", "30minutes"], "likes": 7, "viewed": 709, "published": "Public API", "date": "1494145604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nstruct M{float d;vec3 c;};\nM m;\n\nvoid map(vec3 p){\n    p.xy*=rz2(iTime*.03);\n    p.yz*=rz2(iTime*.05);\n    p.xy*=rz2(iTime*.07);\n    vec3 q=mod(p+2.5,5.)-2.5;\n    vec3 f=floor((p-2.5)/5.);\n    p=q;\n    p.xy*=rz2(f.x+iTime);\n    p.yz*=rz2(f.y+iTime);\n    p.zx*=rz2(f.z+iTime);\n    float d1=length(p)-1.;\n    float a=atan(p.y,p.x);\n    float d2=min(1.,abs(a)-(0.5+sin(iTime*10.)*.2))*length(p.xy);\n    m.d=max(d1,d2);\n    m.c=mix(vec3(1.,0.3,0.3),vec3(0.6,1.,0.6),smoothstep(.75,.85,length(p)));\n    m.c=mix(m.c,vec3(0.,0.3,0.1),smoothstep(0.95,1.,length(p)));\n    float mb=6.2831853/16.;\n    float b=mod(atan(p.z,p.y),mb)-.5*mb;\n    m.c=mix(vec3(0.),m.c,smoothstep(.18,.22,length(vec2(b*3.,length(p.xz)-0.2))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(uv,-2.),rd=vec3(uv,1.),mp=ro;\n    int i;\n    for (i=0;i<50;++i){\n        map(mp);\n        m.d*=.5;\n        if(abs(m.d)<.001)break;\n        mp+=rd*m.d;\n    }\n    float ma=1.-float(i)/50.;\n    vec3 c=m.c*ma;\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [100, 100, 117, 117, 779], [781, 781, 838, 838, 1188]], "test": "ok"}
{"id": "4sBcD3", "name": "Fungi Path", "author": "lherm", "description": "Yah.", "tags": ["raymarch"], "likes": 7, "viewed": 763, "published": "Public API", "date": "1493993462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PSD pow(textureLod(iChannel0, vec2(.5), 0.).r, 1.)\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f-=f;\n    float x = 1., i=x, T=iTime, l;\n\tvec2 R = iResolution.xy;\n    vec4 p = vec4((g+g-R)/R.y, .5, 0), d=p;\n    p.y -= 5.; p.z -= T+T;\n    p *= .5;\n    for (; i > 0. && x > 1e-3; i-= .02)\n        x = length(cos(p.wxw)-cos(p.yzw))-PSD*.5,\n        f = i*i*vec4(l=distance(p, p-p), 1./l*l, abs(p.y), 1.),\n        p -= d*x*.5;\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sBcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 100, 100, 432]], "test": "error"}
{"id": "4sBcWd", "name": "slidinn'", "author": "lennyjpg", "description": "same story, no buffers", "tags": ["2d"], "likes": 5, "viewed": 516, "published": "Public API", "date": "1494282775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.y, s = vec2(.0),c = vec2(.0);\n    float sp = (sin(iTime*0.01)+1.0)*0.5;\n    sp *= 0.05;\n    sp += 0.0001;\n    float tt = iTime * sp;\n\n    tt += fract(sin(uv.x+1.0))*2.0;\n    float e = 1.0+sin(uv.x*3.0)*2.6;\n    float k =  cos(tt-e) + 7.0;\n    vec4 ok = vec4( abs( cos(tt + sin(0.5 * tt + (uv.x+tt*0.001) * k) ) ));\n\n    vec3 pixel = vec3(1.3);\n    float t = iTime * 0.037,d = 0.0,r = 0.0;\n\n    for(float i=0.0; i < 50.0; i+=1.0) {\n       s = vec2(t + fract(sin(i*0.9)*37.0),t + fract(cos(i*2.5)*37.0));\n       c.x = fract(cos(i*42.91 + s.x)*2.751) * 5.0 - 2.0;\n       c.y = fract(sin(i*13.44 + s.y)*1.387) * 4.0 - 2.0;\n        r = fract(sin((i*0.6))*5.0) * 0.67;\n       c += ok.xy*vec2(0.3,-0.1);\n       d = length(uv - c);\n       pixel[int( mod(i,3.0))] -= smoothstep(d*0.05,d,r*r)*0.87;\n        \n        \n       c.x = fract(cos(i*122.91 + s.x)*0.1751) * 5.0 - 2.0;\n       c.y = fract(sin(i*73.44 + s.y)*0.387) * 4.0 - 2.0;\n       r = fract(sin((i*0.4)+1.0)*0.2) * 0.00167;\n       c += ok.xy*vec2(0.1,0.1);\n       d = length(uv - c);\n       pixel[int( mod((i+1.0),3.0))]-= smoothstep(d*0.000000005,d,r)*0.537;\n        \n        \n    }\n\n    fragColor = vec4(pixel.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sBcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1276]], "test": "ok"}
{"id": "4sByWt", "name": "utyut", "author": "moeein", "description": "ghjk", "tags": ["tyu6yunyuiyuiynuiyu"], "likes": 2, "viewed": 411, "published": "Public API", "date": "1494244722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    uv.x -= 0.5;\n    uv.y -= iResolution.y/iResolution.x/2.0;\n    uv *= 4.0;\n    vec2 mv = iMouse.xy / iResolution.x;\n    mv.x -= 0.5;\n    mv.y -= iResolution.y/iResolution.x/2.0;\n    mv *= 4.0;\n  \tfloat c = 1.0/distance(uv,mv);\n    c += 1.0/length(uv);\n    vec2 coord = vec2(sin(iTime),cos(iTime));\n    c += 1.0/distance(uv,coord);\n    coord = vec2(sin(-iTime),cos(-iTime));\n    c += 1.0/distance(uv,coord);\n    float n;\n    if(mod(iTime/4.0,2.0) < 1.0) {\n    \tn = mod(iTime/2.0,2.0);\n    } else {\n    \tn = (mod(2.0-iTime/2.0,2.0));\n    }\n    n -= 1.0;\n    n *= 2.0;\n    coord = vec2(n,0.0);\n    c += 1.0/distance(uv,coord);\n    c /= 20.0;\n\tfragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sByWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 773]], "test": "ok"}
{"id": "4sfBWn", "name": "Daily 2017-05-23", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 11, "viewed": 551, "published": "Public API", "date": "1495542693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318531\n#define rand(x) fract(sin(x)*1e4)\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nvec3 cam(vec3 p){\n    p.yz*=rz2(sin(iTime*.5)*.2);\n    p.xz*=rz2(iTime*.3);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v=uv*(1.-uv);\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=cam(vec3(uv,-3.)),rd=cam(normalize(vec3(uv,1.)));\n    float c=0.;\n    for(int i=0;i<64;++i){\n        float f=float(i);\n        float a=rand(f)*TAU;\n        float r=rand(f)+rand(f+2.);\n        r=min(r,2.-r);\n        float y=mod(rand(f+3.)*3.-iTime*.1, 3.)-1.5;\n        vec3 p=vec3(r*cos(a),y,r*sin(a));\n        vec3 rop=ro-p;\n        float d=length(rop-dot(rop,rd)*rd);\n        c+=.02*rand(f+5.)/d*min(1.,(1.5-abs(y))*10.);\n    }\n    vec3 clr=vec3(.2,.4,1.)*c;\n    clr=pow(clr,vec3(1./2.2))*pow(v.x*v.y * 25.0, 0.25);\n\tfragColor = vec4(clr,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 75, 75, 122], [124, 124, 141, 141, 215], [217, 217, 274, 274, 948]], "test": "ok"}
{"id": "4sfBz4", "name": "filip II", "author": "srtuss", "description": "Recreation of movAX13h's \"filip\" fragment shader effect.\n\nFullscreen looks best!", "tags": ["raytracing", "planes", "quads", "atmospheric"], "likes": 6, "viewed": 330, "published": "Public", "date": "1494955101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// recreation of the \"filip\" fragment shader, as a raytracer\n// written from scratch\n//\n// original shader idea and wonderful music by movAX13h:\n// https://www.shadertoy.com/view/4ssfzn\n//\n//\n\nvec2 rotate(vec2 p, float a)\n{\n    float co = cos(a), si = sin(a);\n    return p * mat2(co, si, -si, co);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(989253. * sin(205.124 * dot(p, vec2(.1, 33.))));\n}\n\n// the floor texture\nfloat map0(vec2 uv)\n{\n    return hash(floor(uv));\n}\n\nfloat particles(out vec3 col, vec3 ro, vec3 rd, float time)\n{\n    float tm = 1e38;\n    vec3 add = vec3(0.);\n    \n    for(int i = 0; i < 100; ++i)\n    {\n        mat3 mp = mat3(1., 0., 0., 0., 1., 0., 0., 0., 1.);\n        \n        float pt = -time * 2. + float(i) * 0.06 + sin(float(i)) * .3;\n        \n        vec3 pos = vec3(\n            sin(pt * .2) * sin(pt * .4) * 4.,\n            abs(sin(pt * 1.5) * sin(pt * .5)) + .01,\n            cos(pt * .3) * 2.);\n        \n        float rt = pt * 2. + sin(float(i));\n        \n        float c0 = cos(rt), s0 = sin(rt);\n        mp *= mat3(1., 0., 0., 0., c0, -s0, 0., s0, c0);\n        float c1 = cos(rt), s1 = sin(rt);\n        mp *= mat3(c1, 0., s1, 0., 1., 0., -s1, 0., c1);\n        \n        float t = -dot(ro - pos, mp[2]) / dot(rd, mp[2]);\n        \n        if(t > 0.)\n        {\n            vec3 vsun = normalize(vec3(.2, 1., .4));\n            \n            vec3 hit = (ro - pos) + rd * t;\n            vec2 quv = vec2(dot(hit, mp[0]), dot(hit, mp[1]));\n            \n            vec3 ref = reflect(rd, mp[2]);\n            \n            float l = max(dot(mp[2], vsun), 0.) + pow(max(dot(ref, vsun), 0.), 64.);\n            \n            float size = fract(sin(float(i) * 124.123) * 12415.25323) * .1 + .001;\n            \n            float df = smoothstep(0., 0.01, max(abs(quv.x), abs(quv.y)) - size);\n            \n            col = mix(vec3(1.) * l * .5, col, df);\n            \n            //col += exp(length(quv) * -10.) * vec3(0.5, 0., 0.);\n        }\n        \n        if(i == 0)\n        {\n            float to = 1. - dot(rd, normalize(pos - ro));\n            add += vec3(1., 0.4, 0.3) * exp(to * -100.);\n        }\n        \n        tm = min(tm, t);\n    }\n    col += add;\n    return tm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    float icst = floor(iTime / 10.);\n    float cst = fract(iTime / 10.);\n    \n    float shut = smoothstep(1., .9, cst) * smoothstep(0., .1, cst);\n    \n    vec3 ro = vec3(0., .5 + sin(iTime * .7) * .3, -2.);\n    vec3 rd = normalize(vec3(uv, 1.66));\n    \n    float pn = sin(icst) * iTime * 0.3;\n    float tt = 0.;//step(.8, sin(icst));\n    \n    ro.xz = rotate(ro.xz, pn);\n    rd.xz = rotate(rd.xz, pn);\n    \n    ro.yx = rotate(ro.yx, tt);\n    rd.yx = rotate(rd.yx, tt);\n    \n\n    ro.x += cst * 2.;\n    \n    vec3 sky = vec3(abs(1. - rd.y));\n    \n    vec3 col = sky;\n    \n    float t = -ro.y / rd.y;\n    vec3 hit = ro + rd * t;\n    \n    if(t > 0.)\n    {\n        vec2 tuv = hit.xz * 3.;\n        vec2 dx = dFdx(tuv), dy = dFdy(tuv);\n    \tcol = vec3(.25) * (\n            map0(tuv) +\n            map0(tuv + dx * .5) +\n            map0(tuv + dy * .5) +\n            map0(tuv + dy * .5 + dx * .5));\n        \n        col = col * .5;\n        \n        col = mix(sky, col, exp(t * -.04));\n        \n        vec3 ref = reflect(rd, vec3(0., 1., 0.));\n        \n        ref += (sin(hit.x * 30.) + sin(hit.z * 10.)) * .002;\n        \n        vec3 colr;\n        particles(colr, hit, ref, iTime * .5);\n        \n        col += colr * .5;\n    }\n    \n    particles(col, ro, rd, iTime * .5);\n    \n    \n    col *= texture(iChannel1, uv * .1 + vec2(pn * 0.2, iTime * -.01)).x * .2 + .8;\n    \n    col *= shut;\n    \n    col *= step(abs(uv.y) - .7, 0.);\n    \n    col *= (1. - pow(abs(uv.x * .2), 2.)) * (1. - pow(abs(uv.y * .6), 2.));\n    \n    //col = pow(col, vec3(3.)) * 3.;\n    //col = pow(col, vec3(1. / 2.2));\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}, {"id": "lssSzH", "previewfilepath": "https://soundcloud.com/filipsound/filip-wooden-rocks", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/filipsound/filip-wooden-rocks", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sfBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 226, 226, 302], [304, 304, 324, 324, 392], [394, 415, 436, 436, 466], [468, 468, 529, 529, 2194], [2196, 2196, 2253, 2253, 3989]], "test": "error"}
{"id": "4slBWN", "name": "fake water caustics v3", "author": "Emil", "description": "Third attempt at doing fake under water caustics\n\nEarlier attempts:\nhttps://www.shadertoy.com/view/XdlBWN <- v2\nhttps://www.shadertoy.com/view/XdlBD4 <- v1", "tags": ["2d", "water", "caustics"], "likes": 20, "viewed": 1341, "published": "Public", "date": "1496241467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float timeSpeed = 2.0;\n\nfloat randomVal (float inVal)\n{\n    return fract(sin(dot(vec2(inVal, 2523.2361) ,vec2(12.9898,78.233))) * 43758.5453)-0.5;\n}\n\nvec2 randomVec2 (float inVal)\n{\n    return normalize(vec2(randomVal(inVal), randomVal(inVal+151.523)));\n}\n\nfloat makeWaves(vec2 uv, float theTime, float offset)\n{\n    float result = 0.0;\n    float direction = 0.0;\n    float sineWave = 0.0;\n    vec2 randVec = vec2(1.0,0.0);\n    float i;\n    for(int n = 0; n < 16; n++)\n    {\n        i = float(n)+offset;\n        randVec = randomVec2(float(i));\n  \t\tdirection = (uv.x*randVec.x+uv.y*randVec.y);\n        sineWave = sin(direction*randomVal(i+1.6516)+theTime*timeSpeed);\n        sineWave = smoothstep(0.0,1.0,sineWave);\n    \tresult += randomVal(i+123.0)*sineWave;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    vec2 uv2 = uv * 150.0; // scale\n    \n    uv *= 2.0;\n    /*\n    uv2 *= (0.9+iMouse.y*0.01);\n    uv *= (0.9+iMouse.y*0.01);\n\t*/\n    \n    float result = 0.0;\n    float result2 = 0.0;\n    \n    result = makeWaves( uv2+vec2(iTime*timeSpeed,0.0), iTime, 0.1);\n    result2 = makeWaves( uv2-vec2(iTime*0.8*timeSpeed,0.0), iTime*0.8+0.06, 0.26);\n    \n    //result *= 2.6;\n    \n    result = smoothstep(0.4,1.1,1.0-abs(result));\n    result2 = smoothstep(0.4,1.1,1.0-abs(result2));\n    \n    result = 2.0*smoothstep(0.35,1.8,(result+result2)*0.5);\n    \n\t//fragColor = vec4(result)*0.7+texture( iChannel0 , uv );\n    \n    // thank for this code below Shane!\n    vec2 p = vec2(result, result2)*.015 + sin(uv*16. - cos(uv.yx*16. + iTime*timeSpeed))*.015; // Etc.\n\tfragColor = vec4(result)*0.7+texture( iChannel0 , uv + p );\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 55, 55, 148], [150, 150, 181, 181, 255], [257, 257, 312, 312, 785], [787, 787, 844, 844, 1703]], "test": "error"}
{"id": "4slfzH", "name": "Fractal Experiment 28", "author": "aiekick", "description": "Fractal Experiment 28", "tags": ["2d", "fractal", "experiment", "28"], "likes": 8, "viewed": 480, "published": "Public API", "date": "1494874732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvec2 zmul(vec2 a, vec2 b){return mat2(a,-a.y,a.x)*b;} // z * z \nvec2 zinv(vec2 a){return vec2(a.x, -a.y) / dot(a,a);} // 1 / z\n\nconst float AA = 2.;\n    \nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f = vec4(0);\n    \n\tvec2 si = iResolution.xy;\n        \n    for( float m=0.; m<AA; m++ )\n    for( float n=0.; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n) / AA - .5;\n        vec2 z = ((g+o)*2.-si)/min(si.x,si.y) * 2.2;\n        vec2 c = vec2(.924,0);\n\t\tc.y = sin(iTime) * .03;\n        float it = 0.;\n        vec2 zo = z;\n        for (int i=0;i<30;i++)\n        {\n            zo = z;\n            z = zinv( .48 * zmul(z, z) - c);\n\t\t\tif( dot(z,z) > 8. ) break;\n            it++;\n        }\n\n        float d = max(abs(z.x),abs(z.y));\n\t\tf += .5 + .5 * sin( 3. + (it - 1. + fract(cos(d)*sin(d))) * 2. + vec4(1,0,1,1));\n    }\n    \n    f /= AA * AA;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4slfzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[214, 214, 240, 240, 267], [268, 278, 296, 296, 331], [368, 368, 409, 409, 1052]], "test": "ok"}
{"id": "4sScDt", "name": "Ring, ring", "author": "DonKarlssonSan", "description": "ring", "tags": ["ring"], "likes": 0, "viewed": 74, "published": "Public", "date": "1494268021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{ \n\tvec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x;\n    vec2 c = vec2(0.0, 0.0);\n    float radius = length(uv) * 2.0 + iTime/10.0;\n\n    float a = mod(radius, 0.1);\n    \n    float blend = smoothstep(0.02, 0.03, a) * (1.0 - smoothstep(0.07, 0.08, a));\n        \n\tfragColor = vec4(blend, 0.0, blend, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sScDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 373]], "test": "ok"}
{"id": "4sScDV", "name": "My first cube with phong shading", "author": "loolo78", "description": "https://www.shadertoy.com/view/Xtd3z7 Thanks to this tutorial", "tags": ["sdf"], "likes": 4, "viewed": 241, "published": "Public", "date": "1493782642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Tutorial used: https://www.shadertoy.com/view/lt33z7\n    I rewrote everything for practice.\n*/\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST         = 0.0;\nconst float MAX_DIST         = 100.0;\nconst float EPSILON          = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat boxSDF( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p)\n{\n    return boxSDF(p, vec3(0.5));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phoneContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                            vec3 lightPos, vec3 lightIntensity)\n{ \n    vec3 N = estimateNormal(p); // Estimate normal of surface\n    vec3 L = normalize(lightPos - p); // Point from point on surface to light\n    vec3 V = normalize(eye - p); // Viewing vector, used to diffuse reflected light\n    vec3 R = normalize(reflect(-L, N)); // Reflect light to the normal\n\n    float dotLN = dot(L,N); // cosine angle between light direction and normal direction\n    float dotRV = dot(R,V); // cosine angle between reflection direction and viewing direction\n    \n    // Light is coming from behind the normal of the face, pitch black\n    if (dotLN < 0.)\n    {\n        return vec3(0.0);\n    }\n    // Reflected light points away from the camera, so there are no direct light. Only ambient light and diffuse color\n    if (dotRV < 0.)\n    {\n        // This value maxes when dotLN = 1, which is when L(light) and N(normal) are equal. 100% of the light is reflected back\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    }\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 globalAmbentLight = 0.9 * vec3(1.);\n    vec3 color = globalAmbentLight * k_a; // Multiply brightness by color to get ambient color\n\n    // Light 1\n    vec3 light1Pos = vec3(0.,1.,3.);\n    vec3 light1Insentity = vec3(0, 67.1/100., 43.5/100.);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Insentity);\n\n\n    // Light 2\n    vec3 light2Pos = vec3(-1.,-1.,1.);\n    vec3 light2Insentity = vec3(100./100., 59.2/100., 0);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Insentity);\n\n    // Light 3\n    vec3 light3Pos = vec3(-0.5,2,-3.);\n    vec3 light3Insentity = vec3(4.7/100., 35.3/100., 65.1/100.);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light3Pos, light3Insentity);\n\n    return color;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    // Start depth\n    float depth = start;\n    // Keep looking for where the marching ray hits a surface\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        // Get the distance from marching ray point to surface of box\n        float dist = sceneSDF(eye + marchingDirection * depth);\n        // If we've hit near the surface, return this distance\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        // Didn't find anything, let's go to where we found something\n        depth += dist;\n        // We're at the end, stop\n        if (depth > end)\n        {\n            return end;\n        }\n    }\n    // Ran out of steps before we hit the end, just return end\n    return end;\n}\n\n/**\n    fov:         Field of View of camera\n    screen_size: Screen size\n    fragCoord:   Screen coord of pixel\n    return:      Direction of rendering ray of the projection camera\n */\nvec3 rayDirection(float fov, vec2 screen_size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - screen_size / 2.0;\n    float z = (screen_size.y / 2.) / tan(radians(fov) / 2.);\n    return normalize(vec3(xy,-z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 lookAtMatrix(vec3 eye, vec3 center, vec3 up) \n{\n    // Based on gluLookAt man page\n    // Forward/Look at vector\n    vec3 f = normalize(center - eye);\n    // Right vector\n    vec3 v = normalize(cross(f, up));\n    // Camera local up Vector\n    vec3 u = cross(v, f);\n    return mat3(\n        vec3(v),\n        vec3(u),\n        vec3(-f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_space_dir = rayDirection(60., iResolution.xy, gl_FragCoord.xy);\n    vec3 eye = \n        vec3(\n            cos(iTime*2.) * 1.,\n            cos(iTime) * 1.,\n            (sin(iTime)+2.) * 1.\n            );\n\n   vec3 world_space_dir = lookAtMatrix(eye, vec3(0.), vec3(0,1,0)) * camera_space_dir;\n    // Find shortest distance surface\n    float dist = shortestDistanceToSurface(\n        eye,\n        world_space_dir, \n        MIN_DIST, \n        MAX_DIST);\n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.07);\n        return;\n    }\n\n    // We've hit a surface\n    // Phong shading time!!\n    // Surface point\n    vec3 p = eye + dist * world_space_dir;\n\n    vec3 K_ambientColor = vec3(0.2, 0.2, 0.2);\n    vec3 K_diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 K_specularColor = vec3(1.0, 1.0, 1.0);\n    float shineness = 20.0;\n\n    vec3 color = phongIllumination(K_ambientColor, K_diffuseColor, K_specularColor, shineness, p, eye);\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sScDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 343, 375, 375, 415], [417, 657, 681, 681, 716], [718, 718, 747, 747, 1057], [1059, 1551, 1693, 1693, 2709], [2711, 3081, 3166, 3166, 3942], [3944, 4365, 4456, 4475, 5171], [5173, 5359, 5423, 5423, 5563], [5565, 5892, 5944, 6009, 6238], [6240, 6240, 6297, 6297, 7285]], "test": "ok"}
{"id": "4ssfRM", "name": "Stolen iq Metaballs", "author": "evilliam", "description": "Metaballs, for vb", "tags": ["metaballs", "iq", "stolen"], "likes": 2, "viewed": 114, "published": "Public", "date": "1495530375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2014 Liam Walsh\n// Taken from Inigo's example\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\n   // anim\n    vec2 c1 = 0.4*sin( iTime*1.0 + vec2(4.0,0.5) + 6.0);\n    vec2 c2 = 0.2*sin( iTime*1.3 + vec2(2.0,1.0) + 2.0);\n    vec2 c3 = 0.3*cos( iTime*1.5 + vec2(0.5,0.1) + 4.0);\n    vec2 c4 = 0.1*sin( iTime*1.8 + vec2(2.0,2.0) + 8.0);\n    vec2 c5 = 0.4*cos( iTime*2.3 + vec2(1.2,1.1) + 3.0);\n    vec2 c6 = 0.2*sin( iTime*1.1 + vec2(0.9,0.3) + 1.0);\n    \n   \n   // potential (4 metaballs)\n    float v = 0.0;    \n    v += 1.0-smoothstep(0.0,0.3,length(uv-c1));\n    v += 1.0-smoothstep(0.0,0.4,length(uv-c2));\n    v += 1.0-smoothstep(0.0,0.3,length(uv-c3));\n    v += 1.0-smoothstep(0.0,0.29,length(uv-c4));\n    v += 1.0-smoothstep(0.0,0.33,length(uv-c5));\n    v += 1.0-smoothstep(0.0,0.21,length(uv-c6));\n    \n   // color    \n    //vec3 col = mix( vec3(v), vec3(1.0,0.6,0.0), smoothstep(0.9,0.91,v) );\n    vec3 col = mix( vec3(v), vec3(0.9,0.7,0.0), smoothstep(0.1,0.1,v) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssfRM.jpg", "access": "shaders20k", "license": "mit", "functions": [[83, 83, 140, 140, 1119]], "test": "ok"}
{"id": "4ssfRN", "name": "Dancing Sea", "author": "Zacland", "description": "Reprise de TDM - https://www.shadertoy.com/view/Ms2SD1", "tags": ["sound", "wave", "sea"], "likes": 4, "viewed": 179, "published": "Public", "date": "1495120216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1416;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 30;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\n\n//const vec3 SEA_BASE = vec3(0.9,0.1,0.1);\n//const vec3 SEA_WATER_COLOR = vec3(0.6,0.1,0.8);\n\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4);\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    //float amp = SEA_HEIGHT;\n    float amp = texture(iChannel0, vec2(.02, .25)).r*1.5;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    //float amp = SEA_HEIGHT;\n    float amp = texture(iChannel0, vec2(.02, .25)).r*1.5;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssfRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[758, 766, 792, 792, 1138], [1139, 1139, 1161, 1161, 1241], [1242, 1242, 1268, 1268, 1569], [1571, 1583, 1621, 1621, 1663], [1664, 1664, 1710, 1710, 1814], [1816, 1823, 1849, 1849, 1938], [1940, 1947, 1988, 1988, 2159], [2161, 2161, 2180, 2180, 2684], [2686, 2686, 2714, 2714, 3218], [3220, 3220, 3283, 3283, 3778], [3780, 3791, 3826, 3826, 4017], [4019, 4019, 4075, 4075, 4587], [4589, 4597, 4654, 4654, 5480]], "test": "error"}
{"id": "4ssfW8", "name": "Daily 2017-05-28", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 7, "viewed": 510, "published": "Public API", "date": "1495971906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rand(x) fract(sin(x)*1e4)\n\nfloat rd(vec2 p, float x) {\n    p.x=mod(p.x,x);\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 uv, float x) {\n    vec2 iuv=floor(uv),\n        fuv=smoothstep(0.,1.,fract(uv)),\n        oi=vec2(0.,1.);\n    float n00=rd(iuv,x),\n        n01=rd(iuv+oi.xy,x),\n        n10=rd(iuv+oi.yx,x),\n        n11=rd(iuv+oi.yy,x);\n    return mix(\n        mix(n00,n10,fuv.x),\n        mix(n01,n11,fuv.x),\n        fuv.y);\n}\n\nvec3 hsv(vec3 c) {\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float d=length(uv);\n    vec3 cex=vec3(0.);\n    for(float f=0.;f<6.;++f){\n\t\tvec3 r=rand(f+vec3(0.,3.,5.));\n        float x=10.+10.*f;\n        float a=atan(uv.y,uv.x)/6.28318531*x+(r.z-.5)*iTime;\n        float n=noise(vec2(a,iTime*r.x),x);\n        cex+=.1*n/d*hsv(vec3(r.y,.5,1.));\n    }\n    vec3 c=mix(vec3(.1-d*.2),cex,smoothstep(.2,.21,d));\n\tfragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 62, 62, 150], [152, 152, 183, 183, 474], [476, 476, 494, 494, 629], [631, 631, 688, 688, 1154]], "test": "ok"}
{"id": "4ssfzn", "name": "filip", "author": "movAX13h", "description": "This is just a string of time made visible with light in the form I chose.", "tags": ["2d"], "likes": 26, "viewed": 3824, "published": "Public API", "date": "1494625042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// filip fragment shader and music by movAX13h, May 2017\n// supersampling added by srtuss\n\nfloat rand( float n )\n{\n  \treturn fract(cos(n)*4145.92653);\n}\n\nfloat noise(vec2 p)\n{\n  \tvec2 f  = smoothstep(0.0, 1.0, fract(p));\n  \tp  = floor(p);\n  \tfloat n = p.x + p.y*57.0;\n  \treturn mix(mix(rand(n+0.0), rand(n+1.0),f.x), mix( rand(n+57.0), rand(n+58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n\tmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\t\n  \tfloat f = 0.5000*noise( p ); p = m2*p;\n  \tf += 0.2500*noise( p ); p = m2*p;\n  \tf += 0.1666*noise( p ); p = m2*p;\n  \tf += 0.0834*noise( p );\n  \treturn f;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\nfloat dir(vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\n}\n\nbool insideQuad(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\tbool b1 = dir(p, a, b) < 0.0;\n\tbool b2 = dir(p, b, c) < 0.0;\n\tbool b3 = dir(p, c, d) < 0.0;\n\tbool b4 = dir(p, d, a) < 0.0;\n  \treturn ((b1 == b2) && (b2 == b3) && (b3 == b4));\n}\n\nfloat background(vec2 uv)\n{\n    float i = smoothstep(0.0, 0.5, 0.1-uv.y);\n    float z = 0.3 - uv.y;\n    \n    uv.x = (0.2*uv.x - 0.1) / z;\n    uv.y = (1.9*uv.y - 0.3) / z;\n    \n    i *= smoothstep(-0.8, 0.2, uv.x);\n    \n    float n = iResolution.x / 24.0;    \n    vec2 g = floor(uv * n) / n;\n    \n    return 1.0 - 0.8 * i * fbm(g * 80.0);    \n}\n\nfloat seg(float id, vec2 p, float time)\n{\n    float t = 0.8*time - 0.18 * id;\n    float s = 0.022;\n    float r = t + 6.283 * rand(id);\n    float z = 1.0+0.3*sin(t*0.6) + 0.3*sin(t*1.9);\n    \n    p.x /= z;\n    p.y /= z;\n\n    vec2 q = p;\n    q.y = abs(q.y + 0.2) - 0.33;\n    \n    vec2 pos = vec2(0.5 * sin(t) + 0.4*sin(t*1.6), \n                    0.2 * abs(sin(2.2*t)) - 0.3);\n    \n    vec2 scale = vec2(sin(t*3.0), cos(t*3.0));\n    \n    vec2 a = rotate(scale*vec2(-s, -s), r) + pos;\n    vec2 b = rotate(scale*vec2( s, -s), r) + pos;\n    vec2 c = rotate(scale*vec2( s,  s), r) + pos;\n    vec2 d = rotate(scale*vec2(-s,  s), r) + pos;\n    \n    return insideQuad(q, a, b, c, d) ? 0.1 + 0.6 *step(0.0, p.y+0.2) : 0.0;\n}\n\nvec2 worm(vec2 uv, float time)\n{\n    for(int i=0; i < 15; i++)\n    {\n        float s = seg(float(i), uv, time);\n        if (s > 0.0) return vec2(s, step(float(i), s-0.5));        \n    }\n    \n    return vec2(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    for(int i = 0; i < 2; ++i)\n    {\n        for(int j = 0; j < 2; ++j)\n        {\n            vec2 uv = 2.0 * ((fragCoord.xy + vec2(j, i) * 0.5) / iResolution.xy) - 1.0;\n    \t\tuv.x *= iResolution.x / iResolution.y;\n            \n            vec3 col = vec3(1.0);\n    \n            float time = iTime + mod(iTime, 0.01);\n            \n            col *= background(uv);\n            vec2 w = worm(uv, time);\n            col -= w.x;\n            col = mix(col, vec3(1.0, 0.0, 0.0), w.y);\n\n            col *= smoothstep(0.48, 0.481, 1.0-abs(uv.y));\n            col -= 0.6*smoothstep(0.3,2.0,length(uv));\n            col -= vec3(0.01, 0.01, 0.0);\n            col = clamp(col, 0.0, 1.0);\n            fragColor.xyz += col;\n        }\n    }\n    fragColor /= 4.0;\n}", "image_inputs": [{"id": "MsXSzH", "previewfilepath": "https://soundcloud.com/filipsound/filip-wooden-rocks", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/filipsound/filip-wooden-rocks", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ssfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 114, 114, 152], [154, 154, 175, 175, 361], [363, 363, 384, 384, 578], [580, 580, 610, 610, 696], [698, 698, 733, 733, 798], [800, 800, 857, 857, 1035], [1037, 1037, 1064, 1064, 1380], [1382, 1382, 1423, 1423, 2097], [2099, 2099, 2131, 2131, 2313], [2315, 2315, 2372, 2372, 3156]], "test": "ok"}
{"id": "4sSyDd", "name": "Smoke Rings", "author": "leon", "description": "Experimenting shapes", "tags": ["raymarching", "smoke"], "likes": 49, "viewed": 1192, "published": "Public API", "date": "1494288776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// training for modeling shapes\n// using koltes code as base https://www.shadertoy.com/view/XdByD3\n// using iq articles\n// using mercury library\n\n#define PI 3.1415926535897932384626433832795\n#define TAU 6.283185307179586476925286766559\n#define t iTime\n\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat iso (vec3 p, float r) { return dot(p, normalize(sign(p)))-r; }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat map (vec3 p)\n{\n    float sph3 = sphere(p, 3.);\n    p.yz *= rz2(t*.2);\n    p.xy *= rz2(t*.3);\n    \n    float d = length(p);\n    \n    float a = atan(p.y,p.x);\n    float l = length(p.xy)-2.;\n    p.xy = vec2(l,a);\n    \n    float as = PI*0.3;\n    p.z += sin(a*2.+sin(l*4.))*.5;\n    \n    float wave1 = sin(p.y*6.)*.5+.5;\n    float wave2 = .5+.5*sin(p.z*3.+t);\n    \n    p.x -= sin(p.z*1.+t)*.5;\n    p.z = mod(p.z+t,as)-as*.5;\n    \n    float sphR = .2-.1*wave1;\n    float sphC = .3;\n    float sphN = 0.2;\n    float sph1 = sphere(vec3(p.x,mod(sphN*p.y/TAU+t*.1,sphC)-sphC*.5,p.z), sphR);\n    \n    p.xz *= rz2(p.y*3.);\n    p.xz = modA(p.xz, 3.);\n    p.x -= 0.3*wave2;\n    float cyl1 = cyl(p.xz, 0.02);\n    float sph2 = sphere(vec3(p.x,mod(p.y*2.-t,1.)-.5,p.z), .1);\n    \n    return smin(sph1, smin(cyl1,sph2,.2), .2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv,-5), rp = vec3(uv,1), mp = ro;\n    int i = 0;\n    const int count = 50;\n    for(;i<count;++i) {\n\t\tfloat md = map(mp);\n        if (md < 0.001) {\n            break;\n        }\n        mp += rp*md*.35;\n    }\n    float r = float(i)/float(count);\n    fragColor = vec4(1);\n    fragColor *= smoothstep(.0,10.,length(mp-ro));\n  \tfragColor *= r;\n    fragColor = 1. - fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sSyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 273, 273, 324], [325, 325, 357, 357, 379], [380, 380, 409, 409, 448], [449, 449, 478, 478, 500], [501, 501, 530, 530, 565], [566, 566, 599, 599, 730], [731, 731, 771, 771, 853], [855, 855, 875, 875, 1670], [1672, 1672, 1729, 1729, 2183]], "test": "ok"}
{"id": "4sSyWK", "name": "Daily 2017-05-02", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 3, "viewed": 400, "published": "Public API", "date": "1493728350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 ro,rd,mp;\nfloat d;\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n/*\nfloat map(vec3 p){\n    p.xz*=rz2(p.y*2.);\n    mat2 r=rz2(iTime);\n    p.xy*=r;p.yz*=r;\n    p.x-=1.;\n    return length(p.xz)-.5;\n}\n*/\nfloat map(vec3 p){\n    p.xy*=rz2(iTime*.5);p.yz*=rz2(iTime*.7);\n    p.xz+=rz2(p.y*2.*sin(iTime))*vec2(1.,0.);\n    return length(p.xz)-.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    ro=vec3(uv,-10.);\n    rd=normalize(vec3(uv,1.));\n    mp=ro;\n    for(int i=0;i<50;++i){\n        d=map(mp);\n        if(d<.001)break;\n        mp+=d*rd*.5;\n    }\n\tfragColor = vec4(length(mp-ro)*.05);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sSyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 43, 43, 90], [91, 226, 244, 244, 365], [367, 367, 424, 424, 680]], "test": "ok"}
{"id": "4sXBR7", "name": "Newton Fractal x^8", "author": "DonKarlssonSan", "description": "Newton Fractal\nControl the zoom factor with mouse x\nControl the hue change factor with mouse y\nNote: you must drag (hold down a button)", "tags": ["fractal", "newton"], "likes": 6, "viewed": 131, "published": "Public", "date": "1495222820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n\n#define PI 3.14159265\n\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x,-a.y)\n#define cx_arg(a) atan2(a.y,a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n    float ipart = atan(a.y,a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\n\n////////////////////////////////////////////////////////////\n// end Complex Number math by julesb\n////////////////////////////////////////////////////////////\n\n\n// My own additions to complex number math\nvec2 cx_mul(vec2 a, vec2 b) { \n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\n#define cx_abs(a) sqrt(a.x * a.x + a.y * a.y)\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.x / a.y);\n    float r = sqrt(a.x * a.x + a.y * a.y);    \n    return vec2(r, phi); \n}\n\n// Complex power\n// Let z = r(cos θ + i sin θ)\n// Then z^n = r^n (cos nθ + i sin nθ)\nvec2 cx_pow(vec2 a, float n) {\n    float angle = atan(a.y, a.x);\n    float r = length(a);\n    float real = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(real, im);\n}\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nmat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n////////////////////////////////\n// End util                   //\n// Actual fractal begins here //\n////////////////////////////////\n\n// f(x) = x^8+15x^4-16\nvec2 f(vec2 z) {\n    vec2 c1 = cx_pow(z, 8.0);\n    vec2 c2 = cx_pow(z, 4.0) * 15.0;\n  \n    return c1 + c2 - 16.0;\n} \n\n// f(x) derivated\n// f'(x) = 8x^7+60x^3  \nvec2 fPrim(vec2 z) {\n    return cx_pow(z, 7.0) * 8.0 + cx_pow(z, 3.0) * 60.0;\n} \n\nint maxIterations = 50;\nvec2 one = vec2(1, 0);\nfloat newtonRapson(vec2 z) {\n  vec2 oldZ = z;\n  float s = 0.0;\n  for(int i = 0; i < maxIterations; i++){\n    z = z - cx_div(f(z), fPrim(z)); \n    if(abs(oldZ.x - z.x) < 0.001 && abs(oldZ.y - z.y) < 0.001) {\n      return s;\n    }\n    \n    vec2 w = cx_div(one, (oldZ - z));\n    float wAbs = cx_abs(w);\n    \n    s += exp(-wAbs);\n    oldZ = z;\n  }\n  return float(maxIterations);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy;\n    if(mouse.x < 0.01 && mouse.y < 0.01) {\n     \tmouse = iResolution.xy / 3.0;\n    }\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 zoomed = uv / mouse.x * iResolution.x / 2.0;\n    vec2 rotated = zoomed * rotate(iTime / 3.0);\n    \n    \n    float hue = newtonRapson(rotated) / float(maxIterations) * mouse.y / 20.0;\n    vec3 c = hsv2rgb(vec3(hue, 1.0, 1.0));\n    fragColor = vec4(c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 456, 456, 634], [636, 636, 657, 657, 695], [697, 697, 718, 718, 875], [877, 877, 901, 901, 996], [998, 998, 1033, 1033, 1076], [1079, 1079, 1114, 1114, 1161], [1325, 1368, 1397, 1397, 1451], [1499, 1499, 1525, 1525, 1633], [1635, 1724, 1754, 1754, 1926], [1928, 2027, 2049, 2049, 2218], [2221, 2221, 2243, 2243, 2292], [2427, 2450, 2466, 2466, 2565], [2568, 2610, 2630, 2630, 2689], [2739, 2739, 2767, 2767, 3115], [3118, 3118, 3175, 3175, 3601]], "test": "ok"}
{"id": "4sXBRM", "name": "colorful tris fixed", "author": "benxo", "description": "copy of https://www.shadertoy.com/view/4dV3Dh but fixed.", "tags": ["2d", "triangles", "colors"], "likes": 3, "viewed": 201, "published": "Public", "date": "1495202704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* ----------------------------------------------------------------------------\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * Nimda@zl wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n * ----------------------------------------------------------------------------\n */\n\nuniform float time;\nuniform vec2 touch;\nuniform vec2 resolution;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat GetLocation(vec2 s, float d)\n{\n    vec2 f = s*d;\n\n    //s = mix(vec2(0), floor(s*d),step(0.5, f));\n\n    // tris\n    f = mod(f, 8.); // because i failed somewhere\n    \n    f = f + vec2(0,0.5)*floor(f).x;\n    s = fract(f);\n    f = floor(f);\n\n    d = s.y - 0.5;\n    float l = abs(d) + 0.5 * s.x;\n    float ff = f.x+f.y;\n    f = mix(f, f+sign(d)*vec2(0,0.5), step(0.5, l));\n    l = mix(ff, ff+sign(d)*0.5, step(0.5, l));\n\n    return l * rand(vec2(f));\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    h = fract(h);\n    vec3 c = smoothstep(2./6., 1./6., abs(h - vec3(0.5, 2./6., 4./6.)));\n    c.r = 1.-c.r;\n    /*\n    vec3 c = vec3(\n    smoothstep(1./6., 2./6., abs(h -0.5)),\n        1.-smoothstep(1./6., 2./6., abs(h -2./6.)),\n        1.-smoothstep(1./6., 2./6., abs(h -4./6.))\n        );*/\n    return mix(vec3(s), vec3(1.0), c) * v;\n}\n\nvec3 getRandomColor(float f, float t)\n{\n    return hsv2rgb(f+t, 0.2+cos(sin(f))*0.3, 0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mx = max( iResolution.x, iResolution.y );\n    float t = iTime*0.3;\n    vec2 s = fragCoord.xy / mx + vec2(t, 0) * 0.2;\n\n\n    float f[3];\n    f[0] = GetLocation(s, 12.);\n    f[1] = GetLocation(s, 6.);\n    f[2] = GetLocation(s, 3.);\n\n    vec3 color = getRandomColor(f[1] *0.05 + 0.01*f[0] + 0.9*f[2], t);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXBRM.jpg", "access": "shaders20k", "license": "beerware", "functions": [[481, 481, 502, 502, 574], [576, 576, 612, 612, 1031], [1033, 1033, 1074, 1074, 1413], [1415, 1415, 1454, 1454, 1507], [1509, 1509, 1566, 1566, 1914]], "test": "error"}
{"id": "4sXBRn", "name": "Luminescence", "author": "BigWIngs", "description": "My entry for the monthly challenge on r/proceduralgeneration \nUse the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\nCode is a bit of a mess, too lazy to clean up. Hope you like it!", "tags": ["raymarching", "ocean", "underwater", "jellyfish", "deepsea"], "likes": 282, "viewed": 16107, "published": "Public", "date": "1495514713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Luminescence by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// My entry for the monthly challenge (May 2017) on r/proceduralgeneration \n// Use the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\n// Code is a bit of a mess, too lazy to clean up. Hope you like it!\n\n// Music by Klaus Lunde\n// https://soundcloud.com/klauslunde/zebra-tribute\n\n// YouTube: The Art of Code -> https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// Twitter: @The_ArtOfCode\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100.\n#define VOLUME_STEPS 8.\n//#define SINGLE\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define HIT_DISTANCE .01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 accentColor1 = vec3(1., .1, .5);\nvec3 secondColor1 = vec3(.1, .5, 1.);\n\nvec3 accentColor2 = vec3(1., .5, .1);\nvec3 secondColor2 = vec3(.1, .5, .6);\n\nvec3 bg;\t \t// global background color\nvec3 accent;\t// color of the phosphorecence\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// final distance to field\n    float m; \t// material\n    vec3 uv;\n    float pump;\n    \n    vec3 id;\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n    //vec3 c;\t\t// the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    //o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n// ============== Functions I borrowed ;)\n\n//  3 out, 1 in... DAVE HOSKINS\nvec3 N31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// DE functions from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s); }\n\n// From http://mercury.sexy/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = twopi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n    \n// -------------------------\n\n\nfloat Dist( vec2 P,  vec2 P0, vec2 P1 ) {\n    //2d point-line distance\n    \n\tvec2 v = P1 - P0;\n    vec2 w = P - P0;\n\n    float c1 = dot(w, v);\n    float c2 = dot(v, v);\n    \n    if (c1 <= 0. )  // before P0\n    \treturn length(P-P0);\n    \n    float b = c1 / c2;\n    vec2 Pb = P0 + b*v;\n    return length(P-Pb);\n}\n\nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nvec2 RayRayTs(vec3 ro1, vec3 rd1, vec3 ro2, vec3 rd2) {\n\t// returns the two t's for the closest point between two rays\n    // ro+rd*t1 = ro2+rd2*t2\n    \n    vec3 dO = ro2-ro1;\n    vec3 cD = cross(rd1, rd2);\n    float v = dot(cD, cD);\n    \n    float t1 = dot(cross(dO, rd2), cD)/v;\n    float t2 = dot(cross(dO, rd1), cD)/v;\n    return vec2(t1, t2);\n}\n\nfloat DistRaySegment(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n\t// returns the distance from ray r to line segment p1-p2\n    vec3 rd2 = p2-p1;\n    vec2 t = RayRayTs(ro, rd, p1, rd2);\n    \n    t.x = max(t.x, 0.);\n    t.y = clamp(t.y, 0., length(rd2));\n                \n    vec3 rp = ro+rd*t.x;\n    vec3 sp = p1+rd2*t.y;\n    \n    return length(rp-sp);\n}\n\nvec2 sph(vec3 ro, vec3 rd, vec3 pos, float radius) {\n\t// does a ray sphere intersection\n    // returns a vec2 with distance to both intersections\n    // if both a and b are MAX_DISTANCE then there is no intersection\n    \n    vec3 oc = pos - ro;\n    float l = dot(rd, oc);\n    float det = l*l - dot(oc, oc) + radius*radius;\n    if (det < 0.0) return vec2(MAX_DISTANCE);\n    \n    float d = sqrt(det);\n    float a = l - d;\n    float b = l + d;\n    \n    return vec2(a, b);\n}\n\n\nvec3 background(vec3 r) {\n\t\n    float x = atan(r.x, r.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = bg*(1.+y);\n    \n\tfloat t = iTime;\t\t\t\t// add god rays\n    \n    float a = sin(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*5.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(42.*x+a*y*21.-t));\n    beam2 *= sat(sin(34.*x+a*y*17.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.05;\n\n    return col;\n}\n\n\n\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\n\n\nde map( vec3 p, vec3 id ) {\n\n    float t = iTime*2.;\n    \n    float N = N3(id);\n    \n    de o;\n    o.m = 0.;\n    \n    float x = (p.y+N*twopi)*1.+t;\n    float r = 1.;\n    \n    float pump = cos(x+cos(x))+sin(2.*x)*.2+sin(4.*x)*.02;\n    \n    x = t + N*twopi;\n    p.y -= (cos(x+cos(x))+sin(2.*x)*.2)*.6;\n    p.xz *= 1. + pump*.2;\n    \n    float d1 = sdSphere(p, vec3(0., 0., 0.), r);\n    float d2 = sdSphere(p, vec3(0., -.5, 0.), r);\n    \n    o.d = smax(d1, -d2, .1);\n    o.m = 1.;\n    \n    if(p.y<.5) {\n        float sway = sin(t+p.y+N*twopi)*S(.5, -3., p.y)*N*.3;\n        p.x += sway*N;\t// add some sway to the tentacles\n        p.z += sway*(1.-N);\n        \n        vec3 mp = p;\n    \tmp.xz = pModPolar(mp.xz, 6., 0.);\n        \n        float d3 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .01, mp.y);\n    \tif(d3<o.d) o.m=2.;\n        d3 += (sin(mp.y*10.)+sin(mp.y*23.))*.03;\n        \n        float d32 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .04, mp.y)*.5;\n        d3 = min(d3, d32);\n        o.d = smin(o.d, d3, .5);\n        \n        if( p.y<.2) {\n             vec3 op = p;\n    \t\top.xz = pModPolar(op.xz, 13., 1.);\n            \n        \tfloat d4 = length(op.xz-vec2(.85, .0))-remap(.5, -3., .04, .0, op.y);\n    \t\tif(d4<o.d) o.m=3.;\n            o.d = smin(o.d, d4, .15);\n        }\n    }    \n    o.pump = pump;\n    o.uv = p;\n    \n    o.d *= .8;\n    return o;\n}\n\nvec3 calcNormal( de o ) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy, o.id).d - map(o.pos-eps.xyy, o.id).d,\n\t    map(o.pos+eps.yxy, o.id).d - map(o.pos-eps.yxy, o.id).d,\n\t    map(o.pos+eps.yyx, o.id).d - map(o.pos-eps.yyx, o.id).d );\n\treturn normalize(nor);\n}\n\nde CastRay(ray r) {\n    float d = 0.;\n    float dS = MAX_DISTANCE;\n    \n    vec3 pos = vec3(0., 0., 0.);\n    vec3 n = vec3(0.);\n    de o, s;\n    \n    float dC = MAX_DISTANCE;\n    vec3 p;\n    rc q;\n    float t = iTime;\n    vec3 grid = vec3(6., 30., 6.);\n        \n    for(float i=0.; i<MAX_STEPS; i++) {\n        p = r.o + r.d*d;\n        \n        #ifdef SINGLE\n        s = map(p, vec3(0.));\n        #else\n        p.y -= t;  // make the move up\n        p.x += t;  // make cam fly forward\n            \n        q = Repeat(p, grid);\n    \t\n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n        dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n        \n        float N = N3(q.id);\n        q.p += (N31(N)-.5)*grid*vec3(.5, .7, .5);\n        \n\t\tif(Dist(q.p.xz, r.d.xz, vec2(0.))<1.1)\n        //if(DistRaySegment(q.p, r.d, vec3(0., -6., 0.), vec3(0., -3.3, 0)) <1.1) \n        \ts = map(q.p, q.id);\n        else\n            s.d = dC;\n        \n        \n        #endif\n           \n        if(s.d<HIT_DISTANCE || d>MAX_DISTANCE) break;\n        d+=min(s.d, dC);\t// move to distance to next cell or surface, whichever is closest\n    }\n    \n    if(s.d<HIT_DISTANCE) {\n        o.m = s.m;\n        o.d = d;\n        o.id = q.id;\n        o.uv = s.uv;\n        o.pump = s.pump;\n        \n        #ifdef SINGLE\n        o.pos = p;\n        #else\n        o.pos = q.p;\n        #endif\n    }\n    \n    return o;\n}\n\nfloat VolTex(vec3 uv, vec3 p, float scale, float pump) {\n    // uv = the surface pos\n    // p = the volume shell pos\n    \n\tp.y *= scale;\n    \n    float s2 = 5.*p.x/twopi;\n    float id = floor(s2);\n    s2 = fract(s2);\n    vec2 ep = vec2(s2-.5, p.y-.6);\n    float ed = length(ep);\n    float e = B(.35, .45, .05, ed);\n    \n   \tfloat s = SIN(s2*twopi*15. );\n\ts = s*s; s = s*s;\n    s *= S(1.4, -.3, uv.y-cos(s2*twopi)*.2+.3)*S(-.6, -.3, uv.y);\n    \n    float t = iTime*5.;\n    float mask = SIN(p.x*twopi*2. + t);\n    s *= mask*mask*2.;\n    \n    return s+e*pump*2.;\n}\n\nvec4 JellyTex(vec3 p) { \n    vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n    \n    float b = .75+sin(s.x*6.)*.25;\n    b = mix(1., b, s.y*s.y);\n    \n    p.x += sin(s.z*10.)*.1;\n    float b2 = cos(s.x*26.) - s.z-.7;\n   \n    b2 = S(.1, .6, b2);\n    return vec4(b+b2);\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    // outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = CastRay(camRay);\n    \n    float t = iTime;\n    vec3 L = up;\n    \n\n    if(o.m>0.) {\n        vec3 n = calcNormal(o);\n        float lambert = sat(dot(n, L));\n        vec3 R = reflect(camRay.d, n);\n        float fresnel = sat(1.+dot(camRay.d, n));\n        float trans = (1.-fresnel)*.5;\n        vec3 ref = background(R);\n        float fade = 0.;\n        \n        if(o.m==1.) {\t// hood color\n            float density = 0.;\n            for(float i=0.; i<VOLUME_STEPS; i++) {\n                float sd = sph(o.uv, camRay.d, vec3(0.), .8+i*.015).x;\n                if(sd!=MAX_DISTANCE) {\n                    vec2 intersect = o.uv.xz+camRay.d.xz*sd;\n\n                    vec3 uv = vec3(atan(intersect.x, intersect.y), length(intersect.xy), o.uv.z);\n                    density += VolTex(o.uv, uv, 1.4+i*.03, o.pump);\n                }\n            }\n            vec4 volTex = vec4(accent, density/VOLUME_STEPS); \n            \n            \n            vec3 dif = JellyTex(o.uv).rgb;\n            dif *= max(.2, lambert);\n\n            col = mix(col, volTex.rgb, volTex.a);\n            col = mix(col, vec3(dif), .25);\n\n            col += fresnel*ref*sat(dot(up, n));\n\n            //fade\n            fade = max(fade, S(.0, 1., fresnel));\n        } else if(o.m==2.) {\t\t\t\t\t\t// inside tentacles\n            vec3 dif = accent;\n    \t\tcol = mix(bg, dif, fresnel);\n            \n            col *= mix(.6, 1., S(0., -1.5, o.uv.y));\n            \n            float prop = o.pump+.25;\n            prop *= prop*prop;\n            col += pow(1.-fresnel, 20.)*dif*prop;\n            \n            \n            fade = fresnel;\n        } else if(o.m==3.) {\t\t\t\t\t\t// outside tentacles\n        \tvec3 dif = accent;\n            float d = S(100., 13., o.d);\n    \t\tcol = mix(bg, dif, pow(1.-fresnel, 5.)*d);\n        }\n        \n        fade = max(fade, S(0., 100., o.d));\n        col = mix(col, bg, fade);\n        \n        if(o.m==4.)\n            col = vec3(1., 0., 0.);\n    } \n     else\n        col = bg;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.04;\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x; \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    if(m.x<0.05 || m.x>.95) {\t\t\t\t// move cam automatically when mouse is not used\n    \tm = vec2(t*.25, SIN(t*pi)*.5+.5);\n    }\n\t\n    accent = mix(accentColor1, accentColor2, SIN(t*15.456));\n    bg = mix(secondColor1, secondColor2, SIN(t*7.345231));\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  0., s, 0., 1., 0., s,  0., -c);\n    \n    #ifdef SINGLE\n    float camDist = -10.;\n    #else\n    float camDist = -.1;\n    #endif\n    \n    vec3 lookAt = vec3(0., -1., 0.);\n    \n    vec3 camPos = vec3(0., INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n   \t\n    CameraSetup(uv, camPos+lookAt, lookAt, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n    \n    col = pow(col, vec3(mix(1.5, 2.6, SIN(t+pi))));\t\t// post-processing\n    float d = 1.-dot(uv, uv);\t\t// vignette\n    col *= (d*d*d)+.1;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dlXz7", "previewfilepath": "https://soundcloud.com/klauslunde/zebra-tribute", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/klauslunde/zebra-tribute", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXBRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1396, 1396, 1417, 1417, 1451], [1452, 1452, 1480, 1480, 1510], [1512, 1512, 1530, 1530, 1625], [2743, 2743, 2775, 2775, 2955], [2975, 2975, 3042, 3042, 3538], [3584, 3616, 3635, 3635, 3807], [3809, 3833, 3874, 3874, 3967], [3969, 3969, 4010, 4010, 4099], [4101, 4101, 4146, 4146, 4174], [4176, 4211, 4271, 4271, 4471], [4508, 4508, 4549, 4578, 4819], [4821, 4821, 4866, 4919, 4964], [4966, 4966, 5021, 5113, 5315], [5317, 5317, 5375, 5433, 5664], [5666, 5666, 5718, 5881, 6136], [6139, 6139, 6164, 6164, 6619], [6624, 6624, 6682, 6682, 6715], [6719, 6719, 6746, 6746, 8087], [8089, 8089, 8114, 8114, 8382], [8384, 8384, 8403, 8403, 9821], [9823, 9823, 9879, 9939, 10384], [10386, 10386, 10409, 10409, 10657], [10659, 10659, 10708, 10731, 12790], [12792, 12792, 12849, 12849, 13920]], "test": "ok"}
{"id": "4sXfWH", "name": "Swirly Grayscale", "author": "TechEpic", "description": "I don't know, this only took a few minutes.", "tags": ["swirl"], "likes": 2, "viewed": 164, "published": "Public", "date": "1495819219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tfloat col = 0.0;\n    uv.x -= 0.5;\n    uv.y -= iResolution.y/iResolution.x/2.0;\n    float dir = atan(uv.x, uv.y)*10.0+iTime*10.0;\n    if(sin(dir-pow(length(uv),3.0)*500.0) > 0.0) {\n    \tcol += 0.25;\n    }\n    dir = atan(uv.x, uv.y)*10.0+iTime*11.0;\n    if(sin(dir-pow(length(uv),3.0)*300.0) > 0.0) {\n    \tcol += 0.25;\n    }\n    dir = atan(uv.x, uv.y)*10.0+iTime*9.0;\n    if(sin(dir-pow(length(uv),3.0)*400.0) > 0.0) {\n    \tcol += 0.25;\n    }\n    dir = atan(uv.x, uv.y)*10.0+iTime*12.0;\n    if(sin(dir-pow(length(uv),3.0)*600.0) > 0.0) {\n    \tcol += 0.25;\n    }\n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 695]], "test": "ok"}
{"id": "4tcXDl", "name": "Quasicrystal zoom", "author": "sheepmaster", "description": "http://wealoneonearth.blogspot.co.uk/2011/11/visual-analogue-of-shepard-tone.html", "tags": ["fractal", "quasicrystal", "zoom", "shepardscale", "shepard"], "likes": 12, "viewed": 611, "published": "Public API", "date": "1495751492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Number of plane waves\nconst int K = 5;\n\n// Number of stripes per wave\nconst int NUM_STRIPES = 3;\n\nconst int NUM_FREQUENCIES = 8;\n\n// The main (central) spatial frequency\nconst float MEAN_FREQUENCY = 4.;\n\n// The spread of the spatial frequency envelope\nconst float SIGMA = 1.;\n\nconst float PERIOD = 3.;\n\nconst float PI = 4.0 * atan(1.0);\n\nconst float mean = MEAN_FREQUENCY * log(2.);\n\nfloat gaussian(float x) {\n    x -= mean;\n    return exp(-x * x / 2.) / SIGMA;\n}\n\n// Adjust the  wavelengths for the current spatial scale\nfloat wavelength(int i, float sc) {\n    return pow(2., float(i)) * sc;\n}\n\n// Modulate each wavelength by a Gaussian envelope in log\n// frequency, centered around aforementioned mean with defined\n// standard deviation\nfloat weight(int i, float sc) {\n    return gaussian(log(wavelength(i, sc)));\n}\n\n// 7-th order smoothstep function:\n// https://en.wikipedia.org/wiki/Smoothstep\n// https://gist.github.com/kylemcdonald/77f916240756a8cfebef\nfloat superSmooth(float x) {\n\tfloat xSquared = x * x;\n\treturn xSquared * xSquared * (x * (x * (x * -20. + 70.) - 84.) + 35.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat scale = pow(0.5, fract(iTime / PERIOD));\n\n    float weightSum = 0.;\n    for (int l = 0; l < NUM_FREQUENCIES; l++) {\n        weightSum += weight(l, scale);\n    }\n    \n    // Cartesian coordinates\n\tvec2 coords = (fragCoord.xy - iResolution.xy / 2.) / iResolution.x\n        * 2. * PI * float(NUM_STRIPES);\n\n    float c = 0.;  // Accumulator\n    \n    // Iterate over all k plane waves\n    for (int t = 0; t < K; t++) {\n    \tfloat tScaled = float(t) / float(K) * PI;\n        vec2 omega = vec2(cos(tScaled), sin(tScaled));\n\n        // Compute the phase of the plane wave\n        float ph = dot(coords, omega);\n\n        // Take a weighted sum over the different spatial scales\n        for (int l = 0; l < NUM_FREQUENCIES; l++) {\n\t\t\tc += cos(ph * wavelength(l, scale)) * weight(l, scale);\n        }\n    }\n    // Convert the summed waves to a [0,1] interval\n    // and then convert to color\n    float cScaled = superSmooth((c / (weightSum * float(K)) + 1.) / 2.);\n\tvec3 color = cScaled * vec3(1.0, 0.0, 1.0);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[387, 387, 412, 412, 466], [468, 525, 560, 560, 597], [599, 742, 773, 773, 820], [822, 962, 990, 990, 1089], [1091, 1091, 1146, 1146, 2187]], "test": "error"}
{"id": "ld2cWK", "name": "Wibbly Embryo of Light", "author": "Hadyn", "description": "Spinoff from my Light Orb shader - https://www.shadertoy.com/view/ldjcWy", "tags": ["2d"], "likes": 27, "viewed": 442, "published": "Public", "date": "1493900390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n * Created by Hadyn Lander \n * 3D noise from Nikita Miropolskiy, nikat/2013 https://www.shadertoy.com/view/XsX3zB\n * That basically includes all of this neat looking code up top:\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n/*\n* The Nintendo Super Mess of code below is all me. I am sorryish.\n*/\n\n// Comment out the enxt line to limit the length of \"rays\"\n#define UNLIMITED\t\t\t\n\n#define CENTERSCALE 0.6\n#define CENTERCONNECTEDNESS 0.35\n#define RADIUS 0.5\t\t\t// Has a bigger impact if UNLIMITED is disabled\n#define FLAMEBOOST 0.15\t\t// Adds the flame shape mask over the top of the multiplied noise to maintain more of original shape.\n#define EDGE 0.65\t\t\t// Edge cutoff \n#define FALLOFFPOW 4.0\t\t// Only used is UNLIMITED is disabled\n#define NOISEBIGNESS 1.5 \n#define NIGHTSPEEDBONUS 1.25 \t\t\n#define PI 3.14159265359\n\n\nfloat getNoiseValue(vec2 p, float time)\n{\n    vec3 p3 = vec3(p.x, p.y, 0.0) + vec3(0.0, 0.0, time*0.025);\n    float noise = simplex3d(p3*32.0);// simplex3d_fractal(p3*8.0+8.0);\n\treturn 0.5 + 0.5*noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 28.22+NIGHTSPEEDBONUS*iTime;\n    float bignessScale = 1.0/NOISEBIGNESS;\n\tvec2 p = fragCoord.xy / iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 positionFromCenter = p-vec2(0.5*aspect, 0.5);\n    \n    float innerOrbEdge = (1.0-CENTERCONNECTEDNESS)*CENTERSCALE*RADIUS;\n    vec2 pOffset = normalize(positionFromCenter) * mix(innerOrbEdge-length(positionFromCenter), 1.0, step(CENTERSCALE*RADIUS, length(positionFromCenter)));\n    p = vec2(0.5*aspect, 0.5)+pOffset;//normalize(positionFromCenter)*min(length(positionFromCenter)+CENTERCONNECTEDNESS*CENTERSCALE*RADIUS, CENTERSCALE*RADIUS);    \n    \n    bignessScale = mix(1.2*bignessScale, bignessScale, step(CENTERSCALE*RADIUS, length(positionFromCenter)));\n    \n    \n    float noise = getNoiseValue(bignessScale*0.25*p, time);\n    \n    float distanceFromCenter = clamp(1.0-length(positionFromCenter)/RADIUS, 0.0, 1.0);\n    \n    float scaledDistance = distanceFromCenter * noise;\n    \n    \n    float falloffMask = 1.0; \n    \n    #ifndef UNLIMITED\n        falloffMask =  2.0*scaledDistance-1.0;\n        falloffMask = clamp(1.0-pow(abs(falloffMask), FALLOFFPOW), 0.0, 1.0);\n    #endif\n    \n    float thinnerMask;\n    \n    thinnerMask = 1.0-clamp(abs(distanceFromCenter-(1.0-CENTERSCALE))/CENTERSCALE, 0.0, 1.0);\n    thinnerMask = pow(thinnerMask, 16.0);    \n    thinnerMask = clamp(0.9*thinnerMask, 0.0, 1.0);\n    \n    float finalValue;\n    finalValue = falloffMask;\n    \n    float innerBall = clamp(abs(distanceFromCenter-(1.0-CENTERSCALE))/CENTERSCALE, 0.0, 1.0);\n    innerBall = smoothstep(0.5, 0.85, innerBall);\n    innerBall += noise;\n    \n    finalValue = mix( (noise*falloffMask+thinnerMask)*thinnerMask + innerBall, noise*falloffMask+thinnerMask, step(distanceFromCenter, 1.0-CENTERSCALE));\n    \n    finalValue = smoothstep(EDGE,EDGE+0.1, finalValue);\n    \n    \n    vec3 colorNoise;\n    colorNoise.x\t= getNoiseValue(bignessScale*0.25*p, 10.0+time);\n    colorNoise.y \t= getNoiseValue(bignessScale*0.25*p, 00.0+time);\n    colorNoise.z\t= getNoiseValue(bignessScale*0.25*p, 30.0+time);\n    \n    colorNoise.x = smoothstep(EDGE,EDGE+0.1, colorNoise.x);\n    colorNoise.y = smoothstep(EDGE,EDGE+0.1, colorNoise.y);\n    colorNoise.z = smoothstep(EDGE,EDGE+0.1, colorNoise.z);\n    \n    \n    vec3 finalColor;\n    //finalColor = vec3(colorNoise.x, colorNoise.y, colorNoise.x+colorNoise.y); \n    finalColor = mix(vec3(colorNoise.x, 0.0, 0.2*colorNoise.x), vec3(colorNoise.x, 1.0, 1.0), 1.0-colorNoise.y);\n    finalColor += vec3(1.0) * (pow(clamp(distanceFromCenter+CENTERSCALE, 0.0, 1.0), 8.0));\n    \n    //finalColor = clamp(finalColor, vec3(0.0), vec3(1.0));\n    \n    finalColor *= finalValue;\n    \n    vec3 bgColor = mix(vec3(0.00,0.07,0.15), vec3(0.15,0.35,0.5), distanceFromCenter*0.5);\n    bgColor += vec3(1.0,.2,0.4)* pow(distanceFromCenter, 4.0);\n    finalColor += bgColor;\n    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2cWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 261, 283, 283, 456], [563, 586, 611, 864, 1781], [2051, 2118, 2151, 2151, 2298], [2891, 2891, 2932, 2932, 3094], [3096, 3096, 3153, 3153, 6057]], "test": "ok"}
{"id": "ld2yDG", "name": "Bisous", "author": "leon", "description": "Shader Love", "tags": ["2d", "sound", "text", "heart"], "likes": 9, "viewed": 335, "published": "Public", "date": "1493680062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bisous from Leon\n\n// Music from:\n// https://soundcloud.com/steelcitydancediscs/a-ghettohousedrummachine\n\n// heart function from:\n// https://www.desmos.com/calculator/lncpsghko4\n\n// text\n#define grid 16.\n#define cell 1./16.\nconst int kA=177,kB=178,kC=179,kD=180,kE=181,kF=182,kG=183,kH=184,kI=185,kJ=186,kK=187;\nconst int kL=188,kM=189,kN=190,kO=191,kP=160,kQ=161,kR=162,kS=163,kT=164,kU=165,kV=166;\nconst int kW=167,kX=168,kY=169,kZ=170,kSpace=80;\n\nvec2 getSymbol (int key)\n{\n\treturn vec2(mod(float(key),grid),floor(float(key)/grid));\n}\n\nvec2 getLetterUV (vec2 target, vec2 offset)\n{\n    vec2 uvLetter = target;\n    uvLetter.x = uvLetter.x * 0.45 + 0.017;\n    uvLetter += offset / grid;\n    float crop = step(target.x, cell) * step(target.y, cell);\n    crop *= step(0., target.x) * step(0., target.y);\n    return uvLetter * crop;\n}\n\nfloat getText (vec2 target)\n{\n    int symbols[] = int[] ( kB,kI,kS,kO,kU,kS );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return texture(iChannel3, textUV).r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Common stuff\n    vec3 color = vec3(0);\n    float time = iTime;\n    const float pi = 3.14159;\n    const float pi2 = 3.14159 * 2.;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvViewport = uv * 2. - 1.;\n    uvViewport.x *= aspect;\n    \n    // Displace UV\n    vec2 uvHeart = uvViewport * 2.;\n    uvHeart.x *= 0.9;\n    uvHeart += vec2(0.0, 0.25);\n    float a = pi2 * texture(iChannel0, uvViewport+vec2(0.1,0.2)*time).r;\n    a += pi2 * texture(iChannel0, uvViewport+vec2(-0.15,-0.08)*time).r;\n    a += time;\n    vec2 offset = vec2(cos(a), sin(a)) * 0.03;\n    uvHeart += offset;\n    uvHeart.y -= abs(sin(uv.x)*0.2);\n    \n    // Heart from: https://www.desmos.com/calculator/lncpsghko4\n    float thinHeart = 0.02;\n\tfloat plotter = (thinHeart/(pow(uvHeart.x,2.)*pow(uvHeart.y,3.)-(pow(pow(uvHeart.x,2.)+pow(uvHeart.y,2.)-1.,3.))));\n    float signP = sign(plotter);\n    plotter += smoothstep(0.0, 0.2, plotter);\n    plotter = abs(plotter);\n    \n    // Polar coordinates\n    float angle = atan(uvViewport.y, uvViewport.x) * 3.;\n    float radius = (length(uvViewport) - 0.5);\n    vec2 uvPolar = vec2(angle, radius);\n    uvPolar.x = mod(abs(sin(uvPolar.x)),1.);\n    uvPolar.y = uvPolar.y * 2. - 0.5;\n    \n    // Sound FFT\n    float thinSignal = 0.1;\n    plotter += -(thinSignal/(texture(iChannel2, uvPolar).r-uvPolar.y));\n    float signP2 = sign(plotter);\n    plotter = abs(plotter);\n    \n    // Background\n    float thinBack = 0.2;\n    uvPolar = vec2(angle, radius);\n    uvPolar.x *= 60.0;\n    uvPolar.y = (uvPolar.y-0.5) * 1.;\n    float fadeCenter = clamp(length(uvViewport)*2.-2.,0.,1.);\n    plotter += fadeCenter * clamp(abs(thinBack/(sin(uvPolar.x)-uvPolar.y)),0.,1.);\n    \n    // Colors\n    vec3 red = vec3(0.5,0.2,0.2);    \n    vec3 blue = vec3(0.1,0.2,0.5);  \n    vec3 yellow = vec3(0.9,0.6,0.2);\n    vec3 gray = vec3(0.2,0.2,0.25);\n    vec3 colorP = mix(red, gray, 1.-clamp(signP,0.,1.));\n    colorP = mix(colorP, yellow, 1.-clamp(signP2,0.,1.));\n    color = mix(color, colorP, plotter);\n    \n    // Text\n    vec2 uvText = uvViewport;\n    uvText.x *= 3.;\n    uvText *= 0.12;\n    uvText.x += sin(uvHeart.y*2.+time)*0.08;\n    uvText.y += sin(uvHeart.x*4.+time)*0.01;\n    color = mix(color, vec3(1.), getText(uvText));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "XslXRr", "previewfilepath": "https://soundcloud.com/steelcitydancediscs/a-ghettohousedrummachine", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/steelcitydancediscs/a-ghettohousedrummachine", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2yDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 478, 478, 539], [541, 541, 586, 586, 834], [1272, 1272, 1329, 1349, 3642]], "test": "error"}
{"id": "ld2yWy", "name": "Sunlight through Water", "author": "bbcollinsworth", "description": "Quick effect to simulate looking up at the sun from underwater.", "tags": ["procedural", "noise", "water", "light"], "likes": 16, "viewed": 537, "published": "Public", "date": "1493687337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//noise functions adapted from Keijiro HLSL Simplex Noise\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - r * 0.85373472095314;\n}\n\nvec3 snoise_grad(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v   - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    // x1 = x0 - i1  + 1.0 * C.xxx;\n    // x2 = x0 - i2  + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec4 p =\n      permute(permute(permute(vec4(i.z) + vec4(0.0, i1.z, i2.z, 1.0))\n                            + vec4(i.y) + vec4(0.0, i1.y, i2.y, 1.0))\n                            + vec4(i.x) + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_);  // mod(j,N)\n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //float4 s0 = float4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n    //float4 s1 = float4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n    vec4 s0 = vec4(floor(b0) * 2.0 + 1.0);\n    vec4 s1 = vec4(floor(b1) * 2.0 + 1.0);\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));\n    g0 *= norm.x;\n    g1 *= norm.y;\n    g2 *= norm.z;\n    g3 *= norm.w;\n\n    // Compute gradient of noise function at P\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m2 * m;\n    vec4 m4 = m2 * m2;\n    vec3 grad =\n      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +\n      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +\n      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +\n      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;\n    return 42.0 * grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 noiseOffset = snoise_grad(vec3(uv*16.-iTime, iTime*2.));\n\n    vec3 c = vec3(clamp(1. - length((uv * 2. - 1.)*1.5+noiseOffset.xy*0.3),0.2,1.0))*2.;\n    c *= vec3(0.2,0.5,1.0);\n    c += (1.-length(uv * 2. - 1.))*0.5;\n    c = c+c+c+c;\n    c /=3.;\n    \n\tfragColor = vec4(c,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2yWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 80, 80, 123], [125, 125, 146, 146, 189], [191, 191, 213, 213, 256], [258, 258, 286, 286, 340], [342, 342, 368, 368, 2720], [2722, 2722, 2779, 2779, 3113]], "test": "ok"}
{"id": "ldBcDd", "name": "hex voxels", "author": "mattz", "description": "Proof-of-concept demonstrating interesting effects (borders, AO, hard shadows) with hex voxels at decent framerates. ", "tags": ["voxels", "hex"], "likes": 14, "viewed": 912, "published": "Public", "date": "1494358697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* hex voxels, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Idea: raytrace through stacked hexagonal boxes, based on Shane's comment\n   in hexwaves - https://www.shadertoy.com/view/XsBczc\n\n   Define DEBUG_MAP if you want to see the underlying implicit function that defines \n   the scene.\n\n*/\n\n//#define DEBUG_MAP\n\n// square root of 3 over 2\nconst float hex_factor = 0.8660254037844386;\n\n// ratio of cell height to hex radius\nconst float cell_height = 1.75;\n\n// relationship between integer grid cells & sizes\nconst vec3 cell_size = vec3(hex_factor, 1.0, cell_height);\n\n// ambient occlusion falloff - smaller is darker\nconst float ao_falloff = 3.5;\n\n// ambient occlusion strength - bigger is darker\nconst float ao_strength = 0.65;\n\n// higher resolution discretizes more finely but needs more grid steps to render\nconst float resolution = 1.5;\n\n// number of steps to take to render\nconst int grid_steps = 100;\n\n// light direction\nvec3 light_dir = vec3(-3, -2, 5);\n\n\n#define HEX_FROM_CART(p) vec2(p.x / hex_factor, p.y)\n#define CART_FROM_HEX(g) vec2(g.x * hex_factor, g.y)\n\n//////////////////////////////////////////////////////////////////////\n// Used to draw top borders\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Given a 2D position, find integer coordinates of center of nearest\n// hexagon in plane.\n\nvec2 nearestHexCell(in vec2 pos) {\n    \n    // integer coords in hex center grid -- will need to be adjusted\n    vec2 gpos = HEX_FROM_CART(pos);\n    vec2 hex_int = floor(gpos);\n\n    // adjust integer coords\n    float sy = step(2.0, mod(hex_int.x+1.0, 4.0));\n    hex_int += mod(vec2(hex_int.x, hex_int.y + sy), 2.0);\n\n    // difference vector\n    vec2 gdiff = gpos - hex_int;\n\n    // figure out which side of line we are on and modify\n    // hex center if necessary\n    if (dot(abs(gdiff), vec2(hex_factor*hex_factor, 0.5)) > 1.0) {\n        vec2 delta = sign(gdiff) * vec2(2.0, 1.0);\n        hex_int += delta;\n    }\n\n    return hex_int;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Flip normal if necessary to have positive dot product with d\n\nvec2 alignNormal(vec2 h, vec2 d) {\n    return h * sign(dot(h, CART_FROM_HEX(d)));\n}\n\n//////////////////////////////////////////////////////////////////////\n// Intersect a ray with a hexagon wall with normal n\n\nvec3 rayHexIntersect(in vec2 ro, in vec2 rd, in vec2 h) {\n    \n    //return vec3(0);\n\n    vec2 n = CART_FROM_HEX(h);\n\n    // solve for u such that dot(n, ro+u*rd) = 1.0\n    float u = (1.0 - dot(n, ro)) / dot(n, rd);\n    \n    // return the \n    return vec3(h, u);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Choose the vector whose z coordinate is minimal\n\nvec3 rayMin(vec3 a, vec3 b) {\n    return a.z < b.z ? a : b;\n}\n\n//////////////////////////////////////////////////////////////////////\n// Generate a distance field for the voxels. Negative (inside) means \n// filled voxel.\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p) {\n    \n    float d = p.z;\n    \n    d = min(d, length(p) - 6.0);\n    \n    d = min(d, sdTorus(p.yxz, vec2(12.0, 2.5)));\n    \n    d = min(d, max(40.0 - length(p), p.z - 15.0));\n\n    return d;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Surface shading function. hit_nt holds normal and ray distance,\n// bdist holds distance to voxel edge, ndist holds distance to \n// neighbors (useful for AO).\n\nvec3 shade(vec4 hit_nt, float bdist, float ndist, float diffuse) {\n    \n    // get the normal\n    vec3 n = hit_nt.xyz;\n\n    // gotta deal with borders\n\n    // need to antialias more far away\n    float border_scale = 2.0/iResolution.y;\n\n    const float border_size = 0.01;\n\n    float border = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);\n\n    // don't even try to draw borders too far away\n    border = mix(border, 0.75, smoothstep(18.0, 70.0, hit_nt.w));\n\n    // diffuse + ambient term\n    diffuse = min(diffuse, clamp(dot(n, light_dir), 0.0, 1.0));\n    \n    float diffamb = (diffuse * 0.8 + 0.2);\n\n    // start out white\n    vec3 color = vec3(0.94, 1.0, 0.97);\n    \n    // add in border color\n    color = mix(vec3(0.74, 0.83, 0.76), color, border);\n\n    // multiply by diffuse/ambient\n    color *= diffamb;\n\n    // consider AO\n    color *= 1.0 - ao_strength*exp(-ao_falloff*ndist);\n\n\treturn color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Just for coloring the sky\n\nvec3 sky(vec3 rd) {\n    \n    float s = 0.5*dot(light_dir, rd) + 0.5;\n    return mix(vec3(0.1, 0.2, 0.6), vec3(1.0, 1.0, 0.9), s*s*s);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Compute min distance between point on vertical side of a hexagon \n// and corners of occupied cells. This checks just the four cells \n// needed.\n\nfloat vertEdgeDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n \n    // Get difference on integer hex grid\n    vec3 cell_diff = prev_cell - hit_cell;\n    \n    // Normal direction across cell boundary\n    vec2 n = CART_FROM_HEX(cell_diff.xy);\n    \n    // Perpendicular vector, scaled to correct length to check corners\n    vec2 np = vec2(-n.y, n.x) * 0.5 / hex_factor;\n        \n    // Coordinates of cell center\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // We only care about difference from center when measuring distances\n    p -= cell_pos;\n    \n    // These are \"rotation\" matrices that rotate directions on the\n    // integer hex grid.  \n    const mat2 M0 = mat2(0.5, 0.75, -1.0, 0.5);\n    const mat2 M1 = mat2(0.5, -0.75, 1.0, 0.5);\n    \n    // Get directions to left and right neighbors, along with sign\n    // for perpendicular to normal\n    vec3 h[2];\n    h[0] = vec3(M0 * cell_diff.xy, 1.0);\n    h[1] = vec3(M1 * cell_diff.xy, -1.0);\n    \n    // Initialize distance to large value\n    float rval = 1e5;\n    \n    // For each neighbor direction\n    for (int i=0; i<2; ++i) {\n        \n        // Check below and above on grid\n        for (float d=-1.0; d<=1.0; d+=2.0) {\n            \n            // Get the neighbor cell\n            vec3 neighbor_cell = hit_cell + vec3(h[i].xy, d);\n            vec3 neighbor_pos = neighbor_cell * cell_size;\n            \n            // If it's occupied\n            if (map(neighbor_pos/resolution) < 0.0) {\n                \n                // Get corner with this neighbor                  \n                vec3 corner = 0.5*(vec3(np*h[i].z, cell_height*d) - cell_diff*cell_size);\n                \n                // Check distance to corner\n                rval = min(rval, length(p - corner));\n                \n            }\n        }\n    }\n    \n    return rval;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Get minimum distance to all eight connected neighbors across a \n// face, except for the occupied one (which would have\n// distance of zero).\n\nfloat neighborDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {\n            \n    // Get cell center position\n    vec3 cell_pos = prev_cell * cell_size;\n    \n    // Only care about distances relative to center\n    p -= cell_pos;\n    \n    // Cancel out some multiplication that will happen down below\n    p.z *= 2.0/cell_height;\n    \n    // Set up four neighbors and distances to walls\n    vec4 h[4];\n    \n    h[0] = vec4(0.0,  1.0, 0.0, 1.0);\n    h[1] = vec4(1.0,  0.5, 0.0, 1.0);\n    h[2] = vec4(1.0, -0.5, 0.0, 1.0);\n    h[3] = vec4(0.0,  0.0, 0.5, 0.5*cell_height);\n    \n    // Initialize return value to large number\n    float rval = 1e5;\n   \n    // For each neighbor direction...\n    for (int i=0; i<4; ++i) {\n        \n        // ...and its opposite direction\n        for (float s=-1.0; s<=1.0; s+=2.0) {\n            \n            // Get the neighbor integer grid coords\n            vec3 neighbor_cell = prev_cell + 2.0*s*h[i].xyz;\n            \n            // Ignore the one we already know is occupied\n            if (neighbor_cell != hit_cell) {\n                \n                // Get neighbor center position\n                vec3 neighbor_pos = neighbor_cell * cell_size;\n                \n                // If occupied...\n                if (map(neighbor_pos/resolution) < 0.0) {\n                \n                    // Get normal\n                    vec3 n = s * h[i].xyz * cell_size;\n                    \n                    // Update using distance to neighbor along normal\n                    rval = min(rval, h[i].w - dot(n, p));\n                \n                }   \n            }\n        }\n    }\n    \n    // Return minimum distance\n    return rval;\n    \n}\n\n#ifdef DEBUG_MAP\n\n//////////////////////////////////////////////////////////////////////\n// Just used for debugging map -- based on iq's raymarcher\n\nfloat raymarch( in vec3 ro, in vec3 rd) {\n    \n\tfloat precis = 0.0001;\n    float h = precis*2.0;\n    float t = 0.0;\n    float m = 1.0;\n    const float maxd = 1000.0;\n    \n    for( int i=0; i<100; i++ ) {\n\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    h = map( ro+rd*t );\n        \n    }\n    \n    if (t > maxd) {\n        return -1.0;\n    } else {\n        return t;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// Just used for debugging map -- based on iq's code\n\n\nvec3 calcNormal( in vec3 pos ) {\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Just used for debugging map\n\nvec3 ray_shade(vec3 ro, vec3 rd) {\n    \n    float t = raymarch(ro, rd);\n    \n    if (t < 0.0) {\n        \n        return sky(rd);\n        \n    } else {        \n        \n        vec3 p = ro + t * rd;\n        vec2 rdelta = CART_FROM_HEX(nearestHexCell(p.xy));\n        float bdist = hexDist(p.xy - rdelta);\n        vec4 hit_nt = vec4(calcNormal(p), t);\n        float ndist = 1e5;\n        \n        vec3 c = shade(hit_nt, bdist, ndist, 1.0);\n        return c.xyz;\n        \n    }\n    \n}\n\n#else\n\n//////////////////////////////////////////////////////////////////////\n// Return the normal and intersection distance for ray with origin\n// ro and direction rd.\n\nvoid raytrace(in vec3 ro, in vec3 rd,\n              out vec4 hit_nt, \n              out vec3 prev_cell,\n              out vec3 cur_cell) {\n        \n    // find nearest hex cell center to ray origin    \n    cur_cell = vec3(nearestHexCell(ro.xy), floor(ro.z/cell_height + 0.5));\n    \n    // we also will care about the cell we entered in from\n    prev_cell = cur_cell;\n    \n    // current cell center\n    vec3 cur_center = cur_cell * cell_size;\n\n    // see if ray is pointed up or down\n    float dz = rd.z < 0.0 ? -1.0 : 1.0;\n\n    // get the three candidate wall directions for this ray (i.e. the\n    // three hex side directions that correspond to normals with positive\n    // dot products to ray direction)\n    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);\n    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);\n    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);\n\n\t// have we hit a hex yet?    \n    bool hit = false;\n    \n    // initialize normal to zero and intersection distance to negative\n    hit_nt = vec4(0, 0, 0, -1.0);    \n\n    // march along ray, one iteration per cell\n    for (int i=0; i<grid_steps; ++i) {\n        \n        // once we hit we're good\n        if (hit) { continue; }\n        \n        // distance from ray origin to current cell center\n        vec3 rdelta = ro-cur_center;\n        \n        // first, test intersections with sides:\n        // after three tests, ht.xy holds the direction, ht.z holds the\n        // ray distance parameter with intersecting sides\n        vec3 ht = rayHexIntersect(rdelta.xy, rd.xy, h0);\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h1));\n        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h2));\n        \n        // next, test intersection with top/bottom \n        float tz = (0.5*dz*cell_height - rdelta.z) / rd.z;\n        \n        // now we will need to figure out how to update the current cell\n        // either horizontally or vertically.\n        \n        // stash the previous cell\n        prev_cell = cur_cell;        \n\n        // variable to hold return value if we do hit\n        vec4 new_nt;\n \n        // check whether we hit top/bottom before side\n        if (tz < ht.z) {\n            \n            // hit top/bottom first, so march vertically\n            cur_cell.z += dz;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(0, 0, -dz, tz);\n            \n        } else {\n            \n            // hit side first, so march horizontally\n            cur_cell.xy += 2.0*ht.xy;\n            \n            // set up normal and ray distance for return value\n            new_nt = vec4(-CART_FROM_HEX(ht.xy), 0, ht.z);\n            \n        }\n        \n        // we updated the current cell, now update the cell center position\n        cur_center = cur_cell * cell_size;\n            \n        // see if the new cell center is occupied\n        if (map(cur_center/resolution) < 0.0) {\n            hit = true;\n            hit_nt = new_nt;\n        }\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Return the color for a ray with origin ro and direction rd\n\nvec3 ray_shade(in vec3 ro, in vec3 rd) {\n    \n    // handle resolution scaling\n    ro *= resolution;\n\n    // hit_nt will hold normal and distance\n    vec4 hit_nt;\n    \n    // prev_cell and hit_cell store cell before and after intersection\n    vec3 prev_cell, hit_cell;\n    \n    // do raytrace\n    raytrace(ro, rd, hit_nt, prev_cell, hit_cell);\n    \n    // output color\n    vec3 color;\n    \n    // if ray hit\n    if (hit_nt.w >= 0.0) {\n        \n        // get the cell center where it hit\n        vec3 cell_center = hit_cell * cell_size;\n        \n        // get the intersection point\n        vec3 pintersect = ro + rd * hit_nt.w;\n        \n        // store distance to border, to neighbor cell\n        float bdist, ndist;\n        \n        // see if we hit top/bottom or side\n        if (abs(hit_nt.z) > 0.0) {\n            \n            // was top/bottom\n            bdist = hexDist(pintersect.xy - cell_center.xy);\n            ndist = neighborDist(prev_cell, hit_cell, pintersect); \n            \n        } else {\n            \n            // was side\n            vec2 n = hit_nt.xy;\n            bdist = abs(fract(pintersect.z/cell_height)-0.5)*cell_height;\n                    \n            vec2 p = pintersect.xy - cell_center.xy;\n            p -= n * dot(p, n);\n            bdist = min(bdist, abs(length(p) - 0.5/hex_factor));\n            \n            ndist = neighborDist(prev_cell, hit_cell, pintersect);\n            ndist = min(ndist, vertEdgeDist(prev_cell, hit_cell, pintersect));\n\n        }\n        \n        // default case: assume shadow - note for \"realism\" we would set 0.0 here\n        float diffuse = 0.5;\n        \n        // see if on lit side\n        if (dot(hit_nt.xyz, light_dir) > 0.0) {\n            \n            // shadow ray\n            vec4 shadow_nt;\n            raytrace(pintersect + 0.001*hit_nt.xyz, light_dir, \n                     shadow_nt, prev_cell, hit_cell);\n            \n            // full light if shadow ray missed\n            if (shadow_nt.w < 0.0) { diffuse = 1.0; }\n\n            \n        }\n        \n        // shade the hit point\n        color = shade(hit_nt, bdist, ndist, diffuse);\n\n        \n    } else {\n        \n        // no ray hit, cheesy sky\n       color = sky(rd);\n        \n    }\n    \n\treturn color;\n\t\n}\t\n\n#endif\n\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    light_dir = normalize(light_dir);\n    float ltheta = 0.2*iTime;\n    float c = cos(ltheta);\n    float s = sin(ltheta);\n    light_dir.xy = mat2(c, -s, s, c) * light_dir.xy;\n\t\n\tconst float yscl = 720.0;\n\tconst float f = 500.0;\n\t\n    vec2 uvn = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\tvec2 uv = uvn * yscl;\n\t\n\tvec3 pos = vec3(-18.0, 0.0, 10.0);\n\tvec3 tgt = vec3(0, 0, 4.0);\n\tvec3 up = vec3(0.0, 0.0, 1.0);\n\t\n\tvec3 rz = normalize(tgt - pos);\n\tvec3 rx = normalize(cross(rz,up));\n\tvec3 ry = cross(rx,rz);\n    \n    mat3 R = mat3(rx,ry,rz);\n\t \n\tvec3 rd = normalize(vec3(uv, f));\n\tvec3 ro = pos;\n\n\tfloat thetax = 0.15;\n\tfloat thetay = 0.6;\n\t\n\tif (iMouse.y > 10.0 || iMouse.x > 10.0) { \n\t\tthetax = (iMouse.y - 0.5*iResolution.y) * -1.25/iResolution.y;\n\t\tthetay = (iMouse.x - 0.5*iResolution.x) * 6.28/iResolution.x; \n\t}\n\n\tfloat cx = cos(thetax);\n\tfloat sx = sin(thetax);\n\tfloat cy = cos(thetay);\n\tfloat sy = sin(thetay);\n\t\n\tmat3 Rx = mat3(cx, 0.0, -sx,\n\t\t\t\t   0.0, 1.0, 0.0,\n\t\t\t\t   sx, 0.0, cx);\n\n    \n    mat3 Ry = mat3(cy, -sy, 0.0,\n                   sy, cy, 0.0,\n                  0.0, 0.0, 1.0);\n\n\t\n    ro = Ry*Rx*(pos-tgt) + tgt;\n    rd = Ry*Rx*R*rd;\n\n\tvec3 color;\n    \n    color = ray_shade(ro, rd);\n    \n\tcolor = sqrt(color);\n\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1227, 1227, 1250, 1250, 1326], [1491, 1491, 1525, 1599, 2133], [2271, 2271, 2305, 2305, 2354], [2481, 2481, 2538, 2565, 2746], [2871, 2871, 2900, 2900, 2932], [3093, 3093, 3126, 3126, 3191], [3193, 3193, 3212, 3212, 3406], [3641, 3641, 3707, 3734, 4565], [4668, 4668, 4687, 4687, 4803], [5024, 5024, 5083, 5127, 6837], [7055, 7055, 7114, 7159, 8721], [15849, 15849, 15906, 15906, 17194]], "test": "ok"}
{"id": "ldBcDt", "name": "Path Tracer MIS", "author": "koiava", "description": "Example Path Tracer which does Next Event Estimation and Multiple Importance Sampling.\nCheck direct light demo with MIS here : https://www.shadertoy.com/view/4sSXWt ", "tags": ["pathtracer", "microfacet", "pbr", "pt", "render", "ggx", "lightpathtracing"], "likes": 36, "viewed": 2729, "published": "Public API", "date": "1494328876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PIXEL_SAMPLES \t\t1\t\t//samples per pixel. Increase for better image quality\n#define DL_SAMPLES\t\t\t1\t\t//direct light samples\n#define MAX_DEPTH\t\t\t3\t\t//GI depth\n#define LENS_SIZE\t\t\t0.2\t\t//depth of field\n#define CLAMP_VALUE\t\t\t2.0\t\t//biased rendering\n#define CLAMP_CAUSTICS\t\t\t\t//biased rendering\n//#define TEXTURES\t\t\t//uncomment to enable textures\n//#define NORMAL_MAPS\t\t//uncomment to enable normal mapping(textures are necessery for normal mapping)\n\n#define SPHERE_LIGHT\n\nconst vec3 backgroundColor = vec3( 0.0 );\n\n//used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\nbool is_inf(float val) {\n\treturn val != val;\n    //return isinf(val);\t//webGL 2.0 is required\n}\n\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n\nfloat misWeight( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\n//////////////////////////////////////////////////////////////////////////\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0/v.w);\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n//fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n      \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int mtl_id_;\n};\n    \n#define SURFACE_ID_BASE\t0\n#define LIGHT_ID_BASE\t64\n\n#define MTL_LIGHT \t\t0\n#define MTL_DIFFUSE\t\t1\n    \n\n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n#define OBJ_DISK\t\t4\n#define OBJ_TORUS\t\t5\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n\n//Weighted sum of Lambertian and Blinn brdfs\nstruct Material {\n    vec3 diffuse_color_;\n    int diffuse_color_tex_;\n    vec3 specular_color_;\n    float specular_roughness_;\n    int specular_roughness_tex_;\n    float specular_weight_;\n    int specular_weight_tex_;\n    int normal_map_;\n    float tex_scale_;\n};\n    \nstruct Light {\n    vec3 color_;\n    float intensity_;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n    float lensSize;\n    float focusDist;\n};\n    \nstruct LightSamplingRecord {\n    vec3 w;\n    float d;\n    float pdf;\n};\n    \n// ************ SCENE ***************\nLight lights[2];\nMaterial materials[7];\nObject objects[8];\nCamera camera;\n//***********************************\nMaterial getMaterial(int i) {\n    if(i==0) return materials[0]; else\n        if(i==1) return materials[1]; else\n            if(i==2) return materials[2]; else\n                if(i==3) return materials[3]; else\n                    if(i==4) return materials[4]; else\n                        if(i==5) return materials[5]; else\n                            return materials[6];\n    //return materials[i];\t//webGL 2.0\n}\n\nLight getLight(int i) {\n    if(i==0) return lights[0]; else\n        return lights[1];\n    //return lights[i];\n}\n\nvec3 getColor(vec2 uv, int tex) {\n#ifdef TEXTURES\n    if(tex==0)\treturn texture( iChannel0, uv).xyz; else\n    if(tex==1)\treturn texture( iChannel1, uv).xyz; else\n    \t\t\treturn texture( iChannel2, uv).xyz;\n#else\n    if(tex==0)\treturn vec3(0.8, 0.5, 0.3);\n    if(tex==1)\treturn vec3(0.5, 0.5, 0.6);\n\t\t\t\treturn vec3(0.7, 0.7, 0.7);\n#endif\n}\n\nvec3 getNormal(vec2 uv, int tex ) {\n#ifdef NORMAL_MAPS\n    float heightScale = 0.004;\n    float dHdU, dHdV;\n    \n    float hpx, hmx, hpy, hmy, h0;\n    vec3 c, c1, c2, c3, c4;\n    vec2 duv;\n    \n    if(tex==0){\n        vec2 res = iChannelResolution[0].xy;\n    \tduv = vec2(1.0) / res.xy;\n \t\tc = texture( iChannel0, uv).xyz;\n        c1 = texture( iChannel0, uv + vec2(duv.x, 0.0)).xyz;\n        c2 = texture( iChannel0, uv - vec2(duv.x, 0.0)).xyz;\n        c3 = texture( iChannel0, uv + vec2(0.0, duv.y)).xyz;\n        c4 = texture( iChannel0, uv - vec2(0.0, duv.y)).xyz;\n    } else if(tex==1) {\n        vec2 res = iChannelResolution[1].xy;\n    \tduv = vec2(1.0) / res.xy;\n        c = texture( iChannel1, uv).xyz;\n        c1 = texture( iChannel1, uv + vec2(duv.x, 0.0)).xyz;\n        c2 = texture( iChannel1, uv - vec2(duv.x, 0.0)).xyz;\n        c3 = texture( iChannel1, uv + vec2(0.0, duv.y)).xyz;\n        c4 = texture( iChannel1, uv - vec2(0.0, duv.y)).xyz;\n        res = iChannelResolution[1].xy;\n    } else {\n        vec2 res = iChannelResolution[2].xy;\n    \tduv = vec2(1.0) / res.xy;\n        c = texture( iChannel2, uv).xyz;\n        c1 = texture( iChannel2, uv + vec2(duv.x, 0.0)).xyz;\n        c2 = texture( iChannel2, uv - vec2(duv.x, 0.0)).xyz;\n        c3 = texture( iChannel2, uv + vec2(0.0, duv.y)).xyz;\n        c4 = texture( iChannel2, uv - vec2(0.0, duv.y)).xyz;\n        res = iChannelResolution[2].xy;\n    }\n    \n    h0\t= heightScale * dot(c , vec3(1.0/3.0));\n    hpx = heightScale * dot(c1, vec3(1.0/3.0));\n    hmx = heightScale * dot(c2, vec3(1.0/3.0));\n    hpy = heightScale * dot(c3, vec3(1.0/3.0));\n    hmy = heightScale * dot(c4, vec3(1.0/3.0));\n    dHdU = (hmx - hpx) / (2.0 * duv.x);\n    dHdV = (hmy - hpy) / (2.0 * duv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n#else\n    return vec3(0.0, 0.0, 1.0);\n#endif\n}\n\nvec3 getRadiance(vec2 uv) {\n    return /*getColor(uv, 2)*lights[0].color_**/vec3(1.0, 1.0, 1.0)*lights[0].intensity_;\n}\n\nvoid createMaterial(vec3 diff,\n                    int diff_tex,\n                    vec3 spec,\n                    float roughness,\n                    int roughness_tex,\n                   \tfloat weight,\n                    int weight_tex,\n                    int normal_map,\n                    float tex_scale,\n                    out Material mtl) {\n    mtl.diffuse_color_ = diff;\n    mtl.diffuse_color_tex_ = diff_tex;\n    mtl.specular_color_ = spec;\n    mtl.specular_roughness_ = roughness;\n    mtl.specular_roughness_tex_ = roughness_tex;\n    mtl.specular_weight_ = weight;\n    mtl.specular_weight_tex_ = weight_tex;\n    mtl.normal_map_ = normal_map;\n    mtl.tex_scale_ = tex_scale;\n}\n\nvoid createLight(vec3 color, float intensity, out Light light) {\n    light.color_ = color;\n    light.intensity_ = intensity;\n}\n\nvoid createAABB( mat4 transform, vec3 bound_min, vec3 bound_max, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_AABB;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = bound_min.x;\n    obj.params_[1] = bound_min.y;\n    obj.params_[2] = bound_min.z;\n    obj.params_[3] = bound_max.x;\n    obj.params_[4] = bound_max.y;\n    obj.params_[5] = bound_max.z;\n}\n\nvoid createTorus( mat4 transform, float R, float r, int mtl, out Object obj) {\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    obj.type_ = OBJ_TORUS;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = R*R;\n    obj.params_[1] = r*r;\n}\n\nvoid createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {\n    obj.type_ = OBJ_PLANE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = minX;\t\t\t//min x\n    obj.params_[1] = minY;\t\t\t//min y\n    obj.params_[2] = maxX;\t\t\t//max x\n    obj.params_[3] = maxY;\t\t\t//max y\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createDisk(mat4 transform, float r, float R, int mtl, out Object obj) {\n    obj.type_ = OBJ_DISK;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r*r;\n    obj.params_[1] = R*R;\n}\n\nvoid createSphere(mat4 transform, float r, int mtl, out Object obj) {\n    obj.type_ = OBJ_SPHERE;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = r*r;\t\t//radius^2\n    obj.params_[2] = 0.0;\t\t//not used\n    obj.params_[3] = 0.0;\t\t//not used\n    obj.params_[4] = 0.0;\t\t//not used \n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nvoid createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {\n    obj.type_ = OBJ_CYLINDER;\n    obj.mtl_id_ = mtl;\n    obj.transform_ = transform;\n    obj.transform_inv_ = mat4Inverse( obj.transform_ );\n    obj.params_[0] = r;\t\t\t//radius\n    obj.params_[1] = minZ;\t\t//min z\n    obj.params_[2] = maxZ;\t\t//max z\n    obj.params_[3] = maxTheta;\t//max phi\n    obj.params_[4] = 0.0;\t\t//not used\n    obj.params_[5] = 0.0;\t\t//not used\n}\n\nmat4 createCS(vec3 p, vec3 z, vec3 x) {\n    z = normalize(z);\n    vec3 y = normalize(cross(z,x));\n    x = cross(y,z);\n    \n    return mat4(\tvec4( x, 0.0 ), \n    \t\t\t \tvec4( y, 0.0 ),\n    \t\t\t\tvec4( z, 0.0 ),\n    \t\t\t\tvec4( p, 1.0 ));\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(1.0 - Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n//taken from: https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n// ************************   Scattering functions  *************************\nbool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){\n\treturn ((dot(n,a)*dot(n,b))>0.0);\n}\n\nbool sameHemisphere(in vec3 a, in vec3 b){\n\treturn (a.z*b.z>0.0);\n}\n\nfloat cosTheta(vec3 w) { return w.z; }\nfloat cosTheta2(vec3 w) { return cosTheta(w)*cosTheta(w); }\nfloat absCosTheta(vec3 w) { return abs(w.z); }\nfloat sinTheta2(vec3 w) { return max(0.0, 1.0 - cosTheta2(w)); }\nfloat sinTheta(vec3 w) { return sqrt(sinTheta2(w)); }\nfloat tanTheta2(vec3 w) { return sinTheta2(w) / cosTheta2(w); }\nfloat tanTheta(vec3 w) { return sinTheta(w) / cosTheta(w); }\n\nfloat cosPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 1.0 : clamp(w.x / sin_Theta, -1.0, 1.0); }\nfloat sinPhi(vec3 w) { float sin_Theta = sinTheta(w); return (sin_Theta == 0.0) ? 0.0 : clamp(w.y / sin_Theta, -1.0, 1.0); }\nfloat cosPhi2(vec3 w) { return cosPhi(w) * cosPhi(w); }\nfloat sinPhi2(vec3 w) { return sinPhi(w) * sinPhi(w); }\n\nfloat ggx_eval(vec3 wh, float alphax, float alphay) {\n    float tan2Theta = tanTheta2(wh);\n    if (is_inf(tan2Theta)) return 0.;\n    float cos4Theta = cosTheta2(wh) * cosTheta2(wh);\n    float e = ((cosPhi2(wh) + sinPhi2(wh)) / (alphax * alphay)) * tan2Theta;\n    return 1.0 / (PI * (alphax * alphay) * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\nvec3 ggx_sample(vec3 wi, float alphax, float alphay, float Xi1, float Xi2) {\n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(Xi1);\n    float phi = (Xi2 < a) ? Xi2 / a*PI : PI + (Xi2 - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((Xi2 < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\n\nfloat ggx_lambda(vec3 w, float alphax, float alphay) {\n    float absTanTheta = abs(tanTheta(w));\n    if (is_inf(absTanTheta)) return 0.;\n    // Compute _alpha_ for direction _w_\n    float alpha_ = sqrt((cosPhi2(w) + sinPhi2(w)) * (alphax * alphay));\n    float alpha2Tan2Theta = (alpha_ * absTanTheta) * (alpha_ * absTanTheta);\n    return (-1.0 + sqrt(1.0 + alpha2Tan2Theta)) / 2.0;\n}\n\nfloat ggx_g1(vec3 w, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(w, alphax, alphay));\n}\n\nfloat ggx_g(vec3 wo, vec3 wi, float alphax, float alphay) {\n    return 1.0 / (1.0 + ggx_lambda(wo, alphax, alphay) + ggx_lambda(wi, alphax, alphay));\n}\n\nfloat ggx_pdf(vec3 wi, vec3 wh, float alphax, float alphay) {\n    return ggx_eval(wh, alphax, alphay) * ggx_g1(wi, alphax, alphay) * abs(dot(wi, wh)) / abs(wi.z);\n}\n\nvec3 fresnelConductor( float cosTheta, vec3 eta, vec3 k ) {\n\tvec3 tmp = (eta*eta + k*k) * (cosTheta * cosTheta);\n\n\tvec3 rParl2 = \t(tmp - (eta * (2.0 * cosTheta)) + vec3(1.0)) /\n        \t\t\t(tmp + (eta * (2.0 * cosTheta)) + vec3(1.0));\n\n\tvec3 tmpF = eta*eta + k*k;\n\n\tvec3 rPerp2 = \t(tmpF - (eta * (2.0 * cosTheta)) + vec3(cosTheta*cosTheta)) /\n\t\t\t\t\t(tmpF + (eta * (2.0 * cosTheta)) + vec3(cosTheta*cosTheta));\n\n\treturn (rParl2 + rPerp2) / 2.0;\n}\n\nvec3 mtlEval(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    float alpha = mtl.specular_roughness_;\n    \n    if(!sameHemisphere(E_local, L_local)) {\n        return vec3(0.0);\n    }\n    \n    //Specular reflection ***********************************\n    float cosThetaO = abs(E_local.z), cosThetaI = abs(L_local.z);\n    vec3 wh = L_local + E_local;\n    // Handle degenerate cases for microfacet reflection\n    if (cosThetaI == 0.0 || cosThetaO == 0.0) return vec3(0.);\n    if (wh.x == 0.0 && wh.y == 0.0 && wh.z == 0.0) return vec3(0.);\n    \n    wh = normalize(wh);\n    \n    vec3 F = fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0));\n    vec3 spec_Refl = \tmtl.specular_color_ * \n        \t\t\t\tggx_eval(wh, alpha, alpha) *\n        \t\t\t\tggx_g(E_local, L_local, alpha, alpha) *\n        \t\t\t\tF / (4.0 * cosThetaI * cosThetaO);\n    \n    vec3 diff_refl = \tvec3(INV_PI) * \n        \t\t\t\tmtl.diffuse_color_ * \n        \t\t\t\t(vec3(1.0) - F);\n    \n    return \tmix(diff_refl, spec_Refl, mtl.specular_weight_);\n}\n\nvec3 mtlSample(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in float Xi1, in float Xi2, out vec3 L, out float pdf, out float spec) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    \n    //convert directions to local space\n    vec3 E_local = inv_trans * E;\n    vec3 L_local;\n    \n    float alpha = mtl.specular_roughness_;\n    // Sample microfacet orientation $\\wh$ and reflected direction $\\wi$\n    if (E_local.z == 0.0) return vec3(0.);\n    vec3 wh = ggx_sample(E_local, alpha, alpha, Xi1, Xi2);\n    if (!sameHemisphere(vec3(0.0, 0.0, 1.0), E_local, wh)) {\n        wh = -wh;\n    }\n    \n    float F = length(fresnelConductor(dot(L_local, wh), vec3(1.5/1.0), vec3(1.0)));\n    //Sample specular or diffuse lobe based on fresnel\n    if(rnd() < F) {\n        L_local = reflect(E_local, wh);\n    \n        if(!sameHemisphere(E_local, L_local)){\n           L_local = -L_local;\n        }\n\n        if (!sameHemisphere(E_local, L_local)) {\n            pdf = 0.0;\n        } else {\n            // Compute PDF of _wi_ for microfacet reflection\n            pdf = ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n        }\n        //pdf *= F;\n    } else {\n        L = sampleHemisphereCosWeighted( Xi1, Xi2 );\n    \tpdf = INV_PI;\n        //pdf *= 1.0 - F;\n    }\n    \n    //convert directions to global space\n    L = trans*L_local;\n    \n    if(!sameHemisphere(Ns, E, L) || !sameHemisphere(Ng, E, L)) {\n        pdf = 0.0;\n    }\n    \n    return mtlEval(mtl, Ng, Ns, E, L);\n}\n\nfloat mtlPdf(Material mtl, in vec3 Ng, in vec3 Ns, in vec3 E, in vec3 L) {\n    mat3 trans = mat3FromNormal(Ns);\n    mat3 inv_trans = mat3Inverse( trans );\n    float alpha = mtl.specular_roughness_;\n    \n    vec3 E_local = inv_trans * E;\n    vec3 L_local = inv_trans * L;\n    \n    if(!sameHemisphere(Ng, E_local, L_local)) {\n        return 0.0;\n    }\n    float diff_pdf = abs(L_local.z)*INV_PI;\n    \n    if (!sameHemisphere(E_local, L_local)) return 0.0;\n    vec3 wh = normalize(E_local + L_local);\n    float spec_pdf = ggx_pdf(E_local, wh, alpha, alpha) / (4.0 * dot(E_local, wh));\n    \n    return mix(diff_pdf, spec_pdf, mtl.specular_weight_);\n}\n\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)/(2.0*A);\n    float t_1 = (-B+rootDiscrim)/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)/(maxY - minY);\n        }\n        \n        isect.uv_ /= 2.0;\n    }\n    \n    return true;\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi/PI;\n        isect.uv_.y = theta/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayDiskIntersection( in Ray ray, in float r2, in float R2, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) / ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    float d2 = dot(isect.position_, isect.position_);\n    \n    if( d2 < r2 || d2 > R2 )\n        return false;\n    \n    if( !forShadowTest ) {\n        float R = sqrt(R2);\n        isect.uv_.x \t\t= (isect.position_.x - R)/(2.0*R);\n        isect.uv_.y \t\t= (isect.position_.y - R)/(2.0*R);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t// Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t// Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t// Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t// Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t// Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);\n        isect.uv_.y = phi/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    //Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_DISK ) {\n        hitResult = rayDiskIntersection( rayLocal, obj.params_[0], obj.params_[1], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        //Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.mtl_id_ = obj.mtl_id_;\n        \n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    \n    for(int i=0; i<8; i++ ) {\n        CHECK_OBJ( objects[i] );\n    }\n    return ( nearestDist < 1000.0 );\n}\n// ***************************************************************************\n\n\nvoid initScene() {\n    float time = 100.0;//iTime;\n    \n    //create lights\n    createLight(vec3(1.0, 1.0, 0.9), 40.0, lights[0]);\n    \n    //Create materials\n    createMaterial(vec3(0.6, 1.0, 0.6), -1, vec3(0.5, 1.0, 0.5), 0.15, -1, 0.6, -1, -1, 1.0, materials[0]);\n    createMaterial(vec3(1.0, 1.0, 1.0), 0, vec3(1.0, 1.0, 1.0), 0.0, 0, 0.2, -1, 0, 2.0, materials[1]);\n    createMaterial(vec3(0.3, 0.5, 1.0), 1, vec3(1.0, 1.0, 1.0), 0.0, 1, 0.4, 1, 1, 1.0, materials[2]);\n    createMaterial(vec3(0.5, 0.5, 0.5), -1, vec3(0.9, 0.9, 1.0), 0.03, -1, 1.0, -1, -1, 1.0, materials[3]);\n    createMaterial(vec3(1.0, 1.0, 1.0), 2, vec3(1.0, 1.0, 1.0), 0.0, 2, 0.4, 2, 2, 1.0, materials[4]);\n    \n    //init lights\n    float r = 1.0;\n    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;\n    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;\n    float x = xFactor*7.0;\n    float z = -3.0-yFactor*5.0;\n    float a = -1.2+sin(time*0.23);\n    mat4 trans = createCS(\tvec3(x, 5.0+sin(time), z),\n                          \tvec3(0.0, sin(a), cos(a)),\n                  \t\t\tvec3(1.0, 0.0, 0.0));\n#ifdef SPHERE_LIGHT\n    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );\n#else\n    createPlane(trans, -2.0, -1.0, 2.0, 1.0, LIGHT_ID_BASE+0, objects[0]);\n#endif\n    \n    \n    //plane 1\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 5.0, -10.0, 1.0 ));\n    createPlane(trans, -10.0, -2.0, 10.0, 4.0, SURFACE_ID_BASE+1, objects[1]);\n   \n    //plane 2\n    trans = mat4(\tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, -1.0, 0.0 ),\n                    vec4( 0.0, -1.0, 0.0, 0.0 ),\n                    vec4( 0.0, -1.0, -4.0, 1.0 ));\n    createPlane(trans, -10.0, -4.0, 10.0, 2.0, SURFACE_ID_BASE+1, objects[2]);\n \n    //Cylinder\n    trans = mat4(\tvec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( -0.0, 3.0, -6.0, 1.0 ));\n    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, SURFACE_ID_BASE+1, objects[3] );\n    \n    //sphere 1\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 1.5, -0.3, -2.0, 1.0 ));\n\n    createSphere(trans, 0.7, SURFACE_ID_BASE+2, objects[4] );\n    \n    //sphere 2\n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 0.0, 0.0, -4.5, 1.0 ));\n\n    createSphere(trans, 1.0, SURFACE_ID_BASE+3, objects[5] );\n    \n    //box\n    trans = createCS(\tvec3(-1.5, -1.0, -3.0),\n                     \tvec3(0.0, 1.0, 0.0),\n                     \tvec3(0.2, 0.0, -0.7));\n    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), SURFACE_ID_BASE+0, objects[6]);\n    \n    trans = mat4( \tvec4( 1.0, 0.0, 0.0, 0.0 ),\n                    vec4( 0.0, 1.0, 0.0, 0.0 ),\n                    vec4( 0.0, 0.0, 1.0, 0.0 ),\n                    vec4( 3.5, 0.5, -4.2, 1.0 ));\n\n    createSphere(trans, 1.5, SURFACE_ID_BASE+4, objects[7] );\n    /*\n    //torus\n    trans = createCS(\tvec3(3.0, 1.0, -4.0),\n                        vec3(-0.5, 0.0, 0.5),\n                  \t    vec3(1.0, 0.0, 0.0));\n    createTorus(trans, 1.5, 0.3, SURFACE_ID_BASE+4, objects[7]);*/\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV,\n                \tin float radius,\n                \tin float focus_dist\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n    camera.focusDist = focus_dist;\n    camera.lensSize = radius;\n}\n\nvoid updateCamera( int strata ) {\n    float strataSize = 1.0/float(PIXEL_SAMPLES);\n    float r1 = strataSize*(float(strata)+rnd());\n    //update camera pos\n    float cameraZ = 4.0;\n    vec3 upDir = vec3( 0.0, 1.0, 0.0 );\n    vec3 pos1, pos2;\n    pos1 = vec3( 0.3, 1.0 + 2.0, cameraZ + 0.8 );\n\n    camera.pos = pos1;\n    \n    vec3 target = vec3( 0.3, 0.4, -5.0 );\n    \n\tvec3 back = normalize( camera.pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {\n    Ray ray;\n\t//vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\t//vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    //ray.origin = camera.pos;\n    //ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    \n    \n    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    if( camera.lensSize > EPSILON ) {\n        vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );\n        vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;\n        vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];\n        vec3 newBack = normalize(newPos - focusPoint);\n        vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );\n        vec3 newUp = cross( newBack, newRight );\n        mat3 newRotate;\n        newRotate[0] = newRight;\n        newRotate[1] = newUp;\n        newRotate[2] = newBack;\n\n\n        ray.origin = newPos;\n        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    } else {\n        ray.origin = camera.pos;\n        ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n    }\n\n\treturn ray;\n}\n\n#ifdef SPHERE_LIGHT\nvec3 sampleLightSource( \tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                          \tout LightSamplingRecord sampleRec ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    \n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    \n    float sin_theta_max_2 = sph_r2 / dc_2;\n\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    float cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n    float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    float sin_theta = sqrt(sin_theta_2);\n    sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n    //Calculate intersection distance\n\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n    sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);\n    \n    return lights[0].color_*lights[0].intensity_;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                            in vec3 wi,\n                           \tin float d,\n                            in float cosAtLight ) {\n    float sph_r2 = objects[0].params_[1];\n    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );\n    float solidangle;\n    vec3 w = sph_p - x;\t\t\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sph_r2 ) {\n    \tfloat sin_theta_max_2 = clamp( sph_r2 / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n}\n#else\nvec3 sampleLightSource(\t\tin vec3 x,\n                          \tfloat Xi1, float Xi2,\n                       out LightSamplingRecord sampleRec) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    vec3 p_local = vec3(min_x + dim_x*Xi1, min_y + dim_y*Xi2, 0.0);\n    vec3 n_local = vec3(0.0, 0.0, 1.0);\n    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );\n    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );\n    \n    float pdfA = 1.0 / (dim_x*dim_y);\n    sampleRec.w = p_global - x;\n    sampleRec.d = length(sampleRec.w);\n    sampleRec.w = normalize(sampleRec.w);\n    float cosAtLight = dot(n_global, -sampleRec.w);\n    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);\n    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);\n    \n\treturn L;\n}\n\nfloat sampleLightSourcePdf( in vec3 x,\n                               in vec3 wi,\n                             \tfloat d,\n                              \tfloat cosAtLight\n                             ) {\n    float min_x = objects[0].params_[0];\t\t\t//min x\n    float min_y = objects[0].params_[1];\t\t\t//min y\n    float max_x = objects[0].params_[2];\t\t\t//max x\n    float max_y = objects[0].params_[3];\t\t\t//max y\n    float dim_x = max_x - min_x;\n    float dim_y = max_y - min_y;\n    float pdfA = 1.0 / (dim_x*dim_y);\n    return PdfAtoW(pdfA, d*d, cosAtLight);\n}\n#endif\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );\n}\n\nLight pickOneLight(out float lightPickingPdf) {\n    lightPickingPdf = 1.0;\n    return lights[0];\n}\n\nvoid fixMtl(inout Material mtl, vec2 uv, out vec3 ns) {\n    uv *= mtl.tex_scale_;\n    if(mtl.diffuse_color_tex_!=-1){\n        mtl.diffuse_color_ = getColor(uv, mtl.diffuse_color_tex_);\n    }\n    \n    if(mtl.specular_roughness_tex_!=-1){\n        mtl.specular_roughness_ = (1.0 - sqrt(getColor(uv, mtl.specular_roughness_tex_).x))*0.8;\n    } else {\n        mtl.specular_roughness_ = sqrt(mtl.specular_roughness_);\n    }\n    \n    if(mtl.specular_weight_tex_!=-1){\n        mtl.specular_weight_ = (getColor(uv, mtl.specular_weight_tex_).x)*0.6;\n    }\n    if(mtl.normal_map_!=-1){\n        ns = getNormal(uv, mtl.normal_map_ );\n    } else {\n        ns = vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec3 sampleBSDF(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex,\n                \tout vec3 wo,\n                \tout float brdfPdfW,\n                \tout vec3 fr,\n                \tout bool hitRes,\n                \tout SurfaceHitInfo hit,\n               \t\tout float spec) {\n    vec3 Lo = vec3(0.0);\n    for(int i=0; i<DL_SAMPLES; i++){\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n        fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW, spec);\n        \n        //fr = eval(mtl, ng, ns, wi, wo);\n\n        float dotNWo = dot(wo, ns);\n        //Continue if sampled direction is under surface\n        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {\n            Ray shadowRay = Ray(x, wo);\n\n            //abstractLight* pLight = 0;\n            float cosAtLight = 1.0;\n            float distanceToLight = -1.0;\n            vec3 Li = vec3(0.0);\n\n            {\n                float distToHit;\n\n                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {\n                    if(hit.mtl_id_>=LIGHT_ID_BASE) {\n                        distanceToLight = distToHit;\n                        cosAtLight = dot(hit.normal_, -wo);\n                        if(cosAtLight > 0.0) {\n                            Li = getRadiance(hit.uv_);\n                            //Li = lights[0].color_*lights[0].intensity_;\n                        }\n                    } else {\n                        hitRes = true;\n                    }\n                } else {\n                    hitRes = false;\n                    //TODO check for infinite lights\n                }\n            }\n\n            if (distanceToLight>0.0) {\n                if (cosAtLight > 0.0) {\n                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;\n\n                    if (useMIS/* && !(mtl->isSingular())*/) {\n                        float lightPickPdf = 1.0;//lightPickingPdf(x, n);\n                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );\n                        //float lightPdfW = sphericalLightSamplingPdf( x, wi );//pLight->pdfIlluminate(x, wo, distanceToLight, cosAtLight) * lightPickPdf;\n\n                        contribution *= misWeight(brdfPdfW, lightPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 salmpleLight(\tin vec3 x,\n                  \tin vec3 ng,\n                  \tin vec3 ns,\n                  \tin vec3 wi,\n                  \tin Material mtl,\n                  \tin bool useMIS,\n                  \tin int strataCount,\n                  \tin int strataIndex ) {\n    vec3 Lo = vec3(0.0);\t//outgoing radiance\n\n    for(int i=0; i<DL_SAMPLES; i++) {\n        float lightPickingPdf;\n        Light light = pickOneLight(lightPickingPdf);\n\n        vec3 wo;\n        float lightPdfW, lightDist;\n\n        LightSamplingRecord rec;\n        float Xi1 = rnd();\n        float Xi2 = rnd();\n        float strataSize = 1.0 / float(strataCount);\n        Xi2 = strataSize * (float(strataIndex) + Xi2);\n\n        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );\n        //vec3 Li = sampleSphericalLight( x, Xi1, Xi2, rec );\n        wo = rec.w;\n        lightPdfW = rec.pdf;\n        lightDist = rec.d;\n        lightPdfW *= lightPickingPdf;\n\n        float dotNWo = dot(wo, ns);\n\n        if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {\n            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);\n            if(dot(fr,fr)>0.0) {\n                Ray shadowRay = Ray(x, wo);\n                if (isLightVisible( shadowRay )) {\n                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;\n\n                    if (useMIS /*&& !(light->isSingular())*/) {\n                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);\n                        contribution *= misWeight(lightPdfW, brdfPdfW);\n                    }\n\n                    Lo += contribution;\n                }\n            }\n        }\n    }\n\n    return Lo*(1.0/float(DL_SAMPLES));\n}\n\nvec3 Radiance( in Ray r, int strataCount, int strataIndex ) {\n    vec3 Lo = vec3(0.0), fr, directLight, pathWeight = vec3(1.0, 1.0, 1.0);\n    vec3 wo;\n    float woPdf;\n    float dotWoN;\n    bool hitResult;\n\n    //Calculate first intersections to determine first scattering event\n    Ray ray = r;\n    SurfaceHitInfo event;\n    SurfaceHitInfo nextEvent;\n    float dist;\n    if(!raySceneIntersection( ray, 0.0, false, event, dist )) {\n        return Lo;\n    } else {\n        //We have to add emmision component on first hit\n        if( event.mtl_id_ >= LIGHT_ID_BASE ) {\n            Light light = getLight(event.mtl_id_ - LIGHT_ID_BASE);\n            float cosAtLight = dot(event.normal_, -ray.dir);\n            if(cosAtLight > 0.0) {\n                Lo = getRadiance(event.uv_);\n                //Lo = light.color_*light.intensity_;\n            }\n        }\n    }\n    \n    float prev_spec;\n\n    for (int i = 0; i < MAX_DEPTH; i++) {\n        if(event.mtl_id_>=LIGHT_ID_BASE){\n        \tbreak;\n    \t}\n        \n        vec3 x = event.position_;\n        vec3 wi = -ray.dir;\n        if(dot(wi, event.normal_) < 0.0) {\n            event.normal_ *= -1.0;\n        }\n        \n        Material mtl = getMaterial(event.mtl_id_);\n    \tvec3 ng = event.normal_, ns;\n    \tfixMtl(mtl, event.uv_, ns);\n    \n        mat3 frame;\n        frame[0] = event.tangent_;\n        frame[1] = cross( ng, event.tangent_ );\n        frame[2] = ng;\n        ns = frame*ns;\n        \n        if (dot(wi,ns) < 0.0) { break; }\n        \n        if(i!=0) {\n            strataCount = 1; strataIndex = 0;\n        }\n        \n        float spec;\n\n        //Calculate direct light with 'Light sampling' and 'BSDF sampling' techniques\n        //In addition BSDF sampling does next event estimation and returns all necessary values which corresponds to next event\n       \tdirectLight  = salmpleLight (x, ng, ns, wi, mtl, true, strataCount, strataIndex);\n        directLight += sampleBSDF   (x, ng, ns, wi, mtl, true, strataCount, strataIndex, wo, woPdf, fr, hitResult, nextEvent, spec);\n       \n#ifdef CLAMP_CAUSTICS\n        if(i!=0) {\n            if(prev_spec < spec) {\n                break;\n            }\n        }\n        prev_spec = spec;\n#endif\n        if(pathWeight.x > 1.0 || pathWeight.y > 1.0 || pathWeight.z > 1.0)\n            break;\n        \n        Lo += directLight*pathWeight;\n\n        if (!hitResult || (dotWoN = dot(event.normal_, wo))<0.0) { break; }\n        if (woPdf == 0.0) { break; }\n        pathWeight *= fr*dotWoN / woPdf;\n\n        //Update values for next iteration\n        ray = Ray(event.position_, wo);\n        event = nextEvent;\n    }\n\n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n    float fov = radians(45.0);\n    initCamera( vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 0.0, 0.0 ),\n               vec3( 0.0, 1.0, 0.0 ),\n               fov,\n               LENS_SIZE,\n               9.0\n              );\n\n    initScene();\n\n    vec3 accumulatedColor = vec3( 0.0 );\n    float oneOverSPP = 1.0/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n    Ray ray;\n\n    for( int si=0; si<PIXEL_SAMPLES; ++si ){\n        updateCamera( si );\n\n        vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n        ray = genRay( screenCoord, rnd(), rnd() );\n\n        if( length( ray.dir ) < 0.2 ) {\n            accumulatedColor = vec3( 0.0 );\n        } else {\n            vec3 Li = Radiance( ray, PIXEL_SAMPLES, si );\n            Li = vec3(min(Li.x, CLAMP_VALUE), min(Li.y, CLAMP_VALUE), min(Li.z, CLAMP_VALUE));\n            accumulatedColor += Li;\n        }\n    }\n\n    //devide to sample count\n    accumulatedColor = accumulatedColor*oneOverSPP;\n    accumulatedColor = pow(accumulatedColor, vec3(1.0/2.2));\n    //accumulatedColor = accumulate(fragCoord, accumulatedColor);\n\n    fragColor = vec4( accumulatedColor, 1.0 );\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[912, 912, 936, 936, 1007], [1009, 1106, 1119, 1119, 1162], [1202, 1320, 1380, 1380, 1473], [1475, 1526, 1586, 1586, 1726], [1728, 1728, 1771, 1771, 1861], [1938, 1938, 1961, 1961, 2051], [2053, 2053, 2084, 2084, 2235], [2237, 2276, 2307, 2307, 2693], [3908, 3946, 3975, 3975, 4359], [4361, 4361, 4384, 4384, 4472], [4474, 4474, 4507, 4507, 4811], [4813, 4813, 4848, 4848, 6644], [6646, 6646, 6673, 6673, 6765], [6767, 6767, 7121, 7121, 7459], [7461, 7461, 7525, 7525, 7587], [7589, 7589, 7680, 7680, 8116], [8118, 8118, 8196, 8196, 8481], [8483, 8483, 8590, 8590, 8954], [8956, 8956, 9032, 9032, 9223], [9225, 9225, 9294, 9294, 9661], [9663, 9663, 9774, 9774, 10141], [10143, 10143, 10182, 10182, 10375], [10377, 10459, 10537, 10537, 10651], [10653, 10653, 10743, 10743, 10893], [10895, 10947, 10994, 10994, 11236], [11238, 11238, 11270, 11270, 11340], [11342, 11342, 11397, 11397, 11497], [11499, 11499, 11669, 11669, 11800], [11802, 11802, 11875, 11875, 11983], [11985, 11985, 12060, 12060, 12203], [12205, 12205, 12269, 12269, 12393], [12395, 12395, 12447, 12447, 12575], [12657, 12735, 12788, 12788, 12825], [12827, 12827, 12869, 12869, 12894], [12896, 12896, 12920, 12920, 12934], [12935, 12935, 12960, 12960, 12994], [12995, 12995, 13022, 13022, 13041], [13042, 13042, 13067, 13067, 13106], [13107, 13107, 13131, 13131, 13160], [13161, 13161, 13186, 13186, 13224], [13225, 13225, 13249, 13249, 13285], [13287, 13287, 13309, 13309, 13411], [13412, 13412, 13434, 13434, 13536], [13537, 13537, 13560, 13560, 13592], [13593, 13593, 13616, 13616, 13648], [13650, 13650, 13703, 13703, 13989], [13991, 13991, 14067, 14086, 14713], [14716, 14716, 14770, 14770, 15099], [15101, 15101, 15151, 15151, 15209], [15211, 15211, 15270, 15270, 15362], [15364, 15364, 15425, 15425, 15528], [15530, 15530, 15589, 15589, 15973], [15975, 15975, 16049, 16049, 17153], [17155, 17155, 17291, 17291, 18662], [18664, 18664, 18738, 18738, 19310], [19313, 19392, 19468, 19468, 19758], [19760, 19760, 19934, 19934, 22337], [22339, 22339, 22467, 22467, 23349], [23351, 23351, 23520, 23520, 24145], [24147, 24147, 24275, 24275, 24839], [24841, 24841, 25009, 25009, 26287], [26289, 26289, 26442, 26442, 28150], [28396, 28396, 28525, 28525, 28665], [28747, 28747, 28765, 28765, 32203], [32205, 32277, 32494, 32494, 32813], [33399, 33399, 33456, 33456, 34675], [38140, 38140, 38178, 38178, 38359], [38361, 38361, 38408, 38408, 38459], [38461, 38461, 38516, 38516, 39136], [43448, 43448, 43509, 43509, 46077]], "test": "ok"}
{"id": "ldBcR1", "name": "Nova invite WIP", "author": "psonice", "description": "Just WIP for Nova invite.", "tags": ["raymarching", "wip", "invite", "nova", "demoparty"], "likes": 4, "viewed": 135, "published": "Public", "date": "1494883213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Set these for sync:\n#define BPM 120. // Song BPM\n#define SYNCBEATS 1. // 1 = 1 pulse per bar, 4 = 1 pulse for beat for 4:4\n#define SYNCVAL (BPM / SYNCBEATS)\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n\n#define kINFINITY 10000.0 // An unimaginably large number\n#define kSQRT2 1.414213\n#define kISQRT2 0.707107\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 180\n#define kEPSILON 0.01\n#define kMAXINTERSECTIONS 1\n\n// refractive index\n#define kREFRACT 1.0/1.5\n\n// materials\n#define kSEAMATERIAL 0\n#define kSCROLLMATERIAL 1\n#define kGLOWMATERIAL 3\n\n#define kSEACOLOUR vec3(0.6, 0.7, 0.65)\n#define kGLOWCOLOUR vec3(0.8)\n\n#define kZENITHCOLOUR vec3(0.0, 0.1, 0.3)\n#define kNADIRCOLOUR vec3(0.7, 0.6, 0.4)\n#define kHORIZONCOLOUR vec3(0.5, 0.4, 0.2)\n#define kSUNCOLOUR vec3(100, 90, 70)\n\nstruct Char {\n\tfloat[5] bits;\n};\n\n#define _A Char(float[5](56.5, 68.5, 124.5, 68.5, 68.5))\n#define _B Char(float[5](120.5, 68.5, 120.5, 68.5, 120.5))\n#define _C Char(float[5](60.5, 64.5, 64.5, 64.5, 60.5))\n#define _D Char(float[5](120.5, 68.5, 68.5, 68.5, 120.5))\n#define _E Char(float[5](60.5, 64.5, 120.5, 64.5, 124.5))\n#define _F Char(float[5](60.5, 64.5, 120.5, 64.5, 64.5))\n#define _G Char(float[5](60.5, 64.5, 76.5, 68.5, 124.5))\n#define _H Char(float[5](68.5, 68.5, 124.5, 68.5, 68.5))\n#define _I Char(float[5](124.5, 16.5, 16.5, 16.5, 124.5))\n#define _J Char(float[5](124.5, 4.5, 4.5, 68.5, 120.5))\n#define _K Char(float[5](68.5, 72.5, 112.5, 72.5, 68.5))\n#define _L Char(float[5](64.5, 64.5, 64.5, 64.5, 124.5))\n#define _M Char(float[5](120.5, 84.5, 84.5, 84.5, 68.5))\n#define _N Char(float[5](52.5, 84.5, 84.5, 84.5, 92.5))\n#define _O Char(float[5](56.5, 68.5, 68.5, 68.5, 56.5))\n#define _P Char(float[5](120.5, 68.5, 120.5, 64.5, 64.5))\n#define _Q Char(float[5](56.5, 68.5, 84.5, 72.5, 52.5))\n#define _R Char(float[5](120.5, 68.5, 120.5, 80.5, 76.5))\n#define _S Char(float[5](60.5, 64.5, 56.5, 4.5, 120.5))\n#define _T Char(float[5](124.5, 16.5, 16.5, 16.5, 16.5))\n#define _U Char(float[5](68.5, 68.5, 68.5, 68.5, 56.5))\n#define _V Char(float[5](68.5, 68.5, 68.5, 40.5, 16.5))\n#define _W Char(float[5](68.5, 84.5, 84.5, 84.5, 40.5))\n#define _X Char(float[5](68.5, 40.5, 16.5, 40.5, 68.5))\n#define _Y Char(float[5](68.5, 68.5, 40.5, 16.5, 16.5))\n#define _Z Char(float[5](124.5, 4.5, 56.5, 64.5, 124.5))\n#define _0 Char(float[5](56.5, 76.5, 84.5, 100.5, 56.5))\n#define _1 Char(float[5](112.5, 16.5, 16.5, 16.5, 124.5))\n#define _2 Char(float[5](120.5, 4.5, 60.5, 64.5, 124.5))\n#define _3 Char(float[5](120.5, 4.5, 56.5, 4.5, 120.5))\n#define _4 Char(float[5](68.5, 68.5, 60.5, 4.5, 4.5))\n#define _5 Char(float[5](124.5, 64.5, 124.5, 4.5, 120.5))\n#define _6 Char(float[5](56.5, 64.5, 120.5, 68.5, 56.5))\n#define _7 Char(float[5](124.5, 4.5, 8.5, 16.5, 32.5))\n#define _8 Char(float[5](56.5, 68.5, 56.5, 68.5, 56.5))\n#define _9 Char(float[5](56.5, 68.5, 60.5, 4.5, 4.5))\n#define _hyphen Char(float[5](0.5, 0.5, 124.5, 0.5, 0.5))\n#define _slash Char(float[5](4.5, 8.5, 16.5, 32.5, 64.5))\n#define _stop Char(float[5](0.5, 0.5, 0.5, 0.5, 16.5))\n#define _space Char(float[5](0.5, 0.5, 0.5, 0.5, 0.5))\n\n#define SCROLL_SPEED 15.0\n#define SCROLL_START_DELAY 100.0\n#define MESSAGE_LENGTH 299\nChar SCROLLER_MSG[MESSAGE_LENGTH] = Char[MESSAGE_LENGTH](_T,_H,_E,_space,_O,_L,_D,_space,_S,_U,_N,_D,_O,_W,_N,_space,_C,_R,_E,_W,_space,_W,_O,_U,_L,_D,_space,_L,_I,_K,_E,_space,_T,_O,_space,_I,_N,_V,_I,_T,_E,_space,_Y,_O,_U,_space,_T,_O,_space,_T,_H,_E,_space,_F,_I,_R,_S,_T,_space,_E,_V,_E,_R,_stop,_space,_stop,_space,_stop,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_N,_space,_O,_space,_V,_space,_A,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_2,_3,_R,_D,_space,_T,_O,_space,_2,_5,_T,_H,_space,_J,_U,_N,_E,_space,_2,_0,_1,_7,_space,_A,_T,_space,_B,_U,_D,_L,_E,_I,_G,_H,_space,_S,_A,_L,_T,_E,_R,_T,_O,_N,_space,_T,_O,_W,_N,_space,_H,_A,_L,_L,_space,_hyphen,_space,_E,_N,_G,_L,_A,_N,_D,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_C,_O,_M,_P,_O,_S,_space,_slash,_space,_M,_U,_S,_I,_C,_space,_slash,_space,_B,_O,_O,_Z,_E,_space,_slash,_space,_G,_O,_O,_D,_space,_P,_E,_O,_P,_L,_E,_space,_slash,_space,_G,_R,_E,_A,_T,_space,_A,_T,_M,_O,_S,_P,_H,_E,_R,_E,_space,_slash,_space,_B,_E,_A,_C,_H,_space,_A,_F,_T,_E,_R,_P,_A,_R,_T,_Y,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_space,_T,_H,_E,_space,_S,_U,_N,_space,_G,_O,_E,_S,_space,_D,_O,_W,_N,_space,_B,_U,_T,_space,_W,_E,_space,_K,_E,_E,_P,_space,_P,_A,_R,_T,_Y,_I,_N,_G);\n\n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Distance to nearest surface\nstruct SDResult {\n    float d; // Distance\n    int material; // Nearest material\n    vec2 uv; // Used for scroll position\n    int idx; // used for scroll letter index\n};\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n    \nstruct Box {\n\tvec3 pos;\n\tvec3 size;\n    float radius;\n};\n    \nfloat eps = kEPSILON;\nfloat divergence;\n\nvec3 smoothBlend(in vec3 point, in vec3 about, in float radius) {\n    point -= about;\n    point = mix(-point, point, smoothstep(-radius, radius, point));\n    return point + about;\n}\n    \n// Distance to sphere (signed)\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\n// Distance to sphere surface\nfloat uSphereDist(in Ray ray, in Sphere sphere) {\n    return abs(length(ray.origin - sphere.pos) - sphere.radius);\n}\n\n// Distance to box surface (signed)\nfloat boxDist(in Ray ray, in Box box) {\n    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);\n    vec3 cDist = max(dist, 0.0);\n    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;\n}\n\n// Distance to box surface\nfloat uBoxDist(in Ray ray, in Box box) {\n    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);\n}\n\n// distance to floor\nfloat floorDist(in Ray ray) {\n    float dist = ray.origin.y;\n    return dist;\n}\n\n// traced coords of floor intersection, floor at height y\nvec2 floorPos(in Ray ray, in float y) {\n    float dist = (ray.origin.y - y) / ray.dir.y;\n \treturn ray.origin.xz + ray.dir.xz * dist; \n}\n\n/*\n---- Random/hash stuff ----\n*/\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand(in vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n/*\n---- INTERSECTION OPS ----\n*/\n\n// Union of two signed distances\nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\n// Intersection of two signed distances\nfloat intersectOp(float d0, float d1) {\n    return max(d0, d1);\n}\n\n// Difference of two signed distances\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\n/*\n---- Scene rendering ----\n*/\n\nfloat seaHeight(in Ray ray, in float t) { \n    float result = 0.0;\n    vec2 s = vec2(0.10, 0.11);\n    float h = 2.0;\n    for (int i=0; i<2; i++) {\n        result += sin(ray.origin.x * s.x + ray.origin.z * s.y + t * 2.0) * h;\n        s *= vec2(0.75, 1.25);\n        result += sin(ray.origin.x * s.x + ray.origin.z * s.y + t * 2.0) * h;\n        s *= vec2(2.6, 1.4);\n        h *= 0.5;\n    }\n    return result;\n}\nfloat seaDist(in Ray ray, in float t) {\n    // the sea\n    float seaDist;\n    if (ray.dir.y < 0.0 || ray.origin.y < 3.0) {\n        seaDist = ray.origin.y + seaHeight(ray, t);\n    } else {\n        seaDist = (ray.origin.y - 3.0) / -ray.dir.y;\n        float seaSkipper = step(0.01, seaDist);\n        seaDist = seaDist * seaSkipper + 10000.0 * (1. - seaSkipper);\n    }\n    return seaDist;\n}\n\nfloat scrollDist(in Ray ray, inout vec2 uv, inout int idx, in float offset) {\n    // The scroller\n    Ray tr = ray;\n    R(tr.origin.xz, -0.5);\n    tr.origin.x = -tr.origin.x;\n    tr.origin.y += offset;\n    \n    /*\n    float r = (sin(ray.origin.x + iTime)) * 0.2;\n    tr.origin += vec3(\n        sin(tr.origin.y*.156145 + iTime*1.561)+sin(tr.origin.y*.11568 + iTime*1.754), \n        sin(tr.origin.x*.18491 + iTime*1.875)+sin(tr.origin.z*.17854 + iTime*1.7432), \n        sin(tr.origin.x*.1475 + iTime*1.1561)+sin(tr.origin.x*.1156 + iTime*1.456)\n    )*4.;\n*/\n    tr.origin.x += iTime * SCROLL_SPEED;\n    // The scroll box, assume character size of 10x10\n    Box scrollBox = Box(\n        vec3(\n            (MESSAGE_LENGTH * 10) / 2 + int(SCROLL_START_DELAY),\n            5.,\n            40),\n        vec3(MESSAGE_LENGTH * 10, 9.75, 0.1), \n        0.0\n        );\n    float scrollD = boxDist(tr, scrollBox);\n    // tr.origin.x *= 0.2;\n    uv = vec2(mod(tr.origin.x, 10.), (tr.origin.y - 0.0)) / 10.;\n    idx = int(mod((tr.origin.x - SCROLL_START_DELAY) / 10., float(MESSAGE_LENGTH)));\n    return scrollD;\n}\n\n// Get the distance to the scene (returns a struct containing distance and nearest material)\nSDResult sceneDist(in Ray ray) {\n    SDResult result;\n    \n    float t = mod(iTime, kPI);\n    \n    float seaDist = seaDist(ray, t);\n\n    vec2 uv; int idx;\n    float scrollDist = scrollDist(ray, uv, idx, seaHeight(ray, t));\n    result.uv = uv; result.idx = idx;\n    \n    // the thing\n    float thingHeight = clamp(iTime - 16.0, 0.0, 5.0) * 100.0;\n    vec3 thingPos = vec3(0, thingHeight - 200.0, 1000);    \n    \n    ray.origin -= thingPos;\n    ray.origin = abs(ray.origin);\n    \n    R(ray.origin.xy, t);\n    R(ray.origin.xz, t);\n    \n    float distToBall = differenceOp(\n        sphereDist(ray, Sphere(vec3(0), 160.0)),\n        sphereDist(ray, Sphere(vec3(0), 150.0))\n        );\n    float distToBox1 = boxDist(ray, Box(vec3(0), vec3(400,400,20), 10.0));\n    float distToBox2 = boxDist(ray, Box(vec3(0), vec3(400,20,400), 10.0));\n    \n    float thingDist = unionOp(distToBox1, distToBox2);\n    thingDist = intersectOp(thingDist, distToBall);\n    \n    result.d = unionOp(\n        seaDist,\n        thingDist\n        );\n    result.d = unionOp(result.d, scrollDist);\n    //result.d = unionOp(result.d, bDist);\n    \n    if (result.d == seaDist) {\n        result.material = kSEAMATERIAL;\n    } else if (result.d == scrollDist) {\n        result.material = kSCROLLMATERIAL;\n    } else {\n    \tresult.material = kGLOWMATERIAL;\n    }\n    return result;\n}\n\n// Gets the normal\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = sceneDist(ray).d;\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - \n        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -\n        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d\n        ));\n}\n\n// Moves the ray to the surface. Helps avoid artefacts due to ray intersection imprecision.\nvoid clampToSurface(in Ray ray, in float d, inout vec3 n) {\n \tray.origin += n * d;\n \td = sceneDist(ray).d;\n \tn = normal(ray);\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in Ray ray, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(ray.dir, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\n/*\n---- LIGHTING ----\n*/\n\n// Pretty background colour of some sort...\nvec3 backgroundColour (in Ray ray, in float divergence) {\n    \n    // Declare a horizon and extremity (either zenith or nadir)\n    vec3 base, extremity, texture;\n    float x = pow(ray.dir.y, 0.4);\n    base = mix(kHORIZONCOLOUR, kZENITHCOLOUR, x);\n    \n    return base;\n}\n\n// Technically broken, but seems to make soft shadows? *shrug*\nfloat occlusion(in Ray ray, in vec3 n) {\n    float o = 0.0;\n    ray.dir = n;\n    float x = 0.1;\n    for (int i=0; i<5; i++) {\n    \tray.origin += x;\n        float d = sceneDist(ray).d;\n        o += max(x - d, 0.0);\n        \n        x *= 2.0;\n    }\n \treturn 1.0 - o * 0.5;;\n}\n\n/*\n---- RAY MARCHING ----\n*/\n\n// The main marching loop\nfloat drawChar(Char c, vec2 uv);\nvoid marchRay(inout Ray ray, inout vec3 colour) {\n    bool inside = false; // are we inside or outside the glass object\n    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours\n\n    vec3 startpoint = ray.origin;\n    \n#ifdef DEBUG   \nvec3 debugColour = vec3(1, 0, 0);\n#endif\n    \n    SDResult result;\n    vec3 n;\n    vec3 glassStartPos;\n    \n    float glow = 0.0;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        result = sceneDist(ray);\n        \n        float syncSpeed = 60. / SYNCVAL;\n        float sync = (pow(mod(-iTime * syncSpeed, 1.), 4.) * .5 +.01);\n        glow += result.material == kGLOWMATERIAL ? \n            pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * sync\n            : 0.0;\n        \n        // Step half that distance along ray (helps reduce artefacts)\n        float stepDistance = result.d;\n        ray.origin += ray.dir * stepDistance * 0.5;\n        //if (length(ray.origin) > 40.0) { break; }\n        \n        if (stepDistance < eps) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tn = normal(ray);\n            //clampToSurface(ray, stepDistance, n);\n#ifdef DEBUG\ndebugColour = n;\nbreak;\n#endif\n            \n            if (result.material == kSCROLLMATERIAL) {\n                vec2 uv = mod(result.uv, 1.0);\n                int c = result.idx;\n                float x = drawChar(SCROLLER_MSG[c], result.uv);\n                if (x < 0.5) { \n                    // Step forward by box thickness (0.1) plus double eps\n                    ray.origin += ray.dir * (0.1 + eps * 2.0);\n                    continue; \n                }\n                float o = result.uv.x * 5.0;\n                vec3 t = vec3(sin(o), sin(o + kPI * 0.666), sin(o + kPI * 1.333)) * 0.5 + 0.5;\n             \tcolour = mix(colour, t, impact) * x;\n                break;\n            }\n            \n            if (result.material == kGLOWMATERIAL) {\n             \tcolour = mix(colour, kGLOWCOLOUR, impact);\n                impact *= 0.;\n                break;\n            }\n            \n            // check what material it is...\n            \n            if (result.material == kSEAMATERIAL) {\n                \n                // it's a mirror, reflect the ray\n                ray.dir = reflect(ray.dir, n);\n                    \n                // Step 2x epsilon into object along normal to ensure we're beyond the surface\n                // (prevents multiple intersections with same surface)\n                ray.origin += n * eps * 4.0;\n                \n                // Mix in the mirror colour\n                impact *= kSEACOLOUR;\n                \n            }\n        }\n        \n        // increase epsilon\n        eps += divergence * stepDistance;\n    }\n    \n    // So far we've traced the ray and accumulated reflections, now we need to add the background.\n    colour.rgb += backgroundColour(ray, 0.0) * impact + glow * kGLOWCOLOUR;\n}\n\n// Sets up a camera at a position, pointing at a target.\n// uv = fragment position (-1..1) and fov is >0 (<1 is telephoto, 1 is standard, 2 is fisheye-like)\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n\t\t// cam setup\n    // Create camera at pos\n\tCamera cam;\n    cam.pos = pos;\n    \n    // A ray too\n    Ray ray;\n    ray.origin = pos;\n    \n    // FOV is a simple affair...\n    uv *= fov;\n    \n    // Now we determine hte ray direction\n\tvec3 cw = normalize (target - pos );\n\tvec3 cp = vec3 (0.0, 1.0, 0.0);\n\tvec3 cu = normalize ( cross(cw,cp) );\n\tvec3 cv = normalize ( cross (cu,cw) );\n    \n\tray.dir = normalize ( uv.x*cu + uv.y*cv + 0.5 *cw);\n    \n    // Add the ray to the camera and our work here is done.\n\tcam.ray = ray;\n    \n    // Ray divergence\n    divergence = fov / iResolution.x;\n    \n\treturn cam;\n}\n\nfloat drawChar(Char c, vec2 uv) {\n    float val = 0.0;\n    \n\tivec2 p = ivec2((1.-uv) * vec2(9,5));\n\n    val = c.bits[p.y];\n\n    float bit = floor(val * exp2(-float(p.x)));\n\n    return bit != floor(bit / 2.0) * 2.0 ? 1.0 : 0.0;\n}\n\nfloat drawLogo(vec2 fragCoord, vec2 iResolution)\n{\n    float val = 0.0;\n    float res = max(iResolution.x, iResolution.y) * 2.0;\n    vec2  pos = vec2(floor((fragCoord.xy / res) * 128.0));\n\n    float ypos = 12.0;\n    float xpos = 64.0;\n\n    val = pos.y == ypos + 0.0 ? 26837048.5 : val;\n    val = pos.y == ypos + 1.0 ? 21250088.5 : val;\n    val = pos.y == ypos + 2.0 ? 22922158.5 : val;\n    val = pos.y == ypos + 3.0 ? 22085792.5 : val;\n    val = pos.y == ypos + 4.0 ? 26001632.5 : val;\n    \n    val = pos.x >xpos ? 0.0 : val;\n\n    float bit = floor(val * exp2(pos.x - xpos));\n\n    return bit != floor(bit / 2.0) * 2.0 ? 1.0 : 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction \n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Make a camera with ALL NEW AND IMPROVED! camera code :)\n    float camTime = iTime / 4.0;\n    vec3 camPos = vec3(0,16,-10);\n    vec3 camTarget = vec3(0,16,0);\n    //camTarget.y -= 3.0;\n    Camera cam = setupCam(camPos, camTarget, 0.500, uv);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    // Create an empty colour\n    vec3 col = vec3(0);\n    \n    // Trace that ray!\n    marchRay(cam.ray, col);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5127, 5127, 5192, 5192, 5308], [5314, 5345, 5393, 5393, 5455], [5457, 5487, 5536, 5536, 5603], [5605, 5641, 5680, 5680, 5861], [5863, 5890, 5930, 5930, 6025], [6027, 6048, 6077, 6077, 6127], [6129, 6187, 6226, 6226, 6322], [6359, 6470, 6494, 6494, 6562], [6598, 6631, 6666, 6666, 6692], [6694, 6734, 6773, 6773, 6799], [6801, 6839, 6879, 6879, 6906], [6941, 6941, 6982, 6982, 7348], [7349, 7349, 7388, 7403, 7735], [7737, 7737, 7814, 7834, 8837], [8839, 8932, 8964, 8964, 10273], [10275, 10294, 10319, 10319, 10774], [10776, 10868, 10927, 10927, 10995], [10997, 11041, 11099, 11099, 11202], [11230, 11274, 11331, 11400, 11544], [11546, 11609, 11649, 11649, 11882], [11973, 11973, 12022, 12022, 14997], [14999, 15156, 15228, 15271, 15834], [15836, 15836, 15869, 15869, 16064], [16066, 16066, 16116, 16116, 16698], [16701, 16701, 16758, 16900, 17515]], "test": "error"}
{"id": "ldBcWd", "name": "Ring, ring, ring - xor", "author": "DonKarlssonSan", "description": "xor\n\nhttp://adrianboeing.blogspot.se/2011/01/xor-demoeffect-in-webgl.html", "tags": ["xor"], "likes": 1, "viewed": 82, "published": "Public", "date": "1494341650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CS(a) vec2(cos(a), sin(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float phaseDiff = 2.22;\n    \n\tvec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x * 2.0;\n    vec2 uv2 = vec2(uv);\n\n    float t = iTime;\n    vec2 xy = CS(t/2.2)/3.0 + CS(t*3.0)/5.0;\n    uv.xy += xy;\n\tfloat radius = length(uv);\n\tbool toggle = mod(radius, 0.1) > 0.05;\n    \n    float t2 = iTime + phaseDiff;\n    vec2 xy2 = CS(t2/1.7)/1.533 + CS(t2*2.34)/4.0;\n    uv2.xy += xy2;\n    float radius2 = length(uv2);\n    bool toggle2 = mod(radius2, 0.1) > 0.05;\n\n    bool xor = toggle != toggle2;\n    \n\tfragColor = vec4(xor, 0.0, xor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 93, 643]], "test": "ok"}
{"id": "ldByWd", "name": "Vegetal Flux", "author": "leon", "description": "Vegetal shapes", "tags": ["raymarching"], "likes": 45, "viewed": 1435, "published": "Public", "date": "1494342992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Vegetal Flux\n// Leon 09-05-2017\n// Refactored in 07-01-2018\n// using code from IQ, Mercury, Koltes\n\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime*.2\n#define repeat(v,r) (mod(v,r)-r/2.)\n\nconst vec4 red = vec4(0.9,0.1,0.2,1);\nconst vec4 green = vec4(0.584, 0.901, 0.270, 1);\nconst vec4 green2 = vec4(0.254, 0.301, 0.211, 1);\nconst vec4 blue = vec4(0.631, 0.901, 0.901, 1);\nconst vec4 orange = vec4(0.901, 0.835, 0.270, 1);\n\nstruct Shape { float dist; vec4 color; };\n\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1,vec2(324.654,156.546)))*46556.24); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat disk (vec3 p, float r, float h) { return max(length(p.xy)-r, abs(p.z)-h); }\nfloat smoo (float a, float b, float r) { return clamp(.5+.5*(b-a)/r,0.,1.); }\nfloat smin (float a, float b, float r) { float h = smoo(a,b,r); return mix(b,a,h)-r*h*(1.-h); }\nfloat amod (inout vec2 p, float c) {\n\tfloat ca = (2.*3.14159)/c;\n\tfloat a = atan(p.y,p.x)+ca*.5;\n\tfloat index = floor(a/ca);\n\ta = mod(a,ca)-ca*.5;\n\tp = vec2(cos(a),sin(a))*length(p);\n\treturn index;\n}\n\nShape map (vec3 pos) {\n\n\tShape shape;\n\tshape.dist = 1000.;\n\tshape.color = vec4(1);\n\n\tfloat twist = .5;\n\tfloat count = 8.;\n\tfloat interval = 2.;\n\tfloat outter = 2.;\n\n\tvec3 p = pos;\n\tp.xz *= rot(sin(pos.y*twist + t));\n\tfloat index = amod(p.xz, count);\n\tfloat sens = mix(-1.,1.,mod(index,2.));\n\tp.x -= outter;\n\n\tfloat stem = cyl(p.xz, 0.04+.02*sin(p.y*4.-iTime*sens));\n\n\tfloat leaf;\n\tp.y = repeat(p.y+index+t*sens, interval);\n\tp.xy *= rot(.25*sens);\n\tp.yz *= rot(.15*sens);\n\tp.x -= .8;\n\tp.y -= sin(abs(p.z)*3.)*.1;\n\tp.y -= sin(abs(p.x-.7)*3.)*.1;\n\tleaf = disk(p.xzy,0.7, 0.01);\n\n\tfloat innerStem;\n\tp = pos;\n\tp.xz *= rot(pos.y+sin(pos.y+t*10.)-t*4.);\n\tindex = amod(p.xz, 3.);\n\tp.x -= 0.3+.2*(.5+.5*sin(pos.y+t));\n\tinnerStem = cyl(p.xz, 0.05);\n\n\tfloat seed;\n\tp = pos;\n\tinterval = 0.6;\n\tp.y = repeat(p.y+t*4., interval);\n\tseed = sphere(p, 0.3*(.5+.5*sin(pos.y+.5)));\n\n\tfloat water;\n\tp = pos;\n\tp.xz *= rot(pos.y*.5+t);\n\tp.x -= 1.2;\n\tp.xz *= rot(pos.y*.5-t*9.);\n\tindex = amod(p.xz, 8.);\n\tp.x -= 0.1+(.5*(.5+.5*sin(pos.y+3.*t)));\n\twater = cyl(p.xz, 0.04);\n\n\tfloat sceneLeaves = smin(leaf, stem, .3);\n\tfloat scene = min(seed, innerStem);\n\n\tshape.color = mix(red, orange, smoo(innerStem, seed, .1));\n\tshape.color = mix(shape.color, green2, smoo(stem, scene, .3));\n\tscene = min(stem, scene);\n\tshape.color = mix(shape.color, green, smoo(sceneLeaves, scene, .1));\n\tshape.color = mix(shape.color, blue, step(water, scene));\n\n\tshape.dist = min(water, min(sceneLeaves, scene));\n\treturn shape;\n}\n\nvec4 raymarch (vec2 coord)\n{\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n  \tfloat dither = rng(uv+fract(iTime));\n\tvec3 eye = vec3(0,0,-8);\n\tvec3 ray = normalize(vec3(uv,1.));\n\tvec3 pos = eye;\n\tvec4 color = vec4(0.);\n\tfor (float i = 0.; i <= 1.; i += 1./30.) {\n\t\tShape shape = map(pos);\n\t\tif (shape.dist < 0.01) {\n\t\t\tcolor = shape.color * (1.-i);\n\t\t\tbreak;\n\t\t}\n\t\tshape.dist *= .9 + .1 * dither;\n\t\tpos += ray * shape.dist;\n\t}\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = raymarch(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldByWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[475, 475, 498, 498, 564], [565, 565, 585, 585, 635], [636, 636, 668, 668, 690], [691, 691, 720, 720, 742], [743, 743, 782, 782, 824], [825, 825, 865, 865, 902], [903, 903, 943, 943, 998], [999, 999, 1035, 1035, 1198], [1200, 1200, 1222, 1222, 2677], [2679, 2679, 2707, 2707, 3133], [3135, 3135, 3192, 3192, 3228]], "test": "ok"}
{"id": "ldfBRN", "name": "Circle Design", "author": "lherm", "description": "An idea I decided to sketch out. ", "tags": ["pattern"], "likes": 1, "viewed": 88, "published": "Public", "date": "1495038678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 u = (g+g-iResolution.xy)/iResolution.y;\n    u = fract(u) - .5;\n    float r = .8, d = step(length(u),r);\n    for (int i = 0; i < 9; i++)\n    {\n        r *= .5 + .1 * sin(float(i) + iTime);\n        if (mod(float(i), 2.) == 0.)\n        {\n        \td -= step(length(u+vec2(0, r)), r);\n        \td -= step(length(u+vec2(r, 0)), r);\n        \td -= step(length(u-vec2(0, r)), r);\n        \td -= step(length(u-vec2(r, 0)), r);\n        }\n        else\n        {\n            d += step(length(u+vec2(0, r)), r);\n        \td += step(length(u+vec2(r, 0)), r);\n        \td += step(length(u-vec2(0, r)), r);\n        \td += step(length(u-vec2(r, 0)), r);\n        }\n        \n    }\n\tf = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldfBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 719]], "test": "ok"}
{"id": "ldffWN", "name": "21/100", "author": "yahe", "description": "Just play TLC123's flower model and learn how it works. \nOriginal one: https://www.shadertoy.com/view/MltSRf", "tags": ["flower"], "likes": 12, "viewed": 603, "published": "Public API", "date": "1496189965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Play with TLC123's flower model\n// https://www.shadertoy.com/view/MltSRf\n\nfloat flower(vec3 p,  float r)\n {     \n     vec3 n=normalize(p);\n     \n     float q=length(p);\n     \n     float rho=atan(length(vec2(n.x,n.z)),n.y)*15.0+q*10.01-iTime*4.;//vertical part of  cartesian to polar with some q warp\n\n     float theta=atan(n.x,n.z)*5.0+p.y*3.0+rho*2.0-iTime ;//horizontal part plus some warp by z(bend up) and by rho(twist)\n \n     return length(p) -(r+sin(theta)*0.5*(1.5-abs(dot(n,vec3(0,1,0)) )) //the 1-abs(dot()) is limiting the warp effect at poles\n                        +sin(rho)*0.3  *(1.5-abs(dot(n,vec3(0,1,0)) )) );// 1.3-abs(dot()means putting some back in \n }\n\nvec2 map( in vec3 pos )\n{\n      \n    return vec2( flower(pos, 0.750), 5.1 + (sin(iTime)/2.)) ;\n    \n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.01;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<400; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*0.05;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<15; i++ )\n    {\n        float hr = 0.05 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.85, 0.8, .9) +rd.y*0.9;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.60 + 0.2*sin( vec3(2.3-pos.y/4.0, 2.15-pos.y/4.0, -1.30)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor ) ;\n\t\tvec3  lig =  normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb =0.0;// clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif  = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac =0.0;// clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = 0.750;//pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = 0.0;//pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.7,0.4,.3), 1.0-exp( -0.01*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime*3.0;\n\n\t// camera\t\n    vec3 ro = vec3(0.0,4.0,4.0);\n  \n \tvec3 ta = vec3( -0.0, 0.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,3.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\t//col = pow( col, vec3(0.7, 1., .9) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldffWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 110, 110, 676], [678, 678, 703, 703, 779], [781, 781, 821, 821, 1416], [1418, 1418, 1450, 1450, 1671], [1673, 1673, 1715, 1715, 2015], [2017, 2017, 2056, 2056, 3567], [3569, 3569, 3621, 3621, 3798], [3800, 3800, 3857, 3857, 4392]], "test": "ok"}
{"id": "ldjcD3", "name": "Laika", "author": "lennyjpg", "description": " ", "tags": ["2d"], "likes": 0, "viewed": 392, "published": "Public API", "date": "1494197827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n\tvec2 v = U.xy / iResolution.y;\n    float t = iTime*.132;\n    float k = (cos(-t * 0.2) + 0.3) * .8;\n    vec3 f = vec3(0.1, 0.3, 0.2)*3.1;\n    vec3 s = vec3(1.3, 0.14, 2.12);\n    vec3 a = vec3(0.223, 0.21, 0.14);\n    vec3 l = vec3(2.12, 4.6, 7.5) * .2;\n    vec3 w = vec3(sin(v.x * l - t * s) * a + k);\n    O = smoothstep(w, w + f, v.yyy).xyzz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 386]], "test": "ok"}
{"id": "ldjcDG", "name": "Daily 2017-05-01", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 3, "viewed": 356, "published": "Public API", "date": "1493671808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 ro,rd,mp;\nfloat md;\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nvoid map(vec3 p) {\n    mat2 r=rz2(iTime);\n    p.xy*=r;p.yz*=r;\n    md=length(max(abs(p)-.5,0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    ro=vec3(uv,1.);\n    rd=normalize(vec3(uv,-1.));\n    mp=ro;\n    for (int i=0;i<50;++i){\n        map(mp);\n        if (md<.001) break;\n        mp+=rd*md;\n    }\n\tfragColor = vec4(length(mp-ro)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjcDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 91], [93, 93, 111, 111, 191], [193, 193, 250, 250, 534]], "test": "ok"}
{"id": "ldjcWy", "name": "Light Orb", "author": "Hadyn", "description": "A little test of an idea I had whilst working on my previous shader - and another messy one due to time constraints - but I'm quite happy with the results and what I've learned in the process!", "tags": ["2d", "abstract", "stylised"], "likes": 29, "viewed": 489, "published": "Public", "date": "1493735828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n * Created by Hadyn Lander \n * 3D noise from Nikita Miropolskiy, nikat/2013 https://www.shadertoy.com/view/XsX3zB\n * That basically includes all of this neat looking code up top:\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n/*\n* The Nintendo Super Mess of code below is all me. I am sorryish.\n*/\n\n// Comment out the enxt line to limit the length of \"rays\"\n#define UNLIMITED\t\t\t\n\n#define CENTERSCALE 0.2\n#define CENTERCONNECTEDNESS 0.35\n#define RADIUS 0.65\t\t\t// Has a bigger impact if UNLIMITED is disabled\n#define FLAMEBOOST 0.15\t\t// Adds the flame shape mask over the top of the multiplied noise to maintain more of original shape.\n#define EDGE 0.65\t\t\t// Edge cutoff \n#define FALLOFFPOW 4.0\t\t// Only used is UNLIMITED is disabled\n#define NOISEBIGNESS 0.25 \n#define NIGHTSPEEDBONUS 1.25 \t\t\n#define PI 3.14159265359\n\n\nfloat getNoiseValue(vec2 p, float time)\n{\n    vec3 p3 = vec3(p.x, p.y, 0.0) + vec3(0.0, 0.0, time*0.025);\n    float noise = simplex3d(p3*32.0);// simplex3d_fractal(p3*8.0+8.0);\n\treturn 0.5 + 0.5*noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 28.22+NIGHTSPEEDBONUS*iTime;\n    float bignessScale = 1.0/NOISEBIGNESS;\n\tvec2 p = fragCoord.xy / iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 positionFromCenter = p-vec2(0.5*aspect, 0.5);\n    \n    p = vec2(0.5*aspect, 0.5)+normalize(positionFromCenter)*min(length(positionFromCenter)+CENTERCONNECTEDNESS*CENTERSCALE*RADIUS, CENTERSCALE*RADIUS);    \n    \t\n    float noise = getNoiseValue(bignessScale*0.25*p, time);\n    \n    float distanceFromCenter = clamp(1.0-length(positionFromCenter)/RADIUS, 0.0, 1.0);\n    \n    float scaledDistance = distanceFromCenter * noise;\n    \n    \n    float falloffMask = 1.0; \n    \n    #ifndef UNLIMITED\n        falloffMask =  2.0*scaledDistance-1.0;\n        falloffMask = clamp(1.0-pow(abs(falloffMask), FALLOFFPOW), 0.0, 1.0);\n    #endif\n    \n    float thinnerMask;\n    \n    thinnerMask = 1.0-clamp(abs(distanceFromCenter-(1.0-CENTERSCALE))/CENTERSCALE, 0.0, 1.0);\n    thinnerMask = pow(thinnerMask, 16.0);    \n    thinnerMask = clamp(0.9*thinnerMask, 0.0, 1.0);\n    \n    float finalValue;\n    finalValue = falloffMask;\n    \n    float innerBall = clamp(abs(distanceFromCenter-(1.0-CENTERSCALE))/CENTERSCALE, 0.0, 1.0);\n    innerBall = smoothstep(0.5, 0.85, innerBall);\n    innerBall += noise;\n    \n    finalValue = mix( (noise*falloffMask+thinnerMask)*thinnerMask + innerBall, noise*falloffMask+thinnerMask, step(distanceFromCenter, 1.0-CENTERSCALE));\n    \n    finalValue = smoothstep(EDGE,EDGE+0.1, finalValue);\n    \n    \n    vec3 colorNoise;\n    colorNoise.x\t= getNoiseValue(bignessScale*0.25*p, 10.0+time);\n    colorNoise.y \t= getNoiseValue(bignessScale*0.25*p, 00.0+time);\n    colorNoise.z\t= getNoiseValue(bignessScale*0.25*p, 30.0+time);\n    \n    colorNoise.x = smoothstep(EDGE,EDGE+0.1, colorNoise.x);\n    colorNoise.y = smoothstep(EDGE,EDGE+0.1, colorNoise.y);\n    colorNoise.z = smoothstep(EDGE,EDGE+0.1, colorNoise.z);\n    \n    \n    vec3 finalColor;\n    //finalColor = vec3(colorNoise.x, colorNoise.y, colorNoise.x+colorNoise.y); \n    finalColor = mix(vec3(1.0, colorNoise.x, 0.05), vec3(colorNoise.x, 1.0, 1.0), colorNoise.y);\n    finalColor += vec3(1.0) * (pow(clamp(distanceFromCenter+CENTERSCALE, 0.0, 1.0), 8.0));\n    \n    //finalColor = clamp(finalColor, vec3(0.0), vec3(1.0));\n    \n    finalColor *= finalValue;\n    \n    vec3 bgColor = mix(vec3(0.07,0.0,0.15), vec3(0.35,0.15,0.5), distanceFromCenter*0.5);\n    bgColor += vec3(0.2,.8,0.4)* pow(distanceFromCenter, 4.0);\n    finalColor += bgColor;\n    \n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 261, 283, 283, 456], [563, 586, 611, 864, 1781], [2051, 2118, 2151, 2151, 2298], [2893, 2893, 2934, 2934, 3096], [3098, 3098, 3155, 3155, 5686]], "test": "ok"}
{"id": "ldjyzc", "name": "Mountain Path", "author": "Shane", "description": "A path running through some dry rocky terrain. Rendered in a pseudo low-poly style.", "tags": ["raymarching", "terrain", "bump", "cellular", "lowpoly", "path", "stairs"], "likes": 69, "viewed": 4294, "published": "Public API", "date": "1493648510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tMountain Path\n\t-------------\n\n    A path running through some dry rocky terrain. Rendered in a pseudo low-poly style.\n\n\tThis was orginally supposed to be a simple curvy path through a field, but then I wondered what\n\tstepping the path would look like, then I wanted to see what it'd look like going through\n\tsomething... so now, I'm not really sure what it is, or why anyone in their right mind would \n\tbuild a ridiculously long path in the middle of a mountainous pass that leads to nowhere. :)\n\n\tI'm fond of the old demo scenes and those pictures on 80s sci-fi novels, so I went for a psuedo \n\tlow-poly look with a little realism thrown into the mix. The geometry was surprisingly simple to \n    produce - I thought the stairs might present some problems, but it just involved stepping the \n    path heights and dealing with the overlap.\n\n\tThe low poly terrain is just a sinusoidal-based layer with some relatively cheap cellular noise \n\tadded to it. Anyway, this is just a practice run for a more interesting variation I have in mind.\n\t\n\n\n*/\n\n#define FAR 80. // Maximum ray distance. Analogous to the far plane.\n\n\n// Scene object ID. Either the path (0) or the surroundings (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(cos(dot(p, vec3(157, 113, 7)))*45758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p);\n    //return max(max(p.x, p.y), p.z);  \n\n    \n    // Cubic.\n    p = abs(fract(p) - .5); \n    return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    //p = abs(fract(p) - .5); \n    //p = max(p*.866025 + p.yzx*.5, p.yzx);\n    //return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return 1. - min(d.x, d.y)*2.; // Scale between zero and one... roughly.\n    \n    // For anyone wanting to experiment with this, the following gives better variance:\n    //const float scale = 1.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    //return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\n/*\n// Second order version.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.; // Normalize.\n    \n}\n*/\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Path 1.\n    //return vec2(sin(z*.05)*cos(z*.1)*2.5, sin(z*.06)*2.); // Path 2.\n    return vec2(sin(z*.15)*2.5, cos(z*.1)); // Path 3.\n}\n\n// Stair path.\nvec2 sPathF(in vec2 p){ \n\n    //return vec2(0); // Path 1.\n    //return sin(p*.06)*2.; // Path 2.\n    return cos(p*.1); // Path 3.\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    return cellTile(p/8.);//*.8 + dot(tri(p*0.384*2. + tri(p.yzx*0.192*2.)), vec3(0.666))*.2;\n     \n    // More interesting formations, and still quick, but not fast enough for this example.\n    //return cellTile(p/10.)*.75 + cellTile(p/10.*3.)*.25; \n \n    // Very cheap triangle noise. Looks OK, all things considering.\n    //p /= 2.5;\n\t//float n = dot(tri(p*0.5 + tri(p.yzx*0.25)), vec3(0.666));\n    //return n*.75 + dot(tri(p*0.75 + tri(p.yzx*0.375)), vec3(0.666))*.25;\n\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Drawing repeat objects right up again one another causes inaccuracies, so you get \n// around that by rending two sets of repeat objects in each dimension. Two for one\n// axis, four for two axes, and eight (I think) for three.\n//\n// Basically, the aforementioned is just a way to say that to draw stairs along the \n// Z-axis, you need to draw two sets of repeat boxes. The boxes are aligned with the \n// path position. In the case of the step portion, the path's height has to be \n// snapped to a quantized number. You do that via flooring, etc.\nfloat stairs(in vec3 p, vec2 pth){\n   \n    const float sc = 2.; // Stair scaling factor. It affects the length.\n    // The quantized stair heights. Basically, making the surface flat. Two heights are \n    // being passed in to account for the two boxes we have to render to account for the\n    // overlap.\n    vec2 iPthY = sPathF(floor(vec2(p.z/sc, p.z/sc + .5))*sc);\n    // Snapping the stair height to factors of four. Makes the step layers equal height.\n    iPthY = floor(iPthY*4.)/4. - 2.5;   \n\n    // Railings. Draw one railing using the path's X and Y positions, then use the\n    // \"abs\" repeat trick to render the other one at the same time.\n    float sY = abs(p.y - pth.y + 2.); // Railing height.\n    p.x = abs(p.x - pth.x); // Railing X-position.\n\n    // Railing, with a bit carved out.\n    float rails = max(abs(p.x - 1.75 + .35/2.) - .35/2., sY - .85);\n    float rails2 = max(abs(p.x - 1.75 + .35/2. + .3) - .35/2., sY - .65);\n    rails = max(rails, -rails2);\n    \n    // Stair render.\n    p.z /= sc;\n    \n    vec2 iy = p.yy - iPthY; // Quantized stair heights.\n    // Render a couple of boxes, then take the minimum.\n    vec2 qz  = abs(fract(vec2(p.z, p.z + .5)) - .5); \n    vec2 n = max(max(p.xx - 1.7, qz - .27), abs(iy) - .75);\n\n    // Return the path object - the minimum of the stairs and the railings.\n    return min(rails, min(n.x, n.y));\n     \n    \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat map(vec3 p){\n    \n    vec2 pth = path(p.z);\n    \n    float sf = surfFunc(p); // Surface perturbation.\n\n    // The terrain base layer.\n    float ter = p.y - 3. + dot(sin(p*3.14159/18. - cos(p.yzx*3.14159/18.)), vec3(3)); // 6. smoothing factor.\n    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.\n\n    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.\n\n    p.xy -= pth; // Wrap the tunnel around the path.\n\n    float n = 1.5 - length(p.xy*vec2(.5, 1)); // The tunnel to bore through the rock.\n    n = smax(n + (.5 - sf)*1.5, ter + (.5 - sf)*3., 6.); // Smoothly boring the tunnel through the terrain.\n    n = smax(n, -max(abs(p.x) - 1.75, abs(p.y + 1.5) - 1.5), .5); // Clearing away the rock around the stairs.\n \n    // Object ID.\n    objID = step(n, st); // Either the physical path or the surrounds.\n    \n    return min(n, st)*.866; // Return the minimum hit point.\n \n}\n \n\n// Pavers. Standard grid stuff.\nfloat paver(vec2 p, float mortW){\n\t\n    \n    vec2 q = abs(fract(p + vec2(.5, .5)) - .5);\n    \n    float d = max(q.x, q.y) - .5;\n    \n    //float c = smoothstep(0., mortW, min(q.x, q.y));\n    float c = smoothstep(0., .02, abs(d) - mortW/3.);\n    //if (q.x<.05 || q.y<.05) c *= .5;\n\n    return c;\n\n    \n}\n\n\n// Surface bump function. Tiles are fiddly, but simple enough. Basically, the surface\n// normal is used to determine the 2D plane we wish to tile, then it's passed to the\n// tile function.\nfloat tiles( in vec3 p, in vec3 n,  float mortW){\n    \n    p.xy -= path(p.z);\n\n    n = abs(n);\n    \n    float c = 1.;\n    \n    if (n.x>0.5) {\n        \n        if(p.y<-1.35) return 1.;\n        p.xy = p.yz;\n\n    }\n    else if (n.y>0.5) {\n         \n       if(p.y>-1.35) p.x += sign(p.x)*.25;\n        \n        p.xy = p.xz;\n        \n    }\n    \n    return paver(p.xz, mortW);\n    \n}\n\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n\n\n    float c;\n    if(svObjID>.5 ) c = 1. - surfFunc(p*3.); // cellTile(p/8.*3.);\n    else c = tiles(p.xyz, n, .1);\n    \n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(8./iResolution.y, 0); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x*2.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<160; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 48; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .07, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .15, 1.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n\n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return smoothstep(.15, .5, tx); \n    \n}\n*/\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 f = fract(p); p -= f; f *= f*(3. - f*2.);  \n    \n    return dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(p, vec2(41, 289)))*43758.5453))*\n                vec2(1. - f.y, f.y), vec2(1. - f.x, f.x) );\n\n}\n\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec2 p){\n    \n    // Four layers of 3D noise.\n    return 0.5333*n2D( p ) + 0.2667*n2D( p*2.02 ) + 0.1333*n2D( p*4.03 ) + 0.0667*n2D( p*8.03 );\n\n}\n\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.0); // Sun strength.\n\tfloat horiz = pow(1.0-max(rd.y, 0.0), 3.)*.35; // Horizon strength.\n\t\n    //vec3 col = mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25*.5;\n    \n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon.\n\tcol = mix(col, vec3(1, .9, .7), horiz);\n    \n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.25*vec3(1, .7, .4)*pow(sun, 5.0);\n\tcol += 0.25*vec3(1, .8, .6)*pow(sun, 64.0);\n\tcol += 0.15*vec3(1, .9, .7)*max(pow(sun, 512.0), .25);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.04 - 0.02, 0., 1.);\n    \n    //return col;\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n    \n    float t = (5000. - ro.y)/rd.y; // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    //vec3 sc = vec3(uv.x, 0., uv.y);\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) col = mix( col, vec3(1, .9, .8), 0.35*smoothstep(0.4, 1.0, fbm(.0005*uv)* clamp(rd.y*5., 0., 1.)));\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n    // Object texture color, with some contract thrown in.\n    vec3 tx;\n    //tx = smoothstep(.05, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.5) {\n        tx = tex3D(iChannel0, p/2., n );\n        tx = smoothstep(-.1, .5, tx);\n        tx *= vec3(1, .6, .35); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.1, .6, surfFunc(p))*.6 + .4;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else {\n        vec2 pth = path(p.z);\n        tx = tex3D(iChannel0, (p - vec3(pth.xy - .5, .0)), n );\n        tx = smoothstep(-.15, .5, tx);\n        tx *= vec3(1.5, 1.0, .5)*.65 + .5; // Tinting the stairs.\n        tx *= tiles(p.xyz, n, .05)*.93 + .07;\n        \n        if(p.y - pth.y>-1.35) tx *= vec3(.64, .62, .6); // Rails.\n        \n        \n    }\n    \n    //tx *= bumpFunc(p.xyz, n);\n\n    \n    return tx;//pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        float edge = 0., crv = 1.;\n        vec3 sn = getNormal(sp, edge, crv);\n\n\n        float bf = .5;\n        if(svObjID<.5) bf = .01;\n\n        float edge2 = 0., crv2 = 1.; \n        //if(svObjID>.5)\n        sn = doBumpMap(sp, sn, bf/(1. + t/FAR*.125), edge2, crv2); \n\n        bf = .07;\n        \n        float txF = 1.;\n        if(svObjID<.5) {\n            bf = .04;\n            txF = 2.;\n        }\n        sn = doBumpMap(iChannel0, sp*txF, sn, bf);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.3)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 3./(1. + lDist*0.01 + lDist*lDist*0.00008);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec*1.);\n        \n        // Edges.\n        if(svObjID>.5) \n           sceneCol *= 1. - edge2*.6; // Bump mapped edging for the terrain only.     \n        \n        //if(svObjID>.5) \n        sceneCol *= 1. - edge*.8; // Geometry based edging.\n        \n        // Reflection. Not really suitable for this example.\n        //sceneCol += eMap(reflect(rd, sn), sn);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(10., FAR*.24, FAR*.52)*3.;\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/32.);\n    rd.yz *= r2(-sw.y/16.);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp);\n    \n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR); // t/FAR; \n\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n    // Sprinkles.\n    //sceneColor *= 1. + hash31(sp)*.1 - .05; \n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    /*\n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    uv = sin(uv*r2(3.14159/6.)*3.14159*iResolution.y/1.5)*.1 + 1.;\n    sceneColor *= uv.x*uv.y;\n    */\n    // Mild LCD overlay.\n    //vec2 rg = mix(mod(fragCoord, vec2(3))*sceneColor.xy, sceneColor.xy, .65);\n    //sceneColor = vec3(rg, sceneColor.z - mix(sceneColor.x - rg.x, sceneColor.y - rg.y, .65));\n    \n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1276, 1319, 1337, 1337, 1405], [1407, 1430, 1453, 1453, 1512], [1514, 1580, 1628, 1628, 2131], [2134, 2134, 2162, 2989, 3510], [3513, 3871, 3897, 4005, 5016], [5848, 5948, 5970, 6076, 6133], [6135, 6150, 6173, 6247, 6282], [6555, 7009, 7035, 7035, 7516], [7520, 7569, 7607, 7607, 7702], [7704, 8252, 8286, 8286, 9624], [9626, 9758, 9776, 9776, 10728], [10732, 10764, 10797, 10797, 11066], [11069, 11258, 11307, 11307, 11634], [11636, 11658, 11689, 11689, 12028], [12030, 12117, 12207, 12390, 14139], [14141, 14328, 14390, 14390, 14900], [14904, 14937, 14967, 14967, 15182], [15185, 15486, 15539, 15656, 16952], [16955, 17154, 17181, 17181, 17340], [17763, 17829, 17888, 17955, 18910], [18912, 19064, 19104, 19104, 19363], [19863, 20103, 20122, 20122, 20332], [20335, 20373, 20394, 20431, 20531], [20534, 20573, 20618, 20618, 22485], [22490, 22560, 22596, 22685, 23707], [23709, 23847, 23905, 23961, 26712], [26719, 26719, 26775, 26803, 29944]], "test": "error"}
{"id": "ldlBz8", "name": "cc", "author": "zhouce", "description": "aa", "tags": ["a"], "likes": 0, "viewed": 365, "published": "Public API", "date": "1494883426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "ok"}
{"id": "ldlBzH", "name": "paints drops", "author": "Torumu106", "description": "Please wait 21seconds to rotate.", "tags": ["shader2d"], "likes": 0, "viewed": 101, "published": "Public", "date": "1494920584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    r.y *= sin(r.x * 6.0 + 1.0) / 4.0 + sin(r.x * 11.0 + 2.0) / 4.0 + 2.0;\n    //r.x *= abs(sin(r.y * 3.0 + 1.0) / 4.0 + sin(r.y * 5.0 - 2.0) / 4.0) + 1.0;\n    //r.y *= sin(r.x * 4.0 - 1.0) / 4.0 + sin(r.x * 9.0 + 2.0) / 4.0 + 1.0;\n    \n    //rotate\n    const float RotateTime = 21.0;\n    if(iTime >= RotateTime){\n        float the = (3.0 - length(r)) * (iTime - RotateTime) / 10.0;\n    \tr.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    }\n    \n    vec3 ret = vec3(0.0, 0.0, 0.0);\n    \n    float x[3] = float[](-1.2, 0.9, 0.0);\n    float y[3] = float[](-0.9, 0.0, 0.8);\n    vec3 cols[3] = vec3[](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n    float dis = 10.0;\n        \n    for(int i = 0; i < 3; i++){\n        float disi = length(r - vec2(x[i], y[i])) ;\n        if(disi <= iTime * 0.1 && disi < dis){\n        \tret = cols[i];\n            dis = disi;\n        }\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "ldsBRH", "name": "Gas Giant Animation", "author": "caosdoar", "description": "How to build a gas giant, step by step.", "tags": ["procedural", "planet", "animation"], "likes": 3, "viewed": 470, "published": "Public API", "date": "1494918492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Caosdoar 2017 (caosdoar@gmail.com)\n\n#define PI          (3.1415926535897932384626433832795)\n#define HALF_PI     (1.5707963267948966192313216916398)\n#define TWO_PI      (6.283185307179586476925286766559)\n\n\n// Spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p)\n{\n    vec2 s = sin(p);\n    vec2 c = cos(p);\n    return vec3(c.x*s.y, c.y, s.x*s.y);\n}\n\nvec2 cart2sphe(vec3 p)\n{\n    p *= inversesqrt(dot(p, p));\n    return vec2(atan(p.z, p.x), acos(p.y));\n}\n\n// Ray-sphere intersection\nfloat sphere(vec3 o, vec3 l, vec3 c, float r2)\n{\n    const float eps = 0.0001;\n    \n    float a_ = dot(l,l);\n\tvec3 p = o - c;\n    float b_ = 2.0 * dot(l,p);\n    float c_ = dot(p,p) - r2;\n    \n    float a = b_*b_-4.0*a_*c_;\n    if (a < 0.0) return -1.0;\n    a = sqrt(a);\n    float t2 = -b_ + a;\n    if (t2 < eps) return -1.0;\n    float t1 = -b_ - a;\n    float result = (t1 > eps && t1 < t2) ? t1 : t2;\n    return result * 0.5 / a_;\n}\n\nint rotl17(int v) { return (v << 17) | (v >> 15); }\n\nint hash(int x, int y, int z, int seed)\n{\n    int h = seed * 374761393;\n    h = (x ^ h) * 374761393;\n    h = (y ^ h) * 374761393;\n    h = (z ^ h) * 374761393;\n    h = (h ^ rotl17(h)) * 2246822519;\n    return h;\n}\n\nfloat noise(vec3 p, int seed)\n{\n    return float(hash(int(p.x), int(p.y), int(p.z), seed)) / 4294967296.0;\n}\n\nfloat vnoise(vec3 p, int seed)\n{\n    vec3 p0 = floor(p);\n    vec3 s = p - p0;\n    //s = s * s * (3.0 - 2.0 * s);\n    s = s * s * s * (s * (s * 6.0 - 15.0) + 10.0);\n    \n    return mix(\n        mix(\n        \tmix(noise(p0, seed), noise(p0 + vec3(1.0, 0.0, 0.0), seed), s.x),\n        \tmix(noise(p0 + vec3(0.0, 1.0, 0.0), seed), noise(p0 + vec3(1.0, 1.0, 0.0), seed), s.x),\n        \ts.y),\n        mix(\n        \tmix(noise(p0 + vec3(0.0, 0.0, 1.0), seed), noise(p0 + vec3(1.0, 0.0, 1.0), seed), s.x),\n        \tmix(noise(p0 + vec3(0.0, 1.0, 1.0), seed), noise(p0 + vec3(1.0), seed), s.x),\n        \ts.y),\n        s.z);\n}\n\nvec3 grad(vec3 p, int seed)\n{\n    return vec3(noise(p, seed), noise(p, seed + 1), noise(p, seed + 2));\n}\n\n// by: Iñigo Quilez (with small modifications for custom hash)\n// https://www.shadertoy.com/view/4dffRH\nfloat gnoise(in vec3 x, int seed)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 iu = 1.0 - u;\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = grad( p+vec3(0.0,0.0,0.0), seed );\n    vec3 gb = grad( p+vec3(1.0,0.0,0.0), seed );\n    vec3 gc = grad( p+vec3(0.0,1.0,0.0), seed );\n    vec3 gd = grad( p+vec3(1.0,1.0,0.0), seed );\n    vec3 ge = grad( p+vec3(0.0,0.0,1.0), seed );\n\tvec3 gf = grad( p+vec3(1.0,0.0,1.0), seed );\n    vec3 gg = grad( p+vec3(0.0,1.0,1.0), seed );\n    vec3 gh = grad( p+vec3(1.0,1.0,1.0), seed );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return \n        va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + \n        u.x*u.y*(va-vb-vc+vd) + \n        u.y*u.z*(va-vc-ve+vg) + \n        u.z*u.x*(va-vb-ve+vf) + \n        (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n// by: Iñigo Quilez (with small modifications for custom hash)\n// https://www.shadertoy.com/view/4dffRH\nvec4 gnoised(in vec3 x, int seed)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    vec3 iu = 1.0 - u;\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = grad( p+vec3(0.0,0.0,0.0), seed );\n    vec3 gb = grad( p+vec3(1.0,0.0,0.0), seed );\n    vec3 gc = grad( p+vec3(0.0,1.0,0.0), seed );\n    vec3 gd = grad( p+vec3(1.0,1.0,0.0), seed );\n    vec3 ge = grad( p+vec3(0.0,0.0,1.0), seed );\n\tvec3 gf = grad( p+vec3(1.0,0.0,1.0), seed );\n    vec3 gg = grad( p+vec3(0.0,1.0,1.0), seed );\n    vec3 gh = grad( p+vec3(1.0,1.0,1.0), seed );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n// Curl-noise \n// Reference\n// https://www.cct.lsu.edu/~fharhad/ganbatte/siggraph2007/CD2/content/papers/046-bridson.pdf\nvec3 curlnoise(in vec3 p, int seed)\n{\n    vec4 x = gnoised(p, seed);\n    vec4 y = gnoised(p, seed+3);\n    vec4 z = gnoised(p, seed+6);\n    return vec3(z.z - x.w, x.w - z.y, y.y - x.z);\n}\n\nvec3 noise_offset(vec3 p, float f, float s)\n{\n    p += curlnoise(p * f, 1) * s;\n    p += curlnoise(p * f, 1) * s;\n    p += curlnoise(p * f, 1) * s;\n    return p;\n}\n\n\nfloat y_equator(float y)\n{\n    return pow(abs(y), 1.0) * sign(y);\n}\n\nfloat y_noise(float y)\n{\n    y += texture(iChannel0, vec2(y * 0.05, 0.0)).x * 0.08;\n    y += texture(iChannel0, vec2(y * 0.1, 0.0)).x * 0.04;\n    y += texture(iChannel0, vec2(y * 0.2, 0.0)).x * 0.02;\n    return y;\n}\n\nvec4 swirl(vec3 p, vec3 sc, float sr)\n{\n    float t = max(0.0, 1.0 - distance(p, sc) / sr);\n    float t2 = smoothstep(0.0, 1.0, t);\n    float theta = t2 * 10.0;\n    vec4 q1 = vec4(0.0, p.x, p.y, p.z);\n    float theta_half = theta * 0.5;\n    float s = sin(theta_half);\n    float c = cos(theta_half);\n    vec4 q2 = vec4(c, s * sc.x, s * sc.y, s * sc.z);\n    vec4 q2i = vec4(q2.x, -q2.y, -q2.z, -q2.w);\n    vec4 qa = vec4(\n        q1.x*q2.x-q1.y*q2.y-q1.z*q2.z-q1.w*q2.w,\n        q1.x*q2.y+q1.y*q2.x-q1.z*q2.w+q1.w*q2.z,\n        q1.x*q2.z+q1.y*q2.w+q1.z*q2.x-q1.w*q2.y,\n        q1.x*q2.w-q1.y*q2.z+q1.z*q2.y+q1.w*q2.x);\n    vec4 q3 = vec4(\n        q2i.x*qa.x-q2i.y*qa.y-q2i.z*qa.z-q2i.w*qa.w,\n        q2i.x*qa.y+q2i.y*qa.x-q2i.z*qa.w+q2i.w*qa.z,\n        q2i.x*qa.z+q2i.y*qa.w+q2i.z*qa.x-q2i.w*qa.y,\n        q2i.x*qa.w-q2i.y*qa.z+q2i.z*qa.y+q2i.w*qa.x);\n    return vec4(q3.yzw, t2);\n    //return vec3(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n#if 1\n    vec3 cc = vec3(0.0,0.0,3.6);\n    float cam_speed = 0.1;\n    vec3 co = 3.6 * sphe2cart(vec2(cam_speed*iTime, 3.14159*0.5+0.5*sin(cam_speed*iTime))) + cc;\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,1.0,0.0)));\n    vec3 cu = normalize(cross(cr, cf));\n#else\n    vec3 cc = vec3(0.0,0.0,3.6);\n    vec3 co = vec3(0.0,2.6,3.6);\n    vec3 cf = normalize(cc-co);\n    vec3 cr = normalize(cross(cf, vec3(0.0,0.0,1.0)));\n    vec3 cu = normalize(cross(cr, cf));\n#endif\n    uv *= 3.14159 * 0.25;\n    \n    vec3 rd = normalize(cr*uv.x + cu*uv.y + cf);\n    \n    vec3 so = vec3(0.0,0.0,3.6);\n    float r = 1.0;\n    float r2 = r*r;\n    float t = sphere(co, rd, so, r2);\n    if (t > 0.0)\n    {\n        vec3 p = co + t * rd;\n        vec3 pc = p - so;\n        \n        // Bands\n        vec2 scoord_clean = cart2sphe(pc);\n        float y_clean = scoord_clean.y / PI * 2.0 - 1.0;\n        y_clean = y_equator(y_clean);\n        y_clean = y_noise(y_clean);\n        float w0_clean = sin((y_clean * HALF_PI + HALF_PI / 4.0) * 12.0f);\n        \n        // Swirls\n        float row_count = 2.0;\n        float row = round(scoord_clean.y * row_count);\n        vec3 row_rand = texture(iChannel0, vec2(row / row_count, 0.35)).rgb;\n        float swirl_size = 0.3 + 0.7 * row_rand.y;\n        float swirl_start = fract(row_rand.x * 10.0f);\n        float swirl_offset = fract(iTime * (row_rand.z * 0.9 + 0.1) * 0.03);\n        vec2 swirlc_sph = vec2((swirl_start + swirl_offset) * TWO_PI, (row + 0.5 * (1.0 - swirl_size) * (row_rand.z * 2.0 - 1.0)) / row_count);\n        vec3 swirlc = sphe2cart(swirlc_sph);\n        vec4 swirl_data = swirl(pc, swirlc, 0.9 * swirl_size * 0.5 / row_count);\n        //float h = texture(iChannel0, cart2sphe(pc + swirl_data.xyz) / PI).r;\n        float swirl_out = 1.0 - swirl_data.w;\n        pc = swirl_data.xyz;\n        \n        vec3 pc1 = noise_offset(pc, 50.0, 0.002);\n        vec3 pc2 = noise_offset(pc, 5.0, 0.02);\n        pc1 += (pc2 - pc) * 0.2;\n        pc2 += (pc1 - pc) * 0.5;\n        \n        pc2 = mix(pc2, swirl_data.xyz, swirl_data.w);\n        \n        vec2 scoord = cart2sphe(pc1);\n        float y = scoord.y / PI * 2.0 - 1.0;\n        y = y_equator(y);\n        y = y_noise(y);\n        \n        float band = (y * HALF_PI + HALF_PI / 4.0) * 12.0f;\n        float w0 = sin(band);\n        float w1 = smoothstep(-1.0, 1.0, w0) * 2.0 - 1.0;\n        float w2 = smoothstep(-1.0, 1.0, w1) * 2.0 - 1.0;\n        \n        // band force\n        float a = sin((scoord.x + w0 * 0.25) * 10.0);\n        vec3 pn = pc2 * 7.0;\n        pn += swirl_out * gnoise(pc * 20.0, 1) * 0.2;\n        vec3 ptan = cross(vec3(0.0,1.0,0.0), normalize(pc));\n        pn += swirl_out * ptan * w0_clean * 2.0;\n        \n        //pn *= 4.0;\n        float b = gnoise(pn, 1) + 0.6 * gnoise(pn * 2.0, 2) + 0.5 * gnoise(pn * 4.0, 3) + 0.4 * gnoise(pn * 8.0, 4);\n        //float c = mix(w2, 0.75 * w0_clean + 0.4 * b, abs(w0_clean));\n        float c = w2 - w0_clean * (b * 0.5 + 0.5);\n        \n        float swirl_height_dir = sign(row_rand.z - 0.5);\n        c += 0.5 * swirl_data.w * swirl_height_dir;\n        //c = clamp(c, -1.0, 1.0) - 0.2 * swirl_data.w * swirl_height_dir * b;\n        float swirl_inner = max(0.0, swirl_data.w);\n        //swirl_inner = pow(swirl_inner, 0.5);\n        c = mix(c, swirl_height_dir * b, swirl_inner);\n        //float a = gnoise(pc * 10.0, 1);\n        \n        \n        \n        fragColor = vec4(vec3(c * 0.5 + 0.5), 1.0);\n        //fragColor = vec4(vec3(swirl_data.w), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(vec3(0.1), 1.0);\n    }\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsBRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 246, 270, 270, 354], [356, 356, 380, 380, 459], [461, 488, 536, 536, 920], [922, 922, 941, 941, 973], [975, 975, 1016, 1016, 1187], [1189, 1189, 1220, 1220, 1297], [1299, 1299, 1331, 1331, 1911], [1913, 1913, 1942, 1942, 2017], [2019, 2124, 2159, 2171, 3525], [3527, 3632, 3667, 3679, 5388], [5390, 5511, 5548, 5548, 5697], [5699, 5699, 5744, 5744, 5862], [5865, 5865, 5891, 5891, 5932], [5934, 5934, 5958, 5958, 6149], [6151, 6151, 6190, 6190, 7053], [7055, 7055, 7112, 7112, 10801]], "test": "error"}
{"id": "ldsBWH", "name": "raym donuts infinite", "author": "anclin", "description": "raym donuts infinite", "tags": ["raymdonutsinfinite"], "likes": 2, "viewed": 74, "published": "Public", "date": "1496092830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat SceneSDF(vec3 p){\n    \n    p = rotateY(iTime * 0.2) * p;\n    \n    float gap = 1.75;\n    \n    p.x = mod(p.x + gap, 2.0 * gap) - gap;\n    p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n\tfloat torus = TorusSDF(p, vec2(1,0.5));\n    return torus;\n}\n\n\n\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for(int i = 0; i < 255; i++){\n    \tfloat dist = SceneSDF(eye + depth * marchingDirection);\n        if( dist <= EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    vec3 eye = vec3(0.0 + 0.0 * cos(iTime),\n                    12.0 + 0.0 * sin(iTime),\n                    40.0 + 0.0 * sin(iTime));\n    \n    vec3 lookAtPos = vec3(3.0 + 0.0 * cos(iTime),\n                          0.0 + 0.0 * sin(iTime/2.0),\n                          -3.0 + 0.0 * sin(iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    \n    float dist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(1,0,0);\n    \n    //vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n    \tfinalColor = (normal + vec3(1.0)) / 2.0;\n        //finalColor = finalColor * (diffuse + ambientColor);\n        finalColor = finalColor * remap(60.0, 20.0, 0.0, 1.0, dist);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 136, 136, 206], [208, 254, 281, 281, 428], [430, 521, 567, 567, 599], [601, 685, 727, 727, 759], [761, 850, 897, 897, 930], [932, 932, 968, 968, 996], [998, 998, 1031, 1031, 1234], [1236, 1236, 1270, 1270, 1335], [1340, 1340, 1363, 1363, 1586], [1591, 1591, 1619, 1619, 1917], [1919, 2008, 2037, 2037, 2347], [2349, 2349, 2413, 2413, 2542], [2544, 2544, 2634, 2634, 2921], [2923, 3250, 3299, 3334, 3560], [3562, 3562, 3619, 3619, 4946]], "test": "ok"}
{"id": "ldsBzn", "name": "fire2d", "author": "lovelyH", "description": "my attempt to make realistic fire.", "tags": ["2d", "fire"], "likes": 0, "viewed": 98, "published": "Public", "date": "1494678204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// rand\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/// UV\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t/// zoom\n\tuv *= 1.2;\n\n\t/// result\n\tfloat r= 0.0;\n\n\t/// repat whole process few times\n\tconst float iterationsNum= 16.0;\n\tfor(float b=0.0;b<iterationsNum;b++){\n\t\tconst float w=8.0;\n\t\tfor( float a=-w;a<=w;a++){\n\t\t\tconst float div= 1.0 / 64.0;\n\t\t\tfloat x= floor( uv.x/div )*div + div/2.0 + a*div;\n\n\t\t\tfloat y= mod( iTime+2.0*rand(vec2(x,0.1+b/iterationsNum)), 2.0 );\n\n\t\t\t/// radius of ball\n\t\t\tfloat rad= div*(w+0.5) * clamp( 0.5*y+1.0, 0.1, 1.0 );\n\n\t\t\t/// ball shape\n\t\t\tif( length(uv-vec2(x,(0.3+0.7*rand(vec2(x,-0.1)))*y-1.0)) < rad ){\n\t\t\t\t/// dark at bottom and top\n\t\t\t\tr += clamp( 1.0-abs(y-1.0), 0.0, 1.0 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/// get rid of artifacts, look much better than clamp\n\tr= 1.0 - 1.0 / (1.0 + 4.0*r/iterationsNum );\n\n\t/// return\n\tr *= 3.0;\n\tfragColor = vec4(\n\t\tclamp(r,0.0,1.0),\n\t\tclamp(r-1.0,0.0,1.0),\n\t\tclamp(r-2.0,0.0,1.0),\n\t\t1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 29, 29, 96], [98, 98, 155, 163, 1108]], "test": "ok"}
{"id": "ldScDc", "name": "Raytracer with Reflections", "author": "Assossa", "description": "Credits in the comments\n\nhttps://github.com/AssossaGPB/Shadertoy-Raytracers", "tags": ["raytracer", "reflections", "prototype"], "likes": 6, "viewed": 152, "published": "Public", "date": "1494090899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nBase raytracer: http://fhtr.blogspot.com/2013/12/opus-2-glsl-ray-tracing-tutorial.html\nCube intersection function: https://tavianator.com/fast-branchless-raybounding-box-intersections/\nCube normal function: http://ray-tracing-conept.blogspot.com/2015/01/ray-box-intersection-and-normal.html\nImplemented suggestions from: iapafoto, abje, KylBlz\n*/\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius) {\n    vec3 rc = ray - center;\n    float c = dot(rc, rc) - (radius * radius);\n    float b = dot(dir, rc);\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t, d));\n    return mix(-1.0, t, st);\n}\n\nfloat cube(vec3 ray, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 ddir = 1.0 / dir;\n    vec3 t1 = (bmin - ray) * ddir;\n    vec3 t2 = (bmax - ray) * ddir;\n    vec3 tmin = vec3(min(t1.x, t2.x), min(t1.y, t2.y), min(t1.z, t2.z));\n    vec3 tmax = vec3(max(t1.x, t2.x), max(t1.y, t2.y), max(t1.z, t2.z));\n    float tmin_max = max(tmin.x, max(tmin.y, tmin.z));\n    float tmax_min = min(tmax.x, min(tmax.y, tmax.z));\n    return tmax_min >= tmin_max ? tmin_max : -1.0;\n}\n\nvec3 cubeNml(vec3 i, vec3 bmin, vec3 bmax) {\n    float epsilon = 0.01;\n    vec3 c = abs(i-bmin);\n    vec3 f = abs(i-bmax);\n    return normalize(step(c, vec3(epsilon)) - step(f, vec3(epsilon)));\n}\n\nvec3 background(float t, vec3 rd) {\n    vec3 light = normalize(vec3(sin(t), 0.2, cos(t)));\n    float sun = max(0.0, dot(rd, light));\n    float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) +\n        pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +\n        pow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 ro = 1.5 * vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 2.0));\n\n    vec3 transmit = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    float epsilon = 0.001;\n    int bounce_count = 8;\n\n    // Cube\n    vec3 cmin;\n    vec3 cmax;\n    {\n        vec3 size = vec3(0.25);\n        float orbit_radius = 2.25;\n        float orbit_speed = 1.334;\n        vec3 center = vec3(sin(iTime * orbit_speed) * orbit_radius, 0.0, cos(iTime * orbit_speed) * orbit_radius);\n        cmin = center - size;\n        cmax = center + size;\n    }\n    float cmat = 0.8;\n\n    // Sphere\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    float radius = 1.75;\n    float smat = 0.9;\n\n    for (int i = 0; i < bounce_count; i++) {\n        float c = cube(ro, rd, cmin, cmax);\n        float s = sphere(ro, rd, p, radius);\n\n        if (c > 0.0 && (s <= 0.0 || (s > 0.0 && s > c))) { // Ray hit the cube\n            ro += rd * c;\n            vec3 nml = cubeNml(ro, cmin, cmax);\n            transmit *= cmat;\n            rd = reflect(rd, nml);\n            ro += rd * epsilon;\n        } else if (s > 0.0 && (c <= 0.0 || (c > 0.0 && c > s))) { // Ray hit the sphere\n            ro += rd * s;\n            vec3 nml = normalize(p - ro);\n            transmit *= smat;\n            rd = reflect(rd, nml);\n            ro += rd * epsilon;\n        } else {\n            light += transmit * background(iTime, rd);\n            break;\n        }\n    }\n\n\tfragColor = vec4(light, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldScDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 412, 412, 641], [643, 643, 697, 697, 1103], [1105, 1105, 1149, 1149, 1300], [1302, 1302, 1337, 1337, 1721], [1723, 1723, 1780, 1780, 3309]], "test": "ok"}
{"id": "ldScDt", "name": "Pack Ice", "author": "dr2", "description": "Flight over voronian icescape (mouse enabled)", "tags": ["voronoi", "ocean", "ice", "flight"], "likes": 9, "viewed": 569, "published": "Public API", "date": "1494322363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Pack Ice\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nmat3 flyerMat[2], flMat;\nvec3 flyerPos[2], flPos, qHit, qHitTransObj, sunDir;\nfloat tCur, dstFar, flyVel, fusLen, wSpan;\nint idObj, idObjGrp;\nconst int idFus = 11, idPipe = 12, idWing = 13, idStrut = 14, idHstab = 15,\n   idFin = 16, idLeg = 17, idAxl = 18, idWhl = 19, idNose = 20, idCkpit = 21,\n   idPlt = 22;\nconst float pi = 3.14159;\n\nfloat VorDist (vec2 p)\n{\n  vec3 dv;\n  vec2 ip, fp, g, b;\n  ip = floor (p);\n  fp = fract (p);\n  dv = vec3 (8.);\n  b.x = 0.;\n  for (float gy = -1.; gy <= 1.; gy ++) {\n    for (float gx = -1.; gx <= 1.; gx ++) {\n      g = vec2 (gx, gy);\n      dv.z = length (g + 0.9 * Hashv2v2 (ip + g) - fp);\n      b.y = step (dv.z, dv.y) * (dv.z - dv.y);\n      dv.xy += b + step (dv.z, dv.x) * (dv.zx - dv.xy - b);\n    }\n  }\n  return dv.y - dv.x;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float s;\n  s = Noisefv2 (0.3 * p.yx);\n  p += 1.5 * sin (2. * pi * s) +\n     0.1 * sin (2. * pi * Noisefv2 (2. * p.xy));\n  return 2. * smoothstep (0.2, 0.35 + 0.3 * s, VorDist (0.03 * p));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.3, 0.35 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  float h;\n  h = GrndHt (p.xz);\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x,\n     h - GrndHt (p.xz + e.yx)));\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, wr;\n  q = p;\n  wr = -0.2 + q.z / fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n     0.11 * (1. - 0.6 * wr * wr), 1.) * fusLen, 0.05 * fusLen);\n  q -= vec3 (0., 0.1, 0.3) * fusLen;\n  d = max (d, - PrRoundBoxDf (q, vec3 (0.05, 0.1, 0.15) * fusLen,\n     0.03 * fusLen)); \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idFus;  qHit = q; }\n  q = p;  q -= vec3 (0., 0.08, 0.3) * fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.02, 0.15) * fusLen, 0.03 * fusLen); \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idCkpit;  qHit = q; }\n  q = p;  q.z = abs (q.z - 0.33 * fusLen) - 0.08 * fusLen;\n  q -= vec3 (0., 0.17, 0.) * fusLen;\n  d = PrSphDf (q, 0.04 * fusLen); \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idPlt;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 0.8);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCapsDf (q, 0.02 * fusLen, 0.15 * fusLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idPipe;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 1.05);\n  d = PrCapsDf (q, 0.05 * fusLen, 0.02 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idNose;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.2);\n  qq = q;  qq.y = abs (qq.y) - 0.21 * fusLen;\n  wr = q.x / wSpan;\n  d = PrFlatCylDf (qq.zyx, 0.24 * (1. - 0.2 * wr * wr) * fusLen,\n     0.01 * (1. - 0.8 * wr * wr) * fusLen, wSpan);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idWing;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.25);\n  q.xz = abs (q.xz) - fusLen * vec2 (0.5, 0.1);\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.21 * fusLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idStrut;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.15, 0.25);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.15 * fusLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idStrut;  qHit = q; }\n  float tSpan = 0.35 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.9);\n  wr = q.x / tSpan;\n  d = PrFlatCylDf (q.zyx, 0.15 * (1. - 0.25 * wr * wr) * fusLen,\n     0.007 * (1. - 0.2 * wr * wr) * fusLen, tSpan);\n  q.x = abs (q.x);\n  d = max (d, 0.02 * fusLen - 1.5 * q.x - q.z);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idHstab;  qHit = q; }\n  float fSpan = 0.32 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.87);\n  q.yz = Rot2D (q.yz, 0.15);\n  wr = q.y / fSpan;\n  d = PrFlatCylDf (q.zxy, 0.15 * (1. - 0.3 * wr * wr) * fusLen,\n     0.007 * (1. - 0.3 * wr * wr) * fusLen, fSpan);\n  d = max (d, - q.y);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idObjGrp + idFin;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.25, 0.5);\n  q.x = abs (q.x) - 0.14 * fusLen;\n  q.xy = Rot2D (q.xy, -0.55);  q.yz = Rot2D (q.yz, 0.15);\n  d = PrCylDf (q.xzy, 0.013 * fusLen, 0.12 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idLeg;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.34, 0.515);\n  q.x = abs (q.x) - 0.22 * fusLen;\n  d = PrCylDf (q.yzx, 0.01 * fusLen, 0.035 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idAxl;  qHit = q; }\n  q.x -= 0.01 * fusLen;\n  d = PrCylDf (q.yzx, 0.1 * fusLen, 0.015 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + idWhl;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  idObjGrp = 1 * 256;\n  dMin = FlyerDf (flyerMat[0] * (p - flyerPos[0]), dMin);\n  idObjGrp = 2 * 256;\n  dMin = FlyerDf (flyerMat[1] * (p - flyerPos[1]), dMin);\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat PropelDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - fusLen * vec3 (0., 0.02, 1.07);\n  d = PrCylDf (q, 0.3 * fusLen, 0.007 * fusLen);\n  if (d < dMin) { dMin = d;  qHitTransObj = q; }\n  return dMin;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = PropelDf (flyerMat[0] * (p - flyerPos[0]), dMin);\n  dMin = PropelDf (flyerMat[1] * (p - flyerPos[1]), dMin);\n  return dMin;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 30; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol (int ig, int id, vec3 n)\n{\n  vec3 col, qqHit, nn;\n  float spec, b;\n  spec = 0.2;\n  qqHit = qHit / fusLen;\n  col = (ig == 2) ? vec3 (1., 0., 0.) : vec3 (0., 1., 0.);\n  if (id == idFus) {\n    qqHit.yz -= vec2 (-0.1, -0.7);\n    col = mix (vec3 (0.5, 0.5, 1.), col,\n       (1. - SmoothBump (0.06, 0.09, 0.01, length (qqHit.yz))) *\n       (1. - SmoothBump (-0.01, 0.03, 0.01, length (qqHit.yz))));\n    if (n.z > 0.9 && qqHit.y < -0.03) col *= 0.3;\n  } else if (id == idWing) {\n    b = wSpan / (8. * fusLen);\n    b = mod (qqHit.x + 0.5 * b, b) - 0.5 * b;\n    col *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, b);\n    if (qqHit.y * n.y > 0.) {\n      qqHit.x = abs (qqHit.x) - 0.8;\n      qqHit.z -= 0.03;\n      col *= mix (vec3 (0.5, 0.5, 1.), col,\n         (1. - SmoothBump (0.08, 0.12, 0.01, length (qqHit.xz))) *\n         (1. - SmoothBump (-0.01, 0.03, 0.01, length (qqHit.xz))));\n    }\n  } else if (id == idFin || id == idHstab) {\n    col *= 1. - 0.6 * SmoothBump (-0.062, -0.052, 0.002, qqHit.z);\n  } else if (id == idPipe || id == idNose) {\n    col = vec3 (0.8, 0.8, 0.);\n    spec = 0.4;\n  } else if (id == idStrut || id == idLeg) {\n    col = 0.6 * col + vec3 (0.4);\n  } else if (id == idAxl) {\n    col = vec3 (0.3, 0.2, 0.);\n  } else if (id == idCkpit) {\n    col = vec3 (0.2, 0.15, 0.05);\n  } else if (id == idPlt) {\n    col = vec3 (0.1, 0.07, 0.);\n    if (n.z > 0.7) {\n      col *= 2.;\n      qqHit.x = abs (qqHit.x) - 0.015 * fusLen;\n      col *= (1. - 0.9 * SmoothBump (0.003, 0.01, 0.001, length (qqHit.xy)));\n    }\n  } else if (id == idWhl) {\n    if (length (qqHit.yz) < 0.07) col = vec3 (0.4, 0.4, 0.4);\n    else {\n      col = vec3 (0.02);\n      spec = 0.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02 * fusLen;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.03 * fusLen;\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.15;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  ro.xz += 2. * tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  col = vec3 (0.1, 0.2, 0.5) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n     0.35 * pow (sd, 8.) + 0.65 * min (pow (sd, 256.), 0.3);\n  f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n  col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, colW, roo;\n  float dstObj, dstGrnd, dstWat, dstPropel, sh;\n  int ig, id;\n  bool isRefl;\n  roo = ro;\n  dstGrnd = GrndRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y - 0.1 : dstFar;\n  dstObj = ObjRay (ro, rd);\n  dstPropel = TransObjRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstPropel) dstPropel = dstFar;\n  isRefl = false;\n  if (dstWat < min (min (dstGrnd, dstObj), dstFar)) {\n    ro += rd * dstWat;\n    roo = ro;\n    vn = VaryNf (0.8 * ro, vec3 (0., 1., 0.), 0.1);\n    rd = reflect (rd, vn);\n    ro += 0.1 * rd;\n    dstGrnd = GrndRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < min (dstGrnd, dstFar)) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    ig = idObj / 256;\n    id = idObj - 256 * ig;\n    col4 = FlyerCol (ig, id, ((ig == 2) ? flyerMat[1] : flyerMat[0]) * vn);\n    if (idObj == 256 + idWing || idObj == 256 + idHstab) {\n      vn.yz = Rot2D (vn.yz, -0.6 * qHit.z / fusLen);\n      vn = VaryNf (100. * ro, vn, 0.05);\n    } else if (idObj == 256 + idFin) {\n      vn.xz = Rot2D (vn.xz, -0.6 * qHit.z / fusLen);\n    }\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n       0.6 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n  } else if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = VaryNf (2.3 * ro, GrndNf (ro), 2.);\n    vn = VaryNf (15. * ro.zyx, vn, 0.5);\n    sh = GrndSShadow (ro, sunDir);\n    col = vec3 (1.);\n    col = col * (0.1 + 0.2 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * 0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n    col = mix (col, SkyCol (roo, rd), max (pow (dstGrnd / dstFar, 4.) - 0.1, 0.));\n  } else col = SkyCol (ro, rd);\n  if (isRefl) col *= 0.95;\n  if (dstPropel < dstFar) col = vec3 (0.1) * (1. - 0.3 * SmoothBump (0.25, 0.27,\n     0.006, length (qHitTransObj.xy) / fusLen)) + 0.7 * col;\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvec3 TrackPath (float z)\n{\n  return vec3 (30. * sin (0.035 * z) * sin (0.012 * z) * cos (0.01 * z) +\n     26. * sin (0.0032 * z),\n     4.5 + 2. * SmoothBump (0.4, 0.7, 0.1, mod (0.006 * z, 1.)), z);\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float vy, dt, rlFac;\n  dt = 0.2;\n  flPos = TrackPath (t * flyVel);\n  fpF = TrackPath ((t + dt) * flyVel);\n  fpB = TrackPath ((t - dt) * flyVel);\n  vel = (fpF - fpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  rlFac = (vu == 0.) ? 0.3 : 0.5;\n  ort = vec3 (0., atan (vel.z, vel.x) - 0.5 * pi,\n     rlFac * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec3 e = vec3 (1., 0., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (sd.z, 8.) *\n     (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.04, 0.07, 0.07, length (uv - sd.xy)) +\n      e.xyx * SmoothBump (0.15, 0.2, 0.07, length (uv - 0.5 * sd.xy)) +\n      e.yxx * SmoothBump (1., 1.2, 0.07, length (uv + sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, f, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  dstFar = 300.;\n  fusLen = 0.7;\n  wSpan = 1.2 * fusLen;\n  flyVel = 5.;\n  FlyerPM (tCur + 3., 1.);\n  flyerPos[0] = flPos;  flyerPos[0].x -= 3.;\n  flyerMat[0] = flMat;\n  FlyerPM (tCur + 3.5, 1.);\n  flyerPos[1] = flPos;  flyerPos[1].x += 3.;\n  flyerMat[1] = flMat;\n  rd = normalize (vec3 (uv, 2.));\n  if (mPtr.z > 0.) {\n    FlyerPM (tCur + 3.25, 0.);\n    ro = flPos;\n    az = clamp (-1.5 * pi * mPtr.x, - pi, pi);\n    el = clamp (-1.3 * pi * mPtr.y, - 0.25 * pi, 0.25 * pi);\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n            mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n    rd = rd * vuMat * flMat;\n  } else {\n    s = mod (0.02 * tCur, 2.);\n    FlyerPM (tCur + 4. * SmoothBump (0.3, 0.8, 0.15, mod (s, 1.)), 0.);\n    ro = flPos;\n    ro.y += sin (0.1 * tCur);\n    vd = normalize (flyerPos[0] + SmoothBump (0.95, 1.95, 0.05, s) *\n       (flyerPos[1] - flyerPos[0]) - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * rd;\n  }\n  col = ShowScene (ro, rd) + GlareCol (rd, vuMat * sunDir, 1.5 * uv);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldScDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[874, 874, 898, 898, 1304], [1306, 1306, 1329, 1329, 1521], [1523, 1523, 1557, 1557, 2051], [2053, 2053, 2075, 2075, 2227], [2229, 2229, 2265, 2265, 5495], [5497, 5497, 5519, 5519, 5733], [5735, 5735, 5768, 5768, 5944], [5946, 5946, 5967, 5967, 6169], [6171, 6171, 6208, 6208, 6386], [6388, 6388, 6415, 6415, 6581], [6583, 6583, 6621, 6621, 6801], [6803, 6803, 6843, 6843, 8516], [8518, 8518, 8555, 8555, 8798], [8800, 8800, 8838, 8838, 9062], [9064, 9064, 9096, 9096, 9474], [9476, 9476, 9511, 9511, 11597], [11599, 11599, 11625, 11625, 11799], [11801, 11801, 11835, 11835, 12545], [12547, 12547, 12590, 12590, 13004], [13006, 13006, 13062, 13062, 14618], [14620, 14620, 14653, 14653, 14680], [14682, 14682, 14724, 14724, 14775], [14777, 14777, 14820, 14820, 14884], [14886, 14886, 14945, 14945, 15049], [15051, 15051, 15097, 15097, 15144], [15146, 15146, 15203, 15203, 15286], [15288, 15288, 15318, 15318, 15376], [15499, 15499, 15523, 15523, 15570], [15572, 15572, 15596, 15596, 15769], [15771, 15771, 15796, 15796, 15975], [15977, 15977, 15998, 15998, 16153], [16155, 16155, 16184, 16184, 16412], [16414, 16414, 16453, 16453, 16648]], "test": "error"}
{"id": "ldScDV", "name": "Machinery", "author": "dr2", "description": "Doesn't do much...", "tags": ["raymarch", "raytrace", "machine"], "likes": 18, "viewed": 523, "published": "Public API", "date": "1493824233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Machinery\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrOBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylAnDf (vec3 p, float b, float r, float w, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n\n#define NBLK 12.\n\nvec3 lbPos, vnBlk;\nvec2 qBlk;\nfloat dstFar, tCur, bEdge, tCyc;\nint idObj;\nbool doSh;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8, idBl = 9;\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float aRot, \n   bool bev, float dMin)\n{\n  vec3 q;\n  float d, s;\n  q = p;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    q.xy = Rot2D (q.xy, aRot);\n    q.xy = Rot2D (q.xy, floor (nt * atan (q.y, - q.x) / (2. * pi) + 0.5) *\n       2. * pi / nt);\n    if (bev) q.xy *= 1.2 - 0.2 * q.z / wlThk;\n    s = q.x - 2. * clamp (1.5 * tWid + 0.5 * q.x * step (0., q.x) - abs (q.y),\n      0., tWid);\n    d = max (d, - rad - 0.95 * s);\n  }\n  return min (dMin, d);\n}\n\nvec4 BPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 5.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t / 5., bEdge, 0.);\n  } else if (t < 10.) {\n    a = 0.5 * pi * (t - 5.) / 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 15.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 10.) / 5., 1. + bEdge, 1.);\n  } else if (t < 17.5) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 15.) / 2.5);\n  } else {\n    t -= 17.5;\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, angRot, wlThk, tWid, nt, rad;\n  dMin = dstFar / 0.3;\n  angRot = 0.1 * pi * tCur;\n  rad = 0.3;\n  wlThk = rad / 7.;\n  tWid = rad / 10.;\n  nt = 20.;\n  dMin = GearWlDf (- (p - vec3 (-1.05, -0.21, 1.3)), rad, wlThk, tWid, nt,\n     angRot, true, dMin);\n  dMin = GearWlDf ((p - vec3 (-1.05 + 0.85 * rad, -0.21, 1.3 + 0.85 * rad)).yzx,\n     rad, wlThk, tWid, nt, angRot + pi / nt, true, dMin);\n  angRot = -0.1 * pi * tCur;\n  rad = 0.39;\n  wlThk = rad / 15.;\n  tWid = rad / 16.;\n  nt = 36.;\n  dMin = GearWlDf ((p - vec3 (0.1, bEdge, 1.)).yzx, rad, wlThk, tWid, nt,\n     angRot, false, dMin);\n  dMin = GearWlDf (- (p - vec3 (0.1, -0.21, 1.555)).zyx, rad * 2./3., wlThk, tWid,\n     nt * 2./3., angRot * 3./2., false, dMin);\n  return dMin * 0.3;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, angRot, r, a;\n  dMin = dstFar;\n  q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n  r = length (q.yz);\n  q.yz = Rot2D (q.yz, -0.5 * pi * tCur / 5.);\n  a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n  q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) / 8.);\n  q.z = abs (q.z);\n  d = max (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n     max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi / 32.),\n     cos (0.8 * 2. * pi / 32.))))), abs (q.x) - 0.03);\n  if (d < dMin) { dMin = d;  idObj = idWhl; }\n  d = PrOBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1));\n  d = min (d, PrOBoxDf (p - vec3 (-1.018, 0.98, 0.5), vec3 (0.1, 0.02, 0.5 - bEdge)));\n  if (d < dMin) { dMin = d;  idObj = idPln; }\n  d = PrFlatCylAnDf (p - vec3 (-0.05, -0.21, 0.), 1., 0.2, 0.01, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idConv; }\n  q = p - vec3 (-0.05, -0.21, 0.);\n  q.x = abs (q.x) - 1.;\n  d = PrCylDf (q, 0.19, 0.12);\n  if (d < dMin) { dMin = d;  idObj = idSpl; }\n  q = p - vec3 (0.65, -0.14, 1.);\n  q.x = abs (q.x) - 0.3;\n  d = PrRoundBoxDf (q, vec3 (0.01, 1.08, 0.06), 0.02);\n  q = p - vec3 (-0.05, -0.68, 0.);\n  q.xz = abs (q.xz) - vec2 (1., 0.2);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n  d = min (d, PrRoundBoxDf (p - vec3 (-1.05, -0.14, 1.),\n     vec3 (0.04, 1.08, 0.01), 0.02));\n  q = p - vec3 (-0.33, -0.68, 1.555);\n  q.x = abs (q.x) - 0.3;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.55, 0.04), 0.02));\n  if (d < dMin) { dMin = d;  idObj = idSup; }\n  q = p - vec3 (0.65, bEdge, 1.);\n  d = PrCylDf (q.yzx, 0.04, 0.62);\n  d = min (d, PrCylDf (p - vec3 (0.95, -0.21, 0.), 0.03, 0.27));\n  d = min (d, min (d, PrCylDf (p - vec3 (-1.05, -0.21, 0.55), 0.03, 0.82)));\n  d = min (d, PrCylDf ((p - vec3 (-0.36, -0.21, 1.555)).yzx, 0.03, 0.51));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  d = PrOBoxDf (p - vec3 (0., -1.2, 0.9), vec3 (1.6, 0.05, 1.4));\n  if (d < dMin) { dMin = d;  idObj = idBas; }\n  if (! doSh) {\n    d = PrSphDf (p - lbPos, 0.04);\n    if (d < dMin) { dMin = d;  idObj = idBl; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0005, -0.0005, 0.);\n  vec4 v = vec4 (GearDf (p + e.xxx), GearDf (p + e.xyy),\n     GearDf (p + e.yxy), GearDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0005, -0.0005, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = 0.; k < NBLK; k ++) {\n    a4 = BPos (tCur + tCyc * k / NBLK);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = max (max (tm.x, tm.y), tm.z);\n    df = min (min (tp.x, tp.y), tp.z);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 a4;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = 0.; k < NBLK; k ++) {\n    a4 = BPos (tCur + tCyc * k / NBLK);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm / rdm;\n    tp = bEdge / abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = max (max (tm.x, tm.y), tm.z);\n    df = min (min (tp.x, tp.y), tp.z);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.03 + 0.03 * d;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GearSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = GearDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.05;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ld;\n  float d, wGlow;\n  wGlow = 0.;\n  ld = lbPos - ro;\n  d = length (ld);\n  ld /= d;\n  if (d < dstHit) wGlow += pow (max (dot (rd, ld), 0.), 1024.);\n  return clamp (0.5 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, ltDir, vn, col, q;\n  float dstObj, dstGear, dstBlk, spec, sh, s, r, a;\n  int idObjT;\n  bool isLit, isBg;\n  tCyc = 18.5;\n  bEdge = 0.08;\n  spec = 0.1;\n  doSh = false;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  isLit = true;\n  isBg = false;\n  roo = ro;\n  dstGear = GearRay (ro, rd);\n  if (dstGear < min (dstObj, dstFar)) {\n    dstObj = dstGear;\n    idObj = idGr;\n  } else idObj = idObjT;\n  dstBlk = BlkHit (ro, rd);\n  if (dstBlk < min (dstObj, dstFar)) {\n    dstObj = dstBlk;\n    ro += rd * dstObj;\n    vn = vnBlk;\n    col = vec3 (1., 0., 0.);\n    qBlk = abs (qBlk);\n    if (max (qBlk.x, qBlk.y) > 0.8 * bEdge) {\n      col = vec3 (0.9);\n      spec = 0.5;\n    }\n  } else if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    if (idObj == idGr) vn = GearNf (ro);\n    else vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idWhl) {\n      col = vec3 (0.9, 0.7, 0.3);\n      q = ro - vec3 (1.1 + bEdge + 0.03, bEdge, 1.);\n      r = length (q.yz);\n      q.yz = Rot2D (q.yz, -0.5 * pi * tCur / 5.);\n      a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n      a = mod (64. * a + 0.5, 1.);\n      if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n      if (r > 0.92) col *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n      spec = 0.5;\n    } else if (idObj == idGr) {\n      col = vec3 (0.8, 0.7, 0.3);\n      spec = 0.5;\n    } else if (idObj == idSpl) {\n      if (abs (ro.z) > 0.1) {\n        col = vec3 (0.8, 0.8, 0.85);\n        spec = 0.5;\n      } else col = vec3 (0.4, 0.4, 0.3);\n    } else if (idObj == idAx) {\n      col = vec3 (0.8, 0.8, 0.85);\n      spec = 0.5;\n    } else if (idObj == idPln) {\n      col = (abs (vn.y) > 0.99) ? vec3 (0.5, 0.7, 0.2) : vec3 (0.5, 0.2, 0.7);\n      spec = 0.;\n    } else if (idObj == idConv) {\n      q = ro - vec3 (-0.05, -0.21, 0.);\n      col = vec3 (0.8, 0.8, 0.2);\n      if (abs (q.x) < 1. && abs (vn.y) > 0.99 && sign (vn.y) != sign (q.y))\n         col *= 1. - 0.9 * SmoothBump (0.45, 0.55, 0.03,\n         mod (10. * (q.x - sign (q.y) * mod (tCur, 20.) * 2.1 / 5.), 1.));\n    } else if (idObj == idSup) {\n      col = vec3 (0.6, 0.4, 0.4);\n    } else if (idObj == idBas) {\n      q = ro;\n      q.z -= 0.9;\n      q.xz = abs (q.xz) - vec2 (1.55, 1.35);\n      col = (max (q.x, q.z) > 0.) ? vec3 (0.2, 0.1, 0.) : vec3 (0., 0.1, 0.05);\n      spec = 0.;\n    } else if (idObj == idBl) {\n      col = (0.7 + 0.5 * dot (rd, normalize (lbPos - ro))) * vec3 (1., 1., 0.7);\n      isLit = false;\n    }\n  } else isBg = true;\n  if (! isBg) {\n    if (isLit) {\n      ltDir = normalize (lbPos - ro);\n      doSh = true;\n      sh = min (ObjSShadow (ro, ltDir), GearSShadow (ro, ltDir));\n      sh = 0.5 + 0.5 * min (sh, BlkHitSh (ro + 0.01 * ltDir, ltDir, 5.));\n      col = col * (0.05 + 0.1 * max (vn.y, 0.) + 0.1 * max (- dot (vn, ltDir), 0.) +\n         0.9 * sh * max (dot (vn, ltDir), 0.)) +\n         spec * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } \n  } else col = vec3 (0., 0., 0.05) * (1. + 0.9 * rd.y);\n  col = mix (col, vec3 (0.7, 0.7, 0.4), GlowCol (roo, rd, dstObj));\n  col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 30.;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += 3. * pi * sin (0.01 * pi * tCur);\n    el += 0.17 * pi * sin (0.07 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -8.);\n  ro.z += 0.9;\n  lbPos = vec3 (1.8 * cos (0.4 * tCur), 2.5 + 0.3 * sin (0.3 * tCur),\n     0.9 + 1.6 * sin (0.4 * tCur));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylAnDf (vec3 p, float b, float r, float w, float h)\n{\n  p.x -= b * clamp (p.x / b, -1., 1.);\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldScDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[666, 666, 775, 775, 1213], [1215, 1215, 1236, 1236, 1809], [1811, 1811, 1834, 1834, 2594], [2596, 2596, 2618, 2618, 4686], [4688, 4688, 4721, 4721, 4898], [4900, 4900, 4934, 4934, 5112], [5114, 5114, 5136, 5136, 5350], [5352, 5352, 5373, 5373, 5583], [5585, 5585, 5618, 5618, 6316], [6318, 6318, 6364, 6364, 6870], [6872, 6872, 6909, 6909, 7133], [7135, 7135, 7173, 7173, 7387], [7389, 7389, 7437, 7437, 7633], [7635, 7635, 7670, 7670, 10781], [10783, 10783, 10839, 10839, 11796], [11798, 11798, 11831, 11831, 11874], [11876, 11876, 11922, 11922, 11969], [11971, 11971, 12004, 12004, 12031], [12033, 12033, 12075, 12075, 12126], [12128, 12128, 12194, 12194, 12294], [12296, 12296, 12353, 12353, 12436], [12438, 12438, 12468, 12468, 12526]], "test": "timeout"}
{"id": "ldScWc", "name": "xem test raymarching + DE", "author": "xem", "description": "-", "tags": ["raymarching", "distance", "estimation"], "likes": 3, "viewed": 134, "published": "Public", "date": "1494077084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Edit the numbers below and press play:\n\n// =========================================\n\n// Shape: 0 = sphere, 1 = box, 2 = torus,\n//        3 = union, 4 = substraction, 5 = intersection\nint shape = 0;\n\n// Infinite: 0 = no, 1 = yes\nint infinite = 1;\n\n// =========================================\n\n// Distance Estimation function\nfloat DE(vec3 p){\n    \n    // Infinite\n    if(infinite == 1){\n      p = mod(p, 2.0) - 0.5 * 2.0;\n    }\n    \n    // Scaling based on a cosinus wave\n    float scale = ((cos(iTime) + 2.5) / 2.7);\n    p = p / scale;\n    \n    float r;\n    \n    // Sphere\n    if(shape == 0){\n      r = length(p) - 0.7;\n    }\n    \n    // Box\n    if(shape == 1){\n      r = length(max(abs(p) - 0.5, 0.0));\n    }\n    \n    // Torus\n    if(shape == 2){\n      vec2 q = vec2(length(p.xy) - 0.5, p.z);\n      r = length(q)-0.1;\n    }\n    \n    // Union\n    if(shape == 3){\n      r = min(length(p) - 0.7, length(max(abs(p) - 0.55, 0.0)));\n    }\n    \n    // Substraction\n    if(shape == 4){\n      r = max(-(length(p) - 0.7), length(max(abs(p) - 0.55, 0.0)));\n    }\n    \n    // Intersection\n    if(shape == 5){\n      r = max(length(p) - 0.7, length(max(abs(p) - 0.5, 0.0)));\n    }\n    \n    // End of scale\n    return r * scale;\n}\n\n// Main function (called for each pixel)\n// Simple algorithm: all rays are parallel.\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n\t\n    // Adjust to canvas size\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Create a ray that goes forward\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    // The origin o is the camera's position\n    vec3 o;\n    \n    // Infinite: Make the camera move\n    if(infinite == 1){\n        o = vec3(0.0, iTime, iTime);\n    }\n    \n    // Not infinite: place the camera at (0,0,-2)\n    if(infinite == 0){\n        o = vec3(0.0, 0.0, -2.0);   \n    }\n    \n    // Raymarching loop\n    //float t = 0.0;\n    //for(int i = 0; i < 99; ++i){\n    //    t += DE(o + r * t) * 0.3;\n    //}\n    \n    float t = 0.0;\n    vec3 p;\n\n    for(int i = 0; i < 99; i++)\n    {\n        p = (o + r * t);// * 0.3;\n    \tfloat d = DE(p);\n        t += d;\n        //if(d < .01){\n        //    break;\n        //}\n    }\n    \n    // Fog\n    float fog = 1.0 / (1.0 + t * t * 0.3);\n    \n    // Color the current pixel according to the fog\n    fragColor = vec4(vec3(fog), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldScWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 329, 346, 367, 1221], [1223, 1308, 1358, 1389, 2370]], "test": "ok"}
{"id": "ldsfD8", "name": "Hyperbolic moving tesselation", "author": "felixbauckholt", "description": "Infinitely many circles move around in the hyperbolic plane.\n\nThis is a stripped-down and converted-to-Shadertoy-syntax version of a thing that I'm building here: https://github.com/felixbauckholt/hyperbolic_canvas", "tags": ["tesselation", "hyperbolic"], "likes": 24, "viewed": 632, "published": "Public API", "date": "1496083975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER_L 20\n\n#define number float\n#define complex highp vec2\n#define i_complex highp ivec2\n#define mobius highp ivec4\n\n\ncomplex thetransform[4];\ncomplex passive_t[4];\nhighp number PI=3.14159265359;\nhighp number l = 1./3.*sqrt(3.);\nhighp number halfl;\nhighp int dcount=0;\n\nhighp int sides = 4;\n\nhighp number t = 0.;\n\ncomplex conj(complex a) {\n\treturn vec2(a.x, -a.y);\n}\n\ncomplex mul(complex a, complex b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\ncomplex expo(complex a)\n{\n\tnumber l = exp(a.x);\n\treturn l*vec2(cos(a.y), sin(a.y));\n}\n\nhighp number abs_sq(complex xy)\n{\n\treturn xy.x*xy.x + xy.y*xy.y;\n}\n\ncomplex invert(complex xy)\n{\n\tnumber a = abs_sq(xy);\n\treturn (1./a)*conj(xy);\n}\n\n\ncomplex doshift(complex z, complex a) {\n\treturn mul(z - a, invert(vec2(1, 0) - mul(conj(a), z)));\n}\n\ncomplex transform(complex z) {\n\treturn mul(mul(z, thetransform[0]) + thetransform[1],\n\t    invert(mul(z, thetransform[2]) + thetransform[3]));\n}\n\nvec4 getpixel(complex pos) {\n\tpos = 1.05*pos;\n\tif (abs_sq(pos) >= 1.) return vec4(0.5, 0.5, 0.5, 0.5);\n\t//if (abs_sq(pos) <= 0.0002) return vec4(1, 0, 0, 1);\n\t//pos = transform(pos);\n\tint col = dcount;\n\n\tcomplex rv = expo(vec2(0, PI*2./float(sides)));\n\tcomplex dv = vec2(l, 0);\n\tint ctr = 0;\n\tint flipctr = 0;\n\tfor (int i=0; i<ITER_L; i++) {\n\t\tdv = mul(dv, rv);\n\t\tcomplex newpos = doshift(pos, dv);\n\t\tif (abs_sq(newpos) >= abs_sq(pos)) {\n\t\t\tctr++;\n\t\t\tif (ctr >= sides) break;\n\t\t} else {\n\t\t\tctr = 0;\n\t\t\tpos = -newpos;\n\t\t\tif (i%2 == 0) flipctr++;\n\t\t\tcol++;\n\t\t}\n\t}\n\n\tif ((col + flipctr) % 2 == 0) pos.x *= -1.;\n\tif (flipctr % 2 == 0) pos.y *= -1.;\n\n\tnumber shift = mod(t, 8.);\n\tif (shift >= 4.) {\n\t\tshift -= 4.;\n\t\t//pos = -pos;\n\t}\n\tif (shift >= 2.) {\n\t\tshift -= 2.;\n\t\tpos = vec2(pos.y, -pos.x);\n\t\tcol++;\n\t}\n    shift = 1. - cos(shift * PI * .5);\n\tshift -= 1.; shift *= halfl;\n\tpos = doshift(pos, vec2(halfl, 0));\n\tpos = doshift(pos, vec2(shift, 0));\n\tcomplex newpos = doshift(pos, vec2(-l, 0));\n\tif (abs_sq(newpos) < abs_sq(pos)) {\n\t\tcol++;\n\t\tpos = newpos;\n\t}\n    \n\tvec4 backgtiles = vec4(vec3(col%2), 1);\n    vec4 thecolor = vec4(0,0,0,1);\n\tif (abs_sq(pos) <= halfl*halfl*0.5) thecolor.rgb = vec3(1, 1, 1);\n\n\treturn 0.9*thecolor + 0.1*backgtiles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    halfl = (1. - sqrt(1. - l*l))/l;\n    pos.xy -= max(vec2(0), iResolution.xy - iResolution.yx)/2.;\n    pos = pos / min(iResolution.x, iResolution.y);\n    pos = pos*2. - vec2(1,1);\n\n    t = iTime * 1.4;\n\tfragColor = getpixel(pos);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 347, 347, 374], [376, 376, 411, 411, 465], [467, 467, 492, 492, 552], [622, 622, 650, 650, 701], [704, 704, 743, 743, 803], [805, 805, 835, 835, 949], [951, 951, 979, 979, 2197], [2199, 2199, 2250, 2250, 2484]], "test": "error"}
{"id": "ldsfR7", "name": "13/100", "author": "yahe", "description": "13/100", "tags": ["blob"], "likes": 0, "viewed": 397, "published": "Public API", "date": "1495502148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define E 40.0\n#define PI 3.1415926535897932384626433832795\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y ;\n\t\n    uv *= 2.;\n    \n    float n = noise(uv);\n    \n\tfloat t00 = sin (iTime);\n\tfloat t01 = sin (iTime+ 2.*PI/3.);\n\tfloat t02 = sin (iTime+4.*PI/3.);\n    \n\tfloat t10 = cos (iTime);\n\tfloat t11 = cos (iTime+2.*PI/3.);\n\tfloat t12 = cos (iTime+4.*PI/3.);\n    \n\tfloat t2 = sin (iTime/1.2);\n\tfloat t3 = cos (iTime/.8);\n\t\n\tvec2 p0 = vec2 (t00*t2, t10*t2) ;\n\tvec2 p1 = vec2 (t01*t2, t11*t2) ;\n\tvec2 p2 = vec2 (t02*t2, t12*t2) ;\n    \n    \n\tvec2 p3 = vec2 (t00*t3, t10*t3) ;\n\tvec2 p4 = vec2 (t01*t3, t11*t3) ;\n\tvec2 p5 = vec2 (t02*t3, t12*t3) ;\n\t\n\tfloat a = 1.0/distance (uv, p0);\n\tfloat b = 1.0/distance (uv, p1);\n\tfloat c = 1.0/distance (uv, p2);\n\tfloat d = 1.0/distance (uv, p3);\n\tfloat e = 1.0/distance (uv, p4);\n\tfloat f = 1.0/distance (uv, p5);\n\t\n\tfloat g = 1.0*n - pow (1.0/(a+b+c+d+e+f), E)*pow (15.0, E*0.7);\n\t\n\tvec4 col = vec4 (a*d, b*e, c*f, 1.0) * g;\n    \n    fragColor = mix(vec4(uv, 0.5+0.5*sin(iTime),1.0), col, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 88, 88, 206], [208, 208, 234, 234, 670], [672, 672, 729, 729, 1723]], "test": "ok"}
{"id": "ldsfWn", "name": "16/100", "author": "yahe", "description": "16/100", "tags": ["2d"], "likes": 3, "viewed": 374, "published": "Public API", "date": "1495758224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_PARTICLES 500.0\n#define GLOW 0.4\n\nvec3 Orb(vec2 uv, vec3 color, float radius, float offset)\n{        \n    float t = (iTime+200.)/5.;\n    vec2 position = vec2(sin(offset * t)*sin(offset * t)+ sin(iTime),\n                         cos(offset * t)*cos(offset * t)+ cos(iTime));\n    \n    if (sin(offset * t) < 0.&& cos(offset * t) > 0.) {\n     \n        position = vec2(-sin(offset * t)*sin(offset * t)+sin(iTime),\n                         cos(offset * t)*cos(offset * t)+cos(iTime));\n    } else if (cos(offset * t) < 0. && sin(offset * t) > 0.) {\n        \n        position = vec2(sin(offset * t)*sin(offset * t)+sin(iTime),\n                         -cos(offset * t)*cos(offset * t)+cos(iTime));\n        \n    } else if (cos(offset * t) < 0. && sin(offset * t) < 0.) {\n        \n        position = vec2(-sin(offset * t)*sin(offset * t)+sin(iTime),\n                         -cos(offset * t)*cos(offset * t)+cos(iTime));\n    }\n    \n    position *= sin((t + offset )*2. )* offset;\n    \n    radius = radius * sqrt(abs(position.x * position.y)) ;\n    \n    float dist = radius / distance(uv, position);\n    \n    return color * pow(dist, 1.0 / GLOW);\n}\n\n    vec2 rotate(vec2 v, float alpha)\n{\n\tfloat vx = v.x*cos(alpha)-v.y*sin(alpha);\n\tfloat vy = v.x*sin(alpha)+v.y*cos(alpha);\n\tv.x = vx;\n\tv.y = vy;\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel = vec3(0.0, 0.0, 0.0);\n   \tvec3 color = vec3(1.);\n    \n    float radius = 0.02;\n    \n    for\t(float i = 0.0; i < NUM_PARTICLES; i++) {\n        pixel += Orb(uv, color, radius,  i / NUM_PARTICLES);\n    //pixel += Orb(uv, color, radius, i / NUM_PARTICLES);\n    }\n\n    \n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 105, 105, 1149], [1155, 1155, 1189, 1189, 1310], [1312, 1312, 1369, 1369, 1765]], "test": "ok"}
{"id": "ldsfz8", "name": "6/100", "author": "yahe", "description": "6/100", "tags": ["wave", "circle", "ring"], "likes": 4, "viewed": 452, "published": "Public API", "date": "1494905851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\n#define W(x,k,c) A*sin(k*(X=x*2.-c*t))*exp(-X*X)\n\n#define C( r, R, t) smoothstep(t, 0., abs(R-(r)) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float A=3., X, y, Y=0.,  T = iTime,  t=mod(T,5.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    vec2 p = uv - vec2(0.5);\n    p.x *= iResolution.x / iResolution.y;\n\n    float pr = length(p);\n    float pa = atan(p.y, p.x);\n    \n    float radius;\n    \n    float o = 0.0;\n    \n\tfloat wave_width = 0.01;\n    \n    for( float i = 1.0 ; i < 10.0 ; i += 1.0 )\n    {\n        radius = .1 + i*i/500. + 0.01 * ( W( (cos(pa * i / 5.) + PI/2.), i, sqrt(i) ) );\n        \n    \to += C(radius + (sin(T)+1.)/10., pr, 8./iResolution.y);\n    }\n    \n    fragColor = mix( vec4(0.7, 0.85, 1. - 0.2*p.y, 0) * (1.0 - 0.1 * pr), o*.7 + p.xyyy * sin(T), o );\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float A=3., X, y, Y=0.,  T = iTime,  t=mod(T,5.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    vec2 p = uv - vec2(0.5);\n    p.x *= iResolution.x / iResolution.y;\n\n    float pr = length(p);\n    float pa = atan(p.y, p.x);\n    \n    float radius;\n    \n    float o = 0.0;\n    \n\tfloat wave_width = 0.01;\n    \n    for( float i = 1.0 ; i < 10.0 ; i += 1.0 )\n    {\n        radius = .1 + i*i/1000. + 0.05 * ( W( (cos(pa * i / 2.) + PI/2.), i, sqrt(i) ) );\n        \n    \to += C(radius + (sin(T*.3)+1.)/10., pr, 8./iResolution.y);\n    }\n    \n    fragColor = mix( vec4(0.5, 0.65*sin(T*.2), .6 - 0.3*p.y, 0) * (1.0 - 0.1 * pr), o*.8 + p.xyyy * sin(T), -o );\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 194, 194, 841]], "test": "ok"}
{"id": "ldSyWc", "name": "MY EYES ARE BLEEDING", "author": "slerpy", "description": "AAAAAAAAAAAHHHH!!!!11!1!1!!!!\nTURN IT OFF!!!!!11!!1", "tags": ["2d"], "likes": 4, "viewed": 90, "published": "Public", "date": "1494066563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 p = vec2(sin(iTime),cos(iTime));\n    float s = length(u+p)+length(u-p);\n\tfragColor = vec4(sin(100.*iTime*s));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldSyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 236]], "test": "ok"}
{"id": "ldXBDH", "name": "Collatz Fractal, Sort of", "author": "DonKarlssonSan", "description": "Collatz", "tags": ["fractal", "collatz"], "likes": 1, "viewed": 105, "published": "Public", "date": "1495928165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n\n#define PI 3.14159265\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x,-a.y)\n#define cx_arg(a) atan2(a.y,a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = length(a);\n    float ipart = atan(a.y, a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) {\n    return cx_mul(z, z) + c;\n}\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\n\n////////////////////////////////////////////////////////////\n// end Complex Number math by julesb\n////////////////////////////////////////////////////////////\n\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://github.com/msfeldstein/glsl-map/blob/master/index.glsl\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n    return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n// My own additions to complex number math\n#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)\n#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)\n#define cx_abs(a) length(a)\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.y / a.x);\n    float r = length(a);\n    return vec2(r, phi); \n}\n\nvec3 cx_exp(vec2 z) { \n    return vec3(exp(z.x), vec2(cos(z.y), sin(z.y)));\n}\n\nvec2 cx_exp_jk(vec2 z) { \n    return exp(z.x) * vec2(vec2(cos(z.y), sin(z.y)));\n}\n    \n// Complex power\n// Let z = r(cos θ + i sin θ)\n// Then z^n = r^n (cos nθ + i sin nθ)\nvec2 cx_pow(vec2 a, float n) {\n    float angle = atan(a.y, a.x);\n    float r = length(a);\n    float real = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(real, im);\n}\n   \nvec2 f(vec2 z) {\n\treturn (7.0 * z + 2.0 - cx_mul(cx_cos(PI * z), (5.0 * z + 2.0))) / 4.0;\n}\n   \n// Collatz and Self Similarity by Inigo Quilez\n// https://www.youtube.com/watch?v=GJDz4kQqTV4\nvec2 f3(vec2 z) {\n    vec2 a = 7.0 * z + 2.0;\n   \n    //vec3 e = cx_exp(PI * z);\n\t//vec2 b = e.x * cx_mul(e.yz, (5.0 * z + 2.0));\n    \n    vec2 e = cx_exp_jk(PI * z);\n\tvec2 b = cx_mul(e, (5.0 * z + 2.0));\n    \n    return (a - b) / 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xy;\n    float zoom = (sin(iTime / 2.0) * 0.5 + 0.5001) * 100.0;\n    zoom *= zoom;\n    vec2 z = vec2(-uv.y, uv.x) * 1.0 / zoom;\n\tint iteration = 0;\n    const int max_iteration = 100;\n    float xtemp;\n    // while loops not supported on iPhone!!\n    for(int i = 0; i < max_iteration; i++) {\n        z = f3(z);\n        iteration = i;\n        if(length(z) > 1000000.0) break;\n    }\n    float h = float(iteration)/float(max_iteration);\n    vec3 hsv = vec3(h*2.0, 1.0, 1.0);\n    vec3 rgb = hsv2rgb(hsv);\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 516, 516, 682], [684, 684, 705, 705, 743], [745, 745, 766, 766, 908], [910, 910, 934, 934, 1029], [1031, 1031, 1066, 1066, 1109], [1111, 1111, 1153, 1153, 1184], [1186, 1186, 1221, 1221, 1268], [1432, 1531, 1553, 1553, 1722], [1724, 1790, 1868, 1868, 1945], [2114, 2114, 2140, 2140, 2226], [2228, 2228, 2249, 2249, 2305], [2307, 2307, 2331, 2331, 2388], [2394, 2483, 2513, 2513, 2685], [2690, 2690, 2706, 2706, 2781], [2786, 2880, 2897, 2897, 3117], [3119, 3119, 3174, 3174, 3769]], "test": "ok"}
{"id": "ldXBDn", "name": "mix 16 textures branchless", "author": "ollj", "description": "mixing 16*vec4, down to 1*vec4, by a pointer, branchless.", "tags": ["texture", "demo", "mis", "branchless", "step", "pipeline"], "likes": 1, "viewed": 502, "published": "Public API", "date": "1495618447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self: https://www.shadertoy.com/view/ldXBDn\n\n#define time iTime\n//above is for fancy movement, below is static and focusing on what matters:\n//#define time 0.\n//being too lazy to rewind!\n\n//set degree of theponynomial that is used to blend between 2 colors.\n//higher polynomials than 0 are \"experimental and not good.\n#define poninomial 2\n//#define poninomial 0, simple step() \n//#define poninomial 1, I failed to get linear interpolation to work as intended.\n//#define poninomial 2, smoothstep() with an ugly but expected modulo discontinuity at 0\n\n//This is about mixing 16 textures down to 1 texture, \n//possibly more efficiently in the long run.\n\n//This is more a proof of concept with potential that I may not see now.\n//I am not sure if this speeds up things in the long run or not.\n//I know this is just one of many solutions and my sorting is not ideal.\n\n//The issue:\n//I see a function a lot that selects one of 2 vec4\n//...depending on which of their .x or .y or .z or .w values is smaller:\nvec4 select(vec4 a,vec4 b){if (a.w<b.w)return a;return b;}\n/*\nIs a common z-buffer branch, used when you only return one of two .xyz textures, \n...depending on their .w distance.\n\nbut your if() branch will likely be compiled into a jump() instruction \n...and every jump() instruction halts (or interrupts) a pipeline.\nModern hardware increasingly supports longer pipelines \n...that perform as fast as its slowest subroutine, \n...and the performance culpit (even for the most dedicated alu)\n...is usually pow(a,b)==exp(log(a)*b)\nA jump() \"breaks\" a pipeline in 2 shorter pipelines.\nA jump() can make sense to skip a slow pipeline, \n...but that diminishes over time with hardware being more in support of long pipellines.\n*/\n//A branchless vesion of select() is:\nvec4 selectBranchless(vec4 a,vec4 b){return mix(a,b,step(a.w,b.w));}\n//rather than worring about order or sign, within the step() part, I just fix it by trial.\n/*\nyou can substitute step(a.x,a.y)==step(a.w-b.w,0), \n...and make its inherent differential apparent.\n\nRenaming selectBranchless to bm() and make the step() part of it less dependent,\nthe fun part is the option of doing a (base2) recursion of bm*(), as below;\n*/\n\n//concept, to alias a small function, to swap a function in multiple places.\n#if (poninomial==0)\n float mt(float a){return step(a,0.);}//do step interpolation. 0deg polynomial\n#elif (poninomial==1)\n float mt(float a){return abs(fract(a/16.)-.5)*4.;}//do linear interpolation. 1deg polynomial\n //this totally fails to be usefull to me.\n //i wanted it to be more like fract?\n //return fract(a/16.); sure looks \"interestring\" somehow\n#else\n float mt(float a){float blur=acos(1.)-cos(time*(sqrt(5.)*.5+.5))*.5+.5;\n  return smoothstep(+blur,-blur,a);}//do cubic interpolation. 2deg polynomial\n  //yeah , smoothstep() is a 3rd deg polynomial, but only x*x*x and x*x are nonZero.\n#endif\n//the other 2 above are not too usefull for now, just concepts for extensions:\n\n//https://en.wikipedia.org/wiki/Smoothstep\n//returns binomial coefficient without explicit factorials, which can't be used with negative integers\nfloat pascalTriangle(float a,int b){float r=1.;for(int i=0;i<b; i++){\n float f=float(i);r *=(a-f)/(f+1.);}return r;}\n//Generalized smoothstep\nfloat smoothstepN(float x,int N){x=clamp(x,0.,1.);float result=0.;float M=float(N);\n for(int n=0;n<=N;n++){float m=float(n);\n   result +=(pascalTriangle(-M-1., n)*pascalTriangle(2.*M+1., N-n)*pow(x,M+m+1.));\n }return result;}\n\n\n\n\n//exponential recursion makes things exponentially repetitive:\n#define bm0i float a,vec4 b,vec4 c\n#define bm1i bm0i ,vec4 d,vec4 e\n#define bm2i bm1i ,vec4 f,vec4 g,vec4 h,vec4 i\n#define bm3i bm2i ,vec4 j,vec4 k,vec4 l,vec4 m,vec4 n,vec4 o,vec4 p,vec4 q\n//bmN() ==Boolean_Mix_N== branchless mix of N vec4:, using step() instead of a boolean branch. \n//N=base2_exponent of number-of_mixed_colors.\nvec4 bm0(bm0i){return mix(b                        ,c                        ,mt(a));}//depending on [a], return one of  2 vec4 [b,c]\nvec4 bm1(bm1i){return mix(bm0(a-2.,b,c            ),bm0(a+2.,d,e            ),mt(a));}//depending on [a], return one of  4 vec4 [b,c,d,e]\nvec4 bm2(bm2i){return mix(bm1(a-4.,b,c,d,e        ),bm1(a+4.,f,g,h,i        ),mt(a));}//depending on [a], return one of  8 vec4 [b,..,i]\nvec4 bm3(bm3i){return mix(bm2(a-8.,b,c,d,e,f,g,h,i),bm2(a+8.,j,k,l,m,n,o,p,q),mt(a));}//depending on [a], return one of 16 vec4 [b,..,q]\n//bm1() does 2*bm0()                           (             3*mt(),            1*sub).  \n//bm2() does 2*bm1(),does 4*bm0()              (             7*mt(),            3*sub). \n//bm3() does 2*bm1(),does 4*bm0(),does 8*bm0() (            15*mt(),            7*sub).\n//bmN() does                                   ((pow(2,N+1)-1)*mt(), (pow(2,N)-1)*sub).\n\n//For when you really do not trust branches and have a long array of vec4 to select from, \n//...but do not want to use arrays.\n//branchless, because you are in a deep subroutine that gets iterated over quite a lot \n//...within a pipeline and you do not want to branch (jump) the pipeline.\n//vec4, because you realized that mat4 is 6x as efficient as float[16], \n//...because arrays are very memory inefficient in webGL.\n\n//The above ordering of variables [b..q] and the a-N a+N offsets are VERY arbituary,\n//...just one of many was to \"sort\" things\"\n//...and likely not too intuitive (unsorted) in its results, \n//...but it LOOKS simple and computes fast.\n//\n//the problem with the above ordering is \n//...how bm3() on its own appears to \"shuffle\" the colors of bmDemo():\n//...which is adjusted by a=mod(a,32.);a-=16.;a=-a; within bmDemo()\n//... which is possibly not the best workaround for sorting this out.\n//\n//You have fun SORTING that one out, by swapping parameters of bm3() and its subroutines.\n//because I am fine with this \"inefficient solution\" as a proof of concept.\n//any any utility (including optimization) is up to you!\n\nvec4 bmDemo(vec2 u,float a){\n //16 textures [b...q] are \"procedural\", and NOT wasting memory by being in an array.\n //16 textures are close to being the \"good old 4bit=16colors palette\".\n vec4 \n b=vec4(0,0,0,1)+texture(iChannel0,u),//+vec4(0,0,0,1)\n c=vec4(0,0,0,1)+texture(iChannel1,u),//+vec4(0,0,1,1)\n d=vec4(0,0,0,1)+texture(iChannel2,u),//+vec4(0,1,0,1)\n e=vec4(0,0,0,1)+texture(iChannel3,u);//+vec4(0,1,1,1)\n //or they could be const (or even global), a bit pointless, but can compile faster.\n const vec4\n f=vec4(1,0,0,1),\n g=vec4(1,0,1,1),\n h=vec4(1,1,0,1),//yellow\n i=vec4(1,1,1,1),//white\n j=vec4(.8,.3,.0,1),//brown \"=yellow.dark\"\n k=vec4(.0,.0,.5,1),//blue.dark\n l=vec4(.0,.5,.0,1),\n m=vec4(.0,.5,.5,1),\n n=vec4(.5,.0,.0,1),\n o=vec4(.5,.0,.5,1),\n p=vec4(.5,.5,.0,1),\n q=vec4(.5,.5,.5,1); \n a=abs(a);//otional abs (makes no difference due to how this demo is used)\n a=mod(a,32.);//likely optional modulo.\n //a=floor(a);//very optional flooring\n a-=16.;//the offset sadly seems essential;\n a=-a;//sort from left to right, except that i and j are swapped.\n //return bm0(a,b,c);\n //return bm1(a,b,c,d,e);\n //return bm2(a,b,c,d,e,f,g,h,j,i);\n return bm3(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);//branchlessly select between one of 16 textures, set by a;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n U=U/iResolution.xy;//u is needed for texture() coordinates.\n float u=U.x;//u sets what \"testure\" of 16 tetures will be shown.\n u*=32.+sin(time)*9.;//scale slice width\n O=bmDemo(U,u+time);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[865, 1003, 1030, 1030, 1061], [1062, 1764, 1801, 1801, 1832], [2949, 3095, 3131, 3131, 3211], [3212, 3237, 3270, 3270, 3462], [3720, 3862, 3877, 3877, 3948], [3948, 3996, 4011, 4011, 4082], [4082, 4134, 4149, 4149, 4220], [4220, 4271, 4286, 4286, 4357], [5901, 5901, 5929, 6087, 7157], [7159, 7159, 7199, 7199, 7390]], "test": "error"}
{"id": "ldXBRH", "name": "Boreal Spring", "author": "ocb", "description": "Ok, guys... hummm, I know, I am a little bit late.\n\nPlease use mouse to look around.\nAdvised music for this shader: Carbon Based Lifeforms", "tags": ["3d", "raytracing", "raymarching", "transparency", "christmas", "particles", "aurora", "greatings"], "likes": 15, "viewed": 1446, "published": "Public API", "date": "1494972118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: ocb\n// Title: Boreal Spring\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// the main process is divided in several parts\n// 1- find the outbound of a ray: Sky or Ground\n// 2- the scenery is divided in sectors (or cells)\n//    the getNextCell() return each cells crossed by ray\n//    so only few object are consider for raytracing\n//    this allow to maintain good perfos with thousands of trees\n//    2D demo + explaination of getNextCell() here: https://www.shadertoy.com/view/XdffRN\n// 3- finally raytrace fairy lights wich are not linked to a cell\n//    fairy lights are raytraced twice for transparency purpose.\n\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000000.\n\n#define maxTreeH 130.\n#define maxHill 300.\n#define cellH 430. \t/*treeH + maxHill*/\n#define cellD 100.\n#define maxCell 200\n#define TREE_DENSITY (abs(fract(cell.x/10.)-.5)*abs(fract(cell.y/10.)-.5))*10.\n\n// object name\n#define GND -1\n#define SKY -1000\n\n#define REDL 1\n#define MAGL 2\n#define BLUL 3\n#define YELL 4\n\n#define COTTA 10\n#define WALL 11\n#define ROOF 12\n\n#define TREE 20\n#define CHRISTREE 21\n\n#define SNOWMAN 40\n#define BELLY 41\n#define HEAD 42\n#define HAT 43\n#define NOZ 44\n\n// ground parameters precalculated for perfo\n#define SHIFT 0.\n#define AMP 1.\n#define P1 .003\n#define P2 .0039999  /* P1*1.3333 */\n#define P3 .0059661  /* P1*1.9887 */\n\n#define DP2 .0039999 /*.00199995  /* AMP * P2 */\n#define DP3 .0059661 /*.00298305  /* AMP * P3 */\n\n#define NRM 4.   /* (1. + AMP + SHIFT) * 2. */\n\n\nint hitObj = SKY;\nfloat T = INFINI;\n\n// object global\n// Camera pos\nvec3 camPos;\n// Ambiance light direction\nvec3 lightRay;\n// lights\nvec3 redO, magO, bluO, yelO;\nfloat redR, magR, bluR, yelR;\n// cotta\nvec3 wallO, roofO;\nfloat wallR, roofR, roofH;\nvec2 cottaCell;\n\n// snowpeople\nvec3 belO, hedO, hatO, nozO;\nfloat belR, hedR, hatH, hatR, nozH, nozR;\nvec2 snowmanCell;\n\n//tree\nvec3 treeO;\nfloat treeR, treeH;\n\n//Christmas tree\nvec3 CtreeO;\nfloat CtreeR, CtreeH;\nvec2 CtreeCell;\n\n\n\nfloat rand1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat rand2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\n\n// ground height\nfloat ground(in vec2 p){\n    float len = max(1.,0.0001*length(p));\n    float hx = max(0., (sin(P1*(p.x+p.y)) + AMP*sin(P2*p.x+PIdiv2) + SHIFT) );\n    float hy = max(0., (sin(P1*(p.y+.5*p.x)) + AMP*sin(P3*p.y+PIdiv2) + SHIFT));\n    return maxHill*(hx+hy)/NRM/len;\n}\n\n// returning ground normal for a position p\n// derivation of the ground function\nvec3 getGndNormal(in vec2 p, in float h) {\n    if(h<.001) return vec3(0.,1.,0.);\n    else{\n        float len = max(1.,0.0005*length(p));\n        float dx = maxHill*( P1*cos(P1*(p.x+p.y)) + DP2*cos(P2*p.x+PIdiv2) )/NRM;\n        float dy = maxHill*( P1*cos(P1*(p.y+.5*p.x)) + DP3*cos(P3*p.y+PIdiv2) )/NRM;\n        return normalize(cross( vec3(1.,dx/len,0.), vec3(0.,dy/len,1.) ));\t\t// divided by len: We may call that \"normal fog\"\n    }\n}\n\n//************ Ray marching to find ground impact ********\nfloat gndRayTrace(in vec3 p, in vec3 ray){\n    float t = 0.;\n    float contact = .5;\n    float dh = p.y - ground(p.xz);\n    if(dh<contact) return .0001;\n    for(int i=0; i<100;i++){\n        t += dh;\t\t\t// t = dh/length(ray) but ray normalized\n        p += dh*ray;\n        if(p.y >= cellH && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y - ground(p.xz);\n        if(abs(dh)<contact)break;\n    }\n    return t;\n}\n\n//********** raytracing for simple primitives *********\nfloat sfcImpact(in vec3 p, in vec3 ray, float h){\n    float t = (h-p.y)/ray.y;\n    if (t <= 0.001) t = INFINI;\n    return t;\n}\n\nfloat sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 ray){\n    float t = INFINI;\n    vec3 d = sphO - pos;\n    float dmin = 0.;\n    float b = dot(d, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float a = dot(ray,ray);\n        float c = dot(d,d) - sphR*sphR;\n    \tfloat disc = b*b - c;\n    \tif (disc >= 0.){\n        \tfloat sqdisc = sqrt(disc);\n            float t1= (b + sqdisc)/a;\n            float t2= (b - sqdisc)/a;\n        \tt = min(t1,t2) ;\n        \tif (t <= 0.001){\n                t = max(t1,t2);\n                if (t <= 0.001) t = INFINI;\n            } \n        }\n    }\n    return t;\n}\n\nfloat coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 ray){\n    float t = INFINI, dmin=0.;\n    vec3 d = coneO - pos;\n    float Dy = coneH + d.y;\n    float r2 = coneR*coneR/(coneH*coneH);\n    float b = dot(d.xz, ray.xz);\n    \n    float a = dot(ray.xz,ray.xz);\n    float c = dot(d.xz,d.xz) - r2*Dy*Dy;\n    float c1 = -b + r2*Dy*ray.y;\n    float disc = c1*c1 - (a - r2*ray.y*ray.y) * c;\n    if (disc >= 0.){\n        float sqdis = sqrt(disc);\n        float t1 = (-c1 + sqdis)/(a - r2*ray.y*ray.y);\n        float t2 = (-c1 - sqdis)/(a - r2*ray.y*ray.y);\n\n        float ofc = -ray.y*t1 + Dy;\n        t1 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t1 <= 0.001) t1 = INFINI;\n\n        ofc = -ray.y*t2 + Dy;\n        t2 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t2 <= 0.001) t2 = INFINI;\n\n        t = min(t1,t2);\n    }\n    \n\treturn t;\n}\n\n\n//******* TEXTURES AND COLORS *********\n\nvec3 skyGlow(in vec3 ray){\n    if(ray.y>=0.)return vec3(.5*max(ray.x+.7,0.)*(.8-max(0.,ray.y)), .35,.4)*(1.-ray.y)*(ray.x+1.5)*.4;\n    else return vec3(0.);\n}\n\nvec3 snowColor(in vec3 pos){\n    vec3 col = vec3(.7,.7,.75)+vec3(.05,.05,.05)*rand2(floor(pos.xz*10.), 0.);\n    col += vec3(1.,.7,.8)*step(.997,rand2 (floor(pos.xz*20.), 0.));\n    return col;\n}\n\n\n// Ctree light on ground \nvec3 CtreeColor(in vec3 pos){\n    return .5*vec3(.5,.5,1.)*min(1.,30./length(pos-CtreeO-vec3(0.,CtreeH/2.,0.)));\n}\n\n// fairylight on ground\nvec3 lightColor(in vec3 pos){\n    vec3 color = vec3(0.);\n    color.r += min(1.,5./length(pos-redO));\n    color.rb += min(1.,5./length(pos-magO));\n    color.b += min(1.,10./length(pos-bluO));\n    color.rg += min(1.,3./length(pos-yelO));\n    return color;\n}\n\n// cotta window\nvec3 window(in float angl, in vec3 pos){\n    float dh = pos.y-wallO.y-.25*wallR;\n    float an = fract(3.*angl/PI)-.5;\n    return vec3(1.,.5,.0)*(smoothstep(-.9,-.8,-abs(abs(dh)-1.))*( smoothstep(-.04,-.03,-abs(abs(an)-.04)))+.2*(1.-smoothstep(.0,.4,abs(an))));\n    \n}\n\n// window light on ground\nvec3 winLitcolor(vec3 pos){\n    float r = length(pos.xz-wallO.xz)*.01;\n    if (r<2.5){\n    \tfloat a= fract(3.*atan(pos.z- wallO.z,pos.x - wallO.x)/PI)-.5;\n    \treturn vec3(1.,.5,.0)*.3*smoothstep(-2.,-.0,-r)*smoothstep(.1,.8,r)*smoothstep(-.5,-.0,-abs(a))*smoothstep(-60.,.0,-pos.y+wallO.y);\n    }\n    else return vec3(0.);\n}\n\nvec3 stars(in float a,in vec3 ray){\n    vec2 star = vec2(a,ray.y*.7)*30.;\n    vec2 p = floor(star);\n    if(rand2(p,0.)>.97){\n        vec2 f = fract(star)-.5;\n    \treturn  vec3(.7*smoothstep(0.,.3,abs(fract(iTime*.3+3.*a)-.5))*ray.y * (smoothstep(-.01,-.0,-abs(f.x*f.y))+max(0.,.1/length(f)-.2)));\n    }\n\telse return vec3(0.);\n}\n\n// northern light\nvec3 boreal(in float a,in vec3 ray){\n    vec3 col = vec3(0.);\n    float b = .03*(asin(clamp(6.*a+12.,-1.,1.))+PIdiv2);\n    float c = .2*(asin(clamp(-.2*a*abs(a)-1.67222,-1.,1.))+2.042);\n    float d = .05*(a+1.)*(asin(clamp(a-1.,-1.,1.))+PIdiv2);\n    float rebord = smoothstep(1.83333,1.9,-a);\n    float rebord2 = smoothstep(-2.,-1.9,-a);\n    float var1 = (sin(1./(a+2.2)+a*30. + iTime)+1.)/4.+.5;\n    float var2 = (sin(a*10. - iTime)+1.)/4.+.5;\n    float var3 = (sin(1./(a+.04)+a*10. + iTime)+1.)/4.+.5;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var1*smoothstep(b,b+.5*ray.y,ray.y)*smoothstep(-b-.9*ray.y,-b,-ray.y)*rebord;\n    col += 1.*vec3(.6-ray.y,.5*ray.y,0.15)*var2*smoothstep(c,c+.07,ray.y)*smoothstep(-c-.5,-c,-ray.y)*rebord;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var3*smoothstep(d,d+.5*ray.y,ray.y)*smoothstep(-d-.9*ray.y,-d,-ray.y)*rebord2;\n\treturn col;\n}\n\nvec3 skyColor(in vec3 ray){\n    float a = atan(ray.z,ray.x);\n    vec3 color = skyGlow(ray);\n    color += stars(a,ray);\n    color += boreal(a, ray);\n    return color;\n}\n\nvec3 groundColor(in vec3 pos, in vec3 ray, in vec3 norm){\n    float len = length(camPos.xz-pos.xz);\n    float dir = max(0.,dot(-lightRay,norm));\n    vec3 color = snowColor(pos*.5)*(.9*dir+.1);\n    color *= .5+.5*pos.y/maxHill;\n    ray = reflect(ray, norm);\n    ray.y = max(0.,ray.y);\n    color = mix(.9*skyGlow(ray),color,.7);\n    color *= 1.-atan(len/10000.)/PIdiv2;\n    color += vec3(.4*max(ray.x+.7,0.), .35,.4)*(ray.x+1.5)*.4*atan(len/20000.)/PIdiv2;\n    color += .8*lightColor(pos);\n    color += winLitcolor(pos);\n    color += CtreeColor(pos);\n\treturn color;\n}\n\n//************* COTTA FUNCTIONS ************\nvec3 roofColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float an = atan((p.z - roofO.z),(p.x - roofO.x));\n    float lim = 4.*(.2*sin(6.*an)+1.1);\n    vec3 tile = (smoothstep(.0,.9, abs(fract(p.y)-.5))+smoothstep(0.,.7,abs(fract(20.*an+step(1., mod(p.y,2.0)) * 0.5)-.5)))*vec3(0.380,0.370,0.207);\n    vec3 color = step(-p.y+roofO.y,-lim)*snowColor(p*5.) + step(p.y-roofO.y,lim)*tile;\n    float h = ground(p.xz);\n    vec3 gndNorm = getGndNormal(p.xz, h);\n    color *= (dot(gndNorm, -lightRay)+.7)/1.;\n    color *= ((dot(lightRay,norm)+1.)*.3 + .05);\n    color += .8*lightColor(p);\n    return color;\n}\n\nvec3 wallColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float angl = atan((p.z - wallO.z),(p.x - wallO.x));\n    float lim =  1.3*(sin(2.*angl)+1.5);\n    vec3 tile = (smoothstep(0.,.5,abs(fract(p.y)-.5))+smoothstep(0.,.1,abs(fract(2.*angl)-.5)))*vec3(0.320,0.296,0.225);\n    vec3 color = step(p.y,lim)*snowColor(p*5.) + step(-p.y,-lim)*tile;\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += window(angl, p);\n    color += .8*lightColor(p);\n    return color;\n}\n\nbool cottaImpact(in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    float tr = coneImpact(p, roofO, roofH, roofR, ray);\n    float tw = sphereImpact(p, wallO, wallR, ray);\n    float t = min(tr,tw);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        if(t == tr){\n            hitObj = ROOF; \n            vec3 norm = normalize(vec3(p.x - roofO.x,roofR*roofR/(roofH*roofH)*(roofH + roofO.y - p.y),p.z-roofO.z));\n            color += roofColor(p, ray, norm);\n        }\n        else{\n            hitObj = WALL;\n            vec3 norm = normalize(p-wallO);\n            color += wallColor(p, ray, norm);\n        }\n    }\n    \n    // twinkeling garland \n    float R = roofR+.5, H = 1.;\n    for(int i = 0; i<47; i++){\n        float fi = float(i);\n        float v = fi/50.;\n        float dh = H*(1.+sin(6.*v*TwoPI));        \n        vec3 bulb = vec3(roofO.x + R*sin(v*TwoPI), roofO.y+dh-.5 ,roofO.z + R*cos(v*TwoPI));\n\t\tfloat d = length(cross((bulb-p), ray));\t\t// no bulbs impact. Distance ray to point for halo effect\n        if (!(impact && dot(bulb-p,ray)>=0.)){\t\t// No bulbs behind object\n            color.rgb += max(0.,.15/d-.005)*(sin(2.*iTime-fi)+1.000)/2.;\n            color.r += max(0.,.15/d-.005)*(sin(2.*iTime+fi)+1.)/2.;\n        }\n    }\n    return impact;\n}\n\n//***************** SNOWMAN FUNTIONS *******************\nvec3 bellyColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 belly){\n    vec3 color = snowColor(norm*30.);\n    color -= vec3(0.016,0.515,0.525)*step(.1,abs(p.z-belO.z));\n    color -= vec3(0.016,0.515,0.525)*step(-.1,-abs(p.z-belO.z))*step(-belO.x,-p.x);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color *= (1.-step(-.5,-abs(p.z-belly.z))*step(0.,p.x-belly.x)* step(.9, fract((p.y-belly.y)*.4)));\n    color += lightColor(p);\n    return color;\n}\n\nvec3 headColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 head){\n    vec3 color = snowColor(norm*30.);\n    color -= vec3(0.016,0.515,0.525)*step(-hedO.y+.4*exp(p.x-hedO.x-2.),-p.y);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,1.5)-p.yz)))*step(hedO.x,p.x);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,-1.5)-p.yz)))*step(hedO.x,p.x);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 hatColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = snowColor(p*5.);\n    color -= step(.5,fract(p.y*.4))*vec3(0.016,0.515,0.525);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 nozColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = vec3(0.475,0.250,0.002);\n    color *= ((dot(vec3(0.,1.,0.),norm)+1.)*.4 + .2);\n    color += lightColor(p);\n    return color;\n}\n\n\nbool caracterImpact(in vec3 p, in vec3 ray,inout vec3 color){\n    bool impact = false;\n    float tbel = sphereImpact(p, belO, belR, ray);\n    float thed = sphereImpact(p, hedO, hedR, ray);\n    float that = coneImpact(p, hatO, hatH, hatR, ray);\n    float tnoz = coneImpact(vec3(-p.y,p.x,p.z), vec3(-nozO.y,nozO.x,nozO.z), nozH, nozR, vec3(-ray.y,ray.x,ray.z));\n    float t = min(min(min(tbel,thed),that),tnoz);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        hitObj = SNOWMAN;\n        if(t == tbel){\n            vec3 norm = normalize(p - belO);\n            color += bellyColor(p, ray, norm, belO);\n        }\n        else if(t == thed){\n            vec3 norm = normalize(p - hedO);\n            color += headColor(p, ray, norm, hedO);\n        }\n        else if(t == that){\n            vec3 norm;\n            norm.xz = p.xz - hatO.xz;\t// simplified norm for hat. (perfo)\n            norm.y = 0.;\n            norm = normalize(norm);\n            color += hatColor(p, ray, norm);\n        }\n        else{\n            vec3 norm;\n            norm.yz = p.yz - nozO.yz;\n            norm.x = 0.;\n            norm = normalize(norm);\n            color += nozColor(p, ray, norm);\n        }\n    }\n    return impact;\n}\n\n\n//**************** TREE FUNCTIONS *********************\nvec3 treeColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float lim = 40.*(.05*sin(.6*p.x)+.5);\n    vec3 color = step(-p.y+treeO.y,-lim)*snowColor(fract(p*5.)) + step(p.y-treeO.y,lim)*vec3(0.000,0.320,0.317);\n    color *= ((dot(lightRay,norm)+1.)*.3 + .05);\n    vec3 r = reflect(ray,norm);\n    r.y = abs(r.y);\n    color += step(-p.y+treeO.y,-lim)*.7*skyGlow(r)*(treeO.y+10.)/maxHill;\n    color *= .6+.4*p.y/maxHill;\n    color += .8*lightColor(p);\n    color += 1.9*winLitcolor(p)*max(0.,dot(-normalize(p-wallO),norm));\n    color *= 1.-atan(length(camPos-p)/5000.)/PI*2.;\n\treturn color;\n}\n\n// create tree, if there is one (treeDensity)\nbool getTree(in vec2 cell,inout vec3 treeO, inout float treeH, inout float treeR){\n    bool treeOk = bool(step(TREE_DENSITY,rand2(cell*1.331,1.)));\t\t\t// check if object, depending cell coords\n        if (treeOk){ \n            treeH = (.5*rand2(cell*3.86,0.)+.5)*maxTreeH;\n            treeR = .15*treeH;\n            float lim = (1.-2.*treeR/cellD);\n            treeO = vec3(lim*(rand2(cell*2.23,0.) - 0.5) + cell.x, 0., lim*(rand2(cell*1.41,0.) -0.5)  + cell.y) *cellD;\n            treeO.y += ground(treeO.xz)-10.;\n        }\n    return treeOk;\n}\n\nbool treeImpact(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    bool tree = getTree(cell,treeO, treeH, treeR);\n    if(tree){\n        float t = coneImpact(p, treeO, treeH, treeR, ray);\n        if(t<T){\n            T=t;\n            hitObj = TREE;\n            impact = true;\n            p += t*ray;\n            vec3 norm = normalize(vec3(p.x - treeO.x,treeR*treeR/(treeH*treeH)*(treeH + treeO.y - p.y),p.z-treeO.z));\n            color += treeColor(p, ray, norm);\n        }\n    }\n    \n    return impact;\n}\n\n//************** Christmas tree *******************\nbool CtreeImpact(in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    \n    float t = coneImpact(p, CtreeO, CtreeH, CtreeR, ray);\n        if(t<T){\n            T=t;\n            hitObj = CHRISTREE;\n            impact = true;\n            p += t*ray;\n            vec3 norm = normalize(vec3(p.x - CtreeO.x,CtreeR*CtreeR/(CtreeH*CtreeH)*(CtreeH + CtreeO.y - p.y),p.z-CtreeO.z));\n            treeO.y = CtreeO.y;\n            color += treeColor(p, ray, norm);\n        }\n    \n    // twinkeling garland\n    float R = CtreeR+1., H = CtreeH+5.;\n    for(int i = 0; i<47; i++){\n        float fi = float(i);\n        float v = rand1(fi*1.87);\n        float dh = H*fract(fi*.02);\n        float r = R*(H-dh)/H;\n        vec3 bulb = vec3(CtreeO.x + r*sin(fi*v), CtreeO.y+dh+5. ,CtreeO.z + r*cos(fi*v));\n\t\tfloat d = length(cross((bulb-p), ray));\t\t\t// no bulbs impact. Distance ray to point for halo effect\n        if (!(impact && dot(bulb-p,ray)>=0.)){\t\t\t// hidden face\n            color.rgb += max(0.,.15/d-.005)*(sin(2.*iTime-fi)+1.)/2.;\n            color.b += max(0.,.15/d-.005)*(sin(2.*iTime+fi)+1.)/2.;\n            \n        }\n        if(impact){\n            float c = .05/length(p-bulb);\n            color += vec3(c,c,4.*c);\n        }\n    }\n\n    return impact;\n}\n\n\n//********************** FAIRY LIGHTS FUNCTIONS ******************\nvec3 fairyReflect(in vec3 ray,in vec3 norm){\n    vec3 r = reflect(ray,norm);\n    r.y = abs(r.y);\n    return skyGlow(r);\n}\n\n// set fairy lights colors\nvec3 fairyLight(in vec3 ray,in vec3 pos,in int hitObj){\n    float cs;\n    vec3 norm;\n    vec3 refl;\n    vec3 col=vec3(0.);\n    if (hitObj == REDL){\n        col.r += .05;\n        norm = normalize(redO-pos);\n        col += .5*fairyReflect(ray,norm);\n\t\tcs = dot(ray,norm);\n        col.r += .2*smoothstep(-1.,0.,-cs);\n    \tcol.r += exp(30.*(cs-1.));\n    }\n    else if (hitObj == MAGL){\n        col.rb += .05;\n        norm = normalize(magO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col.rb += .2*smoothstep(-1.,0.,-cs);\n    \tcol.rb += exp(30.*(cs-1.));\n    }\n    else if (hitObj == BLUL){\n        col += .05*vec3(0.,.3,1.);\n        norm = normalize(bluO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col += vec3(0.,.3,1.)*.3*smoothstep(-1.,0.,-cs);\n    \tcol += vec3(0.,.3,1.)*exp(30.*(cs-1.));\n    }\n\telse if (hitObj == YELL){\n        col.rg += .05;\n        norm = normalize(yelO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col.rg += .2*smoothstep(-1.,0.,-cs);\n    \tcol.rg += exp(30.*(cs-1.));\n    }\n    return col;\n}\n\n// Ray-trace fairy lights taking into account transparency\nfloat lightTrace(in vec3 pos, in vec3 ray,inout int hitLit, in int trans){\n    float t = INFINI, tp; \t\n    \n    if(trans != REDL){\n    \t\ttp = sphereImpact(pos, redO, redR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = REDL;\n    \t\t}\n        }\n    if(trans != MAGL){\n    \t\ttp = sphereImpact(pos, magO, magR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = MAGL;\n    \t\t}\n        }\n    if(trans != BLUL){\n    \t\ttp = sphereImpact(pos, bluO, bluR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = BLUL;\n    \t\t}\n        }\n    if(trans != YELL){\n    \t\ttp = sphereImpact(pos, yelO, yelR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = YELL;\n    \t\t}\n        }\n\n    return t;\n}\n\n//**************************** KEY FUNCTION!! find the next cells crossed by the ray ******************\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = ((cell+d*.5)*cellD-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.020 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n//*************** cal the set of functions depending on particular cell *************\nbool checkCell(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    if(cell == cottaCell) impact = cottaImpact(p, ray, color);   \n    else if(cell == snowmanCell) impact = caracterImpact(p, ray, color);\n    else if(cell == CtreeCell) impact = CtreeImpact(p, ray, color);\n    else impact = treeImpact(cell, p, ray, color);\n    return impact;\n}\n\n//*************** Lights path and camera tracking *******************************\nvec3 circle(in float ti, in vec3 obj){\n    return vec3(80.*cos(ti*TwoPI) + obj.x, 0., 80.*sin(ti*TwoPI) + obj.z);\n}\n\nvec3 freetrack(in float time){\n    return vec3(1500.*cos(time*.05), 0., 1600.*sin(time*.15));\n}\n\nvec3 transfer(in vec3 tr1, in vec3 tr2, in float dti){\n    return tr1*(1.+cos(dti*.25*PI))/2. + tr2*(1.+cos(dti*.25*PI+PI))/2.;\n}\n\nvec3 getTrac(in float time){\n    float ti = 23.*fract(time*.01);\n    vec3 track;\n    \n    if(ti<1.) track = circle(ti,wallO);\n    else if(ti<5.) track = transfer(circle(ti,wallO), freetrack(time), ti-1.);\n    else if(ti<10.) track = freetrack(time);\n    else if(ti<14.) track = transfer(freetrack(time), circle(ti,hedO), ti-10.);\n    else if(ti<15.) track = circle(ti,hedO);\n    else if(ti<19.) track = transfer(circle(ti,hedO), circle(ti,CtreeO), ti-15.);\n    else track = transfer(circle(ti,CtreeO), circle(ti,wallO), ti-19.);\n    \n    return track;\n}\n\nvec3 getCam(in float time, in vec3 track){\n    float ti = 23.*fract(time*.01);\n    vec3 cam;\n    \n    if(ti<1.) cam = wallO;\n    else if(ti<5.) cam = transfer(wallO, track, ti-1.);\n    else if(ti<10.) cam = track;\n    else if(ti<14.) cam = transfer(track, hedO, ti-10.);\n    else if(ti<15.) cam = hedO;\n    else if(ti<19.) cam = transfer(hedO, CtreeO, ti-15.);\n    else cam = transfer(CtreeO, wallO, ti-19.);\n    \n    return cam;\n}\n\n\n//**********************************************************************************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // object def\n    \n    //cotta\n    wallO = vec3(400.,4.,-600.);\n    wallO.y += ground(wallO.xz);\n    wallR = 20.;\n    roofO = wallO+vec3(0.,8.,0.);\n    roofH = 42.;\n    roofR = 22.;\n    cottaCell = vec2(4.,-6.);   //floor(wallO.xz/cellD + .5);\n    \n    //SnowMan\n    belO = vec3(200.,4.,100.);\n    belR = 10.;\n    belO.y = ground(belO.xz);\n    hedO = belO+vec3(0.,13.,0.);\n    hedR = 5.;\n    hatO = belO+vec3(0.,16.,0.);\n    hatH = 15.;\n    hatR = 3.8;\n    nozO = belO+vec3(4.,13.,0.);\n    nozH = 4.;\n    nozR = .8;\n    snowmanCell = vec2(2.,1.);\t\t//floor(belO.xz/cellD + .5);\n    \n    //Christmas tree\n\tCtreeO.xz = vec2(1200.,-600.);\n\tCtreeO.y = ground(CtreeO.xz)-5.;\n    CtreeH = 100.;\n    CtreeR = 15.;\n\tCtreeCell = vec2(12.,-6.);\n    \n    //light\n    vec3 trac = getTrac(iTime);\n    trac.y += ground(trac.xz)+15.;\n    vec3 tracb = getTrac(iTime-.5);\n    tracb.y = ground(tracb.xz)+1.;\n    redO = trac + vec3(20.*sin(iTime*2.),5.*sin(iTime*3.),10.*cos(iTime*2.));\n    redR = 3.;\n    magO = trac +vec3(10.*sin(1.+iTime*2.),4.*sin(1.6+iTime*3.),15.*cos(1.+iTime*2.));\n    magR = 3.;\n    bluO = trac +vec3(10.*sin(5.+iTime*3.),2.*sin(3.+iTime*2.),10.*cos(5.+iTime*3.));\n    bluR = 3.;\n    yelO = tracb +vec3(30.*sin(iTime*3.),abs(15.*sin(iTime*4.)+4.),20.*cos(iTime*3.));\n    yelR = 1.;\n    \n    //vec3 camTarget = trac;\n    //vec3 camTarget = tracb;\n    //vec3 camTarget = wallO*(1.+sin(u_time*.2))/2. + trac*(1.+sin(u_time*.2+PI))/2.;\n    //vec3 camTarget = redO;\n    //vec3 camTarget = bluO;\n    //vec3 camTarget = yelO;\n    //vec3 camTarget = (trac+wallO)/2.;\n    //vec3 camTarget = wallO;\n    //vec3 camTarget = roofO;\n    //vec3 camTarget = hedO;\n    //vec3 camTarget = CtreeO+vec3(0.,50.,0.);\n    vec3 camTarget = getCam(iTime, trac);\n    \n    // camera def\n    float \tfocal = 1.;\n    float \trau = 500.*(sin(iTime/7.)+1.) + 40.,\n    \t\talpha = iMouse.x/iResolution.x*4.*PI/*-u_time/5.*/,\n    \t\ttheta = iMouse.y/iResolution.y*PI/2.-.00001;//(sin(u_time/7.)/2.+0.5)*(PI/2.-.1)+0.05;\t\n    \n    camPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha)) + camTarget;\n\tcamPos.y = max(ground(camPos.xz)+15.,camPos.y);\t\t//anti-collision\n    \n    vec3 pos = camPos;\n    \n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n    \n\tlightRay = vec3(1.,0.,0.);\t// global var\n\tvec3 GNDnorm = vec3(0.);\n    \n    vec3 color = vec3(.0);\n        \n    vec2 cell, outCell;\n    vec3 p = pos;\n    \n    // first step getting boundarry of interesting areas\n    // find exit cell\n    T = gndRayTrace(pos, N_ray);\n    if(T<INFINI){\n        hitObj = GND;\n        vec3 tp = pos+T*N_ray;\n        cell = floor(tp.xz/cellD + .5);\n        outCell = getNextCell(pos.xz,N_ray.xz,cell);\n    }\n    else if(pos.y<cellH){\n        T = sfcImpact(pos, N_ray, cellH);\n        if(T<INFINI){\t\t\t\t\t\t\t\t\t// hitObj = SKY already default value\n            vec3 tp = pos+T*N_ray;\n            cell = floor(tp.xz/cellD + .5);\n            outCell = getNextCell(pos.xz,N_ray.xz,cell);\n            T = INFINI;\t\t\t\t\t\t\t\t\t// T consistant with SKY\n        }\n    }\n    else outCell = floor(pos.xz/cellD + .5);\n\t\n    //if cam above ceiling, find entry cell\n    if(pos.y>=cellH){\n        float t = sfcImpact(pos, N_ray, cellH);\n        if(t<INFINI) p = pos+t*N_ray;\n    }\n    \n    \n    // follow the ray across cells (and if object in cell, raytrace only the current cell)\n    // until:\n    // ray has reached the outCell (i.e. cell where the ray hit ground or ceiling)\n    // or ray has impact object\n    // or ray has reach the maxCell (calculation must end)\n    bool objImpact = false;\n    cell = floor(p.xz/cellD + .5);\n    if(cell != outCell){\n        for(int i=0; i<maxCell;i++){\n            objImpact = checkCell(cell, pos, N_ray, color);\n            if(objImpact) break;\n            cell = getNextCell(pos.xz,N_ray.xz,cell);\n            if(cell == outCell) break;\n        } \n \t}\n    \n    vec3 finalPos = pos + T*N_ray;\n    \n    // if impact, hitObj is TREE, CHRSTREE, COTTA OR SNOWMAN, color already set\n    // finally, if no impact, closing the scenery: SKY or GND\n    \n    if(hitObj == SKY) color += skyColor(N_ray);\n    else if(hitObj == GND){\n        GNDnorm = getGndNormal(finalPos.xz,finalPos.y);\n        color += 1.3*groundColor(finalPos, N_ray, GNDnorm);\n    }\n    \n    \n\t// particles flying around snowman.\n    // done in global because halo light propagates on multiple cells\n    // first line: check if ray enter a radius around snowman vertical axis\n    // to do calulation only in the environement of particules (here radius = 50.)\n    if( (abs(N_ray.z*(belO.x-pos.x) - N_ray.x*(belO.z-pos.z)) <50.) && (dot(belO-pos, N_ray)>=0.) ){\n    \tfloat len_fp_p = length(T*N_ray);\n        if(len_fp_p > length(belO-pos)-cellD){\n            float H = 200., R = 15.;\n            for(int i = 0; i<47; i++){\n                float fi = float(i);\n                float ti = -iTime+fi;\n                float dh = H*pow(fract(ti*.02),4.);\n                float r = R*(H-dh)/H;\t\t// for cone figure\n                float v = rand1(fi);\n                vec3 bulb = vec3(belO.x + r*sin(ti*v), belO.y+dh ,belO.z + r*cos(ti*v));\n                vec3 b_p = bulb-pos;\n                vec3 b_fp = bulb-finalPos;\n                float d;\n                if(len_fp_p<length(b_p)) d = length(b_fp);\n    \t\t\telse d = length(cross((b_p), N_ray));\n                if (!(hitObj == SNOWMAN && dot(b_fp,N_ray)>=0.)){\n                    color += max(0.,.15/d-.003)*rand1(fi);\n                }\n            }\n        }\n    }\n    \n    // Finally dealing with fairy lights, totally independant of cells. Done in global\n    int lightNbr;\n    float tlit;\n    // intercept lights\n    tlit = lightTrace(pos,N_ray,lightNbr,0);\t\t// 0 means no transparency requested\n    \n    if(tlit<T){\n        hitObj = lightNbr;\n        vec3 trpos = pos + tlit*N_ray; \n        // adding fairy lights\n    \tcolor += fairyLight(N_ray, trpos, hitObj);\n        \n        tlit = lightTrace(pos,N_ray,lightNbr,hitObj);\t\t// hitObj means transparency requested for this obj\n        if(tlit<INFINI){\t\t\t\t\t\t\t\t\t// to make visible the fairy light behind\n            trpos = pos + tlit*N_ray;\n        \tcolor += fairyLight(N_ray, trpos, lightNbr);\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [{"id": "lsXSRX", "previewfilepath": "https://soundcloud.com/kevyfastswing/betula-pendula-and-init-short-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kevyfastswing/betula-pendula-and-init-short-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBRH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2074, 2074, 2100, 2100, 2145], [2146, 2146, 2186, 2186, 2271], [2273, 2290, 2314, 2314, 2554], [2556, 2637, 2679, 2679, 3073], [3075, 3134, 3176, 3176, 3577], [3579, 3635, 3684, 3684, 3761], [3763, 3763, 3837, 3837, 4421], [4423, 4423, 4513, 4513, 5293], [5337, 5337, 5363, 5363, 5495], [5497, 5497, 5525, 5525, 5690], [5693, 5719, 5748, 5748, 5833], [5835, 5859, 5888, 5888, 6114], [6116, 6132, 6172, 6172, 6399], [6401, 6427, 6454, 6454, 6752], [6754, 6754, 6789, 6789, 7081], [7083, 7101, 7137, 7137, 7960], [7962, 7962, 7989, 7989, 8129], [8131, 8131, 8188, 8188, 8696], [8698, 8743, 8796, 8796, 9343], [9345, 9345, 9398, 9398, 9961], [9963, 9963, 10022, 10022, 11266], [11268, 11325, 11394, 11394, 11923], [11925, 11925, 11992, 11992, 12511], [12513, 12513, 12565, 12565, 12756], [12758, 12758, 12810, 12810, 12954], [12957, 12957, 13018, 13018, 14186], [14189, 14245, 14298, 14298, 14831], [14833, 14879, 14961, 14961, 15423], [15425, 15425, 15497, 15497, 15964], [15966, 16018, 16077, 16077, 17281], [17284, 17351, 17395, 17395, 17472], [17474, 17501, 17556, 17556, 18632], [18634, 18693, 18767, 18767, 19429], [19431, 19535, 19588, 19588, 19780], [19782, 19868, 19939, 19939, 20243], [20245, 20327, 20365, 20365, 20442], [20444, 20444, 20474, 20474, 20539], [20541, 20541, 20595, 20595, 20670], [20672, 20672, 20700, 20700, 21225], [21227, 21227, 21269, 21269, 21658], [21661, 21746, 21802, 21802, 28263]], "test": "timeout"}
{"id": "ldXBWn", "name": "14/100", "author": "yahe", "description": "14/100", "tags": ["distance"], "likes": 0, "viewed": 354, "published": "Public API", "date": "1495596635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 6\nvec2[N] c;\n\nfloat avgDistance(vec2 uv)\n{\n \tfloat d = 0.0;\n    float k = 30.+sin(iTime)+cos(iTime);\n    for(int i=0; i<N; i++)    \n     \td+= cos(k*distance(uv,c[i])); \n    return d/float(N);  \n}\n\nvec4 distToColor(float d)\n{\n    return vec4(.95,1.2-sin(d),cos(d),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    for(int i=0; i<N; i++)\n    {\n     float fi = 2.0*3.14*float(i)/float(N);\n     c[i]= vec2(sin(fi), cos(fi))*(cos(iTime)+2.)*.1;\n    }\n\tfragColor = distToColor(avgDistance(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 52, 52, 205], [207, 207, 234, 234, 280], [282, 282, 339, 339, 589]], "test": "ok"}
{"id": "ls2cDt", "name": "Domain coloring 2", "author": "ollj", "description": "Visualization of functions of a complex variable. Click and hold to see each cell in full size!\nidentical to \nhttps://www.shadertoy.com/view/Mt2GDV\nwith very minor improvements.", "tags": ["2d", "grid", "domain", "color", "complex", "tiling", "transformation"], "likes": 21, "viewed": 716, "published": "Public API", "date": "1494441600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parent=https://www.shadertoy.com/view/Mt2GDV\n//just slightly crunched with minot optimizations\n\n#define pi 3.14159265359\n//#define E  2.71828182845 //exists as y=exp(1.);\n#define dd(a) dot(a,a)\n//complex number space transforms.\nvec2 sinz(vec2 c){vec2 d=vec2(exp(c.y),exp(-c.y));\n return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 cosz(vec2 c){vec2 d=vec2(exp(c.y),exp(-c.y));\n return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 tanz(vec2 c){vec2 d=vec2(exp(c.y),exp(-c.y));\n float e=cos(c.x),s=(d.x-d.y)*.5;\n return vec2(sin(c.x)*e, s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 logz(vec2 c){return vec2(log(length(c)),atan(c.y, c.x));}\nvec2 sqrtz(vec2 c){float n=c.x+length(c);\n return vec2(n,c.y)/sqrt(2.*n);}\nvec2 exp2z(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}\nvec2 epowz(vec2 c){return vec2(cos(c.y),sin(c.y))*exp(c.x);}\nvec2 mulz(vec2 a,vec2 b){return a*mat2(b.x,-b.y,b.yx);}\nvec2 divz(vec2 n,vec2 d){return n*mat2(d,-d.y,d.x)/dd(d);}\nvec2 invz(vec2 c){return vec2(c.x,-c.y)/dd(c);}\n//by David Bargo-davidbargo/2015\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 func(float i,vec2 c){vec2 r;\n      if(i==1.)r=sinz(c);\n else if(i==2.)r=sqrtz(divz(logz(vec2(-c.y-6.,c.x)),logz(vec2(-c.y+2.,c.x))));\n else if(i==3.)r=epowz(c);\n else if(i==4.)r=tanz(tanz(c));\n else if(i==5.)r=tanz(sinz(c));\n else if(i==6.)r=sqrtz(vec2(1.+c.x,c.y))+sqrtz(vec2(1.- c.x,-c.y));\n else if(i==7.)r=divz(tanz(exp2z(c)),c);\n else if(i==8.)r=sinz(cosz(sinz(c)));\n else if(i==9.)r=invz(vec2(1,0)+epowz(vec2(c.y, c.x)));\n else if(i==10.)r=epowz(invz(sqrtz(-c)));\n else if(i==11.)r=exp2z(invz(c));\n else if(i==12.)r=epowz(sinz(epowz(cosz(c))));   \t\n else if(i==13.)r=divz(sinz(c),c);\n else if(i==14.)r=exp2z(c);\n else if(i==15.)r=divz(sinz(c),cosz(exp2z(c)));\n else if(i==16.)r=invz(c+vec2(1,0))+invz(c-vec2(1,0));\n else if(i==17.)r=logz(c-invz(c));\n else if(i==18.)r=divz(sqrtz(vec2(c.x+1., c.y)), sqrtz(vec2(c.x-1.,c.y)));\n else if(i==19.)r=invz(vec2(1,0)+mulz(c,exp2z(exp2z(c))));\n else return c;return r;}\n\n//2d rotation by iTime\nvec2 animate(vec2 v){\n float s=sin(iTime),c=cos(iTime);return v*mat2(c,-s,s,c);}\n\n//color space\nvec3 hsv2rgb(in vec3 c){//iq's smooth hsv to rgb\n vec3 rgb=clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n rgb=rgb*rgb*(3.0-2.0*rgb);return c.z*mix(vec3(1),rgb,c.y);}\n\n//for tiling grid, by aiekick https://www.shadertoy.com/view/4lj3Ww\nvec2 gridSize=vec2(5,4);\nvec3 getCell(vec2 s,vec2 h){vec2 c=floor(h*gridSize/s);\n return vec3(c.x,c.y,(gridSize.y-1.-c.y)*gridSize.x+c.x);}\nvec3 getSmallCells(vec2 s,vec2 h){\n vec3 c=getCell(s,h);vec2 g=s/gridSize;float r=g.x/g.y;\n vec2 u = pi*((2.*h-g)/g.y - 2.*vec2(c.x*r,c.y));return vec3(c.z,u);}\n\nvoid mainImage( out vec4 Out,in vec2 In){vec2 e=iResolution.xy;    \n vec3 c=iMouse.z>0.? \n  vec3(getCell(e, iMouse.xy).z,pi*(2.*In-e)/(e.y))://fullscreen cell \n  getSmallCells(e,In);//tiled cells\n vec2 z=animate(func(c.x,c.yz))*2.;\n float h=atan(z.y,z.x)/(2.*pi),l=length(z),\n s=abs(fract(l)-.5)-.25;s=step(0.,s)*s*4.;s=1.-s*s;\n vec2  r=abs(fract(z)-.5)-.25;r=step(0.,r)*r*4.;r=1.-r*r*r*r;\n float v=mix(1.,r.x*r.y,s*.5);\n Out=vec4(hsv2rgb(vec3(h,s,v)),1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls2cDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 231, 249, 249, 341], [342, 342, 360, 360, 453], [454, 454, 472, 472, 591], [592, 592, 610, 610, 654], [655, 655, 674, 674, 729], [730, 730, 749, 749, 793], [794, 794, 813, 813, 854], [855, 855, 880, 880, 910], [911, 911, 936, 936, 969], [970, 970, 988, 988, 1017], [1138, 1138, 1164, 1164, 2058], [2060, 2083, 2104, 2104, 2163], [2165, 2179, 2203, 2227, 2351], [2446, 2446, 2474, 2474, 2560], [2561, 2561, 2595, 2595, 2721], [2723, 2723, 2764, 2764, 3180]], "test": "ok"}
{"id": "ls2yWV", "name": "Julia Fractal Morph Smooth Color", "author": "DonKarlssonSan", "description": "Julia Fractal morphed by a point along a Lissajous curve.\nSmooth (continuous) colors by \"normalized iteration count\", see: \nhttps://linas.org/art-gallery/escape/smooth.html \nand\nhttps://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring", "tags": ["fractal", "julia"], "likes": 1, "viewed": 138, "published": "Public", "date": "1493921674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nconst float a = 5.0;\nconst float b = 4.0;\nconst float w = PI / 2.0;\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 lissajous() {\n    float t = iTime/10.0+219.17;\n    float x = sin(a * t + w);\n    float y = sin(b * t);\n\treturn vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float xmin = -2.0;\n    float ymin = -1.4;\n    float xmax = 2.0;\n    float ymax = 1.4;\n    float xDelta;\n    float yDelta;\n    xDelta = (xmax - xmin) / iResolution.x;\n    yDelta = (ymax - ymin) / iResolution.y;\n    int iteration = 0;\n    const int max_iteration = 100;\n    vec2 l = lissajous();\n    float x = xmin + fragCoord.x * xDelta;\n    float y = ymin + fragCoord.y * yDelta;\n    // while loop not supported on iPhone !!\n    // Using a for loop with break condition instead.\n    for (int i = 0; i < max_iteration; i++) {\n        // Multiplication of complex numbers:\n        // (a+bi) (c+di) = (ac-bd) + (bc+ad)i\n        // c^2 = (x+yi) (x+yi) = (xx-yy) + (yx+yx)i = (xx-yy) + (2xy)i\n        float xtemp = x * x - y * y + l.x;\n        y = 2.0 * x * y + l.y;\n        x = xtemp;\n        iteration = i;\n        if(x*x + y*y > 16.0) break;\n    }\n \n    float log_zn;\n    float nu;\n    float sm = float(iteration);\n    float s = 0.0;\n    float v = 0.0;\n    if (iteration < max_iteration ) {\n        // sqrt of inner term removed using log simplification rules.\n        log_zn = log( x*x + y*y ) / 2.0;\n        nu = log( log_zn / log(2.0) ) / log(2.0);\n        // Rearranging the potential function.\n        // Dividing log_zn by log(2) instead of log(N = 1<<8)\n        // because we want the entire palette to range from the\n        // center to radius 2, NOT our bailout radius.\n        sm=float(iteration) + 1.0 - nu;\n        s = 1.0;\n        v = 0.5;\n    }\n    \n    float c = sm / float(max_iteration)*50.0 + iTime/10.0;\n    vec3 hsv = hsv2rgb(vec3(c, s, v));\n    fragColor = vec4(hsv, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls2yWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 191, 213, 213, 382], [384, 384, 402, 402, 513], [515, 515, 572, 572, 2171]], "test": "ok"}
{"id": "ls2yWy", "name": "Rainbow shampoo", "author": "morgaza", "description": "Nice", "tags": ["rainbowshampoo"], "likes": 7, "viewed": 265, "published": "Public", "date": "1493691691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hue_to_rgb(float m1, float m2, float h)\n{\n    if (h < 0.0f) h += 1.0f;\n    if (h > 1.0f) h -= 1.0f;\n    if (h * 6.0f < 1.0f) return m1 + (m2 - m1) * h * 6.0f;\n    if (h * 2.0f < 1.0f) return m2;\n    if (h * 3.0f < 2.0f) return m1 + (m2 - m1) * (2.0f / 3.0f - h) * 6.0f;\n    return m1;\n}\nvec3 hsl_to_rgb(float h, float s, float l)\n{\n    float m2 = (l <= 0.5f) ? (l * (s + 1.0f)) : (l + s - l * s);\n    float m1 = l * 2.0f - m2;\n    float r = hue_to_rgb(m1, m2, h + 1.0f / 3.0f);\n    float g = hue_to_rgb(m1, m2, h);\n    float b = hue_to_rgb(m1, m2, h - 1.0f / 3.0f);\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    float bw = (color.r + color.b + color.g) / 3.0;\n    \n    vec3 rainbow = hsl_to_rgb(mod(bw * 2.0 + iTime, 1.0), 0.5, 0.5);\n\tfragColor = vec4(rainbow, 1);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls2yWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 292], [293, 293, 337, 337, 599], [601, 601, 658, 658, 905]], "test": "error"}
{"id": "lsBcW3", "name": "Generalized Trefoil", "author": "JCDjcd", "description": "Draw a generalized trefoil (p,q) where p and q are co-prime integers. The standard trefoil is (2,3).\nThe parameters (p,q) are changing every 3 seconds.", "tags": ["trefoil"], "likes": 13, "viewed": 168, "published": "Public", "date": "1494029914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\nvec3 trefoil_point(float p,float q,float phi)\n{\n    float cp = cos(p*phi);\n    float sp = sin(p*phi);\n    float cq = cos(q*phi);\n    float sq = sin(q*phi);\n    return vec3((2.0+cq)*cp,(2.0+cq)*sp,-sq);\n} // trefoil_point()\n\n//--------------------------------------------------------------------------\n// treefoil (p,q)\n// ray is defined by point P and direction d\nvec4 compute(in float p,in float q,in vec3 P, in vec3 d)\n{\n    d = d/dot(d,d);\n    int \ti;\n    int \tnb \t\t= 1000;\n    float \tt_min \t= 1000.0;\n    float   phi_min;\n    float \tr2 \t\t= 0.2; // radius of the torus\n    for(i=0;i<nb;i++)\n    {\n        float phi \t= TWOPI*float(i)/float(nb);\n        vec3  A \t= trefoil_point(p,q,phi);\n        float t \t= -dot(P-A,d);\n        vec3  M \t= P+t*d;\n        vec3  diff \t= M-A;\n        if(t > 0.0 && t < t_min && dot(diff,diff) < r2)\n        {\n            t_min \t= t;\n            phi_min = phi;\n        }\n    } // for()\n    \n    if(t_min < 1000.0)\n    {\n     \treturn COLORIZATION(phi_min/TWOPI);\n    }\n    else\n    {\n\t\treturn vec4(0.0,0.0,0.0,1.0);\n    }\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n    if(fragCoord.x >= m || fragCoord.y >= m)\n    {\n        // in order to speed up the computation,\n        // directly put in black the pixels outside\n        // the square m x m\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*10.0;\n    vec3 P \t\t\t= vec3(uv,-5.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    float alpha1\t= iTime*TWOPI/13.0;\n    float alpha2\t= iTime*TWOPI/5.0;\n    P.zx\t\t   *= ROTATION(alpha1);\n    P.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n    \n    float i = mod(iTime/3.0 /* change every 3 seconds */,16.0);\n    float p,q;\n    if(i <= 1.0) \t\t{p=2.0;q=3.0;}\n    else if(i <= 2.0)\t{p=2.0;q=5.0;}\n    else if(i <= 3.0)\t{p=2.0;q=7.0;}\n    else if(i <= 4.0)\t{p=3.0;q=2.0;}\n    else if(i <= 5.0)\t{p=3.0;q=4.0;}\n    else if(i <= 6.0)\t{p=3.0;q=5.0;}\n    else if(i <= 7.0)\t{p=3.0;q=7.0;}\n    else if(i <= 8.0)\t{p=4.0;q=3.0;}\n    else if(i <= 9.0)\t{p=4.0;q=5.0;}\n    else if(i <= 10.0)\t{p=4.0;q=7.0;}\n    else if(i <= 11.0)\t{p=5.0;q=2.0;}\n    else if(i <= 12.0)\t{p=5.0;q=3.0;}\n    else if(i <= 13.0)\t{p=5.0;q=4.0;}\n    else if(i <= 14.0)\t{p=5.0;q=6.0;}\n    else if(i <= 15.0)\t{p=5.0;q=7.0;}\n\telse\t\t\t\t{p=6.0;q=5.0;}\n        \n    fragColor = compute(p,q,P,d);\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 357, 404, 404, 560], [581, 721, 779, 779, 1410], [1425, 1502, 1553, 1553, 2892]], "test": "ok"}
{"id": "lsfBWn", "name": "∇", "author": "haldean", "description": "messing around with signed distance fields and \"fog\"", "tags": ["3d"], "likes": 1, "viewed": 109, "published": "Public", "date": "1495605717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float hit_tol = 1e-5;\n\nstruct hit\n{\n    vec3 p;\n    float d;\n    bool hit;\n    int mat;\n};\n    \nstruct ray\n{\n    vec3 s;\n    vec3 d;\n};\n    \nvoid reset(inout hit h)\n{\n    h.p = vec3(0.);\n    h.d = 1e10;\n    h.hit = false;\n    h.mat = 0;\n}\n\nvoid sdf_sphere(inout hit h, vec3 center, float rad)\n{\n    float d = length(h.p - center) - rad;\n    h.d = d;\n}\n\nvoid sdf_plane(inout hit h, vec3 pos, vec3 n)\n{\n    float d = dot(h.p - pos, n);\n    h.d = d;\n}\n\nvoid sdf_cyl(inout hit h, vec3 pos, vec3 ax, float rad)\n{\n    vec3 rel = h.p - pos;\n    float ap = dot(ax, rel);\n    vec3 axp = ap * ax;\n    float r = length(rel - axp);\n    float d = r - rad;\n    h.d = d;\n}\n\nvoid csg_intersect(inout hit h0, in hit h1)\n{\n    if (h0.d >= h1.d)\n        return;\n    h0 = h1;\n}\n\nvoid csg_subtract(inout hit h0, in hit h1)\n{\n    if (h0.d >= -h1.d)\n        return;\n    h0 = h1;\n    h0.d = -h0.d;\n}\n\nvoid csg_union(inout hit h0, in hit h1)\n{\n    if (h0.d <= h1.d)\n        return;\n    h0 = h1;\n}\n\nvoid csg_blend(inout hit h0, in hit h1, float k)\n{\n    // in the case where h0.d and h1.d are the same, this is 0.5. As h0.d gets larger, this\n    // decreases, and v.v. When the two diverge by more than k, this is either 0 or 1.\n    float blend = clamp(0.5 + 0.5 * (h1.d - h0.d) / k, 0.0, 1.0);\n    // when blend is 0.5, this works out to d - k / 4; you get a radius of k / 4\n    // when you're exactly the same distance from the two hits.\n    float d = mix(h1.d, h0.d, blend) - k * blend * (1.0 - blend);\n    h0.d = d;\n}\n\nvoid sdf(inout hit h, vec3 pos)\n{\n    h.p = pos;\n    \n    hit h0, h1;\n    h0.p = pos;\n    h1.p = pos;\n    \n    sdf_sphere(h, vec3(0., 0., 10.), 2.5 + 0.4 * sin(1.4 * iTime));\n    \n    sdf_cyl(h0, vec3(0., 0., 10.), vec3(sin(iTime), 0., cos(iTime)), 1.);\n\tsdf_sphere(h1, vec3(0., 0., 10.), 4.5);\n    csg_intersect(h0, h1);\n    \n    csg_blend(h, h0, 1.); h.mat = 1;\n\n    sdf_plane(h0, vec3(-4., 0., 0.), vec3(1., 0., 0.)); h0.mat = 0; csg_union(h, h0);\n    sdf_plane(h0, vec3(4., 0., 0.), vec3(-1., 0., 0.)); h0.mat = 0; csg_union(h, h0);\n    sdf_plane(h0, vec3(0., -3., 0.), vec3(0., 1., 0.)); h0.mat = 2; csg_union(h, h0);\n\n    h.hit = h.d < hit_tol;\n}\n\nvoid send(inout hit h, ray r)\n{\n    float t = 0.5;\n    for (int i = 0; i < 128; i++)\n    {\n        sdf(h, r.s + t * r.d);\n        if (h.hit)\n        \treturn;\n        t += h.d;\n        continue;\n    }\n    h.hit = false;\n}\n\nfloat shadow(ray r, vec3 light)\n{\n    float t = 0.5;\n    float shadow = 1.;\n    float dist = length(light - r.s);\n    hit lh;\n    for (int i = 0; i < 64; i++)\n    {\n        if (t >= dist)\n            break;\n        reset(lh);\n        sdf(lh, r.s + t * r.d);\n        if (lh.hit)\n            return 0.;\n        t += lh.d;\n        shadow = min(shadow, 8. * lh.d / t);\n    }\n    return clamp(shadow, 0., 1.);\n}\n\nfloat ao(in hit h, vec3 n)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    hit aoh;\n    for (int i = 0; i < 8; i++)\n    {\n        float hr = 0.6 * float(i) / 5.0 + 0.01;\n        vec3 aopos = n * hr + h.p;\n        \n        reset(aoh);\n        sdf(aoh, aopos);\n\n        occ += (aoh.d - hr) * -sca;\n        sca *= 0.90;\n    }\n    return clamp(1.0 - 0.2 * occ, 0.0, 1.0 );    \n}\n\nvec4 light(hit h, vec3 n, vec3 light, vec4 color)\n{\n    ray r;\n    r.d = normalize(light - h.p);\n    r.s = h.p;\n    float sh = shadow(r, light);\n\n    vec4 diffuse = clamp(dot(n, r.d), 0., 1.) * color;\n    \n    vec3 refl = normalize(2. * dot(r.d, n) * n - r.d);\n    vec3 view = normalize(-h.p);\n    float spec = h.mat == 1\n        ? pow(clamp(dot(view, refl), 0., 1.), 10.)\n        : 0.;\n    vec4 specc = spec * vec4(1., 1., 1., 1.);\n    \n    return clamp(sh * (diffuse + spec),\n                 vec4(0., 0., 0., 1.),\n                 vec4(1., 1., 1., 1.));\n}\n\nvec3 normal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    vec3 n = vec3(0., 0., 0.);\n    hit h;\n    sdf(h, pos + e.xyy); n += e.xyy * h.d;\n    sdf(h, pos + e.yyx); n += e.yyx * h.d;\n    sdf(h, pos + e.yxy); n += e.yxy * h.d;\n    sdf(h, pos + e.xxx); n += e.xxx * h.d;\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    float mw = max(iResolution.x, iResolution.y);\n    vec2 uv = 2.0 * (fragCoord.xy - iResolution.xy / 2.0) / mw;\n    ray r;\n    r.s = vec3(-uv, -0.8);\n    r.d = normalize(-r.s);\n    \n    hit h;\n    reset(h);\n    send(h, r);\n    if (!h.hit)\n    {\n        color = vec4(0.08, 0, 0.1, 1.0);\n    }\n    else\n    {\n        vec4 mat =\n            h.mat == 0 ? vec4(0., .6, 1., 1.) :\n            h.mat == 1 ? vec4(1., 1., 1., 1.) : \n        \th.mat == 2 ? vec4(0., .6, .9, 1.) :\n        \tvec4(0.);\n        vec4 amb = vec4(0.05, 0.03, 0.01, 1.0);\n        vec3 norm = normal(h.p);\n        vec4 dif = light(h, norm, vec3(0, 10., 7.), vec4(1., .3, .6, 1.));\n        vec4 dif2 = light(h, norm, vec3(2., 7., 4.), vec4(0.4, 0.4, 0.1, 1.));\n        float aos = ao(h, norm);\n        color = (amb + aos * (dif + dif2)) * mat;\n    }\n    \n    float fog = pow(clamp(length(h.p - r.s) / 40., 0., 1.), 1.2);\n    color =\n        (1. - fog) * color +\n        fog * vec4(0.7, 0.66, 0.68, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsfBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 172, 172, 244], [246, 246, 300, 300, 357], [359, 359, 406, 406, 454], [456, 456, 513, 513, 663], [665, 665, 710, 710, 763], [765, 765, 809, 809, 881], [883, 883, 924, 924, 977], [979, 979, 1029, 1208, 1501], [1503, 1503, 1536, 1536, 2155], [2157, 2157, 2188, 2188, 2377], [2379, 2379, 2412, 2412, 2785], [2787, 2787, 2815, 2815, 3158], [3160, 3160, 3211, 3211, 3718], [3720, 3720, 3746, 3746, 4035], [4037, 4037, 4088, 4088, 5056]], "test": "ok"}
{"id": "lsffD4", "name": "raytracing experiment", "author": "abje", "description": "ray-sphere intersection + ray-box intersection.", "tags": ["raytracing", "repetition", "subtraction"], "likes": 1, "viewed": 453, "published": "Public API", "date": "1496176877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//a sphere intersection function from iq\n//https://www.shadertoy.com/view/4djSDy\nvec2 sphIntersect( in vec3 ro, in vec3 rd)\n{\n\t\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro )-81.0;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0,-2.0);\n\treturn vec2(-b - sqrt( h ),-b+sqrt(h));\n}\n\nvec4 insidebox(vec3 pos, vec3 dir) {\n    vec3 lens = (1.0-pos*sign(dir))/abs(dir)*step(abs(pos),vec3(1.0));\n    float len = min(min(lens.x,lens.y),lens.z);\n    return vec4(len,lens);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 pointlight = vec3(4.0,0.0,-10.0);\n    \n    vec3 pos = vec3(cos(iTime)*3.0,sin(iTime)*3.0,-20.0);\n    vec3 dir = normalize(vec3(uv,1.5));\n    \n    vec2 len = sphIntersect(pos,dir);\n   \tpos += len.x*dir;\n    vec3 normal = normalize(pos);\n    vec4 len2 = insidebox(mod(pos,2.4)-1.2, dir);\n    if (len2.x > 0.0) {\n        normal = -step(len2.yzw,len2.xxx)*sign(dir);\n    }\n    if(len.y > len.x) {\n        fragColor = vec4(abs(normal),1.0);\n        \n        vec3 lightnorm = (pointlight-pos);\n        float lightdist = length(lightnorm);\n        lightnorm /= lightdist;\n        \n        fragColor = vec4(max(dot(normal,lightnorm),0.1));\n        \n    } else {\n        \n\t\tfragColor = vec4(0.0,0.0,sqrt(uv.y*0.25+0.25),1.0);\n        return;\n    }\n    \n\t//fragColor = vec4(fract(pos+0.001),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsffD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 125, 125, 284], [286, 286, 322, 322, 470], [472, 472, 529, 529, 1398]], "test": "ok"}
{"id": "lsffRN", "name": "Hyperbolic Fun", "author": "decrooks", "description": "Playing with the poincare disk", "tags": ["circle", "disk", "hyperbolic", "poincare"], "likes": 21, "viewed": 451, "published": "Public", "date": "1495045754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\nstruct Circle {\n    float radius;\n    vec2 center;\n};\n\nconst int numCircles = 3;\nCircle circles[3];\n\n\n/*\n\tOrthoganl Circles represent strait line in hyperbolic space.\n\t\n\tsee http://mathworld.wolfram.com/PoincareHyperbolicDisk.html.\n\n*/\nCircle orthogonalCircle(float theta1,float theta2) {\n    \n    float theta = 0.5*(theta1 + theta2);\n    float dTheta = 0.5*(theta1 - theta2);\n    \n    float r = abs(tan(dTheta));\n   //  float r = 0.5;\n    float R = 1.0/cos(dTheta);\n    \n    vec2 center = vec2(R*cos(theta),R*sin(theta));\n    \n    return Circle(r,center);\n}\n\n\n\n\nvoid createCircles() {\n\n    float t = 0.5 - 0.5*cos(iTime);\n\n  \tfloat theta = TWO_PI/3.0;\n   \n    \n    float dTheta = 2.43 + 0.152*t;\n    \n\t//for(int i;i<numCircles  )\n    circles[0] = orthogonalCircle(0.0,dTheta);\n    circles[1] = orthogonalCircle(theta,theta + dTheta);\n    circles[2] = orthogonalCircle(2.0*theta,2.0*theta +  dTheta);\n}\n\nfloat arcosh(float x) {\n    return log(x + sqrt(x*x - 1.0));\n}\n\nfloat hyperbolicDist(vec2 p, vec2 q){\n    //distance between points on  Poincaré Hyperbolic Disk\n    float pq = length(p-q);\n    float op = length(p);\n    float oq = length(q);\n    \n    return arcosh(1.0 + 2.0*pq*pq/((1.0 - op*op)*(1.0 - oq*oq)) );\n}\n\nbool circleContains(vec2 p, Circle c) {\n    \n   return distance(c.center,p) < c.radius;\n    \n}\n\n\n/*\n\tCircle inversion exchanges the inside with the outside of a circle.\n\tReflections in hyperbolic space.\n*/\nvec2 circleInverse(vec2 p, Circle c){\n    \n\treturn ((p - c.center) * c.radius * c.radius)/(length(p - c.center) * length(p - c.center) ) + c.center;\n    \n}\n\nbool isEven(int i){\n    \n    return mod(float(i),2.0) == 0.0;\n    \n}\n\n/*\n\tIterated Inversion System \n    see this paper http://archive.bridgesmathart.org/2016/bridges2016-367.pdf\n    and this shader https://www.shadertoy.com/view/XsVXzW by soma_arc.\n\n\tThis algorythim for draws tileings on the poncaire disk model of hyperbolic space.\n\t\n\tOur array of circles represent the reflections that generate the tiling.\n\tWe repeatedly invert the point in each of the circles and keep track of the total number of inversions.\n\n*/\n\nvec2 iteratedInversion(vec2 p) {\n    \n\n    int count = 0;\n    bool flag = true;\n    \n    for(int i=0; i<100; i++) {\n        \n        flag = true;\n        \n        \n        for(int j = 0; j<numCircles; j++) {\n            Circle c = circles[j];\n\n            if(circleContains(p, c)) {\n                \n                p = circleInverse(p,c);\n                flag = false;\n                count++;  \n                \n        \t} \n            \n        }\n        \n        if(flag) {\n           break;\n        }\n        \n    }\n    \n    //return isEven(count);\n    return p;\n    \n}\n\nfloat drawCircles(vec2 p) {\n    \n    float  d0 =  abs(distance(circles[0].center,p) - circles[0].radius);\n    float  d1 = abs(distance(circles[1].center,p) - circles[1].radius);\n    float  d2 =  abs(distance(circles[2].center,p) - circles[2].radius);\n    \n    float disk = abs(length(p) - 1.0);\n   \n    float d =  min(min(min(d0,d1),d2),disk);\n    \n    if(d<0.01) {\n     \treturn 0.0;   \n    }\n    else {\n        return 1.0 - 0.5*d;  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tcreateCircles();\n    \n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float R = length(uv);\n    \n    vec4 black = vec4(vec3(0.0),1.0);\n    vec4 white = vec4(1.0);\n    \n    \n    //Uncomment this to see the circles that generate the tiling\n    //fragColor = vec4(vec3(drawCircles( uv)),1.0); return;\n   \n   \n    if (R<1.0){\n        vec2 p = iteratedInversion(uv);\n       // float r = length(p);  //distance(p\n        float r = hyperbolicDist(p,vec2(0.0));\n        \n        float h = sin(15.0*r + iTime);\n        \n          fragColor = vec4(vec3(0.5+0.5*h),1.0);\n    }\n    else {\n        fragColor = white;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsffRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[267, 401, 453, 453, 723], [728, 728, 750, 750, 1067], [1069, 1069, 1092, 1092, 1131], [1133, 1133, 1170, 1230, 1384], [1386, 1386, 1425, 1425, 1480], [1483, 1592, 1629, 1629, 1747], [1749, 1749, 1768, 1768, 1817], [2270, 2270, 2302, 2302, 2843], [2845, 2845, 2872, 2872, 3286], [3289, 3289, 3345, 3345, 3987]], "test": "ok"}
{"id": "lsffz7", "name": "everyday 012/100", "author": "kalin", "description": "everyday 012/100", "tags": ["everyday"], "likes": 1, "viewed": 133, "published": "Public", "date": "1495342350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 71.5bpm\n    float bpm = 1.0 / 60.0 * 71.5;\n\n    float t = iTime;\n    float b = t * bpm * 3.1415926535;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    \n    float m0 = texture(iChannel0, vec2(uv.x, 0.25)).x;\n    float m1 = texture(iChannel0, vec2(uv.x, 0.75)).x;\n    \n    float c0 = pow(m0, 8.0) * uv.y;\n    float c1 = m1 * uv.y * 0.0;\n    float c2 = m1 * pow(length(1.0 - abs(nuv * vec2(1.0, 4.0 * sin(b + bpm * 1.25)))), 1.5);\n    \n    c1 = abs(sin(b * 2.0)) * length(nuv) * 1.0;\n    \n    float drum0 = texture(iChannel0, vec2(1.0, 0.25)).x;\n    float drum1 = texture(iChannel0, vec2(1.0, 0.25)).x;\n    float drum2 = texture(iChannel0, vec2(1.0, 0.25)).x;\n\tfloat drum = pow((drum0 + drum1 + drum2) / 3.0, 2.0);\n    \n    drum = smoothstep(0.0, 1.0, drum * 2.0);\n    \n    float cd = drum;\n    \n    vec3 col0 = vec3(0.14, 0.29, 0.45);\n    vec3 col1 = vec3(0.26, 0.65, 0.22);\n    vec3 col2 = vec3(0.76, 0.12, 1.22);\n    \n    fragColor.xyz = col0 + col0 * c1;\n    fragColor.xyz += col1 * c2 * 0.1;\n    fragColor.xyz += col2 * drum;\n    \n    fragColor.xyz -= pow(length(nuv), 3.0) * 0.5 * c2 * c1;\n    fragColor.xyz += pow(m1, 12.0) * pow(abs(nuv.y), 12.0) * 80.0;\n}", "image_inputs": [{"id": "XsXSR7", "previewfilepath": "https://soundcloud.com/f-777/3-the-battle-begins-viking-dance-machine", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/f-777/3-the-battle-begins-viking-dance-machine", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsffz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 72, 1260]], "test": "error"}
{"id": "lsjcDG", "name": "all primitives", "author": "Coolok", "description": "create simple ", "tags": ["raycasting"], "likes": 3, "viewed": 91, "published": "Public", "date": "1493673167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos-(pos.x*pos.y*pos.z)), 1.0 ),\n\t                vec2( sdSphere(    (pos-vec3( 0.0,0.25, 0.0)), 0.25 ), 46.9 ) );\n    /*res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\tres = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\t*/res = opU( res, vec2( 0.2*sdSphere(    pos-vec3(0.0,1.0,0.0), 0.12 ) + \n                           0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z)*(2.0+sin(iTime))/length(pos), 65.0 ) );\n\t/*res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n      */  \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjcDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 155, 155, 170], [172, 172, 207, 207, 233], [235, 235, 266, 266, 357], [359, 359, 402, 402, 462], [464, 464, 509, 509, 551], [553, 553, 586, 586, 641], [643, 643, 679, 679, 921], [923, 923, 975, 975, 1089], [1091, 1091, 1127, 1127, 1375], [1377, 1377, 1413, 1413, 1512], [1514, 1514, 1552, 1552, 1721], [1723, 1723, 1795, 1795, 2010], [2012, 2012, 2079, 2118, 2490], [2492, 2492, 2517, 2517, 2554], [2556, 2556, 2581, 2581, 2639], [2641, 2641, 2666, 2666, 2731], [2733, 2733, 2768, 2768, 2839], [2841, 2841, 2876, 2876, 2947], [2949, 2949, 2986, 2986, 3039], [3111, 3111, 3144, 3144, 3170], [3172, 3172, 3202, 3202, 3235], [3237, 3237, 3267, 3267, 3296], [3298, 3298, 3322, 3322, 3454], [3526, 3526, 3551, 3551, 5767], [5769, 5769, 5809, 5809, 6428], [6431, 6431, 6505, 6505, 6765], [6767, 6767, 6799, 6799, 7238], [7240, 7240, 7282, 7282, 7581], [7583, 7583, 7622, 7622, 9193], [9195, 9195, 9247, 9247, 9424]], "test": "ok"}
{"id": "lsjcWc", "name": "bars", "author": "lennyjpg", "description": "lkfhjsdkjhfg", "tags": ["2d"], "likes": 2, "viewed": 406, "published": "Public API", "date": "1494208925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float t = iTime * 1.7;\n    t += fract(sin(uv.x+1.0))*2.0;\n    float e = 1.0+sin(uv.x*3.0)*2.6;\n    float k =  cos(t-e) + 7.0;\n    O = vec4( abs( cos(t + sin(0.5 * t + (uv.x+t*0.001) * k) ) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 289]], "test": "ok"}
{"id": "lsjcWd", "name": "1/100", "author": "yahe", "description": "1/100", "tags": ["line"], "likes": 1, "viewed": 306, "published": "Public API", "date": "1494449525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    float left = - smoothstep( cos(iTime) / 2.0, cos(iTime) / 2.0 + 0.7, st.x) + 1.0;\n    float top = cos(st.x);\n    float bottom = cos(st.y * 1000.0 * cos(iTime/2.0));\n    \n    color = top * bottom * left * vec3( cos(iTime)+st.x , cos(iTime)+ st.y, 1.0 ); \n    fragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 431]], "test": "ok"}
{"id": "lsjyDK", "name": "Testing Ray Marching", "author": "AceClover", "description": "From here: https://www.shadertoy.com/view/XsB3Rm", "tags": ["testingraymarching"], "likes": 3, "viewed": 155, "published": "Public", "date": "1493903060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct result{\n float dist;\n vec3 color;\n};\n\n// ray marching\nconst int max_iterations = 256;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.02;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat myTime;\n\nvec3 getColor(float _material){\n     \tif(_material == 0.0){\n         \treturn vec3(1, 0, 1);   \n        }\n        else  if(_material == 1.0){\n         \treturn  vec3(1, 1, 0);   \n        }\n        else if(_material == 2.0){\n         \treturn vec3(1, 0, 0);   \n        }\n        else if(_material == 3.0){\n         \treturn vec3(0, 1, 0);   \n        }\n        else if(_material == 4.0){\n         \treturn vec3(0, 0, 2);   \n        }\n       else if(_material == 5.0){\n         \treturn vec3(0.2, 1, 0.5);   \n        }\n    \n    return vec3(0);\n}\n\n\n// iq's distance function\nresult sdSphere( vec3 pos, float r, float _m ) {\n\treturn result( length( pos ) - r, getColor(_m)) ;\n}\n\nresult sdBox( vec3 p, vec3 b, float _m ) {\n  vec3 d = abs(p) - b;\n  return result(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), getColor(_m));\n}\n\n\n\nresult minWithMaterial(float _d1, float _m1, float _d2, float _m2){\n    if(_d1 < _d2){\n     return result(_d1, getColor(_m1));   \n    }\n    return result(_d1, getColor(_m2));\n}\n   \n    \nresult minWithMaterial(vec2 _o1, vec2 _o2){\n    return minWithMaterial(_o1.x, _o1.y, _o2.x, _o2.y);\n}\n\nresult minWithMaterial(float _d1, float _m1, vec2 _o2){\n    return minWithMaterial(_d1, _m1, _o2.x, _o2.y);\n}\n\nresult minWithMaterial(vec2 _o1, float _d2, float _m2){\n    return minWithMaterial(_o1.x, _o1.y, _d2, _m2);\n}\n\nresult minWithMaterial(result a, result b){\n    if(a.dist < b.dist){\n        return a;\n    }\n    return b;\n}\n\n\n\nfloat k = 10.0;\nresult smin( float _d1, float _m1, float _d2, float _m2, bool blend)\n{\n    float res = exp( -k*_d1 ) + exp( -k*_d2 );\n    float d = -log( res )/k;\n    return result(d, abs(_d1-d) > abs(_d2-d) ? getColor(_m2) : getColor(_m1));\n}\n\nresult smin( vec2 a, vec2 b, bool blend )\n{\n    return smin(a.x, a.y,b.x, b.y, blend);\n}\n\nresult smin( vec2 a, float b, float _m2, bool blend )\n{\n    return smin(a.x, a.y,b, _m2, blend);\n}\n\nresult smin( float a, float _m1, vec2 b, bool blend )\n{\n    return smin(a, _m1,b.x, b.y, blend);\n}\n\nresult smin(result a, result b, bool blend){   \n    \n    float res = exp( -k*a.dist ) + exp( -k*b.dist );\n    float d = -log( res )/k;    \n    vec3 color;\n    \n    if( abs(a.dist-d) > abs(b.dist-d) ){\n    \t color =  (a.color*(1.0-a.dist/(a.dist + b.dist))) + (b.color*(a.dist/(a.dist + b.dist)));    \n    }\n    else{ \n        color =  (b.color*(1.0-b.dist/(a.dist + b.dist))) + (a.color*(b.dist/(a.dist + b.dist)));    \n    }\n    \n    if(blend){ \n        return result(d, color);    \n    }\n    else{\n        return result(d, abs(a.dist-d) > abs(b.dist-d) ? b.color :a.color);    \n    }\n}\n\nresult smin(result a, result b){ \n    return smin(a,b,false);  \n}\n\nresult myMax( float _d1, float _m1, float _d2, float _m2 )\n{\n    if(_d1 > _d2){\n        return result(_d1, getColor(_m1));\n    }\n    return result(_d2, getColor(_m2));\n}\n\nresult myMax( vec2 a, vec2 b )\n{    \n    return myMax(a.x, a.y, b.x, b.y);\n}\n\nresult myMax( vec2 a, float b, float _m2 )\n{\n    return myMax(a.x, a.y,b, _m2);\n}\n\nresult myMax( float a, float _m1, vec2 b )\n{\n    return myMax(a, _m1,b.x, b.y);\n}\n\nresult myMax(result a, result b){   \n    if(a.dist > b.dist)\n \t\treturn  result(a.dist, (a.color*(1.0-a.dist/(a.dist + b.dist))) + (b.color*(a.dist/(a.dist + b.dist))));\n    return  result(b.dist, (b.color*(1.0-b.dist/(a.dist + b.dist))) + (a.color*(b.dist/(a.dist + b.dist))));    \n}\n\n// get distance in the world\nresult dist_field( vec3 pos ) {\n        \n    result box = sdBox( pos, vec3(0.5) + sin(myTime*2.0)/35.0, 4.0);    \n    box = myMax( box.dist, 4.0, -sdSphere( pos, 0.6, 0.0).dist +  cos(myTime*3.0)/35.0, 4.0 );\n    \n    result sphereInside = sdSphere( pos + vec3( sin(myTime*4.0) ,0.0,0.0), 0.25 ,1.0) ;    \n    \n    result boxVerticalInside =  sdBox( pos + vec3(0.0, cos(myTime*4.0),0.0), vec3(0.25),2.0) ;\n    boxVerticalInside = minWithMaterial(boxVerticalInside,sdSphere( pos + vec3(0.0, cos(myTime*4.0),0.0), 0.3 + sin(myTime*5.0)*0.015 ,3.0));    \n    \n    result boxHorizontalLoop =  sdBox( pos + vec3(cos(myTime*4.0),0.0, sin(myTime*4.0)), vec3(0.25) ,3.0) ;\n   \n    \n    boxHorizontalLoop = myMax(boxHorizontalLoop.dist,boxHorizontalLoop.color.x, -sdSphere( pos + vec3(cos(myTime*4.0),0.0, sin(myTime*4.0)), 0.3 + sin(myTime*5.0)*0.015, 0.3 ).dist, 0.3);        \n            \n    result sphereVerticalLoop =  sdBox( pos + vec3(0.0, sin(myTime*4.0), cos(myTime*4.0)), vec3(0.25) ,4.0) ;\n    sphereVerticalLoop = myMax(sphereVerticalLoop.dist, 5.0, sdSphere( pos + vec3(0.0, sin(myTime*4.0), cos(myTime*4.0)), 0.3 + sin(myTime*5.0)*0.015, 0.3 ).dist, 0.3);    \n  \n    \n  \treturn smin(box, smin(sphereInside, smin(boxVerticalInside, smin(boxHorizontalLoop,sphereVerticalLoop))));\n\n    //return minWithMaterial(box, minWithMaterial(sphereInside, minWithMaterial(boxVerticalInside, minWithMaterial(boxHorizontalLoop,sphereVerticalLoop))));\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ).dist - dist_field( pos - dx ).dist,\n\t\t\tdist_field( pos + dy ).dist - dist_field( pos - dy ).dist,\n\t\t\tdist_field( pos + dz ).dist - dist_field( pos - dz ).dist\t\t\t\n\t\t)\n\t);\n}\n\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye, vec3 _material ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.3, 0.7, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \t\t\n\t\tfinal +=  (_material*0.5) + light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n\n// ray marching\nresult ray_marching( vec3 origin, vec3 dir, float start, float end ) {    \t\n    float depth = start;  \n\tfor ( int i = 0; i < max_iterations; i++ ) {        \n        vec3 p = origin + dir * depth;        \n        \n        result evaluate = dist_field( p );        \n        \n\t\tfloat dist =evaluate.dist / length( gradient( p ) );\n        \n\t\tif ( abs( dist ) < stop_threshold ) {\n\t\t\treturn result(depth, evaluate.color);\n\t\t}\n\t\tdepth += dist * 0.9;\n\t\tif ( depth >= end) {\n\t\t\treturn result(end, evaluate.color);\n\t\t}\n\t\t\n\t}\n\n\treturn result(end, getColor(-1.0));\n}\n\n\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n        myTime = iTime/2.0;\n    \n        \n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 +sin(myTime) *0.0 );\n    \n    \n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n    \n    // ray marching\n\tresult depth = ray_marching( eye, dir, 0.0, clip_far );          \n    \n\tif (  depth.dist >= clip_far ) {\n\t\tfragColor = vec4( 0.3, 0.4, 0.5, 1.0 );\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth.dist;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye, depth.color ), 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 315, 315, 820], [823, 849, 897, 897, 950], [952, 952, 994, 994, 1103], [1107, 1107, 1174, 1174, 1283], [1293, 1293, 1336, 1336, 1394], [1396, 1396, 1451, 1451, 1505], [1507, 1507, 1562, 1562, 1616], [1618, 1618, 1661, 1661, 1726], [1746, 1746, 1816, 1816, 1973], [1975, 1975, 2018, 2018, 2063], [2065, 2065, 2120, 2120, 2163], [2165, 2165, 2220, 2220, 2263], [2265, 2265, 2309, 2309, 2852], [2854, 2854, 2886, 2886, 2919], [2921, 2921, 2981, 2981, 3090], [3092, 3092, 3124, 3124, 3168], [3170, 3170, 3214, 3214, 3251], [3253, 3253, 3297, 3297, 3334], [3336, 3336, 3369, 3369, 3619], [3621, 3650, 3681, 3681, 5093], [5095, 5124, 5151, 5151, 5515], [5518, 5535, 5593, 5619, 6479], [6482, 6498, 6568, 6568, 7054], [7058, 7079, 7127, 7127, 7303], [7306, 7338, 7369, 7369, 7525], [7528, 7528, 7585, 7585, 8285]], "test": "timeout"}
{"id": "lslBWr", "name": "MandelBrötchen", "author": "goanautix", "description": "MandelBrot set and deform Formular for 2d Space;", "tags": ["mandelbrot", "2dfractal"], "likes": 1, "viewed": 97, "published": "Public", "date": "1496225381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tH (iTime*0.5)\n#define tD (iTime*5.0)\n#define PI 3.1415926535\n// press F key to select the deform Formular\n#define fKey (texture(iChannel3, vec2(0.274509804, 0.25)).x)\n// press D key to map iChannel0 in the fractal\n#define dKey (texture(iChannel3, vec2(0.266666667, 0.25)).x)\n// press S key to show inside the fractal \n#define sKey (texture(iChannel3, vec2(0.325490196, 0.25)).x)\n// press A key to show the fractal on other ways\n#define aKey (texture(iChannel3, vec2(0.254901961, 0.25)).x)\n//------------------------------------------------------------------------>\n//\tsqrt(a^2 + b^2) = c == radius = length(a,b)\nfloat rr(vec2 uv){ \n    return (length(uv));\n    //\t   (sqrt((uv.x*uv.x)+(uv.y*uv.y)));\n}\n//  atan(a/b) = phi == angle\nfloat phi(vec2 uv){ return atan(uv.x/uv.y);}\n//  atan(b/a) = O == ?? \nfloat O(vec2 uv){ return atan(uv.y/uv.x);}\n//------------------------------------------------------------------------>\n// deform UV\nvec2 v1(vec2 uv){return vec2(sin(uv.x),sin(uv.y));}\nvec2 v2(vec2 uv){float r = rr(uv);r*=r;return (1.0/(r))*uv;}\nvec2 v3(vec2 uv){float r = rr(uv);r*=r; return vec2(uv.x*sin(r)-uv.y*cos(r),uv.x*cos(r)-uv.y*sin(r));}\nvec2 v4(vec2 uv){float r = rr(uv);return vec2((1.0/r)*(uv.x-uv.y)*(uv.x+uv.y),2.0*uv);}\nvec2 v5(vec2 uv){float r = rr(uv);float o = O(uv); return vec2(o/PI,r-1.0);}\nvec2 v6(vec2 uv){float r = rr(uv);float o = O(uv); return r*vec2(sin(o+r),cos(o-r));}\nvec2 v7(vec2 uv){float r = rr(uv);float o = O(uv); return r*vec2(sin(o*r),-cos(o*r));}\nvec2 v8(vec2 uv){float r = rr(uv);float o = O(uv); return (o/PI)*vec2(sin(PI*r),cos(PI*r));}\nvec2 v9(vec2 uv){float r = rr(uv);float o = O(uv); return (1.0/r)*vec2(cos(o)+sin(r),sin(o)-cos(r));}\nvec2 v10(vec2 uv){float r = rr(uv);float o = O(uv); return vec2(sin(o)/r,r*cos(o));}\nvec2 v11(vec2 uv){float r = rr(uv);float o = O(uv); return vec2(sin(o)*cos(r),cos(o)*sin(r));}\nvec2 v12(vec2 uv){float r = rr(uv);float o = O(uv);\treturn vec2(sin(r) / o, cos(o) / r); }\nvec2 v13(vec2 uv){float r = rr(uv);float o = O(uv);\treturn vec2(sin(ceil(r) / o), cos(ceil(o) / r)); }\nvec2 v14(vec2 uv){float r = rr(uv);float o = O(uv);\treturn vec2(r - o, o - r); }\nvec2 v15(vec2 uv){float r = rr(uv);float o = O(uv);\treturn uv / vec2(cos(r / o * PI), sin(o / r * PI)); }\nvec2 v16(vec2 uv){float r = rr(uv);float o = O(uv);\treturn uv * vec2(sin(r / o * PI), sin(o / r * PI)); }\n//------------------------------------------------------------------------>\n// mandelbrot whit diffrent break conditions\nfloat fractal(vec2 p, int ma){\n    vec2 f = p;\n    for (int i=0;i<ma;i++){\n    \tfloat x = f.x*f.x - f.y*f.y + p.x;\n        float y = f.x*f.y + f.x*f.y + p.y;\n        //if(x*y*p.x*p.y>=4.0){return 1.0;}\n        //if(length(f)>4.0){return 1.0;}\n        //if(length(f)>4.0){break;}\n        //if(dot(f,f)>=4.0){break;}\n    \tf = vec2(x,y);\n    }\n    f*=mat2(cos(tD),sin(tD),-sin(tD),cos(tD)); // rotate the Mandelbrot\n\treturn (sKey>0.5) ? ((aKey>0.5) ? 1.0-length(f*p)*0.9\n                         \t\t\t: 1.0-length(p-f)*0.9 )\n        \t\t\t  : ((aKey>0.5) ? f.x/f.y-length(f)*9.0\n                         \t\t\t: f.x*f.y-length(f)*2.0 );// *2 = clear // *0 = not clear\n}\n// Shuffle the iChannel0 on the mandelbrot\nvec4 fractalTex(vec2 p, int ma){\n    vec2 f = p;\n    \n    for (int i=0;i<ma;i++){\n    \tfloat x = f.x*f.x - f.y*f.y + p.x;\n        float y = f.x*f.y + f.x*f.y + p.y;\n        //if(x*y*p.x*p.y>=4.0){return vec4(0.0,0.0,0.0,1.0);}\n        //if(length(f)>4.0){return vec4(0.0,0.0,0.0,1.0);}\n        //if(length(f)>3.0){break;}\n        if(dot(f,f)>4.0){break;}\n        f = vec2(x,y);\n    }\n    f*=-mat2(cos(tH),sin(tH),-sin(tH),cos(tH));\n\treturn texture(iChannel0, f);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    uv.x*= iResolution.x/iResolution.y;\n    //uv.y+= 0.1;\n    //uv*=mat2(0.0,-1.0,1.0,0.0);// 90° rotation\n   // uv.y *= (uv.x< 0.0) ? -1.0 : 1.0;\n    uv*=30.0 * ((iMouse.y == 0.0) ? 1.0 : (iMouse.y/iResolution.y));\n    vec2 iv = (uv.x<0.0) ? vec2(uv.x,uv.y*-1.0) : uv ;// invert y if x<0\n  \t//-----------------\n    // 1/17 = 0.0833333333 \n    float fPart = 0.0588235294;\n    float t = fract(((fKey>0.5) ? ((iMouse.x == 0.0) ? 1.0 : (iMouse.x/iResolution.x))*17.0 : tD ) * fPart); //t = 0-1 in 24 sec\n    // select next formular every 2 sec \n    uv = (t<fPart) \t\t? v1(uv) \t: \n    \t (t<fPart*2.0) \t? v2(uv) \t: \n    \t (t<fPart*3.0) \t? v3(uv) \t: \n         (t<fPart*4.0) \t? v4(uv) \t: \n    \t (t<fPart*5.0) \t? v5(iv) \t: \n    \t (t<fPart*6.0) \t? v6(iv) \t: \n         (t<fPart*7.0) \t? v7(iv) \t: \n    \t (t<fPart*8.0) \t? v8(iv) \t: \n    \t (t<fPart*9.0) \t? v9(iv) \t: \n         (t<fPart*10.0) ? v10(iv) \t: \n    \t (t<fPart*11.0)\t? v11(iv) \t: \n    \t (t<fPart*12.0)\t? v12(iv) \t: \n    \t (t<fPart*13.0)\t? v13(iv) \t: \n    \t (t<fPart*14.0)\t? v14(iv) \t: \n    \t (t<fPart*15.0)\t? v15(iv) \t:  \n    \t (t<fPart*16.0)\t? v16(uv) \t: uv ;\n    //uv.x=-abs(-uv.x);\n    //uv.y=abs(uv.y);\n    //-----------------\n    float f = fractal(uv,6);\n    // uv.y=-abs(uv.y);\n    vec4 fTex = fractalTex(uv,6);\n    fragColor = vec4(((dKey > 0.5) ? fTex.xyz : vec3(f)),1.0);\n\t//fragColor = (fTex.x != 0.0) ? vec4(fTex) : vec4(vec3(0.3,0.1,0.0)*(1.0-length(uv*0.2)),1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslBWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 621, 639, 639, 710], [711, 740, 759, 759, 784], [785, 810, 827, 827, 852], [853, 942, 959, 959, 993], [994, 994, 1011, 1011, 1054], [1055, 1055, 1072, 1072, 1157], [1158, 1158, 1175, 1175, 1245], [1246, 1246, 1263, 1263, 1322], [1323, 1323, 1340, 1340, 1408], [1409, 1409, 1426, 1426, 1495], [1496, 1496, 1513, 1513, 1588], [1589, 1589, 1606, 1606, 1690], [1691, 1691, 1709, 1709, 1775], [1776, 1776, 1794, 1794, 1870], [1871, 1871, 1889, 1889, 1961], [1962, 1962, 1980, 1980, 2064], [2065, 2065, 2083, 2083, 2145], [2146, 2146, 2164, 2164, 2251], [2252, 2252, 2270, 2270, 2357], [2358, 2479, 2509, 2509, 3137], [3138, 3181, 3213, 3213, 3645], [3646, 3646, 3703, 3703, 5175]], "test": "error"}
{"id": "lslfDH", "name": "\"Supernova remnant\" by Duke", "author": "psygnisfive", "description": "Just a minor tweak of Duke's, to cycle through a parameter value. Looks pretty cool.", "tags": ["supernova"], "likes": 18, "viewed": 365, "published": "Public", "date": "1496119954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Supernova remnant\" by Duke\n// https://www.shadertoy.com/view/MdKXzc\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" (https://www.shadertoy.com/view/MsVXWW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(vec3 p)\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.9;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = Disk(p.xzy,vec3(2.0,1.8,1.25));\n    final += fbm(p*90.);\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*3.0;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.5*sin(iTime*0.1)-0.4;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<64; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.0);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*10.)/80.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        //idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y*=120.;\n        uv.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uv.y,-uv.x+0.5*sin(4.*iTime+uv.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);\n        \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslfDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[894, 908, 934, 934, 1153], [1155, 1155, 1174, 1174, 1263], [1265, 1265, 1290, 1290, 1327], [1329, 1329, 1354, 1354, 1419], [1422, 1422, 1452, 1452, 1548], [1550, 2211, 2239, 2239, 2788], [2790, 2790, 2817, 2817, 2964], [2966, 2966, 2986, 2986, 3121], [3188, 3217, 3267, 3352, 3622], [3624, 3624, 3700, 3700, 3916], [3918, 4033, 4069, 4069, 4233], [4235, 4235, 4292, 4292, 7464]], "test": "error"}
{"id": "lslfRN", "name": "Dry Rocky Gorge", "author": "Shane", "description": "A simple canyon\\gorge fly-through. Not much different to the many other examples on here, but fun to make.", "tags": ["noise", "terrain", "clouds", "flythrough", "canyon", "gorge"], "likes": 99, "viewed": 5747, "published": "Public API", "date": "1495356173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tDry Rocky Gorge\n\t---------------\n\n\tThis is a very simple terrain example, and not much different to the many others on here. \n\tOverall, it's not that inspiring - After all, there are only so many ways you can render a\n\tterrain scene; Terrain, sky, fake normal-based ground coloring. Not much effort went into \n\tit. In fact, I probably spent more time choosing the ground texture and sky color than \n\tcreating the terrain. :) \n\n    I've been playing around with low-poly terrain lately, but believe it or not, using a modern\n\tmachine to emulate the way things looked on old machines isn't always as easy as you'd think. :)\n\tTherefore, I took a break and coded up a very cliche medium-level terrain fly-though.\n\n\tThe lighting is fudged in a lot of places - especially where the clouds are concerned, so I\n\twouldn't pay too much attention to it. In fact, you could ignore most of the code and just \n\tlook at the camera setup and distance function.\n\n\tThe geometry is very basic. Render a plane, carve out a squarish tube, wrap it around the\n\tcamera path, then add some noise layers to the result. Not much to it. For the terrain itself,\n\tI'd hoped to make use of IQ's gradient noise derivatives code, but speed was an issue, so I let \n\tit go. Maybe next time. :)\n\n\tThere wouldn't be much code here if it were not for the cloud layering routine that I dropped\n    in. It's only used for four layers, which meant the aesthetic returns were rather diminished, \n\tso it was hardly worth the effort.\n\n\tAnyway, I have a lot of more interesting examples than this that I hope to add at some point.\n\n\n*/\n\n#define FAR 80. // Maximum ray distance. Analogous to the far plane.\n//#define HIGHER_CAMERA // Gives a slightly more overhead view of the gorge.\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - See Nimitz's comment.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(sin(dot(p, vec3(157, 113, 7)))*45758.5453); }\n\n// vec3 to float hash.\nfloat hash21( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I put this together, so be \n// careful how much you trust it. :D\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n \n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); //p *= p*p*(p*(p*6. - 15.) + 10.);    \n    \n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n\n}\n \n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Straight path.\n    return vec2(sin(z*.075)*8., cos(z*.1)*.75); // Windy path.\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec2 tri(in vec2 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n/*\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n*/\n\n// Basic terrain - in the form of noise layering. How it's approached depends on the desired outcome, but\n// in general you add a layer of noise, vary the amplitude and frequency, then add another layer, and so\n// on. Other additions include skewing between layers (which is done here) and attenuating the amplitudes\n// with the noise derivatives (For cost reasons, I left that out). Of course, you can do this with functions \n// other than noise, like Voronoi, sinusoidal variations, triangle noise, etc.\nfloat terrain(vec2 p){\n    \n    p /= 8.; // Choosing a suitable starting frequency.\n    \n    // Edging the terrain surfacing into a position I liked more. Not really necessary though.\n    p += .5; \n\n    // Amplitude, amplitude total, and result variables.\n    float a = 1., sum = 0., res = 0.;\n\n    // Only five layers. More layers would be nicer, but cycles need to be taken into\n    // consideration. A simple way to give the impression that more layers are being added\n    // is to increase the frequency by a larger amount from layer to layer.\n    for (int i=0; i<5; i++){\n        \n        res += n2D(p)*a; // Add the noise value for this layer - multiplied by the amplitude.\n        //res += abs(n2D3(p) - .5)*a; // Interesting variation.\n        //res += n2D3(p)*abs(a)*.8; // Another one.\n        \n        // Scaling the position and doing some skewing at the same time. The skewing isn't \n        // mandatory, but it tends to give more varied - and therefore - interesting results.\n        // IQ uses this combination a bit, so I'll assume he came up with the figures. I've \n        // tried other figures, but I tend to like these ones as well.      \n        p = mat2(1, -.75, .75, 1)*p*2.72;\n        //p *= 3.2; // No skewing. Cheaper, but less interesting.\n        \n        sum += a; // I reasoned that the sum will always be positive.\n        \n        // Tempering the amplitude. Note the negative sign - a less common variation - which\n        // was thrown in just to mix things up.\n        a *= -.5/1.7; \n    }\n    \n   \n    return res/sum; // Return the noisy terrain value.\n    \n}\n\n \n\n// The gorge terrain setup up: It's just a flat plane with a channel cut out of it, which is\n// wrapped around the camera path. Then, a few layers of simple 2D noise is added to it.\nfloat map(vec3 p){\n    \n\n    // The noise layers.\n    float trSf = terrain(p.xz);\n \n    p.xy -= path(p.z); // Wrap the gorge around the path.\n\n    // The canyon - or gorge, which consists of a mixed circle and square shape, extruded along\n    // the path. It's been stretched, lowered, then subtracted from the flat plane, before adding\n    /// the noise layers.\n    vec2 ca = abs(p.xy*vec2(1, .7) + vec2(0, -2.75)); // Stretch and lower space.\n    \n    // Smoothly carve out the gorge from the plane, then add the noise to the result.\n    float n = smax(6. - mix(length(ca), max(ca.x, ca.y), .25), p.y - 1.75, 2.) + (.5 - trSf)*4.;\n\n\n    return n*.7; // Return the minimum hit point.\n \n}\n \n\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding why we perform this step. It's been a while, but I vaguely recall\n    // that it's some kind of orthogonal space fix using the Gram-Schmidt process. However, \n    // all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<160; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 48; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .02, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .15, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.002, -0.002); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 nor){\n\n\tfloat sca = 1.5, occ = 0.;\n    \n    for(float i=0.; i<5.; i++){\n        float hr = .01 + i*.5/4.;        \n        float dd = map(nor*hr + p);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n}\n\n\n\n\n// Distance function.\nfloat fmap(vec3 p){\n\n    // Three layers of noise. More would be nicer.\n    p *= vec3(1, 4, 1)/400.;\n    \n    return n3D(p)*0.57 + n3D(p*4.)*0.28 + n3D(p*8.)*0.15;\n}\n\n// Used in one of my volumetric examples. With only four layers, it's kind of going to waste\n// here. I might replace it with something more streamlined later.\nvec4 cloudLayers(vec3 ro, vec3 rd, vec3 lp, float far){\n    \n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*0.004-0.002)); \n    // Randomizing the length also. \n    rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.04-0.02); \n    \n    // Some more randomization, to be used for color based jittering inside the loop.\n    //vec3 rnd = hash33(rd+311.);\n\n    // Local density, total density, and weighting factor.\n    float ld=0., td=0., w=0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d=1., t=0.;\n    \n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n    \n    vec4 d4 = vec4(1, 0, 0, 0);\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<4; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if(td>1. || t>far)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = fmap(sp); // Closest distance to the surface... particle.\n        //d4 = fmap(sp); // Closest distance to the surface... particle.\n        \n        //d = d4.x;\n        //sn = normalize(d4.yzw);\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        ld = (h - d) * step(d, h); \n        w = (1. - td) * ld;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        //td += w*w*8. + 1./60.; //w*w*5. + 1./50.;\n        td += w*.5 + 1./65.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 100./(1. + lDist*0.005 + lDist*lDist*0.00005);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n        \n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations.\n        //col += w*(1. + diff*.5 + spec*.5)*atten;\n \n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        col += w*(diff + vec3(1, .75, .5)*spec + .5)*atten;//*1.25;\n        \n        // Optional extra: Color-based jittering. Roughens up the grey clouds that hit the camera lens.\n        //col += (fract(rnd*289. + t*41.)-.5)*0.02;;\n\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t += max(d4.x*.5, 0.25)*100.; //* 0.75\n        // t += 0.2; // t += d*0.5;// These also work, but don't seem as efficient.\n\n    }\n    \n    //t = min(t, FAR); //24.\n    \n    return vec4(col, t);\n        \n}\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp, float t){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.0); // Sun strength.\n\tfloat horiz = pow(1.0-max(rd.y, 0.0), 3.)*.25; // Horizon strength.\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .5, 1)*.8, vec3(.8, .75, .7), sun*.5);//.zyx;\n    // Mixing in the sun color near the horizon.\n\tcol = mix(col, vec3(1, .5, .25), horiz);\n    \n    //vec3 col = mix(vec3(1, .7, .55), vec3(.6, .5, .55), rd.y*.5 + .5);\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.25*vec3(1, .7, .4)*pow(sun, 5.0);\n\tcol += 0.25*vec3(1, .8, .6)*pow(sun, 64.0);\n\tcol += 0.15*vec3(1, .9, .7)*max(pow(sun, 512.0), .25);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.04 - 0.02, 0., 1.);\n    \n    //return col; // Clear sky day. Much easier. :)\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n \n    // If we haven't hit anything and are above the horizon point (there for completeness), render the sky.\n    \n    // Raytrace to a plane above the scene.\n    float tt = (1000. - ro.y)/(rd.y + .2);\n \n    if(t>=FAR && tt>0.){\n\n        // Trace out a very small number of layers. In fact, there are so few layer that the following\n        // is almost pointless, but I've left it in.\n        vec4 cl = cloudLayers(ro + rd*tt, rd, lp, FAR*3.);\n        vec3 clouds = cl.xyz;\n\n        // Mix in the clouds.\n        col = mix( col, vec3(1), clouds); // *clamp(rd.y*4. + .0, 0., 1.)\n    }\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n\n    // Object texture color.\n    vec3 tx = tex3D(iChannel0, p/8., n ); // Texture value. Pinkish limestone.\n    \n    // Hinting that there's some dry vegetation below. The flatter the surface (based on n.y), the greater \n    // the chance that something's growing on it. Physical trees would be much nicer, and I'm working on that,\n    // but for now, cheap trickery will have to suffice. :) By the way, take a look at IQ's \"Rainforest\"\n    // example for an amazing looking compromise.\n    vec3 gr = mix(vec3(1), vec3(.8, 1.3, .2), smoothstep(.5, 1., n.y)); \n    return mix(tx, tx*gr, smoothstep(.7, 1., (n.y)));\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n            // Advancing the ray origin, \"ro,\" to the new hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point.\n        vec3 sn = getNormal(sp);\n   \n        vec3 tx = sp;\n        //tx.xy -= path(tx.z);\n        sn = texBump(iChannel0, tx/2., sn, .15);\n        \n        // Shading. Shadows, ambient occlusion, etc.\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.25)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 3./(1. + lDist*0.005 + lDist*lDist*0.00005);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 64.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);//mix(sn, oSn, .75)\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    #ifdef HIGHER_CAMERA\n\tvec3 ro = vec3(0, 4, iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.05, .25);  // \"Look At\" position.\n    #else\n\tvec3 ro = vec3(0, 0, iTime*5.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.04, .25);  // \"Look At\" position.\n    #endif\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(8, FAR*.26, FAR*.52)*3.;\n    //vec3 lp = ro + vec3(0., 0, 4);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/16.);\n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp, t);\n    \n    \n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR); // t/FAR; \n\n    // Blend in the sky. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5);\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n   \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    //uv = sin(uv*r2(3.14159/6.)*3.14159*iResolution.y/1.5)*.1 + 1.;\n    //sceneColor *= uv.x*uv.y;\n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1745, 1933, 1953, 1953, 2011], [2013, 2036, 2059, 2059, 2118], [2120, 2143, 2166, 2166, 2221], [2223, 2267, 2287, 2287, 2396], [2398, 2531, 2549, 2549, 2895], [2898, 3138, 3157, 3157, 3400], [3405, 3471, 3519, 3519, 4022], [4024, 4124, 4146, 4188, 4258], [4532, 4581, 4619, 4619, 4714], [4893, 5399, 5421, 5421, 6996], [7001, 7183, 7201, 7232, 7871], [7877, 8063, 8123, 8123, 8960], [8964, 8997, 9027, 9027, 9242], [9245, 9546, 9599, 9716, 11012], [11406, 11478, 11506, 11622, 11772], [11777, 11929, 11966, 11966, 12212], [12217, 12239, 12258, 12310, 12404], [12406, 12566, 12621, 12988, 17215], [17217, 17256, 17310, 17310, 19400], [19405, 19475, 19511, 19571, 20163], [20165, 20303, 20361, 20417, 22284], [22287, 22287, 22343, 22371, 25233]], "test": "error"}
{"id": "lslfz4", "name": "my avatar", "author": "wutzhuhn", "description": "I used a signed distance field to render the general shape to a buffer, then in the second step I generate a normal based on the gradient and do some normal-based lighting. There is also some light grain added to the image to avoid banding in the light.", "tags": ["2d", "sdf", "normalmap", "signeddistancefield"], "likes": 2, "viewed": 171, "published": "Public", "date": "1495145271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define roundnes 0.025\n\nfloat merge(float a, float b) {\n\treturn max(min(a, b), roundnes) - length(max(vec2(roundnes) - vec2(a, b), vec2(0.0)));\n}\n\nfloat substract(float a, float b) {\n\treturn max(-a, b);\n}\n\nfloat intersect(float a, float b) {\n\treturn min(max(a, b), -roundnes) + length(max(vec2(roundnes) + vec2(a, b), vec2(0.0)));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float sa = sin(a), ca = cos(a);\n\treturn p * mat2(ca, -sa, sa, ca);\n}\n\nfloat circle(vec2 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat box(vec2 p, vec2 size) {\n\tvec2 d = abs(p) - size + roundnes;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - roundnes;\n}\n\nfloat shapeDist(vec2 p) {\n\treturn\n      intersect(\n        substract(\n          circle(p, 0.75),\n          merge(\n            min(\n              box(\n                rotate(p, PI / 6.0),\n                vec2(0.125, 1.25)),\n              min(\n                box(\n                  p,\n                  vec2(0.125, 1.25)),\n                box(\n                  rotate(p, -PI / 6.0),\n                  vec2(0.125, 1.25)))),\n              circle(p, 1.0))),\n        circle(\n          p - vec2(0.0, -1.25),\n          1.0));\n}\n\nfloat maskSharp(vec2 p) {\n    return clamp(shapeDist(p - vec2(0.0, 0.5)) * 400.0, 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p) {\n    return clamp((shapeDist(p - vec2(0.0, 0.5)) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p) {\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = fragCoord * 2.0 / iResolution.xx - 1.0;\n\n    vec3 lightPos = vec3(cos(iTime), sin(iTime), 1.0);\n    vec3 toLight = lightPos - vec3(p, 0.0);\n    vec3 normal = normalAt(p);\n    float shade = 0.3 + maskSharp(p) * 0.7;\n    vec3 color = vec3(clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight)) * shade;\n    vec3 noise = vec3((texture(iChannel0, p * 4.0).x - 0.5) / 32.0);\n\n\tfragColor = vec4(color + noise, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lslfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 71, 71, 161], [163, 163, 198, 198, 220], [222, 222, 257, 257, 348], [350, 350, 380, 380, 453], [455, 455, 491, 491, 521], [523, 523, 553, 553, 659], [661, 661, 686, 686, 1182], [1184, 1184, 1209, 1209, 1278], [1280, 1280, 1306, 1306, 1384], [1386, 1386, 1409, 1409, 1644], [1646, 1646, 1701, 1701, 2140]], "test": "error"}
{"id": "lssBz4", "name": "Satin", "author": "DonKarlssonSan", "description": "Full screen is best", "tags": ["noise"], "likes": 5, "viewed": 98, "published": "Public", "date": "1495140791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex 2D noise\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float xnoise = snoise(vec2(uv.x, iTime / 10.0 + 10000.0));\n    float ynoise = snoise(vec2(uv.y, iTime / 10.0));\n    vec2 t = vec2(xnoise, ynoise) + iMouse.xy / 100.0;\n    float s1 = snoise(uv + t/2.0 + snoise(uv + snoise(uv + t/4.0)));\n    float s2 = snoise(uv + s1);\n\tfragColor = vec4(s2, s2, s2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 116, 116, 155], [157, 157, 178, 178, 998], [1000, 1000, 1057, 1057, 1409]], "test": "ok"}
{"id": "lssBzr", "name": "[ #16 ] - Fractal gem", "author": "Yrai", "description": "Playing with fractals (first successful experiment). A lot more to be understood :) ", "tags": ["3d", "raymarching", "fractal", "glow"], "likes": 16, "viewed": 901, "published": "Public API", "date": "1494700435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res_           iResolution\n#define time_          iTime\n#define pi_            3.14159265\n#define tau_           2.*pi_\n\n#define dom(f,s)             (2. * f.xy - res_.xy) / res_.y * s\n#define ry(a)                mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define rz(a)                mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.)\n\n#define march_steps_         1250\n#define max_range_           2048.\n\n#define hit_perc_            .0001\n#define grad_perc_           .001\n#define dist_perc_           .9\n\n#define rot_speed_           .22\n#define fractal_iters_       6\n#define fractal_divergence_  2140.\n\n\nfloat de(vec3 p);\nvec3  normal(vec3 p);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\n\n\nvoid mainImage(out vec4 o, vec2 f) {\n\t// Domain x -> [-2., 2.]; y-> [-1., 1.]  & xn, yn -> [0., 1.]\n    // -----------------------------------------------------------\n    vec2 p  = dom(f, 1.); vec2 np = f / res_.xy;\n    \n    // Camera\n    // -----------------------------------------------------------\n    vec3 ro = vec3(0., 1.2, 1.4); vec3 target = vec3(0.);\n    mat3 lam = look_at(ro, target, 0.);    \n\tvec3 rd = normalize(lam * vec3(p.xy, .5));\n    \n    // Raytracing\n    // -----------------------------------------------------------\n    vec3 pos, nor = vec3(0.);\n    float d, step_, iters = 0.;\n    for(int i = 0; i < march_steps_; i++) {\n        pos    = ro + step_ * rd;\n        d      = de(pos);\n        step_ += d * dist_perc_;\n        iters++;\n    \tif(d < hit_perc_ || d > max_range_) break;    \n    }\n    \n    vec3 c = vec3(.0);\n    if(d < hit_perc_) {\n    \t// Obtain hit pos and normal\n        // --------------------------------------------------------\n        pos = ro + step_ * rd;\n        nor = normal(pos);\n\n        // Lightning\n        // --------------------------------------------------------\n        vec3 lg = vec3(0.345);\n        float diff = clamp(0., 1., 1. + dot(rd, nor) );\n        float spec = clamp(0., 1., dot(nor, lg) );\n        float lm = diff + .4*spec;\n        \n        // Shading\n        // --------------------------------------------------------\n        vec3 mat = vec3(1.9, .5 + clamp(0., 1., pos.y), .1);\n        mat.b += fract(length(nor))*length(rd);\n        c = mix(c, mat, lm);\n    }\n    else {\n    \t// Missed fractal\n        // ---------------------------------------------------------\n        c = smoothstep(0.5, 1.7, abs(vec3(log(log(iters)) - .7 * vec3(2., .4, .3))));\n    }\n        \n    \n    // Post-processing\n    // ----------------------------------------------------------------\n    c = pow(c, vec3(2.5));\n    \n    o = vec4(c, 1.);\n}\n\nvec2 zcos(vec2 z) {\n    vec2 d = vec2(exp(z.y), exp(-z.y));\n \treturn vec2(cos(z.x) * (d.x+d.y)*.5, -sin(z.x) * (d.x-d.y)*.5);\n}\n\nfloat de(vec3 p) {\n   \tp *= ry(time_ * rot_speed_) * rz(time_ * rot_speed_);\n    \n    vec3  c  = vec3(0.);\n    float r  = length(p);\n\tfloat dr = 1.;\n\n\tfor(int i = 0; i < fractal_iters_; i++){\n\t\tif(r > fractal_divergence_)\n            break;\n\t\t\n        float psi = abs(mod(atan(p.z ,p.y) + pi_/4., pi_/4.) - pi_/8.);\n\t\tp.yz = vec2(cos(psi), sin(psi)) * length(p.zy);\n\t\t\n        vec3 p2 = p * p;\n\t\tp = vec3(vec2(p2.x - p2.y, 1.5 * p.x * p.y), 2.*p.z * sqrt(p2.x + p2.y)) + c;\t\n        \n\t\tdr *= 1. / r + 2.*r;\n        r   = 1.2*length(p);\n\t}\n    \n\treturn log(r) * r / dr;    \n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(grad_perc_, .0);\n    return normalize(vec3(\n        de(p+e.xyy)-de(p-e.xyy),\n        de(p+e.yxy)-de(p-e.yxy),\n        de(p+e.yyx)-de(p-e.yyx)\n    ));\n}\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[712, 712, 748, 878, 2597], [2599, 2599, 2618, 2618, 2726], [2728, 2728, 2746, 2746, 3302], [3304, 3304, 3325, 3325, 3495], [3497, 3497, 3541, 3541, 3714]], "test": "ok"}
{"id": "lsScDd", "name": "Lissajous experiment", "author": "jes5199", "description": "can we do oscilloscope shapes in GL? of course we can.", "tags": ["oscilloscope", "waveform", "lissajous"], "likes": 3, "viewed": 159, "published": "Public", "date": "1494355038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 0.01 * (fragCoord.xy - iResolution.xy/2.) / iResolution.y * 300.;\n    float pi = cos(-1.);\n    \n    float interval = 7.;\n    \n    float base = 440.;\n    float xhz = base;\n    float yhz = base * pow(pow(2., 1./12.), interval); //3./2.;\n    float zhz = base * 4./2.;\n    \n    float value = 1.;\n    float zval = 0.;\n    \n    vec3 uv3 = vec3(uv, 0);\n    vec3 color = vec3(0,0,0);\n    \n    for(int i = 0; i<50; i++){\n        float t = iTime - float(i)/base;\n\n        vec3 signal = vec3(\n            sin(t * 2.*pi * xhz),\n            sin(t * 2.*pi * yhz),\n            sin(t * 2.*pi * zhz)\n        );\n    \n        if( distance(signal.xy * 50., uv * 50.) < 2.){\n            float depth = signal.z;\n            \n            color = color + vec3(\n                depth * 2.,\n                (1. - abs(depth)) * 2.,\n                -depth * 2.\n            ) + 0.5;\n        }\n    }\n\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsScDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 980]], "test": "ok"}
{"id": "lssfDr", "name": "BW Raster Effect", "author": "Jpg3D", "description": "This was my really first shader here but it was hidden. I was just trying to create a retro stylish environment.\nThanks to the community.\nYou helped me to learn a lot!", "tags": ["25d", "raster"], "likes": 1, "viewed": 68, "published": "Public", "date": "1495796184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float mscroll=uv.x+cos(iTime*1.0)*0.25;\n    float fscroll=cos(iTime*1.0)*0.25;\n    float absolutx=abs((fscroll+uv.x-0.5)/(-uv.y+0.5));\n         uv.x *=iResolution.x/iResolution.y;\n\n\n    absolutx=fract(1.45-absolutx*1.5);\n\n \n    \n\tabsolutx=round(absolutx-0.38);\n    //absolutx=pow(1.5,((-uv.y*0.55)+absolutx*1.8)*2.0);\n    float sky;\n    float hlines;\n    float vlines;\n    if(uv.y<0.5){\n    //hlines=fract(pow((uv.y*1.0)+0.75,10.0)+iTime);\n    hlines=fract((1.0/(0.6-uv.y)+iTime));\n    \n    }else{\n    hlines=0.0;\n    absolutx=0.0;\n        \n    float skyx=(+cos(mscroll*4.0+4.0)*1.3+(uv.y+0.35)*6.28)*0.25+\n        (+cos(mscroll*12.0+0.8)*1.3+(uv.y+0.35)*6.28)*0.25+\n        (+cos(mscroll*18.0+1.2)*1.3+(uv.y+0.35)*6.28)*0.25+\n        (+cos(mscroll*13.0+1.4)*1.3+(uv.y+0.35)*6.28)*0.25;\n\n        \n\tsky=round((cos(skyx)-0.4995));\n    }\n    hlines=round(hlines-0.35);\n    float end= (hlines+absolutx)+sky;\n    \n    //end=absolutx;\n\tfragColor = vec4(end,end,end,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1085]], "test": "ok"}
{"id": "lssfWn", "name": "superstar", "author": "nshelton", "description": "raymach tunnel", "tags": ["tunnel", "raymarch", "star"], "likes": 4, "viewed": 640, "published": "Public API", "date": "1495769495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat time = 0.1;\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat map(vec3 p)\n{\n\n    vec3 q = p;\n\n    float rep = 0.1;\n    vec3 c = vec3(rep);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n\n    \n    vec3 p_s;\n    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), sin(q.z  +iTime) + sin(iTime/10.0));\n\n    float inner = 1000.0;\n    float outer = 1000.0;\n    \n    \n    int sides = 5;\n    float angle = 3.1415 * 2.0 / float(sides);\n    \n    for ( int i = 0; i < sides; i ++)\n    {\n        \n        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));\n        \n       \tp_s += vec3(\n            cos(q.z)* 2.0,\n            sin(q.z)* 2.0,\n            -0.0);\n            \n       // p_s = p_s * rotationMatrix(vec3(0.0, 0.0, 1.0), 4.0 * angle * float(i));\n        \n        float rad = cos(q.z* 1.0 - iTime) * 0.5 + 0.6;\n        \n        outer = min(outer, length(p_s) - rad);  \n        \n        vec3 p_fac = p_s.yxz;\n        \n        p_fac += vec3(\n            sin(iTime + q.z)* 0.4 , \n            cos(q.z)* 0.9 , \n            0.1 * sin(q.z));\n        \n        float tt = 0.01 * sin(q.z * 10.0 + time * 10.0) + 0.01;\n        float facet = sdCylinder(p_fac, vec3(sin(q.z), tt, tt));\n            \n\n        inner = min(inner, facet);  \n\t\n        \n    }\n    \n    float result = min(outer, inner);   \n    return result;\n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = time;\n\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx) - map(p-e.yxx),\n\t\t\t\t\tmap(p+e.xyx) - map(p-e.xyx),\n\t\t\t\t\tmap(p+e.xxy) - map(p-e.xxy)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.5;\n    vec2 _p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 80; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d * 0.5 ;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 80.0);\n\n    if(hit)\n    col = pow(col, vec3(\n        0.2 + 0.5 * sin(p.z * 33.0),\n        0.7 + 0.5 * sin(p.z * 10.0),\n        0.6)).bgr;\n    \n    fragColor = vec4(sqrt(col), hit? length(p.xy) : 0.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 50, 50, 137], [139, 139, 172, 172, 198], [200, 200, 236, 236, 270], [273, 273, 318, 318, 790], [792, 792, 811, 811, 2031], [2033, 2033, 2079, 2079, 2099], [2102, 2102, 2134, 2134, 2309], [2312, 2312, 2369, 2369, 3148]], "test": "ok"}
{"id": "lssfz4", "name": "9/100", "author": "yahe", "description": "9/100", "tags": ["cloud"], "likes": 4, "viewed": 473, "published": "Public API", "date": "1495153421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.x;\n    \n    uv = rotate2D(uv, iTime/2.);\n    uv = 6.*uv;\n    float noise = fractalNoise2d(uv);\n    float plasma = noise*(sin(uv.x)+cos(uv.y))/.2 + .5;\n    \n    vec3 col = vec3(sin((plasma*.5)+iTime)+1.3,\n                    sin((plasma*.3+.4)+iTime)+1.3,\n                    sin((plasma*.2+.5)+iTime)+1.3);\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 164], [166, 245, 269, 269, 799], [801, 874, 905, 905, 1282], [1284, 1284, 1322, 1322, 1462], [1464, 1464, 1520, 1520, 1894]], "test": "ok"}
{"id": "lssfzr", "name": "Circle Drawing", "author": "Thejokemachine", "description": "basically just testing drawing of a circle", "tags": ["simplecircledrawing"], "likes": 0, "viewed": 64, "published": "Public", "date": "1494710850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mPos = iMouse.xy / iResolution.xy;\n    \n    \n    float thickness = .01f;\n    float radius = 0.1f;\n    vec4 backgroundColor = vec4(1,1,1,1);\n    vec4 circleColor = vec4(0,0,0,1);\n    \n\tfragColor = backgroundColor;\n    vec2 d = uv - mPos;\n    d.x *= 1.78f;\n    float distance = (d.x * d.x + d.y * d.y);\n    \n    if (distance >= radius - thickness / 2.f && distance <= radius + thickness / 2.f)\n    {\n        float angle = abs(degrees(atan(d.y, d.x)));\n        angle *= sin(iTime);\n        fragColor = circleColor;\n        fragColor.r = .5f-(angle / 180.f);\n        fragColor.g = 1.f-(angle / 180.f);\n        fragColor.b = angle / 180.f;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lssfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 751]], "test": "ok"}
{"id": "lsXBD8", "name": "Random Tiles", "author": "flewww", "description": "Some random tiles on ceil and floor.", "tags": ["3d", "tiles"], "likes": 1, "viewed": 480, "published": "Public API", "date": "1495882886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float floor_dist = 2.;\nconst float speed = 4.;\n\nconst int nvdr[256] = int[256](\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,\n    0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,\n    0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,\n    0,0,0,1,1,0,1,1,1,0,1,1,0,0,0,0,\n    0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,\n    0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,\n    0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,\n    0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n);\n\nvec2 rot(vec2 v, float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a)) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.*uv - 1.; // Center coordinates\n    uv.y *= iResolution.y / iResolution.x; // Fix display form factor\n    uv.xy = rot(uv.xy, sin(iTime)/2.);\n    \n    vec3 dir = normalize(vec3(uv, -1.));\n    float dst = abs(floor_dist/dir.y);\n    vec3 pos = vec3(0., 0., -1.) + dir * dst;\n    pos.z -= speed * iTime;\n    vec3 posf = fract(pos);\n    vec3 posi = floor(pos);\n    \n    float fcol;\n    vec4 vcol;\n    int tind = (int(-posi.z)%16)*16 + (int(posi.x)+8)%16;\n    if (nvdr[tind] == 1) {\n        vcol = vec4(0.7,1.,1.,0.);\n    } else {\n        fcol = fract((posi.x+123.)*.546 * (posi.z+789.)*.123);\n        vcol = vec4(fcol/2.,0.2,0.2,0.);\n    }\n    vcol = vcol*1.7/exp(dst/15.); // Fog\n    if (posf.x < .8 && posf.z < .8) {\n        fragColor = vcol;\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[681, 681, 708, 708, 764]], "test": "ok"}
{"id": "lsXBR7", "name": "11/100", "author": "yahe", "description": "11/100", "tags": ["sphere", "softshadow"], "likes": 3, "viewed": 442, "published": "Public API", "date": "1495307142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using iq's 3D template\n\n#define PI 3.14159265\n\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nfloat noise2(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise2(pos);\t\t\t\t\t// bottom left\n    float b = noise2(pos + vec2(1., 0.));\t// bottom right\n    float c = noise2(pos + vec2(1., 1.));\t// top right\n    float d = noise2(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\nvec3 doBackground( vec2 uv )\n{\n    uv *= .8;\n    uv.x = uv.x + 1.5;\n    float noise = fractalNoise2d(uv);\n    float plasma = .8*noise*(sin(uv.x)+cos(uv.y))/.2 + .5;\n    \n    vec3 col = vec3((sin(plasma)+1.)*.1,\n                    (sin(plasma+.2)+1.)*.1,\n                    (sin(plasma+.2)+1.)*.1);\n\n    return mix(col, vec3(0.25, 0.24, .45), 0.1);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat sdSphere( vec3 p )\n{\n    \n    float n = exp(noise(vec3(p * 5.))) ;\n    \n    return length(p) - (1.*( sin(iTime)/4. + 1.) + n * 0.13)*.9;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.078,0.1,0.3)+vec3(0.1 * (sin(iTime)+1.),0.03,0.05);\n}\n\nfloat gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    //vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    //vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    //float dif = max(dot(nor,lig),0.0);\n    //float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    //lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    //lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    //vec3 col = mal*lin;\n\n    \n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  view = normalize(-rd);\n    vec3  lig1 = normalize(vec3(1.0,0.7,0.9));\n    vec3  lig2 = normalize(vec3(1.0,0.9,0.9)*-1.);\n    vec3  lig3 = normalize(vec3(1.4,2.4,1.3));\n    \n    float spc1 = gaussianSpecular(lig1, view, nor, 0.95)*0.5;\n    float dif1 = max(0., orenNayarDiffuse(lig1, view, nor, -20.1, 1.0));\n    float sha1 = 0.0; if( dif1>0.02 ) sha1=calcSoftshadow( pos+0.01*nor, lig1 );\n    vec3  col1 = vec3(1.,4.2,2.);\n    lin += col1*spc1+dif1*col1*sha1;\n    \n    float spc2 = gaussianSpecular(lig2, view, nor, 0.95);\n    float dif2 = max(0., orenNayarDiffuse(lig2, view, nor, -20.1, 1.0));\n    float sha2 = 0.0; if( dif2>0.02 ) sha2=calcSoftshadow( pos+0.01*nor, lig2 );\n    vec3  col2 = vec3(2.0,1.05,1.55);\n    lin += col2*spc2+dif2*col2*sha2;\n\n    float spc3 = gaussianSpecular(lig3, view, nor, 0.95);\n    float dif3 = max(0., orenNayarDiffuse(lig3, view, nor, -20.1, 1.0));\n    float sha3 = 0.0; if( dif3>0.02 ) sha3=calcSoftshadow( pos+0.01*nor, lig3 );\n    vec3  col3 = vec3(0.50,1.05,2.15);\n    lin += col3*spc3+dif3*col3*sha3;\n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.05);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = sdSphere( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*sdSphere( pos + v1*eps ) + \n\t\t\t\t\t  v2*sdSphere( pos + v2*eps ) + \n\t\t\t\t\t  v3*sdSphere( pos + v3*eps ) + \n\t\t\t\t\t  v4*sdSphere( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = sdSphere(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground(p);\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1. );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 383, 466, 466, 585], [587, 818, 850, 850, 963], [965, 1044, 1068, 1068, 1602], [1604, 1677, 1708, 1708, 2085], [2087, 2087, 2117, 2117, 2438], [2440, 2440, 2463, 2463, 2499], [2501, 2501, 2524, 2524, 2893], [2899, 3181, 3207, 3207, 3325], [3327, 3680, 3725, 3725, 3797], [3799, 3799, 3910, 3910, 4062], [4064, 4064, 4191, 4191, 4666], [4879, 4879, 4963, 5449, 6872], [6874, 6874, 6924, 6924, 7342], [7344, 7344, 7376, 7376, 7792], [7794, 7794, 7842, 7842, 8269], [8271, 8271, 8335, 8335, 8513], [8515, 8515, 8572, 8572, 9776]], "test": "timeout"}
{"id": "lsXBWn", "name": "everyday 015/100", "author": "kalin", "description": "everyday 015/100", "tags": ["everyday"], "likes": 0, "viewed": 72, "published": "Public", "date": "1495605451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    \n    float bpm = 1.0 / 60.0 * 108.0;\n    float t = iTime;\n    float bt = t * bpm * 3.1415926535 * 2.0;\n    \n    fragColor.x = cos(bt);\n    \n    vec3 col0 = vec3(0.9, 0.6, 0.3);\n    vec3 col1 = vec3(0.9, 0.7, 0.3);\n    \n    fragColor.xyz = col0 * 0.5;\n    fragColor.xyz += col1 * pow(abs(cos(bt * 0.5)), 3.0) * 0.3;\n    \n    vec3 col2 = vec3(1.0, 1.0, 1.0);\n    \n    vec2 nuvd = nuv * vec2(cos(bt * length(nuv)), sin(bt * length(nuv) * 0.2));\n    \n    fragColor.xyz += col2 * (1.0 - length(nuvd));\n    \n    float s0 = texture(iChannel1, uv * 0.05 + vec2(sin(bt / 32.0) * 0.5, sin(bt / 96.0) * 0.2)).x;\n    s0 = pow(s0, 2.0);\n    s0 = step(pow(s0, 4.0), 0.001 * step(fract(bt), 0.1 * sin(bt) * length(nuv)));\n    s0 = s0 * pow(texture(iChannel0, vec2(0.1, 0.25)).x, 2.0) * 4.0;\n    \n    fragColor.xyz += col2 * s0 * 0.2;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dsXz7", "previewfilepath": "https://soundcloud.com/cleopatra-recs/play-that-funky-music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cleopatra-recs/play-that-funky-music", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 955]], "test": "error"}
{"id": "lsXfDr", "name": "Simple Sierpinski fractal", "author": "voidc", "description": "Sierpinski triangle created with the bitwise AND operation.", "tags": ["fractal"], "likes": 4, "viewed": 108, "published": "Public", "date": "1495658099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tTitle: Simple Sierpinski fractal\n\tTags: fractal\n\tDescription: Sierpinski triangle created with the bitwise AND operation.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = min(iResolution.x, iResolution.y);\n    vec2 p = fragCoord.xy - (iResolution.xy - size) / 2.0;\n    \n    vec3 col = vec3(0.0);\n    if(p.x >= 0.0 && p.y >= 0.0 && p.x < size && p.y < size) {\n        vec2 z = p / exp2(fract(iTime));\n    \tuint res = uint(z.x) & uint(z.y);\n        \n        vec3 fg = vec3(1.0, 0.0, 0.0);\n        vec3 bg = 1.5 * vec3(0.0, 0.0, 1.0) / log2(float(res));\n    \tcol = res == 0U ? fg : bg;\n    } \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 187, 187, 661]], "test": "ok"}
{"id": "lsXfRr", "name": "Quadratic map function", "author": "KylBlz", "description": "Anyone know of a resource or algorithm to UV parameterize a quadric surface so I can texture/displacement map it better?\nFunction at line 81: vec2 map(vec3 location, quadric q)", "tags": ["ray", "displacement", "quadric", "raytrace", "projection", "function", "trace"], "likes": 1, "viewed": 420, "published": "Public API", "date": "1494572427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GAMMA\t\t.5\n#define EXPOSURE\t1.\n\n//some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define minT(a) (a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec3max((tex(a, b).rgb * c))\n\n//Absorb, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, Refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, distance material\nstruct hit { vec3 l, n; float d; mat m; };\n//Origin, Direction, Color, current material\nstruct ray { vec3 o, d, c; mat m; };\n//location, coefficients c.xyz*L^2=-c.w, orientation, Material, id\nstruct qdr { vec3 l; vec4 c; mat3 o; mat m; int d; };\n\nconst float\teps = .0001, ieps = .9999,\n\t\t\tzfar = 100., sml = .001, isml = .999,\n\t\t\tpi_rcp = .3183098, pi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732051;\n\nconst mat nullMat = mat(v30, v30, v20, v20, 0., 0., 0);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, zfar, nullMat);\nconst vec2 nullT = vec2(zfar, 0.);\n\n\n////////////////////// Materials //////////////////////\nconst mat\n//conductor\n\t_air = mat(vec3(.99), vec3(.99), vec2(.01), vec2(.1), 1.0003, 0., 0),\n//dynamic materials\n  \t_mqdr = mat(v30, v30, v20, v20, -1., 0., 40),\n\t_dbg = mat(v30, v30, v20, v20, -1., 0., 99);\n\n\n////////////////////// Primitives //////////////////////\nqdr qdr0 = qdr(v30, vec4(eps,1.,1., -1.), mat3(1.), _mqdr, 30),\n    qdr1 = qdr(v30, vec4(1.,eps,1., -1.), mat3(1.), _mqdr, 31),\n    qdr2 = qdr(v30, vec4(1.,1.,eps, -1.), mat3(1.), _mqdr, 32);\n\n\n////////////////////// some tools //////////////////////\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n\tfloat a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n}\nvec3 norm3(sampler2D iChannel, in vec3 comp, in vec3 px, in vec2 uv) {\n\tfloat s01 = texComp(iChannel, uv + px.xy, comp), s21 = texComp(iChannel, uv + px.zy, comp),\n\t\ts10 = texComp(iChannel, uv + px.yx, comp), s12 = texComp(iChannel, uv + px.yz, comp);\n\tvec3 va = normalize(vec3(px.xy*4., s21 - s01)),\n\t\tvb = normalize(vec3(px.yx*4., s12 - s10));\n\treturn cross(va, vb).xzy;\n}\n\n\n////////////////////// Quadric functions //////////////////////\nfloat sd(in vec3 l, in qdr q) {\n    //this isnt actually the distance\n    return length(sqrt(q.c.xyz) * (l - q.l)) - sqrt(-q.c.w);\n}\nvec2 map(in vec3 l, in qdr q) {\n\t//https://en.wikipedia.org/wiki/Quadric#Projective_geometry ???\n    return (l.xz - l.y) - (q.l.xz - q.l.y) ;\n}\nvec3 nrm(in vec3 l, in qdr q) {\n    return normalize(q.c.xyz*q.c.xyz * (l - q.l));\n}\nseg rayseg(in ray r, in qdr q) {\n\tvec3 o = r.o - q.l;\n    float a = dot(q.c.xyz, r.d * r.d),\n    \t  b = dot(q.c.xyz * 2., o * r.d),\n    \t  c = dot(q.c.xyz, o * o) + q.c.w;\n    if (a != 0.) {\n        float h = b * b - 4. * a * c;\n        if (h < 0.) return nullSeg;\n        h = sqrt(h);\n        return seg(vec2(-b-h, -b+h) * (.5 / a), ivec2(q.d, -q.d));\n    }\n    return seg(vec2(-c / b), ivec2(q.d));\n}\n\n\n////////////////////// Trace functions //////////////////////\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\nvoid lt(inout hit o, in hit h) {\n\tif (h.d < o.d) o = h;\n}\n\n#define _trc(r, j) seg s = rayseg(r, j); float d = minT(s.t); vec3 l = r.o + r.d * d; return hit(l, nrm(l, j), d, j.m)\nhit trace(in ray r, in qdr o) { _trc(r, o); }\n\n#define _trcPOM(r, j) hit h = trace(r, o); if (h.d >= zfar) return h; sa += h.d*.01; vec3 l = v30; vec2 uvw = v20; float depth = 0., height = 0., ld = 0., mar = 0., p = heightScale * sa / -dot(r.d, h.n); p += ms * sign(p); for (int i = 0; i < 32; i++) { mar += p; l = h.l + r.d*mar; uvw = map(l, o); depth = -sd(l, o); height = heightScale - heightScale * texComp(heightMap, fract(uvw*scale), comp); if (depth > height || depth < 0.) break; ld = height - depth; } if (depth < height || depth < 0.) return nullHit; float cd = depth - height, lerp = 1. - clamp(ld / (ld + cd), 0., 1.); mar -= p*lerp; l = h.l + r.d*mar; h.l = l; h.d += mar; vec3 px = 1.0001 / iResolution.yyy * vec3(-1., 0., 1.); uvw = map(l, o) \nhit tracePOM(in ray r, in qdr o, in sampler2D heightMap, in vec3 comp, in float scale, in float heightScale) {\n    float ms = .05, sa = .05;\n    _trcPOM(r, o);\n\tmat3 rot = mat3(v30, nrm(l, o), v30);\n    basis(rot[1], rot[0], rot[2]);\n\th.n = norm3(heightMap, comp, px, fract(uvw*scale)) * vec3(-1., 1., -1.) * inverse(rot);\n\treturn h;\n}\n\n\n////////////////////// Scene //////////////////////\nhit traceScene(in ray r) {\n\thit ret = nullHit;\n    // sort by number of pixels that will be seen to reduce work\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n\t\t\tlt(ret, tracePOM(r, qdr0, iChannel0, vec3(1.,0.,0.), .1, 1.));\n    \t\tqdr0.l.y -= 10.;\n            qdr0.c.x += eps;\n            \n            lt(ret, tracePOM(r, qdr1, iChannel0, vec3(1.,0.,0.), .1, 1.));            \n    \t\tqdr1.l.x -= 10.;\n            qdr1.c.y += eps;\n            \n            lt(ret, tracePOM(r, qdr2, iChannel0, vec3(1.,0.,0.), .1, 1.));\n    \t\tqdr2.l.y -= 10.;\n            qdr2.c.z += eps;\n        }\n        qdr0.l.y += 50.;\n        qdr0.c.x -= eps*5.;\n        qdr0.l.z -= 10.;\n        \n        qdr1.l.x += 50.;\n        qdr1.c.y -= eps*5.;\n        qdr1.l.z -= 10.;\n        \n        qdr2.l.y += 50.;\n        qdr2.c.z -= eps*5.;\n        qdr2.l.x -= 10.;\n    }\n    return ret;\n}\n\n\n////////////////////// Dynamic material implementation //////////////////////\nmat mqdr(in ray r, inout hit h) {\n    float lp = 1000./(1.+h.d*h.d);\n    return mat(\n\t\tv30,\n\t\tvec3(max(.05*lp, lp*-dot(h.n, r.d))) * tex(iChannel1, (h.l.xz-h.l.y)*.1).rgb,\n\t\tv20, v20,\n\t\t_mqdr.r, 0., _mqdr.d);\n}\nmat dbg(in ray r, inout hit h) {\n    return mat(\n\t\tv30,\n\t\tmax(v30, h.n),\n\t\tv20, v20,\n\t\t_dbg.r, 0., _dbg.d);\n}\n\n//updates dynamic materials (ghetto, find better solution)\nvoid updateMaterials(inout hit h, in ray r) {\n\tif (h.m.d < 40) return;\n\telse if (h.m.d == _mqdr.d) h.m = mqdr(r, h);\n\telse if (h.m.d == _dbg.d) h.m = dbg(r, h);\n}\n\n//here we go\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n\t//update camera\n    float sg = sin(iTime*.5), cg = cos(iTime*.4);\n\tvec3 l = vec3(41.*cg, 21.*(1.-cg*sg), 31.*sg);\n    mat3 b = mat3(v30, v30, normalize(vec3(-25.) - l));\n    basis(b[2], b[0], b[1]);\n    vec3 d = b * normalize(vec3(uv, 1.));\n    \n    //begin tracing\n\thit res;\n\tray r = ray(l, d, _air.a, _air);\n\t//trace scene\n\tres = traceScene(r);\n\t//update dynamic materials\n\tupdateMaterials(res, r);\n\t\n    //material color\n\tvec3 final = r.c * res.m.e;\n    //sky color and fog\n    final = mix(final, vec3(.3,.7,1.)+max(-.3, dot(d, vec3(0., -sc45, sc45))), res.d*res.d*.00008);\n    float eye = clamp(pow(dot(uv, uv), 2.), 0., 1.);\n    fragColor = vec4(pow(final*EXPOSURE, vec3(GAMMA+eye)), 1.);\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1956, 2013, 2060, 2060, 2193], [2194, 2194, 2264, 2264, 2568], [2571, 2635, 2666, 2704, 2767], [2768, 2768, 2799, 2864, 2911], [2912, 2912, 2943, 2943, 2996], [2997, 2997, 3029, 3029, 3399], [3402, 3464, 3483, 3483, 3633], [3634, 3634, 3666, 3666, 3691], [3812, 3812, 3843, 3843, 3857], [4571, 4571, 4681, 4681, 4906], [4909, 4961, 4987, 4987, 5840], [5843, 5921, 5954, 5954, 6131], [6132, 6132, 6164, 6164, 6241], [6243, 6302, 6347, 6347, 6464], [6466, 6479, 6534, 6534, 7331]], "test": "error"}
{"id": "lsXfW4", "name": "OJ - Ljusfärd, scene 4", "author": "rammoskar", "description": "Full demo: https://www.youtube.com/watch?v=-helx-SxnJo", "tags": ["3d", "reflection", "lightning"], "likes": 15, "viewed": 434, "published": "Public", "date": "1496164399", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TIME mod(iTime, 26.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm;\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\n#define TEX 0.2\n#define SIZE 8.0\n#define PI 3.1415\n\n#define MAT_WALL 1.0\n#define MAT_SPIN 2.0\n#define MAT_GROUND 3.0\n\n\nvec2 ground(vec3 p) {\n\tp -= vec3(0,0,5);\n\tp.y += 10.0*TIME;\n\tfloat s = 1.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\n\tq.z += sin(p.x) * 0.5;\n\tq.z += sin(p.y) * 0.5;\n\tfloat d = udRoundBox(q, vec3(s * 0.3), s * 0.3);\n\treturn vec2(d, MAT_GROUND);\n}\n\nvec2 spin(vec3 p, vec3 rd, float dir) {\n\tp.x = p.x == 0.0 ? 0.00001 : p.x;\n\n\tfloat len = length(p.xy);\n\tfloat lenSize = 6.0;\n\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\tfloat lenPart = floor(len / lenSize);\n\tif (lenPart < 0.5 || lenPart > 2.5) {\n\t\treturn vec2(99999,  MAT_SPIN);\n\t}\n\tfloat angle = atan(p.y, p.x);\n\tfloat numParts =  floor( 5.5*lenPart);\n\tfloat partSize = PI / numParts;\n\tangle += PI;\n\tfloat r = dir * sign(cos(lenPart*PI))* TIME * 0.4 / lenPart;\n\tfloat part = floor(mod(angle + r + (lenPart < 1.5 ? partSize / 2.0 : 0.0), PI * 2.0) / partSize);\n\n\tangle = mod(0.3*lenPart + angle + r, partSize) + partSize * 0.5 * max(0.0, numParts - 1.0);\n\n\n\tvec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\tfloat d = sdSphere(newPos, 1.0);\n\treturn vec2(d, MAT_SPIN);\n}\n\n\n\nvec2 map(vec3 p, vec3 rd) {\n\tvec2 res = spin(p ,rd, 1.0);\n\tres = un(ground(p - vec3(0, 0, 0)), res);\n \treturn res;\n}\n\nvec4 roofLight(vec3 p) {\n\tfloat music = drum; \n\tfloat s = 15.0;\n\tp.y += 10.0*TIME;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tq *= rot(0.0,0.0,TIME * 5.0 + p.x*0.1 + p.z*0.1);\n\tvec3 lightCol = vec3(0.5 + 0.5 * sin(p.x), 0.5 + 0.5 * sin(p.y), 0.1);\n\tfloat dis = sdCappedCylinder(q.zxy - vec3(-10, 0, 0), vec2(0.05, 5.0));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 5.0/(0.1*distanceToL + 0.3*distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec4 sunLight(vec3 pos) {\n\tvec3 lightCol = vec3(1.0,0.8, 0.5*(cos(TIME) + 1.0));\n\n\tfloat music = drum;\n\tfloat mdis = sdSphere(pos - vec3(0.0,0.0,0.5*sin(10.0*TIME)), 0.8 + 0.8 * music);\n\n\n\tfloat distanceToL = max(0.0001, mdis);\n\tvec3 point = lightCol * (80.0 + 80.0 * music)/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 sun = sunLight(pos);\n\tvec4 rl = roofLight(pos);\n\tdis = min(sun.w, rl.w);\n\treturn sun.xyz + rl.xyz;\n}\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\tvec3 lpos = vec3(0, 0,0);\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 220.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.1*dis*dis);\n\tfloat tmp = 0.0;\n\tstr = 1.0;\n\tcolor =  color * (0.0 + 0.8*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\n\n\nvec3 getNormal(vec3 p, vec3 rd)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz, rd).x - map(p - ep.xyz, rd).x;\n    normal.y = map(p + ep.yxz, rd).x - map(p - ep.yxz, rd).x;\n    normal.z = map(p + ep.yzx, rd).x - map(p - ep.yzx, rd).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal, vec3 rd)\n{\n\tfloat o = clamp(2.0*map(p + normal * 0.5, rd).x, 0.0, 1.0);\n\treturn 0.2 + 0.8*o;\n}\n\n\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 finalPos, vec3 eye) {\n\tfloat t = 0.0;\n\tconst int maxIter = 100;\n\tconst float maxDis = 300.0;\n\tfloat d = 0.0;\n\tvec3 p = vec3(-1.0, -1.0, -1.0);\n\tvec3 col = vec3(0);\n\tconst int jumps = 3;\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tfor (int j = 0; j < jumps; j++) {\n\t\tfor (int i = 0; i < maxIter; i++) {\n\t\t\tp = ro + rd * t;\n\n\t\t\tvec2 res = map(p, rd);\n\t\t\td = res.x;\n\t\t\tfloat fogAmount = 0.01;\n\t\t\tfloat lightDis = -1.0;\n\t\t\tvec3 light = evaluateLight(p, lightDis);\n\t\t\td = min(min(d, 1.0), max(lightDis, 0.05));\n\t\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\t\tscatteredLight += transmittance * lightIntegrated;\n\t\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\t\tt += d;\n\t\t\tfloat m = res.y;\n\t\t\tbool end = i == maxIter - 1 ||t > maxDis;\n\t\t\tif (d < 0.01 || end) {\n\t\t\t\tvec3 c = vec3(1);\n\t\t\t\tvec3 normal = getNormal(p, rd);\n\t\t\t\tif (m == MAT_WALL) {\n\t\t\t\t\tc = vec3(1,0,0);\n\t\t\t\t} else if (m == MAT_SPIN) {\n\t\t\t\t\tc = vec3(0.5);\n\t\t\t\t} else if (m == MAT_GROUND) {\n\t\t\t\t\tvec3 q = floor(p);\n\t\t\t\t\tc = vec3(0.3,0.3,1);\n\t\t\t\t}\n\n\t\t\t\tc *= occlusion(p, normal, rd);\n\t\t\t\taddLightning(c, normal, eye, p);\n\t\t\t\tif (end) {\n\t\t\t\t\ttransmittance = 0.0;\n\t\t\t\t}\n\t\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\t\t\t\tif (m == MAT_SPIN) {\n\t\t\t\t\tref *= 0.8;\n\t\t\t\t} else {\n\t\t\t\t\tref = 0.0;\n\t\t\t\t}\n\t\t\t\trd = reflect(rd, getNormal(p, rd));\n\t\t\t\tro = p + rd*0.05;\n\t\t\t\tt = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t > maxDis) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ref < 0.1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinalPos = p;\n\treturn col;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n\n    float t = TIME;\n    vec3 start = vec3(0.3*sin(t), -24.0 + 2.0*cos(t) , -4.0 );\n\n    float alpha = smoothstep(200.0, 201.0, TIME);\n\tvec3 tar = vec3(0); //eye + vec3(0.0, 0.0, 1.0);\n    vec3 eye = start + alpha*(tar - start);\n    vec3 lol = vec3(0, 1, 0);\n\n      if (t > 16.0) {\n    \teye = vec3(0.0, 0.0, -(TIME + 4.0)*3.0 + 55.0);\n    \ttar = vec3(0.1);\n    \tlol = vec3(0, 0, -1);\n\n        float alpha = smoothstep(25.0, 26.0, TIME);\n        eye = eye + alpha*(tar - eye);\n    } else if(t > 8.0) {\n    \teye = vec3(11.0*cos(0.4*t + 1.0),11.0*sin(0.4*t+1.0),-0.0);\n    \ttar = vec3(0.1, 1.0, 0.0);\n    \tlol = vec3(0.0, 0.0, -1.0);\n    }\n\n\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(lol, dir));\n\tvec3 up = cross(dir, right);\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, finalPos, eye);\n\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 106, 106, 135], [137, 137, 168, 168, 255], [257, 257, 302, 302, 342], [344, 344, 386, 386, 485], [487, 487, 520, 520, 585], [587, 587, 612, 612, 677], [679, 679, 714, 714, 781], [783, 783, 819, 819, 903], [905, 905, 942, 942, 969], [971, 971, 1002, 1002, 1040], [1042, 1042, 1076, 1076, 1100], [1102, 1102, 1139, 1139, 1464], [1466, 1466, 1530, 1530, 1655], [1659, 1659, 1690, 1690, 1799], [1801, 1801, 1843, 1843, 1936], [1937, 1937, 1963, 1963, 2094], [2096, 2096, 2132, 2132, 2291], [2413, 2413, 2434, 2434, 2661], [2663, 2663, 2702, 2702, 3451], [3455, 3455, 3482, 3482, 3571], [3573, 3573, 3597, 3597, 4048], [4050, 4050, 4075, 4075, 4388], [4391, 4391, 4438, 4438, 4545], [4547, 4547, 4617, 4617, 5000], [5004, 5004, 5037, 5037, 5302], [5304, 5304, 5351, 5351, 5435], [5439, 5439, 5503, 5503, 6989], [6995, 6995, 7050, 7050, 8269]], "test": "timeout"}
{"id": "ltV3DG", "name": "Julia set 1", "author": "urbans", "description": "julia", "tags": ["fractal"], "likes": 1, "viewed": 68, "published": "Public", "date": "1495311480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    //uv.x -= 0.7;\n    \n    const int max_iter = 1000;    \n    float ReC = sin(iTime/5.0);\n    float ImC = sin(iTime/4.0);\n    \n    //float ReC = -0.2+0.5*sin(iTime/3.0);\n    //float ImC = -0.2+0.5*sin(iTime/5.0);\n    \n    float ReZ = uv.x;\n    float ImZ = uv.y;\n    \n    float ReTmp;\n    float ImTmp;\n\n    int cur_iter = 0;\n    \n    for (int i=0; i<max_iter; i++){\n\n        // (a+bi)^2 = a^2 + 2abi - b^2 \n   \t\tReTmp = ReZ*ReZ - ImZ*ImZ + ReC;\n        ImTmp = 2.0*ReZ*ImZ + ImC;\n\n    \tReZ = ReTmp;\n\t\tImZ = ImTmp;\n        \n        cur_iter = i;\n        \n        if (ReZ*ReZ+ImZ*ImZ > 4.0){\n        \tbreak;\n        }\n    }\n    \n\tfloat intensity = 0.0;\n    float abs2 = ReZ*ReZ+ImZ*ImZ;\n    //if(abs2 < 4.0){\n\t\tintensity = float(cur_iter) / 20.0;\n    //}else if (abs2 < 20.0){\n\t//\tintensity = float(cur_iter) / 50.0;\n    //}\n    vec4 col=vec4(intensity, 0.0, 0.0, 1.0);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltV3DG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1044]], "test": "ok"}
{"id": "Md2cDK", "name": "Golden Spiral Wave", "author": "decrooks", "description": "A wavy logarithmic spiral with golden mean ratio.", "tags": ["wave", "spiral", "fibonacci", "logarithmic", "golden"], "likes": 6, "viewed": 197, "published": "Public", "date": "1493911944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat spiralWave(vec2 p, float ratio, float rate, float scale) {\n    \n    float r = length(p);\n    \n    float theta = atan(p.x,p.y);\n   \n    float logspiral = log(r)/ratio  + theta;\n   \n    return sin(rate*iTime + scale*logspiral);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n   \n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\t\n    float goldenRatio = 0.618;\n    \n    float gray = 0.5 + 0.5 * spiralWave(p,goldenRatio,3.0,5.0);  \n\n    vec3 color = vec3( gray  );\n    \n \tfragColor  = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 65, 65, 239], [242, 242, 299, 299, 563]], "test": "ok"}
{"id": "Md2cWK", "name": "Overlap Tiling", "author": "Shane", "description": "A slight variation on an old tile flipping technique.", "tags": ["circle", "pattern", "polar", "tile", "flip"], "likes": 41, "viewed": 1326, "published": "Public API", "date": "1494079862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tOverlap Tiling\n\t--------------\n\n\tIf I were to give this a longer descriptive title, I'd probably call it tile\n\tquadrant overlap flipping... which is not a catchy title either. :) I'm not \n\treally sure what you'd technically call the process, but it's just some basic \n\ttile flipping that you may have seen around. Fabrice Neyret makes use of it in \n\tsome of his examples, but this particular one was inspired by one of Cexlearning's \n\tpostings - I've provided the link below.\n\n\tThe trick behind this is pretty simple: Partition space into a grid, then \n\tsubdivide the grid into quadrants. In each quadrant (top left, top right, bottom\n\tleft, bottom right), draw two overlapping symmetrical quarter shapes - Circles are\n\tthe most common. Randomly overlap the top one or the bottom one, depending on the \n\thash ID for that quadrant... \n\n\tOK, this is the point where I'd have difficulty visualizing, which is why I've \n\tprovided a \"SHOW_GRID\" define below. Look at the way the shapes overlap in each\n\tquadrant cell. There's also a \"SHOW_FLIPPED\" define that displays which quadrants\n    have been flipped. Hopefully, those should make the description much clearer.\n\n\tThe rest is just some polar coordinate-based decoration. For anyone not familiar\n\twith that part of the process, it's worth taking some time out to draw something\n\talong the lines of a clock face with circles, squares, etc, in place of the \n\tnumbers.\n\n\n\t// A nice example - especially if you want to see a much less bloated version.\n\tSketch_Discs3 - cexlearning\n    https://www.shadertoy.com/view/4d2yDh\n    Based on this: Keijiro - https://github.com/keijiro/ShaderSketches\n\n*/\n\n// A visual aid to see the overlapping shapes in each quadrant. \n//#define SHOW_GRID\n// Shows which quadrants have been flipped. Only shows when \"SHOW_GRID\" is defined.\n//#define SHOW_FLIPPED\n\n// Gives the pattern shapes a polynomial feel. Try 3, 4, 5, 9, etc.\nconst float sides = 5.; \n\n// vec2 to float hash.\nfloat hash21( vec2 p ){ return fract(cos(dot(p, vec2(41.31, 289.97)))*45758.5453); }\n\n// Fabrices consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Drawing a shape of radius \"w\" with falloff factor \"fo.\"\nfloat ci(vec2 p, float w, float fo){\n    \n    p = fract(p) - .5; // Grid partition.\n    float a = atan(p.y, p.x); // Used to vary the radius to give a polynomial look.\n    float circ = -length(p)*(cos(a*sides)*.035 + .965) + w;     \n    return smoothstep(0., fo*2.*.333/450./max(circ, 0.001), circ); // Less interference than \"fwidth.\"\n    //return smoothstep(0., fwidth(circ-.015)*2., circ-.015); \n    \n}\n \n// The indivdual shape gradient. Basically the same as above, but without the smoothstepping.\nfloat ciGrad(vec2 p, float w){\n    \n    p = fract(p) - .5; // Grid partition. \n    float a = atan(p.y, p.x); // Used to vary the radius to give a polynomial look.\n    return -length(p)*(cos(a*sides)*.035 + .965) + w;  \n    \n}\n\n// The shape patterns. It's all pretty easy, but it's fiddly... which is just another way to say that\n// it's really annoying to code. :) Honestly, you could pretty much ignore this.\nfloat ciPat(vec2 p, float w, float dir){\n   \n    // Subdivide the grid.\n    p = fract(p) - .5; \n    \n    // Converting to polar coordinates:\n    // r = length(p), a = atan(p.y, p.x), p = p*rot(a).\n    // Ie: p.x = r*cos(a), p.y = r*sin(a).\n    \n    // To make this slightly more complica... interesting, I've multiplied the radius\n    // by a sinusoidal term to give the circles a rounded polynomial looking shape. \n    \n    \n    // Some prerotation (is that a word?) for a bit of animation.\n    p *= r2(iTime*.25*dir);\n    // Matching the shape mutation.\n    p *= cos((atan(p.y, p.x) + iTime*.25*dir)*sides)*.035 + .965;\n    \n    // The single center circle. Not sure why I called it \"dt.\" ...\n    // Short for dot, which is a reserved word. :)\n    float dt = -length(p) + .05;\n    dt = min(dt, -dt + .035);\n    dt = smoothstep(0., fwidth(dt)*1., dt);\n\n    \n    // Converting the grid positions to polar coordinates, as described above.\n    // The \"cos\" term is some aditional circle mutation. Change the global variable \"sides\" \n    // to something like 4 or 5, then you'll see the effect more clearly.\n    //float r = length(p)*(cos(atan(p.y, p.x)*sides)*.035 + .965);\n    float a = atan(p.y, p.x);\n    \n    \n    \n    // Calculating the the radial centers of each cell. It's a pretty standard way to get\n    // it done.\n    float cellDots = 9.;\n    float ia = floor(a/6.2831853*cellDots);\n    ia = (ia + .5)/cellDots*6.2831853;\n    \n    // Converting the radial centers to their positions within the circular looking shape.\n    p *= r2(ia);\n    \n    // Moving the points out a bit along the radial line.\n    float q = p.x - .18; //fract(p.x) - .5; // Radial repetion.\n    q = abs(abs(q) - .09); // Repeat trick to double up on points.\n    \n    // Drawing the two sets of nine dots.\n    float circ = -length(vec2(q, p.y)) + .03;\n    circ = min(circ, -circ + .0275);  // Taking the inner portions out to show just the outlines.\n    float c = smoothstep(0., fwidth(circ)*1., circ);\n    \n    // Drawing the lines within the slice shapes.\n    q = p.x - .27; // Radius.\n    float line = -max(abs(abs(p.y) - .05) - .1/8., abs(q) - .6/8.);\n    line = max(line, -max(abs(abs(p.y) - .015) - .1/8., abs(q + .1/8.) - .8/8.));\n    float c1 = smoothstep(0., fwidth(line)*1., line)*.5; // Lighten the lines.\n    \n    // I must have had fruit on my mind with doing this, hence the \"slice\" name.\n    // Anyway, this is the nine... abstrace fruit slice objects.\n    float slice = -length(vec2(q*.8, p.y))*(cos(atan(p.y, q)*3.)*.15 + .85) + .085;\n    slice = min(slice, -slice + .025); // Taking the inner chunks out to show just the outlines.\n    float c2 = smoothstep(0., fwidth(slice)*1., slice);\n    \n    // Combining the individual elements for the overall pattern.\n    return max(max(c, c2), max(c1, dt));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    // A bit of fake screen coordinate distortion for that fish-eye look.\n    uv *= sqrt(1. + dot(uv*iResolution.y/iResolution.x, uv)*.25);\n    \n    // Right to left scrolling.\n    float tm = iTime*.25;\n    // Slowing things down at larger resolutions - Based on Flockaroo's observation.\n    if(iResolution.x>800.) tm *= 800./iResolution.x;\n    uv += vec2(tm, 0);\n    \n    \n    // Subdivding the grid. I wanted the shapes to be the same size, regardless of\n    // resolution. Not sure whether that was the right choise or not. :)\n    vec2 p = uv*3.5*iResolution.y/450.;\n    \n    // The two colors. One for the top circle, and the other for the bottom. Which is top\n    // and bottom, depends on the random quadrand ID.\n    vec3 col1 = vec3(1);\n    vec3 col2 = vec3(1);\n    \n    // The shape radius - relative to maximum grid width. \".5\" is the maximum. In fact, I'm not\n    // sure why I coded this in, because \".5\" is pretty much the only setting that looks acceptable. :)\n    const float w = .5;\n    \n    // In regards to the following mask, overlays, etc. If you just want to put a simple example\n    // together without borders, decorations, etc, only one set is necessary. I could probably group\n    // a few together, but the calculations are relatively cheap, so I'm leaving them in a more\n    // legible state.\n    \n    // Inner shapes.\n    float c1Inner = ci(p, w - .075, 1.);\n    float c2Inner = ci(p + .5, w - .075, 1.); \n    \n    // Shape borders.\n    float c1Bord = ci(p, w + .025 - .075, 1.);\n    float c2Bord = ci(p + .5, w + .025 - .075, 1.); \n    \n    // Shadow masks.\n    float c1Sh = ci(p, w + .075 - .075, 2.);\n    float c2Sh = ci(p + .5, w + .075 - .075, 2.); \n    \n    // Shape pattern for decoration.\n    float c1Pat = ciPat(p, w - .075, 1.);\n    float c2Pat = ciPat(p + .5, w - .075, -1.);\n    \n    // Reverse the pattern on random shapes to add a bit more variance.\n    if(hash21(floor(p) + .71)>.65) c1Pat = 1. - c1Pat;\n    if(hash21(floor(p + .5) + .41)>.65) c2Pat = 1. - c2Pat;\n\n    \n    // Random shape colors.\n    if(hash21(floor(p) + .37)>.65) col1 *= mix(col1, vec3(.65, 1, .3), c1Inner);\n    if(hash21(floor(p + .5) + .53)>.65) col2 *= mix(col2, vec3(1, .75, .65), c2Inner);\n    \n    \n    // Applying the design pattern to the individual grid shapes.\n    col1 = mix(col1, vec3(0), c1Pat*.7);\n    col2 = mix(col2, vec3(0), c2Pat*.7);\n \n    // Shading the grid shapes with a circular gradient.\n    col1 = mix(vec3(0), col1, min(pow(ciGrad(p, w - .075)/(w - .075), 3.)*3. + .35, 1.));\n    col2 = mix(vec3(0), col2, min(pow(ciGrad(p + .5, w - .075)/(w - .075), 3.)*3. + .35, 1.));\n    \n\n    // Dark borders and edges. I did this in a hurry, so there'd be a better way for sure.\n    // The functions are cheap enough, so I'll leave them be, for now.\n    col1 = mix(vec3(.0), col1, c1Bord);\n    col2 = mix(vec3(.0), col2, c2Bord);\n    col1 =  mix(col1, vec3(0), c1Bord - c1Inner);\n    col2 =  mix(col2, vec3(0), c2Bord - c2Inner);  \n \n     \n    \n    // Applying the shadow masks, according to the random quadrant ID.\n    vec3 col;\n    if(hash21(floor(p*2.))>.5) col = mix(col1*c1Sh, col2, c2Sh);\n    else col = mix(col2*c2Sh, col1, c1Sh);\n    \n\n    \n    // The grid lines, to show each quadrant. The bottom shape is either on the top or the bottom,\n    // depending on the random ID for the quadrant. If you can understand that concept and know how\n    // to draw circles, you can pretty much ignore this bloated example in its entirety. :)\n    #ifdef SHOW_GRID\n    \n    vec2 ln;\n    \n    // Displays the flipped quadrants. Look at the shape encompassed by the red grid lines. Note that\n    // the flipped quadrants are drawn on top - relative to the central shape bounded by the four \n    // quadrant grid cell. \n    #ifdef SHOW_FLIPPED\n    if(hash21(floor(p*2.))>.5) col *= vec3(1., .5, 2);\n    ln = abs(fract(p + .5) - .5) - 3./450.;\n    col *= smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y)*.9 + .1;  \n    #else\n    ln = abs(fract(p + .5) - .5) - 7./450.;\n    col *= smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y)*.9 + .1;\n    ln = abs(fract(p + .5) - .5) - 2.5/450.;\n    col += (1. - smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y))*vec3(.5);\n    #endif\n    \n    ln = abs(fract(p) - .5) - 8./450.;\n    col *= smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y)*.85 + .15;\n\n    ln = abs(fract(p) - .5) - 2.5/450.;\n    col += (1. - smoothstep(0., fwidth(ln.x), ln.x)*smoothstep(0., fwidth(ln.y), ln.y))*vec3(1, .0, .1);\n    \n    #endif\n    \n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored varation.\n    col = mix(pow(min(vec3(1.5, 1, 1)*col, 1.), vec3(1, 3, 16)), col, \n                     pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .2)*.75 + .25);\n    \n    \n    // Mild LCD overlay. It's very subtle, but it's there. :)\n    vec2 rg = mix(mod(fragCoord, vec2(2))*col.xy, col.xy, .5);\n    col = vec3(rg, col.z - mix(col.x - rg.x, col.y - rg.y, .5));\n \n   \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2cWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1936, 1959, 1982, 1982, 2043], [2045, 2087, 2105, 2105, 2173], [2176, 2235, 2271, 2271, 2640], [2643, 2737, 2767, 2767, 2962], [2964, 3147, 3187, 3218, 5949], [5952, 5952, 6008, 6036, 11212]], "test": "ok"}
{"id": "Md2cWt", "name": "everyday 002/100", "author": "kalin", "description": "everyday 002/100", "tags": ["everyday"], "likes": 0, "viewed": 110, "published": "Public", "date": "1494481309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float s(float t) { return sin(t); }\nfloat c(float t) { return cos(t); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = mix(uv, uv + vec2(c(t*1.01), s(t*1.02)) * 0.1 * texture(iChannel0, uv).x, texture(iChannel0, uv).y + 0.7);\n    \n    fragColor = vec4(s(t), c(s(t*0.2)*4.0)+0.3, s(t*t), 1.0);\n    fragColor.x = s(uv.x * 26.0) * c(uv.y * 17.0);\n\n    vec4 m = texture(iChannel3, round(uv*32.0)/32.0);\n   \n    float dither = s(fragCoord.x * 1.0) * c(fragCoord.y * 0.5);\n    //vec2 cc = vec2(c(t), s(t));\n    float center = pow(1.0 - length(uv - vec2(0.5, iResolution.y / iResolution.x)) * abs(s(t*0.3+m.x)), 2.0);\n    //float center = length(cc);\n\n    //fragColor *= dither * 0.7 + abs(sin(t*8.0)) * dither * 0.3 * center * texture(iChannel3, uv) * fragColor.x;\n    fragColor *= dither * 0.7 + abs(sin(t*8.0)) * dither * 1.4 * center * m.x * fragColor.x;\n    \n    //fragColor.x = texture(iChannel3, uv).x;  \n\t//fragColor.x = 1.0-m.x;\n    fragColor.y = mix(fragColor.y, center * texture(iChannel0, uv).x, 0.3*c(t*0.001));\n    fragColor.z = fragColor.x * fragColor.y;\n    fragColor.z *= 2.0;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2cWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 35], [36, 36, 54, 54, 71], [73, 73, 130, 130, 1182]], "test": "error"}
{"id": "Md2yDK", "name": "Whirlpool Vortex", "author": "decrooks", "description": "Whirlpool ", "tags": ["raytracing", "swirl", "spiral", "vortex", "whirlpool"], "likes": 17, "viewed": 465, "published": "Public", "date": "1493918012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n};\n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    Ray \t ray;\n    Material material;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\n\n    \nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n    float x = exp(-k * a);\n    float y = exp(-k * b);\n    return (a * x + b * y) / (x + y);\n}\n\nfloat smoothmax(float a, float b, float k)\n{\n    return smoothmin( a,  b, -k);\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n   \n    float sd = smoothmax(d1.signedDistance,d2.signedDistance,3.0);\n    MapValue mv;\n  \tmv.material = d1.material;\n  \tmv.signedDistance = sd;\n  return mv;  \n    \n    /*if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }*/\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nMapValue subtractObjects( MapValue d1, MapValue d2 )\n{\n    \n    d1.signedDistance = -d1.signedDistance;\n    return intersectObjects(  d1, d2 );\n}\n\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0);\n    whiteMat = Material(LightColor(0.75*vec3(1.0,1.0,0.9),0.3*vec3(1.0,1.0,0.9)) ,shininess );\n\n}\n\n/////////////////////////   SDFs   ///////////////////////////////////\n\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n  vec3 a = p - origin;\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = dot(a,normal);\n  return mv;\n}\n\n\n\nfloat spiralWave(vec2 p, float ratio, float rate, float scale) {\n    \n    float r = length(p);\n    \n    float theta = atan(p.x,p.y);\n   \n    float logspiral = log(r)/ratio  + theta;\n   \n    return sin(rate*iTime + scale*logspiral);\n    \n}\n\n\nMapValue vortex( vec3 p ,vec3 c, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n    \n    vec2 v =  p.xz - c.xz;\n    \n float h1 = 0.03* spiralWave(v,0.618,3.0,5.0); \n    \n    float theta = 2.45*iTime;\n    \n  vec2 orbit = 0.2*vec2(sin(theta),cos(theta));  \n    \n     float h2 = 0.02*spiralWave(v+orbit,0.618,6.53,6.0);\n    \n  mv.signedDistance = length(v )  - exp(p.y + c.y + h1 + h2);\n  return mv;\n}\n\n\nMapValue sphere(vec3 p, vec3 center, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = distance(p, center) - radius;\n  return mv;\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////// Map The Scene ////////////////////////////////\n\nMapValue map(vec3 p){\n   \tfloat t  = iTime;\n   \t\n //   MapValue obj2  = sphere(p,vec3(-0.15),0.2, whiteMat);\n \n  //MapValue obj  = sphere(p,vec3(0.0),0.25, whiteMat);\n     MapValue vtx  = vortex(p,vec3(0.0,0.3,0.0), whiteMat);\n    \n    \n     MapValue pl = plane(p,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0) ,whiteMat);\n      MapValue obj = subtractObjects( vtx,pl) ;  \n         \n         \n  //obj  = subtractObjects(obj2, obj);\n    \n  return obj;\n}\n\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////// Raytracing ///////////////////////////////////\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    float dist = 0.01;\n    float presicion = 0.002;\n\tvec3 p;\n    MapValue mv;\n    \n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion || dist>maxDistance) break;\n       \n    }\n    \n    return Trace(dist,p,ray,mv.material);\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = traceRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\n/////////////////////// Lighting ////////////////////////////////\n\nvec3 diffuseLighting(in Trace trace, vec3 normal, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\nvec3 specularLighting(in Trace trace, vec3 normal, vec3 lightColor,vec3 lightDir){\n    //blinn-phong\n    //https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 viewDir = -trace.ray.direction;\n\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specAngle = max(dot(halfDir, normal), 0.0);\n    float specular = pow(specAngle, trace.material.shininess);\n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\nvec3 pointLighting(in Trace trace, vec3 normal, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, normal, light.color.diffuse, lightDir);\n    \n    color += specularLighting(trace, normal, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, vec3 normal, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, normal, light.color.diffuse, light.direction);\n    \n    color += specularLighting(trace, normal, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(0.7);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(0.7),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(0.6),specular)); \n    light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    dirLight = DirectionalLight(normalize(vec3(0.0,1.0,0.0)),LightColor(vec3(0.1),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace, vec3 normal){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, normal,light1);\n\tcolor += pointLighting(trace, normal,light2) ;\n    color += pointLighting(trace, normal,light3) ;\n\tcolor += directionalLighting(trace, normal,dirLight);\n    \n    return color;\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.7,1.4,-1.9);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.3);\n   \tTrace trace = traceRay(ray,12.0);\n    \n\tvec3 normal = calculateNormal(trace.p);\n    vec3 color = lighting(trace,normal);\n    \n   \treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2yDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[816, 816, 846, 846, 884], [886, 886, 930, 930, 1024], [1026, 1026, 1070, 1070, 1106], [1108, 1108, 1163, 1163, 1474], [1476, 1476, 1517, 1517, 1610], [1612, 1612, 1666, 1666, 1757], [1760, 1760, 1781, 1781, 2074], [2148, 2148, 2194, 2194, 2294], [2296, 2296, 2344, 2344, 2424], [2426, 2426, 2489, 2489, 2598], [2602, 2602, 2666, 2666, 2840], [2843, 2843, 2889, 2889, 3242], [3245, 3245, 3309, 3309, 3410], [3412, 3412, 3460, 3460, 3568], [3715, 3715, 3736, 3736, 4156], [4302, 4302, 4332, 4332, 4777], [4779, 4779, 4826, 4826, 5160], [5162, 5162, 5203, 5203, 5355], [5357, 5357, 5424, 5424, 5794], [5863, 5863, 5944, 5944, 6069], [6071, 6071, 6153, 6241, 6523], [6526, 6526, 6592, 6592, 7033], [7035, 7035, 7110, 7110, 7401], [7404, 7404, 7421, 7421, 7915], [7919, 7919, 7962, 7962, 8250], [8252, 8252, 8272, 8272, 8560], [8562, 8562, 8619, 8619, 8952]], "test": "ok"}
{"id": "MdBcW3", "name": "julia 0.3", "author": "NNenov", "description": "click n drag\n\nthanks to lycium for teaching me and Kchplr for some touch-ups!", "tags": ["fractal"], "likes": 0, "viewed": 367, "published": "Public API", "date": "1494066296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nconst float scale = 1.8;\nconst float mscale = 3.0;\nconst float escape= 4.;\nconst float bAmt = 0.2; // moblur amount\nconst float speed = 1.0;\n\nconst int fSamples = 10; //fibonacci sequence index\nconst int iters = 256;\n\nivec2 fib(const in int f)\n{\n  int n0 = 1;\n  int n1 = 1;\n  int fi = 0;\n    \n  for (int i = 0; i < f; i++) \n  {\n    fi = n0 + n1;\n    n0 = n1;\n    n1 = fi;\n  }\n    \n  return ivec2(n0, n1);\n}\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 rotate(vec2 v, float t)\n{\n    float tx = cos(t)*v.x-sin(t)*v.y;\n    float ty = sin(t)*v.x+cos(t)*v.y;\n    return vec2(tx,ty);\n}\n\nvec2 mandel(vec2 a, vec2 c)\n{\n    float sqrz_x = a.x * a.x - a.y * a.y;\n    float sqrz_y = 2.0 * a.x * a.y;\n    \n   \n \tvec2 md =  vec2(sqrz_x,sqrz_y) +c;\n    \n    return (md);\n    \n}\n\nvec2 julia(vec2 a, float t, vec2 mo)\n{\n    \n    float sqrz_x = a.x * a.x - a.y * a.y + 0.45 + ( (sin(t) + mo.y ) * 0.01);\n    float sqrz_y = 2.0 * a.x * a.y + 0.45 + ( (cos(t) + mo.x ) * 0.02);\n    \n   \n \tvec2 md =  vec2(sqrz_x,sqrz_y);\n    \n    return (md);\n}\n\nfloat pxFunc(vec2 px, float t)\n{\n    \n    vec2 st = -scale / 2.0 + ( px / iResolution.xy ) * scale;\n    \n    vec4 m = mscale/2.0 -(iMouse / iResolution.xxxx)*mscale;\n\n    //st += m.xy;//vec2(0., 0.);\n    \n\tst = rotate(st, -t*0.1);\n    \n    vec2 z = st;\n    \n    //z = rotate(z, t*0.1);\n    \n    \n\tint k = 32;\n\n  \tfor(int j = 0; j < iters; j++)\n    {\n\n        z = julia(z*(0.95+sin(t*2.)*0.03), t, m.xy);\n        \n        if(z.x * z.x + z.y * z.y > escape) \n        {\n           k = j;\n           break;\n        }\n     }\n  \t\n    return 1.0-(float(k)/float(iters)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    ivec2 fi = fib(fSamples - 2);\n    int ifN = fi.x;\n    float ffN = float(fi.x);\n    float ffk = float(fi.y);\n\n    \n    vec3 sum = vec3(0.);\n    float colMap;\n    float timeMap;\n    \n    float r = rand(gl_FragCoord.xy / iResolution.xy); // not sure how to best generate a random number\n    float fx;\n    for (int i = 0; i < ifN; i++) \n    {\n        vec2 samp = vec2(\n            float(i) / ffN,\n            fract(ffk * float(i) / ffN)\n        );\n        \n        timeMap = iTime + (float(i) + r) / ffN * bAmt;\n        \n        colMap = pxFunc( gl_FragCoord.xy + samp , timeMap*speed);\n    \tfloat steps = float(iters)-sin(timeMap*0.5)*5.;\n        float r = abs(0.7+sin(colMap*(steps-sin(timeMap)*0.1)));\n        float g = abs(0.7+sin(colMap*(steps+0.1)));\n        float b = abs(0.7+sin(colMap*(steps+0.2-cos(timeMap)*0.1)));\n        sum += vec3(r,g,b);\t\n    }\n\n    vec3 colNorm = sum / ffN;\n\n    fragColor = vec4(colNorm,1.0);\n\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdBcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 453, 453, 521], [523, 523, 553, 553, 655], [657, 657, 686, 686, 839], [841, 841, 879, 879, 1101]], "test": "error"}
{"id": "MdBcWK", "name": "WaterGrass", "author": "tholzer", "description": "simple shader that draws some animated water grass in 2D", "tags": ["procedural", "2d", "water", "grass"], "likes": 17, "viewed": 469, "published": "Public", "date": "1493802068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// WaterGrass.glsl\n// original: https://www.shadertoy.com/view/MlSXRV\n// Created by Eric Arnebäck - erkaman/2015\n// This work is licensed under a \n// Creative Commons Attribution 4.0 International License\n\n#define GRASS_BLADES 222\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\n// 2D rotation matrix by approximately 36 degrees.\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat fbm(vec2 r) \n{\n    // rotate every octave to add more variation. \n    return 0.5000*noise( r ); r = r*m*2.01;\n         + 0.2500*noise( r ); r = r*m*2.02;\n         + 0.1250*noise( r ); r = r*m*2.03;\n         + 0.0625*noise( r ); r = r*m*2.01;\n}\n\nfloat rand(float co)\n{\n    return fract(sin(dot(vec2(co ,co ) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand_range(float seed, float low, float high) \n{\n\treturn low + (high - low) * rand(seed);\n}\n\nvec3 rand_color(float seed, vec3 col, vec3 variation) \n{\n    return vec3(col.x + rand_range(seed,-variation.x, +variation.x),\n                col.y + rand_range(seed,-variation.y, +variation.y),\n                col.z + rand_range(seed,-variation.z, +variation.z));\n}\n\nvec4 grass(vec2 p, int i, vec2 q, vec2 pos, float curve, float height)\n{\n    pos = q + pos;\n    pos.y += 0.5; // coordinate y=0 will represent the bottom. \n\n    float r = rand_range(float(i+200),0.002,0.005 ); // grass radius \n    \n    // the grass gets thinner and thinner, \n    // as it grows to the top of the screen\n    r = r * (1.0 - smoothstep(0.0,height, pos.y)); \n\n    float s = sign(curve); // curve value sign. \n    //the grass shape is described by a function on the form\n    // x = c* y^2, where c is the curve.\n    float grass_curve = abs(pos.x - s* pow( curve*( pos.y),2.0));\n\n    // the grass ends at ymax. \n    float ymax = height; \n    \n    // sligthly blur the edges of the grass blade to decrease\n    // aliasing issues\n    float res = 1.0-(1.0 - smoothstep(r, r+0.006,grass_curve  )) *\n                    (1.0 - smoothstep(ymax-0.1, ymax, pos.y));\n       \n    // grass bottom is dark, but the blade gets gradually brighter as it\n    // grows upward.\n    vec3 bottom_color = rand_color(float(i),vec3(0.10,0.3,0.1), vec3(0.0,0.20,0.0));\n    vec3 top_color =  rand_color(float(i),vec3(0.40,0.6,0.2), vec3(0.0,0.20,0.0));\n    vec3 col = mix(bottom_color,top_color,pos.y);\n   \n    // gradually make the grass color lighter as we approach the edges; \n    // makes for a slight 3D effect.\n    col = col + vec3(0.0,0.10,0.0)* (1.0-smoothstep(0.0, r,grass_curve));\n\n    // add noise in order to add slight visual interest. \n    vec2 a = 104.0*vec2(p.xy);   \n    a.x *= 2.9;\n    a.y *= 0.2;\n    float f = fbm(a);\n    col = mix(col - vec3(0.0,0.05,0.0) , col + vec3(0.0,0.1,0.0) ,f);\n       \n    return vec4(col, 1.0-res);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - vec2(0.5, 0.33);\n    q.x *= 0.5;\n\n    vec3 col = vec3(-p.y,0.5*p.y,0.4);   // background color\n\n    for(int i = 0; i <GRASS_BLADES; i += 1)\n    {\n        float height = rand_range(float(i+2),0.4,1.20 );\n\n        // grass curve depends on the height. \n        float max_curve = 1.0 - height + 0.40;\n\n        float curve = 0.1*sin(iTime+float(i)) + rand_range(float(i+1),-max_curve,max_curve );\n            \n        vec2 pos = vec2(rand_range(float(i+3),-0.35,0.35 ),0.0);\n       \n        vec4 ret = grass(p,i,q*1.4, pos, curve, height);\n        \n        // blend the grass with the background. \n        col = mix(col, ret.xyz, ret.w);\n    }\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dlSzM", "previewfilepath": "https://soundcloud.com/uxmal-records/psyrius-uranus", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/uxmal-records/psyrius-uranus", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdBcWK.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0 WITH generic-exception", "functions": [[233, 233, 256, 256, 292], [294, 294, 320, 320, 539], [629, 629, 649, 700, 878], [880, 880, 902, 902, 982], [984, 984, 1038, 1038, 1081], [1083, 1083, 1139, 1139, 1349], [1351, 1351, 1423, 1423, 2985], [2988, 2988, 3045, 3045, 3773]], "test": "ok"}
{"id": "MdByWt", "name": "hex tile march", "author": "ollj", "description": "a good basis for something i wanted for 2 years...\npracticing and learning by twiddling around with\nparent= https://www.shadertoy.com/view/XsBczc", "tags": ["voxel", "raytrace", "hex"], "likes": 5, "viewed": 510, "published": "Public API", "date": "1494325695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self  = https://www.shadertoy.com/view/MdByWt\n//parent= https://www.shadertoy.com/view/XsBczc\n\n/* hexwaves, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Uses the hex grid traversal code I developed in https://www.shadertoy.com/view/XdSyzK\n\n*/\n\n\n\n// square root of 3 over 2 for hex tiling.x,sixth rotation, sin(acos(-1.)/3.)\n//#define hex_factor (pow(3.,.5)*.5)\n//pow(x,y) is internally doing exp(log(x)*y):\n#define p322 (exp(log(3.)*.5)*.5)\n\nfloat df(vec3 p){\n return length(p)-1.;\n}\n\n#define rmIterations 100\n#define eps .001\nfloat rm3(vec3 o,vec3 r){float t=0.;for(int i=0;i<rmIterations;++i){\n  //float d2=df(o+r*t2);\n  // if(d2>eps)t2+=d2*.5;\n  float d=df(o+r*t);\n  t+=d*.5;\n  #ifdef dynamicEps\n  d=pow(d,pow(t,.5));\n  #endif\n  if(d<eps*.05)break;}return t;}\n// From Dave Hoskins' https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash32(vec2 p) {\n vec3 p3=fract(vec3(p.xyx) * HASHSCALE3);\n p3+=dot(p3, p3.yxz+19.19);\n return\nfract((p3.xxy+p3.yzz)*p3.zyx);}\n/**/\n\n// Used to draw top borders on top of hex\nfloat hexDist(vec2 p){p=abs(p);\n return max(dot(p,vec2(p322,.5)),p.y)-1.;}\n\n//return  center of nearest hex from p;\nvec2 nearestHexCenter(in vec2 p) {\n //integer coords in hex center grid\n vec2 hex_int=floor(vec2(p.x/p322,p.y));\n float sy=step(2.,mod(hex_int.x+1.,4.));\n hex_int+=mod(vec2(hex_int.x, hex_int.y + sy),2.);\n vec2 r=hex_int*vec2(p322,1.);//cartesian hexagon center\n p=p-r;\n //figure out which side of line we are on \n //and modify hex center if necessary\n if(dot(abs(p),vec2(p322,.5))>1.){\n  hex_int+=sign(p)*vec2(2,1);\n  return hex_int*vec2(p322,1);\n }\n return r;}\n\n//Flip normal if necessary to have positive dot product with d\nvec2 alignNormal(vec2 n,vec2 d){return n*sign(dot(n,d));}\n//Intersect a ray with a hexagon wall with normal n\nvec3 rayHexIntersect(vec2 o,vec2 d, vec2 n){\n return vec3(n,(1.-dot(n,o))/dot(n,d));}\n\n//Choose the vector whose z coordinate is minimal\nvec3 rayMin(vec3 a,vec3 b){return mix(a,b,step(b.z,a.z));}\n\n//Return the cell height for the given cell center\nfloat height_for_pos(vec2 p){\n p*=.1;p+=p.x+p.y;\n //shift origin a bit randomly\n //p+=vec2(2.*sin(iTime*.3+.2),2.*cos(iTime*0.1+0.5));\n //cosine of distance from origin, modulated by Gaussian\n float q=dot(p,p),x=sqrt(q);\n return 6.*cos(x*.2+iTime)*exp(-q/128.);   \n}\n\n//return fully saturated hue.rgb of [h]; 0=1=red, 1/3=green, 2/3=blue \nvec3 hue(float h){return clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);}\n//return color.rgb of c.xyz .x=hue .y=saturation .z=variance       \nvec3 hsv2rgb(vec3 c){return c.z*mix(vec3(1),hue(c.x),c.y);}\n//return color.rgb of c.xyz .x=hue .y=saturation .z=lightness\nvec3 hsl2rgb(vec3 c){return c.z+c.y*(hue(c.x)-.5)*(1.-abs(2.*c.z-1.));}\n//https://www.shadertoy.com/view/lsS3Wc\n/*\nvec3 rgb2hsv(vec3 c){vec4 k=vec4(0,-1,2,-3)/3.,\n p=mix(vec4(c.zy,k.wz),vec4(c.yz, k.xy),(c.z<c.y)?1.:0.),\n q=mix(vec4(p.xyw,c.x),vec4(c.x, p.yzx),(p.x<c.x)?1.:0.);\n float d=q.x-min(q.w,q.y);\n return vec3(abs(q.z+(q.w- q.y)/(6.*d+eps)),d/(q.x+eps),q.x);}\nvec3 rgb2hsl(vec3 c){float n=vmin(c),m=vmax(c);\n vec3 a=step(c.grr,c.rgb)*step(c.bbg,c.rgb),\n h=a*(vec3(0,2,4)+(c.gbr-c.brg)/(m-n + eps))/6.;\n return vec3(fract(1.+vsum(h)),//H\n    (m-n)/(1.-abs(n+m-1.)+eps),//S\n   (n+m)*.5 );}                //L\n*/\n\nvoid hitWallOfadj(in vec2 c,in float prev_cell_height,in vec3 i,inout float h, inout float bdist,inout vec4 hit_nt,inout bool hit,inout vec3 hs,out vec3 n){  \n hit_nt=vec4(n.xy,0.,n.z);\n hit=true;\n hs=vec3(.3,1.,.7);\n //distance to wall top: ... //distance to wall bottom:\n bdist=min(h-i.z,i.z-prev_cell_height);\n vec2 p=i.xy-c;//distance to wall outer side corner\n p=p-n.xy*dot(p,n.xy);\n n=min(n,abs(length(p)-.5/p322));\n }\n\nvoid hitfloor(in vec2 c,in vec3 o,in vec3 d,in float tz,out bool hit,out vec4 hit_nt,out float bdist){\n hit =true;\n hit_nt=vec4(0,0,1,tz);   \n vec2 pinter=o.xy+d.xy*tz;\n bdist=hexDist(pinter-c);// distance to hex border\n}\n\nvoid leavingCell2(inout float prev_cell_height,inout vec3 i,in vec3 o,in vec3 d,out vec3 hs,in vec3 n,inout vec2 c,in float h){\n hs=vec3(.8,1.,1.);\n //update the cell center by twice the normal of intersection\n c+=2.*n.xy;\n prev_cell_height=h;\n h=height_for_pos(c);\n i=o+d*n.z;//ray intersection point with cell wall\n}\n\nvoid leavingCell(out vec3 j,in vec3 o,in vec3 d,out float prev_cell_height,inout float h,inout vec2 c,in vec3 n,out vec3 hs){\n prev_cell_height=h;\n hs=vec3(.8,1.,1.);\n c+=2.*n.xy;//set cell center to +twice_normal_of_intersection\n h=height_for_pos(c);\n j=o+d*n.z;//ray intersection point with cell wall\n}\n\nvoid noHit(in float h,in vec2 c,in vec3 o, in vec3 d,out vec3 n, out float tz){\n // needed to hit against line of a horizon\n //n.xy holds normal, n.z holds ray distance\n //3 possible plane normals to intersect with:\n #define ise(a) rayHexIntersect(o.xy-c,d.xy,alignNormal(a,d.xy))\n n=rayMin(rayMin(ise(vec2(0,1)),ise(vec2(p322,.5))),ise(vec2(p322,-.5)));\n tz=(h-o.z)/d.z; //try to intersect with top of cell\n}\n    \n//Return color for ray with origin o and direction d\n#define border_size .4\n#define border_scale (2./iResolution.y)\nvec3 shade(in vec3 o,in vec3 d) {\n const vec3 fog_color = vec3(1,1,1)*.5;\n vec3 r=fog_color;\n vec2 c=nearestHexCenter(o.xy);//nearest hex center to ray origin\n float h=height_for_pos(c);//cell height\n bool hit=false;\n vec4 hit_nt;\n vec3 hs;//hsv color\n float bdist=1e5;\n float prev_cell_height;\n vec3 j;\n for(int i=0; i<99; ++i){//march one iteration per cell\n  if(!hit){\n   float tz;vec3 n;\n   noHit(h,c,o,d,n,tz);\n   if(o.z >h&&d.z<0.&&tz<n.z)//if(hit floor in this cell)\n    hitfloor(c,o,d,tz,hit,hit_nt,bdist);\n   else{//if(hit cell wall before hitting top)\n    vec3 j=vec3(0);\n    leavingCell(j,o,d,prev_cell_height,h,c,n,hs);\n   if(j.z<h)//if(intersected below the height of neibor cell)\n    hitWallOfadj(c,prev_cell_height,j,h,bdist,hit_nt,hit,hs,n);  \n }}}if (hit){// compute color if hit\n  vec3 n=hit_nt.xyz;// get normal\n  //noise makes a nice \"disco ball\" look in background\n  vec3 noise = (hash32(nearestHexCenter(c))-.5);\n  //n = normalize(n + noise);  \n  hs.x=noise.x+noise.y; \n  float c=1.;\n  c=smoothstep(c,border_scale*hit_nt.w,abs(bdist)-border_size);      \n  //c=mix(c,.5,smoothstep(18.,45.,hit_nt.w));//anti-moidre-fade\n  r=mix(hsv2rgb(hs),vec3(1), 0.);//mix color\n  //vec3 L=normalize(vec3(3,1,4));//ambient direction\n  //r*=(clamp(dot(n,L),0.,1.)*.8+.2);//diffuse/ambient\n        \n  //r=mix(r, texture(iChannel0, reflect(rd,n)).yzx,.4*border);//cubemap\n  //r=mix(fog_color, color,exp(-length(hit_nt.w*d)*.01));//fog\n  return r;}return r;}\t\n\n// Pretty much my boilerplate rendering code, just a couple of \n// fancy twists like radial distortion and vingetting.\n\nvoid camera(out vec3 o,out vec3 d,in vec2 In){\n const float f=500.;\n vec2 uvn=(In.xy-.5*iResolution.xy)/iResolution.y;\n vec2 u=uvn*720.;\n o=vec3(-12,0,10);//cam pos\n vec3 tgt=vec3(0);\n vec3 up=vec3(0,0,1);\n vec3 rz=normalize(tgt-o);\n vec3 rx=normalize(cross(rz,up));\n vec3 ry=cross(rx,rz);\n float s=1.+dot(uvn,uvn)*1.;//radial distortion\n d=mat3(rx,ry,rz)*normalize(vec3(u*s,f));\n float thetax=-.35-.2*cos(.031513*iTime); \n float thetay=-.2*iTime;\n if(any(greaterThan(iMouse.xy,vec2(10.)))){\n  thetax=(iMouse.y-.5*iResolution.y)*-1./iResolution.y;\n  thetay=(iMouse.x-.5*iResolution.x)*6./iResolution.x; \n }/**/\n float cx=cos(thetax),sx=sin(thetax),cy=cos(thetay),sy=sin(thetay);\n mat3 Rx=mat3(1,0,0,0,cx,sx,0,-sx,cx),\n Ry=mat3(cy,0,-sy,0,1,0,sy,0,cy),\n R=mat3(0,0,1,-1,0,0,0,1,0),\n Rt=transpose(R);\n d=Rt*Ry*Rx*R*d;\n o=Rt*Ry*Rx*R*(o-tgt)+tgt;}\n\nvoid mainImage( out vec4 Out,in vec2 In){\n vec3 o,d;camera(o,d,In);\n vec3 r=shade(o,d);\n //r=sqrt(r);\n //vec2 q=In.xy/iResolution.xy;\n //r *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),.1);//iq's vingette       \n Out=vec4(r,1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdByWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[499, 499, 516, 516, 540], [584, 584, 609, 609, 819], [926, 926, 947, 947, 1057], [1064, 1106, 1128, 1128, 1180], [1182, 1222, 1256, 1293, 1684], [1686, 1749, 1781, 1781, 1806], [1807, 1859, 1903, 1903, 1944], [1946, 1996, 2023, 2023, 2054], [2056, 2107, 2136, 2136, 2373], [2375, 2446, 2464, 2464, 2521], [2522, 2590, 2611, 2611, 2649], [2650, 2712, 2733, 2733, 2783], [3332, 3332, 3488, 3488, 3756], [3758, 3758, 3860, 3860, 3979], [3981, 3981, 4108, 4108, 4299], [4301, 4301, 4426, 4426, 4605], [4607, 4607, 4686, 4822, 5016], [5138, 5138, 5171, 5171, 6598], [6721, 6721, 6767, 6767, 7564], [7566, 7566, 7607, 7607, 7789]], "test": "ok"}
{"id": "Mdd3Rf", "name": "wave spectrum", "author": "masaki", "description": "wave spectrum", "tags": ["wave"], "likes": 8, "viewed": 664, "published": "Public API", "date": "1494092885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec4 color = vec4(uv,.5+.5*sin(iTime),1.);\n    \n    vec4 color2 = vec4(1. - ((uv.x + uv.y) / 2.),uv,1.);\n    \n    vec2 pos = uv*2.-1.;\n    \n    \n    color = color2 * abs(1./(sin(pos.y + cos(pos.x*.5 + iTime)*.8)*10.));\n   \n    fragColor = color;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdd3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 388]], "test": "ok"}
{"id": "MdfBRN", "name": "Circle Design 2", "author": "lherm", "description": "Another pattern. I realize the code is pretty inefficient and would appreciate any tips to refactor.", "tags": ["pattern"], "likes": 0, "viewed": 393, "published": "Public API", "date": "1495039980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 u = (g+g-iResolution.xy)/iResolution.y;\n    u = fract(u) - .5;\n       vec2 un = u, us = u, ue = u, uw = u;\n    \n    float r = .7, d = step(length(u),r);\n    for (int i = 0; i < 10; i++)\n    {\n        r *= .4 + .1 * sin(float(i) + iTime);\n        \n        un += vec2(0, r);\n        us -= vec2(0, r);\n        ue -= vec2(r, 0);\n        uw += vec2(r, 0);\n        \n        vec2 en=ue, es=ue, ew=ue, ee=ue,\n             nn=un, ns=un, nw=un, ne=un,\n             wn=uw, ws=uw, ww=uw, we=uw,\n             sn=us, ss=us, sw=us, se=us;\n        r *= 1.5;\n        en += vec2(0, r);\n        es -= vec2(0, r);\n        ee -= vec2(r, 0);\n        ew += vec2(r, 0);\n        \n        wn += vec2(0, r);\n        ws -= vec2(0, r);\n        we -= vec2(r, 0);\n        ww += vec2(r, 0);\n        \n        sn += vec2(0, r);\n        ss -= vec2(0, r);\n        se -= vec2(r, 0);\n        sw += vec2(r, 0);\n        \n        nn += vec2(0, r);\n        ns -= vec2(0, r);\n        ne -= vec2(r, 0);\n        nw += vec2(r, 0);\n        \n        if (mod(float(i), 2.) == 0.)\n        {\n        \td -= step(dot(en,en), r*r);\n            d -= step(dot(es,es), r*r);\n            d -= step(dot(ee, ee),r*r);\n            d -= step(dot(ew, ew),r*r);\n            \n            d -= step(dot(nn,nn), r*r);\n            d -= step(dot(ns,ns), r*r);\n            d -= step(dot(ne, ne),r*r);\n            d -= step(dot(nw, nw),r*r);\n            \n            d -= step(dot(wn,wn), r*r);\n            d -= step(dot(ws,ws), r*r);\n            d -= step(dot(we, we),r*r);\n            d -= step(dot(ww, ww),r*r);\n            \n            d -= step(dot(sn,sn), r*r);\n            d -= step(dot(ss,ss), r*r);\n            d -= step(dot(se, se),r*r);\n            d -= step(dot(sw, sw),r*r);\n        }\n        else\n        {\n        \td += step(dot(en,en), r*r);\n            d += step(dot(es,es), r*r);\n            d += step(dot(ee, ee),r*r);\n            d += step(dot(ew, ew),r*r);\n            \n            d += step(dot(nn,nn), r*r);\n            d += step(dot(ns,ns), r*r);\n            d += step(dot(ne, ne),r*r);\n            d += step(dot(nw, nw),r*r);\n            \n            d += step(dot(wn,wn), r*r);\n            d += step(dot(ws,ws), r*r);\n            d += step(dot(we, we),r*r);\n            d += step(dot(ww, ww),r*r);\n            \n            d += step(dot(sn,sn), r*r);\n            d += step(dot(ss,ss), r*r);\n            d += step(dot(se, se),r*r);\n            d += step(dot(sw, sw),r*r);\n        }\n        \n    }\n\tf = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdfBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 2514]], "test": "ok"}
{"id": "MdffDr", "name": "Red triangles pattern", "author": "josemorval", "description": "A simple pattern. Using mod to make a pattern, but each cell has its own move parameters.", "tags": ["triangles", "red", "pattern", "rotation", "cell"], "likes": 2, "viewed": 458, "published": "Public API", "date": "1495661741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float easingSinInOut(float t){\n   t = mod(t,1.0);\n   return 0.5*(1.0 - cos(3.14159 * t)); \n}\n\nfloat triDist(vec2 p){\n  float f = smoothstep(0.0,0.01,p.x-p.y);\n  f*=  smoothstep(0.0,0.01,-p.x-p.y);\n  f*=  smoothstep(0.0,0.01,0.5+p.y);\n  return f;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 p = fragCoord.xy/iResolution.xy;\n  p-=0.5;\n  p.x *= iResolution.x/iResolution.y;\n  p*=15.0;\n  \n  float t = mod(0.7*iTime,4.0);\n  p.x+=6.0*easingSinInOut(t)*(1.0-step(1.0,t));\n  p.x+=6.0*step(1.0,t)*(1.0-step(2.0,t));\n  p.x+=(6.0-6.0*easingSinInOut(t))*step(2.0,t)*(1.0-step(3.0,t));\n  p.x+=0.0*step(3.0,t)*(1.0-step(4.0,t));\n\n  p.y+=0.0*(1.0-step(1.0,t));  \n  p.y+=6.0*easingSinInOut(t)*step(1.0,t)*(1.0-step(2.0,t));\n  p.y+=6.0*step(2.0,t)*(1.0-step(3.0,t));\n  p.y+=(6.0-6.0*easingSinInOut(t))*step(3.0,t)*(1.0-step(4.0,t));\n  \n  float gridsize = 1.3;\n \n  vec2 pcenter = floor((p)/gridsize);\n \n  float angle = 1.0+iTime+10.0*sin(1.0*pcenter.y+1.0*iTime)*sin(1.0*pcenter.x+1.0*iTime);\n  angle = angle;\n \n  vec2 prot=mod(p,gridsize)-gridsize/2.0;\n  prot  = mat2(\n    cos(angle),\n    sin(angle),\n    -sin(angle),\n    cos(angle)\n  )*prot;\n \n  vec2 ptrans = prot-vec2(0.0,0.0);\n  float f = triDist(ptrans);\n \n  ptrans = mat2(\n    cos(3.14159/1.0),\n    sin(3.14159/1.0),\n    -sin(3.14159/1.0),\n    cos(3.14159/1.0)\n  )*prot;\n  ptrans = ptrans-vec2(0.0,-0.0);\n \n  f = max(f,triDist(ptrans));\n \n  float m = 0.5+0.5*sin(123.0*pcenter.x+5587.0*pcenter.y+3.0*iTime);\n  fragColor = vec4(m*f,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdffDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 92], [94, 94, 116, 116, 247], [250, 250, 306, 306, 1509]], "test": "ok"}
{"id": "MdjcDV", "name": "Burning Ship <-> Mandelbrot", "author": "DonKarlssonSan", "description": "Burning Ship <-> Mandelbrot Morph\n\"The difference between [Burning Ship] calculation and that for the Mandelbrot set is that the real and imaginary components are set to their respective absolute values before squaring at each iteration - Wikipedia", "tags": ["fractal", "mandelbrot", "morph", "burningship"], "likes": 6, "viewed": 221, "published": "Public", "date": "1493937666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float xmin = -1.795;\n    float xmax = -1.715;\n    float ymin = 0.09;\n    float ymax = -0.089;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float x0 = (uv.x * (xmax - xmin) + xmin);\n    float y0 = (uv.y * (ymax - ymin) + ymin);\n    float x = 0.0;\n    float y = 0.0;\n    float mixAmount = cos(iTime/3.0)*0.5+0.5;\n    int iteration = 0;\n    const int max_iteration = 2000;\n    const float max_d_sq = 4.0;\n    float xtemp;\n    // while loops not supported on iPhone!!\n    // using for instead with a break condition\n    for(int i = 0; i < max_iteration; i++) {\n        xtemp = x*x - y*y + x0;\n        //y = 2.0*abs(x*y) + y0; // normal mandelbrot\n        y = 2.0*mix(abs(x*y), x*y, mixAmount) + y0;\n        x = xtemp;\n        iteration = i;\n        if(x*x + y*y > max_d_sq) \n            break;\n    }\n    float c = 1.0 - float(iteration)/float(max_iteration) * 35.0;\n    fragColor = vec4(mix(c, 0.0, mixAmount), 0.0, mix(0.0, c, mixAmount), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdjcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1009]], "test": "ok"}
{"id": "MdlfDH", "name": "cylinders to boxes?", "author": "lahwran", "description": "trying to convert cylinders to boxes but not sure exactly what distance function to change yet\n\nso far just screwing things up\n\n(clarification: not OC, just trying to change iq's shader)", "tags": ["procedural"], "likes": 0, "viewed": 158, "published": "Public", "date": "1496118294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#define VIS_SAMPLES 1\n\nfloat controlledTime() {return iTime*0.04;}\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\t\n\tf *= sqrt( textureLod( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0, 0.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<400; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris*0.3;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<16; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nvec3 desat( in vec3 col, float a )\n{\n    return mix( col, vec3(dot(col,vec3(0.333))), a );\n}\n\nvec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n        // background color\t\n\t\tfloat sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n\t\tvec3 bgcol = vec3(0.9,0.9,0.8) + 0.3*pow(sun,4.0)*vec3(1.0,1.0,0.0);\n\n        // raytrace\n        vec3 col = bgcol;\n\t\tvec4 res = castRay( ro, rd );\n        vec2 vos = res.zw;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\tvec3  nor = calcNormal( fract(pos)-0.5, res.y );\n\t\t\tfloat h = map(vos);\n\n            // material color\t\t\t\n\t\t\tvec3 mate1 = 0.5 + 0.45*sin( 3.14*id + 0.8 + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate2 = 0.5 + 0.45*sin( 6.28*id + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate = mix( mate1, mate2, smoothstep( 9.0, 11.0, h) );\n\t\t\t\n\t\t\tvec3 uvw = pos - vec3(0.0,h,0.0);\n\t\t\tvec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n\t\t\tmate *= 0.2+4.0*pow( desat(tex,0.3), vec3(2.0) );\n            mate *= 1.5*sqrt(texture( iChannel0, pos.xz/iChannelResolution[0].xy ).xyz);\n            mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\t\t\t\n            // material cheap/wrong bump\t\t\t \n            vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n            //nor = normalize(nor + 0.45*bn*(1.0-0.5*nor.y) );\n\t\t\t\n\t\t\t// procedural occlusion\n\t\t\tfloat occ = nor.y*0.75;\n\t\t\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\t\t\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\t\t\tocc = 0.2 + 0.8*occ;\n\t\t\tocc *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\t\t\tocc = occ*0.5+0.5*occ*occ;\n\t\t\tfloat rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n \n            //-------------\n            // lighitng\n            //-------------\n\t\t\tfloat amb = 1.0;\n            //-------------\n\t\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n            //-------------\n\t\t\tfloat sha = 0.0;\n\t\t\tfloat dif = dot( nor, lig );\n\t\t\tif( dif<0.0 ) dif=0.0; else sha = castShadowRay( pos, lig );\n            float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n            //-------------\n\t\t\tvec3 lin  = 3.00*vec3(1.0,1.0,1.0)*0.7*sqrt(dif)*sha;\n\t\t\t     lin += 0.40*vec3(0.4,1.0,1.7)*amb*occ;\n\t\t\t     lin += 0.60*vec3(0.8,0.5,0.3)*bac*occ;\n\t\t\t\n\t\t\tcol = mate * lin + tex.x*1.5*vec3(1.0,1.0,1.0)*(0.3+0.7*rim)*spe*dif*sha;\n\n            // tone mapping\t\t\t\n\t\t\tcol *= 1.1 + 0.5*dot( rd, lig );\n\n            // fog\n            float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n\t\t\tcol = mix( col, bgcol, 1.0-ff );\n\t\t}\n\t\tcol += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = controlledTime();\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*controlledTime() + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(controlledTime() + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(controlledTime()) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\t\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\t// vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( controlledTime() );\n\n    gAnimTime = controlledTime()*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[205, 205, 229, 229, 248], [250, 250, 274, 274, 312], [313, 313, 337, 337, 396], [397, 397, 421, 421, 471], [490, 490, 512, 512, 681], [683, 683, 728, 728, 802], [804, 804, 844, 844, 1820], [1822, 1822, 1869, 1869, 2695], [2697, 2697, 2725, 2749, 3137], [3139, 3139, 3191, 3191, 3320], [3322, 3322, 3358, 3358, 3414], [3460, 3460, 3499, 3528, 6329]], "test": "error"}
{"id": "MdlfRr", "name": "Mad Wave", "author": "metabog", "description": "Messing around trying to make a chaotic waveform. ", "tags": ["wave", "chaos", "scope", "mad"], "likes": 1, "viewed": 73, "published": "Public", "date": "1494694496", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERMAX 18\n\nfloat solve(float x, float ex)\n{\n    float val = 0.0;\n    for(int i = 0; i<ITERMAX;i++)\n    {\n        val = cos(val*val*1.5)+x*sin(val+ex) + val*0.4;\n    }\n    \n    return clamp(abs(val),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float funcval = solve(uv.x+0.25,iTime);\n    \n    //float scope_intensity = 1.0 - clamp(abs(funcval-uv.y)*16.0,0.0,1.0f);\n    float scope_intensity = clamp((funcval-uv.y)*16.0,0.0,1.0);;\n    \n\tfragColor = vec4(vec3(1.0)*scope_intensity,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 52, 52, 218], [220, 220, 277, 277, 571]], "test": "ok"}
{"id": "MdsBW8", "name": "Daily 2017-05-29", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 14, "viewed": 553, "published": "Public API", "date": "1496092014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 10.\n\nfloat C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n\nvec3 ro,rd;\nfloat c;\n\nvoid rays(vec3 p, vec3 d) {\n    vec3 n=cross(rd,d);\n    vec3 np=cross(rd,n),nq=cross(d,n);\n    float t=dot(ro-p,np)/dot(d,np),\n        r=dot(p-ro,nq)/dot(rd,nq);\n    float u=t+SIZE*.5;\n    float i=floor(u/SIZE);\n    u=mod(u,SIZE)-SIZE*.5;\n    u=sign(u)*min(abs(u),SIZE*.25);\n    u=i*SIZE+u;\n    vec3 h=p+d*u;\n    float l=length(cross(rd,ro-h));\n    c+=step(0.,r)*mix(.01,.005,sin(iTime*10.))/l/l*pow(max(1.-r*.032,0.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    c=0.;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    ro=vec3(-1.+sin(iTime*.3+2.)*.5,-1.+sin(iTime*.5+4.)*.5,iTime);\n    rd=normalize(vec3(uv,1.));\n    rd.xz*=rot(sin(iTime*.3));\n    rd.xy*=rot(sin(iTime*.5));\n    float o=floor(iTime/SIZE*2.)+6.;\n    for(float x=-6.;x<6.;x+=1.)\n    {\n        for(float y=-6.;y<6.;y+=1.)\n        {\n            rays(vec3(.5,y,x+o)*SIZE*.5, vec3(1.,0.,0.));\n            rays(vec3(y,.5,x+o)*SIZE*.5, vec3(0.,1.,0.));\n            rays(vec3(x,y,.5)*SIZE*.5, vec3(0.,0.,1.));\n        }\n    }\n    vec3 clr=mix(vec3(.1,.5,1.), vec3(.2,.6,1.),c)*c;\n    clr=sqrt(clr);\n\tfragColor = vec4(clr,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 123, 123, 520], [522, 522, 579, 579, 1254]], "test": "ok"}
{"id": "MdsBzn", "name": "smoke", "author": "lovelyH", "description": "I was trying to make fire. I end up with this. ", "tags": ["smoke"], "likes": 0, "viewed": 189, "published": "Public", "date": "1494678283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// rand\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/// UV\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t/// result\n\tfloat r= 0.0;\n\n\t/// repat whole process few times\n\tfor(float b=0.0;b<6.0;b++){\n\t\tconst float w=8.0;\n\t\tfor( float a=-w;a<=w;a++){\n\t\t\tconst float div= 1.0 / 64.0;\n\t\t\tfloat x= floor( uv.x/div )*div + div/2.0 + a*div;\n\n\t\t\tfloat y= mod( iTime+4.0*rand(vec2(x,0.5+b/16.0)), 4.0 );\n\n\t\t\t/// radius of ball\n\t\t\tfloat rad= div*(w+0.5) * clamp( 0.5*y+0.5, 0.1, 1.0 );\n\n\t\t\t/// ball as light as close to center\n\t\t\tfloat power= clamp( (rad-length(uv-vec2(x,(0.5+0.5*rand(vec2(x,-0.1)))*y-1.0)))/rad, 0.0, 1.0);\n\n\t\t\t/// darker at bottom and top of scene\n\t\t\tfloat h= rand(vec2(x,-0.1*b))*y-1.0;\n\t\t\tpower *= clamp( 1.0-abs(h), 0.0, 1.0 );\n\n\t\t\t/// apply this ball\n\t\t\tr += power;\n\t\t}\n\t}\n\n\t/// get rid of artifacts, look much better than clamp\n\tr= 1.0 - 1.0 / (1.0+r);\n\n\t/// return\n\tfragColor = vec4(r,r,r, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 29, 29, 96], [98, 98, 155, 163, 1071]], "test": "ok"}
{"id": "MdsBzr", "name": "Newton Fractal ----", "author": "DonKarlssonSan", "description": "n", "tags": ["fractal", "newton"], "likes": 4, "viewed": 109, "published": "Public", "date": "1494702158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n\n#define PI 3.14159265\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x,-a.y)\n#define cx_arg(a) atan2(a.y,a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = length(a);\n    float ipart = atan(a.y, a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) {\n    return cx_mul(z, z) + c;\n}\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\n\n////////////////////////////////////////////////////////////\n// end Complex Number math by julesb\n////////////////////////////////////////////////////////////\n\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// My own additions to complex number math\n#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)\n#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)\n#define cx_abs(a) length(a)\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.y / a.x);\n    float r = length(a);\n    return vec2(r, phi); \n}\n    \n// Complex power\n// Let z = r(cos θ + i sin θ)\n// Then z^n = r^n (cos nθ + i sin nθ)\nvec2 cx_pow(vec2 a, float n) {\n    float angle = atan(a.y, a.x);\n    float r = length(a);\n    float real = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(real, im);\n}\n   \nmat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// End utils, here comes the actual fractal\n\n// z^6 + z^3 - 1 \nvec2 f(vec2 z) {\n    return cx_pow(z, 6.0) + cx_pow(z, 3.0) - 1.0;\n} \n\n// f(z) derivated\n// 6*z^5 + 3*z^2\nvec2 fPrim(vec2 z) {\n    vec2 a = 6.0 * cx_pow(z, 5.0);\n    \n\tvec2 b = 3.0 * cx_pow(z, 2.0);\n    return cx_add(a, b);\n}\n\nconst int maxIterations = 90;\nvec2 one = vec2(1, 0);\nvec3 newtonRapson(vec2 z) {\n  vec2 oldZ = z;\n  float s = 0.0;\n  for(int i = 0; i < maxIterations; i++){\n    z = cx_sub(z, cx_div(f(z), fPrim(z))); \n    if(abs(oldZ.x - z.x) < 0.0001 && abs(oldZ.y - z.y) < 0.0001) {\n      break;\n    }\n    \n    vec2 w = cx_div(one, cx_sub(oldZ, z));\n    float wAbs = cx_abs(w);\n    \n    s += exp(-wAbs);\n    oldZ = z;\n  }\n  return vec3(s, cx_to_polar(z));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = (sin(iTime/3.0)*0.5+0.5)*3.0 + 1.0;\n    vec2 centered = (fragCoord - iResolution.xy * 0.5) / iResolution.xy * zoom;\n\tvec2 rotated = centered * rotate(iTime/2.0);\n    vec3 result = newtonRapson(rotated);\n    float c = 1.0-result.x/float(maxIterations)*7.0;    \n    vec3 color = hsv2rgb(vec3(result.z*3.0 + iTime/15.0, 1.0, c));    \n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 516, 516, 682], [684, 684, 705, 705, 743], [745, 745, 766, 766, 908], [910, 910, 934, 934, 1029], [1031, 1031, 1066, 1066, 1109], [1111, 1111, 1153, 1153, 1184], [1186, 1186, 1221, 1221, 1268], [1432, 1531, 1553, 1553, 1722], [1891, 1891, 1917, 1917, 2003], [2009, 2098, 2128, 2128, 2300], [2305, 2305, 2327, 2327, 2376], [2423, 2441, 2457, 2457, 2509], [2512, 2547, 2567, 2567, 2666], [2721, 2721, 2748, 2748, 3110], [3114, 3114, 3171, 3171, 3555]], "test": "ok"}
{"id": "MdScDK", "name": "Daily 2017-05-03", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 1, "viewed": 358, "published": "Public API", "date": "1493817065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on LJ magics\n\nvec3 ro,rd,mp;\nfloat md;\n\nmat2 r2d(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nfloat soc(vec3 p){vec3 n=normalize(sign(p));return min(min(dot(p.xy,n.xy),dot(p.yz,n.yz)),dot(p.xz,n.xz));}\n\nfloat map(vec3 p){\n    p.xy*=r2d(iTime*.7);\n    p.yz*=r2d(iTime*.5);\n\tp.xz*=r2d(iTime*.3);\n    return soc(max(abs(p)-.2,1e-6))-.1*sqrt(2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    ro=vec3(uv,3.);\n    rd=vec3(uv,-1.);\n    mp=ro;\n    for(int i=0;i<50;++i){\n        md=map(mp);\n        if(md<.001)break;\n        mp+=rd*md;\n    }\n\tfragColor = vec4(length(mp-ro)*.1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdScDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 67, 67, 114], [115, 115, 133, 133, 222], [224, 224, 242, 242, 365], [367, 367, 424, 424, 672]], "test": "ok"}
{"id": "MdsfDH", "name": "19/100", "author": "yahe", "description": "19/100", "tags": ["wave"], "likes": 2, "viewed": 418, "published": "Public API", "date": "1496123180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on shader by Vamoss\n// https://www.shadertoy.com/view/XtjSzw\n\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n    float radius = .3;\n    \n    //tile\n    vec2 frequency = vec2(33.0, 18.0);\n    vec2 index = floor(frequency * st)/frequency;\n    float centerDist = 1.0-length(index-0.5 * (sin(iTime)+1.));\n    vec2 nearest = 2.0 * fract(frequency * st) - 1.0;\n    \n    //movement\n    float velocity = 5.0;\n    nearest.x += cos(iTime * velocity + centerDist * TWO_PI)*(1.0-radius);\n    nearest.y += sin(iTime * velocity + centerDist * TWO_PI)*(1.0-radius);\n    \n    //circle\n    float dist = length(nearest);\n    float circle = step(radius, dist);\n    \n    //colors\n    vec3 bgColor = vec3(0.0, 0.0, 0.0);\n    \n    float colorAngle = centerDist;\n    vec3 circleColor = vec3(colorAngle*sin(iTime/5.0)+0.2, colorAngle*.4*cos(iTime/5.0+2.0)+0.2, colorAngle*.5*cos(iTime+2.0)+0.4);\n    \n    vec3 color = mix(circleColor, bgColor, circle);\n    \n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(vec3(centerDist), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 158, 158, 1111]], "test": "ok"}
{"id": "MdsfDn", "name": "Spikeball_v2", "author": "tholzer", "description": "Modified spikeball demo from Patapom's  https://www.shadertoy.com/view/lds3WH\n\nWhat kind of basic polyhedron is this?", "tags": ["3d", "sphere", "animated", "ball", "spherical", "spike"], "likes": 0, "viewed": 285, "published": "Public", "date": "1495786108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------------------------\n// Spikeball_v2.glsl    \n// Modified spikeball demo from Patapom, \n//   see  https://www.shadertoy.com/view/lds3WH\n// which code was stolen from pouet.net and adapted\n//-------------------------------------------------------\n\n#define t iTime*0.1\n\nfloat spikeball(vec3 p, vec3 v)\n{\n  vec3 c[19];\n  c[0] = vec3(1,0,0);\n  c[1] = vec3(0,1,0);\n  c[2] = vec3(0,0,1);\n  c[3] = vec3(.577,.577,.577);\n  c[4] = vec3(-.577,.577,.577);\n  c[5] = vec3(.577,-.577,.577);\n  c[6] = vec3(.577,.577,-.577);\n  c[7] = vec3(0,.357,.934);\n  c[8] = vec3(0,-.357,.934);\n  c[9] = vec3(.934,0,.357);\n  c[10] = vec3(-.934,0,.357);\n  c[11] = vec3(.357,.934,0);\n  c[12] = vec3(-.357,.934,0);\n  c[13] = vec3(0,.851,.526);\n  c[14] = vec3(0,-.851,.526);\n  c[15] = vec3(.526,0,.851);\n  c[16] = vec3(-.526,0,.851);\n  c[17] = vec3(.851,.526,0);\n  c[18] = vec3(-.851,.526,0);\n\n  float MinDistance = 9999.;\n  for ( int i=3; i < 19; i++ )\n  {\n    float d = clamp( dot( p, c[i] ), -1.0, 1.0 );\n    vec3 proj = d * c[i];\n    d = abs( d );\n\t\t\n    float Distance2Spike = length( p - proj );\n    float sd = 1.4+ 0.6*sin(t*8.);\n    float SpikeThickness = 01. * exp( -sd*d ) + 0.0;\n    float Distance = Distance2Spike - SpikeThickness;\n    MinDistance = min( MinDistance, Distance );\n  }\n  return MinDistance;\t\n}\n\n// Rotation\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nfloat Distance( vec3 p, vec3 v )\n{\n\tvec3 q = p;\n\tR( p.yz, t );\n\tR( p.xz, 2.0*t + p.x*sin(t)*0.2 );\n\tfloat d = spikeball(p, v);\n//return d;   // black background\n\tfloat nd = dot( q + vec3(0.0, 3.0, 0.0), vec3(0.0, 1.0, 0.0));\n\treturn min( nd, d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aspect = vec2( iResolution.x / iResolution.y, 1 );\n  vec3 p = vec3( 0, 0, 12 );\n  vec3 v = vec3( (2.0 * uv - 1.0) * aspect, 0 ) ;\n  v = 0.8*normalize(v - p*0.7);\n  \n  // Raymarching loop\n  float r, l, a, s, ml=0.0001;\n  for ( int i=0; i < 64; i++ )\n  {\n    l = Distance(p, v);\n    p += l*v;\n    l = abs(l);\n    r += l;\n    if (l < ml*r) break;\n  }    \n\t\n  // Compute normal\n  vec2 epsilon = vec2( 0.001,0.0 );\n  float pd = Distance(p, v);\n  vec3 n = vec3( Distance(p+epsilon.xyy, v) - pd,\n                 Distance(p+epsilon.yxy, v) - pd,\n                 Distance(p+epsilon.yyx, v) - pd);\n  float c = 1.0 + dot(normalize(n),v);\n  fragColor = vec4(c,c,c, 1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 338, 338, 1324], [1388, 1388, 1422, 1422, 1636], [1638, 1638, 1695, 1695, 2409]], "test": "ok"}
{"id": "MdsfR8", "name": "Pruebas_03", "author": "ps", "description": "raymarching", "tags": ["raymarching"], "likes": 3, "viewed": 79, "published": "Public", "date": "1494937361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// iluminación de iq http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo paret de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\n// define el terreno (signed distanced function) dada unas coordenadas x y z devuelve si ha colisionado o no\nfloat terrainSDF (vec2 posxz){\n    float x=posxz.x;\n    float  z=posxz.y;\n    return 3.2 + 0.1*sin(20.0*x)*cos(20.0*z);\n}\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n    return terrainSDF(posxz);\n}\n// \nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = tmin;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - scene( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 calcNormal( in vec3 pos)\n{\n    vec2  eps = vec2( 0.0001 );\n    return normalize( vec3( scene(pos.xz-eps.xy) - scene(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            scene(pos.xz-eps.yx) - scene(pos.xz+eps.yx) ) );\n}\n\nvec3 makeFog(in vec3 realColor, vec3 fogColor, float distancia, float fogDensity){\n    float theE = 2.718281828459045235360;\n\tfloat res = 1.0/(pow(theE,((distancia*fogDensity)*(distancia*fogDensity)*(distancia*fogDensity))));\n    return mix(fogColor,realColor,res);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    /*vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n  //  vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(10.0 * sin(iTime),  2.0,10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;*/\n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    Sfactor=pow(Sfactor,length(nor));\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n}\n\nfloat fogAngleFixer(vec3 angle){\n\treturn clamp(-angle.y*2.0+0.1,0.0,1.0);   \n}\nvec3 getBackground(vec3 angle){\n    float heigh = clamp(angle.y*2.0+0.2,0.0,1.0);\n    return vec3(0.3*(1.0-heigh),0.5*heigh*0.5+0.5,1.0*heigh/2.0+0.5);\n}\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n    float fogDensity = 0.1;\n    fogDensity*=fogAngleFixer(rd);\n    vec3 fogColor = vec3(1.0,1.0,1.0);\n    //return vec4(fogDensity);\n \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n\n        //draw background\n        col = getBackground(rd);// colorBackground;\n        t = -1.0;\n        col = makeFog(col, fogColor, tmax, fogDensity);\n    \n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos, t );\n      //   return vec4 (nor,1. );\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_s = vec3(0.2, 0.2, 0.2);\n        float shininess = 1.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        //return vec4(color,1.0);\n\t\tcol = makeFog(color, fogColor, t*3.0, fogDensity);\n        \n    }\n\treturn vec4(col,t);\n}\n\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\t//vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    //vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n   \n    vec2  m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\ndir.xz = rot2D(dir.xz, 180. * m.x);\n    \n    vec3 ro = vec3(0.0, 4.8, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,dir); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdsfR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[606, 715, 745, 745, 836], [837, 905, 929, 929, 961], [962, 966, 1039, 1039, 1236], [1239, 1239, 1280, 1280, 1509], [1511, 1511, 1542, 1542, 1765], [1767, 1767, 1849, 1849, 2034], [2036, 2036, 2176, 2176, 2762], [2764, 3134, 3238, 4095, 5015], [5017, 5017, 5049, 5049, 5095], [5096, 5096, 5127, 5127, 5249], [5250, 5250, 5285, 5285, 6476], [6478, 6478, 6511, 6511, 6636], [6638, 6638, 6695, 6790, 7341]], "test": "ok"}
{"id": "Mdsfz7", "name": "Sampling function grapher", "author": "grinist", "description": "Draws an explicit function of x, sampling in x neighbourhood. Focusing on decent looking output, see remarks in code comments. Oscilloscope thing version: https://www.shadertoy.com/view/4dfBWn", "tags": ["2d", "oscilloscope", "antialias", "graph"], "likes": 12, "viewed": 757, "published": "Public API", "date": "1495529903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Draws an explicit function of x. I was focusing on getting decent looking output\n// with constant line size and \"disconnected discontinuities\".\n// Remarks:\n// The naive sampling approach has its problems.\n// The drawing code and the function itself are coupled. At least sampling could be separated.\n// A good sampling step size depends on local function gradient and graph range.\n// Performance is proportional to line width, aa falloff and sample step; easy to\n// make it too heavy.\n// Connected line segments would be more performant, but would mask the discontinuity.\n// Aliasing on this looks funky. :)\n\n// The values below control the rendering, knock yourself out.\n#define AA_FALLOFF 1.0\t\t\t// AA falloff in pixels, must be > 0, affects all drawing\n#define GRID_WIDTH 0.1\t\t\t// grid line width in pixels, must be >= 0\n#define CURVE_WIDTH\t8.0\t\t\t// curve line width in pixels, must be >= 0\n\n#define FUNC_SAMPLE_STEP 0.2\t// function sample step size in pixels\n\nfloat pp; \t\t\t// pixel pitch in graph units\n\n// The function to be drawn\nfloat func(float x)\n{\n    float p = (x + iTime * 0.1) * 6.2832;\n    float f = 1.0 * sin(p);\n    f += 0.5 * sin(p * 3.0);\n    f += 0.25 * sin(p * 5.0 + iTime * 2.5);\n    f *= 0.5;\n    return 0.5 + step(-0.5, x) * step(x, 1.5) * f;\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat aaStep(float a, float b, float x)\n{\n    // lerp step, make sure that a != b\n    return (clamp(x, a, b) - a) / (b - a);\n}\n\n// Alphablends color\nvoid blend(inout vec4 baseCol, vec4 color, float alpha)\n{\n    baseCol = vec4(mix(baseCol.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\n// Draws a gridline every stepSize\nvoid drawGrid(inout vec4 baseCol, vec2 xy, float stepSize, vec4 gridCol)\n{\n\tfloat hlw = GRID_WIDTH * pp * 0.5;\n    float mul = 1.0 / stepSize;\n\tvec2 gf = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul));\n\tfloat g = 1.0 - aaStep(hlw * mul, (hlw + pp * AA_FALLOFF) * mul, min(gf.x, gf.y));\n    blend(baseCol, gridCol, g);\n}\n\n// Draws a circle\nvoid drawCircle(inout vec4 baseCol, vec2 xy, vec2 center, float radius, vec4 color)\n{\n    float r = length(xy - center);\n    float c = 1.0 - aaStep(radius, radius + pp * AA_FALLOFF, r);\n    blend(baseCol, color, c);\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float hlw = CURVE_WIDTH * pp * 0.5;\n    \n    // cover line width and aa\n    float left = xy.x - hlw - pp * AA_FALLOFF;\n    float right = xy.x + hlw + pp * AA_FALLOFF;\n    float closest = 100000.0;\n    for (float x = left; x <= right; x+= pp * FUNC_SAMPLE_STEP)\n    {\n        vec2 diff = vec2(x, func(x)) - xy;\n        float dSqr = dot(diff, diff);\n        closest = min(dSqr, closest);\n    }\n    \n\tfloat c = 1.0 - aaStep(hlw, hlw + pp * AA_FALLOFF, sqrt(closest));\n\tblend(baseCol, curveCol, c);    \n}\n\nmat2 rotate2d(float angle)\n{\n    float sina = sin(angle);\n    float cosa = cos(angle);\n    return mat2(cosa, -sina,\n                sina, cosa);\n}\n\n// Finds the next smaller power of 10\nfloat findMagnitude(float range)\n{\n    float l10 = log(range) / log(10.0);\n    return pow(10.0, floor(l10));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n    float z = 0.0;\n\t// comment out disable zoom:\n    z = sin(iTime * 0.3) * 1.1;\n    \n    float graphRange = 0.4 + pow(1.5, z * z * z);\n\tvec2 graphSize = vec2(aspect * graphRange, graphRange);\n\tvec2 graphPos = 0.5 - graphSize * 0.5;\t// center at (0.5, 0.5)\n\n    vec2 xy = graphPos + uv * graphSize;\t// xy = current graph coords\n    pp = graphSize.y / iResolution.y;\t\t// pp = pixel pitch in graph units\n    \n    // comment out to disable rotation:\n   \txy = rotate2d(sin(iTime * 0.2) * 0.2) * (xy - 0.5) + 0.5;\n\n    // background\n    float t = length(0.5 - uv) * 1.414;\n    t = t * t * t;\n\tvec4 col = mix(vec4(0.1, 0.25, 0.35, 1.0), vec4(0.0, 0.0, 0.0, 1.0), t);\n    \n\t// grid\n    float range = graphSize.y * 2.0;\n    //float mag = findMagnitude(range);\n    drawGrid(col, xy, 0.1, vec4(1.0, 1.0, 1.0, 0.1));\n\tdrawGrid(col, xy, 0.5, vec4(1.0, 1.0, 1.0, 0.1));\n\tdrawGrid(col, xy, 1.0, vec4(1.0, 1.0, 1.0, 0.4));\n\n    // curve\n    vec4 cCol = vec4(0.0, 1.0, 0.7, 0.8);\n    drawFunc(col, xy, cCol);\n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdsfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1010, 1038, 1059, 1059, 1269], [1271, 1330, 1371, 1411, 1456], [1458, 1479, 1536, 1536, 1609], [1611, 1646, 1720, 1720, 1977], [1979, 1997, 2082, 2082, 2214], [2216, 2267, 2326, 2401, 2906], [2908, 2908, 2936, 2936, 3054], [3056, 3094, 3128, 3128, 3204], [3206, 3206, 3261, 3261, 4395]], "test": "ok"}
{"id": "MdSyW3", "name": "Newton Fractal - Smooth Color", "author": "DonKarlssonSan", "description": "Newton Fractal with smooth color\nSmoothness math from: \nhttp://www.hiddendimension.com/fractalmath/Convergent_Fractals_Main.html", "tags": ["fractal"], "likes": 2, "viewed": 106, "published": "Public", "date": "1494010938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n\n#define PI 3.14159265\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x,-a.y)\n#define cx_arg(a) atan2(a.y,a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n    float ipart = atan(a.y,a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) {\n    return cx_mul(z, z) + c;\n}\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\n\n////////////////////////////////////////////////////////////\n// end Complex Number math by julesb\n////////////////////////////////////////////////////////////\n\n\n// My own additions to complex number math\n#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)\n#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)\n#define cx_abs(a) sqrt(a.x * a.x + a.y * a.y)\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.x / a.y);\n    float r = sqrt(a.x * a.x + a.y * a.y);    \n    return vec2(r, phi); \n}\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// Actual fractal begins here\n\n// z^3 - 1  \nvec2 f(vec2 z) {\n  vec2 z3 = cx_mul(z, cx_mul(z, z));\n  return vec2(z3.x - 1.0, z3.y);\n} \n\n// f(z) derivated\n// 3z^2  \nvec2 fPrim(vec2 z) {\n  vec2 z2 = cx_mul(z, z);\n  return vec2(3.0*z2.x, 3.0*z2.y);\n}\n\n\nint maxIterations = 50;\nvec2 one = vec2(1, 0);\nfloat newtonRapson(vec2 z) {\n  vec2 oldZ = z;\n  float s = 0.0;\n  for(int i = 0; i < maxIterations; i++){\n    z = cx_sub(z, cx_div(f(z), fPrim(z))); \n    if(abs(oldZ.x - z.x) < 0.001 && abs(oldZ.y - z.y) < 0.001) {\n      return s;\n    }\n    \n    vec2 w = cx_div(one, cx_sub(oldZ, z));\n    float wAbs = cx_abs(w);\n    \n    s += exp(-wAbs);\n    oldZ = z;\n  }\n  return float(maxIterations);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float zoom = (sin(iTime)*0.5+0.43)*3.0+0.3;\n    vec2 scaled = zoom*(uv*6.0-3.0);\n    float cs = cos(iTime);\n\tfloat sn = sin(iTime);\n    vec2 rotated = vec2(scaled.x * cs - scaled.y * sn, scaled.x * sn + scaled.y * cs);\n    float hue = newtonRapson(rotated) / float(maxIterations)*9.0;\n    vec3 c = hsv2rgb(vec3(hue, 1.0, 1.0));\n    fragColor = vec4(c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 516, 516, 694], [696, 696, 717, 717, 755], [757, 757, 778, 778, 935], [937, 937, 961, 961, 1056], [1058, 1058, 1093, 1093, 1136], [1138, 1138, 1180, 1180, 1211], [1213, 1213, 1248, 1248, 1295], [1644, 1644, 1670, 1670, 1778], [1780, 1879, 1901, 1901, 2070], [2104, 2117, 2133, 2133, 2205], [2208, 2236, 2256, 2256, 2319], [2369, 2369, 2397, 2397, 2757], [2760, 2760, 2817, 2817, 3226]], "test": "ok"}
{"id": "MdSyWK", "name": "Holy hell, lots of 3D cubessss", "author": "loolo78", "description": "Damn, things escalated quikly", "tags": ["sdf", "fractals"], "likes": 3, "viewed": 212, "published": "Public", "date": "1493790351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Tutorial used: https://www.shadertoy.com/view/lt33z7\n    I rewrote everything for practice.\n*/\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST         = 0.0;\nconst float MAX_DIST         = 2000.0;\nconst float EPSILON          = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat boxSDF( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p)\n{\n    pMod3(p, vec3(5,5,5));\n    return boxSDF(p, vec3(0.5));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phoneContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                            vec3 lightPos, vec3 lightIntensity)\n{ \n    vec3 N = estimateNormal(p); // Estimate normal of surface\n    vec3 L = normalize(lightPos - p); // Point from point on surface to light\n    float light_dist = distance(eye, p);\n    vec3 V = normalize(eye - p); // Viewing vector, used to diffuse reflected light\n    vec3 R = normalize(reflect(-L, N)); // Reflect light to the normal\n\n    float dotLN = dot(L,N); // cosine angle between light direction and normal direction\n    float dotRV = dot(R,V); // cosine angle between reflection direction and viewing direction\n    \n    // Light is coming from behind the normal of the face, pitch black\n    if (dotLN < 0.)\n    {\n        return vec3(0.0);\n    }\n    // Reflected light points away from the camera, so there are no direct light. Only ambient light and diffuse color\n    if (dotRV < 0.)\n    {\n        // This value maxes when dotLN = 1, which is when L(light) and N(normal) are equal. 100% of the light is reflected back\n        return min(1., abs(30./light_dist)) * lightIntensity * (k_d * dotLN);\n    }\n    return min(1., abs(30./light_dist)) * lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    }\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 globalAmbentLight = 0.9 * vec3(1.);\n    vec3 color = globalAmbentLight * k_a; // Multiply brightness by color to get ambient color\n\n    // Light 1\n    vec3 light1Pos = vec3(0.,1.,3.);\n    vec3 light1Insentity = vec3(0, 67.1/100., 43.5/100.);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Insentity);\n\n\n    // Light 2\n    vec3 light2Pos = vec3(-1.,-1.,1.);\n    vec3 light2Insentity = vec3(50./100., 59.2/100., 0);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Insentity);\n\n    // Light 3\n    vec3 light3Pos = vec3(-0.5,2,-3.);\n    vec3 light3Insentity = vec3(4.7/100., 35.3/100., 65.1/100.);\n    color += phoneContribForLight(k_d, k_s, alpha, p, eye, light3Pos, light3Insentity);\n\n    return color;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    // Start depth\n    float depth = start;\n    // Keep looking for where the marching ray hits a surface\n    for (int i = 0; i < MAX_MARCHING_STEPS; ++i)\n    {\n        // Get the distance from marching ray point to surface of box\n        float dist = sceneSDF(eye + marchingDirection * depth);\n        // If we've hit near the surface, return this distance\n        if (dist < EPSILON)\n        {\n            return depth;\n        }\n        // Didn't find anything, let's go to where we found something\n        depth += dist;\n        // We're at the end, stop\n        if (depth > end)\n        {\n            return end;\n        }\n    }\n    // Ran out of steps before we hit the end, just return end\n    return end;\n}\n\n/**\n    fov:         Field of View of camera\n    screen_size: Screen size\n    fragCoord:   Screen coord of pixel\n    return:      Direction of rendering ray of the projection camera\n */\nvec3 rayDirection(float fov, vec2 screen_size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - screen_size / 2.0;\n    float z = (screen_size.y / 2.) / tan(radians(fov) / 2.);\n    return normalize(vec3(xy,-z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 lookAtMatrix(vec3 eye, vec3 center, vec3 up) \n{\n    // Based on gluLookAt man page\n    // Forward/Look at vector\n    vec3 f = normalize(center - eye);\n    // Right vector\n    vec3 v = normalize(cross(f, up));\n    // Camera local up Vector\n    vec3 u = cross(v, f);\n    return mat3(\n        vec3(v),\n        vec3(u),\n        vec3(-f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_space_dir = rayDirection(60., iResolution.xy, gl_FragCoord.xy);\n    vec3 eye = \n        vec3(\n            cos(iTime*0.25) * 100.,\n            cos(iTime) * 30.,\n            (sin(iTime)+5.) * 1.5\n            );\n\n   vec3 world_space_dir = lookAtMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0,1,0)) * camera_space_dir;\n    // Find shortest distance surface\n    float dist = shortestDistanceToSurface(\n        eye,\n        world_space_dir, \n        MIN_DIST, \n        MAX_DIST);\n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.2 * vec3(1.), 1);\n        return;\n    }\n\n    // We've hit a surface\n    // Phong shading time!!\n    // Surface point\n    vec3 p = eye + dist * world_space_dir;\n\n    vec3 K_ambientColor = vec3(0.2, 0.2, 0.2);\n    vec3 K_diffuseColor = vec3(0.7, 0.2, 0.2);\n    vec3 K_specularColor = vec3(1.0, 1.0, 1.0);\n    float shineness = 20.0;\n\n    vec3 color = phongIllumination(K_ambientColor, K_diffuseColor, K_specularColor, shineness, p, eye);\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 344, 376, 376, 416], [419, 449, 486, 486, 578], [580, 820, 844, 844, 906], [908, 908, 937, 937, 1247], [1249, 1741, 1883, 1883, 3002], [3004, 3374, 3459, 3459, 4234], [4236, 4657, 4748, 4767, 5463], [5465, 5651, 5715, 5715, 5855], [5857, 6184, 6236, 6301, 6530], [6532, 6532, 6589, 6589, 7607]], "test": "ok"}
{"id": "MdXBR4", "name": "everyday 008/100", "author": "kalin", "description": "everyday 8/100", "tags": ["everyday"], "likes": 1, "viewed": 99, "published": "Public", "date": "1494996870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    float t = iTime;\n    float tt = texture(iChannel0, uv).x;\n    \n    tt = pow(tt, 0.4 * nuv.x);\n    \n\tfragColor.x = sin(10.0 * (uv.x * sin(t * 0.3) + uv.y * cos(t * 0.01)) + t);\n    fragColor.y = sin(nuv.x * 0.3 * sin(t * 1.3) + nuv.y * 0.4 * sin(t * 0.2));\n    \n    float cx = nuv.x * 0.3 * sin(t * 0.2);\n    float cy = nuv.y * 0.5 * cos(t * 0.4) * tt * 0.1;\n    fragColor.z = sin(sqrt(520.0 * (cx * cx + cy * cy) + 1.0) + t * 3.0);\n    \n    fragColor.x = fragColor.x + fragColor.z;\n    fragColor.y = fragColor.x * fragColor.x * 0.3 - fragColor.z * 0.2;\n    fragColor.z = fragColor.x * 0.2;\n    \n    fragColor.x -= length(nuv) * 4.0;\n    fragColor.y += cy * nuv.x;\n    fragColor.z *= cx;\n    \n    fragColor.xyz += vec3(0.1, 0.1, 0.4);\n    fragColor.xyz += length(fragColor.xyz) * 0.1 * tt;\n    fragColor.x += fragColor.x * tt * 2.0;\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 968]], "test": "error"}
{"id": "MdXBzH", "name": "everyday 006/100", "author": "kalin", "description": "everyday 6/100", "tags": ["everyday"], "likes": 0, "viewed": 86, "published": "Public", "date": "1494825223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926535;\n\nfloat sdsphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdtorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat displacement(vec3 p, float c)\n{\n\treturn sin(c * p.x) * sin(c * p.y) * sin(c * p.z);\n}\n\nfloat sdspheredisplace(vec3 p, float r, float c)\n{\n    float d1 = sdsphere(p, r);\n    float d2 = displacement(p, c);\n    return d1 + d2;\n}\n\nfloat map(vec3 p)\n{\n    float a = sdtorus(p + vec3(-0.25, 0.0, 0.0), vec2(0.1, 0.01));\n    float b = sdtorus(p + vec3(+0.25, 0.0, 0.0), vec2(0.1, 0.01));\n    \n\treturn min(a, b);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n    for(int i = 0; i < 64; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    nuv.x *= iResolution.x / iResolution.y;\n\n    vec2 rot = vec2(iTime * 1.0, iTime * 1.0);\n    mat2 rotm = mat2(cos(rot.y), -sin(rot.x), sin(rot.x), cos(rot.y));\n    \n    float tt0 = texture(iChannel0, vec2(0.0, 0.0)).x;\n    float tts = \n        texture(iChannel0, vec2(0.1, 0.0)).x +\n        texture(iChannel0, vec2(0.2, 0.0)).x +\n        texture(iChannel0, vec2(0.3, 0.0)).x +\n        texture(iChannel0, vec2(0.4, 0.0)).x +\n        texture(iChannel0, vec2(0.5, 0.0)).x +\n        texture(iChannel0, vec2(0.6, 0.0)).x +\n        texture(iChannel0, vec2(0.7, 0.0)).x +\n        texture(iChannel0, vec2(0.8, 0.0)).x +\n        texture(iChannel0, vec2(0.9, 0.0)).x;\n    \n    tts /= 9.0;\n\n    \n    vec3 ro = vec3(cos(iTime) * 0.0, sin(iTime) * 0.0, -0.5 + sin(iTime) * 0.4 * tt0);\n    vec3 rd = normalize(vec3(nuv, 1.0));\n    \n    rd.xy = rd.xy * rotm;\n    \n    float d = march(ro, rd);\n    float r = step(d, 0.99);\n    \n    vec4 bbg = vec4(0.1, 0.4, 0.5, 1.0);\n    vec4 bg = vec4(0.0, 0.2, 0.7, 1.0);\n    vec4 fg = vec4(0.2, 1.5, 0.0, 1.0);\n    \n    fragColor = bbg + bg * pow(tts * .25, 0.4) + fg * r * d;\n\n    float c0 = sin(d);\n    float c1 = sin(d);\n    float c2 = abs(sin(uv.x - 0.5)) + abs(sin(uv.y - 0.5));\n   \n    fragColor.xy += tts * tt0 * (2.5 + tts * 0.3) * c0 * fragColor.y;\n    fragColor.z *= c2 * fragColor.y * 3.0 * (1.0 + tts);\n    \n    float t = iTime;\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 59, 59, 87], [89, 89, 120, 120, 190], [192, 192, 229, 229, 283], [285, 285, 335, 335, 423], [425, 425, 444, 444, 604], [606, 606, 637, 637, 791], [793, 793, 848, 848, 2289]], "test": "error"}
{"id": "MdXBzM", "name": "raym donuts", "author": "anclin", "description": "raym donuts", "tags": ["raymdonuts"], "likes": 0, "viewed": 81, "published": "Public", "date": "1495743000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SceneSDF(vec3 p){\n    \n    p = rotateY(iTime * 0.5) * p;\n    \n    float final = CubeSDF(p, vec3(0.01));;\n    \n    float count = 5.0;\n    float gap = 7.0;\n    float width = gap * (count-1.0);\n    \n    for(float i = 0.0; i < count; i += 1.0){\n        for(float j = 0.0; j < count; j += 1.0){\n            float x = gap * i - width * 0.5;\n            float z = gap * j - width * 0.5;\n            float angle = 5.0;\n            float y = sin(i * angle + iTime) + cos(j * angle + iTime);\n            y *= 0.75;\n            vec3 offset = vec3(x, y, z);\n            float torus = TorusSDF(p + offset, vec2(1,0.45));\n            final = unionSDF(final, torus);\n        }\n    }\n    \n    \n    \n    //final = torus;\n    \n    return final;\n}\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for(int i = 0; i < 255; i++){\n    \tfloat dist = SceneSDF(eye + depth * marchingDirection);\n        if( dist <= EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    vec3 eye = vec3(0.0 + 0.0 * cos(iTime),\n                    12.0 + 0.0 * sin(iTime),\n                    40.0 + 0.0 * sin(iTime));\n    \n    vec3 lookAtPos = vec3(2.0 + 0.0 * cos(iTime),\n                          0.0 + 0.0 * sin(iTime/2.0),\n                          -3.0 + 0.0 * sin(iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    \n    float dist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(1,0,0);\n    \n    //vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n    \tfinalColor = (normal + vec3(1.0)) / 2.0;\n        //finalColor = finalColor * (diffuse + ambientColor);\n        finalColor = finalColor * remap(60.0, 20.0, 0.0, 1.0, dist);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 136, 136, 206], [208, 254, 281, 281, 428], [430, 521, 567, 567, 599], [601, 685, 727, 727, 759], [761, 850, 897, 897, 930], [932, 932, 968, 968, 996], [998, 998, 1031, 1031, 1234], [1236, 1236, 1270, 1270, 1335], [1337, 1337, 1360, 1360, 2071], [2073, 2073, 2101, 2101, 2399], [2401, 2490, 2519, 2519, 2829], [2831, 2831, 2895, 2895, 3024], [3026, 3026, 3116, 3116, 3403], [3405, 3732, 3781, 3816, 4042], [4044, 4044, 4101, 4101, 5428]], "test": "ok"}
{"id": "MdXfDr", "name": "Resolution", "author": "anclin", "description": "Resolution", "tags": ["resolution"], "likes": 1, "viewed": 61, "published": "Public", "date": "1495655911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res1 = (100.0-1.0) * ((sin(iTime)+1.0)/2.0) + 1.0;//sinus\n    float res2 = (30.0-1.0) * abs(mod(iTime * 0.1,2.0)-1.0);//linear bounce\n    float res = res2;\n    \n    vec2 uv = vec2(floor(fragCoord.x / res) * res, floor(fragCoord.y / res) * res) / iResolution.xy;\n    \n    vec3 color = vec3(uv,1);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 400]], "test": "ok"}
{"id": "MdXfzN", "name": "basic_cube", "author": "flewww", "description": "cube", "tags": ["cube"], "likes": 1, "viewed": 390, "published": "Public API", "date": "1495061909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotmat() {\n    float a = iTime;\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat dist(vec3 p) {\n    mat2 r = rotmat();\n    p.xy *= r;\n    p.yz *= r;\n    p.xz *= r;\n    vec3 delta = abs(p) - 0.6;\n    return length(max(delta, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2.0 * (fragCoord.xy/iResolution.xy - 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 d = normalize(vec3(uv, -1.0));\n    vec3 p = vec3(uv, 1.0);\n    vec3 o = p;\n    int i=0;\n    float dst;\n    for(i=0; i<60; i++) {\n        dst = dist(p);\n        if(dst < 0.01) {\n            break;\n        }\n        p += dst*d;\n    }\n    if(dst < 0.1) {\n        fragColor = vec4(length(p-o)*0.5);\n    } else {\n        fragColor = vec4(uv, 0.0, 0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 15, 15, 88], [90, 90, 110, 110, 247], [249, 249, 306, 306, 774]], "test": "ok"}
{"id": "Ms2cWG", "name": "Newton Raphson Fractal - Color", "author": "DonKarlssonSan", "description": "Newton fractal for z^3-1 with color.\n\nSometimes flickers in Chrome, runs fine in Firefox...", "tags": ["fractal", "newton"], "likes": 1, "viewed": 73, "published": "Public", "date": "1493668386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n\n#define PI 3.14159265\n\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x,-a.y)\n#define cx_arg(a) atan2(a.y,a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = sqrt(a.x*a.x+a.y*a.y);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n    float ipart = atan(a.y,a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) {\n    return cx_mul(z, z) + c;\n}\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\n\n////////////////////////////////////////////////////////////\n// end Complex Number math by julesb\n////////////////////////////////////////////////////////////\n\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// My own additions to complex number math\n#define cx_sub(a, b) vec2(a.x - b.x, a.y - b.y)\n#define cx_add(a, b) vec2(a.x + b.x, a.y + b.y)\n\nvec2 cx_to_polar(vec2 a) {\n  float phi = atan(a.x, a.y);\n  float r = sqrt(a.x * a.x + a.y * a.y);    \n  return vec2(r, phi); \n}\n    \n    \n// End utils, here comes the actual fractal\n\n// z^3 - 1  \nvec2 f(vec2 z) {\n  vec2 z3 = cx_mul(z, cx_mul(z, z));\n  return vec2(z3.x - 1.0, z3.y);\n} \n\n// f(z) derivated\n// 3z^2  \nvec2 fPrim(vec2 z) {\n  vec2 z2 = cx_mul(z, z);\n  return vec2(3.0*z2.x, 3.0*z2.y);\n}\n\n\nint maxIterations = 300;\nvec3 newtonRapson(vec2 z) {\n  vec2 oldZ = z;\n  int iterations = 0;\n  for(int i = 0; i < maxIterations; i++){\n    z = cx_sub(z, cx_div(f(z), fPrim(z))); \n    if(abs(oldZ.x - z.x) < 0.001 && abs(oldZ.y - z.y) < 0.001) {\n      break;\n    }\n    oldZ = z;\n    iterations++;\n  }\n  return vec3(float(iterations), cx_to_polar(z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float zoom = (sin(iTime/2.0)*0.5+0.5)*9.0+0.1;\n    vec2 scaled = zoom*(uv*4.0-2.0);\n    float cs = cos(iTime/2.0);\n\tfloat sn = sin(iTime/2.0);\n    vec2 rotated = vec2(scaled.x * cs - scaled.y * sn, scaled.x * sn + scaled.y * cs);\n    vec3 result = newtonRapson(rotated);\n    vec3 color = hsv2rgb(vec3(result.z*1.3, 1.5, 1.0));\n    \n    // \"It is not, for now, mandatory but recommended to leave the alpha channel to 1.0.\"\n    //float alpha = result.x/float(maxIterations);\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2cWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 516, 516, 694], [696, 696, 717, 717, 755], [757, 757, 778, 778, 935], [937, 937, 961, 961, 1056], [1058, 1058, 1093, 1093, 1136], [1138, 1138, 1180, 1180, 1211], [1213, 1213, 1248, 1248, 1295], [1459, 1558, 1580, 1580, 1749], [1891, 1891, 1917, 1917, 2018], [2074, 2087, 2103, 2103, 2175], [2178, 2206, 2226, 2226, 2289], [2317, 2317, 2344, 2344, 2641], [2644, 2644, 2701, 2701, 3259]], "test": "ok"}
{"id": "Ms2yDK", "name": "Equirectangular Fibonacci Sphere", "author": "starea", "description": "Spherical Fibonacci mapping is an approximation of uniform distribution over a sphere.\nThis demo shows how to distribute circles over a sphere.\nMouse available for moving around.\nUsed for my experiments as an omnidirectional texture.", "tags": ["sphere", "mapping", "spherical", "fibonacci", "equirectangular", "projections"], "likes": 11, "viewed": 1154, "published": "Public API", "date": "1493921827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** \n * Equirectangular Fibonacci Sphere\n * Link to demo: https://www.shadertoy.com/view/Ms2yDK\n * starea @ ShaderToy\n *\n * Most of the code is forked from:\n * [1] nomadiclizard's Dragon Egg. https://www.shadertoy.com/view/MslyRr\n * Thank you nomadiclizard for sharing!\n * I added the equirectangular part and orange circles to mimic the Kusama style (https://hirshhorn.si.edu/kusama/).\n *\n * Reference: \n * [1] Keinert, Benjamin, et al. \"Spherical fibonacci mapping.\" ACM Transactions on Graphics (TOG) 34.6 (2015): 193.\n       http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping.pdf\n * [2] https://www.openprocessing.org/sketch/41142\n * [3] http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere\n *\n * My Related Shaders:\n * [1] Unified Gnomonic & Stereographic Projections. https://www.shadertoy.com/view/ldBczm\n * [2] Cubemap to Gnomonic Projection. https://www.shadertoy.com/view/4sjcz1\n * [3] [WiP] Halftone Sphere. https://www.shadertoy.com/view/4sSyD1\n *\n **/\n\n#define pi 3.14159265359\n#define twoPi 6.28318530718\n#define halfPi 1.57079632679\n#define infinity 100.0\n#define phi 1.61803398875\n#define phiMinusOne 0.61803398875\n#define twoPiOnPhi 3.88322207745\n#define root5 2.2360679775\n#define logPhiPlusOne 0.96242365011\n#define EQUIRECTANGULAR true\n#define KUSAMA_COLOR true\n//#define TIME iTime\n#define TIME 5.0\n\n// egg definition and colouring\nconst float maxn = 50.0;\nconst float growtime = 5.0;\nconst bool convex = true;\nconst float f1 = 856.0, s1 = 3.0, a1 = 0.15;\nconst float f2 = 335.0, s2 = 2.0, a2 = 0.10;\n\n// SIMPLE STUFF THAT WOULD BE COOL IF WEBGL HAD IN A STANDARD LIBRARY :V\n\nvec3 lookat(vec3 p1, vec3 p2)\n{\n    return normalize(p2 - p1);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec4 rotationQuat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float c = cos(0.5 * angle);\n    float s = sqrt(1.0 - c * c);\n    return vec4(axis.x * s, axis.y * s, axis.z * s, c);\n}\n\nvec3 rotate(vec3 p, vec4 q)\n{\n\treturn p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    return rotate(p, rotationQuat(axis, angle));\n}\n\nmat4 translationMatrix(vec3 p)\n{\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                p.x, p.y, p.z, 1.0);\n}\n\nmat4 scaleMatrix(float s)\n{\n    return mat4(s,   0.0, 0.0, 0.0,\n                0.0, s,   0.0, 0.0,\n                0.0, 0.0, s,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// k'th fibonacci number\nfloat calcfk(float k)\n{\n\treturn round(pow(phi, k) / root5);\n}\n\n// calculates a basis vector for fibonacci sphere n\nvec2 calcbk(float fk, float n)\n{\n    return vec2(twoPi * fract((fk + 1.0) * phiMinusOne) - twoPiOnPhi,\n                -2.0 * fk / n);\n}\n\n// calc point i of n in spherical coordinates\nvec2 calcpoint(float i, float n)\n{\n    return vec2(twoPi * fract(i * phiMinusOne),\n                1.0 - (2.0 * i + 1.0) / n);\n}\n\n// converts [phi,cos theta] into [x,y,z] for unit sphere\nvec3 s2c(vec2 s)\n{\n    float sinTheta = sqrt(1.0 - s.y * s.y);\n    return vec3(cos(s.x) * sinTheta,\n                sin(s.x) * sinTheta,\n                s.y);\n}\n\n// converts [x,y,z] into [phi, cos theta] for unit sphere\nvec2 c2s(vec3 c)\n{\n    return vec2(atan(c.y, c.x),\n                c.z);\n}\n\n// angle between two points in spherical coords\nfloat angdist(vec2 sp1, vec2 sp2)\n{\n    float sinTheta1 = sqrt(1.0 - sp1.y * sp1.y);\n    float sinTheta2 = sqrt(1.0 - sp2.y * sp2.y);\n    return acos(sp1.y * sp2.y + sinTheta1 * sinTheta2 * cos(sp2.x - sp1.x));\n}\n\n// calculate new point [phi, cos theta] if walking point sp on bearing ib distance d\nvec2 gcircle(vec2 sp, float ib, float d)\n{\n    float cosd = cos(d);\n    float sind = sin(d);\n    float sinTheta1 = -sp.y;\n    float cosTheta1 = sqrt(1.0 - sp.y * sp.y);\n    float sinTheta2 = sinTheta1 * cosd + cosTheta1 * sind * cos(ib);\n    float theta2 = asin(sinTheta2);\n    float phi2 = sp.x + atan(sin(ib) * sind * cosTheta1, cosd - sinTheta1 * sinTheta2);\n    return vec2(mod(phi2, twoPi), cos(theta2 + halfPi));\n}\n\n// 0..1 for seed x\nfloat random(float x)\n{\n    return fract(abs(sin(x * 12.9898) * 43758.5453));\n}\n\n// distance to nearest cell on a fibonacci sphere\nfloat fibspheren(vec3 p, float n, out float minidx, out vec3 sn)\n{\n    // get spherical coords for point p on surface of unit sphere\n    vec2 sp = c2s(p);\n    float avdist = sqrt(4.0 * pi / n);\n    \n    // calc the dominant zone number\n    float k = max(2.0, floor(log(root5 * n * pi * (1.0 - sp.y * sp.y)) / logPhiPlusOne));   \n    \n    // calc basis vectors for this zone\n    // [could all be precalculated and looked up for k,n]\n    vec2 f = vec2(calcfk(k), calcfk(k + 1.0));\n    vec2 bk = calcbk(f[0], n);\n    vec2 bk1 = calcbk(f[1], n);\n    mat2 b = mat2(bk, bk1);\n    mat2 invb = inverse(b);\n    \n    // change of basis for point sp to local grid uv\n    float z0 = 1.0 - 1.0 / n;\n    vec2 c = floor(invb * (sp - vec2(0.0, z0)));\n    \n    // for k<=4 paper suggests using (-1,0,+1)^2 offset factors but we'll\n    // stick with (0,1)^2 and live with the occasional glitches\n    float mindist = pi;\n    vec2 minisp;\n    for (int s = 0; s < 4; s++) {\n        // figure out the point index and generate fib point\n        vec2 o = vec2(s - (s/2) * 2, s / 2);\n        float idx = dot(f, c + o);\n        if (idx > n) continue;        \n        vec2 isp = calcpoint(idx, n);\n        \n        // walk on a random bearing a random distance to make cells move a bit\n        //float b = mod((-0.05 + 0.1 * random(idx + 42.39)) * iTime, twoPi);\n        //float d = dist * random(idx + 28.93) * cos((-0.5 + 1.0 * random(idx + 42.39)) * iTime);\n        //isp = gcircle(isp, b, d);\n        \n        // closest?\n        float dist = angdist(isp, sp);\n        if (dist < mindist) {\n\t\t\tmindist = dist;\n            minidx = idx;\n            minisp = isp;\n        }\n    }\n    \n    // use nearest point to calculate surface normal via rotation around cotangent from p -> ip\n    // ohhhh wow I can make keeled scales real easy if dist varies by direction!\n    vec3 ip = s2c(minisp), cotan;\n    if (convex) {\n        cotan = cross(ip - p, p);\n    } else {\n        cotan = cross(p - ip, p);\n    }\n    sn = rotate(p, cotan, mindist / avdist);\n    return mindist;\n}\n\n// view stuff\nconst float fov = radians(50.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\n// calculates intersection parameters for a ray through a sphere at sp radius r\n// return true if the halfray ro + t1.rd is hitting\nbool spherehit(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    vec3 rosp = ro - sp;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, rosp);\n    float c = dot(rosp, rosp) - (r * r);\n    float b2m4ac = b * b - 4.0 * a * c;\n    if (b2m4ac >= 0.0) {\n        float r = sqrt(b2m4ac);\n        t1 = (-b - r) / (2.0 * a);\n        t2 = (-b + r) / (2.0 * a);\n        return t1 >= 0.0 || t2 >= 0.0;\n    } else {\n        return false;\n    }\n}\n\n\nbool spherehitd(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)\n{\n    return true; \n}\n\n// black -> white via red and yellow for 0,1\nvec4 falsecolourr(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\n// black -> white via green and cyan for 0,1\nvec4 falsecolourg(float x, float stretch)\n{\n    float px = pow(clamp(x, 0.0, 1.0), stretch) * pi;\n    return vec4(sin(clamp(px - 2.0 * pi / 3.0, 0.0, halfPi)),\n                sin(clamp(px, 0.0, halfPi)),\n                sin(clamp(px - pi / 3.0, 0.0, halfPi)),\n                1.0);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord, vec3 ro, vec3 rd)\n{\n    \n    // number of points in fibsphere\n    float n = pow(2.0, log(maxn) / log(2.0) * smoothstep(0.0, 1.0, TIME / growtime)); \n    \n    // fibsphere location and size\n    vec3 sp = vec3(0.0);\n\tif (!EQUIRECTANGULAR) sp = vec3(0.0, 0.0, -2.0);\n    float sr = pow((n / maxn), 0.333) * (1.0 + 0.01 * cos(TIME));\n    \n    // mouse rotates it\n    float r1 = (iMouse.x / iResolution.x - 0.5) * twoPi;\n    float r2 = (iMouse.y / iResolution.y - 0.5) * twoPi;\n    r1 += TIME * 0.25;\n    \n    // transform and inverse matrices\n    mat4 ms = scaleMatrix(1.0 / sr) *\n              translationMatrix(-sp);\n    mat4 mr = rotationMatrix(forward, -r1) *\n              rotationMatrix(right, -r2);\n    mat4 mmr = rotationMatrix(right, r2) *\n        \t   rotationMatrix(forward, r1);\n    \n    \n    // check if an intersection is possible (in world space)\n    float t1, t2;\n    if (spherehit(sp, sr, ro, rd, t1, t2)) {\n        \n        \n        vec4 wp = vec4(ro + t1 * rd, 1.0);\n    \t// calculate hit of fibsphere (back in model space)\n        vec3 mp = vec3(mr * ms * wp), msn;\n        float idx, ir = fibspheren(mp, n, idx, msn);\n        \n        // surface normal back in world coords\n        vec3 sn = vec3(mmr * vec4(msn, 1.0));\n        \n        // colour it all pretty - similar to adding octaves of noise\n        // overlaying lots of waves gives it a cool mesmerising effect\n        float vrange = 0.5 + a1 * cos(f1 * (idx / maxn) + s1 * TIME) +\n            \t\t\ta2 * cos(f2 * (idx / maxn) + s2 * TIME);\n        \n        vec3 c = vec3(0.0, 1.0, 0.0); \n       // if (idx < 0.5) c = vec3(1.0, 0.0, 0.0); \n        if (KUSAMA_COLOR) c = vec3(0.86, 0.78, 0.1);\n        c*=smoothstep(.02, .0 , ir-0.1 + sin(iTime+idx)*.05);\n        //if (ir > 0.1 + sin(iTime + idx) * 0.05) c = vec3(0.0); \n        fragColor = vec4(c, 1.0); \n        \n        \n    \t// define the spherical coordinates, [-1, 1]\n    \t//vec2 s = vec2(acos(sn.z), atan(sn.y, sn.x)) / pi; \n    \t//fragColor = texture(iChannel0, s);\n        \n    } else {\n        fragColor = vec4(1.0); \n        //fragColor = 0.3 + 0.3 * vec4(fragCoord.y / iResolution.y);\n    }\n    \n     \n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd)\n{\n    // the VR version does it for us\n    render(fragColor, fragCoord, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // figure out where to look\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, vec3(uv.x * tan(fov), uv.y * tan(fov), -1.0));\n    \n    if (EQUIRECTANGULAR) {\n   \t\tvec2 sph = fragCoord.xy / iResolution.xy * vec2(twoPi, pi);\n    \trd = vec3(sin(sph.y) * sin(sph.x), cos(sph.y), sin(sph.y) * cos(sph.x)); \n    }\n    render(fragColor, fragCoord, ro, rd);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2yDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1648, 1648, 1679, 1679, 1712], [1714, 1714, 1759, 1759, 2382], [2384, 2384, 2427, 2427, 2578], [2580, 2580, 2609, 2609, 2670], [2672, 2672, 2717, 2717, 2768], [2770, 2770, 2802, 2802, 2949], [2951, 2951, 2978, 2978, 3125], [3127, 3152, 3175, 3175, 3213], [3215, 3267, 3299, 3299, 3403], [3405, 3451, 3485, 3485, 3579], [3581, 3638, 3656, 3656, 3798], [3800, 3858, 3876, 3876, 3932], [3934, 3982, 4017, 4017, 4194], [4196, 4281, 4323, 4323, 4701], [4703, 4722, 4745, 4745, 4801], [4803, 4853, 4919, 4985, 6895], [7065, 7197, 7277, 7277, 7654], [7657, 7657, 7738, 7738, 7758], [7760, 7805, 7848, 7848, 8089], [8091, 8136, 8179, 8179, 8420], [8422, 8422, 8492, 8534, 10609], [10611, 10611, 10687, 10724, 10768], [10770, 10770, 10825, 10861, 11263]], "test": "error"}
{"id": "Ms2yDt", "name": "Yet another mandelbulb raymarche", "author": "ichko", "description": "Mandelbulb Raymarcher", "tags": ["raymarching", "fractal", "raytracer", "mandelbulb", "raymarcher", "distanceestimator"], "likes": 2, "viewed": 252, "published": "Public", "date": "1494446546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX = 8;\nconst float PI = 3.1415927;\nconst vec3 BGCOLOR = vec3(0.0);\nconst float INF =  9999999.0;\nvec3 LIGHT_DIR = vec3(0.0, 1.0, 0.5);\n\n\nstruct Sphere {\n    vec3 p;\n    float r;\n};\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n};\n\n\nSphere sphereContainer[MAX];\nint sphereCnt = 0;\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// Src - http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\nfloat MandelBulbDE(vec3 pos) {\n    pos = mod(pos, 4.0) - 2.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    int Iterations = 4;\n    float Bailout = 3.0;\n    float Power = 8.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos*(cos(iTime) / 1.5 + 1.2);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat traceDE(Ray ray) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n    int MaxRaySteps = 50;\n    float MinimumDistance = 0.0005;\n\tfor (steps=0; steps < MaxRaySteps;++steps) {\n\t\tvec3 p = ray.o + totalDistance * ray.d;\n\t\tfloat distance = MandelBulbDE(p);\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t}\n\treturn 1.0 - float(steps) / float(MaxRaySteps);\n}\n\n\nfloat iSphere(Ray ray, Sphere sphere, out vec3 color) {\n    //ray.o = mod(ray.o, 5.0);\n    //ray.d = mod(-ray.d, 5.0);\n    \n    \n    float dx = ray.o.x - sphere.p.x;\n    float dy = ray.o.y - sphere.p.y;\n    float dz = ray.o.z - sphere.p.z;\n    \n    float a = ray.d.x * ray.d.x + ray.d.y * ray.d.y + ray.d.z * ray.d.z;\n    float b = 2.0 * (ray.d.x * dx + ray.d.y * dy + ray.d.z * dz);\n    float c = dx * dx + dy * dy + dz * dz - sphere.r * sphere.r;\n    float d = b * b - 4.0 * a * c;\n\n    if (d > 0.0) {\n        float t0 = (-b + sqrt(d)) / 2.0;\n        float t1 = (-b - sqrt(d)) / 2.0;\n        float t = max(t0, t1);\n        vec3 ip = ray.o + ray.d * t;\n        vec3 normal = normalize(ip - sphere.p);\n\n        vec3 sphereColor = vec3(1.0, 1.0, 0.0);\n        color = clamp(vec3(sphereColor) * dot(normal, LIGHT_DIR), vec3(0.0), vec3(1.0));\n        color += sphereColor * vec3(0.1);\n        return t;\n    }\n\n    return INF;\n}\n\n\nvoid setupScene() {\n    Sphere sphere0;\n    sphere0.p = vec3(0.0, 0.0, 0.0);\n    sphere0.r = 1.0;\n    \n\tsphereContainer[0] = sphere0;\n    sphereCnt = 1;\n    LIGHT_DIR.x = sin(iTime);\n    LIGHT_DIR.y = cos(iTime);\n}\n\nRay getRay(vec2 uv) {\n\tRay ray;\n    float t = iTime / 5.0;\n    mat3 rot = rotationMatrix(vec3(1.0, 1.0, 1.0), t / 10.0);\n    \n    vec3 ro = vec3(sin(t), cos(t / 32.0) * 15.0, sin(t) / 45.0) * 10.0;\n\n\tray.o = ro;\n\tray.d = normalize(vec3(1.0, uv));\n    \n    float angle = t / 5.0;\n    float s = sin(angle), c = cos(angle);\n    mat2 rot2 = mat2(c, -s, s, c);\n    ray.d.xy *= rot2;\n    ray.d.yz *= rot2;\n    \n\treturn ray;\n}\n\nvec3 trace(Ray ray) {\n    vec3 closestColor = BGCOLOR;\n    float closestDist = INF;\n    \n    for(int i = 0;i < sphereCnt;++i) {\n        vec3 currentColor;\n        float currentDist = iSphere(ray, sphereContainer[i], currentColor);\n        if (closestDist > currentDist) {\n            closestDist = currentDist;\n            closestColor = currentColor;\n        }\n    }\n    return closestColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(ar * 0.5, 0.5);\n\n    \n    setupScene();\n    vec3 colorSum = vec3(0.0);\n    float kernelSize = 2.0;\n    for(float x = 0.0;x < kernelSize;++x) {\n        for(float y = 0.0;y < kernelSize;++y) {\n            vec2 ruv = uv + vec2(x / kernelSize, y / kernelSize) / iResolution.xy;\n    \t\tRay ray = getRay(ruv);\n    \t\tcolorSum += trace(ray);\n        }\n    }\n    colorSum /= kernelSize * kernelSize;\n\t\n    \n    Ray ray = getRay(uv);\n    vec3 mandelbulbColor = vec3(1.0, 0.0, 0.5) * traceDE(ray) * 1.1 + 0.1;\n    \n\tfragColor = vec4(mandelbulbColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2yDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 325, 325, 797], [799, 893, 923, 923, 1578], [1581, 1581, 1605, 1605, 1955], [1958, 1958, 2013, 2076, 2882], [2885, 2885, 2904, 2904, 3099], [3101, 3101, 3122, 3122, 3520], [3522, 3522, 3543, 3543, 3916], [3919, 3919, 3974, 3974, 4613]], "test": "ok"}
{"id": "MsBcDc", "name": "Daily 2017-05-06", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 9, "viewed": 413, "published": "Public API", "date": "1494101670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat random(vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat map(vec3 p){\n    p.xy*=rz2(iTime*.3);\n    p.yz*=rz2(iTime*.5);\n    p.xy*=rz2(iTime*.7);\n    vec3 q=mod(p+2.5,5.)-2.5;\n    vec3 f=floor((p-2.5)/5.);\n    float fft=texture(iChannel0,vec2(0.05,0.25)).x;\n    float r=random(vec2(random(f.xy),f.z));\n    vec3 s=vec3(.2+r*.5+fft*.5);\n    r*=6.2831853;\n    vec3 c;\n    c.x=sin(r+iTime*1.3);\n    c.y=sin(r+iTime*1.4);\n    c.z=sin(r+iTime*1.5);\n    c*=.8;\n    return min(length(max(abs(q-c)-s,0.))-.1,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v=uv*(1.-uv);\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(uv,-2.5),rd=vec3(uv,1.),mp=ro;\n    int i;\n    for(i=0;i<50;++i){\n        float md=map(mp);\n        if(md<.001)break;\n        mp+=rd*md;\n    }\n    float m=1.-float(i)/50.;\n    vec3 c=vec3(.9,.1,.5)*m;\n    c *= pow(v.x*v.y * 25., .25);\n\tfragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [67, 67, 90, 90, 165], [167, 167, 185, 185, 620], [622, 622, 679, 679, 1074]], "test": "error"}
{"id": "MsByDK", "name": "Gravity Field Experiments #1", "author": "Casheera", "description": "Gravity field", "tags": ["2d", "gravityfield"], "likes": 1, "viewed": 271, "published": "Public", "date": "1493845011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Planet\n{\n\tint base; // index of parent planet of -1 for root\n\tfloat R;  // Radius\n    float M;  // Mass\n    float H;  // Orbit height over base planet\n    float PH; // Phase\n    float P;  // Period\n    float C;  // Color (hue)\n};\n#define N 7\nPlanet PSys[] = Planet[](\n\tPlanet(-1, .11, 0.434782608695652, .0, .06, .0, .12),\n    Planet(0, .03, 0.217391304347826, .15, .02, .9, .3),\n    Planet(0, .01, 0.130434782608696, .04, .0167, .6, .8),\n    Planet(1, .006, 0.086956521739131, .03, .0267, 2.2, .7),\n    Planet(2, .003, 0.086956521739131, .01, .02, -3.5, .5),\n    Planet(0, .007, 0.043478260869565, .07, .05, 2.0, .6),\n    Planet(3, .003, 0.03, .008, .05, 0.74, .9)\n);\n\nmat2 rot2(float a) {\n\tfloat s = sin(a*6.28);\n\tfloat c = cos(a*6.28);\n\treturn  mat2(c, -s, s, c);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat GF(vec2 p, vec2 c, float r, float m)\n{\n    float d = distance(p,c)-r;\n    float g = .0;\n    if (d>0.0)\n    {\n        g = m/d;\n    }\n    return g;\n}\n\nvec2 rotPos(int j)\n{\n    float cr = 0.0;\n    if (PSys[j].base>-1)\n    {\n        cr = PSys[PSys[j].base].R+PSys[j].H;\n    }\n    float t = (.1*iTime*PSys[j].P + PSys[j].PH)*6.28;\n    return vec2(cr*cos(t), cr*sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/mx;\n    float gacc = 1.;\n    vec3 plc = vec3(.0, .0, .0);\n    for (int i = 0; i < N; i++)\n    {\n        vec2 c = vec2(.0, .0);\n        int parentID = i;\n            while (parentID > -1)\n            {        \n                c += rotPos(parentID);\n                parentID = PSys[parentID].base;\n            }\n        float gf = GF(uv, c, PSys[i].R, PSys[i].M);\n        plc = mix(hsv2rgb(vec3(PSys[i].C, 1., 1.)),\n                  plc,\n                  smoothstep(-.001, .0, distance(uv, c)-PSys[i].R));\n        gacc *= gf;\n    }\n    float gnorm = 5.*log2(gacc);\n\tvec3 c = mix(plc ,vec3(1.0),  smoothstep (.8, 1.2, cos(gnorm)));\n    if (iMouse.z>.0)\n    {\n        vec3 fv = reflect(normalize(vec3(uv, -1.)), normalize(vec3(uv, sqrt(gacc))));\n        c = plc+smoothstep(.0, 1.0, fv);\n    }\n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsByDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 677, 697, 697, 775], [777, 777, 799, 799, 968], [970, 970, 1014, 1014, 1123], [1125, 1125, 1145, 1145, 1342], [1344, 1344, 1401, 1401, 2318]], "test": "error"}
{"id": "MsfBRn", "name": "Rotating Balls", "author": "DonKarlssonSan", "description": "Rotating Ball", "tags": ["ball"], "likes": 0, "viewed": 69, "published": "Public", "date": "1494533236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CS(a) vec2(cos(a), sin(a))\n#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n\n    vec2 p1 = vec2(p); \n    p1 += CS(iTime) * 0.2;\n\tfloat r1 = length(p1) * 8.0; \n    \n    vec2 p2 = vec2(p);\n    p2 += CS(iTime + PI) * 0.2;\n    float r2 = length(p2) * 8.0;\n        \n    float green = 1.0 - r1;\n    float red = 1.0 - r2;\n\tfragColor = vec4(red, green, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 465]], "test": "ok"}
{"id": "MsfBz4", "name": "2D Copper Bars", "author": "MarcoLizza", "description": "2D old-school copper-bars.", "tags": ["2d", "oldschool", "copperbars"], "likes": 3, "viewed": 169, "published": "Public", "date": "1495023499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Basic colors.\nconst vec4 BRIGHT_RED = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 BRIGHT_YELLOW = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 BRIGHT_GREEN = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 BRIGHT_CYAN = vec4(0.0, 1.0, 1.0, 1.0);\nconst vec4 BRIGHT_BLUE = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 BRIGHT_PURPLE = vec4(1.0, 0.0, 1.0, 1.0);\nconst vec4 RED = vec4(0.8, 0.0, 0.0, 1.0);\nconst vec4 YELLOW = vec4(0.8, 0.8, 0.0, 1.0);\nconst vec4 GREEN = vec4(0.0, 0.8, 0.0, 1.0);\nconst vec4 CYAN = vec4(0.0, 0.8, 0.8, 1.0);\nconst vec4 BLUE = vec4(0.0, 0.0, 0.8, 1.0);\nconst vec4 PURPLE = vec4(0.8, 0.0, 0.8, 1.0);\nconst vec4 DARK_RED = vec4(0.4, 0.0, 0.0, 1.0);\nconst vec4 DARK_YELLOW = vec4(0.4, 0.4, 0.0, 1.0);\nconst vec4 DARK_GREEN = vec4(0.0, 0.4, 0.0, 1.0);\nconst vec4 DARK_CYAN = vec4(0.0, 0.4, 0.4, 1.0);\nconst vec4 DARK_BLUE = vec4(0.0, 0.0, 0.4, 1.0);\nconst vec4 DARK_PURPLE = vec4(0.4, 0.0, 0.4, 1.0);\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 BRIGHT_GRAY = vec4(0.8, 0.8, 0.8, 1.0);\nconst vec4 DARK_GRAY = vec4(0.4, 0.4, 0.4, 1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\n\n// Shader parameters, you would probably define them as \"uniform\".\nconst float FREQUENCY_MULTIPLIER = 5.0;\nconst float AMPLITUDE_MULTIPLIER = 0.25;\nconst float BASE_POSITION = 0.5;\nconst float HEIGHT = 0.0500;\n\n// Computes the copperbar colors for the [uv] pixel.\nvec4 copperbar(in vec2 uv,\n               in float base, in float offset, in float frequency, in float amplitude,\n               in vec4 innerColor, in vec4 outerColor) {\n    float alpha = (iTime + offset) * frequency; // Offset and scale current time.\n    float position = base + (sin(alpha) * amplitude); // Get the copperbar middle position.\n    float ratio = abs(uv.y - position) / HEIGHT; // Normalized (to height) distance.\n    if (ratio > 1.0) { // Pixel is beyond copperbar limit, set to black.\n        return BLACK;\n    }\n    return mix(innerColor, outerColor, ratio); // Mix to generate a gradient.\n}\n\n// Picks the first non-black color in the array.\nvec4 choose(in vec4[5] colors) {\n    for (int i = 0; i < colors.length(); ++i) {\n        vec4 color = colors[i];\n        if (color != BLACK) {\n            return color;\n        }\n    }\n    return BLACK;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = choose(vec4[](\n        copperbar(uv, BASE_POSITION + 0.0, 0.00, FREQUENCY_MULTIPLIER * 1.0, AMPLITUDE_MULTIPLIER * 1.0, BRIGHT_CYAN,    DARK_BLUE),\n        copperbar(uv, BASE_POSITION + 0.0, 0.10, FREQUENCY_MULTIPLIER * 1.0, AMPLITUDE_MULTIPLIER * 1.0, BRIGHT_YELLOW, DARK_RED),\n        copperbar(uv, BASE_POSITION + 0.0, 0.20, FREQUENCY_MULTIPLIER * 1.0, AMPLITUDE_MULTIPLIER * 1.0, BRIGHT_YELLOW, DARK_GREEN),\n        copperbar(uv, BASE_POSITION + 0.0, 0.30, FREQUENCY_MULTIPLIER * 1.0, AMPLITUDE_MULTIPLIER * 1.0, PURPLE, DARK_YELLOW),\n        copperbar(uv, BASE_POSITION + 0.0, 0.40, FREQUENCY_MULTIPLIER * 1.0, AMPLITUDE_MULTIPLIER * 1.0, BRIGHT_GRAY, BLUE)\n    ));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1295, 1348, 1518, 1518, 1958]], "test": "ok"}
{"id": "MsfBzH", "name": "5/100", "author": "yahe", "description": "5/100", "tags": ["wave", "sine"], "likes": 9, "viewed": 469, "published": "Public API", "date": "1494827830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 wave_color = vec3(0.0);\n\n\tuv = rotate2D(uv,PI*0.1*iTime);\n\n\t// To create the waves\n\tfloat wave_width = 0.01;\n\tuv = 2.0*uv;\n\t\n    for(float i = 0.0; i < 20.0; i++) {\n\t\tuv.y += (0.04 * sin(uv.x + i/20.0 + iTime ));\n\t\twave_width = abs(1.0 / (250.0 * uv.y));\n\t\twave_color += vec3(wave_width * uv.x, wave_width * 0.4 , wave_width * 0.8);\n\t}\n\t\n\tfragColor = vec4(wave_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 73, 73, 213], [215, 215, 272, 272, 696]], "test": "ok"}
{"id": "MsffRN", "name": "Kaleidoscopic Hyperbolic ", "author": "decrooks", "description": "kaleidoscopic pattern from hyperbolic disk", "tags": ["kaleidoscope", "pattern", "hyperbolic"], "likes": 4, "viewed": 228, "published": "Public", "date": "1495095309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\nstruct Circle {\n    float radius;\n    vec2 center;\n};\n\nconst int numCircles = 3;\nCircle circles[3];\n\n\n/*\n\tOrthoganl Circles represent strait line in hyperbolic space.\n\t\n\tsee http://mathworld.wolfram.com/PoincareHyperbolicDisk.html.\n\n*/\nCircle orthogonalCircle(float theta1,float theta2) {\n    \n    float theta = 0.5*(theta1 + theta2);\n    float dTheta = 0.5*(theta1 - theta2);\n    \n    float r = abs(tan(dTheta));\n   //  float r = 0.5;\n    float R = 1.0/cos(dTheta);\n    \n    vec2 center = vec2(R*cos(theta),R*sin(theta));\n    \n    return Circle(r,center);\n}\n\n\n\n\nvoid createCircles() {\n\n    float t = 0.5 - 0.5*cos(iTime);\n\n  \tfloat theta = TWO_PI/3.0;\n   \n    \n    float dTheta = 2.43 + 0.152*t;\n    \n\t//for(int i;i<numCircles  )\n    circles[0] = orthogonalCircle(0.0,dTheta);\n    circles[1] = orthogonalCircle(theta,theta + dTheta);\n    circles[2] = orthogonalCircle(2.0*theta,2.0*theta +  dTheta);\n}\n\nfloat arcosh(float x) {\n    return log(x + sqrt(x*x - 1.0));\n}\n\nfloat hyperbolicDist(vec2 p, vec2 q){\n    return arcosh(1. + 2.*dot(p-q,p-q) / ((1. - dot(p,p))*(1. - dot(q,q))) );\n}\n\nbool circleContains(vec2 p, Circle c) { \n   return distance(c.center,p) < c.radius;  \n}\n\n\n/*\n\tCircle inversion exchanges the inside with the outside of a circle.\n\tReflections in hyperbolic space.\n*/\nvec2 circleInverse(vec2 p, Circle c){\n    p -= c.center;\n\treturn p  * c.radius * c.radius / dot(p,p) + c.center;\n    \n}\n\nbool isEven(int i){\n    \n    return mod(float(i),2.0) == 0.0;\n  //  return i%2 == 0;\n    \n}\n\n/*\n\tIterated Inversion System \n    see this paper http://archive.bridgesmathart.org/2016/bridges2016-367.pdf\n    and this shader https://www.shadertoy.com/view/XsVXzW by soma_arc.\n\n\tThis algorythim for draws tileings on the poncaire disk model of hyperbolic space.\n\t\n\tOur array of circles represent the reflections that generate the tiling.\n\tWe repeatedly invert the point in each of the circles and keep track of the total number of inversions.\n\n*/\n\nvec3 iteratedInversion(vec2 p) {\n    \n\n    int count = 0;\n    bool flag = true;\n    \n    for(int i=0; i<100; i++) {\n        \n        flag = true;\n        \n        \n        for(int j = 0; j<numCircles; j++) {\n            Circle c = circles[j];\n\n            if(circleContains(p, c)) {\n                \n                p = circleInverse(p,c);\n                flag = false;\n                count++;  \n                \n        \t} \n            \n        }\n        \n        if(flag) {\n           break;\n        }\n        \n    }\n    \n    \n     return vec3(p,isEven(count));  \n   \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tcreateCircles();\n    \n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \n    vec3 p = iteratedInversion(uv);\n    // float r = length(p);  //distance(p\n    float r = hyperbolicDist(p.xy,vec2(0.0));\n    float theta = atan(p.x,p.y);\n    float h = 0.66*sin(30.0*r + iTime) + 0.335*sin(3.0*theta) ;\n    float g =  0.33*sin(5.0*r + iTime) + 0.666*sin(3.0*theta) ;\n    float c =  0.5+0.5*h;\n    fragColor = vec4(0.5*h,0.5*h*p.z,g,1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsffRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[267, 401, 453, 453, 723], [728, 728, 750, 750, 1067], [1069, 1069, 1092, 1092, 1131], [1133, 1133, 1170, 1170, 1250], [1252, 1252, 1291, 1291, 1339], [1342, 1451, 1488, 1488, 1570], [1572, 1572, 1591, 1591, 1663], [2116, 2116, 2148, 2148, 2698], [2701, 2701, 2757, 2757, 3218]], "test": "ok"}
{"id": "MsffWn", "name": "Cockpit View", "author": "dr2", "description": "What a pilot sees in \"Red Canyon 2\"", "tags": ["landscape", "flight"], "likes": 7, "viewed": 619, "published": "Public API", "date": "1495618216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Cockpit View\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3a (vec3 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nvec2 Rot2D (vec2 q, float a);\n\n#define N_FLYER 3\n\nint idObj, idFlmGrp, idLsrGrp;\nmat3 flyerMat[N_FLYER], flMat;\nvec3 flyerPos[N_FLYER], flPos, qHit, qHitFlm, qHitLsr, sunDir, flmCylPos, lsrCylPos,\n   trkF, trkA;\nfloat dstFar, tCur, fusLen, flmCylRad, flmCylLen, lsrCylRad, lsrCylLen, vFly;\nconst int idFus = 11, idEngO = 12, idEngI = 13, idWng = 14, idCan = 15;\nconst float pi = 3.14159;\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.2, 0.9), vec3 (0.4, 0.4, 0.55),\n     1. - max (rd.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, clCol, col;\n  float fCloud, cloudLo, cloudRngI, atFac, colSum, attSum, s,\n     att, a, dDotS, ds;\n  const int nLay = 60;\n  cloudLo = 200.;  cloudRngI = 1./200.;  atFac = 0.035;\n  fCloud = 0.45;\n  if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro.x += 3. * tCur;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      att += atFac * max (fCloud - Fbm3 (0.007 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * 2.8 * (colSum + 0.05);\n    cSun = vec3 (1.) * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    col = clamp (mix (SkyBg (rd) + cSun, clCol, attSum), 0., 1.);\n    col = mix (col, SkyBg (rd), pow (1. - rd.y, 16.));\n  } else col = SkyBg (rd);\n  return col;\n}\n\nfloat GrndDf (vec3 p)\n{\n  float d, s;\n  s = p.y - 3.;\n  d = SmoothMin (12. + 4. * sin (0.019 * p.z) -\n     abs (p.x - dot (trkA, sin (trkF * p.z))) +\n     s * (0.3 - 0.05 * s), 3. + p.y, 2.);\n  d = SmoothMax (d, - (8. + 1.1 * sin (0.022 * p.z) - p.y), 1.);\n  d += 2.3 * Noisefv2 (0.2 * p.xz) + 1.1 * Noisefv2 (0.6 * p.xz) +\n     0.3 * Noisefv2 (1.1 * p.xz);\n  return d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += 0.5 * h + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 4; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., GrndDf (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec3 e;\n  float s;\n  e = vec3 (0.01, 0., 0.);\n  s = GrndDf (p);\n  return normalize (vec3 (GrndDf (p + e.xyy) - s, e.x,\n     GrndDf (p + e.yyx) - s));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  vec4 col, wCol, bCol;\n  wCol = mix (vec4 (0.5, 0.4, 0.4, 1.), vec4 (0.22, 0.2, 0.2, 1.),\n     clamp (1.4 * (Noisefv2 (5. * p.xy +\n     vec2 (0., 3.7 * sin (0.17 * p.z))) +\n     Noisefv2 (p.zy * vec2 (5., 10.3))) - 1., 0., 1.));\n  bCol = mix (vec4 (0.2, 0.4, 0.2, 0.), vec4 (0.2, 0.2, 0., 0.),\n     clamp (Noisefv2 (2. * p.xz) - 0.3, 0., 1.));\n  col = mix (wCol, bCol, smoothstep (0.6, 0.9, n.y));\n  col.w *= clamp (1. - 2. * n.y, 0., 1.);\n  return col;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 16; j ++) {\n    h = GrndDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 1.;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat FlmDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, s;\n  dMin = dstFar;\n  s = (0.55 / sqrt (2.)) * fusLen;\n  for (int k = 0; k < N_FLYER; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) - flmCylPos;\n    r = flmCylRad * (0.6 + 0.4 * q.z / flmCylLen);\n    qq = q + vec3 (s, s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n    qq = q + vec3 (s, - s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n    qq = q + vec3 (- s, - s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n    qq = q + vec3 (- s, s, 0.);\n    d = PrCylDf (qq, r, flmCylLen);\n    if (d < dMin) { dMin = d;  qHitFlm = qq;  idFlmGrp = k; }\n  }\n  return dMin;\n}\n\nfloat FlmRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = FlmDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat LsrDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_FLYER; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]);\n    q -= lsrCylPos;\n    d = PrCylDf (q, lsrCylRad, lsrCylLen);\n    if (d < dMin) { dMin = d;  qHitLsr = q;  idLsrGrp = k; }\n    q.x += 2. * lsrCylPos.x;\n    d = PrCylDf (q, lsrCylRad, lsrCylLen);\n    if (d < dMin) { dMin = d;  qHitLsr = q;  idLsrGrp = k; }\n  }\n  return dMin;\n}\n\nfloat LsrRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = LsrDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  if (d >= 0.001) dHit = dstFar;\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wr, ws;\n  dMin = dstFar / 0.8;\n  p.z -= 0.4 * fusLen;\n  q = p;\n  q.xy = Rot2D (q.xy, pi / 4.);\n  wr = 0.6 + q.z / fusLen;\n  wr = (0.14 - 0.1 * wr * wr) * fusLen;\n  q.z -= 0.3 * fusLen;\n  d = min (PrCapsDf (q * vec3 (0.7, 1., 0.7), wr, fusLen),\n     PrCapsDf (q * vec3 (1., 0.7, 0.7), wr, fusLen));\n  q.z += 0.3 * fusLen;\n  d = SmoothMin (d, PrCapsDf (q, 0.1 * fusLen, 0.5 * fusLen), 0.01 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idFus;  qHit = q; }\n  q = p;\n  q.xy = Rot2D (q.xy, 2. * pi *\n     (floor (4. * atan (q.y, - q.x) / (2. * pi)) + 0.5) / 4.);\n  q.xz -= vec2 (-0.55, -0.8) * fusLen;\n  ws = q.z / (0.4 * fusLen);\n  wr = ws - 0.1;\n  d = max (PrCylDf (q, (0.09 - 0.05 * wr * wr) * fusLen, 0.35 * fusLen),\n     - PrCylDf (q, 0.05 * fusLen, 0.36 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idEngO;  qHit = q; }\n  d = min (PrCylDf (q, (0.04 - 0.038 * ws * ws) * fusLen, 0.38 * fusLen),\n     PrCylDf (q - vec3 (0., 0., 0.03 * fusLen), 0.05 * fusLen, 0.28 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idEngI;  qHit = q; }\n  q.xz -= vec2 (0.3, -0.05) * fusLen;\n  q.xz = Rot2D (q.xz, 0.05 * pi);\n  d = PrFlatCylDf (q.zyx, 0.2, 0.01, 0.27) * fusLen;\n  if (d < dMin) { dMin = d;  idObj = idWng;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= fusLen * vec2 (0.1, 0.2);\n  d = PrFlatCylDf (q.zyx, 0.03 * fusLen, 0.01 * fusLen, 0.1 * fusLen);\n  q.x -= 0.1 * fusLen;\n  d = min (d, PrCapsDf (q, 0.02 * fusLen, 0.1 * fusLen));\n  if (d < dMin) { dMin = d;  idObj = idCan;  qHit = q; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < N_FLYER; k ++) {\n    dMin = min (dMin, FlyerDf (flyerMat[k] * (p - flyerPos[k])));\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 rom[N_FLYER], rdm[N_FLYER], qHitF;\n  float dHit, d, df;\n  int idObjF;\n  for (int k = 0; k < N_FLYER; k ++) {\n    rom[k] = flyerMat[k] * (ro - flyerPos[k]);\n    rdm[k] = flyerMat[k] * rd;\n  }\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    df = dstFar;\n    for (int k = 0; k < N_FLYER; k ++) {\n      d = FlyerDf (rom[k] + dHit * rdm[k]);\n      if (d < df) {\n        df = d;\n        qHitF = qHit;\n        idObjF = idObj;\n      }\n    }\n    dHit += df;\n    if (df < 0.001 || dHit > dstFar) break;\n  }\n  if (df >= 0.001) dHit = dstFar;\n  else {\n    qHit = qHitF;\n    idObj = idObjF;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 16; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.1;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec4 FlyerCol ()\n{\n  vec3 qq, col;\n  float spec, br;\n  spec = 1.;\n  qq = qHit / fusLen;\n  br = 0.4 + 0.6 * abs (cos (3. * tCur));\n  col = vec3 (0.9);\n  if (idObj == idFus) {\n    qq.xy = Rot2D (qq.xy, - pi / 4.);\n    if (qq.y > 0.) col *= 0.7;\n  } else if (idObj == idWng) {\n    if (abs (qq.x + 0.05) < 0.115)\n       col *= 1. - SmoothBump (-0.005, 0.005, 0.001, qq.z + 0.17);\n    if (qq.z < -0.17)\n       col *= 1. - SmoothBump (- 0.005, 0.005, 0.001,\n       abs (abs (qq.x + 0.05) - 0.26) - 0.15);\n\n  } else if (idObj == idEngO) {\n    if (qq.z > 0.34) {\n      col = vec3 (0.8, 0.8, 1.);\n    } else if (qq.z < -0.2 && length (qq.xy) < 0.05) {\n      col = vec3 (1., 0.3, 0.);\n      spec = 0.1;\n    }\n  } else if (idObj == idEngI) {\n    if (qq.z > 0.36) col = vec3 (1., 0., 0.);\n    else if (qq.z < 0.) {\n      col = vec3 (1., 0.3, 0.);\n      spec = 0.1;\n    } else {\n      col = vec3 (0.01);\n    }\n  } else if (idObj == idCan) {\n    col *= 0.5;\n  }\n  if (idObj == idFus) {\n    if (qq.z > 0.5) {\n      if (length (qq.xy) < 0.01) {\n        col = vec3 (0., 1., 0.) * br;\n        spec = -1.;\n      } else if (min (abs (qq.x), abs (qq.y)) > 0.01 && abs (qq.z - 0.52) > 0.007) {\n        col = vec3 (0.4, 0.2, 0.1);\n        spec = 0.2;\n      }\n    } else if (qq.z < -1.2 && length (qq.xy) < 0.03) {\n      col = vec3 (1., 0., 0.) * br;\n      spec = -1.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nfloat FlmAmp (vec3 p, vec3 rd)\n{\n  vec3 dp, q;\n  float g, s, fr, fz;\n  dp = (2. * flmCylRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    s = length (p.xy);\n    if (s > flmCylRad || g > 10.) break;\n    fr = max (1. - s / flmCylRad, 0.);\n    fz = 0.6 + 0.4 * p.z / flmCylLen;\n    q = 5. * p / fusLen;\n    g += fr * fz * Noisefv3a (vec3 (q.xy, q.z +\n       50. * (1. - 0.5 * fr) * (100. + tCur)));\n  }\n  return min (0.15 * g, 1.);\n}\n\nfloat LsrAmp (vec3 p, vec3 rd)\n{\n  float g;\n  g = smoothstep (0., 0.2, abs (dot (normalize (p.xy), - rd.xy))) *\n     smoothstep (0.3, 0.4, mod (23. * p.z / fusLen - 10. * tCur, 1.)) *\n     step (0.2, mod (0.7 * tCur, 1.));\n  return g;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn, rdm;\n  float dstHit, dstGrnd, dstFlm, aFlm, dstLsr, aLsr, sh;\n  bool isGrnd;\n  flmCylRad = 0.051 * fusLen;\n  flmCylLen = 0.5 * fusLen;\n  flmCylPos = vec3 (0., 0., -(0.55 * fusLen + flmCylLen));\n  lsrCylRad = 0.005 * fusLen;\n  lsrCylLen = 5. * fusLen;\n  lsrCylPos = vec3 (0.2 * fusLen, 0., 1.12 * lsrCylLen);\n  dstFlm = FlmRay (ro, rd);\n  dstLsr = LsrRay (ro, rd);\n  dstHit = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  if (dstHit < dstFlm) dstFlm = dstFar;\n  if (dstHit < dstLsr) dstLsr = dstFar;\n  isGrnd = false;\n  if (dstHit < dstGrnd) {\n    ro += rd * dstHit;\n    objCol = FlyerCol ();\n    vn = ObjNf (ro);\n    if (objCol.a >= 0.) {\n      sh = 0.1 + 0.9 * ObjSShadow (ro, sunDir);\n      col = objCol.rgb * 0.7 * (0.2 + sh * 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.3 * SkyCol (ro, reflect (rd, vn)) +\n         vec3 (1.) * sh * objCol.a *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 256.);\n    } else col = objCol.rgb;\n  } else {\n    dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro += dstGrnd * rd;\n      isGrnd = true;\n    } else col = SkyCol (ro, rd);\n  }\n  if (isGrnd) {\n    vn = VaryNf (5. * ro, GrndNf (ro), 5.);\n    objCol = GrndCol (ro, vn);\n    sh = 0.2 + 0.8 * GrndSShadow (ro, sunDir);\n    col = objCol.rgb * (0.1 + 0.2 * max (vn.y, 0.) +\n       sh * 0.9 * max (dot (vn, sunDir), 0.)) +\n       vec3 (1.) * sh * objCol.a *\n       pow (max (dot (normalize (sunDir - rd), vn), 0.), 256.);\n  }\n  if (dstFlm < min (dstFar, dstHit)) {\n    rdm = (idFlmGrp == 0) ? flyerMat[0] * rd :\n       ((idFlmGrp == 1) ? flyerMat[1] * rd : flyerMat[2] * rd);\n    aFlm = FlmAmp (qHitFlm, rdm);\n    col = mix (col, mix (vec3 (1., 0.2, 0.2),\n       vec3 (1., 1., 0.7), 0.8 * aFlm), aFlm);\n  }\n  if (dstLsr < min (dstFar, dstHit)) {\n    rdm = (idLsrGrp == 0) ? flyerMat[0] * rd :\n       ((idLsrGrp == 1) ? flyerMat[1] * rd : flyerMat[2] * rd);\n    aLsr = LsrAmp (qHitLsr, rdm);\n    col = mix (col, vec3 (1.5, 1.2, 0.5), aLsr);\n  }\n  if (dstHit < dstFar)\n     col = mix (col, 0.7 * SkyBg (rd), clamp (pow (dstGrnd / dstFar, 4.), 0., 1.));\n   col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  return col;\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 g, w;\n  float f, c, s;\n  v = normalize (v);\n  g = cross (v, vec3 (0., 1., 0.));\n  if (g.y != 0.) {\n    g.y = 0.;\n    w = normalize (cross (g, v));\n  } else w = vec3 (0., 1., 0.);\n  f = v.z * a.x - v.x * a.z;\n  f = - clamp (30. * f, -0.3 * pi, 0.3 * pi);\n  c = cos (f);\n  s = sin (f);\n  return mat3 (c, - s, 0., s, c, 0., 0., 0., 1.) * AxToRMat (v, w);\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 v, s;\n  s = sin (trkF * t);\n  flPos = vec3 (dot (trkA, s), 0., t);\n  v = vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n  if (vu > 0.) v.xz *= -1.;\n  flMat = EvalOri (v, vec3 (- dot (trkF * trkF * trkA, s), 0., 0.));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, vuMatF;\n  vec3 col, ro, rd;\n  vec2 canvas, uv, ut, mSize, mMid, ori, ca, sa;\n  float tGap, el, az, zmFac, s, t, aHlx, fHlx, flNear;\n  int fVu;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  sunDir = normalize (vec3 (cos (0.031 * tCur), 0.5, sin (0.031 * tCur)));\n  trkF = vec3 (0.029, 0.021, 0.016);\n  trkA = vec3 (15., 23., 34.);\n  fusLen = 1.;\n  vFly = 8.;\n  tGap = 80. / vFly;\n  aHlx = 1.2 * fusLen;\n  fHlx = 0.03 * vFly;\n  FlyerPM (tCur * vFly, 0.);\n  ro = flPos;\n  ro.xy += 0.6 * aHlx * vec2 (cos (fHlx * tCur), sin (fHlx * tCur));\n  vuMatF = flMat;\n  for (int k = 0; k < N_FLYER; k ++) {\n    t = tGap * (float (k) + floor (ro.z / (tGap * vFly))) - mod (tCur, tGap);\n    FlyerPM (t * vFly, 1.);\n    flyerPos[k] = flPos;\n    flyerPos[k].xy -= aHlx * vec2 (cos (fHlx * t), sin (fHlx * t));\n    flyerMat[k] = flMat;\n  }\n  az = 0.;\n  el = -0.05 * pi;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  dstFar = 250.;\n  fVu = 1;\n  s = abs (uv.x + 0.1 * uv.y * sign (uv.x));\n  if (abs (s - 0.8) < 0.01) {\n    fVu = 0;\n    col = vec3 (0.4) * clamp (1. - 50. * abs (s - 0.8), 0.1, 1.);\n  }\n  if (abs (s) > 0.8 && (uv.y + 0.15 * s > 1.1 || uv.y + 0.2 * s < -0.44) ||\n     abs (s) < 0.8 && (uv.y < -0.6 || uv.y > 0.98)) {\n    fVu = 0;\n    col = vec3 (0.4) * clamp (4. - 3.5 * abs (uv.y), 0.1, 1.);\n  }\n  mSize = vec2 (0.6, 0.18);\n  mMid = vec2 (0., -0.8);\n  zmFac = 2.;\n  ut = abs (uv - mMid) - mSize;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.x;\n    fVu = 1;\n    zmFac *= -0.4;\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  rd = rd * vuMatF;\n  if (fVu > 0) col = ShowScene (ro, rd);\n  else if (length (vec2 (abs (uv.x), uv.y) - vec2 (0.8, -0.85)) < 0.03) {\n    flNear = dstFar;\n    for (int k = 0; k < N_FLYER; k ++) {\n      s = flyerPos[k].z - ro.z;\n      if (s > 0. && s < flNear) flNear = s;\n    }\n    col = mix (vec3 (0.8, 0., 0.), vec3 (0., 0.8, 0.), step (50., flNear));\n  }\n  if (max (ut.x, ut.y) < 0.) {\n    ut = abs (ut);\n    if (min (ut.x, ut.y) * canvas.y < 2.) col = vec3 (0.5, 0.3, 0.1);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n),\n     Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y),\n     vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsffWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[945, 945, 967, 967, 1055], [1057, 1057, 1089, 1089, 2270], [2272, 2272, 2295, 2295, 2643], [2645, 2645, 2679, 2679, 3186], [3188, 3188, 3210, 3210, 3364], [3366, 3366, 3397, 3397, 3854], [3856, 3856, 3894, 3894, 4104], [4106, 4106, 4128, 4128, 4901], [4903, 4903, 4936, 4936, 5144], [5146, 5146, 5168, 5168, 5570], [5572, 5572, 5605, 5605, 5813], [5815, 5815, 5839, 5839, 7383], [7385, 7385, 7407, 7407, 7564], [7566, 7566, 7599, 7599, 8209], [8211, 8211, 8232, 8232, 8445], [8447, 8447, 8484, 8484, 8696], [8698, 8698, 8716, 8716, 10081], [10083, 10083, 10115, 10115, 10541], [10543, 10543, 10575, 10575, 10779], [10781, 10781, 10816, 10816, 12971], [12973, 12973, 13004, 13004, 13365], [13367, 13367, 13401, 13401, 13630], [15966, 15966, 16009, 16009, 16082], [16084, 16084, 16126, 16126, 16177], [16179, 16179, 16238, 16238, 16342], [16465, 16465, 16489, 16489, 16536], [16538, 16538, 16563, 16563, 16762], [16764, 16764, 16788, 16788, 17027], [17029, 17029, 17055, 17055, 17349], [17351, 17351, 17372, 17372, 17632], [17634, 17634, 17663, 17663, 17875], [17877, 17877, 17916, 17916, 18111], [18113, 18113, 18147, 18147, 18314], [18316, 18316, 18346, 18346, 18404], [18406, 18406, 18451, 18451, 18554], [18556, 18556, 18601, 18601, 18639], [18641, 18641, 18698, 18698, 18781]], "test": "error"}
{"id": "MsffWr", "name": "cheerilee cutiemark", "author": "ollj", "description": "it begins", "tags": ["pony", "mlp", "face", "flowers", "mylittlepony", "cutiemark", "mark", "talent"], "likes": 5, "viewed": 595, "published": "Public API", "date": "1495646257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self: https://www.shadertoy.com/view/MsffWr\n//cheerilee cutie mark flowers\n//cartoon pony butt for reference: \n//https://vignette3.wikia.nocookie.net/mlp/images/3/3f/Cheerilee%27s_cutie_mark_S1E12.png/revision/latest?cb=20121118163857&format=original\n\n//uncomment below line to show 2d distance fields, aso showing the polar modulo fold borders.\n//#define showFract\n\n#define tau 6.28318530718\n//return cathesian of polar_modulo see: http://mercury.sexy/hg_sdf\nfloat pModPolar(inout vec2 p,float t){float g=tau/t,a=atan(p.y,p.x)+g*.5,r=length(p),\n c=floor(a/g);a=mod(a,g)-g*.5;p=vec2(cos(a),sin(a))*r;if(abs(c)>=t*.5)c=abs(c);return c;}\n//return polar coordinates of carthesian input\nvec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//return carthesian coordinates of polar input\nvec2 p2c(vec2 u){return vec2(u.x*cos(u.y),u.x*sin(u.y));}\n//#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//return distance of (p) to ray that starts at (0,0) and has direction (0,-1);\nfloat ils(vec2 p){return mix(abs(p.y),length(p),step(0.,p.x));}\n//rotate p (carthesian) by angle r (full rotation==tau): p=r(p,r);\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//r() with offset o;\n//vec2 rOffset(vec2 p,float r,vec2 o){p-=o;return (cos(r)*p+sin(r)*vec2(-p.y,p.x))+o;}\n//return vec3 range [0..1] of 3*8bit color picker values 3*[0..255]\nvec3 bit82vec3(int r,int g,int b){return vec3(r,g,b)/255.;}\n//return framed [u], adjusting aspect ratio, and centering to display.\nvec2 frame(vec2 u){u/=iResolution.xy;u-=.5;\n u.x*=iResolution.x/iResolution.y;u*=2.;\n return u;}\n//return brightness of eyes and mouth \nfloat eyes(vec2 w,float n){\n w=c2p(w);//we branch modify for one polar coordinate, therefore we must transform.\n if(n!=0.)w.y+=2.*n;//rotate whole faces, depenting by \"slice\"\n w.y+=.5*sin(iTime+n);//faces wiggle to sin() pebbles rotate to cos()\n w=p2c(w);\n w.x*=1.2;\n n=pModPolar(w,3.);//eyes and mouth are a 3fold , within 3fold flowers.\n w.x-=.14;\n w=c2p(w);\n w.y+=4.7;//(tricky transform cases to make \"faces\" look half decent, by rotating eyes)\n if(n==1.)w.y+=1.;if(n==0.)w.y-=1.;\n w=p2c(w);\n float blur=4./iResolution.y;\n //max(a,-b) of 2 distances (a,b) returns a distance that is ==(a NOT b)== crescent moon.\n #ifdef showFract\n  return fract(max(length(w)-.08,-length(w-vec2(0,.04))+.1)*19.);}\n #else\n //return smoothstep(blur,-blur,max(length(w)-.1,0.));//debug Ooooooo-face\n return smoothstep(blur,-blur,max(length(w)-.08,-length(w-vec2(0,.04))+.1));}\n #endif\n \nvoid mainImage(out vec4 O,in vec2 U){vec2 m=-frame(U);\n float blur=2./iResolution.y;\n m=r(m,3.);//rotate\n m.y+=.07;//offset\n float n=pModPolar(m,3.);//3 fold symmetry for 3 flowers\n m+=vec2(-.55-n*.055,.1+n*.1);//offset within 3fold; +n* -> 2 flowers are closer together\n #ifdef showFract\n  float d=fract((length(m)-.25)*19.);//yellow flower circle distances.\n #else\n  float d=smoothstep(blur,-blur,length(m)-.25);//yellow flower circle.\n #endif                                    \n m=r(m,.5*cos(iTime+n));//rotate whole flower\n float e=eyes(m,n);\n n=pModPolar(m,8.);//8fold symmetry for pebbles. \n float p=ils(m-vec2(.31,0));//flower pebbles=distance to ray==infiniteLineSegment\n #ifdef showFract\n  p=fract(p*19.);//pink flower pebbles distances\n #else\n  p=smoothstep(blur,-blur,p-.11);//pink flower pebbles \n #endif\n vec3 cBG=bit82vec3(195,111,160);//color background cheerilee cutiemark eye && mouth && body\n vec3 cYe=bit82vec3(247,244,177);//color yellow     cheerilee cutiemark circles\n vec3 cPi=bit82vec3(244,215,227);//color pink       cheerilee cutiemark pebbles\n vec3 r; \n r=mix(cBG,cPi,p);//mix background with pink pebbles\n r=mix(r,cYe,d);//add yellow circles to mix\n #ifdef showFract\n  r=mix(r,1.1*(1.-cBG),e);//add eyes and mouth to mix, tinted green\n #else\n  r=mix(r,cBG,e);//add eyes and mouth to mix \n #endif\n O=vec4(r,1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsffWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 462, 500, 500, 637], [638, 685, 702, 702, 740], [741, 788, 805, 805, 845], [846, 978, 996, 996, 1041], [1157, 1333, 1367, 1367, 1392], [1393, 1464, 1483, 1483, 1560]], "test": "ok"}
{"id": "Msffz8", "name": "Sphere : 3D", "author": "JCDjcd", "description": "Simple 3D sphere", "tags": ["3d", "sphere"], "likes": 2, "viewed": 128, "published": "Public", "date": "1495667868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t) = P + t.d\nvec4 compute(vec3 P,vec3 d)\n{\n\t// compute the intersections with the sphere\n    // a.t^2 + b.t + c = 0\n    float a = dot(d,d);\n    float b = 2.0*dot(P,d);\n    float c = dot(P,P)-1.0; // sphere of radius 1\n    float delta = b*b-4.0*a*c;\n    \n    if(delta >= 0.0)\n    {\n        float t[2];\n        t[0] = (-b-sqrt(delta))/(2.0*a);\n        t[1] = (-b+sqrt(delta))/(2.0*a);\n        \n        vec4 color = vec4(0.0,0.0,0.0,1.0);\n        for(int i=0;i<2;i++)\n        {\n            vec3 M \t\t= P+t[i]*d;\n            float beta \t= acos(M.z);\n            float alpha\t= atan(M.y,M.x);\n            \n            int bool_alpha \t= cos(alpha*24.0) > 0.80 ? 1 : 0;\n            int bool_beta\t= cos( beta*24.0) > 0.80 ? 1 : 0;\n            if(bool_alpha == 1 && bool_beta == 0)\n            {\n                color  = vec4(1.0,0.0,0.0,1.0);\n                color *= i==1 ? 0.2 : 1.0;\n                break;\n            }\n            else if(bool_alpha == 0 && bool_beta == 1)\n            {\n                color  = vec4(0.0,1.0,0.0,1.0);\n                color *= i==1 ? 0.3 : 1.0;\n                break;\n            }\n            \n        } // for()\n        \n        return color;\n    }\n    else\n    {\n\t    return vec4(0.0,0.0,0.0,1.0);\n    }\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*2.5;\n    vec3 P \t\t\t= vec3(uv,-5.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    \n    float alpha1\t= iTime*TWOPI/11.0;\n    float alpha2\t= iTime*TWOPI/5.0;\n    P.zx\t\t   *= ROTATION(alpha1);\n    P.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n\t\n\tfragColor \t\t= compute(P,d);\n\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Msffz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 393, 422, 495, 1616], [1631, 1708, 1759, 1759, 2180]], "test": "ok"}
{"id": "MsffzM", "name": "Growing flowers", "author": "sebastianomorando", "description": "Playing with the polar coordinates exercise  taken from book of shaders:\nhttps://thebookofshaders.com/07/", "tags": ["polarcoordinates"], "likes": 0, "viewed": 62, "published": "Public", "date": "1495304876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-uv;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\n    float f = smoothstep(-3.0, 3.0, cos(a * cos(iTime) + a * sin(iTime/20.0)*10.0));\n    \n    color = vec3( 1.-smoothstep(f,f+0.2,r) );\n    \n    vec2 gradient = uv * ((sin(iTime)+2.0)/2.0);\n    \n\tfragColor = vec4(color * vec3(gradient, 0.5), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsffzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 478]], "test": "ok"}
{"id": "MsjcDc", "name": "Daily 2017-05-08", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 6, "viewed": 410, "published": "Public API", "date": "1494243189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat random(vec2 p){return fract(sin(dot(p,vec2(12.,78.)))*4375.);}\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d=abs(p)-b;\n    return min(max(max(d.x,d.y),d.z),0.)+length(max(d,0.));\n}\n\nfloat ribbon(vec3 p){\n    p.x+=sin(iTime+p.z)*.1;\n    p.y+=.4+sin(iTime*2.+p.z*3.)*0.1-p.z*.1;\n    p.xy*=rz2(sin(iTime+p.z)*.3);\n    return sdBox(p,vec3(.2,.001,2.));\n}\n\nfloat picket(vec3 p){\n    p.z-=2.;\n    p.y+=1.;\n    p.yz*=rz2(-1.);\n    return max(length(p.xy)-.1,abs(p.z)-1.);\n}\n\nfloat terrain(vec3 p){\n    p.x+=14.;\n    vec2 q=p.xz*vec2(.05,.03);\n    vec2 f=floor(q);\n    float r=sin(q.x*PI)*sin(q.y*PI)*random(f)*3.;\n    vec2 s=p.xz*vec2(.07,.03)*10.;\n    s.y+=iTime*3.;\n    s.x+=sin(s.y);\n    float fft=0.;\n    for(int i=0;i<20;++i)\n    \tfft+=pow(texture(iChannel0,vec2(float(i)*.005,.25)).r,10.);\n    float r2=sin(s.x)*sin(s.y)*fft*.3;\n    return p.y+1.5-r-r2;\n}\n\nfloat map(vec3 p){\n    float d=ribbon(p);\n    d=min(d,picket(p));\n    d=min(d,terrain(p));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfloat a=iTime*.5;\n    vec3 ro=vec3(uv+vec2(5.,3.)+vec2(cos(a),sin(a))*.5,-10.),rd=vec3(uv,1.),mp=ro;\n    for (int i=0;i<50;++i){\n        float md=map(mp);\n        if(md<.001)break;\n        mp+=md*rd;\n    }\n\tfragColor = vec4(length(mp-ro)*.01);\n}", "image_inputs": [{"id": "MdlXzr", "previewfilepath": "https://soundcloud.com/relaxdaily/n093-light-ambient-music-studying-yoga-think", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/relaxdaily/n093-light-ambient-music-studying-yoga-think", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 87], [89, 89, 110, 110, 157], [158, 158, 186, 186, 269], [271, 271, 292, 292, 439], [441, 441, 462, 462, 555], [557, 557, 579, 579, 943], [945, 945, 963, 963, 1051], [1053, 1053, 1110, 1110, 1416]], "test": "error"}
{"id": "MsjcDd", "name": "Larvae", "author": "liamegan", "description": "Thanks to Patricio Gonzalez Vivo\nhttps://thebookofshaders.com/12/", "tags": ["2d", "voronoi", "noise"], "likes": 2, "viewed": 179, "published": "Public", "date": "1494459991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// smin courtecy of iq http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nvec4 cells(in vec2 uv, float speed) {\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    float m_dist = 2.;\n    \n    for( int y = -1; y<= 1; y++ ) {\n        for( int x = -1; x <= 1; x++ ) {\n            vec2 neighbour = vec2(float(x), float(y));\n            vec2 n = i_uv + neighbour;\n            vec2 point = random2(i_uv + neighbour);\n            point = 0.5 + 0.5*sin(iTime * speed + 6.2831*point);\n            vec2 diff = neighbour + point - f_uv;\n            m_dist = smin(m_dist, length(diff) * m_dist, 16.0);\n            //m_dist = min(m_dist, length(diff) * m_dist);\n            \n        }\n    }\n    \n    return vec4(m_dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 2.;\n\tvec2 uv = (fragCoord.xy -.5 * iResolution.xy) / iResolution.y;\n    uv.x -= iTime * (speed / 4.);\n    \n    fragColor = cells(uv * 5., speed);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 118], [120, 192, 233, 233, 311], [313, 313, 350, 350, 964], [966, 966, 1023, 1023, 1189]], "test": "ok"}
{"id": "MsjcDG", "name": "Newton's Fractal : polynomial", "author": "JCDjcd", "description": "Newton's fractal with root finding of a polynomial. The color of point (x,y) is attributed as follow: starting the Newton's iterations with z0=x+i.y, the algorithm converges toward a root z of the polynomial P(z)=0. Argument of z is used for the color.", "tags": ["fractal", "newton"], "likes": 6, "viewed": 188, "published": "Public", "date": "1493755953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI (2.0*3.1415926535) \n//--------------------------------------------------------------------------\nvec4 hsv(float h,float s,float v)\n{\n    vec3 X = abs(fract(vec3(h,h,h)+vec3(1.0,2.0/3.0,1.0/3.0))*6.0-vec3(3.0,3.0,3.0));\n    vec3 C = v*mix(vec3(1.0,1.0,1.0),clamp(X-vec3(1.0,1.0,1.0),0.0,1.0),s);\n    return vec4(C.xyz,1.0);\n} // hsv()\n//--------------------------------------------------------------------------\nvec4 compute(vec2 z0)\n{\n    float t = iTime/5.0*TWOPI;\n        \n    // Define the polynomial X^5 + exp(i*t/3)*X^3 + 0.05*exp(i*t/2)*X + exp(i.t)\n    // The five roots will vary with time.\n    vec2 polynomial[6];\n    polynomial[0].x \t= sin(t);\n    polynomial[0].y \t= cos(t);\n    polynomial[1].x \t= 0.05*cos(t/2.0);\n    polynomial[1].y \t= 0.05*sin(t/2.0);\n    polynomial[2].x \t= 0.0;\n    polynomial[2].y \t= 0.0;\n    polynomial[3].x \t= cos(t/3.0);\n    polynomial[3].y \t= sin(t/3.0);\n    polynomial[4].x \t= 0.0;\n    polynomial[4].y \t= 0.0;\n    polynomial[5].x \t= 1.0;\n    polynomial[5].y \t= 0.0;\n    \n    // do the Newton's iteration\n    vec2 z = z0;\n    int i;\n    for(i=0;i<50;i++) // do only 50 iterations\n    {\n        // compute P(z) and its derivative P'(z)\n        vec2 P \t\t\t= vec2(0.0,0.0);\n        vec2 dP \t\t= vec2(0.0,0.0);\n        vec2 z_power_d \t= vec2(1.0,0.0); // z^d\n        vec2 z_power_d1 = vec2(0.0,0.0); // z^(d-1)\n        int d;\n        float x,y;\n        for(d=0;d<=5;d++)\n        {\n            x \t= polynomial[d].x*z_power_d.x-polynomial[d].y*z_power_d.y;\n            y \t= polynomial[d].x*z_power_d.y+polynomial[d].y*z_power_d.x;\n\t\t\tP  += vec2(x,y);\n\n            x \t= polynomial[d].x*z_power_d1.x-polynomial[d].y*z_power_d1.y;\n            y \t= polynomial[d].x*z_power_d1.y+polynomial[d].y*z_power_d1.x;\n\t\t\tdP += float(d)*vec2(x,y);\n            \n            z_power_d1 \t= z_power_d;\n            x \t\t\t= z_power_d.x*z.x-z_power_d.y*z.y;\n            y \t\t\t= z_power_d.x*z.y+z_power_d.y*z.x;\n            z_power_d \t= vec2(x,y);\n\t\t} // for()\n        \n        // compute P/dP\n        float r2 \t= dP.x*dP.x+dP.y*dP.y;\n        x     \t\t= P.x*dP.x+P.y*dP.y;\n        y \t\t\t= P.y*dP.x-P.x*dP.y;\n        // Newton's iteration new_z = z - P/dP\n        if(r2 < 1.0e-12)\n        {\n            break;\n        }\n\n        z.x -= x/r2;\n        z.y -= y/r2;\n\n    } // for()\n    \n    if(50 == i) // if everything goes well\n    {\n        float h = atan(z.y,z.x)/TWOPI;\n        float s = 1.0;\n        float v = 1.0;\n        return hsv(h,s,v);\n    }\n    else // divide by 0 should have been avoided\n    {\n\t    return vec4(0.0,0.0,0.0,1.0);\n    }\n    \n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get min/max of the resolution (in most case the width).\n    float m \t= min(iResolution.x,iResolution.y);\n    float M \t= max(iResolution.x,iResolution.y);\n    vec2 uv \t= ((fragCoord.xy-0.5*iResolution.xy) / m)*2.5;\n    fragColor \t= compute(uv);\n    \n    // draw axis and unit circle in white on top of everything\n    float width = 0.01;\n    if(abs(sqrt(uv.x*uv.x+uv.y*uv.y)-1.0)<width)\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    if(abs(uv.x)<width)\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    if(abs(uv.y)<width)\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n        \n} // mainImage()\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjcDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 111, 146, 146, 338], [339, 425, 448, 448, 2567], [2582, 2659, 2716, 2779, 3296]], "test": "ok"}
{"id": "MsjcWc", "name": "Mandelbrot Exponential Map", "author": "Dodecaplex", "description": "\"Mercator\" Mandelbrot as seen in http://www.aleph.se/andart/archives/2009/03/mercator_mandelbrot.html\n\nVertical scrolling corresponds to zooming on the target point, while horizontal scrolling corresponds to rotation.", "tags": ["fractal", "logarithmic", "mercator", "exponential"], "likes": 6, "viewed": 219, "published": "Public", "date": "1494210750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318\n\nvec2 cmul(in vec2 u, in vec2 v) { return vec2(u.x*v.x - u.y*v.y, u.y*v.x + u.x*v.y); }\n\nfloat cabs(in vec2 z) { return length(z);      }\nfloat carg(in vec2 z) { return atan(z.y, z.x); }\n\nvec2 polar(float t) { return vec2(cos(t), sin(t)); }\nvec2 cexp(vec2 z){ return exp(z.x)*polar(z.y); }\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return vec3(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y));\n}\n\nfloat sin2(float x) { float s = sin(x); return s*s; }\n\n\n\n#define SCALE TAU/2.0\nvec2 rectify(vec2 v) { return SCALE*(v+v-iResolution.xy)/iResolution.x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = rectify(fragCoord.xy);\n    vec2 m = 0.01*rectify(iMouse.xy);\n\n    vec2 pan = vec2(\n        mix(0.0, -4.5, sin2(0.5*iTime/sqrt(2.0))), // oscillating zoom level \n        0.5*iTime                                  // constant angular pan\n    );\n\n    vec2 target = vec2(-1.5, 0.0) - m; // zoom center\n    vec2 c = cexp(p.yx+pan)+target;\n\n    vec2 z = c;\n    float l = 0.0;\n    for (int i = 0; i < 256; ++i) {\n        z = cmul(z,z) + c;\n        if (dot(z,z) > 4.0) break;\n        l += 1.0;\n    }\n    \n    float s = 1.0+log2(1.0+cabs(z)); \n\tvec3 col = hsv2rgb(\n    \tvec3(\n            0.125*s - 0.2*iTime,\n            0.5,\n            sin2(s+iTime)\n        )\n    );\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 54, 54, 107], [109, 109, 132, 132, 157], [158, 158, 181, 181, 206], [208, 208, 229, 229, 260], [261, 261, 279, 279, 309], [311, 311, 336, 336, 511], [513, 513, 534, 534, 566], [592, 592, 614, 614, 665], [667, 667, 724, 724, 1431]], "test": "ok"}
{"id": "MsjcWK", "name": "Daily 2017-05-04", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 7, "viewed": 417, "published": "Public API", "date": "1493901072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://thndl.com/square-shaped-shaders.html\n\n#define TAU 6.2831853\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat st(float t,float n){return min(floor(mod(t,2.)*n)/n,ceil(mod(2.-t,2.)*n)/n);}\nfloat rev(vec2 p){\n    float a=atan(p.y,p.x);\n    float r=TAU/(st(iTime,4.)*4.+3.);\n    return cos(floor(.5+a/r)*r-a)*length(p);\n}\n\nfloat map(vec3 p)\n{\n    p.xy*=rz2(iTime*.3);\n    p.xz*=rz2(iTime*.7);\n\n    vec3 c=vec3(2.);\n    p=mod(p+.5*c,c)-.5*c;\n\n    p.yz*=rz2(iTime*.5);\n    p.xz*=rz2(iTime*.7);\n       \n    float rex=rev(p.xy)-.5;\n    float rin=rev(p.xy)-.3;\n    \n    return max(max(-rin,rex),abs(p.z)-.1)*.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(uv,-1.),rd=vec3(uv,1.),mp=ro;\n    for(int i=0;i<100;++i){\n        float md=map(mp);\n        if(md<.001)break;\n        mp+=rd*md;\n    }\n\tfragColor = vec4(length(mp-ro)*.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 89, 89, 136], [138, 138, 164, 164, 221], [222, 222, 240, 240, 352], [354, 354, 373, 373, 639], [641, 641, 698, 698, 949]], "test": "ok"}
{"id": "MslBWn", "name": "Pulse at mouse w/waves", "author": "JSeligstein", "description": "pulses color focused at mouse", "tags": ["2d", "pulse"], "likes": 3, "viewed": 143, "published": "Public", "date": "1495751635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float speed = 5.0;\n    float revSpeed = 5.0;\n    \n    float pulseWidth = 100.0;\n    float revPulseWidth = 12.0;\n    \n    vec2 center = iMouse.xy;\n    float dist = length(fragCoord-center);\n    float len = iResolution.x / 2.0;\n    float pct = 1.0-dist/len;\n\n    vec4 finalColor = vec4(pct, pct, pct, 1);\n    finalColor.r *= abs(sin(iTime));\n    finalColor.g *= abs(cos(iTime));\n    finalColor.b *= abs(sin(iTime) + cos(iTime));\n    \n    float pulseFactor = abs(sin(dist/pulseWidth-iTime*speed));\n\tfinalColor *= pulseFactor;\n    \n    float revPulseFactor = abs(sin(dist/revPulseWidth+iTime*revSpeed));\n\tfinalColor *= revPulseFactor;\n    \n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 732]], "test": "ok"}
{"id": "MslBz7", "name": "lines & cubes", "author": "fernandomv3", "description": "Repeated rounded cubes with moving lines and a background grid", "tags": ["grid", "line", "proceduralfiltering"], "likes": 8, "viewed": 512, "published": "Public API", "date": "1495515634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nvec2 map(vec3 p){\n  vec3 c = vec3(9.0,9.0,9.0);\n  vec3 q = mod(p,c) - 0.5*c;\n  float d = udRoundBox(q ,vec3(1.2,0.5,0.7),1.0);\n  float limit = -sdBox(p,vec3(32.0));\n  d = min(d,limit);\n  return vec2(d,limit > d ? 0.0 : 2.0);\n}\n\nvec2 trace(in vec3 camPos, in vec3 rayDir){\n  float s = 0.0;\n  float e = 0.0001;\n  float rMax = 128.0;\n  float m = 1.0;\n  for(int i = 0; i < 64; i++){\n    vec3 pos = camPos + s*rayDir;\n    vec2 d = map(camPos + s*rayDir);\n    if(d.x < e || d.x > rMax) break;\n    s += d.x;\n    m = d.y;\n  }\n  if(s > rMax) m = -1.0;\n  return vec2(s,m);\n}\n\nvec3 gridTexture(vec3 uvw){\n  vec3 res = vec3(0.0);\n  uvw = sin(uvw *0.5);\n  res += 0.2*exp(-16.0*abs(uvw));\n  res += 0.1*exp( -4.0*abs(uvw));\n  return vec3(length(res));\n}\n\nvec3 sampleTexture(vec3 uvw){\n  float dir = uvw.z;\n  dir = sin((-dir*6.0)+iTime*1.5);\n  float d = 1.0*exp(-16.0*abs(dir));\n  d += 0.5*exp(-4.0*abs(dir));\n  return vec3(0.0,d,d) + (1.0 - d)*vec3(0.05);  \n}\n\n//filtering based on https://www.shadertoy.com/view/MdjGR1\nconst int MaxSamples = 10;\nconst float detail = 4.0;\nvec3 sampleTextureWithFilter(vec3 uvw, vec3 dx, vec3 dy){\n  int sx = 1 + int(clamp(detail * length(dx-uvw),0.0,float(MaxSamples-1)));\n  int sy = 1 + int(clamp(detail * length(dy-uvw),0.0,float(MaxSamples-1)));\n  vec3 color = vec3(0.0);\n  for(int i=0;i<MaxSamples;i++){\n    for(int j=0;j<MaxSamples;j++){\n      if(i<sx && j<sy){\n        vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n        color += sampleTexture(uvw + st.x*(dx-uvw) + st.y*(dy-uvw));  \n      }\n    }  \n  }    \n  return color / float(sx*sy);\n}\n\nvec4 render(in vec3 camPos, in vec3 rayDir){\n  vec2 res = trace(camPos,rayDir);\n  if(res.y > -1.0){\n    vec3 pos = camPos + rayDir*res.x;\n    vec3 ddx_uvw = pos + dFdx( pos ); \n    vec3 ddy_uvw = pos + dFdy( pos );\n    //return vec4(sampleTexture(pos),1.0);\n    if (res.y < 1.0) return vec4(sampleTextureWithFilter(pos,ddx_uvw,ddy_uvw),1.0);\n\treturn vec4(gridTexture(pos),1.0);\n  }\n}\n\nmat3 camera(in vec3 position, in vec3 target){\n  vec3 w = normalize(target - position);\n  vec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n  vec3 v = cross(u,w);\n  return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv = uv * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n    \n  vec3 camPos =vec3(8.0) + vec3(4.0*cos(iTime*0.1),0.0,4.0*sin(iTime*0.1));\n  vec3 camTarget = vec3(0.0,0.0,0.0);\n  mat3 cam = camera(camPos,camTarget);\n  vec3 rayDir = cam * normalize(vec3(uv,1.0));\n  fragColor = render(camPos,rayDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 84], [86, 86, 116, 116, 203], [205, 205, 237, 237, 261], [263, 263, 280, 280, 489], [491, 491, 534, 534, 827], [829, 829, 856, 856, 1001], [1003, 1003, 1032, 1032, 1207], [1321, 1321, 1378, 1378, 1852], [1854, 1854, 1898, 1898, 2237], [2239, 2239, 2285, 2285, 2423], [2425, 2425, 2481, 2481, 2832]], "test": "error"}
{"id": "MslfDH", "name": "\"Supernova remnant\" by Duke 2", "author": "psygnisfive", "description": "Another modification, this time tweaking other parts of the code.", "tags": ["supernova"], "likes": 9, "viewed": 230, "published": "Public", "date": "1496121187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Supernova remnant\" by Duke\n// https://www.shadertoy.com/view/MdKXzc\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" (https://www.shadertoy.com/view/MsVXWW) \n// and \"Protoplanetary disk\" (https://www.shadertoy.com/view/MdtGRl) \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(vec3 p)\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.9;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n    float final = Disk(p.xzy,vec3(2.0,1.8,1.25));\n    final += fbm(p*90.);\n    final += SpiralNoiseC(p.zxy*0.5123+100.0*(iTime*0.0001))*3.0;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.001);\n\n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise-0.1;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<64; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n  \n\t\t// Loop break conditions.\n\t    if(td>0.9 || d<0.1*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n        // evaluate distance function\n        float d = map(pos);\n\t\t       \n\t\t// change this string to control density \n\t\td = max(d,0.0);\n        \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light \n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n        sum.rgb+=(vec3(0.67,0.75,1.00)/(lDist*lDist*10.)/80.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t\tif (d<h) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = h - d;\n            \n            // compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 1./200.;\n\t\t\n\t\t\tvec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;\t\n            \n\t\t\t// uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n       \n\t\t}\n      \n\t\ttd += 1./70.;\n\n        #ifdef DITHERING\n        //idea from https://www.shadertoy.com/view/lsj3Dw\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y*=120.;\n        uv.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uv.y,-uv.x+0.5*sin(4.*iTime+uv.y*4.0))).r);\n        #endif \n\t\t\n        // trying to optimize step size near the camera and near the light source\n        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);\n        \n\t}\n    \n    // simple scattering\n\tsum *= 1. / exp( ld * 0.2 ) * 0.6;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz*2.2),1.0);\n\t#else\n    fragColor = vec4(sum.xyz,1.0);\n\t#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslfDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[894, 908, 934, 934, 1153], [1155, 1155, 1174, 1174, 1263], [1265, 1265, 1290, 1290, 1327], [1329, 1329, 1354, 1354, 1419], [1422, 1422, 1452, 1452, 1548], [1550, 2211, 2239, 2239, 2788], [2790, 2790, 2817, 2817, 2979], [2981, 2981, 3001, 3001, 3119], [3186, 3215, 3265, 3350, 3620], [3622, 3622, 3698, 3698, 3914], [3916, 4031, 4067, 4067, 4231], [4233, 4233, 4290, 4290, 7462]], "test": "error"}
{"id": "MslfRn", "name": "Synthwave Shader [VIP2017]", "author": "Koltes", "description": "Entry for the Fast Compo at VIP 2017.", "tags": ["synthwave", "fastcompo"], "likes": 15, "viewed": 1282, "published": "Public API", "date": "1494677980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831853\nstruct M{float d;vec3 c;};M m;\nvoid mmin(float d, vec3 c){if (d<m.d){m.d=d;m.c=c;}}\n\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat amod(float a,float m){return mod(a,m)-m*.5;}\n\nfloat random(float x){return fract(sin(x*13.+4375.));}\n\nfloat height(vec2 iuv){\n    return sin(sin(iuv.x+iTime*.1)*sin(iuv.y+iTime*.1)*5.)*(pow(abs(iuv.x),2.)*.02+0.1);\n}\n\nvoid map(vec3 p){\n   \tm.d=max(max(p.y,.0),max(p.z-6.,0.));\n    vec2 uv=p.xz*2.;\n    uv.y+=iTime;\n    vec2 f=fract(uv)-.5;\n    float fft=max(texture(iChannel0,vec2(0.01,0.25)).r*2.-1.8,0.005);\n    float l=fft/(abs(f.x)*abs(f.y));\n    l+=.1*fft/(abs(p.z-6.));\n    m.c=mix(vec3(0.196, 0.003, 0.149),vec3(1, 0.019, 0.384),l);\n    \n    uv=p.xz-.5;\n    vec2 iuv=floor(uv);\n    vec2 fuv=fract(uv);\n    float h=mix(\n        mix(height(iuv+vec2(0.,0.)), height(iuv+vec2(1.,0.)), fuv.x),\n        mix(height(iuv+vec2(0.,1.)), height(iuv+vec2(1.,1.)), fuv.x),\n        fuv.y)-1.;\n    float d=p.y-h;\n    d=max(d,abs(p.z-10.)-4.);\n    vec2 vuv=fuv*(1.-fuv);\n    float v=vuv.x*vuv.y;\n    l=.01*fft/v;\n    mmin(d, vec3(0.,0.,1.)*l);\n}\n\nvec3 noise(vec2 uv){return texture(iChannel1,uv*.1).rgb;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 v=uv*(1.-uv);\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 uvn=uv*2.5;\n    vec2 iuvn=floor(uvn)+vec2(2.,0.);\n    vec2 fuvn=fract(uvn);\n    vec3 nb=mix(\n        mix(noise(iuvn+vec2(0.,0.)), noise(iuvn+vec2(1.,0.)), fuvn.x),\n        mix(noise(iuvn+vec2(0.,1.)), noise(iuvn+vec2(1.,1.)), fuvn.x),\n        fuvn.y)*.1;\n    vec3 c=(vec3(0.168, 0, 0.2)*.5+nb*3.);\n\n    vec2 suv=uv;\n    suv*=rz2(iTime*.02);\n    c*=vec3(1./(1.-smoothstep(0.9,1.,texture(iChannel1,suv).r)));\n    \n    vec2 uvc=uv-vec2(.4,.2);\n    float circle=1.-smoothstep(.25,.252,length(uvc));\n    float raytime=uv.y*100.+iTime*2.;\n    float thr=-uvc.y*5.-1.;\n    float rays= step(thr,sin(raytime));\n    circle=min(circle,rays);\n    vec3 csun=mix(vec3(0.968, 0.137, 0.094),vec3(1, 0.819, 0.019),uvc.y*3.+.5);\n    c=mix(c,csun,circle);\n    \n    vec3 ro=vec3(0.,2.,0.),rd=vec3(uv,1),mp=ro;\n    rd.yz*=rz2(-.2);\n    int i;\n    for(i=0;i<50;++i){map(mp);if(m.d<.001){break;}mp+=rd*.5*m.d;}\n    if(mp.z<14.)c=m.c;\n    \n    c=max(c,0.);\n    float cren=fract(uv.y*200.+iTime*.5);\n    c+=(smoothstep(.2,.3,cren)-smoothstep(.7,.8,cren))*0.01;\n    c=pow(c,vec3(1./2.2));\n    c *= pow(v.x*v.y * 25.0, 0.25);\n\tfragColor = vec4(c,1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XdlSR8", "previewfilepath": "https://soundcloud.com/synthwave80s/01-vice-point", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/synthwave80s/01-vice-point", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MslfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 80, 80, 105], [107, 107, 125, 125, 172], [174, 174, 202, 202, 224], [226, 226, 248, 248, 280], [282, 282, 305, 305, 396], [398, 398, 415, 415, 1115], [1117, 1117, 1137, 1137, 1174], [1176, 1176, 1233, 1233, 2488]], "test": "error"}
{"id": "MssBzN", "name": "Test clover 2", "author": "Zacland", "description": "Clover with effetcs", "tags": ["2d", "effects", "clover"], "likes": 1, "viewed": 346, "published": "Public", "date": "1495193173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // RGBA\n    vec4 color = vec4(0.5, 1.0, 0.5, 1.0);\n    // color.gr = vec2(0.1, 0.5);\n    \n    // pixel position\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    \n    //color.r = pixel.y;\n    \n    // center origin point \n    pixel = (pixel - 0.5) * 1.0;\n    \n    // aspect ratio\n    pixel.x *= iResolution.x / iResolution.y;\n    \n    // time elapsed\n    float time = iTime;\n\n    float anim = sin(time);\n\n    //pixel *= abs(anim); // * 3.;\n        \n    //pixel -= vec2(.5, 0.);\n    \n    //trèfle derrière la vitre bullée\n    pixel += mod(pixel, .05);\n    \n    //pixel *= abs(pixel * 0.5);\n    \n    // trèfle\n    \n    //float r = sqrt(dot(pixel, pixel)); // Old version\n    float r = length(pixel); // New version\n    \n    float a = atan(pixel.y, pixel.x) + time * 0.5;\n    float s = 0.5 + 0.5 * sin(3.0 * a);\n    float t = 0.15 + 0.35 * pow(s, 0.3);\n    t += 0.1 * pow(0.5 + 0.5 * cos(6.0 * a), 0.5);\n    float h = r/t;\n\n    //float f = 0.0;\n    //if(h < 1.0) f = 1.0; // Old Version\n    float f = 1. - step(1., h); // New Version\n    \n    color.rgb = mix(vec3(1.0), vec3(0.5 * h, 0.5 + 0.5 * h, 0.0), f);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 69, 1196]], "test": "ok"}
{"id": "MssfW8", "name": "Liquid Rainbow", "author": "DonKarlssonSan", "description": "Drag with the mouse!", "tags": ["noise"], "likes": 7, "viewed": 364, "published": "Public", "date": "1496067945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Simplex 2D noise\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float xnoise = snoise(vec2(uv.x, iTime / 5.0 + 10000.0));\n    float ynoise = snoise(vec2(uv.y, iTime / 5.0 + 500.0));\n    vec2 t = vec2(xnoise, ynoise) + iMouse.xy / 100.0;\n    float s1 = snoise(uv + t / 2.0 + snoise(uv + snoise(uv + t/3.0) / 5.0));\n    float s2 = snoise(uv + snoise(uv + s1) / 7.0);\n    vec3 hsv = vec3(s1, 1.0, 1.0-s2);\n    vec3 rgb = hsv2rgb(hsv);\n\tfragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MssfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 99, 121, 121, 290], [292, 386, 408, 408, 447], [449, 449, 470, 470, 1388], [1390, 1390, 1447, 1447, 1892]], "test": "ok"}
{"id": "Mssfz4", "name": "10/100", "author": "yahe", "description": "10/100", "tags": ["wood"], "likes": 13, "viewed": 550, "published": "Public API", "date": "1495153699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.x;\n    \n    float noise = fractalNoise2d(uv);\n    uv = rotate2D(uv, noise*300.);\n    \n    uv = .5*uv;\n    float plasma = noise*(sin(uv.x)+cos(uv.y))*5.;\n    \n    vec3 col = vec3(sin((-plasma)+iTime),\n                    sin((-plasma+.4)+iTime),\n                    sin((-plasma+.5)+iTime));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mssfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 164], [166, 245, 269, 269, 799], [801, 874, 905, 905, 1282], [1284, 1284, 1322, 1322, 1462], [1464, 1464, 1520, 1520, 1878]], "test": "ok"}
{"id": "MsSyDy", "name": "Wasted land", "author": "Karambit", "description": "Nothing special about it", "tags": ["terrain"], "likes": 9, "viewed": 1129, "published": "Public API", "date": "1493762768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Scale vec3(.8, .8, .8)\n#define K 19.19\n\n\nconst vec3 BlueSky = normalize(vec3(50.0,119.0,223.0));\nconst vec3 Orange = normalize(vec3(180.0,100.0,36.0))*0.8;\n\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * Scale);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec3 fbm(in vec3 q)\n{\n            vec3 f  = 0.5000*noise( q ); q = m*q*2.01;\n            f += 0.2500*noise( q ); q = m*q*2.02;\n            f += 0.1250*noise( q ); q = m*q*2.03;\n            f += 0.0625*noise( q ); q = m*q*2.01; \n            //f += 0.03125*noise( q ); q = m*q*2.01; \n    return vec3(f);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  p.y *= pow(sin(fbm(p*0.3).y), 2.0); \n  return dot(p,n.xyz) + n.w;\n}\n\nfloat map(vec3 p)\n{\n    return sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const int ITERATIONS = 80;\n    const float maxD = 60.0;\n    const float minD = 0.0001;\n    float h = 1.0;\n    float t = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n        if(h < minD || t > maxD)\n            break;\n        \n        h = map(ro+rd*t);\n        t += h;\n    }\n    \n    if(t > maxD) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvec3 lighting(vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 n = normalize(calcNormal(p));\n    vec3 l = -normalize(ro + vec3(20.,20.0, 2.0) - p );\n    float d = max(dot(-l, n), 0.0);\n    \n    float s = pow(max(dot(reflect(-l, n), rd), 0.0), 2.0);\n    \n    float a = 1.0 / length(ro - p);\n    \n    return vec3(s+d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(sin(iTime*0.05)*10.0, sin(iTime)*0.2, 2.0 - iTime*0.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = intersect(ro, rd);\n    \n    vec3 color;\n    vec3 pos = ro+rd*t;\n    vec3 normal = calcNormal(pos);\n    \n    vec3 t1= texture(iChannel1, vec2(pos.x, pos.z)*0.2).rgb;\n    vec3 t2= texture(iChannel0, vec2(pos.x, pos.z)*0.2).rgb;\n    vec3 c = mix(t2, t1, max(dot(normal, vec3(0.0, 1.0, 0.0)), -1.0));\n    \n    c *= lighting(pos, ro, rd)*t2;\n    \n    /**Sky*/\n    vec3 FBM = fbm(vec3(vec2(uv.x, uv.y*2.0), 1.0)*2.0+iTime*0.1);\n    \n    float scatteringFactor = uv.y+0.3;\n    \n    vec3 gradient = mix(normalize(vec3(148, 235, 233)), BlueSky, uv.y/2.0 - 0.5);\n    \n    vec3 SkyColor = mix(Orange, gradient, scatteringFactor);\n    \n    vec3 fgc = mix(vec3(2.0), vec3(0.5), smoothstep(0.0, 1.0, length(uv-vec2(0.0, 1.0))));\n    color = mix(SkyColor*fgc, vec3(0.8), (pow(FBM.x, 3.0))+uv.y);\n    \n    \n    /*------------------------------------------------------*/\n    c = mix(c, color, smoothstep(0.4, 0.8, t/20.0));\n    if(t > 0.0)\n    {\n        color = vec3(c);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsSyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 185, 185, 290], [292, 292, 317, 317, 791], [918, 918, 939, 939, 1221], [1223, 1223, 1256, 1256, 1284], [1286, 1286, 1319, 1345, 1415], [1417, 1417, 1436, 1436, 1487], [1489, 1489, 1530, 1530, 1873], [1875, 1875, 1907, 1907, 2119], [2121, 2121, 2162, 2162, 2427], [2429, 2429, 2486, 2486, 3736]], "test": "error"}
{"id": "MsSyWK", "name": "sawtooth mod() fract()", "author": "ollj", "description": "distance of point p.xy to\ny=fract(x) <-> dist=sawtooth(p)\n&\ny=mod(x,a)*b  <->  dist=sawtoothW(p,vec2(a,b))\n*U <-> unsigned, saves 1mult 2add.\n\nyou might be able to fix some discontinuities\nby subtracting the distance to sawtooth-functions from \"something\"", "tags": ["2d", "wave", "ocean", "mod", "distance", "fract", "sawtooth"], "likes": 3, "viewed": 477, "published": "Public API", "date": "1493800257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//signed (& unsigned) distance from p.xy\n//to sawtooth function y=mod(x,a)*b;\n//hold left mouse button to set; mouse.x->a , mouse.y->b\n//\n//also has shortcut version to sawtooth function y=fract(x)=mod(x,1)*1;\n\n//set zoom and distance_between_lines (converging to surface).\n//#define zoom    (sin(iTime   )*.5+1.)\n#define zoom  1.\n\n#define dbl  (5.*sin(iTime*3.)+5.)\n//#define dfv   5.\n\n//sawShape.x=wavelength sawshape.y=amplitude range [0..sawShape.y]\n//#define sawShape vec2(1,2)\n#define sawShape vec2(sin(iTime)+2.,cos(iTime)+1.)\n\n//eightRotation.y=eightRotation.x=cos(3.14/4)=sin(3.14/4)=\n//...pow(2,1/2)/2=sqrt(2)/2=0.70710678118654752440084436210485\n#define p222 sqrt(0.5) \n//return p, rotated by 45deg\nvec2 pR45(in vec2 p){return (p+vec2(p.y,-p.x))*p222;}\n//return p, rotated by r;\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n\n//the function y=fract(x)   \n//is a sawtooth with wavelength=amplitude=1\n//\n//the function y=mod(x,b)*c \n//is a sawtooth with wavelength=b, amplitude=c\n\n//distance to sawtooth with wavelength=amplitude=1 is simpler\n//than a parametric sawdooth with parametric wavelength.\n//below both are solved, for signed and unsidned values.\n\n//a core subroutine is; distance to an infinite-line-segment: ils()\n\n//return distance of (p) to ray that starts at (0,0) and has direction (0,-1);\nfloat ils(vec2 p){return mix(abs(p.y),length(p),step(0.,p.x));}\n//vertical utility of ils()\nfloat vert(vec2 p){p.x=fract(p.x);return ils(p.yx-vec2(1,0));}\n//45deg diagonal utility of ils()\nfloat diag(vec2 p){p.x=fract(p.x);p=pR45(p);\n return ils(p-vec2(sqrt(2.),0));}\n\n//tt1 and tt2 transform p from a point below the curve \n//to an identical point above the curve.\n//(as far as unsigned distance function to its curve is concerned) \n\n//if(p.y-fract(p.x)<0.){p=-p;p.y+=1.;}//<- is identical to [t1]\n#define tt1 p=mix(p,-p,t);p.y+=mix(0.,1.,t);\n#define tt11 float t=step(p.y-fract(p.x),0.);tt1\n//return unsigned distance to sawtooth-wave, wavelength=1, range.y=[0..1]\nfloat sawtoothU(vec2 p){tt11 return min(vert(p),diag(p));}\n\n//abive uses vert(p),diag(p);\n//below function does not use vert(p),diag(p), but its functions.\n\n//return distance to sawtooth-wave, wavelength=1, range.y=[0..1]\nfloat sawtooth(vec2 p){tt11\n p.x=fract(p.x);\n float vert=ils(p.yx-vec2(1,0));\n p=pR45(p);\n float diag=ils(p-vec2(sqrt(2.),0));\n return (1.-t*2.)*min(vert,diag);}\n\n//above 2 functions are special SHORT cases for below 2 functions as in:\n//sawtoothU(p)==sawtoothWU(p,vec2(1))\n//sawtooth (p)==sawtoothW (p,vec2(1))\n\n\nfloat diag2(vec2 p,vec2 w){\n return ils(r(p,-atan(w.y/w.x))-vec2(length(w),0));}\n\nfloat vert2(vec2 p,vec2 w){p.x=mod(p.x,w.x);\n return ils(p.yx-vec2(w.y,0));}\n\n//subroutine for sawtoothW*()\nfloat sawtooth2s(vec2 p,vec2 w){p.x+=w.x;\n float v=vert2(p,w),d=diag2(p,w),e=diag2(p-vec2(w.x,0),w);\n return min(min(d,e),v);}\n\n#define tt2 p.y-=mix(0.,w.y,t);p=mix(p,-p,t);\n#define tt2w p=vec2(mod(p.x,w.x),p.y);float t=step(p.y-p.x*w.y/w.x,0.);tt2\n//return unsigned distance of [p] to sawtooth[w] .x=wavelength .y=amplitude\nfloat sawtoothWU(vec2 p,vec2 w){tt2w return sawtooth2s(p,w);}\n\n//return distance of [p] to sawtooth[w] .x=wavelength .y=amplitude\nfloat sawtoothW(vec2 p,vec2 w){tt2w return (1.-t*2.)*sawtooth2s(p,w);}\n\n//subroutine for sawtoothW*()\nfloat sawtooth2s2(vec2 p,vec2 w){p.x+=w.x;\n float v=vert2(p,w),d=diag2(p,w),e=diag2(p-vec2(w.x,0),w);\n return min(min(d,e),v);}\nfloat sawtoothW2(vec2 p,vec2 w){tt2w return (1.-t*2.)*sawtooth2s2(p,w);}\n\nvec2 frame(vec2 u){u=u/iResolution.xy;u-=.5;\n u.x*=iResolution.x/iResolution.y;u*=5.;return u*zoom;}\nvec2 frame2(vec2 u){u=u/iResolution.xy;\n u.x*=iResolution.x/iResolution.y;u*=5.;return u*zoom;}\n\nvoid mainImage( out vec4 Out, in vec2 In ){\n vec2 u=frame(In);\n vec2 m=frame2(iMouse.xy);\n vec2 shape=sawShape;   \n if(iMouse.w>0.&&iMouse.x>0.)shape=m;\n\n float sawU=sawtoothWU(u,shape);\n float saw =sawtoothW(u,shape);\n //above is distance to y=mod(u,shape.x)*shape.y\n //overwrite to show a simpler special fract(u)=mod(u,1)*1 case:\n //saw  =sawtooth(u);\n //sawU =sawtoothU(u);\n \n float sawS=saw+.73;//makes a neat wave-shilouette.\n sawU=fract(sawU*dbl);\n saw =fract(saw *dbl);\n float green=sawU;//fract(diag(u)*5.);\n float blue =saw;//fract(vert(u)*5.);\n \n //green=.2*fract(length(u));\n //blue=1.-pow(fract(u.x)*fract(u.y),.3);//cheap coordinate system\n    \n //sawS shows some potential \n //...to make a good distance to something like a wave:\n sawS+=.01*(sin(u.x*20.-iTime*9.)+5.*cos(u.y*5.));//+octvaves.\n sawS=smoothstep(0.,.1,sawS);//sharper gradient\n green=sawS;\n \n //blue=+green;sawU=green;//only show \"ocean\"\n \n Out=vec4(sawU,green,blue,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsSyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[681, 710, 731, 731, 763], [1238, 1317, 1335, 1335, 1380], [1381, 1409, 1428, 1428, 1471], [1472, 1506, 1525, 1525, 1584], [2520, 2520, 2547, 2547, 2600], [2602, 2602, 2629, 2629, 2678], [2680, 2710, 2742, 2742, 2836], [3237, 3267, 3300, 3300, 3394], [3469, 3469, 3488, 3488, 3569], [3570, 3570, 3590, 3590, 3665], [3667, 3667, 3710, 3710, 4617]], "test": "ok"}
{"id": "MsXBW4", "name": "OJ - Ljusfärd, scene 2", "author": "rammoskar", "description": "Full demo: https://www.youtube.com/watch?v=-helx-SxnJo", "tags": ["3d", "refraction"], "likes": 24, "viewed": 598, "published": "Public API", "date": "1496161719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TIME mod(iTime, 24.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n#define LPOS vec3(0, 2, 0)\nvec4 roomLight(vec3 pos) {\n\tvec3 lightCol = vec3(1,0.8, 0.8);\n\n\tfloat dis = sdSphere(pos - LPOS, 0.1);\n\n\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 30.0/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec4 laser(vec3 p) {\n\tvec3 lightCol = vec3(1,0.05, 0.05);\n\tfloat dx = 2.0;\n\tint partX = int(p.x / dx);\n\tp.x = mod(p.x, dx) - dx * 0.5;\n\tfloat dz = 4.0;\n\tp.z = mod(p.z, dz) - dz * 0.5;\n\tp.y -= -1.3;\n\tfloat music = drum; \n\tfloat dis = sdCappedCylinder(p.xzy, vec2(0.0, 1.0 * (0.2 + 0.8 * music))) - 0.05;\n\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 5.0/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 r = roomLight(pos);\n\tvec4 l = laser(pos);\n\tdis = min(r.w, l.w);\n\treturn r.xyz + l.xyz;\n}\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\n\tvec3 lpos = LPOS;\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 70.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.1*dis*dis);\n\tfloat tmp = 0.0;\n\tcolor =  color * (0.1 + 0.9*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n#define MAT_BOX 1.0\n#define MAT_GEL 2.0\n#define MAT_GROUND 3.0\n\nvec2 gels(vec3 p, inout bool inBox){\n\tfloat ttt = TIME * 1.6;\n\tfloat gelDis = 99999.0;\n\tfloat boxDis = 99999.0;\n\tfloat cycle = 14.0;\n\tfloat mz = 4.0;\n\tp.z += 2.0;\n\tfloat partZ = floor(p.z / mz);\n\tfloat iTimeZ = ttt + partZ * 3.0;\n\tfloat time = mod(iTimeZ, cycle);\n\n\tfloat t1 = max(0.0, time - 0.5);\n\tfloat t2 = time;\n\n\tfloat m = 3.0;\n\n\tp.x +=  smoothstep(cycle - 2.0, cycle, mod(iTimeZ, cycle)) * m;\n\tfloat part = floor((p.x) / m);\n\tp.x = mod(p.x, m) - m * 0.5;\n\n\n\tp.z = mod(p.z, mz) - mz * 0.5;\n\n\tfloat r = 0.3;\n\tfloat rt = iTimeZ;\n\tfloat yr = 1.0;\n\tfloat cx = \tcos(rt + p.y * yr)*r;\n\tfloat cz = \tsin(rt + p.y * yr)*r;\n\tfloat s = 1.0;\n\tfloat outer = 9999.0; \n\tfloat inner = 9999.0; \n\tfloat mt = mod(iTimeZ + 3.0, 60.0);\n\tif (partZ == 0.0) {\n\t\touter = length(p - vec3(0, 0.4 , 0)) - 1.2;\n\t\tinner = sdCappedCylinder(p - vec3(0, 2.5, 0), vec2(0.0, 2.0)) - 0.9;\n\t} else if(partZ == 1.0) {\n\t\touter = sdHexPrism(p.xzy - vec3(0, 0, 0), vec2(1.1, 1.1));\n\t\tinner = sdHexPrism(p.xzy - vec3(0, 0, 2), vec2(0.9, 2.0));\n\t} else if (partZ == -1.0) {\n\t\touter = udRoundBox(p, vec3(s), s * 0.1);\n\t\tinner = udRoundBox(p - vec3(0, 1.0, 0), vec3(s * 0.8, s, s * 0.8), s * 0.1);\n\t}\n\tboxDis = max(-inner, outer);\n\tif (boxDis > 0.01) {\n\t\tinBox = false;\n\n\t\tif (abs(partZ) <= 1.0) {\n\t\t\tt1 -= part * cycle;\n\t\t\tt2 -= part * cycle;\n\t\t\tfloat dis = p.y - min(t1, 9.0) * 0.1 + sin(length(p.xz*20.0) - 2.0*(1.0-smoothstep(10.0,12.0,t2)))*0.03*(1.0-0.8*smoothstep(8.0, 12.0, t2));\n\t\t\tif (inner > 0.01 || length(p.xz-vec2(cx, cz))*2.0 > t1) {\n\t\t\t\t\tdis = 999.0;\n\t\t\t\t}\n\t\t\tfloat dc = sdCappedCylinder(p - vec3(cx, 12.0 - min(t2 * 3.0, 2.0), cz), vec2(0.1, 10.0));\n\t\t\tfloat h = 3.0 - max(0.0, t2 - 8.0);\n\t\t\tif (p.y > h) {\n\t\t\t\tdc = max(dc,p.y - h);\n\t\t\t}\n\t\t\tgelDis = smink(dis, dc, 1.5);\n\t\t}\n\t}\n\treturn gelDis < boxDis || inBox ? vec2(gelDis, MAT_GEL) : vec2(boxDis, MAT_BOX);\n}\n\nvec2 map(vec3 p, inout bool inBox) {\n\tvec3 q = mod(p, 1.0) - 0.5;\n\tq.y = p.y + 2.0;\n\tfloat dis = length(max(abs(q)-vec3(0.3),0.0))- 0.3;\n\n\tq = mod(p.xzy, 1.0) - 0.5;\n\tq.y = p.z - 8.0;\n\tdis = min(dis, length(max(abs(q)-vec3(0.3),0.0))- 0.3 );\n\n\tq = mod(p.xzy, 1.0) - 0.5;\n\tq.y = p.z + 8.0;\n\tdis = min(dis, length(max(abs(q)-vec3( 0.3),0.0))-  0.3 );\n\n\tvec2 res = vec2(dis, MAT_GROUND);\n    res = un(res, gels(p, inBox));\n\treturn res;\n}\n\nvec2 map(vec3 p) {\n\tbool tmp = false;\n\treturn map(p, tmp);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz).x - map(p - ep.xyz).x;\n    normal.y = map(p + ep.yxz).x - map(p - ep.yxz).x;\n    normal.z = map(p + ep.yzx).x - map(p - ep.yzx).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal)\n{\n\tfloat o = clamp(2.0*map(p + normal * 0.5).x, 0.0, 1.0);\n\treturn 0.7 * o + 0.3; //fma(0.7, o, 0.3);\n}\n\n\n#define maxIter 200\n#define maxDis 300.0\nvec3 raymarch(vec3 ro, vec3 rd, vec3 eye) {\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tvec3 col = vec3(0);\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tbool inBox = false;\n\tfor (int i = 0; i < maxIter; i++) {\n\t\tvec3 p = ro + rd * t;\n\t\tvec2 res = map(p, inBox);\n\t\td = res.x;\n\t\tfloat fogAmount = 0.005;\n\t\tfloat lightDis = -1.0;\n\t\tvec3 light = evaluateLight(p, lightDis);\n\t\td = min(min(d, 1.0), max(lightDis, 0.05)); \n\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\tscatteredLight += transmittance * lightIntegrated;\n\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\tt += d;\n\t\tfloat m = res.y;\n\t\tif (d < 0.01) {\n\t\t\tvec3 c = vec3(1);\n\t\t\tvec3 normal = getNormal(p);\n\t\t\tif (m == MAT_BOX) {\n\t\t\t\tc = vec3(0.7, 0.6, 0.4);\n\t\t\t} else if(m == MAT_GEL) {\n\t\t\t\tif (p.z > 2.0) {\n\t\t\t\t\tc = vec3(0.1, 0.8, 0.3);\n\t\t\t\t} else if (p.z < -2.0) {\n\t\t\t\t\tc = vec3(0.9, 0.2, 0.3);\n\t\t\t\t} else {\n\t\t\t\t\tc = vec3(0.3, 0.1, 0.7);\n\t\t\t\t}\n\t\t\t} else if(m == MAT_GROUND) {\n\t\t\t\tvec3 fp = floor(p);\n\t\t\t\tc = vec3(0.5);//texCube(iChannel0, p * 1.0 + floor(p) * 1.3, normal, 1.0).xyz * 0.5 + 0.5;\n\t\t\t\tif (abs(p.z) <= 1.0 || abs(p.z + 4.0) <= 1.0 || abs(p.z - 4.0) <= 1.0) {\n\t\t\t\t\tc = mix(c, vec3(0.2, 0.5, 0.7), 0.5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc *= occlusion(p, normal);\n\t\t\taddLightning(c, normal, eye, p);\n\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\n\t\t\tinBox = true;\n\t\t\tref *= 0.8;//0.8\n\t\t\ti = 0;\n\n\t\t\tif (m != MAT_BOX){\n\t\t\t\treturn col;\n\t\t\t}\n\n\t\t\trd = refract(rd, getNormal(p), 1.0/1.3);\n\t\t\tro = p + rd*0.05;\n\t\t\tt = 0.0;\n\t\t}\n\t\tif (t > maxDis ||  ref < 0.1) {\n\t\t\treturn col;\n\t\t}\n\t}\n\n\treturn col;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n    \n    float t = TIME * 0.25;\n    vec3 eye = vec3(sin(t) * 3.5, 2.5 + 0.5 * sin(t) , cos(t) * 3.5);\n\tvec3 tar = vec3(0, 0 , sin(t) * 1.5);//eye + vec3(0.0, 0.0, 1.0);\n\n\tfloat mt = mod(TIME, 25.0);\n\tfloat tpart = floor(mt / 5.0);\n\tfloat tmp = mod(mt, 5.0)*1.5;\n\tif (tpart == 0.0) {\n\t\teye = vec3(0.0, 2.0 + tmp * 0.3, 0.0);\n\t\ttar = vec3(0.1);\n\t} else if (tpart == 1.0) {\n\t\teye = vec3(0, 3, 1.5 + tmp * 0.2);\n\t\ttar = eye + vec3(1,-0.8,0);\n\t} else if (tpart == 2.0) {\n\t\teye = vec3(4.0, 3.0, -3.0 + tmp * 0.2);\n\t\ttar = eye + vec3(-1,-0.8,0.5);\n\t} else if (tpart == 3.0) {\n\t\teye = vec3(3.5, 2, 6.5 - tmp * 0.2);\n\t\ttar = eye + vec3(0,-0.5,-1);\n\t} else /*if (tpart == 4.0) */{\n\t\tvec3 start = vec3(0, 15, 0);\n\t\ttar = LPOS + vec3(0.01);//vec3(0.1);\n\t\teye = start  + smoothstep(4.0, 6.0, tmp)*(tar - start);\n\t}\n\n\n\tvec3 dir = normalize(tar - eye);\n\tfloat rot = TIME * 0.5;\n\tvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), dir));\n\tvec3 up = cross(dir, right);\n\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n//\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, eye);\n\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 106, 106, 135], [137, 137, 182, 182, 222], [224, 224, 266, 266, 365], [367, 367, 400, 400, 465], [467, 467, 492, 492, 557], [559, 559, 594, 594, 661], [663, 663, 699, 699, 783], [785, 785, 822, 822, 849], [851, 851, 882, 882, 920], [922, 922, 956, 956, 980], [982, 982, 1013, 1013, 1100], [1102, 1102, 1166, 1166, 1291], [1320, 1320, 1346, 1346, 1557], [1559, 1559, 1579, 1579, 1994], [1996, 1996, 2043, 2043, 2138], [2140, 2140, 2210, 2210, 2573], [2575, 2575, 2606, 2606, 2715], [2717, 2717, 2759, 2759, 2852], [2853, 2853, 2879, 2879, 3010], [3012, 3012, 3048, 3048, 3207], [3273, 3273, 3309, 3309, 5112], [5114, 5114, 5150, 5150, 5548], [5550, 5550, 5568, 5568, 5610], [5612, 5612, 5636, 5636, 5877], [5879, 5879, 5917, 5917, 6019], [6063, 6063, 6106, 6106, 7652], [7658, 7658, 7713, 7713, 9131]], "test": "ok"}
{"id": "MsXfW8", "name": "Daily 2017-05-27", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 9, "viewed": 441, "published": "Public API", "date": "1495881544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n\nfloat map(vec3 p) {\n    p.xy*=rot(iTime*.3);\n    p.yz*=rot(iTime*.5);\n    p.xz*=rot(iTime*.7);\n    vec2 q=vec2(length(p.xz)-1.,p.y);\n  \treturn length(q)-.2;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e=vec2(.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n    ));\n}\n\nfloat clr(vec2 uv) {\n    vec3 ro=vec3(uv,-2.),rd=normalize(vec3(uv,1.)),mp=ro;\n    float f;for(f=0.;f<30.;++f){\n        float md=map(mp);\n        if(md<.001)break;\n        mp+=rd*md;\n    }\n    if(length(mp)>1e2)return 1.;\n    vec3 n=normal(mp);\n    return length(cross(n,rd));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 st=uv*40.,fst=fract(st),ist=floor(st);\n    vec2 wp=ist+step(.5,fst),bp=ist+vec2(.5);\n    float wl=length(st-wp),bl=length(st-bp);\n    float c=step(clr(uv)-.5,(bl/(bl+wl)-.5));\n\tfragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 75, 75, 214], [216, 216, 237, 237, 404], [406, 406, 426, 426, 684], [686, 686, 743, 743, 1045]], "test": "ok"}
{"id": "MsXfzr", "name": "zebra", "author": "lennyjpg", "description": "trying to make this: https://leanderherzog.ch/zebra/\n\n", "tags": ["2d"], "likes": 9, "viewed": 552, "published": "Public API", "date": "1494597561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void zebra(inout vec4 O, in vec2 uv, in float t, in float speed, float bands) {\n    float d = uv.y + t * speed;\n    O = vec4(smoothstep(.4, .41, abs(1.0 + sin( d * bands))*0.5));\n}\nvoid dots(inout vec4 O, in vec2 uv, in float t, in float speed) {\n    uv.y -= iTime / 10.0;\n    O = vec4(round(1.0-length(vec2(0.5) - fract(uv*20.))*5.));\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U.xy / iResolution.y, mouse = (vec2(iMouse.xy / iResolution.y) - .5 )*2.;\n    float t = iTime, a = atan(mouse.y,mouse.x);\n    uv-=.5;\n    uv = mat2(cos(a),-sin(a),sin(a),cos(a)) * uv + .5;\n    float speed = 0.1 + round( fract( cos( 3.37 * uv.x + 7.5 )) * 2. * (1. - iMouse.x / iResolution.x * 2.) -1.0);\n    if(abs(speed) > .9) {\n      zebra(O, uv, t, speed, 13.7);\n    } else if(abs(speed) > .3) {\n      dots(O, uv, t, speed);\n    } else {\n      zebra(O, uv, t, speed, 100.2);\n    }   \n}\n\n/*\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= .5;\n    _st =  mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle)) * _st;\n    return _st + .5;\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float t = iTime;\n    vec2 u = U.xy / iResolution.y;\n    \n    // rotate everything with mouse\n    vec2 mouse = (vec2(iMouse.xy / iResolution.y) - .5 ) * 2.;\n    float angle = atan(mouse.y,mouse.x);\n    float ta = t*0.1;\n    u = rotate2D(u,angle+ta);\n   \n    // random speed in both directions\n    float minimumSpeed = .1;\n    float speed =  round( fract( cos( 3.37 * u.x + 7.5 ))*2.-1.) ;\n    speed += minimumSpeed;\n        \n    // hm\n    float d = u.y + t * speed;\n    float bands = 13.7;\n    float g = (1. + sin( d * bands)) * .5;\n    O = vec4(round(g));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 79, 79, 180], [181, 181, 246, 246, 337], [338, 338, 379, 379, 882]], "test": "ok"}
{"id": "Xd2cDt", "name": "RaymarchingSphere", "author": "gyabo", "description": "Rehabilitation...", "tags": ["raymarchingsphere"], "likes": 8, "viewed": 159, "published": "Public", "date": "1494372439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n\t\n}\n\nfloat map(vec3 p) {\n\tfloat tp0 = 4.0 - dot(abs(p), vec3(0,1,0));\n\tfloat tp1 = 4.0 - dot(abs(p), vec3(1,0,0));\n\tfloat ts = length(mod(p, 2.0) - 1.0) - 0.5;\n\tfloat tx = length(mod(p.yz, 2.0) - 1.0) - 0.3;\n\tfloat ty = length(mod(p.zx, 2.0) - 1.0) - 0.3;\n\tfloat tz = length(mod(p.xy, 2.0) - 1.0) - 0.3;\n    float txs = length(mod(p.yz, 4.0) - 2.0) - 1.9;\n\tfloat tys = length(mod(p.zx, 4.0) - 2.0) - 1.9;\n\tfloat tzs = length(mod(p.xy, 4.0) - 2.0) - 1.9;\n    float txp = length(mod(p.yz, 0.2) - 0.1) - 0.04;\n\tfloat typ = length(mod(p.zx, 0.2) - 0.1) - 0.04;\n\tfloat tzp = length(mod(p.xy, 0.2) - 0.1) - 0.04;\n    float t = 10000.0;\n\tt = min(tp0, t);\n\tt = min(tp1, t);\n\tt = max(-tx, t);\n\tt = max(-ty, t);\n\tt = max(-tz, t);\n    t = max(-txp, t);\n\tt = max(-typ, t);\n\tt = max(-tzp, t);\n    t = max(-txs, t);\n\tt = max(-tys, t);\n\tt = max(-tzs, t);\n    t = min(ts, t);\n\tt = max(-txp, t);\n\tt = max(-typ, t);\n\tt = max(-tzp, t);\n\tt = max(-tx, t);\n\tt = max(-ty, t);\n\tt = max(-tz, t);\n    return t;\n}\n\nvec3 getnormal(vec3 p){\n    float d = 0.001;\n        return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)) - map(p + vec3( -d, 0.0, 0.0)),\n        map(p + vec3(0.0,   d, 0.0)) - map(p + vec3(0.0,  -d, 0.0)),\n        map(p + vec3(0.0, 0.0,   d)) - map(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvec4 getcolor(vec2 uv, float z) {\n    uv.x += z;\n    float rad = 0.3;\n\t\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tvec3 pos = vec3(rad, rad, iTime * 3.0 + sin(iTime) * 2.0);\n    pos.xy = rot(pos.xy, iTime * 0.5);\n    dir.xz = rot(dir.xz, iTime * 0.2);\n    dir.yz = rot(dir.yz, iTime * 0.1);\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat temp = map(dir * t + pos);\n\t\tif(temp < 0.005) break;\n\t\tt += temp;\n\t}\n\tvec3 ip = dir * t + pos;\n\tvec3 V = normalize(-ip);\n\tvec3 N = getnormal(ip);\n\tvec3 L = normalize(vec3(3,4,-1));\n\tvec3 H = normalize(L + V);\n\tfloat Kd = max(dot(L, N), 0.0);\n\tfloat Ks = pow(max(dot(H, N), 0.0), 16.0);\n\tvec4 D = vec4(Kd) * vec4(1,0.3,0.3,1);\n\tvec4 S = vec4(Ks) * vec4(1,1,0.3,1);\n\tvec4 F = vec4(t * 0.1) * vec4(0.4,0.7,2,1);\n\treturn vec4((D + S + F).xyz + dir * 0.2, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float cod = mod(fragCoord.y, 2.0);\n    if(mod(fragCoord.x + cod, 2.0) > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy )  * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n\tfloat Z = 0.007;\n\tvec4 R = getcolor(uv, -Z);\n\tvec4 G = getcolor(uv, 0.0);\n\tvec4 B = getcolor(uv, Z);\n\tfragColor.x = R.x;\n\tfragColor.y = G.y;\n\tfragColor.z = B.z;\n\tfragColor.w = 1.0;\n\tfloat v = fragColor.x * 0.298912 + fragColor.y *  0.586611 + fragColor.z * 0.114478;\n\tfragColor.xyz *= mix(vec3(0.5,0.6,0.9), vec3(0.5,0.6,0.9).zyx, v);\n    fragColor.xyz *= clamp(fragColor.xyz, vec3(0.0), vec3(1.0));\n\tfragColor.xyz *= clamp(1.0 - dot(uv * 0.7, uv), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2cDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 108], [110, 110, 129, 129, 1091], [1093, 1093, 1116, 1116, 1384], [1386, 1386, 1419, 1419, 2192], [2194, 2194, 2251, 2251, 2954]], "test": "ok"}
{"id": "XdBcDt", "name": "Circle March", "author": "liamegan", "description": "Nothing new or groundbreaking, just a marching of circles. \n\nThanks for Book of Shaders - https://thebookofshaders.com/09/", "tags": ["2d", "circles"], "likes": 4, "viewed": 93, "published": "Public", "date": "1494268204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\nvec4 circle(in vec2 position, in vec2 uv, float size, vec3 color) {\n    \n    float dist = distance(position, uv); // The distance between the pixel and the circle position\n    \n    vec4 circ = vec4(0.0); // Creating a \"full\" color for the circle\n    circ.r = circ.g = circ.b = smoothstep(size, size + 0.01, dist); // Setting up the inverted circle rgb color\n    \n//   \tcirc.rgb -= vec3(1.0) - color; // Remove the color difference from the white\n    circ.rgb += color;\n\n    return circ;\n}\n\n// Courtesy Robert Penner\n// t: current time, b: begInnIng value, c: change In value, d: duration\nfloat easeOutElastic(in float t, in float b, in float c, in float d) {\n    float s=1.70158;\n    float p=0.0;\n    float a=c;\n    if (t==0.0) {\n    \treturn b;\n    }\n    if ((t/=d)==1.0) {\n        return b+c;\n    }\n    if (p == .0) {\n        p=d*.3;\n    }\n    if (a < abs(c)) {\n        a=c;\n        s=p/4.0;\n    } else {\n        s = p/(2.0*PI) * asin(c/a);\n    }\n    return a*pow(2.0,-10.0*t) * sin( (t*d-s)*(2.0*PI)/p ) + c + b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.4;\n    float time = iTime * speed;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float repeat = 4.0;\n    uv *= repeat;\n    float radius = 0.4;\n    \n    if( mod(floor(time), 2.0) == 0.0 ) {\n        float change = (-1.0 + mod(ceil(uv.y), 2.0) * 2.0);\n        uv.x += easeOutElastic(fract(time), .0, change, 1.0);\n    } else {\n        float change = (-1.0 + mod(ceil(uv.x), 2.0) * 2.0);\n        uv.y += easeOutElastic(fract(time), .0, change, 1.0);\n    }\n    \n    vec2 position = vec2(.5);\n\n    \n    fragColor = circle(position, fract(uv), radius, vec3(0.3, 0.3, 0.3));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdBcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 94, 94, 515], [517, 615, 685, 685, 1043], [1045, 1045, 1102, 1102, 1714]], "test": "ok"}
{"id": "XdByD3", "name": "Daily 2017-05-05", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 13, "viewed": 614, "published": "Public API", "date": "1493985495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831853\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat hlx(vec3 p){\n    float m=TAU/6.;\n    float a=mod(atan(p.y,p.x)-p.z+iTime,m)-.5*m;\n    float l=length(p.xy);\n    return length(vec2(a*l,length(p.xy)-1.))-.2;\n}\n\nfloat map(vec3 p){\n    p.xy*=rz2(iTime*.3);\n    p.yz*=rz2(iTime*.5);\n    p.xz*=rz2(iTime*.7);\n    float d=min(min(hlx(p.xyz), hlx(p.yzx)),hlx(p.zxy))*.5;\n    vec3 n=normalize(sign(p));\n    float d2=max(length(max(abs(p)-vec3(2.),0.)),dot(p,n)-2.3);\n    return min(d,d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(uv,sin(iTime)*2.-6.),rd=vec3(uv,1.),mp=ro;\n    for(int i=0;i<50;++i){\n        float md=map(mp);\n        if(md<.001)break;\n        mp+=rd*md;\n    }\n\tfragColor = vec4(length(mp-ro)*.08);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdByD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 87], [89, 89, 107, 107, 253], [255, 255, 273, 273, 527], [529, 529, 586, 586, 849]], "test": "ok"}
{"id": "XdfBD8", "name": "Grid non-AA using fract()", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/4tBGRz", "tags": ["grid"], "likes": 1, "viewed": 104, "published": "Public", "date": "1495804098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of https://www.shadertoy.com/view/4tBGRz\n\n// Why doesn't smoothstep induces AA in this case? Anyone know?\n\n#define N_TILES_Y 2.\n#define THICKNESS .04\n\nfloat draw_grid(vec2 st){\n  float tile_len = N_TILES_Y / iResolution.y;\n\n  // Why doesn't smoothstep induces AA in this case?\n  vec2 grid = smoothstep(.5 * tile_len, tile_len, fract(tile_len * st) - THICKNESS);\n  return min(grid.x, grid.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 st = 2. * fragCoord - iResolution.xy;  // Center (but don't normalize) pixel coordinates!\n\n  st *= 1. + sin(iTime);  // Zoom!\n  st = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * st;  // Rotate!\n\n  float grid = draw_grid(st);\n  fragColor.rgb = vec3(1. - grid);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 184, 184, 401], [403, 403, 457, 457, 737]], "test": "ok"}
{"id": "XdfBWH", "name": "honeycomb tessellation slice", "author": "ollj", "description": "Just making sure that I am getting this core concept of this 3d tessellation right.\n\nYou see a slice that goes \"up\" trough a Honeycomb-tesselation \n== tightly packed WHITE space filling balls that only touch diagonally\n\nhttps://www.shadertoy.com/view/XsXB", "tags": ["slice", "honeycomb", "tessellation"], "likes": 1, "viewed": 509, "published": "Public API", "date": "1495812280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//return 3d honeycomb, distance to closest \"white tile\" of checkerboard tiling\nfloat cells(vec3 p){p=fract(p/2.)*2.;p=min(p,2.-p );    \n return min(length(p),length(p-1.));}\n\nvoid mainImage( out vec4 O, in vec2 fragCoord){O=vec4(1);\n vec2 u = fragCoord.xy/iResolution.xy;\n u.x*=iResolution.x/iResolution.y;\n vec3 u3=vec3(u*9.,iTime+.5);\n float r=cells(u3);//distance to honeycomb center\n vec3 a=step(.5,fract(u3*.5-.25));//color coded 3d coordinates\n //r=fract(r*5.); \n r=smoothstep(-.01,.01,r-.875);\n a=a*.5+.5;//mix with 50% grey                        \n O.rgb=1.-a*r;\n}\n\n//how do i get distance to this tile border again?\n//i saw and copied this before...", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 99, 99, 173], [175, 175, 222, 222, 572]], "test": "ok"}
{"id": "XdfBzn", "name": "Box & spher", "author": "Rifeyka", "description": "random figure", "tags": ["3d", "beginner"], "likes": 0, "viewed": 382, "published": "Public API", "date": "1494493089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define QUALITES 100\n#define EPSILON 0.01\n#define Pi 3.141592653589793\n\n\nmat3 rotY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c, 0., s, 0., 1., 0., -s, 0., c);\n}\n\nmat3 rotX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1., 0., 0., 0., c, s, 0., -s, c);\n}\n\nfloat udBox( vec3 p, vec3 b ){\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k ){\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat M(vec3 a, float x){\n    float t = mod(iTime, 12.56);\n    float roubox = udRoundBox(rotY(t * x) * rotX(t) *  a,vec3(x), x / 15.);\n    float spher = sdSphere(a, (sin(iTime * 11.) / (10. / x )+ (1.666 * x))/*x * 1.6*/);\n    return max (roubox, -spher);\n}\n\nfloat M2(vec3 a, float x){\n    \n    float tor = sdTorus(rotX(iTime * x) * rotY(iTime) * a,vec2(x, x * (sin(iTime * 11.) + x * 1.5) / (5. / x ) * 0.1));\n    float spher = sdSphere(a, x);\n    return max (tor, -spher);\n}\n\nfloat wplane(vec3 a) {\n  return a.y + 4.0;\n}\n\nfloat world1(vec3 a) {\n    float minM = M(a, 2.0);\n    for(float x = 1.75; x >= 0.25; x -= 0.25)\n        minM = min(minM, M(a, x));\n    return min(minM, wplane(a));\n}\n\nfloat world2(vec3 a) {    \n    float minM = M2(a, 2.0);\n    for(float x = 1.75; x >= 0.25; x -= 0.25)\n        minM = min(minM, M2(a, x));\n    return min(minM, wplane(a));\n}\n\nvec3 wcolor(vec3 a) {\n    float x = 2.;\n    float minimum = M(a, x);\n    vec3 color = vec3(length (a) / sqrt(3.), 0.,  1. - length (a) / sqrt(3.));\n    for(float x = 1.75; x >= 0.25; x -= 0.25){\n        if (minimum > M(a, x)) {\n        \tminimum = M(a, x);\n            color =  vec3(length (a) / sqrt(3.), 0., 1. - length (a) / sqrt(3.));\n        }\n    }\n    if (minimum > wplane(a))\n        color = vec3(0.0, 1.0, 0.0);\n    color *= 1.5;\n    return color;\n}\n\nvec3 wnormal(vec3 a) {\n  vec2 e = vec2(EPSILON, 0.);\n  float w = world1(a);\n  return normalize(vec3(\n    world1(a+e.xyy) - w,\n    world1(a+e.yxy) - w,\n    world1(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D) {\n    float t = mod(iTime, Pi * 12.);\n\tfloat L = 0.;\n    float d1, d2;\n\tfor (int i = 0; i < QUALITES; ++i) {\n        if (t < Pi * 4.) {\n\t\t\td1 = world1(O + D*L);\n        } else {\n            if (t < Pi * 5.) {\n            \tfloat x = abs(sin(iTime * 0.5));\n                d1 = mix(world1(O + D*L), d1 = world2(O + D*L), x);\n        \t} else {\n            \tif (t < Pi * 11.) {\n        \t\t\td1 = world2(O + D*L);\n           \t\t} else {\n            \t\tfloat x = abs(sin(iTime * 0.5));\n            \t    d1 = mix(world1(O + D*L), d1 = world2(O + D*L), x);            \t   \n            \t}\n            }\n        }\n        //float x = sin(iTime * 0.5) / 3. + 0.33;\n\t\t//L += mix(d1, d2, x);\n        \n\t\tL += d1;\n\t\tif (d1 < EPSILON && d2 < EPSILON) break;\n\t}\n\treturn L;\n}\n\nfloat occlusion(vec3 at, vec3 normal) {\n  float b = 0.;\n  for (int i = 1; i <= 4; ++i) {\n    float L = .06 * float(i);\n    float d = world1(at + normal * L);\n    b += max(0., L - d);\n  }\n  return min(b, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 O =  vec3(0., 0., 9.);\n\tvec3 D = normalize(vec3(uv, -2.));\n    \n\tfloat path = trace(O, D);    \n    vec3 pos = O + D * path;\n    vec3 nor = wnormal(pos);\n\n    vec3 color = vec3(.9) * (1.0 - occlusion(pos, nor)) * wcolor(pos);\n\n    color = mix(color, vec3(1.0), smoothstep(0.,30.,path));\n\n    fragColor = vec4(color,1.);\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 94, 94, 180], [182, 182, 202, 202, 288], [290, 290, 320, 320, 358], [360, 360, 404, 404, 444], [446, 446, 480, 480, 504], [506, 506, 538, 538, 603], [605, 605, 645, 645, 723], [725, 725, 750, 750, 982], [984, 984, 1010, 1010, 1201], [1203, 1203, 1225, 1225, 1247], [1249, 1249, 1271, 1271, 1415], [1417, 1417, 1439, 1439, 1589], [1591, 1591, 1612, 1612, 2048], [2050, 2050, 2072, 2072, 2229], [2231, 2231, 2260, 2260, 3012], [3014, 3014, 3053, 3053, 3223], [3225, 3225, 3282, 3282, 3706]], "test": "ok"}
{"id": "XdffDn", "name": "Psy Matrix (Raymarching)", "author": "otiose", "description": "This one could make you feel a little dizzy.", "tags": ["raymarching"], "likes": 5, "viewed": 267, "published": "Public", "date": "1495554394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p){\n    //vec3 q = fract(p) * 2.0 - 1.0;\n    float r = 1.0 * (sin(iTime) + 3.0);\n    vec3 q = mod(p,r)-0.5*r;\n    \n    vec3 c = vec3(0.0, 0.0, 0.05);\n    \n\treturn min(min(min(length(q) - (1.1 + sin(iTime + length(p * 0.4) * 2.0)) * 0.25, length(q.xz-c.xy)-c.z), length(q.xy-c.xy)-c.z), length(q.yz-c.xy)-c.z);\n}\n\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 30; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.8;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float fov = 2.0 * (sin(iTime)+2.0);\n    \n    uv = uv * fov - fov / 2.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,  1.0));\n    \n    float the =  0.2 * iTime;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0, iTime* 0.5, -3.0 - iTime);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    if(fog < 0.3)fog *= 2.0 * (1.5 + sin(iTime * 0.2));\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fog * uv.x, fog, fog * uv.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdffDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 55, 326], [328, 328, 356, 356, 503], [505, 505, 562, 562, 1217]], "test": "ok"}
{"id": "XdffR7", "name": "Checkerboard Spin", "author": "DonKarlssonSan", "description": "Chekcers", "tags": ["checkers"], "likes": 1, "viewed": 114, "published": "Public", "date": "1495227824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x * rotate(iTime / 3.0);\n    /*\n    bool x = mod(uv.x, 0.1) < 0.05;\n    bool y = mod(uv.y, 0.1) < 0.05;\n    bool c = x != y;\n*/\n    float x = mod(uv.x, 0.1);\n    float y = mod(uv.y, 0.1);\n    //float c = mix(x, y, 0.5);\n    float xx = smoothstep(0.029, 0.031, x) * (1.0 - smoothstep(0.079, 0.081, x));\n    float yy = smoothstep(0.029, 0.031, y) * (1.0 - smoothstep(0.079, 0.081, y));\n\n    float c = mix(xx, yy, 0.5);\n    \n    \n    vec3 col = vec3(c);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdffR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 71], [73, 73, 128, 128, 672]], "test": "ok"}
{"id": "XdjcDd", "name": "Pretty Grid", "author": "TimoKinnunen", "description": "Base 10 grid with zoom for e.g. as a background for 2D graphing, distance field estimation or as planar procedural background. ", "tags": ["2d", "grid", "zoom", "gradient"], "likes": 7, "viewed": 639, "published": "Public API", "date": "1494408611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n//\n// Pretty Grid by Timo Kinnunen 2017\n//\n// Drag up/down to zoom.\n//\n// Based loosely on distance meter by cupe\n// @ https://www.shadertoy.com/view/ldK3zD\n//\n// This shader is licensed under\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License \n// [ http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US ].\n//\n\n//#define MINUS\n\nconst float TAU = 2.* 3.1415926535897932384626433832795;\nconst float grid4 = 2097152.0,grid3 = 131072.0,grid2 = 1024.0,grid1 = 64.0;\n\nvec4 grid(vec2 f, vec3 pos, float rdy, float t) {\n    float ff = min(iResolution.x,iResolution.y)/1024.0;\n\tvec4 distances = (abs(pos.xz)* TAU).xxyy;\n\tfloat referenceBase = log(20.*ff/ (t* pow(abs(rdy),.8)))/ log(10.);\n\tfloat nearestBase = floor(referenceBase);\n\tfloat partialBase = fract(referenceBase);\n\tconst vec4 gain = vec4(grid4- grid3,grid1,grid3- grid2,grid2- grid1);\n\tconst vec4 off = vec4(grid3,0,grid2,grid1);\n\tvec4 exponentialBase = partialBase* partialBase* gain+ off;\n\tvec4 bases = pow(vec4(10),nearestBase+ vec4(-2,1,-1,0));\n\tvec4 lx = pow(.5+ .5* cos(distances* bases.xyxy),exponentialBase.xyxy);\n\tvec4 ly = pow(.5+ .5* cos(distances* bases.zwzw),exponentialBase.zwzw);\n\tvec4 l4 = (1.- lx* vec4(1.- partialBase,partialBase,1.- partialBase,partialBase))* (1.- ly);\n\tvec2 l2 = l4.xy* l4.zw;\n\tfloat l1 = .30078125* (1.- l2.x* l2.y);\n#ifdef MINUS\n    l1 = -l1;\n#endif\n\treturn vec4(vec3(f.x/ iResolution.x,.5,f.y/ iResolution.y)+ l1,1);\n}\nvec4 mainImageGrid(vec2 f) {\n\tfloat rcpResY = 1./ iResolution.y;\n\tvec2 uv = 2.0* rcpResY* f- vec2(iResolution.x* rcpResY,1);\n\tvec3 ro = vec3(0,exp2(128.* (sin(iTime* .002)+ step(10.,iMouse.x)*(2.* rcpResY* iMouse.y- 1.))),0);\n\tvec3 rd = normalize(vec3(uv.x,-1,uv.y));\n\tfloat t = ro.y/ -rd.y;\n\tvec3 pos = ro+ t* rd;\n\treturn grid(f,pos,rd.y,t);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tfragColor = mainImageGrid(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdjcDd.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[528, 528, 577, 577, 1476], [1477, 1477, 1505, 1505, 1821], [1822, 1822, 1874, 1874, 1915]], "test": "ok"}
{"id": "XdjyWd", "name": "Fake sphere planet lighting", "author": "thecodewarrior", "description": "SPREAD is a bias to make the light extend farther across the surface\nORBIT is the radius of the orbit\nSCALE is the scale of the planet\nCOLOR is the color of the planet\nBG is the color of the background", "tags": ["2d", "lighting", "sphere", "planet", "fragment"], "likes": 0, "viewed": 461, "published": "Public API", "date": "1494376981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPREAD 0.2\n#define ORBIT 0.5\n#define PLANET_SIZE 0.1\n#define RING_BEGIN 0.025\n#define RING_THICKNESS 0.1\n#define SUN_INTENSITY 1.0\n#define MOUSE_INTENSITY 1.0/toMouseDist\n\n#define PLANET_COLOR vec4(0, 1, 0, 1)\n#define RING_COLOR vec4(0, 0, 1, 1)\n#define BACKGROUND_COLOR vec4(1, 0, 0, 1)\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat length2(vec2 v) {\n    return dot(v, v);\n}\n\nfloat length2(vec3 v) {\n    return dot(v, v);\n}\n\n// lighting calculation. +SPREAD biases it so the light will fade out farther from\n// the centerline.\nfloat lightSphere(float existing, vec3 surfaceNormal, vec3 lightNormal, float intensity) {\n    float b = dot( surfaceNormal, -lightNormal )+SPREAD;\n    b *= intensity;\n    return clamp( max(existing, b + existing/2.0), 0.0, 1.0);\n}\n\nfloat lightRings(float existing, vec2 ringPos, vec2 lightNormal, float intensity) {\n    float d = distanceToSegment(vec2(0, 0), lightNormal*10.0, ringPos) / PLANET_SIZE;\n    float b = smoothstep(.8,1.0, d)*0.8*intensity;\n    return clamp( max(existing, b + existing/2.0), 0.0, 1.0);\n}\n\n// make screen coordinates reasonable\nvec2 normalizeScreenCoords(vec2 screenCoords) {\n    vec2 coords = (2.0*(screenCoords / iResolution.xy)) - 1.0;\n    coords.x = coords.x * (iResolution.x / iResolution.y);\n\treturn coords;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = vec3(sin(iTime), cos(iTime), 0); // light direction\n    \n    // normalise coordinates\n    vec2 fragUV = normalizeScreenCoords(fragCoord.xy);\n    \n    // center of circle\n    vec2 center = light.xy * ORBIT;\n    \n    vec2 posRelCircle = fragUV - center;\n    \n    float d2 = dot(posRelCircle, posRelCircle); // distance from center squared\n    \n    if(d2 <= PLANET_SIZE*PLANET_SIZE) {\n        posRelCircle = posRelCircle / PLANET_SIZE;\n        float len = length(posRelCircle); // distance from center\n    \n    \tvec3 normal = normalize(vec3(posRelCircle, cos(len))); // horizontal components + vertical component\n    \n        float lightMultiplier = 0.0;\n        \n        lightMultiplier = lightSphere(lightMultiplier, normal, light, SUN_INTENSITY);\n        \n        if(iMouse.z > 0.0) {\n            vec2 toMouseVec = normalizeScreenCoords(iMouse.xy)-center;\n            float toMouseDist = length(toMouseVec);\n            vec2 mouseNormal = -normalize(toMouseVec);\n            \n            float intensity = MOUSE_INTENSITY;\n            \n        \tlightMultiplier = lightSphere(lightMultiplier, normal, vec3(mouseNormal, 0), intensity);\n        }\n        \n        lightMultiplier = clamp(lightMultiplier, 0.0, 1.0);\n\t\tfragColor = PLANET_COLOR * lightMultiplier;\n    } else if(d2 > (PLANET_SIZE+RING_BEGIN)*(PLANET_SIZE+RING_BEGIN) &&\n         d2 < (PLANET_SIZE+RING_BEGIN+RING_THICKNESS)*(PLANET_SIZE+RING_BEGIN+RING_THICKNESS)) {\n        float lightMultiplier = 0.0;\n        \n        lightMultiplier = lightRings(lightMultiplier, posRelCircle, light.xy, SUN_INTENSITY);\n        \n        if(iMouse.z > 0.0) {\n            vec2 toMouseVec = normalizeScreenCoords(iMouse.xy)-center;\n            float toMouseDist = length(toMouseVec);\n            vec2 mouseNormal = -normalize(toMouseVec);\n            \n            float intensity = MOUSE_INTENSITY;\n            \n        \tlightMultiplier = lightRings(lightMultiplier, posRelCircle, mouseNormal, intensity);\n        }\n        \n        lightMultiplier = clamp(lightMultiplier, 0.0, 1.0);\n        \n        fragColor = RING_COLOR * lightMultiplier;\n    } else {\n        fragColor = BACKGROUND_COLOR;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdjyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 348, 348, 462], [464, 464, 487, 487, 511], [513, 513, 536, 536, 560], [562, 664, 754, 754, 895], [897, 897, 980, 980, 1181], [1183, 1221, 1268, 1268, 1408], [1410, 1410, 1467, 1467, 3632]], "test": "ok"}
{"id": "XdjyWV", "name": "Honey", "author": "leon", "description": "Miam", "tags": ["2d", "sound"], "likes": 8, "viewed": 255, "published": "Public", "date": "1493852886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Honey from Leon\n\n// music from: https://soundcloud.com/sofoclemusic/milk-honey\n\n// text\n#define grid 16.\n#define cell 1./16.\nconst int kA=177,kB=178,kC=179,kD=180,kE=181,kF=182,kG=183,kH=184,kI=185,kJ=186,kK=187;\nconst int kL=188,kM=189,kN=190,kO=191,kP=160,kQ=161,kR=162,kS=163,kT=164,kU=165,kV=166;\nconst int kW=167,kX=168,kY=169,kZ=170,kSpace=80;\n\nvec2 getSymbol (int key)\n{\n\treturn vec2(mod(float(key),grid),floor(float(key)/grid));\n}\n\nvec2 getLetterUV (vec2 target, vec2 offset)\n{\n    vec2 uvLetter = target;\n    uvLetter.x = uvLetter.x * 0.45 + 0.017;\n    uvLetter += offset / grid;\n    float crop = step(target.x, cell) * step(target.y, cell);\n    crop *= step(0., target.x) * step(0., target.y);\n    return uvLetter * crop;\n}\n\nfloat getText (vec2 target)\n{\n    int symbols[] = int[] ( kH,kO,kN,kE,kY );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return texture(iChannel1, textUV).r;\n}\n\nfloat signal (vec2 uv, float thin, float freq1, float freq2)\n{\n    const float height = 0.2;\n    uv.y += sin(uv.x*freq1+iTime)*0.2;\n    return abs(thin/(sin(uv.x*freq2-iTime)-uv.y/height));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    float unit = 1./iResolution.y;\n    vec2 uv = 2.*(fragCoord-.5*iResolution.xy)*unit;\n    float time = iTime;\n    vec3 honey = vec3(0.9, 0.45, 0.2);\n    vec3 light = vec3(1.,0.9,0.8);\n    \n    float thin = .5;\n    float freq1 = 4.;\n    float freq2 = 3.;\n    vec2 prev = vec2(uv.x-unit, signal(uv-vec2(unit,0), thin, freq1, freq2));\n    vec2 next = vec2(uv.x+unit, signal(uv+vec2(unit,0), thin, freq1, freq2));\n    vec2 tangent = normalize(next - prev);\n    vec2 normal = vec2(tangent.y, -tangent.x);\n    vec2 soundUV = vec2(abs(atan(normal.y, normal.x)/3.1459),0.);\n    float bounce = texture(iChannel0, soundUV).r;\n    freq1 = 4.+bounce*4.;\n    \n    vec2 uvText = (fragCoord-.5*iResolution.xy)*unit;\n    uvText *= 0.1*vec2(2,1);\n    vec2 uvTexture = 0.8*fragCoord/iResolution.xy;\n    float lum = texture(iChannel2, uvTexture).r;\n    float angle = lum * 3.14159 * 2. + time;\n    vec2 offset = vec2(cos(angle), sin(angle));\n    uv += offset*0.2*getText(uvText);\n    \n    uv.xy += normal * sin(uv.y*3.);\n    float plotter1 = signal(uv, thin, freq1, freq2);\n    float shade = 0.5+0.5*dot(normal, normalize(vec2(uv.x,plotter1)-(prev+next)/2.));\n        \n    thin = .25;\n    freq1 = 4.+bounce*10.;\n    freq2 = 8.+sin(time);\n    float plotter2 = signal(uv, thin, freq1, freq2);\n    \n    color = mix(color, honey, clamp(plotter1,0.,1.));\n    color = mix(color, honey, shade);\n    color = mix(color, light, clamp(plotter2,0.,1.));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "4dlXzr", "previewfilepath": "https://soundcloud.com/sofoclemusic/milk-honey", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sofoclemusic/milk-honey", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdjyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 380, 380, 441], [443, 443, 488, 488, 736], [1170, 1170, 1232, 1232, 1361], [1365, 1365, 1422, 1422, 2910]], "test": "error"}
{"id": "XdlBDH", "name": "Mandelbulb + Zoom", "author": "sixstring982", "description": "Control camera with the mouse.", "tags": ["fractal", "mouse"], "likes": 3, "viewed": 171, "published": "Public", "date": "1496006952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CAMERA_DIST (0.7 + 2.0 * iMouse.x / iResolution.x)\n#define CAMERA_Y ((-iMouse.y / iResolution.y + 0.5) * 5.0)\n\n#define MARCH_DIST (sqrt(CAMERA_Y * CAMERA_Y + 2.0 * CAMERA_DIST * CAMERA_DIST))\n\n#define INFTY 1e20\n#define MARCH_ITERS 700\n#define MAX_RAY_DIST 100.0\n#define MARCH_EPSILON (0.0001 + 0.0001 * pow(MARCH_DIST, 3.0))\n#define MBULB_ITERS 100\n#define MBULB_BAILOUT 2.0\n#define MBROT_POW 8.0\n\n#define TAU 6.283185\n\nfloat mbulb(in vec3 p) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < MBULB_ITERS; i++) {\n        r = length(z);\n        if (r > MBULB_BAILOUT) {\n            break;\n        }\n        \n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr = pow(r, MBROT_POW - 1.0) * MBROT_POW * dr + 1.0;\n        \n        float zr = pow(r, MBROT_POW);\n        theta *= MBROT_POW;\n        phi *= MBROT_POW;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n\nfloat sdSphere(in vec3 p, in float s) {\n    return length(p) - s;\n}\n\nfloat map(in vec3 p) {\n    return mbulb(p);\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n    float dist = INFTY;\n    float totalDist = 0.0;\n    for (int i = 0; i < MARCH_ITERS; i++) {\n        if (totalDist > MAX_RAY_DIST\n            || dist < MARCH_EPSILON) {\n            break;\n        }\n        \n        dist = map(ro);\n        totalDist += dist;\n        ro += dist * rd;\n    }\n    \n    if (dist < MARCH_EPSILON) {\n        return totalDist;\n    }\n    return INFTY;\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 EV = vec2(MARCH_EPSILON, 0.0);\n    return normalize(vec3(map(ro + EV.xyy) - map(ro - EV.xyy),\n                          map(ro + EV.yxy) - map(ro - EV.yxy),\n                          map(ro + EV.yyx) - map(ro - EV.yyx)));\n}\n\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.0;\n    float delta = 0.5;\n    for (float i = 1.0; i <= 5.0; i++) {\n        float c = (1.0 / pow(2.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += clamp(c, 0.0, 1.0);\n    }\n    \n    return 1.0 - k * s;\n}\n\n#define COLOR_MAP_INDEX 2\nmat4 COLOR_MAPS[] = mat4[3](\n  mat4(0.5, 0.5, 1.0, 0.00,\n       0.5, 0.5, 1.0, 0.33,\n       0.5, 0.5, 1.0, 0.66,\n       0.0, 0.0, 0.0, 0.00),\n  mat4(0.5, 0.5, 1.0, 0.30,\n       0.5, 0.5, 1.0, 0.20,\n       0.5, 0.5, 1.0, 0.20,\n       0.0, 0.0, 0.0, 0.00),\n  mat4(0.5, 0.5, 1.0, 0.00,\n       0.5, 0.5, 1.0, 0.10,\n       0.5, 0.5, 1.0, 0.20,\n       0.0, 0.0, 0.0, 0.00)\n);\nvec3 colorAt(vec3 p) {\n    float x = length(p);\n    mat4 cmap = COLOR_MAPS[COLOR_MAP_INDEX];\n    \n    return vec3(\n        cmap[0][0] + cmap[0][1] * cos(TAU * (cmap[0][2] * x + cmap[0][3])),\n        cmap[1][0] + cmap[1][1] * cos(TAU * (cmap[1][2] * x + cmap[1][3])),\n        cmap[2][0] + cmap[2][1] * cos(TAU * (cmap[2][2] * x + cmap[2][3])));\n}\n\n#define LIGHT_COUNT 1\nvec3 getLight(in int index) {\n    if (index == 0) {\n        return vec3(0, 5.0, 0);\n    }\n    return vec3(5.0, 0, 0);\n}\n\n#define SPECULAR_POW 8.0\nvec3 lighting(in vec3 ro, in vec3 rd, float dist) {\n    vec3 n = normalAt(ro);\n    vec3 V = -rd;\n    float diffuse = 0.0;\n    float specular = 0.0;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n        vec3 lp = getLight(i);\n        vec3 L = normalize(lp - ro);\n        vec3 R = reflect(-L, n);\n        float dist = length(ro - lp);\n        float intensity = 100.0 / (dist * dist);\n        \n        float shadow = march(lp, -L);\n        if (length((-L * shadow) - ro) < MARCH_EPSILON) {\n            break; // No hit, no lighting.\n        }\n        \n        diffuse = clamp(diffuse + intensity * max(0.0, dot(L, n)), 0.0, 1.0);\n        specular = clamp(specular + intensity * max(0.0, pow(dot(R, V), 8.0)), 0.0, 1.0);\n    }\n    \n    return colorAt(ro)\n         * vec3(diffuse + specular)\n         * occlusion(ro, n, 1.0);\n}\n\n#define CAMERA_SPEED 0.1\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = vec3(sin(iTime * CAMERA_SPEED) * CAMERA_DIST,\n              (-iMouse.y / iResolution.y + 0.5) * 5.0,\n              cos(iTime * CAMERA_SPEED) * CAMERA_DIST);\n    vec3 target = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    \n    vec3 cameraDir = normalize(target - ro);\n    vec3 cameraRight = cross(cameraDir, up);\n    vec3 cameraUp = cross(cameraRight, cameraDir);\n    \n    rd = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd;\n    setupCamera(uv, ro, rd);\n    float dist = march(ro, rd);\n    if (dist == INFTY) {\n        fragColor = vec4(.459, .69, .584, 1.0);\n    } else {\n        fragColor = vec4(lighting(ro + rd * dist, rd, dist), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 429, 453, 453, 1020], [1023, 1023, 1062, 1062, 1090], [1092, 1092, 1114, 1114, 1137], [1139, 1139, 1176, 1176, 1556], [1558, 1558, 1585, 1585, 1818], [1820, 1820, 1871, 1871, 2139], [2537, 2537, 2559, 2559, 2882], [2906, 2906, 2935, 2935, 3025], [3052, 3052, 3103, 3103, 3877], [3904, 3904, 3960, 3960, 4405], [4407, 4407, 4464, 4464, 4815]], "test": "error"}
{"id": "XdlBWN", "name": "fake water caustics v2", "author": "Emil", "description": "second attempt at doing fake under water caustics", "tags": ["2d", "water", "caustics"], "likes": 14, "viewed": 392, "published": "Public", "date": "1496239397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float timeSpeed = 2.0;\n\nfloat randomVal (float inVal)\n{\n    return fract(sin(dot(vec2(inVal, 2523.2361) ,vec2(12.9898,78.233))) * 43758.5453)-0.5;\n}\n\nvec2 randomVec2 (float inVal)\n{\n    return normalize(vec2(randomVal(inVal), randomVal(inVal+151.523)));\n}\n\nfloat makeWaves(vec2 uv, float theTime, float offset)\n{\n    float result = 0.0;\n    float direction = 0.0;\n    float sineWave = 0.0;\n    vec2 randVec = vec2(1.0,0.0);\n    float i;\n    for(int n = 0; n < 16; n++)\n    {\n        i = float(n)+offset;\n        randVec = randomVec2(float(i));\n  \t\tdirection = (uv.x*randVec.x+uv.y*randVec.y);\n        sineWave = sin(direction*randomVal(i+1.6516)+theTime*timeSpeed);\n        sineWave = smoothstep(0.0,1.0,sineWave);\n    \tresult += randomVal(i+123.0)*sineWave;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    \n    vec2 uv2 = uv * 150.0; // scale\n    \n    uv *= 2.0;\n    \n    float result = 0.0;\n    float result2 = 0.0;\n    \n    result = makeWaves( uv2, iTime, 0.1);\n    result2 = makeWaves( uv2, iTime*0.8+0.06, 0.26);\n    \n    //result *= 2.6;\n    \n    result = smoothstep(0.8,1.0,1.0-abs(result));\n    result2 = smoothstep(0.8,1.0,1.0-abs(result2));\n    \n    result = smoothstep(0.0,1.0,(result+result2)*0.5);\n    \n\tfragColor = vec4(result)*0.7+texture( iChannel0 , uv );\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 55, 55, 148], [150, 150, 181, 181, 255], [257, 257, 312, 312, 785], [787, 787, 844, 844, 1357]], "test": "error"}
{"id": "XdlBz4", "name": "8/100", "author": "yahe", "description": "8/100", "tags": ["voronoi"], "likes": 0, "viewed": 445, "published": "Public API", "date": "1495069776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// use voronoi function from iq \n\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o )/2.;\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xx;\n\n    vec3 c = voronoi( 3.0*uv + ( sin(iTime)/2. +.5) );\n\n    c = c*c*1.5;\n    vec3 col = vec3(c.x*3., c.y*c.x, c.y);\n    col = mix( vec3(sin(iTime)+.3,sin(iTime)+.6,.9), col, 0.5 );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 146, 146, 239], [241, 241, 268, 268, 1370], [1372, 1372, 1429, 1429, 1689]], "test": "ok"}
{"id": "XdsBRN", "name": "Dancing Ballz 2", "author": "Zacland", "description": "version Jonathan + mes bidouilles :p", "tags": ["sound", "ball"], "likes": 3, "viewed": 85, "published": "Public", "date": "1495108907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rz2(float a) {\n    float c = cos(a); \n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat map(vec3 p) {\n    p.xy *= rz2(iTime * .3);\n    p.yz *= rz2(iTime * .4);\n    \n    float freq = texture(iChannel0, vec2(.02, .25)).r;\n    p = mod(p + 1., 2.) - 1.;\n    return length(p) - (.1 + .4*freq); // (mod(freq, .4) + .2) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0.,0.,3.4);\n    vec3 rd=normalize(vec3(uv, -1.));\n    \n    vec3 mp=ro;\n    for (int i=0; i<50; ++i) {\n     \tfloat md = map(mp);\n        if (md < .0001) break;\n        mp += rd * md;\n    }\n    \n    fragColor = vec4(length(mp - ro) * 0.1);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 96], [98, 98, 117, 117, 332], [334, 334, 391, 391, 747]], "test": "error"}
{"id": "XdsBz4", "name": "everyday 009/100", "author": "kalin", "description": "everyday 9/100", "tags": ["everyday"], "likes": 1, "viewed": 100, "published": "Public", "date": "1495082933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    \n    float ttx = abs(nuv.x * 0.5);\n    float tt = texture(iChannel0, vec2(ttx, 0.25)).x;\n    float ttf = max(pow(tt, 2.0) - 0.15, 0.0);\n    \n    float ttfinal = ttf * abs(nuv.y * 0.5) * step(0.0 - nuv.y, 0.0);\n    \n    float t = iTime;\n\n    float ground = step(nuv.y + 0.3 + sin(uv.x * 14.0 + 0.3 * t) * 0.02, 0.0);\n    float iground = 1.0 - ground;\n\n    vec2 groundUV = vec2(sin(uv.x * 14.0 + 0.3 * t) * 0.02, uv.y);\n    vec3 groundColor = vec3(0.9, 0.8, 0.3) * max(pow(uv.y * 12.0, 0.15) * 1.0, 0.5);\n    vec3 groundNoiseColor = vec3(1, 0, 0);\n    vec2 groundNoiseUV = vec2(mod(t * 0.8 + uv.x, 1.0), mod(t * 2.2 + uv.y, 0.2));\n    vec3 groundNoise = texture(iChannel1, groundNoiseUV).xyz;\n    \n    groundNoise.x = pow(groundNoise.x - 0.1, 12.0);\n    \n    vec3 bg = vec3(0.2, 0.2, 0.4);\n\n    fragColor.xyz = bg * iground;\n    fragColor.xyz += vec3(ttfinal) * vec3(3.0, 2.0, 0.0) * pow((uv.y + 0.5) * 1.6, 4.0) * (uv.y * 0.1);\n    \n    fragColor.xyz += ground * groundColor;\n   \n    //fragColor.xyz += vec3(0,5.0,0) * iground * groundNoise.x;\n    //fragColor.xyz += vec3(1,1,1) * ground * groundNoise.x;\n    fragColor.xyz += vec3(1,1,1) * iground * 0.2 * ttf;\n    if (iground > 0.9)\n    fragColor.xyz += vec3(11,11,222) * groundNoise.x * (0.1 + 0.2 * ttf) * iground;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "lssSz4", "previewfilepath": "https://soundcloud.com/emeenz/wishy-washy", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/emeenz/wishy-washy", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1403]], "test": "error"}
{"id": "XdsBzN", "name": "test clover", "author": "Zacland", "description": "clover from Iq youtube video :D (Thx)\n\nhttps://www.youtube.com/watch?v=-z8zLVFCJv4", "tags": ["2d", "clover"], "likes": 2, "viewed": 76, "published": "Public", "date": "1495182326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // RGBA\n    vec4 color = vec4(0.5, 1.0, 0.5, 1.0);\n    // color.gr = vec2(0.1, 0.5);\n    \n    // pixel position\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    \n    //color.r = pixel.y;\n    \n    // center origin point \n    pixel = (pixel - 0.5) * 2.0;\n    \n    // aspect ratio\n    pixel.x *= iResolution.x / iResolution.y;\n    \n    // time elapsed\n    float time = iTime;\n    \n    //pixel -= vec2(.5, 0.);\n    \n    // trèfle\n    float r = sqrt(dot(pixel, pixel));\n    float a = atan(pixel.y, pixel.x) + time * 0.1;\n    float s = 0.5 + 0.5 * sin(3.0 * a);\n    float t = 0.15 + 0.35 * pow(s, 0.3);\n    t += 0.1 * pow(0.5 + 0.5 * cos(6.0 * a), 0.5);\n    float h = r/t;\n    float f = 0.0;\n   \n    if(h < 1.0) f = 1.0;\n    \n    color.rgb = mix(vec3(1.0), vec3(0.5 * h, 0.5 + 0.5 * h, 0.0), f);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdsBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 69, 879]], "test": "ok"}
{"id": "XdScDt", "name": "Circle Thing, Circling", "author": "DonKarlssonSan", "description": "c", "tags": ["circle"], "likes": 0, "viewed": 72, "published": "Public", "date": "1494267052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = cos(iTime);\n    float y = sin(iTime);\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x += x;\n    p.y += y;\n\tfloat radius = sqrt(p.x * p.x + p.y * p.y); \n\tfragColor = vec4(radius*0.5, 0.3*radius, 1.0-radius, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdScDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 302]], "test": "ok"}
{"id": "XdSyDV", "name": "BaseCase", "author": "BaseCase", "description": "just learning!", "tags": ["learning"], "likes": 0, "viewed": 63, "published": "Public", "date": "1493765871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat plot(vec2 pos) {\n    float threshhold = 0.02;\n    float PI = 3.14159;\n\n    float y = (sin(pos.x*2.0*PI + iTime*2.0) / 2.0) + 0.5;\n\n    return smoothstep(0.0, threshhold, abs(y - pos.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    float multiplier = 1.0;\n    \n    vec3 line_color = vec3(0.0, 0.0, 0.0);\n    \n\tvec2 pos = fragCoord / iResolution.xy;    \n    float scaled_y = pos.y;\n\n    multiplier = plot(pos);\n    \n    vec3 fade_color = multiplier * vec3(r, scaled_y, b);    \n    vec3 color = fade_color + line_color;\n    \n\tfragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdSyDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 195], [198, 198, 255, 255, 640]], "test": "ok"}
{"id": "XdXBDH", "name": "Parametrized curves", "author": "sheepmaster", "description": "Parametrized multiharmonic curves. Similar to Lissajous curves (https://en.wikipedia.org/wiki/Lissajous_curve), but with an additional cyclic factor.\n\nSegment-based approximation from https://www.shadertoy.com/view/XdSGzh.", "tags": ["2d", "oscilloscope", "rainbow", "parametrized"], "likes": 23, "viewed": 834, "published": "Public API", "date": "1495921002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PERIOD = 3.5;\n\nconst float RADIUS = 0.8;\n\nconst float LINE_WIDTH = 3.;\n\nconst int NUM_LINE_SEGMENTS = 50;\nconst int NUM_NEWTON_ITERATIONS = 0;\n\nconst int TILE_MIN = -5;\nconst int TILE_MAX = 5;\n\nconst float PI = 4. * atan(1.);\n\n// Smooth HSV to RGB conversion \n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(float hue, float saturation, float value) {\n    vec3 rgb = clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);  // Cubic smoothing\t\n\n\treturn value * mix(vec3(1.0), rgb, saturation);\n}\n\nvec2 curve(float t, float a, float b, float d) {\n\treturn vec2(\n        sin(a * t + d) * cos(t + d),\n        cos(b * t)     * sin(t + d)\n    );\n}\n\nvec2 curvePrime(float t, float a, float b, float d) {\n    return vec2(\n        a * cos(a * t + d) * cos(t + d) -     sin(a * t + d) * sin(t + d),\n            cos(b * t)     * cos(t + d) - b * sin(b * t)     * sin(t + d)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const int numTiles = TILE_MAX - TILE_MIN + 1;\n    \n    float minRes = min(iResolution.x, iResolution.y);\n    float scale = float(numTiles) / minRes;\n\n    ivec2 tileCoord = ivec2(round((fragCoord - iResolution.xy / 2.) * scale));\n\n\tvec2 uv = 2. * fragCoord * scale - 2. * vec2(tileCoord) - iResolution.xy * scale;\n    \n    // Flip tiles with positive a Y coordinate for symmetry.\n    if (tileCoord.y > 0) {\n        uv.y = -uv.y;\n    }\n\n\tfloat d = (iMouse.w > 0. ? iMouse.y / iResolution.y : iTime / PERIOD) * 2. * PI;\n    float hueOffset = (iMouse.w > 0. ? 4. * iMouse.x / iResolution.x : 0.);\n\n    // If the tile coordinates have different parity,\n    // only half of the period is needed.\n    bool halfPeriod = abs((tileCoord.x * tileCoord.y) % 2) == 1;\n\tfloat tPeriod = halfPeriod ? PI : 2. * PI;\n    vec2 p1 = curve(0., float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n\tfloat minDist = 1.0;\n    float minT;\n    float t;\n    int numSteps = halfPeriod ? NUM_LINE_SEGMENTS : 2 * NUM_LINE_SEGMENTS;\n    for (int i = 1; i <= numSteps; i++) {\n        t = float(i) / float(numSteps) * tPeriod;\n        vec2 p2 = curve(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n\n\t\t// Distance to line\n        vec2 pa = uv - p2;\n        vec2 ba = p1 - p2;\n\n        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n        vec2 q = pa - ba * h;\n\n        float dist = dot(q, q);\n        if (dist < minDist) {\n            minDist = dist;\n            minT = (float(i) - h) / float(numSteps) * tPeriod;\n        }\n        p1 = p2;\n    }\n    \n    t = minT;\n    // TODO: This doesn't work well yet\n    for (int i = 0; i < NUM_NEWTON_ITERATIONS; i++) {\n        vec2 p = curve(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n        vec2 pPrime = curvePrime(t, float(tileCoord.x), float(tileCoord.y), d) * RADIUS;\n        vec2 uvp = uv - p;\n        float h = dot(uvp, pPrime) / dot(pPrime, pPrime);\n        t += h;\n        vec2 q = uv - (p + pPrime * h);\n        minDist = dot(q, q);\n    }\n\n    float hue = fract(hueOffset + t / tPeriod);\n//    float dist = length(curve(hue * tPeriod, float(tileCoord.x), float(tileCoord.y), d) * RADIUS - uv);\n    \n\tfloat v = smoothstep(LINE_WIDTH * scale, 0.0, sqrt(minDist));\t\n\tfragColor = vec4(hsv2rgb_smooth(hue, 1., v), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 313, 376, 376, 561], [563, 563, 611, 611, 707], [709, 709, 762, 762, 937]], "test": "error"}
{"id": "XdXBRH", "name": "Noise - Gradient - 2D - Deriv", "author": "iq", "description": "Analytic derivatives for 2D Gradient Noise ([url]https://www.shadertoy.com/view/XdXGW8[/url])", "tags": ["procedural", "2d", "noise", "perlin", "analytic"], "likes": 56, "viewed": 9951, "published": "Public API", "date": "1494745317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Computes the analytic derivatives of a 2D Gradient Noise\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 n = noised( 8.0*p + iTime*4.0 );\n\n    vec3 col = 0.5 + 0.5*((p.x>0.0) ? n.yzx : n.xxx);\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBRH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1940, 1940, 2001, 2001, 2139], [2142, 2202, 2228, 2228, 3094], [3148, 3148, 3205, 3205, 3404]], "test": "ok"}
{"id": "XdXfRr", "name": "Shepards IDW", "author": "tjlaxs", "description": "Trying to pretend to have a Shepards IDW", "tags": ["idw"], "likes": 2, "viewed": 399, "published": "Public API", "date": "1494529767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 u_samples[] = vec3[](\n    vec3(0.1, 0.1, 17.0),\n    vec3(0.9, 0.5, 13.0),\n    vec3(0.7, 0.3, 9.0),\n    vec3(0.1, 0.9, 19.0),\n    vec3(0.4, 0.2, 9.0),\n    vec3(0.3, 0.5, 29.0),\n    vec3(0.4, 0.4, 39.0),\n    vec3(0.5, 0.7, 12.0)\n);\n\nfloat w_i(vec2 x_i, vec2 x, float p) {\n    return 1.0 / pow(distance(x, x_i), p);\n}\n\nfloat u(vec2 x, float p) {\n    for(int i = 0; i < u_samples.length(); i++) {\n        if(distance(x, u_samples[i].xy * iResolution.xy) <= 1.0) {\n            return u_samples[i].z;\n        }\n    }\n    float tmp1 = 0.0;\n    float tmp2 = 0.0;\n    for(int i = 0; i < u_samples.length(); i++) {\n        float wi = w_i(u_samples[i].xy * iResolution.xy, x, p);\n        tmp1 += (wi * u_samples[i].z);\n        tmp2 += wi;\n    }\n    return tmp1 / tmp2;\n}\n\nfloat sampleValueMax() {\n    float m = 0.0;\n    for(int i = 0; i < u_samples.length(); i++) {\n        if(m < u_samples[i].z) {\n            m = u_samples[i].z;\n        }\n    }\n    return m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat uv = u(fragCoord, 9.0+7.0*sin(iTime));\n    float maxValue = sampleValueMax();\n\tfragColor = vec4(uv/maxValue * 0.9, uv/maxValue * 0.6, 1.0 - 0.9*uv/maxValue, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdXfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 280, 280, 325], [327, 327, 353, 353, 770], [772, 772, 796, 796, 962], [964, 964, 1019, 1019, 1191]], "test": "error"}
{"id": "XlfXDr", "name": "glitchy zone", "author": "netgrind", "description": "glitchy", "tags": ["glitch"], "likes": 3, "viewed": 496, "published": "Public API", "date": "1494653001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//forked from https://www.shadertoy.com/view/llfSzH\n\nvoid mainImage( out vec4 f, vec2 u )\n{\n    float t = iTime*.3;\n    float s = 1.;\n    //u.x+=100.;\n    vec3 r = vec3(cos(t*s*1.)*3. + s*.5, s*.5,sin(t*s*1.)) + s*.5,\n         R = iResolution ;\n    \n    u-= R.xy*.5;\n    float d = length(u/R.y)*2.;\n    float a = sin(t*.1);\n    u*= mat2(d,a,-a,d);\n    u+=R.xy*.5;\n    \n    for( float i = .7; i > .1 ; i-=.009 ) {\n        r += vec3( (u+u-R.xy)/R.y, 1) *.5\n             * ( f.a = length( mod(r,s) - (s*.5) )+sin(mod(r.z*r.x*r.y,s))*.2 - .3 ) ;\n        float aa = atan(r.y,r.z);\n        float dd = length(r.zy);\n        aa += r.x*.01;\n        \n        r.y = sin(aa)*dd;\n        r.z = cos(aa)*dd;\n        f.bgr=abs(sin(vec3(i)));\n        if( f.a < .001 ) break ;\n    }\n    f.rgb = sin(t+(f.rgb+vec3(0.0,.33,.66))*6.)*.5+.5;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfXDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 91, 91, 822]], "test": "ok"}
{"id": "Xs2cDt", "name": "Alien Tissue", "author": "Ebanflo", "description": "A circle inversion IFS. Mouse changes circle radii.", "tags": ["2d", "fractal", "interactive", "apollonian", "gasket"], "likes": 12, "viewed": 715, "published": "Public API", "date": "1494516406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\n#define zoom 0.5\n#define yShift -0.25\n\nconst int ITS = 35;\nconst float pi = 3.1415926536;\nconst vec2 c1 = vec2(0, 1);\nconst vec2 c2 = vec2(.866, -.866);\nconst vec2 c3 = vec2(-.866, -.866);\nconst float rad1 = 1.0;\n\nvec2 circleInverse(vec2 pos, vec2 center, float rad){\n    vec2 d = pos - center;\n\treturn d * rad * rad/dot(d, d) + center;\n}\n\nvec3 gasket(vec2 pos){\n    float rad2 = iMouse.x / iResolution.x + .5;\n\tfloat rad3 = iMouse.y / iResolution.y + .5;\n    if(iMouse.xy == vec2(0.)) {rad2 = 1.; rad3 = 1.;}\n    float index = 0.;\n\tfor(int i = 0 ; i < ITS; i++){\n\t\tif(distance(pos, c1) < rad1){\n\t\t\tpos = circleInverse(pos, c1, rad1);\n            index++;\n\t\t}\n        else if(distance(pos, c2) < rad2){\n\t\t\tpos = circleInverse(pos, c2, rad2);\n            index++;\n\t\t}\n        else if(distance(pos, c3) < rad3){\n\t\t\tpos = circleInverse(pos, c3, rad3);\n            index++;\n\t\t}\n        else if(pos.y < 0.){\n\t\t\tpos = vec2(pos.x, -pos.y);\n            index++;\n\t\t}\n        else return vec3(pos, index);\n\t}\n}\n\nvec3 render(vec2 p){\n    p = zoom*(2.0*p - iResolution.xy)/iResolution.y;\n    p.y += yShift;\n    vec3 n = gasket(p);\n    float s = 0.08 * (4.0-length(n.xy)) + n.z;\n    if (n.z > 44.0)return vec3(0);\n    float arg = pi * s / 20. + iTime;\n    vec3 col = sin(arg - vec3(0.5*pi, pi, 0.666666*pi)) * 0.5 + 0.5;\n    return col*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \tcol += render(fragCoord);    \n    }\n    col /= float(AA*AA);\n#else\n        \n    col = render(fragCoord);\n#endif            \n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2cDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 280, 280, 351], [353, 353, 375, 375, 1013], [1015, 1015, 1035, 1035, 1342], [1344, 1344, 1400, 1400, 1669]], "test": "error"}
{"id": "Xs2yDt", "name": "03. Noise and distortion.", "author": "liamegan", "description": "Distortion of an image using noise as input", "tags": ["2d", "noise", "distortion", "fractalnoise"], "likes": 14, "viewed": 363, "published": "Public", "date": "1494373676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat interpolate(float a, float b) {\n    return a + ( b - a ) * ( ( 1.0 - a ) / ( b - a ) );\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;    \n//    uv += 0.5;\n    \n    float value = fractalNoise2d(uv);\n    \n//    uv += (0.5 - value) / 20.0;\n//    fragColor = texture(iChannel0, uv);\n    \n    float rotationAmt = iMouse.y / iResolution.y * 2.0;\n    \n    uv *= mat2(cos(rotationAmt), -sin(rotationAmt), sin(rotationAmt), cos(rotationAmt));\n    \n    uv.y *= 10.0;\n    uv += (0.5 - value * 3.0);\n    \n    fragColor = vec4(smoothstep(0.6, 0.55, fract(uv.y)) * smoothstep(0.35, 0.4, fract(uv.y)));\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2yDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 144], [146, 146, 183, 183, 241], [243, 322, 346, 346, 876], [878, 951, 982, 982, 1359], [1366, 1366, 1423, 1470, 1991]], "test": "ok"}
{"id": "Xs2yW3", "name": "halodotfield", "author": "lennyjpg", "description": "learn all dem things", "tags": ["2d", "blobs", "mono"], "likes": 10, "viewed": 1019, "published": "Public API", "date": "1494098751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.y, s = vec2(.0),c = vec2(.0);\n    vec3 pixel = vec3(0.);\n    float t = iTime * 0.07,d = 0.0,r = 0.0;\n\tfor(float i=0.0; i<50.0; i+=1.0) {\n       s = vec2(t + fract(sin(i*0.9)*37.0),t + fract(cos(i*2.5)*37.0));\n       c.x = fract(cos(i*42.9 + s.x)*2.551) * 4.0 - 1.0;\n       c.y = fract(sin(i*13.44 + s.y)*0.987) * 3.0 - 1.0;\n       r = fract(sin((i*0.6))*5.0) * 0.67;\n       d = length(uv - c);\n       pixel[int( mod(i,3.0))] += smoothstep(d*0.05,d,r*r)*0.47;\n    }\n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2yW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 593]], "test": "ok"}
{"id": "Xs2yWd", "name": "everyday 001/100", "author": "kalin", "description": "everyday 001/100", "tags": ["everyday"], "likes": 1, "viewed": 97, "published": "Public", "date": "1494395421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    float s = sin(iTime);\n    float r = texture(iChannel1, vec2(t*0.001,t*0.002), 2.0).x;\n    vec4 rr = texture(iChannel1, vec2(t*0.01,t*0.02));\n\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = mix(fragColor, fragColor * mod(uv.y+t*0.1+s*abs(s)*0.1, 0.1), 0.5);\n    fragColor *= 2.1 - uv.x*uv.x*0.01*sin(iTime*2.0*r);\n    \n    float c = 1.0 - pow(length(uv - vec2(0.5)), 1.0);\n    fragColor *= c;\n    fragColor.y += r * c * 0.1;\n        \n    fragColor = mix(fragColor, vec4(fragColor.x,1,0,1) * mod(uv.x, 0.1), 0.1);\n    fragColor = mix(fragColor, texture(iChannel0, c*fragColor.xy*4.0), 0.1); \n    \n    fragColor.x *= fragColor.z*5.0;\n    fragColor.xy += rr.xy;\n    \n    vec4 mm = texture(iChannel2, vec2(uv.x*uv.y*c*c*c,0));\n    \n    //fragColor = mm;\n    fragColor.x *= mm.x;\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2yWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 918]], "test": "error"}
{"id": "XsBcDc", "name": "vornoy mountain maze", "author": "ollj", "description": "mouse.x=distortion\nmouse.y =view\n\n3d raymarch version of \nhttps://www.shadertoy.com/view/4lV3zc\nmakes a maze of valleys on a distorted square tiling.", "tags": ["3d", "voronoi", "mountainmaze"], "likes": 5, "viewed": 652, "published": "Public API", "date": "1494016185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parent= https://www.shadertoy.com/view/4lV3zc\n\n#define mode3d\n\n//epsilon\n#define eps .01\n//max render distance\n#define zFar 50.\n#define rmIterations 64.\n\n//scales height of hills\n#define scaleHeight .7\n//flat lower plane height\n#define erroded .01\n\n//set distance to view plane, laziest camera.\n#define fowd 3.5\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031, .11369, .13787) // int range\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x+p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n// basic line function (ends are clipped not rounded)\nfloat line(in vec2 p, vec2 p0, vec2 p1) {\n    vec2 n = normalize(p1-p0);\n    p -= p0;\n    float l = .5 * length(p1-p0);\n    return abs(dot(p, vec2(n.y, -n.x))) + step(l, abs(dot(p, n)-l));\n}\n\n// get hash offset (jitter and p are assigned in main)\n#define getH(d) j*hash22(floor(p-d))-d;\n//[j]=jitter\nfloat vorLines(vec2 p,float j){\n // random offsets of neighbors (clockwise starting north)\n vec3 v = vec3(-1., 0., 1.);\n vec2 o[10];\n o[0]=getH(v.yz);\n o[1]=getH(v.zz);\n o[2]=getH(v.zy);\n o[3]=getH(v.zx);\n o[4]=getH(v.yx);\n o[5]=getH(v.xx);\n o[6]=getH(v.xy);\n o[7]=getH(v.xz);\n o[8]=o[0];\t // trying to prevent excess code\n o[9]=o[1];\t// <--'\n // center offset\n vec2 c=getH(0.);\n // center cell dot (we won't know which lines connect, so all line caps contribute)\n float f=length(fract(p)-c);\n // check neighbors and combine into f:\n for(int n=0;n<8;n++){\n  f=min(f,length(fract(p)-o[n])); // dots from neighbors\n  //lines between center and neighbors\n  if(distance(c, o[n])<1.)\n   f=min(f, line(fract(p), c, o[n]));\n  //lines between adjacent neighbors\n  if(distance(o[n], o[n+1]) < 1.)\n   f=min(f,line(fract(p),o[n],o[n+1]));\n  //lines between every other neighbor\n  if(distance(o[n], o[n+2]) < 1.)\n   f=min(f,line(fract(p),o[n],o[n+2]));\n }\n return f;}\n\n//making a linear gradient smoothe and more erroded.\nfloat vormod(float f){\n //f+=.05*sin(p.x*5.);\n //f+=.05*cos(p.y*5.);\n f=smoothstep(erroded,1.,f);\n //f=sqrt(f);\n f=1./exp(f);\n return f;}\n\nfloat df(vec3 p){\n float jitter=iMouse.z>0. ? min(1.,iMouse.x /iResolution.x):1.;\n //p.xy+=.05*vec2(sin(p.x*2.),cos(p.y*3.));\n p.z-=.3*(sin(p.x)+cos(p.y/3.));\n float f=vorLines(p.xy,jitter);\n return vormod(f)-p.z*scaleHeight;}\n\nfloat rm(vec3 o,vec3 d){\n float r=0.;\n for(float i=0.;i<rmIterations;i++){\n  float e=df(o+d*r);\n  if(e<eps||r>zFar)break;\n  r+=e*.8;\n }return r;}\n\n/*\n//below raymarching loop is poorly set up for this scene\n#define dynamicEps\nfloat rm0(vec3 o,vec3 r){float t=0.;\n for(float i=0.;i<rmIterations;++i){\n  float d=df(o+r*t);\n  t+=d;\n  #ifdef dynamicEps\n  d=pow(d,pow(t,.5));\n  #endif\n  if(d<eps*.005)break;\n }return t;}\n*/\n\n//vec3 Gradient(vec3 p,float d){vec2 e=vec2(.001,0);p*=99.;\n// return (vec3(df(p+e.xyy),df(p+e.yxy),df(p+e.yyx))*99.-d)/e.x;}\nvec3 Normal(vec3 p){vec2 e=vec2(.01,0);return normalize(vec3(\n df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}\nvec3 Normal2(vec3 p){if(df(p)<.03)return Normal(p);return vec3(-.7);}\n\n//transform.2d:\n//2d rotation r=3.14 -> half rotation roundrclockwise\n#define r2d(r) mat2(cos(r),-sin(r),sin(r),cos(r))\n\nvoid mainImage( out vec4 fragColor, in vec2 In ) {\n vec2 res = iResolution.xy;\n //vec2 u = (In.xy-res/2.) / res.y + 1.e-4; // a small value is added to avoid errors where floor meets fract\n vec2 u=In/iResolution.xy;\n u-=.5;\n // init p, with zoom\n u*=6.;\n u.x*=iResolution.x/iResolution.y;\n #ifdef mode3d\n u.y=-u.y;\n //float f=vorLines(p,jitter);\n vec3 o=vec3(-3);\n vec3 d=vec3(fowd,u);\n d=normalize(d);  \n d.xz*=r2d(iMouse.y*3./iResolution.y);\n d.xy*=r2d(iTime*.2);\n float e=rm(o,d);\n e=min(e,zFar); \n vec3 c=Normal2(o+d*e)*.5+.5;\n//super cheesy ambient at lead destroys optical illusions:\n c=c*.2+pow(c,vec3(e*.5-1.3));\n #else\n  u*=2.;\n  float jitter=iMouse.z>0. ? min(1.,iMouse.x /iResolution.x):1.;\n  float f=vorLines(u,jitter);\n  vec3 c=vec3(1.-vormod(f));\n  //c=vec3(f);\n #endif   \n //e=fract(e*3.);\n fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 452, 452, 585], [588, 642, 683, 683, 832], [929, 942, 973, 1032, 1897], [1899, 1952, 1974, 2020, 2089], [2091, 2091, 2108, 2108, 2317], [2319, 2319, 2343, 2343, 2464], [2739, 2865, 2885, 2885, 3003], [3004, 3004, 3025, 3025, 3073], [3196, 3196, 3246, 3246, 4028]], "test": "ok"}
{"id": "XsBcDt", "name": "Ring, ring - xor, noise", "author": "DonKarlssonSan", "description": "I read this tutorial:\nhttp://adrianboeing.blogspot.se/2011/01/xor-demoeffect-in-webgl.html", "tags": ["noise", "simplex", "ring", "xor"], "likes": 4, "viewed": 91, "published": "Public", "date": "1494270492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex 2D noise\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tvec2 uv = (fragCoord.xy -0.5 * iResolution.xy) / iResolution.x * 2.0;\n    float radius = length(uv);\n\tbool toggle = mod(radius, 0.1) > 0.05;\n    \n    float xnoise = snoise(vec2(uv.x, iTime / 5.0)) / 3.0;\n    float ynoise = snoise(vec2(uv.y, iTime / 5.0)) / 3.0;\n    float radius2 = sqrt(dot(uv - xnoise, uv - ynoise));\n    \n    //float x = mod(radius2, 0.1);\n    //float xx = smoothstep(0.029, 0.031, x) * (1.0 - smoothstep(0.079, 0.081, x));\n    //fragColor = vec4(vec3(xx), 1.0);\n\n    bool toggle2 = mod(radius2, 0.1) > 0.05;\n    bool xor = toggle != toggle2;\n\n    float t1 = mod(radius, 0.1);\n    float t2 = mod(radius2, 0.1);\n    float sm = smoothstep(0.029, 0.031, t1) * (1.0 - smoothstep(0.079, 0.081, t2));\n\t\n    fragColor = vec4(vec3(sm), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 111, 111, 150], [152, 152, 173, 173, 993], [995, 995, 1052, 1052, 1810]], "test": "ok"}
{"id": "XsBcWd", "name": "Torus : Translucidity", "author": "JCDjcd", "description": "Very simple torus displayed using ray tracing.\nThe ray intersects with at most 4 points (solving fourth degree equation itself solved by third degree equation).", "tags": ["torus"], "likes": 12, "viewed": 190, "published": "Public", "date": "1494535470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n#define torus_R \t\t0.7\n#define torus_r \t\t0.4\n\n//--------------------------------------------------------------------------\n// complex multiplication (ax + i*ay) * (bx + i*by)\nvec2 complex_mul(vec2 a,vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n} // complex_mul()\n\n//--------------------------------------------------------------------------\n// square root\nvec2 complex_sqrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return sqrt(sqrt(r2))*vec2(cos(0.5*theta),sin(0.5*theta));\n} // complex_sqrt()\n\n//--------------------------------------------------------------------------\n// cubic root\nvec2 complex_cbrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return pow(r2,1.0/6.0)*vec2(cos(theta/3.0),sin(theta/3.0));\n} // complex_cbrt()\n\n//--------------------------------------------------------------------------\nvec2 complex_conj(vec2 z)\n{\n    return vec2(z.x,-z.y);\n} // complex_conj()\n\n//--------------------------------------------------------------------------\n// solve the equation A*u^3 + B*u^2 + C*u + D = 0\nvoid solve3(float A,float B,float C,float D,out vec2 u1,out vec2 u2,out vec2 u3)\n{\n    // First step consists on shifting u = v-B/(3*A)\n    // in order to write the equation v^3 + p*v + q = 0\n    // (no second term)\n    float p \t= (-B*B/(3.0*A)+C)/A;\n    float q \t= (2.0*B*B*B/(27.0*A*A)-B*C/(3.0*A)+D)/A;\n\n    float delta = q*q/4.0+p*p*p/27.0;\n    vec2 j  \t= vec2(cos(TWOPI/3.0),sin(TWOPI/3.0)); // j^3=1\n    vec2 j2 \t= complex_conj(j);\n    \n    if(delta < 0.0) // three real roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q,0.0)+complex_sqrt(vec2(delta,0.0)));\n\t\tu1 \t\t= vec2(2.0*(\t\t\t\tx).x\t,0.0);\n\t\tu2 \t\t= vec2(2.0*(complex_mul(j,\tx)).x\t,0.0);\n\t\tu3 \t\t= vec2(2.0*(complex_mul(j2,\tx)).x\t,0.0);\n    }\n    else if(delta > 0.0) // one real root and two (conjugated) complex roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q+sqrt(delta),0.0));\n        vec2 y  = -p/3.0*complex_conj(x)/dot(x,x);\n        u1 \t\t= \t\t\t\t\tx\t+\t\t\t\t\ty\t;\n        u2 \t\t= complex_mul(j,\tx)\t+\tcomplex_mul(j2,\ty)\t;\n        u3 \t\t= complex_mul(j2,\tx)\t+\tcomplex_mul(j,\ty)\t;\n    }\n    else // trivial cases\n    {\n        if(0.0 == p && 0.0 == q)\n        {\n            u1 \t= vec2(0.0,0.0);\n            u2 \t= vec2(0.0,0.0);\n            u3 \t= vec2(0.0,0.0);\n        }\n        else\n        {\n            u1 \t= vec2( 3.0*q/p,0.0);\n            u2 \t= vec2(-1.5*q/p,0.0);\n            u3 \t= vec2(-1.5*q/p,0.0);\n        }\n    }\n    \n    // From v to u:\n    u1.x -= B/(3.0*A);\n    u2.x -= B/(3.0*A);\n    u3.x -= B/(3.0*A);\n\n} // solve3()\n\n\n//--------------------------------------------------------------------------\n// solve the equation a*u^3 + b*u^2 + c*u + d = 0\nvoid solve4(float A,float B,float C,float D,float E,out vec2 t1,out vec2 t2,out vec2 t3,out vec2 t4)\n{\n    // We need to find the roots of the polynomial of degree 4.\n    // First step consists on shifting t = s - B/(4.0*A) such that\n    // s^4 + p*s^2 + q*s + r = 0 (no cubic terms)\n    float p = (-3.0*B*B/(8.0*A)+C)/A;\n    float q = (B*B*B/(8.0*A*A)-B*C/(2.0*A)+D)/A;\n    float r = (-3.0*B*B*B*B/(256.0*A*A*A)+B*B*C/(16.0*A*A)-B*D/(4.0*A)+E)/A;\n\n    // Now we must solve u^3 + 2*p*u^2 + (p^2-4*r)*u - q^2 = 0\n\tvec2 u1,u2,u3;\n    solve3(1.0,2.0*p,p*p-4.0*r,-q*q,u1,u2,u3);\n    \n    // Before finalizing, we need to compute the square root of u1, u2, and u3\n    // such that sqrt(u1)*sqrt(u2)*sqrt(u3) = -s\n    vec2 v1 = complex_sqrt(u1);\n    vec2 v2 = complex_sqrt(u2);\n    vec2 v3 = complex_sqrt(u3);\n    if(complex_mul(v1,complex_mul(v2,v3)).x*q > 0.0)\n    {\n        v3 = -v3; // take the other square root of u3\n    }\n    \n    // We finally got our four roots:\n    t1 = 0.5*( v1+v2+v3);\n    t2 = 0.5*( v1-v2-v3);\n    t3 = 0.5*(-v1+v2-v3);\n    t4 = 0.5*(-v1-v2+v3);\n    \n    // From s to t:\n    t1.x -= B/(4.0*A);\n    t2.x -= B/(4.0*A);\n    t3.x -= B/(4.0*A);\n    t4.x -= B/(4.0*A);\n\n} // solve4()\n\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t) = P + t.d\nvec4 compute(vec3 P,vec3 d)\n{\n    // Parametrization of the torus by phi and theta angles.\n    // x = (R+r*cos(theta))*cos(phi)\n    // y = (R+r*cos(theta))*sin(phi)\n    // z = r*sin(theta)\n    \n    // U*t^2 + V*t + W = 2*r*R*cos(theta)\n\tfloat U = dot(d,d);\n    float V = 2.0*dot(P,d);\n    float W = dot(P,P) - (torus_R*torus_R+torus_r*torus_r);\n    \n    // A*t^4 + B*t^3 + C*t^2 + D*t + E = 0\n    float A = U*U;\n    float B = 2.0*U*V;\n    float C = V*V + 2.0*U*W + 4.0*torus_R*torus_R*d.z*d.z;\n    float D = 2.0*V*W + 8.0*torus_R*torus_R*P.z*d.z;\n    float E = W*W + 4.0*torus_R*torus_R*(P.z*P.z-torus_r*torus_r);\n\n    vec2 t[4]; // complex roots\n    solve4(A,B,C,D,E,t[0],t[1],t[2],t[3]);\n\n    float sorted_t[4];\n    int   nb_intersection = 0;\n    for(int i=0;i<4;i++)\n    {\n        if(abs(t[i].y)<0.005) // if the root is real, we got an intersection\n        {\n            nb_intersection ++;\n            sorted_t[nb_intersection-1] = t[i].x;\n            for(int j=nb_intersection-2;j>=0;j--)\n            {\n                if(sorted_t[j] > sorted_t[j+1])\n                {\n                    float tmp \t\t= sorted_t[j];\n                    sorted_t[j] \t= sorted_t[j+1];\n                    sorted_t[j+1] \t= tmp;\n                }\n            } // for()\n        }\n    } // for()\n    \n    // colorization\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    for(int i=0;i<nb_intersection;i++)\n    {\n        vec3 \tM \t\t= P+sorted_t[i]*d;\n        float \tphi \t= atan(M.y,M.x);\n        float   theta   = atan(M.z,sqrt(M.x*M.x+M.y*M.y)-torus_R);\n        \n        vec4 c = COLORIZATION((3.0*phi+2.0*theta)/TWOPI);\n        if(cos(7.0*phi) > 0.95) // displays 7 white small rings\n        {\n            c = vec4(1.0,1.0,1.0,1.0);\n        }\n        if(cos(4.0*theta) > 0.95) // displays 4 white large rings\n        {\n            c = vec4(1.0,1.0,1.0,1.0);\n        }\n        \n        color = c*0.5 + 0.5*color;\n    } // for()\n    \n    \n    return vec4(color.rgb,1.0);\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*2.5;\n    vec3 P \t\t\t= vec3(uv,-5.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    \n    float alpha1\t= iTime*TWOPI/11.0;\n    float alpha2\t= iTime*TWOPI/5.0;\n    P.xy\t\t   *= ROTATION(alpha2);\n    P.zx\t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n\t\n\tfragColor \t\t= compute(P,d);\n\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 453, 486, 486, 538], [557, 649, 676, 676, 809], [829, 920, 947, 947, 1081], [1101, 1178, 1205, 1205, 1234], [1254, 1381, 1463, 1596, 2865], [2880, 3007, 3109, 3290, 4196], [4211, 4324, 4353, 4559, 6272], [6287, 6364, 6415, 6415, 6836]], "test": "error"}
{"id": "XsfBDH", "name": "glide reflect transflect", "author": "ollj", "description": "mouse input!\n\nhttps://en.wikipedia.org/wiki/Glide_reflection\nThe darker half is the mirrored duplicate\nmirror() abs()es a reflection to render in a single pass\ntransflect() adds offset to the mirror image,like footprints\n\ncould use pMod() along the mirror", "tags": ["reflection", "mirror", "tiling", "reflect", "euclidean", "tesselation", "wallpaper", "wallpapergroup", "pmodmirror", "transflect", "isometrie", "glide"], "likes": 1, "viewed": 518, "published": "Public API", "date": "1495831831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self: https://www.shadertoy.com/view/XsfBDH\n//dad : https://www.shadertoy.com/view/lsBcDt   (sloppy mirror tesselation)\n//mon : https://www.shadertoy.com/view/4dfBRn   (previous failed attempt)\n\n/*\nhttps://en.wikipedia.org/wiki/Glide_reflection\nThe darker (less green) half is the mirrored duplicate.\n\nmirror() abs()es a mirror imate to render in a single pass.\ntransflect() adds an offset to the mirror image, like 2 footprints\nThe mirror image is offset by [transflectOffset]\n\nI am pretty sure i made this uneccessesarrily complicated\njust by adding mouse input.\n\nthis could use pmod() or pmodmirror below.\n*/\n\n//mirror changes over time (moves or rotates or both)\n#define MirrorMove\n#define MirrorRotate\n//the mirror image is offset to the side like 2 footpriints (transflection==https://en.wikipedia.org/wiki/Glide_reflection)\n#define transflectOffset -1.5\n\n/*\n//pMod       repeats space, f(x)=x -> fract(x)       =   seesaw-wave\n//pModMirror repeats space, f(x)=x -> fract(x)*2.-1. = triangle-wave\n//pMod* functions inout-project p into a tile via fract(), with offset,\n//... and return a tileIDoffset that is \"floor()\", with offset\nfloat pMod(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror(inout float p,float s){float c=pMod(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pMod(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror(inout vec2 p,vec2 s){vec2 c=pMod(p,s);p*=mod(c,2.)*2.-1.;return c;}\n//http://mercury.sexy/hg_sdf/\n*/\n\n/*\n//possibly useful for an extension.\nfloat pModMirror1interval(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n    float start =-1.;\n    //above is pModMirror\n    //fused with\n    //below is pModInterval\n    float stop=0.;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c );\n\t\tc = stop;\n\t}if (c <start) {\n\t\tp += size*(c);\n\t\tc = start;\n\t}return c;}*/\n\n//return mirror duplicate of [m]mousePos and [u]FragmentPos on axis y=0;\nvoid mirror(inout vec2 u,inout vec2 m){m.y=abs(m.y);u.y=abs(u.y);}\n//mirror(), but the mirror immage is offset by [o]\nvoid transflect(inout vec2 u, inout vec2 m,float o){\n if(m.y<0.){u.x+=step(0.,u.y)*o;}//if (sign(u.y)>0.)u.x+=o;}\n else u.x+=step(u.y,0.)*o;//if (sign(u.y)<0.)u.x+=o;\n mirror(u,m);}\n\n//return distance to a, asymmetric glyph, to tell what symmetry transformatiosns are happening.\nfloat AsymmetricGlyph(vec2 p){p.y=-p.y;p+=.5;\n float a=min(length(p),length(p-.4)*.5);\n p.y+=.2;return max(a,-length(p)+.5);}//the claw! (i was in a hurry)\n\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n\n#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U)*6.;\n vec2 m;\n if (iMouse.z<0.) m=-vec2(2,1);\n else m=frame(iMouse.xy)*6.;\n float time=iTime*.2;\n #ifdef MirrorMove\n  float t=sin(time)*2.;u.y+=t;m.y+=t;//move mirror over time.\n #endif\n #ifdef MirrorRotate\n  u.x-=.4;m.x-=.4;\n  mat2 a=r2(time*.61);m*=a;u*=a;//rotate mirror over time\n #endif\n bool isMitrrored=(sign(m.y)!=sign(u.y));//if(fragment is in mirror image)\n transflect(u,m,transflectOffset);\n float d=AsymmetricGlyph(m-u);\n //d=length(m-u);//simpler less symmetrical distance to mouse position.\n d=fract(d*3.1);//seesaw first derivative, contrast illusion.\n u=fract(u+.02);//shows that the whole domain is transflect-ed, and small offset shows the mirror\n if(isMitrrored)u*=.4;\n u.x*=.7;//less green = better dichromacy contrast.\n O=vec4(d,u,1.);} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2037, 2110, 2149, 2149, 2176], [2177, 2228, 2280, 2280, 2409], [2411, 2507, 2537, 2537, 2632], [3078, 3078, 3115, 3115, 3887]], "test": "error"}
{"id": "XsfBRM", "name": "decrunchscreen", "author": "premium_prd", "description": "Don't know what i am doing but it looks funny :) and reminds me the old decrunch screens on amiga", "tags": ["tryanderrorthxtovirgillforthetune"], "likes": 1, "viewed": 115, "published": "Public", "date": "1495204129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = (fragCoord.y - iResolution.xy );\n\n    float color = 0.33;\n\tcolor += sin(position.x * position.y) ;\n\tcolor -= sin(iTime)* cos(sin(iTime)*position.y*position.x*sin(position.x))+2.1;\n\tcolor += sin(iTime)*position.x*sin(position.y*sin(sin(tan(cos (iTime)))));\n\tfragColor = vec4( vec3(sin(color-color)*6.0, sin(color+color) , color )+sin(iTime*position.x*(iTime*0.14)),iTime*0.828 );\n\n}", "image_inputs": [{"id": "lslXRN", "previewfilepath": "https://soundcloud.com/virgill/virgill-headcrash-hively-rmx?in=virgill/sets/chiptunes", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/virgill/virgill-headcrash-hively-rmx?in=virgill/sets/chiptunes", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 456]], "test": "ok"}
{"id": "XsfBW8", "name": "Norm-squared transform", "author": "etale_cohomology", "description": "Fork of iq's https://www.shadertoy.com/view/Xdf3Rn", "tags": ["2d", "simple", "math", "tutorial", "transform"], "likes": 2, "viewed": 143, "published": "Public", "date": "1495797986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of iq @ https://www.shadertoy.com/view/Xdf3Rn\n// Created by inigo quilez - iq/2013 - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// TILES controls how many tiles we see!\n#define TILES 8.\n\n// Compute the norm-squared transform of our original (straight) coordinate system!\nvec2 norm_squared(vec2 st){\n  //st *= 2. * (sin(iTime) + 1.1);  // Animate zoom!\n  return vec2(-st.t, st.s) / dot(st, st);  // `dot(st, st)` is the norm-squared of the vector `st`\n}\n\n// Compute antialias! I don't understand how it works, at all\nvec2 antialias(vec2 st){\n  vec2 sine_st = sin(st);\n  vec2 jacobian = fwidth(sine_st) * 0.7071;  // Jacobian!\n  vec2 aa_st = smoothstep(-jacobian, jacobian, sine_st);  // Map smoothly to [0;1]\n  return 2. * aa_st - 1.;  // Remap to [-1;1]\n}\n\n// Compute an antialiased checkerboard!\n// https://www.shadertoy.com/view/Md2XWt\nfloat checkerboard(vec2 st){\n  st *= TILES;  // Expand the st-plane to see more tiles!\n  st.s += -.4 * iTime;  // Move the tiles along the u-direction, just for teh lulz\n  vec2 aa_st = antialias(st);\n  float rgb = .5 * aa_st.s * aa_st.t + .56;  // Combine sine waves and remap to [0;1]\n  return clamp(rgb, .0, 1.);  // Actually ensure we've remapped to [0;1]...\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 st = (2. * fragCoord - iResolution.xy) / iResolution.y;  // Normalize pixel coordinates!\n  st = norm_squared(st);  // Comment this out to see a plain grid!\n  float rgb = checkerboard(st);\n\n  fragColor.rgb = vec3(rgb) * .94;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[236, 320, 347, 400, 501], [503, 565, 589, 589, 804], [806, 887, 915, 915, 1250], [1252, 1252, 1306, 1306, 1539]], "test": "ok"}
{"id": "XsfBWn", "name": "Foggy Duck", "author": "dr2", "description": "Another in the duck series (mouse enabled)", "tags": ["reflection", "refraction", "fog", "fresnel"], "likes": 5, "viewed": 494, "published": "Public API", "date": "1495539813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Foggy Duck\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 VtRot (vec3 p, vec3 a);\nvec3 HsvToRgb (vec3 c);\n\nvec3 ltDir, qnBall;\nvec2 qBlk;\nfloat tCur, dstFar, rBall, cldFac;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idEye = 5;\nconst float pi = 3.14159;\n\nfloat CloudDens (vec3 p)\n{\n  return clamp ((Fbm3 (2.5 * p) - 0.2) / (1. - 0.2), 0., 1.);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit, vec2 bDist)\n{\n  vec3 p, ps;\n  const vec3 cCld = vec3 (1.2, 1.2, 1.1), cLt = vec3 (1.3, 1.3, 1.);\n  float d, f, db, fs, ds, t;\n  int ii;\n  ro = VtRot (ro, vec3 (0.02, 0.033, 0.044));\n  rd = VtRot (rd, vec3 (0.02, 0.033, 0.044));\n  db = rBall / 20.;\n  d = bDist.x;\n  ii = 0;\n  for (int i = 0; i < 20; i ++) {\n    d += db;\n    if (d > min (bDist.y, dHit)) break;\n    p = ro + d * rd;\n    f = CloudDens (p) * (1. - smoothstep (0.9 * rBall, rBall, length (p))) *\n       smoothstep (0., 0.1 * rBall, dHit - d);\n    if (ii == 0) {\n      fs = 0.;\n      if (f > 0.) {\n        ds = 0.;\n        ps = p + (3./2.) * db * rd;\n        for (int j = 0; j < 4; j ++) {\n          ds += 3. * db;\n          ps -= ds * ltDir;\n          t = length (ps);\n          if (t > rBall) break;\n          fs += CloudDens (ps) * (1. - smoothstep (0.9 * rBall, rBall, t));\n        }\n      }\n    }\n    col = mix (col, mix (cCld, cLt, fs), clamp (cldFac * f, 0., 1.));\n    if (++ ii == 3) ii = 0;\n  }\n  return col;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 r;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dMin, d, h, s;\n  dMin = dstFar;\n  p -= vec3 (0., -0.3, -0.1);\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idWng; }\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)),\n     dMin, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idHead; }\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= 0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 2. * h)), dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idBk; }\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - vec3 (0.245, 0.825, -0.6), 0.125);\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat MarbVol (vec3 p)\n{\n  vec3 q;\n  float f;\n  f = 0.;\n  p *= 0.7;\n  q = p;\n  for (int j = 0; j < 5; j ++) {\n    q = abs (q) / dot (q, q) - 0.89;\n    f += 1. / (1. + abs (dot (p, q)));\n  }\n  return f;\n}\n\nvec3 DukMarb (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float t;\n  col = vec3 (0.);\n  ro = VtRot (ro, - vec3 (0.03, 0.022, 0.026));\n  rd = VtRot (rd, - vec3 (0.03, 0.022, 0.026));\n  t = 0.;\n  for (int j = 0; j < 32; j ++) {\n    t += 0.02;\n    col = mix (HsvToRgb (vec3 (mod (0.4 * MarbVol (ro + t * rd) +\n       0.03 * pi * tCur, 1.), 1., 1. / (1. + t))), col, 0.95);  \n  }\n  return clamp (col, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.0005;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.01;\n    if (sh < 0.03) break;\n  }\n  return sh;\n}\n\nvec2 BallHit (vec3 ro, vec3 rd)\n{\n  float dbIn, dbOut, b, d;\n  b = dot (rd, ro);\n  d = b * b + rBall * rBall - dot (ro, ro);\n  dbIn = dstFar;\n  dbOut = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    dbIn = - b - d;\n    dbOut = - b + d;\n    qnBall = (ro + dbIn * rd) / rBall;\n  }\n  return vec2 (dbIn, dbOut);\n}\n\nvoid BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  float dMin, dn, df, bSize;\n  bSize = 2.;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk));\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, vnp, roo, q;\n  vec2 bDist;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dstObj, ltDotVn, sh, glit, fr, rInd;\n  cldFac = 0.05 + 0.04 * sin (0.14 * pi * tCur);\n  rInd = 1. / (2.5 - 1.4 * cos (0.03 * pi * tCur));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    q = ro - vec3 (0., -0.3, -0.1);\n    if (idObj != idEye) {\n      col = DukMarb (ro, refract (rd, vn, rInd));\n      if (idObj == idBdy) {\n        col *= 1. - smoothstep (0.1, 0.3, ro.y) * smoothstep (0., 0.7, ro.z) * 0.2 *\n           SmoothBump (0.3, 0.5, 0.05, mod (20. * ro.x, 1.));\n      } else if (idObj == idWng) {\n        q.x = abs (q.x);\n        q -= vec3 (0.5, 0.3, 0.6);\n        q.yz = Rot2Cs (q.yz, cs);\n        q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n        q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n        col *= 1. - step (0.02, q.x) * smoothstep (0., 0.2, q.z) * 0.2 *\n           SmoothBump (0.3, 0.5, 0.05, mod (30. * q.y, 1.));\n      } else if (idObj == idBk) {\n        col = mix (vec3 (0.6, 0.6, 0.9) * max (0.7 - 0.3 * dot (rd, vn), 0.), col,\n          smoothstep (-1.1, -0.97, ro.z));\n      }\n    } else {\n       col = mix (vec3 (0.1), vec3 (1., 0.8, 0.2) * max (0.7 - 0.3 * dot (rd, vn), 0.),\n         smoothstep (0.02, 0.04, length (q.yz - vec2 (0.865, -0.645) +\n         vec2 (0., 0.017 * sin (0.6 * pi * tCur)))));\n    }\n    sh = ObjSShadow (ro, ltDir);\n    ltDotVn = max (0., dot (vn, ltDir));\n    vnp = VaryNf (1000. * ro, vn, 1.5);\n    glit = 300. * step (0.01, ltDotVn) *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), vnp)), 8.);\n    col = 0.8 * col + (1. - 10. * cldFac) * sh * vec3 (1., 1., 0.5) * (glit +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.));\n    fr = pow (1. - abs (dot (rd, vn)), 5.);\n    col = mix (col, vec3 (0.5) * (0.7 + 0.3 * reflect (rd, vn).y), fr);\n  } else {\n    dstObj = dstFar;\n    col = vec3 (0.1, 0.1, 0.3);\n  }\n  bDist = BallHit (roo, rd);\n  if (bDist.x < dstObj) {\n    col = FogCol (col, roo, rd, dstObj, bDist);\n    fr = pow (1. - abs (dot (rd, qnBall)), 3.);\n    BlkHit (roo + bDist.x * rd, reflect (rd, qnBall));\n    qBlk = step (0.1, mod (2. * qBlk + 0.1/2., 1.));\n    col = mix (col, vec3 (0.5, 0.5, 0.6) * (0.5 + 0.5 * qBlk.x * qBlk.y), fr);\n    col += 0.005 + 0.05 * max (dot (ltDir, qnBall), 0.) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), qnBall), 0.), 64.);\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 3. * pi * mPtr.x;\n    el = 1. * pi * mPtr.y;\n  } else {\n    az = 0.6 * pi * sin (0.03 * pi * tCur);\n    el = -0.1 * pi + 0.1 * pi * sin (0.05 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.8));\n  ro = vuMat * vec3 (0., 0., -8.);\n  rBall = 1.5;\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 VtRot (vec3 p, vec3 a)\n{\n  a *= pi * tCur;\n  p.yz = Rot2D (p.yz, a.x);\n  p.zx = Rot2D (p.zx, a.y);\n  p.xy = Rot2D (p.xy, a.z);\n  return p;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a, s;\n  f = 0.;\n  a = 1.;\n  s = 0.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    s += a;\n    a *= 0.5;\n    p = 2. * p.yzx;\n  }\n  return f / s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[676, 676, 702, 702, 766], [768, 768, 834, 834, 1801], [1803, 1803, 1825, 1825, 3232], [3234, 3234, 3267, 3267, 3444], [3446, 3446, 3467, 3467, 3677], [3679, 3679, 3703, 3703, 3882], [3884, 3884, 3917, 3917, 4281], [4283, 4283, 4320, 4320, 4535], [4537, 4537, 4570, 4570, 4845], [4847, 4847, 4879, 4879, 5366], [5368, 5368, 5403, 5403, 7951], [7953, 7953, 8009, 8009, 8848], [8850, 8850, 8883, 8883, 8910], [8912, 8912, 8947, 8947, 9009], [9011, 9011, 9055, 9055, 9130], [9132, 9132, 9177, 9177, 9280], [9282, 9282, 9339, 9339, 9422], [9424, 9424, 9454, 9454, 9512], [9514, 9514, 9545, 9545, 9609], [9611, 9611, 9640, 9640, 9756], [9758, 9758, 9782, 9782, 9918], [10041, 10041, 10065, 10065, 10112], [10114, 10114, 10139, 10139, 10338], [10340, 10340, 10365, 10365, 10709], [10711, 10711, 10732, 10732, 10907], [10909, 10909, 10938, 10938, 11150], [11152, 11152, 11191, 11191, 11414]], "test": "error"}
{"id": "XsfBzn", "name": "Test Sound Benou", "author": "Benou_De_Nice", "description": "Code", "tags": ["test"], "likes": 2, "viewed": 153, "published": "Public", "date": "1494493355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n#define FREQ 8\nvec4 values[FREQ];\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 rot(in float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n// main distance function\nfloat de(vec3 p) {\n    \n    //p = mod(p, vec3(20.0)) - vec3(10.0);\n    \n    \n    float de = length(p) - 5.0;\n    de = sdBox(p, vec3(5.0))-0.3;\n    \n    for (int i = 0 ; i < FREQ ; i++) {\n        float f = float(i) / float(FREQ-1);\n        vec4 value = values[i];\n        \n        float theta = f * PI * 1.5;\n        vec3 dir = vec3(cos(theta), sin(theta), 0);\n        dir.yz *= rot(f*PI*1.0);\n        \n        float v = dot(p,dir);\n        \n        de += sin(v*2.0*pow(2.0, f) + iTime*1.0)*0.25*value.x;\n    }\n\n\treturn de;\n} \n\n// normal function\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.001, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nvec4 myTexture(vec2 texCoord) {\n\t//return texture(iChannel0, texCoord);\n\ttexCoord *= 5.0;\n\tvec2 f = fract(texCoord)-vec2(0.5);\n\tfloat v = smoothstep(0.0, 0.75, length(f));\n\treturn vec4(mix(vec3(0, 1, 0), vec3(1, 1, 0), v), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(-50, 0, 0);\n\tvec3 dir = normalize(vec3(uv*0.2, 1.0));\n\tdir.xz *= rot(3.1415*.5);\n\t\n\tvec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n\tif (iMouse.z < 1.0) mouse = vec2(0.0);\n\t\n\tmat2 rotxz = rot(iTime*0.0652+mouse.x*5.0);\n\tmat2 rotxy = rot(0.3-mouse.y*5.0);\n\t\n\tfrom.xy *= rotxy;\n\tfrom.xz *= rotxz;\n\tdir.xy  *= rotxy;\n\tdir.xz  *= rotxz;\n\n\tfloat totdist = 0.0;\n\tbool set = false;\n\tvec3 norm = vec3(0);\n\t\n    //fragColor = myTexture(uv);\n\t//return;\n\t\n\t\n    for (int i = 0 ; i < FREQ ; i++) {\n        float f = float(i) / float(FREQ-1);\n        values[i] = texture(iChannel0, vec2(f, 0));\n\t\t//values[i] = texture( vec2(uFloatAvgFreq,uFloatAvgFreq) , vec2(f, 0));\n\t\t//values[i] = myTexture(vec2(f, 0));\n    }\n\t\n\tfor (int steps = 0 ; steps < 200 ; steps++) {\n\t\tif (set) continue;\n\t\tvec3 p = from + totdist * dir;\n        \n\t\tfloat dist = de(p)*0.5;\n        \n\t\ttotdist += dist;\n\t\tif (dist < 0.01) {\n\t\t\tset = true;\n\t\t}\n\t}\n    \n    vec3 p = from + totdist * dir;\n    norm = normal(p);\n    \n    if (set) {\n        \n        vec3 light = normalize(vec3(-1, 2, 3));\n        float l = max(dot(norm, light), 0.0);\n       fragColor = vec4(vec3(l), 1.0);\n        fragColor.rgb = norm*0.5+0.5;\n    } else {\n        fragColor = vec4(0, 0.2, 0, 1);\n\n    }\n\t\n\t\n\t\n\t\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 91, 91, 178], [180, 180, 202, 202, 249], [251, 277, 295, 343, 801], [804, 823, 844, 844, 987], [989, 989, 1020, 1060, 1217], [1219, 1219, 1276, 1276, 2645]], "test": "error"}
{"id": "XsffRr", "name": "Diced Duck", "author": "dr2", "description": "Q.a.k (mouse enabled)", "tags": ["raymarch", "slice", "glint"], "likes": 4, "viewed": 469, "published": "Public API", "date": "1494524964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Diced Duck\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\n\nvec3 ltDir;\nfloat dstFar, tCur, sWid;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idEye = 5;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qs;\n  vec2 r;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dMin, d, h, s, slc;\n  dMin = dstFar;\n  qs = abs (mod (p + 0.025, 0.05) - 0.025) - 0.025 * sWid;\n  slc = max (max (qs.x, qs.z), qs.y);\n  q = p;\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (q.z, -2., 2.));\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = max (min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h), slc);\n  if (d < dMin) { dMin = d;  idObj = idBdy;; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = max (SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h),\n     dMin, 0.05), slc);\n  if (d < dMin) { dMin = d;  idObj = idWng; }\n  q = p;\n  q.yz -= vec2 (0.75, -0.4);\n  d = max (SmoothMin (PrEllipsDf (q, vec3 (0.4, 0.35, 0.5)), dMin, 0.1), slc);\n  if (d < dMin) { dMin = d;  idObj = idHead; }\n  q = p;\n  q.yz -= vec2 (0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= h;\n  d = max (SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 2. * h)), dMin, 0.01), slc);\n  if (d < dMin) { dMin = d;  idObj = idBk; }\n  q = p;\n  q.x = abs (q.x) - 0.245;\n  q.yz -= vec2 (0.825, -0.6);\n  d = max (PrSphDf (q, 0.125), slc);\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.00005, -0.00005, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 DukCol (vec3 p)\n{\n  vec3 col, q;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float hu;\n  hu = mod (0.1 * tCur, 1.);\n  col = mix (HsvToRgb (vec3 (hu, 1., 1.)),\n     HsvToRgb (vec3 (mod (hu + 0.1, 1.), 1., 1.)),\n     smoothstep (0.3, 0.5, Fbm3 (10. * p * vec3 (1., 1., 0.5))));\n  if (idObj == idBdy) {\n    col *= 1. - smoothstep (0.1, 0.3, p.y) * smoothstep (0., 0.7, p.z) * 0.1 *\n       SmoothBump (0.3, 0.5, 0.05, mod (20. * p.x, 1.));\n  } else if (idObj == idWng) {\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.5, 0.3, 0.6);\n    q.yz = Rot2Cs (q.yz, cs);\n    q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n    q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n    col *= 1. - step (0.02, q.x) * smoothstep (0., 0.2, q.z) * 0.2 *\n       SmoothBump (0.3, 0.5, 0.05, mod (30. * q.y, 1.));\n  } else if (idObj == idBk) {\n    col *= 1.2;\n  } else if (idObj == idEye) {\n    col = (abs (length (p.yz - vec2 (0.86, -0.64)) - 0.05) < 0.015) ?\n       vec3 (1.2) : vec3 (0.7);\n  }\n  return col;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.0005;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.005;\n    if (sh < 0.03) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, vnp, col, mCol;\n  float dstObj, ltDotVn, sh, glit;\n  dstFar = 30.;\n  sWid = 1. - 0.65 * SmoothBump (0.2, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    ltDotVn = max (0., dot (vn, ltDir));\n    vnp = VaryNf (1000. * ro, vn, 2.);\n    glit = 1000. * step (0.01, ltDotVn) *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), vnp)), 8.);\n    mCol = DukCol (ro);\n    sh = ObjSShadow (ro, ltDir);\n    col = mCol * (0.1 + 0.5 * (0.5 + 0.5 * sh) * ltDotVn) +\n       step (1., sh) * vec3 (1., 1., 0.5) * glit;\n  } else {\n    col = vec3 (0.1) * (1.2 + 0.8 * rd.y);\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 3.5 * pi * sin (0.009 * pi * tCur);\n    el += 0.17 * pi * sin (0.14 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -6.);\n  ro.y += 0.15;\n  ltDir = vuMat * normalize (vec3 (1., 0.5, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.3;\n    p *= 3.;\n    p = p.yzx;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsffRr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[589, 589, 611, 611, 2182], [2184, 2184, 2217, 2217, 2394], [2396, 2396, 2417, 2417, 2629], [2631, 2631, 2653, 2653, 3619], [3621, 3621, 3658, 3658, 3874], [3876, 3876, 3911, 3911, 4698], [4700, 4700, 4756, 4756, 5599], [5601, 5601, 5634, 5634, 5661], [5663, 5663, 5698, 5698, 5760], [5762, 5762, 5806, 5806, 5881], [5883, 5883, 5928, 5928, 6031], [6033, 6033, 6090, 6090, 6173], [6175, 6175, 6206, 6206, 6270], [6393, 6393, 6417, 6417, 6464], [6466, 6466, 6491, 6491, 6690], [6692, 6692, 6717, 6717, 7061], [7063, 7063, 7084, 7084, 7254], [7256, 7256, 7285, 7285, 7497], [7499, 7499, 7538, 7538, 7761], [7763, 7763, 7787, 7787, 7923]], "test": "error"}
{"id": "XsffW8", "name": "Naive grid", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/4tS3Rm", "tags": ["grid"], "likes": 1, "viewed": 82, "published": "Public", "date": "1495802839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of https://www.shadertoy.com/view/4tS3Rm\n\n#define N_TILES_Y 2.\n#define THICKNESS .008\n\nfloat draw_grid(vec2 uv){\n    vec2 dif  = fract(uv * vec2(N_TILES_Y));\n    vec2 grid_2D = floor(dif + vec2(THICKNESS * N_TILES_Y));\n    return floor(grid_2D.x + grid_2D.y);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Rotation: left-multiplication by a unit complex-number!\n    uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;\n\n    float grid = draw_grid(uv);\n    fragColor.rgb = vec3(grid);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsffW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 120, 120, 270], [272, 272, 326, 326, 591]], "test": "ok"}
{"id": "XsffWr", "name": "LineAO", "author": "Geolm", "description": "Use line integral to compute capsule ao. inspired by https://labs.unity.com/article/linear-light-shading-linearly-transformed-cosines\n\nLast update : 2018-11-28, compute capsule cap using the nearest point on the segment and a sphere AO", "tags": ["ao"], "likes": 1, "viewed": 151, "published": "Public", "date": "1495629764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AO_DISTANCE (1.0)\n#define AO_STEPS_COUNT (6)\n#define AO_RAYCOUNT (512)\n#define PI (3.14159265359)\n#define PI_3 (1.0472)\n#define PI_6 (PI / 6.0)\n#define PI_8 (0.7853981 * 0.5)\n#define TWOPI (6.283185307)\n#define CAPSULE_RADIUS (0.09)\n\n//#define VS_CAPSULEAO\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\n\nvec3 mul(mat3 m, vec3 v)\n{\n    return m * v;\n}\n\n// intersect capsule\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec2 opUnion( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvec2 map(in vec3 pos)\n{\n    vec2 dm = vec2(10000.0, -1.0);\n    \n    dm = vec2(sdPlane(pos), 1.0);\n    \n    for(int i=0; i<4; ++i)\n    {\n        float fi = float(i);     \n        \n        float x = float(i - ((i/4)*4));\n        float y = float(i/4) * 1.0;    \t\n        \n        dm = opUnion( dm, vec2(sdCapsule(pos,vec3(x - 2.25,y+1.25 + sin(iTime + fi),-0.5), \n                                             vec3(x - 0.75,y+1.25 + cos(iTime + fi), 1.0),\n                                         0.1 + CAPSULE_RADIUS * fi), 4.0 ));\n    }       \n       \n    return dm;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.01;\n    float tmax = 20.0;\n\n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat raytracedAO(in vec3 pos, in vec3 normal, in vec4 random, in float maxDistance)\n{\n    vec3  ru  = normalize( cross( normal, vec3(0.0,1.0,1.0) ) );\n    vec3  rv  = normalize( cross( ru, normal ) );    \n\n    float occ = 0.0;\n    for( int i=0; i<AO_RAYCOUNT; i++ )\n    {\n        vec2  aa = hash2( random.x + float(i)*203.1 );\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x); \n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt( 1.0-aa.y );\n        vec3  dir = vec3( rx*ru + ry*rv + rz*normal );      \n\n        for(int u=0; u<4; ++u)\n        {\n            float fi = float(u);     \n        \n            float x = float(u - ((u/4)*4));\n            float y = float(u/4) * 1.0;    \t\n                \n            float distance = capIntersect(pos, normalize(dir), vec3(x - 2.25,y+1.25 + sin(iTime + fi),-0.5), \n                                             vec3(x - 0.75,y+1.25 + cos(iTime + fi), 1.0),\n                                         0.1 + CAPSULE_RADIUS * fi);\n                                         \n            if (distance > 0.01)                           \n            {\n                occ+= 1.0;\n                break;\n            }\n        }                \n    }\n    occ /= float(AO_RAYCOUNT);\n    \n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\n// https://www.shadertoy.com/view/lsjXDc\nfloat acosFast( float y )\n{\n    float x = abs( clamp(y,-1.0,1.0) );\n    float z = (-0.168577*x + 1.56723) * sqrt(1.0 - x);\n    return mix( 0.5*3.1415927, z, sign(y) );\n}\n\nvec3 closestPointOnLine(in vec3 a, in vec3 b, in vec3 point)\n{\n    vec3 ab = b - a;\n    float t = dot(point-a, ab) / dot(ab, ab);\n    return a + t * ab;\n}\n\nvec3 closestPointOnSegment(in vec3 a, in vec3 b, in vec3 point)\n{\n    vec3 ab = b - a;\n    float t = dot(point-a, ab) / dot(ab, ab);\n    return a + clamp(t, 0.0, 1.0) * ab;\n}    \n\nfloat Fpo(float d, float l)\n{\n    return l/(d*(d*d + l*l)) + atan(l/d)/(d*d);\n}\n\nfloat Fwt(float d, float l)\n{\n    return l*l/(d*(d*d + l*l));\n}\n\nfloat I_diffuse_line(vec3 p1, vec3 p2)\n{\n    // tangent\n    vec3 wt = normalize(p2 - p1);\n\n    // clamping\n    if (p1.z <= 0.0 && p2.z <= 0.0) return 0.0;\n    if (p1.z < 0.0) p1 = (+p1*p2.z - p2*p1.z) / (+p2.z - p1.z);\n    if (p2.z < 0.0) p2 = (-p1*p2.z + p2*p1.z) / (-p2.z + p1.z);\n\n    // parameterization\n    float l1 = dot(p1, wt);\n    float l2 = dot(p2, wt);\n\n    // shading point orthonormal projection on the line\n    vec3 po = p1 - l1*wt;\n\n    // distance to line\n    float d = length(po);\n\n    // integral\n    float I = (Fpo(d, l2) - Fpo(d, l1)) * po.z +\n              (Fwt(d, l2) - Fwt(d, l1)) * wt.z;\n    return I/PI;\n}\n\nfloat sphereAO(in vec3 spherePosition, in float radius, in vec3 point, in vec3 normal)\n{\n    vec3 sphereUnormL = spherePosition - point;\n    vec3 sphereL = normalize ( sphereUnormL );\n    float sqrSphereDistance = dot ( sphereUnormL , sphereUnormL );\n    \n    float sphereOcc = clamp(dot(sphereL, normal), 0.0, 1.0) *\n           ((radius * radius)/sqrSphereDistance);\n    \n    return sphereOcc;\n}\n\nfloat lineAO(in vec3 a, in vec3 b, float radius, in vec3 point, in vec3 normal)\n{\n\t // no ambient occlusion if we're in the capsule\n    if (sdCapsule(point, a, b, radius) < 0.0)\n        return 1.0;    \t\n    \n    vec3  T1  = normalize( cross( normal, vec3(0.0,1.0,1.0) ) );\n    vec3  T2  = normalize( cross( T1, normal ) );    \n    mat3 toObjectSpace = transpose(mat3(T1, T2, normal));\n    \n    \n    vec3 p1 = mul(toObjectSpace, a-point);\n    vec3 p2 = mul(toObjectSpace, b-point);\n    \n    float occ = radius * I_diffuse_line(p1, p2);\n    \n    vec3 spherePosition = closestPointOnSegment(a, b, point);\n    \n    // hack: AO of the hemisphere ~= sphereAO / 2\n    occ += sphereAO(spherePosition, radius, point, normal) / 2.0;    \n    \n    return 1.0 - min(1.0, occ);\n}\n\n\n\nfloat analyticalLineAO(in vec3 point, in vec3 normal)\n{\n    float occ = 1.0;\n    \n    for(int i=0; i<4; ++i)\n    {\n        float fi = float(i);\n        float x = float(i - ((i/4)*4));\n        float y = float(i/4) * 1.0;    \t\n        \n        occ *= lineAO(vec3(x - 2.25,y+1.25 + sin(iTime + fi),-0.5), \n                         vec3(x - 0.75,y+1.25 + cos(iTime + fi), 1.0),\n                         0.1 + CAPSULE_RADIUS * fi, point, normal);\n    }\n    \n    return occ;    \n}\n\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec4 random, in vec2 CSCoord)\n{ \n    float split = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) split=0.0;\n   \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 albedo = vec3(0.0, 0.0, 0.0);\n    vec3 light = normalize( vec3(-0.6, 0.7, -0.5) );\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {               \n        vec3 pos = ro + t*rd;\n        vec3 normal = calcNormal( pos );\n       \n       \n        vec3 skyColor = clamp(normal.y, 0.0, 1.0)*getSkyColor(normal);\n                           \n        float t1 = iPlane( ro, rd );\n        float ao = 0.0;\n    \tif( CSCoord.x>split )            \n        \tao = analyticalLineAO(pos, normal);\n        #ifdef VS_CAPSULEAO\n       \telse             \n        \tao = analyticalCapsuleAO(pos, normal);\n        #else\n\t\telse             \n        \tao = raytracedAO(pos, normal, random, 100.0);\n        #endif\n        \n        col = vec3(ao);          \n    }   \n    else\n        col = getSkyColor(rd);\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float split = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) split=0.0;\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;    \n\t\t \n\tfloat time = 15.0 + iTime;\n    \n    vec4 random = texture( iChannel0, (fragCoord.xy)/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n\t// camera\t\n\tvec3 ro = vec3( 5.0*cos(0.1*time + 6.0), 2.0, 5.0*sin(0.1*time + 6.0) );\n\tvec3 ta = vec3( 0.5, 0.0, 0.0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n\t// render\t\n    vec3 col = render( ro, rd, random, p);\n    \n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x - split) );\n\t\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsffWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 290, 290, 360], [362, 362, 384, 384, 669], [671, 671, 697, 697, 717], [719, 740, 822, 822, 1553], [1555, 1555, 1580, 1580, 1595], [1597, 1597, 1632, 1632, 1658], [1660, 1660, 1691, 1691, 1778], [1780, 1780, 1832, 1832, 1946], [1948, 1948, 1984, 1984, 2018], [2020, 2020, 2054, 2054, 2087], [2089, 2089, 2129, 2129, 2162], [2164, 2164, 2187, 2187, 2730], [2732, 2732, 2772, 2772, 3089], [3091, 3091, 3123, 3123, 3344], [3346, 3346, 3432, 3432, 4637], [4640, 4681, 4708, 4708, 4850], [4852, 4852, 4914, 4914, 5006], [5008, 5008, 5073, 5073, 5182], [5188, 5188, 5217, 5217, 5267], [5269, 5269, 5298, 5298, 5332], [5334, 5334, 5374, 5389, 5964], [5966, 5966, 6054, 6054, 6362], [6364, 6364, 6445, 6495, 7129], [7133, 7133, 7188, 7188, 7607], [7610, 7617, 7643, 7643, 7781], [7783, 7783, 7854, 7854, 8847], [8849, 8849, 8901, 8901, 9078], [9080, 9080, 9137, 9137, 9931]], "test": "error"}
{"id": "XsfyzB", "name": "a green and ancient light", "author": "jes5199", "description": "simple but I like it", "tags": ["2d", "plasma", "symmetries"], "likes": 3, "viewed": 93, "published": "Public", "date": "1495828325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((100.0 + 0.*pow(iTime / 5., 0.9))) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    float value =  pow(sin(uv.x) * uv.y + sin(uv.y) * uv.x, 0.5);\n    float color = sin(value + iTime / 1.0) * 3.0;\n    //color = color * sign(uv.x) * sign(uv.y); // revision 2\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(0., high, 0.,1.0);\n    } else {\n      fragColor = vec4(high, high, 0.,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsfyzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 571]], "test": "ok"}
{"id": "XsjcWc", "name": "wobbly sphere diffuse", "author": "anclin", "description": "wobbly sphere diffuse", "tags": ["wobblyspherediffuse"], "likes": 2, "viewed": 97, "published": "Public", "date": "1494149573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap(float value, float inputMin, float inputMax, float outputMin, float outputMax)\n{\n    return (value - inputMin) * ((outputMax - outputMin) / (inputMax - inputMin)) + outputMin;\n}\n\nvec2 M(){\n    float aspectRatio = iResolution.x / iResolution.y;\n\tfloat mx = (iMouse.x / iResolution.x - 0.5) * 2.0;\n    float my = (iMouse.y / iResolution.y - 0.5) * 2.0;\n    return vec2(mx,my);\n}\n\nvec3 LightDirection(vec2 xy){\n    float R = 1.0;\n    float sensitivity = 1.0;\n    float x = xy.x * sensitivity;\n    float y = xy.y * sensitivity;\n    float var = R*R - x*x - y*y;\n\tfloat z = sqrt( var );\n    if( var < 0.0 )\n        z = 0.0;\n    return normalize(vec3(x,y,z));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float R = 0.5;\n    float atten = 1.1;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uv -= 0.5;\n    uv.x *= aspectRatio;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    // region wobbly\n    float t = iTime * 2.0;\n    float freq = 10.0;\n    float amplitude = remap( sin(t), -1.0, 1.0, 0.01, 0.04);\n    float waves = sin(y * freq + t*5.0) + cos(x * freq + t*2.0);\n    waves = (waves + 1.0) *  0.5; //normalize 0-1\n    \n    R += waves * amplitude - 0.05;\n    // endof wobbly\n    \n    float nx = x;\n    float ny = y;\n    float nz = sqrt( R*R - x*x - y*y );\n    vec3 n = vec3(nx,ny,nz);\n    \n    vec3 color = vec3(0);\n    \n    float d = sqrt( dot( uv, uv ) );\n    float mask = d < R ? 1.0 : 0.0;\n    \n    vec3 lightDirection = LightDirection( M() );\n    \n    float diffuse = dot(n,lightDirection);\n\tdiffuse = max(0.0, diffuse) * atten;\n    \n    \n    float rim = 1.0 - dot(n, vec3(0,0,1) ) * 3.0;\n\trim = max(0.0, rim);\n    vec3 rimColor = vec3(1,0,0) * 0.2;\n    \n    \n    vec3 lightColor = vec3(0.9, 0.9, 0.7);\n    vec3 ambientColor = vec3(0.11, 0.13, 0.15);\n    color += vec3(lightColor * diffuse + rim * rimColor + ambientColor);\n    \n    color *= mask;\n    \n    fragColor = vec4(color,1);\n    \n    // DEBUG\n\t//fragColor = vec4(n,1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 92, 92, 189], [191, 191, 200, 200, 388], [390, 390, 419, 419, 668], [670, 670, 727, 727, 2034]], "test": "ok"}
{"id": "XsjyDc", "name": "the learning curve", "author": "lennyjpg", "description": "dfgsdgffsdgfsdgds", "tags": ["2d"], "likes": 0, "viewed": 245, "published": "Public API", "date": "1494163268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n\tvec2 u = U.xy / iResolution.y;\n    float t = iTime*.1;\n    vec4 f = vec4(0.005, 0.1, 0.2,.0);\n    vec4 w = vec4(sin(u.x*2.1-t*1.345)*0.2,sin(u.x*1.1-t)*0.2,sin(u.x*7.5-t*3.123)*0.01,.0);\n    O = smoothstep(-0.6+w,1.4+w+f,u.yyyy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjyDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 274]], "test": "ok"}
{"id": "XsjyWc", "name": "UnColorblind Enchroma Sim", "author": "ollj", "description": "Trying to simulate how Enchroma glasses filter out some wavelengths, to focus the remaining wavelengths, to better differentiate between some wavelength-compositions. \nThis can aid medical diagnosis and enables colorblind people pass colorblind tests.", "tags": ["filter", "rainbow", "hsv", "colorblind", "protan", "protans", "protoss", "rdb", "enchroma"], "likes": 2, "viewed": 783, "published": "Public API", "date": "1494135463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//seeing small differences between colors of wounds/infections can be significant for a diagnosis\n//even for non-colorblind people\n\n/*\nthe brain does differential calculus (DFT) of wavelength-overlapping trichromatic input \n(or of (nearly) bichromatic for colorblindness)\n, which can be amplified, by filtering some wavelengths (with expensive sunglasses)\n, by mostly filtering \"pure rgb colors\" and non-yellow\n\nthe trick to counter colorblindness is to filfer out pure RGB colors\nso that only CMY remains unfiltered\n\nthe interpolation between that increases a derivative\n- most Types of colorblind people can barely differentiate purple/cyan/pink from other colors\nunless you filter out \"near purple/cyan\" wavelengths\n, with sunglasses that only remove (near pure) geen blue (and near infraRed, but not pure 400nM red)\n*/\n\n/*\nTrying to simulate how Enchroma glasses filter out some wavelengths, \nto help differenciating between the remaining (unfiltered) wavelengths.\n\nthis translates rather poorly to an hsv rgb color space, \nfor VacuumTube, LCD or OLED displays, but it sill works, kinda.\n\n\"Protan\" is \"red-green colorblindness\"\nwhere cells that should measure red do only measure green instead.\nOwr where the loval maximum of red and green are significantly closer together.\nThis is not binary,\nbut a gradient with percentage of lacking the ability to distinguish red.\n\nall vision comes down to a gradient of wavelengths, on a linear hue-gradient\nbut wavelengths get mixed (the brain does Fourier-Transform the input from the eyes).\nall colorblindness boils down to a limitation of one domains of a 3d color space.\nIf the hue of 2 mixed colors is (nearly) the same,\nthe differentiation of mixed wavelengths gets tricky, or impossible.\nthe dotproduct is a bitch like that!\nbasically, color blindness applies a 3d to 2d matrix transform with no inverse:\n https://www.shadertoy.com/view/MdSGRW\n\nHuman cells are not too good in distinguishing wavelengths.\nbecause there is a lot of frequency overlap between cells \n,that peak in measuring green, and cells that peak in measuring red.\n\nHuman vision does automatic diferentiation and Fourier Analysis from input of the eyes.\n  https://www.shadertoy.com/results?query=derivative+arithmetic\nbetween the input from 1, 2 or 3 cell types to estimate hue and brightness.\nThe differenciation between red and green \nis more prone to rounding errors due to a lot of overlapping.\n\nthis sloppy simulations visualizes how the filter increases contrast\nbetween purple and blue\nand between \"shades of green\".\n\nWe want to enghance an inverse, therefore we filter out the RGB main colors\n, to nehanche the remaining  mixed CMY coplors\n\nEnChroma glasses filter out wavelengths that are \nfurther AROUND the local maximum that human cells measure.\nThe (mlocal maximum) peak wavelengths of the primal colors are unfiltered, \nbut wavelengths a bit above and below become invisible (or diminished to 10%).\ntherefore you see sharper hues, that are easier to differenciate.\n\nIn hue, this filters out the colors around red, green and blue. \nIt reduces ALMOST PURE red and green down to 10% \nIt reduces ALMOST PURE red and violet     to  0% (for color balance)\nwhile PURE red, green violet are still at 100%\n\nThen the brain can easier differenciate between the filtered input\nand more easily distinguish colors between the peaks.\nBetter distinguishing colors between the main-color-peaks \nenables red-green colorblind people to distinguish orange from green.\nBetter distinguishing colors between the main-color-peaks \nenables red-green colorblind people to distinguish blue   from purple.\n*/\n\n#define phi (sqrt(5.)*.5+.5)\n\n\n//hard c0 discontinuious step() filter:\n#define EnHsv\n#define EnHsvIntensity (sin(iTime*phi)*.5+.5)\n//#define EnHsvIntensity 1.\n\n\n//softer c1 dicsontinous piecewise filter: \n#define EnRgb\n#define EnRgbIntensity (sin(iTime*5.)*.5+.5)\n\n/*\nEnRgb does\ncolor.rgb=EnChromaRgb(color.rgb);\nTo kind of simulate how that same filter \nenables to focus on certain color frequencies \nby by diminishing the 3 main colors.\n\nPurple|magenta, yellow and cyan \"shine\" a lot more \nby diminishing all other colors.\n\nThis can help dorctors to make better diagnoses\n\nRedGreen colorblind people \ncan only differenciate between 2 cell inputs.\nand this color filter enables SOME them to pass SOME colorblind-tests \nas if they are not (as much) colorblind.\n\nBecause natural light is a mix of colors, the amount unfiltered colors\nthat still pass trough these glasses\nhelps them differenciate the color of orange carrots from green apples.\n*/\n\n/*\n\nNatural (outdoor) light is more mixed in wavelengths \nthan (indoor) lcd or led display light.\nsince this is 100% lcd/led, sorted by hue, this looks very silly:\n\nA way to aid colorblind people to better distinguish more hues is\nto block out the wavelengths that are in between the peaks \nof SML (short, medium,long wavelength)-receptor wavesforms.\n\n*/\n\nconst float eps = 0.0000001;\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nvec3 rgb2hsl( vec3 col )\n{\n    float minc = min( col.r, min(col.g, col.b) );\n    float maxc = max( col.r, max(col.g, col.b) );\n    vec3  mask = step(col.grr,col.rgb) * step(col.bbg,col.rgb);\n    vec3 h = mask * (vec3(0.0,2.0,4.0) + (col.gbr-col.brg)/(maxc-minc + eps)) / 6.0;\n    return vec3( fract( 1.0 + h.x + h.y + h.z ),              // H\n                 (maxc-minc)/(1.0-abs(minc+maxc-1.0) + eps),  // S\n                 (minc+maxc)*0.5 );                           // L\n}\n\n//reduce s and v of some hue ranges\nvec3 EnChromaHsv(vec3 c){\n\n if (c.x> 80./255.&&c.x<100./255.)c.yz*=.1;//hues from  80/255 to 100/255 filtered\n if (c.x>150./255.&&c.x<190./255.)c.yz*=.1;//hues from 150/255 to 190/255 filtered\n if (c.x>217./255.)c.yz*=.0;       //remove ultraviolet for color balance\n if (c.x< 12./255.)c.yz*=.0;       //remove infrared    for color balance\n return c;\n}\n\n//reduce rgb values of some ranges, similar to EnChromaHsv(), but\n//not quite how human vision works, still helps \"visualizing\"\n//how this apparently enhanches yellow, and mostly filters out green.\nvec3 EnChromaRgb(vec3 c){//this is not too pretty\n if(c.b<.6)c.b*=.1;\n if(c.r<.3)c.r*=.1;\n if(c.r+c.g<.7){c.r*=.1;c.g*=.1;}\n return c;\n}\n\n//========================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 hsv = vec3( uv.x, 0.5+0.5*sin(iTime), uv.y );\n\t#ifdef EnHsv\n    hsv=mix(hsv,EnChromaHsv(hsv),EnHsvIntensity);\n    #endif\n\tvec3 rgb=hsv2rgb(hsv);\n\t//vec3 rgb = hsl2rgb(hsl);\n    #ifdef EnRgb\n\trgb=mix(rgb,EnChromaRgb(rgb),EnRgbIntensity);;\n    #endif\n    \n\tfragColor = vec4( rgb, 1.0 );\n}\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Somehow optimized HSV and HSL to RGB conversion functions. \n\n//========================================================================\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4947, 4947, 4974, 4974, 5103], [5105, 5105, 5132, 5132, 5274], [5276, 5276, 5302, 5302, 5617], [5619, 5619, 5645, 5645, 6097], [6099, 6135, 6160, 6160, 6488], [6490, 6688, 6713, 6737, 6824], [6902, 6902, 6959, 6959, 7296]], "test": "ok"}
{"id": "XslBR8", "name": "Glass Duck", "author": "dr2", "description": "Not so easy with real glass", "tags": ["reflection", "refraction", "texture"], "likes": 14, "viewed": 578, "published": "Public API", "date": "1494841680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Glass Duck\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\n\nvec3 ltDir;\nfloat dstFar, tCur;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idEye = 5;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 r;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dMin, d, h, s;\n  dMin = dstFar;\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  if (d < dMin) { dMin = d;  idObj = idWng; }\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)),\n     dMin, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idHead; }\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= 0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 2. * h)), dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idBk; }\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - vec3 (0.245, 0.825, -0.6), 0.125);\n  if (d < dMin) { dMin = d;  idObj = idEye; }\n  return 0.9 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat MarbVol (vec3 p)\n{\n  vec3 q;\n  float f;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 5; j ++) {\n    q = abs (q) / dot (q, q) - 0.89;\n    f += 1. / (1. + abs (dot (p, q)));\n  }\n  return f;\n}\n\nvec3 DukMarb (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float t;\n  col = vec3 (0.);\n  t = 0.;\n  for (int j = 0; j < 32; j ++) {\n    t += 0.02;\n    col = mix (HsvToRgb (vec3 (mod (MarbVol (ro + t * rd), 1.), 1., 1. / (1. + t))),\n       col, 0.95);  \n  }\n  return clamp (col, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.0005;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.01;\n    if (sh < 0.03) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 q, vn, vnp, col;\n  const vec2 cs = vec2 (cos (0.3), sin (0.3));\n  float dstObj, ltDotVn, sh, glit, fr;\n  dstFar = 30.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    q = ro;\n    if (idObj != idEye) { \n      col = DukMarb (ro, refract (rd, vn, 0.75));\n      if (idObj == idBdy) {\n        col *= 1. - smoothstep (0.1, 0.3, ro.y) * smoothstep (0., 0.7, ro.z) * 0.1 *\n           SmoothBump (0.3, 0.5, 0.05, mod (20. * ro.x, 1.));\n      } else if (idObj == idWng) {\n        q.x = abs (q.x);\n        q -= vec3 (0.5, 0.3, 0.6);\n        q.yz = Rot2Cs (q.yz, cs);\n        q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n        q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n        col *= 1. - step (0.02, q.x) * smoothstep (0., 0.2, q.z) * 0.2 *\n           SmoothBump (0.3, 0.5, 0.05, mod (30. * q.y, 1.));\n      } else if (idObj == idBk) {\n        col = mix (vec3 (0.6, 0.6, 0.9) * max (0.7 - 0.3 * dot (rd, vn), 0.), col,\n          smoothstep (-1.1, -0.97, ro.z));\n      }\n    } else {\n       col = mix (vec3 (0.1), vec3 (0.8, 0.7, 0.2) * max (0.7 - 0.3 * dot (rd, vn), 0.),\n         smoothstep (0.02, 0.04, length (q.yz - vec2 (0.875, -0.65))));\n    }\n    sh = ObjSShadow (ro, ltDir);\n    ltDotVn = max (0., dot (vn, ltDir));\n    vnp = VaryNf (1000. * ro, vn, 2.);\n    glit = 500. * step (0.01, ltDotVn) *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 16.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd), vnp)), 8.);\n    col += sh * vec3 (1., 1., 0.5) * (glit +\n       0.3 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.));\n    fr = pow (1. - abs (dot (rd, vn)), 5.);\n    col = mix (col, vec3 (0.5) * (0.7 + 0.3 * reflect (rd, vn).y), fr);\n  } else {\n    col = vec3 (0.5) * (0.7 + 0.3 * rd.y);\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.9));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n    el = clamp (el, -0.27 * pi, -0.03 * pi);\n  } else {\n    az += 3.5 * pi * sin (0.014 * pi * tCur);\n    el += 0.12 * pi * sin (0.2 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -5.);\n  ro.y += 0.15;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslBR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[562, 562, 584, 584, 1961], [1963, 1963, 1996, 1996, 2173], [2175, 2175, 2196, 2196, 2406], [2408, 2408, 2432, 2432, 2599], [2601, 2601, 2634, 2634, 2877], [2879, 2879, 2916, 2916, 3131], [3133, 3133, 3168, 3168, 5003], [5005, 5005, 5061, 5061, 5953], [5955, 5955, 5988, 5988, 6015], [6017, 6017, 6052, 6052, 6114], [6116, 6116, 6160, 6160, 6235], [6237, 6237, 6282, 6282, 6385], [6387, 6387, 6444, 6444, 6527], [6529, 6529, 6560, 6560, 6624], [6626, 6626, 6650, 6650, 6786], [6909, 6909, 6933, 6933, 6980], [6982, 6982, 7007, 7007, 7206], [7208, 7208, 7237, 7237, 7449], [7451, 7451, 7490, 7490, 7713]], "test": "error"}
{"id": "XslBRr", "name": "Torus : Spiral", "author": "JCDjcd", "description": "A spiral on a torus.\n(Cocorico!)", "tags": ["torus", "spiral"], "likes": 5, "viewed": 157, "published": "Public", "date": "1494629319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n#define torus_R \t\t0.6\n#define torus_r \t\t0.5\n\n//--------------------------------------------------------------------------\n// complex multiplication (ax + i*ay) * (bx + i*by)\nvec2 complex_mul(vec2 a,vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n} // complex_mul()\n\n//--------------------------------------------------------------------------\n// square root\nvec2 complex_sqrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return sqrt(sqrt(r2))*vec2(cos(0.5*theta),sin(0.5*theta));\n} // complex_sqrt()\n\n//--------------------------------------------------------------------------\n// cubic root\nvec2 complex_cbrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return pow(r2,1.0/6.0)*vec2(cos(theta/3.0),sin(theta/3.0));\n} // complex_cbrt()\n\n//--------------------------------------------------------------------------\nvec2 complex_conj(vec2 z)\n{\n    return vec2(z.x,-z.y);\n} // complex_conj()\n\n//--------------------------------------------------------------------------\n// solve the equation A*u^3 + B*u^2 + C*u + D = 0\nvoid solve3(float A,float B,float C,float D,out vec2 u1,out vec2 u2,out vec2 u3)\n{\n    // First step consists on shifting u = v-B/(3*A)\n    // in order to write the equation v^3 + p*v + q = 0\n    // (no second term)\n    float p \t= (-B*B/(3.0*A)+C)/A;\n    float q \t= (2.0*B*B*B/(27.0*A*A)-B*C/(3.0*A)+D)/A;\n\n    float delta = q*q/4.0+p*p*p/27.0;\n    vec2 j  \t= vec2(cos(TWOPI/3.0),sin(TWOPI/3.0)); // j^3=1\n    vec2 j2 \t= complex_conj(j);\n    \n    if(delta < 0.0) // three real roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q,0.0)+complex_sqrt(vec2(delta,0.0)));\n\t\tu1 \t\t= vec2(2.0*(\t\t\t\tx).x\t,0.0);\n\t\tu2 \t\t= vec2(2.0*(complex_mul(j,\tx)).x\t,0.0);\n\t\tu3 \t\t= vec2(2.0*(complex_mul(j2,\tx)).x\t,0.0);\n    }\n    else if(delta > 0.0) // one real root and two (conjugated) complex roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q+sqrt(delta),0.0));\n        vec2 y  = -p/3.0*complex_conj(x)/dot(x,x);\n        u1 \t\t= \t\t\t\t\tx\t+\t\t\t\t\ty\t;\n        u2 \t\t= complex_mul(j,\tx)\t+\tcomplex_mul(j2,\ty)\t;\n        u3 \t\t= complex_mul(j2,\tx)\t+\tcomplex_mul(j,\ty)\t;\n    }\n    else // trivial cases\n    {\n        if(0.0 == p && 0.0 == q)\n        {\n            u1 \t= vec2(0.0,0.0);\n            u2 \t= vec2(0.0,0.0);\n            u3 \t= vec2(0.0,0.0);\n        }\n        else\n        {\n            u1 \t= vec2( 3.0*q/p,0.0);\n            u2 \t= vec2(-1.5*q/p,0.0);\n            u3 \t= vec2(-1.5*q/p,0.0);\n        }\n    }\n    \n    // From v to u:\n    u1.x -= B/(3.0*A);\n    u2.x -= B/(3.0*A);\n    u3.x -= B/(3.0*A);\n\n} // solve3()\n\n\n//--------------------------------------------------------------------------\n// solve the equation a*u^3 + b*u^2 + c*u + d = 0\nvoid solve4(float A,float B,float C,float D,float E,out vec2 t1,out vec2 t2,out vec2 t3,out vec2 t4)\n{\n    // We need to find the roots of the polynomial of degree 4.\n    // First step consists on shifting t = s - B/(4.0*A) such that\n    // s^4 + p*s^2 + q*s + r = 0 (no cubic terms)\n    float p = (-3.0*B*B/(8.0*A)+C)/A;\n    float q = (B*B*B/(8.0*A*A)-B*C/(2.0*A)+D)/A;\n    float r = (-3.0*B*B*B*B/(256.0*A*A*A)+B*B*C/(16.0*A*A)-B*D/(4.0*A)+E)/A;\n\n    // Now we must solve u^3 + 2*p*u^2 + (p^2-4*r)*u - q^2 = 0\n\tvec2 u1,u2,u3;\n    solve3(1.0,2.0*p,p*p-4.0*r,-q*q,u1,u2,u3);\n    \n    // Before finalizing, we need to compute the square root of u1, u2, and u3\n    // such that sqrt(u1)*sqrt(u2)*sqrt(u3) = -s\n    vec2 v1 = complex_sqrt(u1);\n    vec2 v2 = complex_sqrt(u2);\n    vec2 v3 = complex_sqrt(u3);\n    if(complex_mul(v1,complex_mul(v2,v3)).x*q > 0.0)\n    {\n        v3 = -v3; // take the other square root of u3\n    }\n    \n    // We finally got our four roots:\n    t1 = 0.5*( v1+v2+v3);\n    t2 = 0.5*( v1-v2-v3);\n    t3 = 0.5*(-v1+v2-v3);\n    t4 = 0.5*(-v1-v2+v3);\n    \n    // From s to t:\n    t1.x -= B/(4.0*A);\n    t2.x -= B/(4.0*A);\n    t3.x -= B/(4.0*A);\n    t4.x -= B/(4.0*A);\n\n} // solve4()\n\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t) = P + t.d\nvec4 compute(vec3 P,vec3 d)\n{\n    // Parametrization of the torus by phi and theta angles.\n    // x = (R+r*cos(theta))*cos(phi)\n    // y = (R+r*cos(theta))*sin(phi)\n    // z = r*sin(theta)\n    \n    // U*t^2 + V*t + W = 2*r*R*cos(theta)\n\tfloat U = dot(d,d);\n    float V = 2.0*dot(P,d);\n    float W = dot(P,P) - (torus_R*torus_R+torus_r*torus_r);\n    \n    // A*t^4 + B*t^3 + C*t^2 + D*t + E = 0\n    float A = U*U;\n    float B = 2.0*U*V;\n    float C = V*V + 2.0*U*W + 4.0*torus_R*torus_R*d.z*d.z;\n    float D = 2.0*V*W + 8.0*torus_R*torus_R*P.z*d.z;\n    float E = W*W + 4.0*torus_R*torus_R*(P.z*P.z-torus_r*torus_r);\n\n    vec2 t[4]; // complex roots\n    solve4(A,B,C,D,E,t[0],t[1],t[2],t[3]);\n\n    float sorted_t[4];\n    int   nb_intersection = 0;\n    for(int i=0;i<4;i++)\n    {\n        if(abs(t[i].y)<0.005) // if the root is real, we got an intersection\n        {\n            nb_intersection ++;\n            sorted_t[nb_intersection-1] = t[i].x;\n            for(int j=nb_intersection-2;j>=0;j--)\n            {\n                if(sorted_t[j] > sorted_t[j+1])\n                {\n                    float tmp \t\t= sorted_t[j];\n                    sorted_t[j] \t= sorted_t[j+1];\n                    sorted_t[j+1] \t= tmp;\n                }\n            } // for()\n        }\n    } // for()\n    \n    // colorization\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    for(int i=0;i<nb_intersection;i++)\n    {\n        vec3 \tM \t\t= P+sorted_t[i]*d;\n        float \tphi \t= atan(M.y,M.x);\n        float   theta   = atan(M.z,sqrt(M.x*M.x+M.y*M.y)-torus_R);\n        \n        float a = 5.0*phi+15.0*theta+iTime*TWOPI/0.75;\n        // make sure the angle is between 0 and 2.pi\n\t\ta = mod(TWOPI+mod(a,TWOPI),TWOPI);\n        \n        vec4 c;\n        if(a < TWOPI/6.0)\n            c = vec4(1.0,0.0,0.0,1.0);\n        else if(a < 2.*TWOPI/6.0)\n            c = vec4(1.0,1.0,1.0,1.0);\n        else if(a < 3.*TWOPI/6.0)\n            c = vec4(0.0,0.0,1.0,1.0);\n        else\n            continue; // be transparent\n            \n        color = c;\n        break; // don't do translucidity\n    } // for()\n    \n    \n    return vec4(color.rgb,1.0);\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= ((fragCoord.xy - 0.5*iResolution.xy) / m)*1.6;\n    vec3 P \t\t\t= vec3(uv,-5.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    \n    float alpha1\t= TWOPI*0.2;\n    float alpha2\t= TWOPI*0.2;\n    P.xy\t\t   *= ROTATION(alpha2);\n    P.zx\t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n\t\n\tfragColor \t\t= compute(P,d);\n\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 453, 486, 486, 538], [557, 649, 676, 676, 809], [829, 920, 947, 947, 1081], [1101, 1178, 1205, 1205, 1234], [1254, 1381, 1463, 1596, 2865], [2880, 3007, 3109, 3290, 4196], [4211, 4324, 4353, 4559, 6429], [6444, 6521, 6572, 6572, 6987]], "test": "error"}
{"id": "XslBWn", "name": "Sierpinski fractal", "author": "anclin", "description": "Sierpinski fractal", "tags": ["sierpinskifractal"], "likes": 1, "viewed": 86, "published": "Public", "date": "1495662615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tTitle: Simple Sierpinski fractal\n\tTags: fractal\n\tDescription: Sierpinski triangle created with the bitwise AND operation.\n*/\n\n\nfloat Fractal(vec2 fragCoord, float t){\n    float size = min(iResolution.x, iResolution.y);\n    vec2 o = (iResolution.xy - vec2(size)) / 2.0;\n    vec2 p = fragCoord.xy;// (fragCoord.xy - o);\n    \n    float col = 0.0;\n    //if(p.x >= 0.0 && p.y >= 0.0 && p.x < size && p.y < size) {\n        float s = exp2(fract(t));\n    \tuint ix = uint(p.x / s);\n    \tuint iy = uint(p.y / s);\n    \tuint res = (ix & iy);\n    \tcol = res == 0U ? 0.0 : 1.0;\n    //}\n    return col;\n}\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    fragCoord.x *= fragCoord.y * 0.01;// * remap(-1.0, 1.0, 1.0, .01, sin(iTime) );;\n    //fragCoord *= remap(-1.0, 1.0, 1.0, .02, sin(iTime) );\n    \n    float tx = -0.5 * iResolution.x;// * aspectRatio;\n    float ty = -0.5 * iResolution.y;\n    mat3 trans = mat3(\n        1.0, 0.0, tx,\n        0.0, 1.0, ty,\n\t\t0.0, 0.0, 1.0\n\t);\n    \n    \n    float fi = iTime * 0.3;\n    mat2 rot = mat2(\n        cos(fi), -sin(fi),\n        sin(fi), cos(fi)\n\t);\n    \n    \n    fragCoord = (vec3(fragCoord,1) * trans).xy;\n    fragCoord = fragCoord * rot;\n    fragCoord = (vec3(fragCoord,1) * -trans).xy;\n\n    \n    float t = iTime;// + 3.0 * ((sin(iTime * 0.5)+1.0)/2.0);\n    float col = Fractal(fragCoord, t );\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    float value = remap(-1.0,1.0, 0.0, 1.0, sin(iTime * 0.1) );\n    vec4 tex = texture(iChannel0, mix(uv,uv2,value));\n    \n    vec3 color = vec3(0);\n    \n    float frequency = remap(-1.0, 1.0, 1.0, 30.0, sin(iTime) );\n\n    int sw = 0;\n    float stp = step(0.0, sin(iTime));\n    if( stp > 0.0)sw = 1;\n    \n    if( sw == 0 ){\n        color = vec3(col) * vec3(uv,1);\n    }else if(sw == 1){\n        color = vec3(1.0-col) * vec3(uv,1);\n    }\n    \n    //color = mix(color, vec3(uv,1), uv.x);\n    \n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 170, 170, 593], [595, 595, 670, 670, 740], [742, 742, 799, 799, 2169]], "test": "error"}
{"id": "XslBzH", "name": "Test noise distribution", "author": "tloch14", "description": "Testing something I read on twitter.", "tags": ["noise", "rand"], "likes": 2, "viewed": 88, "published": "Public", "date": "1494873714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float maxCheckerSize = 6.0f;\n    \nfloat CheckerValue(vec2 n)\n{\n//    float maxCheckerSize = 6.0f;\n    int checkerSize = 1<< int(iMouse.y / iResolution.y * maxCheckerSize + 1.0f);\n    return float((int(n.x)&checkerSize)^(int(n.y)&checkerSize));\n}\n\nfloat Diagonal(vec2 n)\n{\n    float checkerSize = ceil(iMouse.y / iResolution.y * maxCheckerSize);\n    float i = floor(n.y) + floor(n.x);\n    \n    if (mod(i, checkerSize) == 0.0) { return 1.0f;  }\n    else { return 0.0f; }\n}\n\n\nfloat v2rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract( iTime );\n    \n    float mouseXNorm = float(iMouse.x) / float(iResolution.x);\n    float color = 1.0f;\n    float rand = v2rand(fragCoord * t);\n    if(fragCoord.x < iResolution.x/2.0f)\n    {\n        color = rand;\n    }\n    else\n    {\n        color = (rand * 0.5f) + CheckerValue(fragCoord) * mouseXNorm;\n        //color = (rand * 0.5f) + Diagonal(fragCoord) * mouseXNorm;\n    }\n    \n    fragColor = vec4(color);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 271, 271, 470], [473, 473, 497, 497, 565], [567, 567, 624, 624, 1056]], "test": "ok"}
{"id": "XslBzM", "name": "Cubesnakes", "author": "slerpy", "description": "-", "tags": ["3d", "tunnel", "procedual"], "likes": 6, "viewed": 184, "published": "Public", "date": "1495383046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n\n#define ITER 200\n#define QUA .001\n#define NORK 5e-4\n\nfloat map(vec3 p)\n{\n    p.xy += vec2(cos(p.z),sin(p.z))/2.;\n\tvec3 cen = round(p);\n    vec3 v = abs(cen-p);\n\treturn max(v.x,v.y)-.1;\n}\n\nvec3 normal(vec3 p, float k)\n{\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tmap(p + e.yxx) - map(p - e.yxx),\n\t\tmap(p + e.xyx) - map(p - e.xyx),\n\t\tmap(p + e.xxy) - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t) break;\n        t += .9 * d;\n    } \n    return t;\n}\n\nvec3 fog(vec3 col, float t)\n{\n    vec3 fcol = vec3(.1);\n    return mix( col, fcol, 1.0-exp(-t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*int m = int(iResolution.x);\n    uint xor = ( uint(fragCoord.x) ^ uint(fragCoord.y) ) % uint(m);\n    if(xor != uint(iFrame%m))discard;*/\n    \n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n\tfloat ang = atan(uv.x,uv.y) - iTime/8.;\n\tuv = vec2(cos(ang),sin(ang))*length(uv);\n\n\tvec3 ro = vec3(vec2(.5),iTime);\n    vec3 rd = normalize(vec3(uv,2));\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n    \n\tvec3 sn = normal(sp,NORK);\n    vec3 ld = normalize(ro-sp);\n\tfloat diff = max(dot(sn,ld),0.);\n    \n    vec3 col = (sn.xyz+1.)/2.;\n    col *= (3.+diff)/4.;\n    col = fog(col, t/8.);\n    \n\tfragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 99, 99, 213], [215, 215, 245, 245, 402], [404, 404, 436, 436, 604], [606, 606, 635, 635, 704], [706, 706, 763, 905, 1404]], "test": "ok"}
{"id": "XslBzr", "name": "everyday 004/100", "author": "kalin", "description": "everyday 4/100", "tags": ["everyday"], "likes": 0, "viewed": 69, "published": "Public", "date": "1494653401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdsphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat map(vec3 p)\n{\n    return max(\n        sdsphere(p - vec3(0.05, 0.0, 0.0), 0.94),\n        sdsphere(p + vec3(0.05, 0.0, 0.0), 0.94)\n    );\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 ray(vec2 ro, vec3 rd)\n{\n\tvec3 up = vec3(0,1,0);\n    vec3 right = cross(rd, up);\n    return rd + right * ro.x + up * ro.y;\n}\n\n//vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n//vec3 ro = vec3(0, 0, 3);\n//vec3 rd = normalize(vec3(p, -1.5));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 lookat = vec3(0, 0, 1.0);\n    \n    vec3 ro = vec3(0.25 * sin(iTime), 0.0, -1.0);\n    vec3 rd = ray(ro.xy, lookat - normalize(vec3(uv, 1.0)));\n    float t = march(ro, rd);\n    \n\tfragColor = vec4(t, 0.4, 0.7, 1.0);\n    fragColor.y *= sin(iTime * 0.2);\n    fragColor.x += sin(iTime * 0.6) * 0.1;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 61], [63, 63, 82, 82, 206], [208, 208, 239, 239, 393], [395, 395, 423, 423, 523], [657, 657, 712, 712, 1134]], "test": "ok"}
{"id": "XslfDr", "name": "raymarching sphere depth", "author": "anclin", "description": "raymarching sphere", "tags": ["raymarchingsphere"], "likes": 1, "viewed": 88, "published": "Public", "date": "1495742610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat SceneSDF(vec3 p){\n    \n    p = rotateY(iTime) * p;\n    \n    float sphere = SphereSDF(p, 1.0);\n    float cube = CubeSDF(p, vec3(0.8));\n    \n    return intersectSDF(sphere, cube);\n}\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for(int i = 0; i < 255; i++){\n    \tfloat dist = SceneSDF(eye + depth * marchingDirection);\n        if( dist <= EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    vec3 eye = vec3(0.0 + 0.0 * cos(iTime),\n                    0.0 + 0.0 * sin(iTime),\n                    5.0 + 0.0 * sin(iTime));\n    \n    vec3 lookAtPos = vec3(0.0 + 0.0 * cos(iTime),\n                          0.0 + 0.0 * sin(iTime/2.0),\n                          0.0 + 0.0 * sin(iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    \n    float dist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(1,0,0);\n    \n    //vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n    \t//finalColor = color * diffuse + ambientColor;\n        finalColor = vec3(1,0,0);//(normal + vec3(1.0)) / 2.0;\n        //finalColor = finalColor * (diffuse + ambientColor);\n        finalColor = finalColor * remap(4.0, 5.0, 1.0, 0.0, dist);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 136, 136, 206], [208, 254, 281, 281, 428], [430, 521, 567, 567, 599], [601, 685, 727, 727, 759], [761, 850, 897, 897, 930], [932, 932, 968, 968, 996], [998, 998, 1031, 1031, 1234], [1236, 1236, 1259, 1259, 1421], [1423, 1423, 1451, 1451, 1749], [1751, 1840, 1869, 1869, 2179], [2181, 2181, 2245, 2245, 2374], [2376, 2376, 2466, 2466, 2753], [2755, 3082, 3131, 3166, 3392], [3394, 3394, 3451, 3451, 4842]], "test": "ok"}
{"id": "XslfWr", "name": "Globular", "author": "brainslug", "description": "Raymarching spheres", "tags": ["raymarch"], "likes": 1, "viewed": 106, "published": "Public", "date": "1495731502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.002\n#define MAX_STEPS 32\n#define FAR_CLIP 200.0\n#define RADIUS .95\n\nfloat map(vec3 p)\n{\n    vec3 s = vec3(2.0);\n    vec3 m = mod(p, s) - 0.5 * s;\n    return length(m) - sin(iTime * RADIUS) * 0.5 - 0.5;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n\tmap(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n\tmap(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n\tmap(vec3(p.x, p.y, p.z + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n\t));\n}\n\nvec3 trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    vec3 p;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = o + (r * t);\n        float d = map(p);\n        \n        if (d < EPSILON)\n        {\n            break;\n        }\n        \n        t += d * 0.5;\n        \n        if (t > FAR_CLIP)\n        {\n            return vec3(0.0);\n        }\n    }\n    \n    return (getNormal(p) + vec3(1.0)) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, iTime);\n    vec3 focus = vec3(0.0, 1.0, iTime + 1.0);\n    \n    vec3 lookDir = normalize(focus - o);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(lookDir, up);\n    float fov = 3.;\n    \n    vec3 r = normalize(right * uv.x + up * uv.y + fov * lookDir);\n    \n    vec3 t = trace(o, r);\n    \n    vec3 col = vec3(0.0, 0.75, 0.5);\n    \n    vec3 fc = t;\n    \n\tfragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XslfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 105, 105, 221], [223, 223, 247, 247, 502], [504, 504, 532, 532, 907], [909, 909, 966, 966, 1501]], "test": "ok"}
{"id": "XssBz7", "name": "Fun with fuzzy logic and colors", "author": "FractalCurious", "description": "SEIZURE WARNING!\n\nhttps://en.wikipedia.org/wiki/Fuzzy_logic\n\nFuzzy logic allows treating values from 0 to 1 in a similar fashion as booleans. I thought I'd play around with XOR'ing several moving shapes, thus inverting the colors where they intersect.", "tags": ["colors", "fuzzylogic"], "likes": 2, "viewed": 157, "published": "Public", "date": "1495422538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat circle(vec2 p, vec2 center, float radius) {\n    \n    float border = .05;\n    \n    return smoothstep(radius * (1. - border), radius * (1. + border), length(p - center));\n}\n\nfloat squareWave(float x, float period) {\n\treturn step(period * .5, mod(x, period));\n}\n\nfloat reduceAtZero(float x) {\n\treturn x * x / (x + 1.) / (x + 1.);\n}\n\nvec2 twistedPolarCoords(vec2 p, float twistFactor) {\n    float r = length(p);\n    float a = atan(p.y / p.x);\n    \n    a += r * twistFactor;\n    \n    return vec2(r * cos(a), r * sin(a));\n}\n\nfloat scene(vec2 p) {\n    \n    float displacement = sin((iTime + 2. * p.x + p.y) * 2.5);\n    float displacement2 = iTime / 10.;\n    \n    p.y += displacement2;\n    \n    p = mod(p, .2);\n    \n    return circle(p, vec2(0.1 + 0.05 * displacement, 0.1), .05);\n}\n\nfloat fNot1(float x) {\n    return 1. - x;\n}\n\nfloat fAnd1(float x, float y) {\n    return x * y;\n}\n\nfloat fOr1(float x, float y) {\n    return x + y - x * y;\n}\n\nfloat fXor1(float x, float y) {\n\treturn fOr1(fAnd1(x, fNot1(y)), fAnd1(fNot1(x), y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy - vec2(.5, .5);\n    p.x *= iResolution.x / iResolution.y;\n    \n    float scene1 = scene(p);\n    float scene2 = scene(p.yx);\n    \n    float slowDownAtStart = reduceAtZero(iTime / 3.) * reduceAtZero(iTime / 3.);\n    \n    float square_size = .5  + .495 * sin(iTime / 3.) + 1.5 -  1.5 * slowDownAtStart;\n    vec2 polarTwist = p; //twistedPolarCoords(p, 2. + square_size / 1.55 * 2.);\n    float scene3 = (mod(polarTwist.x - square_size / 2., square_size) + mod(polarTwist.y - square_size / 2., square_size)) / square_size / 2.;\n    \n    float timeAdjustment = iTime / 5. * slowDownAtStart + .1 * sin(iTime) * slowDownAtStart;\n    \n    float radius = .25 + .03 * sin(sin(iTime / 10.) - 1.1 * sin(length(p))) * reduceAtZero(iTime / 5.) + 4. * (1. - reduceAtZero(iTime / 5.));\n    float s4 = squareWave(length(p) - timeAdjustment, radius);\n    \n    float angle = iTime * .332;\n    float s5 = squareWave(length(p - .2 * vec2(cos(angle), sin(angle))) - timeAdjustment, radius);\n    \n    float r = fXor1(scene1, fXor1(s4, scene2));\n    \n\tfragColor = vec4(vec3(\n        r * r,\n        fXor1(fXor1(scene3 * .75, s5), fXor1(fNot1(s4), scene2)),\n        fXor1(s4, fXor1(scene1, scene3))\n    ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 50, 50, 177], [179, 179, 220, 220, 265], [267, 267, 296, 296, 335], [337, 337, 389, 389, 524], [526, 526, 547, 547, 781], [783, 783, 805, 805, 826], [828, 828, 859, 859, 879], [881, 881, 911, 911, 939], [941, 941, 972, 972, 1028], [1030, 1030, 1087, 1087, 2314]], "test": "ok"}
{"id": "XssBzH", "name": "Classic Plasma", "author": "DJDoomz", "description": "Hello world.", "tags": ["2d", "plasma"], "likes": 1, "viewed": 718, "published": "Public API", "date": "1494871977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//117 char version by FabriceNeyret2\nvoid mainImage( out vec4 O,  vec2 U ){\n\tU = 2.* sin (25.*U/iResolution.x);  \n    O = .5 + .5* sin( U.x+U.y + vec4(0,2.4,-2.4,0) +iTime);\n}\n\n\n/*\n//my original\n#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.x;\n    \n    float plasma = (sin(uv.x*25.)+sin(uv.y*25.))/.4 + .5;\n    \n    vec3 col = vec3(.5*sin((plasma)*PI/4.+iTime)+.5,\n                    .5*sin((plasma+3.)*PI/4.+iTime)+.5,\n                    .5*sin((plasma-3.)*PI/4.+iTime)+.5);\n\n\tfragColor = vec4(col,1.0);\n}\n*/\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 75, 75, 175]], "test": "ok"}
{"id": "XsScWc", "name": "grid of cubes", "author": "abje", "description": "many cubes, rendered with several ray-plane-intersections.", "tags": ["3d", "planeintersection"], "likes": 9, "viewed": 618, "published": "Public API", "date": "1494004832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**/\n\nfloat mid(vec3 p) {\n    p = min(p,p.yzx);\n    return max(max(p.x,p.y),p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    vec3 pos = vec3(0.0,0.0,iTime);\n    //the direction of the ray is made very simple, looks forward in positive z\n    vec3 dir = normalize(vec3(uv,1.0));\n    vec3 signdir = sign(dir);\n    //the length of the ray\n    float dist = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        //moves position to cube space(0,0,0 is between 8 cubes)\n        vec3 pos2 = mod(pos+1.0,2.0)-1.0;\n        \n        //planes is a bad variable name, but it contains the ray-plane distances/intersections to 3 planes, one for x, y and z\n        //i know that there is no cubes in x, y and z between -0.5,0.5,\n        //so if the ray points far forward it can jump pretty farin one step,\n        vec3 planes  = 0.75-pos2*signdir;\n        //if x, y or z is over 0.5 or under -0.5 i set its length to 0\n        planes *= step(abs(pos2),vec3(1.0));\n        //turns it from closest point distance to ray-plane intersection distance, you can comment this out if you want a distance field\n        planes /= dir*signdir;\n        //takes the longest distance,\n        //if you take not the longest, not the smallest but the middle you get a nice pattern, useful for menger sponge\n        float len  = max(max(planes.x,planes.y),planes.z);\n        //float len = mid(planes);\n        \n        //moves the ray position forward\n        pos += dir*len;\n        dist += len;\n        \n        //if it hits a cube it breaks out of the loop\n        if (len < 0.001) {\n            break;\n        }\n    }\n    //moves position to cube space(0,0,0 is in the middle of the cube)\n    vec3 pos2 = mod(pos,2.0)-1.0;\n    //finds the normal, finds the x,y or z furthest from 0, and checks if it is over or under 0\n    vec3 normal = vec3(greaterThan(abs(pos2),max(abs(pos2.yzx),abs(pos2.zxy))))*sign(pos2);\n    //colors the cubes with random colors, don't need to say more about this\n    fragColor = vec4((sin(pos*3.0+dist+iTime)*0.5+0.5)/(dist+1.0)*2.0+(normal*0.25+0.25),1.0);\n    //makes the color darker the farther the ray has traveled\n    fragColor *= 2./(2. + dist*dist*.0001);\n}\n/**/\n\n/**\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 pos = vec3(1.0,0.0,iTime);\n    \n    vec3 dir = normalize(vec3(uv,1.0));\n    vec3 signdir = sign(dir);\n    float dist = 0.0;\n    vec3 normal;\n    \n    //these 3 variables are used for \n    float hitcount = 0.0; //how many times the ray has reflected\n    float number = 1.0;   //divides by 2 everytime the ray hits\n    float number2 = 0.0;\n    for (int i = 0; i < 48; i++) {\n        \n        vec3 pos2 = mod(pos+1.0,2.0)-1.0;\n        vec3 num  = 0.5-pos2*signdir;\n        num *= step(abs(pos2),vec3(0.5));\n        num /= dir*signdir;\n        float len  = max(max(num.x,num.y),num.z);\n        \n        if (len < 0.001) {\n            hitcount++;\n            number *= 0.5;\n            number2 += number;\n            fragColor += vec4((sin(pos*3.0+dist+iTime)*0.5+0.5)/(dist+1.0)*2.0+normal*0.2,1.0)*number;\n            if (hitcount == 4.0) break;\n            \n            dir = reflect(dir,normal);\n            signdir = sign(dir);\n            pos += dir*0.1;\n        }\n        \n        normal = vec3(equal(vec3(len),num));\n        \n        pos += dir*len;\n        dist += len;\n    }\n    \n    fragColor /= number2;\n    fragColor *= 2./(2. + dist*dist*.001);\n    //fragColor = vec4(dot(normal,vec3(0.5,0.25,1.0)));\n\t//fragColor = vec4((sin(pos*3.0+dist+iTime)*0.5+0.5)/(dist+1.0)*2.0+normal*0.2,1.0);\n    //fragColor.xyz = normal;\n}\n\n/**/\n\n/**\n//golfed version by coyote 276 chars\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float d = 1., t = iTime, l = d;\n    \n    vec4 D = normalize(vec4(U+U - (O.xy=iResolution.xy), O.y ,0)),\n         p = D/D,\n         n;\n    p.z = t;\n\n    while (l > .001)\n        O = step(l,n)*.2,\n        n = mod(p,2.)-1.,\n        n = (.5*sign(D)-n)\n             * step(abs(n),.5+D-D)\n            / D,\n        l  = max(max(n.x,n.y),n.z),\n        p += D*l,\n        d += l;\n    \n\tO +=  (1.+sin(p*3.+d+t)) / d;\n}\n/**/\n\n//golfed version by FabriceNeyret2 283 chars\n/**\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float d = 1., t = iTime, l=1.;\n    \n    vec4 p = vec4(1,1,t,1),\n         D = normalize(vec4(U+U - (O.xy=iResolution.xy), O.y ,0)),\n         n;\n\n    while (l > .001)\n        O = step(l,n)*.2,\n        n = mod(p,2.)-1.,\n        n = (.5*sign(D)-n)\n             * step(abs(n),vec4(.5))\n            / D,\n        l  = max(max(n.x,n.y),n.z),\n        p += D*l,\n        d += l;\n    \n\tO +=  (1.+sin(p*3.+d+t)) / d;\n}\n/**/\n\n//golfed version with changed look 275 chars\n/**\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    float d = 0., t = iTime, l=1.;\n    \n    vec4 p = vec4(0,0,t,0),\n         D = normalize(vec4(U+U - (O.xy=iResolution.xy), O.y ,0)),\n         n;\n\n    while (l > .001)\n        O = step(l,n)*.2,\n        n = mod(p+1.,2.)-1.,\n        n = (.5*sign(D)-n)\n             * step(abs(n),vec4(.5))\n            / D,\n        l  = max(max(n.x,n.y),n.z),\n        p += D*l,\n        d += l;\n    \n\tO +=  (1.+sin(p*3.+d+t)) / (d+1.);\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsScWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 6, 25, 25, 83], [85, 85, 142, 142, 2286]], "test": "ok"}
{"id": "XssfDr", "name": "raym ortographic", "author": "anclin", "description": "raym ortographic", "tags": ["raymortographic"], "likes": 1, "viewed": 59, "published": "Public", "date": "1495744711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SceneSDF(vec3 p){\n    \n    p = rotateY(iTime * 0.5) * p;\n    \n    float final = CubeSDF(p, vec3(1));\n    \n    return final;\n}\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirectionOrto(){\n    return vec3(0,0,-1.0);\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for(int i = 0; i < 255; i++){\n    \tfloat dist = SceneSDF(eye + depth * marchingDirection);\n        if( dist <= EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirectionOrto();\n    \n    vec3 eye = vec3(-5.0 + 0.0 * cos(iTime),\n                    -5.0 + 0.0 * sin(iTime),\n                    0.0 + 0.0 * sin(iTime));\n    \n    /*\n    vec3 lookAtPos = vec3(0.0 + 0.0 * cos(iTime),\n                          0.0 + 0.0 * sin(iTime/2.0),\n                          0.0 + 0.0 * sin(iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    */\n    \n    float dist = ShortestDistanceToSurface(eye + vec3(fragCoord.xy / iResolution.xy * 10.0, 0), rayDir, 0.0, 1000.0);\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(1,0,0);\n    \n    //vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * rayDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    if( dist < MAX_DIST){\n    \tfinalColor = (normal + vec3(1.0)) / 2.0;\n        finalColor = finalColor * (diffuse + ambientColor);\n        finalColor = finalColor * remap(60.0, 20.0, 0.0, 1.0, dist);\n        //finalColor = vec3(1,0,0);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 136, 136, 206], [208, 254, 281, 281, 428], [430, 521, 567, 567, 599], [601, 685, 727, 727, 759], [761, 850, 897, 897, 930], [932, 932, 968, 968, 996], [998, 998, 1031, 1031, 1234], [1236, 1236, 1270, 1270, 1335], [1337, 1337, 1360, 1360, 1468], [1470, 1470, 1498, 1498, 1796], [1798, 1887, 1916, 1916, 2226], [2228, 2228, 2252, 2252, 2281], [2283, 2283, 2347, 2347, 2476], [2478, 2478, 2568, 2568, 2855], [2857, 3184, 3233, 3268, 3494], [3496, 3496, 3553, 3553, 4942]], "test": "ok"}
{"id": "XssfRn", "name": "Lights in the smoke", "author": "liamegan", "description": "Using cellular voronoi noise in fun ways", "tags": ["2d", "voronoi", "cellular", "cells", "cellularnoise"], "likes": 5, "viewed": 181, "published": "Public", "date": "1494611548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 cells(in vec2 uv) {\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    float m_dist = 2.;\n    float second_m_dist = 0.0;\n    float attr = 0.0;\n    \n    for( int y = -1; y<= 1; y++ ) {\n        for( int x = -1; x <= 1; x++ ) {\n            vec2 neighbour = vec2(float(x), float(y));\n            vec2 n = i_uv + neighbour;\n            vec2 point = random2(i_uv + neighbour);\n            vec2 point2 = random2(i_uv + neighbour);\n            vec2 point3 = random2(i_uv + neighbour);\n            point = 0.5 + 0.5*sin(iTime * 0.5 + 6.2831*point);\n            point2 = 0.5 + 0.5*sin(iTime * 0.253 + 9.2831*point2);\n            point3 = 0.5 + 0.5*sin(iTime * 0.1 + 3.2831*point3);\n            vec2 diff = neighbour + point - f_uv;\n            vec2 diff2 = neighbour + point2 - f_uv;\n            vec2 diff3 = neighbour + point3 - f_uv;\n            \n            m_dist = min(m_dist, length(diff)*m_dist);\n            m_dist = min(m_dist, length(diff2)*m_dist);\n            m_dist = min(m_dist, length(diff3)*m_dist);\n            \n        }\n    }\n    \n    attr = smoothstep(0.01, 0.999, second_m_dist);\n    \n    return vec4(sqrt(m_dist*5.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (gl_FragCoord.xy -.5 * iResolution.xy) / iResolution.y;\n//    uv.x -= iTime / 10.;\n    \n    fragColor = 1.-smoothstep(0., 0.9, cells(uv * 5.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 143, 143, 1272], [1274, 1274, 1331, 1331, 1488]], "test": "ok"}
{"id": "XssfRr", "name": "Sketch_TriLattice3", "author": "cexlearning", "description": "TriLattice3，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 3, "viewed": 127, "published": "Public", "date": "1494642829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 hue2rgb(float h)\n{\n    h = fract(h) * 6.0 - 2.0;\n    return clamp(vec3(abs(h - 1.0) - 1.0, 2.0 - abs(h), 2.0 - abs(h - 2.0)), 0.0, 1.0);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float sxf = fract(sx);\n    float offs = step(fract(1.0 - uv.y), sxf);\n    return vec2(floor(sx) * 2.0 + sxf + offs, uv.y);\n}\n\nfloat tri(vec2 uv)\n{\n    vec2 p = floor(uv2tri(uv));\n    p = vec2(p.x + p.y, p.y * 2.0);\n    float d = length(p + 1.0);\n    float f1 = 1.6 + sin(iTime * 0.5765) * 0.583;\n    float f2 = 1.3 + sin(iTime * 1.7738) * 0.432;\n    return abs(sin(f1 * d) * sin(f2 * d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float t = smoothstep(0.2, 0.8, fract(iTime));\n\n    vec2 uv = fragCoord.xy - iResolution.xy / 2.0;\n    uv *= (2.0 - t) / iResolution.y;\n\n    float c = mix(tri(uv * 4.0), tri(uv * 8.0), t);\n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XssfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 91], [93, 93, 116, 116, 236], [238, 238, 260, 260, 435], [437, 437, 457, 457, 701], [703, 703, 760, 760, 992]], "test": "ok"}
{"id": "XsSyDt", "name": "Iso Ritual", "author": "leon", "description": "Raymarching experiment about octahedron", "tags": ["raymarch"], "likes": 18, "viewed": 271, "published": "Public", "date": "1494273634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// training for modeling shapes\n// using koltes code as base https://www.shadertoy.com/view/XdByD3\n// using iq articles\n\n#define TAU 6.2831853\n#define t iTime\nmat2 rz2(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\nfloat iso (vec3 p, float r) { return dot(p, normalize(sign(p)))-r; }\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n\treturn mix(b,a,h) - r*h*(1.-h);\n}\n\nfloat map1 (vec3 p)\n{\n    float size = 1.;\n    p += vec3(0,-1.5,0);\n    float od = length(p);\n    p.xy *= rz2(t*.2);\n    p.yz *= rz2(t*.3);\n    p.xz *= rz2(t*.4);\n    float shape1 = max(-sphere(p,size+.1), iso(p,size));\n    p.xy *= rz2(t*1.2);\n    p.yz *= rz2(t*1.5);\n    p.xz *= rz2(t*2.);   \n    float shape2 = max(length(p)-size-.1, -iso(p,size));\n\treturn min(shape1, shape2);\n}\n\nfloat map2 (vec3 p)\n{\n    vec3 pr = p;\n    float count = TAU/5.;\n    float a = atan(pr.z,pr.x)+count*.5-t*.3;\n    float l = length(pr.xz)-.5;\n    a = mod(a,count)-count*.5;\n    pr.xz = vec2(cos(a),sin(a))*l;\n    float base = max(-sdBox(pr,vec3(1.7)),cube(pr,vec3(2.,1,.1)));\n    return smin(base, iso(pr-vec3(1.85,1,0),0.2),0.1);\n}\n\nfloat ripple (vec3 p)\n{\n    float a = atan(p.z,p.x);\n    float fade = 1.-smoothstep(1.,3.5,length(p));\n    float base = max(0.,p.y+(sin(a*16.+sin(length(p))*16.+t*2.))*.05*fade);\n    return max(base, -sphere(p,1.2));\n}\n\nfloat scene (vec3 p)\n{\n    float d = smin( map2(p), ripple(p), .9 );\n    d = max(sphere( p, 2.9 ), d);\n    d = min(map1( p ), d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv,-4)+vec3(0,1,0), rd = vec3(uv, 1.), mp = ro;\n    int i = 0;\n    const int count = 50;\n    fragColor = vec4(1);\n    for (;i<count;++i) {\n        float md = scene(mp);\n        if (md<0.0001) {\n            break;\n        }\n        mp += rd*md*.5;\n    }\n    float r = float(i)/float(count);\n\tfragColor *= smoothstep(0.5,3.,length(mp));\n\tfragColor *= smoothstep(0.0,7.,length(mp-ro));\n    fragColor *= r;\n  \t//fragColor = 1.-fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsSyDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 177, 177, 224], [226, 226, 258, 258, 280], [281, 281, 310, 310, 345], [346, 346, 375, 375, 414], [415, 415, 446, 446, 533], [534, 534, 574, 574, 651], [653, 653, 674, 674, 1034], [1036, 1036, 1057, 1057, 1367], [1369, 1369, 1392, 1392, 1587], [1589, 1589, 1611, 1611, 1734], [1736, 1736, 1793, 1793, 2307]], "test": "ok"}
{"id": "XsXBD8", "name": "BezierPathTest Multiple Paths 2", "author": "Sleicreider", "description": "This is for simulation purpose only. Works for multiple bezierpath points.\nIs an fixed version of an old implementation.\nNot optimized yet!!!", "tags": ["2d", "bezierpath"], "likes": 0, "viewed": 79, "published": "Public", "date": "1495803292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define YELLOW vec3(1.,1.,0.)\n#define BLUE vec3(0.,0.,1.)\n\nstruct Rect\n{\n    float width;\n    float height;\n    float x;\n    float y;\n    vec3  color;\n    float rotation;\n    \n    vec2 csys; //it's own coordinate system\n};\n   \nRect CreateRect(float width, float height, float x, float y, vec3 color)\n{\n    Rect rect;\n    \n    rect.width = width;\n    rect.height = height;\n    rect.x = x;\n    rect.y = y;\n    rect.color = color;\n    \n    return rect;\n}\n\nvoid DrawRect(inout Rect rect,vec2 p, inout vec3 pix)\n{\n    \n   \tfloat dx = p.x - rect.x;\n    float dy = p.y - rect.y;\n    \n    dx = cos(rect.rotation)*(p.x - rect.x) + sin(rect.rotation)*(p.y - rect.y);\n    dy = -sin(rect.rotation)*(p.x - rect.x) + cos(rect.rotation)*(p.y - rect.y);\n    \n    float fL = - rect.width/2.;  //far left\n    float fR = + rect.width/2.;  //far right\n    float fT = + rect.height/2.; //far top\n    float fB = - rect.height/2.; //far bottom\n\n    //anti-aliasing\n    float del;\n    del =  smoothstep(fL - 0.005, fL + 0.005,dx);\n    del *= 1. - smoothstep(fR - 0.005, fR + 0.005,dx);\n    del *=  smoothstep(fB - 0.005, fB + 0.005,dy);\n    del *= 1. - smoothstep(fT - 0.005, fT + 0.005,dy);\n    \n    float d = 0.005;\n    \n    if(dx > fL-d && dx < fR+d \n    && dy < fT+d && dy > fB-d)\n    {\n        pix = mix(pix,rect.color,del);\n    }\n    \n    rect.csys = vec2(dx,dy);\n}\n\nfloat GetPathCoord(float p1, float p2, float percent)\n{\n   return p1 + ((p2 - p1) * percent);\n}\n\nconst int NUM_PATHS = 6;\nvec2 BezierPaths[NUM_PATHS];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.* vec2(fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec3 pixel = vec3(0.);\n    \n\tBezierPaths[0] = vec2(0.,1.);\n    BezierPaths[1] = vec2(0.0,0.8);\n    BezierPaths[2] = vec2(0.,0.);\n    BezierPaths[3] = vec2(0.4,0.0);\n    BezierPaths[4] = vec2(0.45,0.0);\n\n    BezierPaths[5] = vec2(1.,0.);\n\n    \n    //Draw the bezier path points\n    \n    for(int i = 0; i < NUM_PATHS; i++)\n    {\n        Rect tmp_rect = CreateRect(0.05,0.05,BezierPaths[i].x, BezierPaths[i].y,YELLOW);\n        DrawRect(tmp_rect,r,pixel);\n    }\n     \n    float percent = (mod(iTime,4.0))/ 4.0;\n    \n    //Bezier path calculation for multiple paths\n\tint runs = NUM_PATHS-1;\n\tvec2 prev[NUM_PATHS];\n    \n   \tfor(int i = 0; i < NUM_PATHS; i++)\n    {\n        prev[i] = BezierPaths[i];\n    }\n    \n    vec2 tmp[NUM_PATHS];\n    for(int i = 0; i < runs; i++)\n    {\n        for(int k = 0; k < runs-i; k++)\n        {\n            tmp[k].x = GetPathCoord(prev[k].x , prev[k+1].x, percent);\n            tmp[k].y = GetPathCoord(prev[k].y , prev[k+1].y, percent);\n        }\n        \n        for(int k = 0; k < runs-i; k++)\n        {\n            prev[k] = tmp[k];\n        }\n    }\n    \n    //Draw Bezier Point which follows the path\n    Rect rp = CreateRect(0.05,0.05,tmp[0].x,tmp[0].y,BLUE);\n\tDrawRect(rp,r,pixel);\n\n    fragColor = vec4(pixel,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 301, 301, 451], [453, 453, 508, 508, 1347], [1349, 1349, 1404, 1404, 1444], [1501, 1501, 1558, 1558, 2876]], "test": "ok"}
{"id": "XsXBRr", "name": "Go in mandelbrot set", "author": "mjdr", "description": "Simple fractal shader.", "tags": ["mathfractal"], "likes": 1, "viewed": 70, "published": "Public", "date": "1494514924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int n = 1250;\n    \n    float t = iTime;\n    \n    vec2 point = (fragCoord) - iResolution.xy/2.0;\n    vec2 x = point/exp(t) - vec2(1.483,0.0);\n    \n    vec2 y = x;\n    int k = 0;\n    for(int h = 0;h < n;h++){\n        if(length(y) > 2.0)\n            break;\n        \n        vec2 yn = vec2(y.x*y.x - y.y*y.y, 2. * y.x * y.y) + x;\n        y = yn;\n        k++;\n    }\n    \n    \n    fragColor = vec4(vec3(pow(float(k)/float(n),1.)),1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 506]], "test": "ok"}
{"id": "XsXBWH", "name": "honeycomb insideout", "author": "ollj", "description": "distance field displacement by honeycomb foam tessellation\n\nIs a  more structured branch of \nhttps://www.shadertoy.com/view/ltXGWS\nwhich did not use a lot of its contained potential\nand i prefer h=max(h,-(h+cells(o)))\nover           h=max(h,+(h+cells(o)))", "tags": ["3d", "tiled", "tilings", "honeycomb", "tiling", "tesselation", "foam", "tiles", "filling"], "likes": 5, "viewed": 985, "published": "Public API", "date": "1495808454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//parent: https://www.shadertoy.com/view/ltXGWS\n\n//ended up warping the df() distanceField \n//..within the rm() Raymarch function.\n\n//radius (and thickness)\n//...of (a mix of a sphere and a cylinder) that bounds the volume.\n#define radius 3.\n//that volume then gets \"filled with\" \n//...honeycomb-tesselation holes (or spheres).\n\n//displace the distance Field by DISPLACE*honeycomb\n//(and not just textures it), intended range [-1..1]\n//remove for better performance\n#define DISPLACE 1.\n//With small DISPLACE, a lot of camera positions \n//...are inside the signed distance field (negative distance)\n\n//uncomment to toggle between boolean [difference] or [intersect]\n//#define intersection\n//above gets pretty much obsoleted by [HoleScaling]\n\n//size of holes (or spheres)=distance_to_surface*HoleScaling\n#define HoleScaling 1.2\n//range [-0.5 .. -2.0] OR range [0.5 .. 2.0]\n//HoleScaling outside that rande is too bad for lipschitz continuity.\n\n//larger reciprocalCellScale make holes smaller\n#define reciprocalCellScale 2.\n//honeycomb scaling == 1/reciprocalCellScale\n\n\n//for performance:\n\n//maximum raymarch steps.\n#define rmItteratons 255\n\n//its almost strange how a larger epsilon looks better.\n//...with a honeycomb displacement\n#define eps 1e-3\n\n//scale raymarch steps by ReciprocalLipschitz\n#define ReciprocalLipschitz .3\n//lipschitsConstant=abs(firstDerivative(x));\n//global (or local) lipschitsConstant is not defined for point x,\n//...but is the max() of ANY x,range [a..b] or range [-inf...+inf].\n//Multiplying raymarchStepDistances by\n//...the reciprocal of an ESTIMATION of a global lipschitsConstant\n//...is the lazy way to avoid overestimation of raymarch step distances.\n\n//the smart solution would be \"automatic differenciation\" \n//...returning you the exact lipschitzConstant for every step.\n\n\n\n//return 3d honeycomb, distance to closest \"white tile\" of checkerboard tiling\nfloat cells(vec3 p){p=fract(p/2.)*2.;p=min(p,2.-p );    \n return min(length(p),length(p-1.));}\n\n//return distance field. actually, rm() modifies this A LOT\nfloat df(vec3 p){float a=1.5-length(p.xy);\n float b=(length(p.xz)-abs(p.y)+.4);\n float r=min(a,b*.2);return r;}\n\n//raymarch, return position were ray hits surface\nvec3 rm(vec3 o,vec3 d,out float h){float m=(cos(iTime*.61*.1)*.5+.5);\n for(int i=0;i<rmItteratons;i++){h=length(o)-radius;float a=df(o);\n  h=mix(a,max(h,a),m);//first displacement\n  #ifdef DISPLACE\n   float displace=h;\n   #ifdef intersection\n    displace=max(h,+(h+(cells(o*reciprocalCellScale)-.7)*HoleScaling)*ReciprocalLipschitz);//lipschitsConstant==5.0?                \n    //above does intersection: [h AND     h+cells()] max(a,+b)\n   #else\n    //below does difference:   [h AND NOT h+cells()] max(a.-b)\n    displace=max(h,-(h+(cells(o*reciprocalCellScale)-.7)*HoleScaling)*ReciprocalLipschitz);//lipschitsConstant==5.0?                \n   #endif\n   h=mix(h,displace,DISPLACE);//sedond displacement\n  #endif\n  o+=d*h;if(h<eps)return o;}return o;}\n\n//return RayPos for [U]FragmentPos,and set [d]RayDirection\nvec3 cam(vec2 U,out vec3 d){\n vec2 h=iResolution.xy/2.;\n d=normalize(vec3(U.xy-h,h.y*2.));\n vec2 r=vec2(0);//2 rotations around 2 axes\n if(iMouse.z >.0)r+=vec2(-2,3)*(iMouse.yx/h.yx-1.);//mouse cam\n else r.y=iTime*.3;//auto cam\n vec2 c=cos(r),s=sin(r);\n d.yz=vec2(-1,1)*d.zy*s.x+d.yz*c.x;//2d rotation\n d.xz=vec2(1,-1)*d.zx*s.y+d.xz*c.y;//2d rotation\n return vec3(-c.x*s.y,s.x,-c.x*c.y)*8.;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){O=vec4(0);\n vec3 d,p=cam(U,d);//camera [o]origin [d]direction [U]fragCoord                                          \n float h=0.;p=rm(p,d,h);//raymarch [h]distanceToSurface\n #ifndef intersection\n  if(h<eps){//conditional only makes sense for intersection\n #endif\n  vec3 a=step(.5,fract(p*reciprocalCellScale/2.0-.25));\n  vec3 b=vec3(cells(p*reciprocalCellScale)/1.3);\n O.rgb=mix(a,b,sin(iTime)*.2+.8);}\n #ifndef intersection\n  }\n #endif\n\n// Ben Quantock 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1810, 1889, 1909, 1909, 1983], [1985, 2045, 2062, 2062, 2156], [2158, 2208, 2243, 2243, 2960], [2962, 3021, 3049, 3049, 3413]], "test": "ok"}
{"id": "XsXBzM", "name": "simple Starfield", "author": "dpkaminski", "description": "modified Version of https://www.shadertoy.com/view/4ljXDt", "tags": ["2d", "starfield"], "likes": 14, "viewed": 545, "published": "Public", "date": "1495207954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modified version of https://www.shadertoy.com/view/4ljXDt\n\nfloat Cell(vec2 c) {\n\tvec2 uv = fract(c);c -= uv;\n\treturn (1.-length(uv*2.-1.)) * step(fract(sin(c.x+c.y*1e2)*1e3), .04);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy -.5;\n\tfloat a = fract(atan(p.x, p.y) / 6.2832);\n\tfloat d = length(p);\n\tfloat z = iTime / 1.5;\n    vec3 col;\n    \n    for(int i=0; i<3 ;i++)\n\t{\n    \tz += 0.02;\n\t\tvec2 coord = vec2(pow(d, .04), a)*256.;\n\t\tvec2 delta = vec2(1. + z*20., 1.);\n\t\tfloat c = Cell(coord-=delta);\n\t\tc += Cell(coord-=delta);\n        col[i]=c*d*3.;\n    }    \n\t\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 81, 81, 184], [186, 186, 243, 243, 643]], "test": "ok"}
{"id": "XsXfD4", "name": "fit periodic mod()ulations", "author": "ollj", "description": "mouse input!\nsimpler while \"paused\" -> no phase shifting\n\nmay be useful for shadertoy audio.\nthinking of tessellating the music_sheet rather than checking EVERY sheet_note for every moment in time.\n\ni might be missing something obvious as i am no expert.", "tags": ["filter", "audio", "tiling", "tile", "tesselation", "modulation"], "likes": 1, "viewed": 482, "published": "Public API", "date": "1496141577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define zoom 3.\n#define frame(u) zoom*(u-.5*iResolution.xy)/iResolution.y\n\n/*\nIf you put a period inside another period, for tiling tesselation.\nEg: If you want to play a sine wave of a set wavelength \n... for a limited (or tiled) amount of time (==note duration).\nYou have the problem of a tiling suddenly breaking mix-tile,\n...that fourier-transforms into one high pitch cracking-noise at the end\n...that is usually filtered lazily with a band-filter (overkill)\n...or dealt with by fading it into silence (lazy (physical piano solution)).\n\nHaving a periodic wave only stop when f(x)=0,\n... and defining a period.y's start=end=f(x)=0, (like sin(x))\n... avoids this high pitch cracking-noise at the end.\n\nyou just calculate how man times a smaller tile fits into a larger tile.\nvia howManyAfitInB() and use that within the packsin() filter.\n*/\n\n//return how many times period [a] fits into period [b].\nfloat howManyAfitInB(float a, float b){if(a==0.)return 0.;return floor(b/a);}\nfloat howManyFitIn(float a){if(a==0.)return 0.;return floor(1./a);}\n\n//if (x < largest_possible_stack_of_interval_p ) return 1; return 0; //[p]PeriodLength (wavelength)\nfloat packsin(float x,float p){return step(abs(x),p*howManyFitIn(p));}\n//is oblivious about negative input ranges.\n\n#define tau acos(-1.)*2.\n\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U);\n vec2 m=frame(iMouse.xy);\n float d;  \n m.x=fract(m.x);//if(out of bounds) beter have strange (but save) things happen than nothing happen. (derivative_voids are boring)\n m.x=max(.001,abs(m.x));//skipping \"0\"\n float w=u.x;//modifying a copy of u.x\n w+=sin(iTime*.1);//phase shift the whole thing\n d=packsin(w,m.x);//a filter;\n d*=sin(w/m.x*tau);//a periodic waveform.\n d-=u.y;\n d=smoothstep(.01,-.01,abs(d)-.1);\n u=fract(u);\n O=vec4(d,u,1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[845, 902, 941, 941, 979], [980, 980, 1008, 1008, 1047], [1049, 1149, 1180, 1180, 1219], [1291, 1291, 1328, 1328, 1786]], "test": "ok"}
{"id": "XsXfD8", "name": "Grid AA using sin()", "author": "etale_cohomology", "description": "Fork of https://www.shadertoy.com/view/MlVSDW", "tags": ["grid", "antialiasing"], "likes": 0, "viewed": 206, "published": "Public", "date": "1495805351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of https://www.shadertoy.com/view/MlVSDW\n\n// Sadly, this grid doesn't admit nonlinear transformations without shearing like crazey!\n// Anyone know how to fix that?\n\n#define ZOOM_FACTOR 4.\n#define ZOOM_SPEED  (iTime * .5)  // Set this to 0. or 1. or -1., for instance\n#define PI          3.14159\n\nfloat draw_grid(vec2 uv){\n  float zoom = ZOOM_FACTOR * (1. + sin(ZOOM_SPEED));\n\n  float antialias = 12. * zoom / iResolution.y;\n  vec2 grid_2D = smoothstep(antialias, .0, abs(sin(PI * zoom * uv)));\n\n  return max(grid_2D.x, grid_2D.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\t// Center & normalize pixel coordinates!\n  uv = mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime)) * uv;  // Left-multiplication by a unit-complex number!\n\n  float grid = draw_grid(uv);\n  fragColor.rgb = vec3(grid);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 329, 329, 540], [542, 542, 596, 596, 880]], "test": "ok"}
{"id": "XsXfWn", "name": "Rythm Bubble", "author": "jfranmp", "description": "Click to move the bubble!", "tags": ["bubble"], "likes": 0, "viewed": 81, "published": "Public", "date": "1495542673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float angle(vec2 point, vec2 center) {\n    float tmp = atan(point.y - center.y, center.x - point.x);\n    return (degrees(tmp) + 180.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 center = vec2(.5, .5) * iResolution.xy;\n    vec2 center = iMouse.xy;\n    vec2 point = fragCoord;\n    float ang = angle(point, center);\n    float amp = 20.0 * texture(iChannel0, vec2(ang / 360.0, 0)).x;\n    \n    float dist = distance(fragCoord, center);\n    float base = 100.0;\n    float freq = 5.0f;\n    float size = 5.0 + 5.0 * (sin(freq * 2.0 * 3.1415 * ang / 360.0 + 5.0*iTime) *.5 + .5);\n\n    if (dist < base + size / 2.0 + amp && dist > base - size / 2.0) {\n        //float r = sin(ang / 360.0 + 2.0 * iTime) * .5 + .5;\n        float r = ang / 360.0;\n    \tfloat g = sin(ang / 360.0 + 1.2 * iTime) * .5 + .5;\n    \tfloat b = 1.0;\n    \tfragColor = vec4(0,1,1,1.0);\n    }  \n    else {\n        fragColor = vec4(0,0,0,1.0);\n    }\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 137], [139, 139, 196, 247, 938]], "test": "error"}
{"id": "XsXfWr", "name": "Simple sunset", "author": "voidc", "description": "My first shader!", "tags": ["2d"], "likes": 1, "viewed": 115, "published": "Public", "date": "1495567149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec2 p)\n{\n    return texture(iChannel0, p / 32.0).r;\n}\n\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5 * noise(p); p *= m*2.01;\n    f += 0.25 * noise(p); p *= m*2.03;\n    f += 0.125 * noise(p); p *= m*2.02;\n    f += 0.0625 * noise(p); p *= m*2.04;\n    return f / 0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0 * coord - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float h = 1.0 - 2.0 * iTime / 15.0;\n    float r = length(vec2(p.x, p.y - h));\n    \n    vec3 col = vec3(1.0,0.8,0.6);\n    if(r < 0.6)\n    {\n        vec3 sun = vec3(0.8,0.6,0.0);\n        float f = fbm(5.0*p);\n        sun = mix(sun, vec3(0.8,0.2,0.0), f);\n        col = mix(col, sun, 1.0-smoothstep(0.55, 0.6, r));\n    }\n    col = log(col / log(1.0+r));\n    \n    vec3 stars = texture(iChannel1, p / 3.0).rgb;\n    col = mix(col, stars, smoothstep(0.6, 1.5, r));\n    \n    col *= smoothstep(-0.5, 0.0, p.y - 0.1 * p.x * p.x);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 66], [104, 104, 123, 123, 325], [327, 327, 384, 384, 1068]], "test": "error"}
{"id": "XsXfzN", "name": "Fractal Brownian Motion Techno", "author": "DonKarlssonSan", "description": "FBM Techno\nMusic: https://soundcloud.com/drumcode/ramiro-lopez-september", "tags": ["fbm", "audio", "techno"], "likes": 9, "viewed": 480, "published": "Public", "date": "1494973541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex 2D noise\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// Fractal Brownian Motion from https://www.shadertoy.com/view/lsl3RH\n// By inigo quilez\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * snoise(p); \n    p = m*p*2.02;\n    f += 0.2500 * snoise(p); \n    p = m*p*2.03;\n    f += 0.1250 * snoise(p); \n    p = m*p*2.01;\n    f += 0.0625 * snoise(p);\n    return f/0.9375;\n}\n\n////// My code below\n\n\nfloat getAverage(float start, float end) {\n    float sum = 0.0;\n    int count = 0;\n    for(float i = start; i < end; i += 1.0/512.0) {\n        sum += texture(iChannel0, vec2(i, 0.25)).x;\n        count++;\n    }\n    float average = sum/float(count);\n    return average;\n}\n\nvec2 liquid(vec2 uv) {\n    float t0 = iTime / 2.0;\n    float bass = getAverage(0.001, 0.04);\n    float mids = getAverage(0.3, 0.6);  \n    float highs = getAverage(0.8, 1.0);  \n    float t = t0 + mids / 4.0;\n    float s1 = fbm(uv + t / 2.0 + fbm(uv + fbm(uv + (t + highs) / 4.0) / 10.0));\n    float s2 = fbm(uv + s1 + bass * 1.5);\n    \n    float f = sin(t0);\n    float f2 = sin(t0 * 2.3);\n    return vec2(mix(s1, s2, f), mix(s2, s1, f2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 liq = liquid(uv);\n\tfragColor = vec4(0.0, liq, 1.0);\n}", "image_inputs": [{"id": "XdXSzN", "previewfilepath": "https://soundcloud.com/drumcode/ramiro-lopez-september", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/drumcode/ramiro-lopez-september", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 116, 116, 155], [157, 157, 178, 178, 998], [1139, 1139, 1158, 1158, 1373], [1398, 1398, 1440, 1440, 1667], [1669, 1669, 1691, 1691, 2108], [2110, 2110, 2167, 2167, 2275]], "test": "error"}
{"id": "XtySDz", "name": "Shadertoy 튜토리얼 한글번역", "author": "ho4040", "description": "Korean version of https://www.shadertoy.com/view/Md23DV ", "tags": ["tutorial", "korean"], "likes": 7, "viewed": 1040, "published": "Public API", "date": "1495767973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n원문 : https://www.shadertoy.com/view/Md23DV \n번역 : General Choi (github: ho4040)\n\n안녕하세요, 한달전에 GLSL을 시작했습니다. GPU를 이용한 빠른 리얼타임 그래픽들이 놀랍네요.\n쉐이더를 작성하는 것을 배우고 싶으신 분들께 이 튜토리얼은 좋은 시작점이 될 겁니다.\n단어에러나 코딩에러가 있다면 고쳐주세요. :-)\n\n*/\n\n// 아래 번호를 바꾸고 다시 컴파일하면 튜토리얼을 선택할 수 있습니다.\n#define TUTORIAL 0\n\n/* 튜토리얼 목록\n 1 빈 화면.\n 2 균일 색상.\n 3 GLSL 벡터\n 4 RGB 색상 모델과 벡터의 요소들\n 5 좌표계\n 6 해상도와 프레임 사이즈 \n 7 좌표게 변환\n 8 수평선, 수직선\n 9 VISUALISING THE COORDINATE SYSTEM\n10 MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n11 MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n12 DISK\n13 FUNCTIONS\n14 BUILT-IN FUNCTIONS: STEP\n15 BUILT-IN FUNCTIONS: CLAMP\n16 BUILT-IN FUNCTIONS: SMOOTHSTEP\n17 BUILT-IN FUNCTIONS: MIX\n18 ANTI-ALIASING WITH SMOOTHSTEP\n19 FUNCTION PLOTTING\n20 COLOR ADDITION AND SUBSTRACTION\n21 COORDINATE TRANSFORMATIONS: ROTATION\n22 COORDINATE TRANSFORMATIONS: SCALING\n23 SUCCESSIVE COORDINATE TRANSFORMATIONS\n24 TIME, MOTION AND ANIMATION\n25 PLASMA EFFECT\n26 TEXTURES\n27 MOUSE INPUT\n28 RANDOMNESS\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#if TUTORIAL == 1\n// 빈화면.\n//\n// \"main\" 함수는 쉐이더 효과를 출력하기 위해서 매초 마다 수십회 호출됩니다. \n// 컴퓨터 시스템은 초당 60 프레임(60FPS)을 출력하려고 노력합니다.\n// 하지만 GLSL 스크립트가 계산이 빡세지면 이 숫자는 더 낮아질 수 있습니다.\n// (FPS는 화면 아래쪽 정보 바 에 표시됩니다.)\n//\n// 우리가 아무것도 안할거기 때문에 이 쉐이더는 그냥 검은 화면을 보여줍니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#elif TUTORIAL == 2\n// 균일 색상\n//\n// \"fragColor\" 는 쉐이더의 출력입니다.\n// 이 값이 화면에 보여지는 이미지를 결정하게 됩니다.\n// 이 쉐이더는 이 값을 노란색으로 지정합니다.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1.0, 1.0, 0.0 ,1.0);\n}\n\n\n#elif TUTORIAL == 3\n// GLSL 벡터들\n// \n// \"fragColor\" 는 vec4 객체에 할당되어야 합니다.\n// 이건 0~1 사이 실수 값이 담긴 4개 짜리 배열 입니다.\n// 앞에 3 개의 숫자는 색상을 지정 하고 4번째 숫자는 \n// 불투명도(opactiy) 를 지정 합니다.\n// (당장은 4 번째 투명도 값은 아무런 효과도 없습니다.)\n// 하나의 vec2 객체는 4개의 float 을 인자로 받아 생성되거나.\n// 아래처럼, vec3 와 float. 2개의 인자를 생성자 인자로 받아 생성됩니다.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Here we are seperating the color and transparency parts\n\t// of the vec4 that represents the pixels.\n\tvec3 color = vec3(0.0, 1.0, 1.0);\n\tfloat alpha = 1.0;\n\t\n\tvec4 pixel = vec4(color, alpha);\n\tfragColor = pixel;\n}\n\n#elif TUTORIAL == 4\n// RGB 색상 모델 과 벡터의 구성요소들\n//\n// 벡터를 초기화 하고나면, 각 요소들은 \".\" 표현을 이용해서 접근 할 수 있습니다.\n//\n// RGB: http://en.wikipedia.org/wiki/RGB_color_model\n// 색상 하나는 3개의 숫자(0부터 1사이 값)로 표현됩니다. \n// 이 모델은 순수한 빨강, 초록, 파랑 색의 빛을 각각 강도를 달리 하여 합한 것으로 취급합니다.\n// \n// 만약에 저처럼 디자인 스킬이 후지고, 색상의 조합이 간지나게 만들기가 힘들다면\n// 이 웹사이트들을 참고해보세요 여러가지 색상 조합을 살펴 볼 수 있습니다.\n// https://kuler.adobe.com/create/color-wheel/\n// http://www.colourlovers.com/palettes\n// http://www.colourlovers.com/colors\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// 아래 숫자들을 바꿔가며 놀아보세요:\n\tfloat redAmount = 0.6; // 빨간색의 세기\n\tfloat greenAmount = 0.2; // 초록색의 세기\n\tfloat blueAmount = 0.9; // 파란색의 세기\n\t\n\tvec3 color = vec3(0.0); \n\t\n\t// 이건 인자 하나만 쓰는 세번째 벡터 생성 방법입니다.\n\t// \"vec3(x)\" 은 \"vec3(x, x, x)\" 랑 똑같습니다.\n\t// 이 벡터는 아래 방법으로 초기화 했습니다.\n\t// color.x = 0.0, color.y = 0.0; color.z = 0.0;\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\t\n\tfloat alpha = 1.0;\n\tvec4 pixel = vec4(color, alpha);\t\n\tfragColor = pixel;\n}\n\n\n#elif TUTORIAL == 5\n// 좌표계\n//\n// \"fragCoord\", \"fragment coordinate\" 는 입력 변수입니다.\n// 이걸 통해서 지금 계산하는 값이 어느 위치에 보여줄 픽셀인지 알 수 있습니다.\n// 이 좌표계의 중심은 좌측 하단 이고 오른쪽 상단이 값이 증가하는 방향입니다.\n// \n// main 함수는 는 화면의 모든 픽셀에 대응되어서 실행이 됩니다.\n// 각 호출에서 \"gl_FragCoord\"는 각 픽셀의 위치에 해당합니다.\n//\n// GPUs 는 여러개의 코어를 가지고 있어서 동시에 병렬 호출되어고 여러개의\n// 픽셀이 동시에 계산되는게 가능합니다.\n// 따라서 CPU에서 하나 하나씩 계산하는 것보다 빠른 속도를 보여줄 수 있습니다.\n// 하지만 이 때문에 여기에는 중요한 제약이 따라옵니다.\n// 하나의 픽셀값은 다른 픽셀값에 의해서 결정 될 수 없습니다. (각 픽셀이 동시에 병렬로 \n// 계산이 되기 때문에 어떤 픽셀이 먼저 계산 될지 알 수 엇습니다.)\n// 픽셀의 출력은 픽셀의 좌표에 의해 결정됩니다. (그리고 추가 다른 인풋들)\n// 이것이 쉐이더 프로그래밍에서 가장 중요한 차이점입니다. 이 것을 아마 계속 마주치게 될 것 입니다.\n//\n// 균일 색상이 아닌 뭔가를 그려보도록 하죠.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// 생상을 선택합니다.\n\tvec3 color1 = vec3(0.886, 0.576, 0.898);\n\tvec3 color2 = vec3(0.537, 0.741, 0.408);\n\tvec3 pixel;\n\n\t// x 좌표가 100 보다 크면 color1을 찍습니다.\n\t// 아니면 color 2를 찍습니다.\n\tfloat widthOfStrip = 100.0;\n\tif( fragCoord.x > widthOfStrip ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 6\n// 해상도, 프레임 사이즈\n//\n// 브라우저 크기를 조절하거나 풀스크린모드로 갔다가 돌아오면\n// 첫번째 색과 두번째색 폭의 비율이 달라지는 걸 볼 수 있습니다.\n// 이건 화면 비율에 따라서 값을 지정하지 않고 몇 픽셀인지 절대값을 지정하기 때문입니다.\n// \n// 우리가 두가지 색으로 화면을 이등분 한다고 해보면,\n// 화면 크기를 알기 전까지는 몇 픽셀로 해야할지 결정을 할 수가 없게 됩니다.\n//  \n// 어떻게 화면 크기(폭과 높이)를 픽셀단위로 얻어올까요.\n// 이건 \"iResolution\" 이라는 변수로 주어지게 됩니다.\n// \"iResolution.x\" 는 화면 프레임의 폭\n// \"iResolution.y\" 는 화면 프레임의 높이가 됩니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(0.741, 0.635, 0.471);\n\tvec3 color2 = vec3(0.192, 0.329, 0.439);\n\tvec3 pixel;\n\n\t// if 문 대신 3항 연산자로 편하게 표현합니다.\n\t// x 좌표가 화면 폭의 절반이 넘어가면 color1을 사용하고\n\t// 아니면 color2를 사용.\n\tpixel = ( fragCoord.x > iResolution.x / 2.0 ) ? color1 : color2;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 7\n// 좌표계 변형\n// 화면 좌표 시스템 보다는 우리가 직접 지정한 좌표계가 \n// 더 편한 경우가 대부분일겁니다.\n//\n// \"fragCoord\"라는 화면의 절대좌표계 대신에\"r\" 이라는 새로운 좌표계를 만들겠습니다.\n// \"r\" 에서는 x값과 y값은 는 0 에서 1 사이 값을 가집니다.\n// x값이 0 이면 좌측끝을 1이면 우측끝을 의미합니다. y 값이 0이면 아래쪽끝을\n// 1이면 위쪽끝을 의미합니다.\n//\n// \"r\" 을 사용하여 화면을 3 둥분 하도록 하겠습니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\t\n\t// r 은 vec2 입니다. 이 벡터의 첫번째 값(x값) 픽셀의x값(fragCoord.x)값을 화면폭으로 나눈 값 입니다.\n\t// 벡터의 두번째 값(y값)은 픽셀위치(fragCoord.y) 을 화면 높이로 나눈 값 이니다.\n\n\t// 예를들어, 제 노트북에서는, 전체화면시 화면크기는 \n\t// 1440 x 900 입니다. 그래서 iResolution 은 (1440.0, 900.0) 이 됩니다.\n\t// 한 프레임을 그리기 위해서 1400*1900=1296000 번이나 메인함수가 호출되어야 합니다.\n\t// fragCoord.x 는 0에서 1439 사이의 값을 가질 수 있을 것이교\n\t// fragCoord.y 는 0에서 899, r.x 와 r.y는 0에서 1 사이 값 이 될 것입니다.\n\t\n\tvec3 color1 = vec3(0.841, 0.582, 0.594);\n\tvec3 color2 = vec3(0.884, 0.850, 0.648);\n\tvec3 color3 = vec3(0.348, 0.555, 0.641);\n\tvec3 pixel;\n\t\n\t\n\t// 1:1:1 로 화면비율에 따라서 색을 지정합니다.\n\t// (역주) 원글에 주석이 잘못달려있네요.\n\n\tif( r.x < 1.0/3.0) {\n\t\tpixel = color1;\n\t} else if( r.x < 2.0/3.0 ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color3;\n\t}\n\t\t\t\n\t// pixel = ( r.x < 1.0/3.0 ) ? color1 : (r.x<2.0/3.0) ? color2: color3;\n\t// 위처럼 3항 연산자를 이용해서 간단하게 표현도 가능합니다.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 8\n// 수평선과 수직선\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t// 짧은 버젼의 좌표계번환.\n\t// \"aVector.xy\" 은 \"aVector\" 의 처음 두번째 요소로 만들어진 새로운 벡터입니다. \n\t// 그리고 나누기 연산을 벡터끼리 하게되면\n\t// 첫번째 벡터의 각 요소는 두번째 벡터의 각 요소로 나누어 지게 됩니다. (x는 x끼리 y는 y끼리)\n\t// 그래서 이 튜토리얼의 첫번째줄은 이전 튜토리얼의 첫번째 줄과 같습니다.\n\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(0.216, 0.471, 0.698);\n\tvec3 color2 = vec3(1.00, 0.329, 0.298);\n\tvec3 color3 = vec3(0.867, 0.910, 0.247);\n\t\n\t// 먼저 배경색(backgroundColor)을 지정합니다. 다른 색이 사용되지 않으면 이 색을 사용합니다.\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// 현재 픽셀의 x값이 아래 값들의 사이 값 이라면 color1 을 사용합니다.\n\t// 0.55와 0.54의 차가 라인의 폭을 결정하게 됩니다.\n\t\n\tfloat leftCoord = 0.54;\n\tfloat rightCoord = 0.55;\n\tif( r.x < rightCoord && r.x > leftCoord ) pixel = color1;\n\t\n\t\n    // 수직선을 다른 방식의 표현한 것 입니다.\n    // x 좌표와 두께 를 이용한 표현:\n\tfloat lineCoordinate = 0.4;\n\tfloat lineThickness = 0.003;\n\tif(abs(r.x - lineCoordinate) < lineThickness) pixel = color2;\n\t\n\t// 수평선\n\tif(abs(r.y - 0.6)<0.01) pixel = color3;\n\t\n\t// 3번째 수평선이 위의 두 선 위로 어떻게 지나가는지 확인해보세요.\n\t// 마지막으로 \"pixel\" 값이 지정되었기 때문에 제일 위에 놓인 선이 됩니다.\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 9\n// 좌표계 시각화\n//\n// for 루프와 수평선, 수직선을 이용하여 그리드(격자무늬) 그려보도록 하겠습니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// 배경색을 지정하면서 시작합니다. 만약에 다른 값으로 할당 되지 않으면\n\t// 이 색이 화면에 보여지게 됩니다.\n\tvec3 pixel = backgroundColor;\n\t\n\t// 그리드의 선을 그립니다.\n\t// 루프는 상수 표현으로만 조절 할 수 있어서 'const' 를 사용하게 됩니다.\n\tconst float tickWidth = 0.1;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\t// \"i\" 라인 좌표입니다.\n\t\tif(abs(r.x - i)<0.002) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.002) pixel = gridColor;\n\t}\n\t// 축을 그립니다.\n\tif( abs(r.x)<0.005 ) pixel = axesColor;\n\tif( abs(r.y)<0.006 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 10\n// 좌표계 중심을 프레임중심으로 옮기기\n//\n// [0, iResolution.x]x[0, iResolution.y]영역 대신\n// [0,1]x[0,1]영역을 [-1,1]x[-1,1] 로 맵핑합니다.\n// 이 방법을 쓰면 (0,0)은 왼쪽 하단이 아니고 화면 중앙이 됩니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tr = 2.0 * r.xy / iResolution.xy;\n\t// [-0.5*iResolution.x, 0.5*iResolution.x] -> [-1.0, 1.0]\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// 배경색을 지정하면서 시작합니다. 만약에 다른 값으로 할당 되지 않으면\n\t// 이 색이 화면에 보여지게 됩니다.\n\tvec3 pixel = backgroundColor;\n\t\n\t// 그리드를 출력.\n\t// 이번에는 루프를 이용해 모든 픽셀을 검사하지 않고\n    // 나머지 연산을 이용해서 한번의 계산으로 같은 결과를 얻어보겠습니다. (mikatalk님 감사합니다.)\n\tconst float tickWidth = 0.1;\n\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n    if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n    // Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 11\n//좌표계에 화면비율 만들기 1.0\n//\n// 이전 예제에서는 화면에 정사각형이 그려지지 않고 직사각형이 그려지게 됩니다.\n// 이것은 수치적으로는 [0,1]로 두 축이 같지만 물리적 거리는 다르기 때문입니다.\n// 사실 가로가 세로보다 더 큽니다.\n// 따라서 화면비율을 유지하기 위해서는 실제 거리인 \n// [0,iResolution.x] 와 [0, iResolution.y] 를 같은 간격으로 맵핑하면 안됩니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 2.0 * r.xy / iResolution.y;\n\t// r.x를 iResolution.x 로 나누고 r.y를 iResolution.y로 나누는 것 대신\n\t// 둘다 iResolution.y로 나눕니다.\n\t// 이 방법으로 하면 r.y는 [-1.0, 1.0] 이 되고\n\t// r.x 는 프레임 사이즈에 따라 달라지게 됩니다.\n\t// 전체화면이 아닌 경우에는 r.x 는 [-1.78,1.70] 정도일거고, 제가 가진 노트북 전체화면 모드에선\n\t// [-1.6, 1.6]이 됩니다.(1440./900=1.6)\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// 그리드를 그립니다.\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" 는 라인의 좌표입니다.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// 축을 그립니다.\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 12\n// DISK\n//\n// Let's draw disks\n//\n// So, in GLSL we don't give a command of \"draw this disk here with that\n// color\". Instead we use an indirect command such as \"if the pixel \n// coordinate is inside this disk, put that color for the pixel\"\n// The indirect commands are a bit counter intuitive until you\n// get used to that way of thinking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\t// To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n\tfloat radius = 0.8;\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n\t\tpixel = col1;\n\t}\n\t\n\t// There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\tif( length(r) < 0.3) {\n\t\tpixel = col3;\n\t}\n\t\n\t// draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n\tvec2 center = vec2(0.9, -0.4);\n\tvec2 d = r - center;\n\tif( length(d) < 0.6) {\n\t\tpixel = col2;\n\t}\n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// Note how the latest disk is shown and previous ones are left\n// behind it. It is because the last if condition changes the pixel\n// value at the end.\n// If the coordinates of pixel fits multiple if conditions, the last\n// manipulation will remain and fragColor is set to that one.\n\n\n#elif TUTORIAL == 13\n// FUNCTIONS\n//\n// Functions are great for code reuse. Let's put the code for disks\n// into a function and use the function for drawing.\n// There are so many different ways of writing a function to draw a shape.\n//\n// Here we have a void function that does not return anything. Instead,\n// \"pixel\" is taken as an \"inout\" expression. \"inout\" is a unique\n// keyword of GLSL.\n// By default all arguments are \"in\" arguments. Which\n// means, the value of the variable is given to the function scope\n// from the scope the function is called. \n// An \"out\" variable gives the value of the variable from the function\n// to the scope in which the function is called.\n// An \"inout\" argument does both. First the value of the variable is\n// sent to the function as its argument. Then, that variable is\n// processed inside the function. When the function ends, the value\n// of the variable is updated where the function is called.\n//\n// Here, the \"pixel\" variable that is initialized with the background\n// color in the \"main\" function. Then, \"pixel\" is given to the \"disk\"\n// function. When the if condition is satisfied the value of the \"pixel\"\n// is changed with the \"color\" argument. If it is not satified, the\n// \"pixel\" is left untouched and keeps it previous value (which was the\n// \"bgColor\".\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tdisk(r, vec2(0.1, 0.3), 0.5, col3, pixel);\n\tdisk(r, vec2(-0.8, -0.6), 1.5, col1, pixel);\n\tdisk(r, vec2(0.8, 0.0), .15, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// As you see, the borders of the disks have \"jagged\" curves, where\n// individual pixels can be seen. This is called \"aliasing\". It occurs\n// because pixels have finite size and we want to draw a continuous\n// shape on a discontinuous grid.\n// There is a method to reduce the aliasing. It is done by mixing the\n// inside color and outside colors at the border. To achieve this\n// we have to learn some built-in functions.\n\n// And, again, note the order of disk function calls and how they are\n// drawn on top of each other. Each disk function manipulates\n// the pixel variable. If a pixel is manipulated by multiple disk\n// functions, the value of the last one is sent to fragColor.\n\n// In this case, the previous values are completely overwritten.\n// The final value only depends to the last function that manipulated\n// the pixel. There are no mixtures between layers.\n\n\n#elif TUTORIAL == 14\n// BUILT-IN FUNCTIONS: STEP\n//\n// \"step\" function is the Heaviside step function :-)\n// http://en.wikipedia.org/wiki/Heaviside_step_function\n// \n// f(x0, x) = {1 x>x0, \n//            {0 x<x0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(r.x < -0.6*xMax) { // Part I\n\t\tvariable = r.y;\n\t\tedge = 0.2;\n\t\tif( variable > edge ) { // if the \"variable\" is greater than \"edge\"\n\t\t\tret = 1.0;          // return 1.0\n\t\t} else {                // if the \"variable\" is less than \"edge\"\n\t\t\tret = 0.0;          // return 0.0\n\t\t}\n\t} \n\telse if(r.x < -0.2*xMax) { // Part II\n\t\tvariable = r.y;\n\t\tedge = -0.2;\n\t\tret = step(edge, variable); // step function is equivalent to the\n\t\t                            // if block of the Part I\n\t} \n\telse if(r.x < 0.2*xMax) { // Part III\n\t\t// \"step\" returns either 0.0 or 1.0.\n\t\t// \"1.0 - step\" will inverse the output\n\t\tret = 1.0 - step(0.5, r.y); // Mirror the step function around edge\n\t} \n\telse if(r.x < 0.6*xMax) { // Part IV\n\t\t// if y-coordinate is smaller than -0.4 ret is 0.3\n\t\t// if y-coordinate is greater than -0.4 ret is 0.3+0.5=0.8\n\t\tret = 0.3 + 0.5*step(-0.4, r.y);\n\t}\n\telse { // Part V\n\t\t// Combine two step functions to create a gap\n\t\tret = step(-0.3, r.y) * (1.0 - step(0.2, r.y));\n\t\t// \"1.0 - ret\" will create a gap\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 15\n// BUILT-IN FUNCTIONS: CLAMP\n//\n// \"clamp\" function saturates the input below and above the thresholds\n// f(x, min, max) = { max x>max\n//                  { x   max>x>min\n//                  { min min>x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 0.25) { // Part I\n\t\tret = p.y; // the brightness value is assigned the y coordinate\n\t\t           // it'll create a gradient\n\t} \n\telse if(p.x < 0.5) { // Part II\n\t\tfloat minVal = 0.3; // implementation of clamp\n\t\tfloat maxVal = 0.6;\n\t\tfloat variable = p.y;\n\t\tif( variable<minVal ) {\n\t\t\tret = minVal;\n\t\t}\n\t\tif( variable>minVal && variable<maxVal ) {\n\t\t\tret = variable;\n\t\t}\n\t\tif( variable>maxVal ) {\n\t\t\tret = maxVal;\n\t\t}\n\t} \n\telse if(p.x < 0.75) { // Part III\n\t\tfloat minVal = 0.6;\n\t\tfloat maxVal = 0.8;\n\t\tfloat variable = p.y;\n\t\tret = clamp(variable, minVal, maxVal);\n\t} \n\telse  { // Part IV\n\t\tfloat y = cos(5.*TWOPI*p.y); // oscillate between +1 and -1\n\t\t                             // 5 times, vertically\n\t\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\tret = clamp(y, 0.2, 0.8);\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 16\n// BUILT-IN FUNCTIONS: SMOOTHSTEP\n//\n// \"smoothstep\" function is like step function but instead of a\n// sudden jump from 0 to 1 at the edge, it makes a smooth transition\n// in a given interval\n// http://en.wikipedia.org/wiki/Smoothstep\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\tfloat edge = 0.5;\n\t\tret = step(edge, p.y); // simple step function\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// linearstep (not a builtin function)\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = (p.y - edge0)/(edge1 - edge0);\n\t\t// when p.y == edge0 => t = 0.0\n\t\t// when p.y == edge1 => t = 1.0\n\t\t// RHS is a linear function of y\n\t\t// so, between edge0 and edge1, t has a linear transition\n\t\t// between 0.0 and 1.0\n\t\tfloat t1 = clamp(t, 0.0, 1.0);\n\t\t// t will have negative values when t<edge0 and\n\t\t// t will have greater than 1.0 values when t>edge1\n\t\t// but we want it be constraint between 0.0 and 1.0\n\t\t// so, clamp it!\t\t\n\t\tret = t1;\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// implementation of smoothstep\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = 3.0*t*t - 2.0*t*t*t;\n\t\t// previous interpolation was linear. Visually it does not\n\t\t// give an appealing, smooth transition.\n\t\t// To achieve smoothness, implement a cubic Hermite polynomial\n\t\t// 3*t^2 - 2*t^3\n\t\tret = t1;\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tret = smoothstep(0.45, 0.55, p.y);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// smootherstep, a suggestion by Ken Perlin\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\t\t\n\t\t// 6*t^5 - 15*t^4 + 10*t^3\n\t\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\t\tret = t1;\n\t\t// faster transition and still smoother\n\t\t// but computationally more involved.\n\t}\t\n\t\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 17\n// BUILT-IN FUNCTIONS: MIX\n//\n// A shader can be created by first constructing individual parts\n// and composing them together.\n// There are different ways of how to combine different parts.\n// In the previous disk example, different disks were drawn on top\n// of each other. There was no mixture of layers. When disks\n// overlap, only the last one is visible.\n//\n// Let's learn mixing different data types (in this case vec3's\n// representing colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow \n\t\n\tvec3 ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\t// implementation of mix\n\t\tfloat x0 = 0.2; // first item to be mixed\n\t\tfloat x1 = 0.7;  // second item to be mixed\n\t\tfloat m = 0.1; // amount of mix (between 0.0 and 1.0)\n\t\t// play with this number\n\t\t// m = 0.0 means the output is fully x0\n\t\t// m = 1.0 means the output is fully x1\n\t\t// 0.0 < m < 1.0 is a linear mixture of x0 and x1\n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// try all possible mix values \n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// use the mix function\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = mix(x0, x1, m);\n\t\tret = vec3(val);\t\t\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\t// mix colors instead of numbers\n\t\tfloat m = p.y;\n\t\tret = mix(col1, col2, m);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// combine smoothstep and mix for color transition\n\t\tfloat m = smoothstep(0.5, 0.6, p.y);\n\t\tret = mix(col1, col2, m);\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 18\n// ANTI-ALIASING WITH SMOOTHSTEP\n//\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\tfloat m;\n\t\n\tfloat radius = 0.4; // increase this to see the effect better\n\tif( r.x < -0.5*xMax ) { // Part I\n\t\t// no interpolation, yes aliasing\n\t\tm = step( radius, length(r - vec2(-0.5*xMax-0.4,0.0)) );\n\t\t// if the distance from the center is smaller than radius,\n\t\t// then mix value is 0.0\n\t\t// otherwise the mix value is 1.0\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < -0.0*xMax ) { // Part II\n\t\t// linearstep (first order, linear interpolation)\n\t\tm = linearstep( radius-0.005, radius+0.005, length(r - vec2(-0.0*xMax-0.4,0.0)) );\n\t\t// mix value is linearly interpolated when the distance to the center\n\t\t// is 0.005 smaller and greater than the radius.\n\t\tpixel = mix(col1, bgCol, m);\n\t}\t\n\telse if( r.x < 0.5*xMax ) { // Part III\n\t\t// smoothstep (cubical interpolation)\n\t\tm = smoothstep( radius-0.005, radius+0.005, length(r - vec2(0.5*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < 1.0*xMax ) { // Part IV\n\t\t// smootherstep (sixth order interpolation)\n\t\tm = smootherstep( radius-0.005, radius+0.005, length(r - vec2(1.0*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 19\n// FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) {\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tvec3 col1 = vec3(0.841, 0.582, 0.594);\n\tvec3 col2 = vec3(0.884, 0.850, 0.648);\n\tvec3 col3 = vec3(0.348, 0.555, 0.641);\t\n\n\tvec3 pixel = bgCol;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridCol;\n\t\tif(abs(r.y - i)<0.004) pixel = gridCol;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesCol;\n\tif( abs(r.y)<0.007 ) pixel = axesCol;\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\t// pink functions\n\t// y = 2*x + 5\n\tif( abs(2.*x + .5 - y) < 0.02 ) pixel = col1;\n\t// y = x^2 - .2\n\tif( abs(r.x*r.x-0.2 - y) < 0.01 ) pixel = col1;\n\t// y = sin(PI x)\n\tif( abs(sin(PI*r.x) - y) < 0.02 ) pixel = col1;\n\t\n\t// blue functions, the step function variations\n\t// (functions are scaled and translated vertically)\n\tif( abs(0.25*step(0.0, x)+0.6 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*linearstep(-0.5, 0.5, x)+0.1 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smoothstep(-0.5, 0.5, x)-0.4 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smootherstep(-0.5, 0.5, x)-0.9 - y) < 0.01 ) pixel = col3;\n\t\n\t// yellow functions\n\t// have a function that plots functions :-)\n\tplot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, col2, pixel);\n\t// bell curve around -0.5\n\tplot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// in the future we can use this framework to see the plot of functions\n// and design and find functions for our liking\n// Actually using Mathematica, Matlab, matplotlib etc. to plot functions\n// is much more practical. But they need a translation of functions \n// from GLSL to their language. Here we can plot the native implementations\n// of GLSL functions.\n\n\n#elif TUTORIAL == 20\n// COLOR ADDITION AND SUBSTRACTION\n//\n// How to draw a shape on top of another, and how will the layers\n// below, affect the higher layers?\n//\n// In the previous shape drawing functions, we set the pixel\n// value from the function. This time the shape function will\n// just return a float value between 0.0 and 1.0 to indice the\n// shape area. Later that value can be multiplied with some color\n// and used in determining the final pixel color.\n\n// A function that returns the 1.0 inside the disk area\n// returns 0.0 outside the disk area\n// and has a smooth transition at the radius\nfloat disk(vec2 r, vec2 center, float radius) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-0.005, radius+0.005, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 gray = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\t\n\tvec3 ret;\n\tfloat d;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\t// opaque layers on top of each other\n\t\tret = gray;\n\t\t// assign a gray value to the pixel first\n\t\td = disk(r, vec2(-1.1,0.3), 0.4);\n\t\tret = mix(ret, col1, d); // mix the previous color value with\n\t\t                         // the new color value according to\n\t\t                         // the shape area function.\n\t\t                         // at this line, previous color is gray.\n\t\td = disk(r, vec2(-1.3,0.0), 0.4);\n\t\tret = mix(ret, col2, d);\n\t\td = disk(r, vec2(-1.05,-0.3), 0.4); \n\t\tret = mix(ret, col3, d); // here, previous color can be gray,\n\t\t                         // blue or pink.\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\t// Color addition\n\t\t// This is how lights of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Additive_color\n\t\tret = black; // start with black pixels\n\t\tret += disk(r, vec2(0.1,0.3), 0.4)*col1; // add the new color\n\t\t                                         // to the previous color\n\t\tret += disk(r, vec2(-.1,0.0), 0.4)*col2;\n\t\tret += disk(r, vec2(.15,-0.3), 0.4)*col3;\n\t\t// when all components of \"ret\" becomes equal or higher than 1.0\n\t\t// it becomes white.\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\t// Color substraction\n\t\t// This is how dye of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Subtractive_color\n\t\tret = white; // start with white\n\t\tret -= disk(r, vec2(1.1,0.3), 0.4)*col1;\n\t\tret -= disk(r, vec2(1.05,0.0), 0.4)* col2;\n\t\tret -= disk(r, vec2(1.35,-0.25), 0.4)* col3;\t\t\t\n\t\t// when all components of \"ret\" becomes equals or smaller than 0.0\n\t\t// it becomes black.\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 21\n// COORDINATE TRANSFORMATIONS: ROTATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tvec2 q;\n\tfloat angle;\n\tangle = 0.2*PI; // angle in radians (PI is 180 degrees)\n\t// q is the rotated coordinate system\n\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\n\tret = bgCol;\n\t// draw the old and new coordinate systems\n\tret = mix(ret, col1, coordinateGrid(r)*0.4 );\n\tret = mix(ret, col2, coordinateGrid(q) );\n\t\n\t// draw shapes in old coordinate system, r, and new coordinate system, q\n\tret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\tret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\t// as you see both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\t\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 22\n// COORDINATE TRANSFORMATIONS: SCALING\n//\n// Scaling the coordinate system.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\t\n\t// original\n\tfloat scaleFactor = 2.0; // zoom in this much\n\tret = mix(ret, col1, coordinateGrid(r)/2.0);\n\t// scaled\n\tvec2 q = 0.3*r;\n\tret = mix(ret, col2, coordinateGrid(q));\n\n\tret = mix(ret, col2, disk(q, vec2(0.0, 0.0), 0.1));\t\n\tret = mix(ret, col1, disk(r, vec2(0.0, 0.0), 0.1));\n\t\n\tret = mix(ret, col1, rectangle(r, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\tret = mix(ret, col2, rectangle(q, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\t\n\t// not how the rectangle that are not centered at the coordinate origin\n\t// changed its location after scaling, but the disks at the center\n\t// remained where they are.\n\t// This is because scaling is done by multiplying all pixel\n\t// coordinates with a constant.\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 23\n// SUCCESSIVE COORDINATE TRANSFORMATIONS\n//\n// Drawing a shape on the desired location, with desired size, and\n// desired orientation needs mastery of succesive application of\n// transformations.\n//\n// In general, transformations do not commute. Which means that\n// if you change their order, you get different results.\n//\n// Let's try application of transformations in different orders.\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\n\tfloat angle = 0.6;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\tif(p.x < 1./2.) { // Part I\n\t\t// put the origin at the center of Part I\n\t\tr = r - vec2(-xMax/2.0, 0.0); \n\n\t\tvec2 rotated = rotationMatrix*r;\n\t\tvec2 rotatedTranslated = rotated - vec2(0.4, 0.5);\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(rotated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(rotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(rotatedTranslated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t} \n\telse if(p.x < 2./2.) { // Part II\n\t\tr = r - vec2(xMax*0.5, 0.0); \n\n\t\tvec2 translated = r - vec2(0.4, 0.5);\n\t\tvec2 translatedRotated = rotationMatrix*translated;\n\t\t\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(translated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(translated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(translatedRotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\t\t\n\t} \t\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 24\n// TIME, MOTION AND ANIMATION\n//\n// One of the inputs that a shader gets can be the time.\n// In ShaderToy, \"iTime\" variable holds the value of the\n// time in seconds since the shader is started.\n//\n// Let's change some variables in time!\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\t\n\tif(p.x < 1./5.) { // Part I\n\t\tvec2 q = r + vec2(xMax*4./5.,0.);\n\t\tret = vec3(0.2);\n\t\t// y coordinate depends on time\n\t\tfloat y = iTime;\n\t\t// mod constraints y to be between 0.0 and 2.0,\n\t\t// and y jumps from 2.0 to 0.0\n\t\t// substracting -1.0 makes why jump from 1.0 to -1.0\n\t\ty = mod(y, 2.0) - 1.0;\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), 0.1) );\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\tvec2 q = r + vec2(xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\t// oscillation\n\t\tfloat amplitude = 0.8;\n\t\t// y coordinate oscillates with a period of 0.5 seconds\n\t\tfloat y = 0.8*sin(0.5*iTime*TWOPI);\n\t\t// radius oscillates too\n\t\tfloat radius = 0.15 + 0.05*sin(iTime*8.0);\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), radius) );\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\tvec2 q = r + vec2(xMax*0./5.,0.);\n\t\tret = vec3(0.4);\n\t\t// booth coordinates oscillates\n\t\tfloat x = 0.2*cos(iTime*5.0);\n\t\t// but they have a phase difference of PI/2\n\t\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n\t\tfloat radius = 0.2 + 0.1*sin(iTime*2.0);\n\t\t// make the color mixture time dependent\n\t\tvec3 color = mix(col1, col2, sin(iTime)*0.5+0.5);\n\t\tret = mix(ret, color, rect(q, vec2(x-0.1, y-0.1), vec2(x+0.1, y+0.1)) );\t\t\n\t\t// try different phases, different amplitudes and different frequencies\n\t\t// for x and y coordinates\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tvec2 q = r + vec2(-xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\tfor(float i=-1.0; i<1.0; i+= 0.2) {\n\t\t\tfloat x = 0.2*cos(iTime*5.0 + i*PI);\n\t\t\t// y coordinate is the loop value\n\t\t\tfloat y = i;\n\t\t\tvec2 s = q - vec2(x, y);\n\t\t\t// each box has a different phase\n\t\t\tfloat angle = iTime*3. + i;\n\t\t\tmat2 rot = mat2(cos(angle), -sin(angle), sin(angle),  cos(angle));\n\t\t\ts = rot*s;\n\t\t\tret = mix(ret, col1, rect(s, vec2(-0.06, -0.06), vec2(0.06, 0.06)) );\t\t\t\n\t\t}\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\tvec2 q = r + vec2(-xMax*4./5., 0.);\n\t\tret = vec3(0.2);\n\t\t// let stop and move again periodically\n\t\tfloat speed = 2.0;\n\t\tfloat t = iTime*speed;\n\t\tfloat stopEveryAngle = PI/2.0;\n\t\tfloat stopRatio = 0.5;\n\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\t\t\n\t\tfloat x = -0.2*cos(t1);\n\t\tfloat y = 0.3*sin(t1);\n\t\tfloat dx = 0.1 + 0.03*sin(t*10.0);\n\t\tfloat dy = 0.1 + 0.03*sin(t*10.0+PI);\n\t\tret = mix(ret, col1, rect(q, vec2(x-dx, y-dy), vec2(x+dx, y+dy)) );\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 25\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./10.) { // Part I\n\t\t// vertical waves\n\t\tret = vec3(v1);\n\t} \n\telse if(p.x < 2./10.) { // Part II\n\t\t// horizontal waves\n\t\tret = vec3(v2);\n\t} \n\telse if(p.x < 3./10.) { // Part III\n\t\t// diagonal waves\n\t\tret = vec3(v3);\n\t}\n\telse if(p.x < 4./10.) { // Part IV\n\t\t// circular waves\n\t\tret = vec3(v4);\n\t}\n\telse if(p.x < 5./10.) { // Part V\n\t\t// the sum of all waves\n\t\tret = vec3(v);\n\t}\t\n\telse if(p.x < 6./10.) { // Part VI\n\t\t// Add periodicity to the gradients\n\t\tret = vec3(sin(2.*v));\n\t}\n\telse if(p.x < 10./10.) { // Part VII\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t}\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\n\n\n#elif TUTORIAL == 26\n// TEXTURES\n//\n// ShaderToy can use upto four textures. \n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\tret = texture(iChannel1, p).xyz;\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\tret = texture(iChannel1, 4.*p+vec2(0.,iTime)).xyz;\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\tr = r - vec2(xMax*2./3., 0.);\n\t\tfloat angle = iTime;\n\t\tmat2 rotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tvec2 q = rotMat*r;\n\t\tvec3 texA = texture(iChannel1, q).xyz;\n\t\tvec3 texB = texture(iChannel2, q).xyz;\n\t\t\n\t\tangle = -iTime;\n\t\trotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tq = rotMat*r;\t\t\n\t\tret = mix(texA, texB, rect(q, vec2(-0.3, -0.3), vec2(.3, .3)) );\n\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 27\n// MOUSE INPUT\n//\n// ShaderToy gives the mouse cursor coordinates and button clicks\n// as an input via the iMouse vec4.\n//\n// Let's write a shader with basic Mouse functionality.\n// When clicked on the frame, the little disk will follow the\n// cursor. The x coordinate of the cursor changes the background color.\n// And if the cursor is inside the bigger disk, it'll color will change.\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\t// background color depends on the x coordinate of the cursor\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec2 center;\n\t// draw the big yellow disk\n\tcenter = vec2(100., iResolution.y/2.);\n\tfloat radius = 60.;\n\t// if the cursor coordinates is inside the disk\n\tif( length(iMouse.xy-center)>radius ) {\n\t\t// use color3\n\t\tret = mix(ret, col3, disk(fragCoord.xy, center, radius));\n\t}\n\telse {\n\t\t// else use color2\n\t\tret = mix(ret, col2, disk(fragCoord.xy, center, radius));\n\t}\t\n\t\n\t// draw the small blue disk at the cursor\n\tcenter = iMouse.xy;\n\tret = mix(ret, col1, disk(fragCoord.xy, center, 20.));\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n#elif TUTORIAL == 28\n// RANDOMNESS\n//\n// I don't know why, but GLSL does not have random number generators.\n// This does not pose a problem if you are writing your code in\n// a programming language that has random functions. That way\n// you can generate the random values using the language and send\n// those values to the shader via uniforms.\n//\n// But if you are using a system that only allows you to write\n// the shader code, such as ShaderToy, then you need to write your own\n// pseuo-random generators.\n//\n// Here is a pattern that I saw again and again in many different\n// shaders at ShaderToy.\n// Let's draw N different disks at random locations using this pattern.\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 hashPosition(float x)\n{\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec2(hash(x), hash(x * 1.1));\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.005, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.y));\n\treturn ret;\n}\n\nfloat plot(vec2 r, float y, float thickness) {\n\treturn ( abs(y - r.y) < thickness ) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec3 white = vec3(1.);\n\tvec3 gray = vec3(.3);\n\tif(r.y > 0.7) {\n\t\t\n\t\t// translated and rotated coordinate system\n\t\tvec2 q = (r-vec2(0.,0.9))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// just the regular sin function\n\t\tfloat y = sin(5.*q.x) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.1));\n\t}\n\telse if(r.y > 0.4) {\n\t\tvec2 q = (r-vec2(0.,0.6))*vec2(1.,20.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\t// take the decimal part of the sin function\n\t\tfloat y = fract(sin(5.*q.x)) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\t\n\telse if(r.y > 0.1) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0.,0.25))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// scale up the outcome of the sine function\n\t\t// increase the scale and see the transition from\n\t\t// periodic pattern to chaotic pattern\n\t\tfloat scale = 10.0;\n\t\tfloat y = fract(sin(5.*q.x) * scale) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.2));\n\t}\t\n\telse if(r.y > -0.2) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0., -0.0))*vec2(1.,10.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\tfloat seed = q.x;\n\t\t// Scale up with a big real number\n\t\tfloat y = fract(sin(seed) * 43758.5453) * 2.0 - 1.0;\n\t\t// this can be used as a pseudo-random value\n\t\t// These type of function, functions in which two inputs\n\t\t// that are close to each other (such as close q.x positions)\n\t\t// return highly different output values, are called \"hash\"\n\t\t// function.\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\n\telse {\n\t\tvec2 q = (r-vec2(0., -0.6));\n\t\t\n\t\t// use the loop index as the seed\n\t\t// and vary different quantities of disks, such as\n\t\t// location and radius\n\t\tfor(float i=0.0; i<6.0; i++) {\n\t\t\t// change the seed and get different distributions\n\t\t\tfloat seed = i + 0.0; \n\t\t\tvec2 pos = (vec2(hash(seed), hash(seed + 0.5))-0.5)*3.;;\n\t\t\tfloat radius = hash(seed + 3.5);\n\t\t\tpos *= vec2(1.0,0.3);\n\t\t\tret = mix(ret, col1, disk(q, pos, 0.2*radius));\n\t\t}\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n\n\n/* End of tutorials */\n\n#elif TUTORIAL == 0\n// WELCOME SCREEN\nfloat square(vec2 r, vec2 bottomLeft, float side) {\n\tvec2 p = r - bottomLeft;\n\treturn ( p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side ) ? 1.0 : 0.0;\n}\n\nfloat character(vec2 r, vec2 bottomLeft, float charCode, float squareSide) {\n\tvec2 p = r - bottomLeft;\n\tfloat ret = 0.0;\n\tfloat num, quotient, remainder, divider;\n\tfloat x, y;\t\n\tnum = charCode;\n\tfor(int i=0; i<20; i++) {\n\t\tfloat boxNo = float(19-i);\n\t\tdivider = pow(2., boxNo);\n\t\tquotient = floor(num / divider);\n\t\tremainder = num - quotient*divider;\n\t\tnum = remainder;\n\t\t\n\t\ty = floor(boxNo/4.0); \n\t\tx = boxNo - y*4.0;\n\t\tif(quotient == 1.) {\n\t\t\tret += square( p, squareSide*vec2(x, y), squareSide );\n\t\t}\n\t}\n\treturn ret;\n}\n\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat G = 990623.; // compressed characters :-)\n\tfloat L = 69919.;\n\tfloat S = 991119.;\n\t\n\tfloat t = iTime;\n\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t//vec2 rL = rot(t)*r+0.0001*t;\n\t//vec2 rL = r+vec2(cos(t*0.02),sin(t*0.02))*t*0.05;\n\tfloat c = 0.05;//+0.03*sin(2.5*t);\n\tvec2 pL = (mod(r+vec2(cos(0.3*t),sin(0.3*t)), 2.0*c)-c)/c;\n\tfloat circ = 1.0-smoothstep(0.75, 0.8, length(pL));\n\tvec2 rG = rot(2.*3.1415*smoothstep(0.,1.,mod(1.5*t,4.0)))*r;\n\tvec2 rStripes = rot(0.2)*r;\n\t\t\t\t\n\tfloat xMax = 0.5*iResolution.x/iResolution.y;\n\tfloat letterWidth = 2.0*xMax*0.9/4.0;\n\tfloat side = letterWidth/4.;\n\tfloat space = 2.0*xMax*0.1/5.0;\n\t\n\tr += 0.001; // to get rid off the y=0 horizontal blue line.\n\tfloat maskGS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskG = character(rG, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskL1 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*1.0, L, side);\n\tfloat maskSS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0, S, side);\n\tfloat maskS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0 + vec2(0.01*sin(2.1*t),0.012*cos(t)), S, side);\n\tfloat maskL2 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*3.0, L, side);\n\tfloat maskStripes = step(0.25, mod(rStripes.x - 0.5*t, 0.5));\n\t\n\tfloat i255 = 0.00392156862;\n\tvec3 blue = vec3(43., 172., 181.)*i255;\n\tvec3 pink = vec3(232., 77., 91.)*i255;\n\tvec3 dark = vec3(59., 59., 59.)*i255;\n\tvec3 light = vec3(245., 236., 217.)*i255;\n\tvec3 green = vec3(180., 204., 18.)*i255;\n\n\tvec3 pixel = blue;\n\tpixel = mix(pixel, light, maskGS);\n\tpixel = mix(pixel, light, maskSS);\n\tpixel -= 0.1*maskStripes;\t\n\tpixel = mix(pixel, green, maskG);\n\tpixel = mix(pixel, pink, maskL1*circ);\n\tpixel = mix(pixel, green, maskS);\n\tpixel = mix(pixel, pink, maskL2*(1.-circ));\n\t\n\tfloat dirt = pow(texture(iChannel0, 4.0*r).x, 4.0);\n\tpixel -= (0.2*dirt - 0.1)*(maskG+maskS); // dirt\n\tpixel -= smoothstep(0.45, 2.5, length(r));\n\tfragColor = vec4(pixel, 1.0);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
