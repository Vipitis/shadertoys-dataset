{"id": "4d3Bz8", "name": "Pulsing Sphere Audio", "author": "AndyWhetstone", "description": "Sphere that pulses to audio in channel 0", "tags": ["sphere"], "likes": 1, "viewed": 75, "published": "Public", "date": "1525201302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/**\n\n * Exercise 2\n\n * - Make the camera move up and down while still pointing at the cube\n\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n\n * - Make the camera zoom in and out\n\n */\n\n\nconst int MAX_MARCHING_STEPS = 255;\n\nconst float MIN_DIST = 0.0;\n\nconst float MAX_DIST = 100.0;\n\nconst float EPSILON = 0.0001;\n\n\n\n/**\n\n * Signed distance function for a cube centered at the origin\n\n * with width = height = length = 2.0\n\n */\n\nfloat cubeSDF(vec3 p) {\n\n   // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n\n   // So if all components of d are negative, then p is inside the unit cube\n\n   vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n\n\n\n   // Assuming p is inside the cube, how far is it from the surface?\n\n   // Result will be negative or zero.\n\n   float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n\n\n   // Assuming p is outside the cube, how far is it from the surface?\n\n   // Result will be positive or zero.\n\n   float outsideDistance = length(max(d, 0.0));\n\n\n\n   return insideDistance + outsideDistance;\n\n}\n\nfloat distSphere(vec3 p, float radius)\n{\n    float freq = texture( iChannel0, vec2( 0.02, 0.2 ) ).x * 1.1;   \n  \treturn length(p) - clamp(0.1, 1.0, radius * freq);\n}\n\n\n/**\n\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n\n */\n\n/*\n\nfloat sphereSDF(vec3 p) {\n\n   return length(p) - 1.0;\n\n}\n\n*/\n\nfloat length2( vec2 p )\n\n{\n\n   return sqrt( p.x*p.x + p.y*p.y );\n\n}\n\n\n\nfloat length6( vec2 p )\n\n{\n\n   p = p*p*p; p = p*p;\n\n   return pow( p.x + p.y, 1.0/6.0 );\n\n}\n\n\n\nfloat length8( vec2 p )\n\n{\n\n   p = p*p; p = p*p; p = p*p;\n\n   return pow( p.x + p.y, 1.0/8.0 );\n\n}\n\n\n\n\n\n\nfloat sdTorus82( vec3 p, vec2 t )\n\n{\n\n   vec2 q = vec2(length2(p.xz)-t.x,p.y);\n\n   return length8(q)-t.y;\n\n}\n\n\n\n/**\n\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n\n */\n\nfloat intersectSDF(float distA, float distB) {\n\n   return max(distA, distB);\n\n}\n\n\n\n/**\n\n * Constructive solid geometry union operation on SDF-calculated distances.\n\n */\n\nfloat unionSDF(float distA, float distB) {\n\n   return min(distA, distB);\n\n}\n\n\n\n/**\n\n * Constructive solid geometry difference operation on SDF-calculated distances.\n\n */\n\nfloat differenceSDF(float distA, float distB) {\n\n   return max(distA, -distB);\n\n}\n\nmat3 rotateX(float theta) {\n\n   float c = cos(theta);\n\n   float s = sin(theta);\n\n   return mat3(\n\n       vec3(1, 0, 0),\n\n       vec3(0, c, -s),\n\n       vec3(0, s, c)\n\n   );\n\n}\n\nmat3 rotateY(float theta) {\n\n   float c = cos(theta);\n\n   float s = sin(theta);\n\n   return mat3(\n\n       vec3(c, 0, s),\n\n       vec3(0, 1, 0),\n\n       vec3(-s, 0, c)\n\n   );\n\n}\n\nmat3 rotateZ(float theta) {\n\n   float c = cos(theta);\n\n   float s = sin(theta);\n\n   return mat3(\n\n       vec3(c, -s, 0),\n\n       vec3(s, c, 0),\n\n       vec3(0, 0, 1)\n\n   );\n\n}\n\n\n/**\n\n * Signed distance function describing the scene.\n\n *\n\n * Absolute value of the return value indicates the distance to the surface.\n\n * Sign indicates whether the point is inside or outside the surface,\n\n * negative indicating inside.\n\n */\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n   samplePoint = rotateX(iTime/2.0)*samplePoint;\n    \n   samplePoint = rotateZ(iTime/1.0)*samplePoint;\n    \n   samplePoint = rotateY(iTime/2.0)*samplePoint;\n\n   float sphereDist = distSphere(samplePoint / 1.0, 0.5) * 1.2;\n\n   float cubeDist = cubeSDF(samplePoint);\n\n   return unionSDF( sdTorus82(samplePoint, vec2(0.6, 0.2)), intersectSDF(cubeDist, sphereDist));\n\n}\n\n\n\n\n\n/**\n\n * Return the shortest distance from the eyepoint to the scene surface along\n\n * the marching direction. If no part of the surface is found between start and end,\n\n * return end.\n\n *\n\n * eye: the eye point, acting as the origin of the ray\n\n * marchingDirection: the normalized direction to march in\n\n * start: the starting distance away from the eye\n\n * end: the max distance away from the ey to march before giving up\n\n */\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n\n   float depth = start;\n\n   for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\n       float dist = sceneSDF(eye + depth * marchingDirection);\n\n       if (dist < EPSILON) {\n\n         return depth;\n\n       }\n\n       depth += dist;\n\n       if (depth >= end) {\n\n           return end;\n\n       }\n\n   }\n\n   return end;\n\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\n\n\n/**\n\n * Return the normalized direction to march in from the eye point for a single pixel.\n\n *\n\n * fieldOfView: vertical field of view in degrees\n\n * size: resolution of the output image\n\n * fragCoord: the x,y coordinate of the pixel in the output image\n\n */\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n\n   vec2 xy = fragCoord - size / 2.0;\n\n   float z = size.y / tan(radians(fieldOfView) / 2.0);\n\n   return normalize(vec3(xy, -z));\n\n}\n\n\n\n/**\n\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n\n */\n\nvec3 estimateNormal(vec3 p) {\n\n   return normalize(vec3(\n\n       sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n\n       sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n\n       sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n\n   ));\n\n}\n\n\n\n/**\n\n * Lighting contribution of a single point light source via Phong illumination.\n\n *\n\n * The vec3 returned is the RGB color of the light's contribution.\n\n *\n\n * k_a: Ambient color\n\n * k_d: Diffuse color\n\n * k_s: Specular color\n\n * alpha: Shininess coefficient\n\n * p: position of point being lit\n\n * eye: the position of the camera\n\n * lightPos: the position of the light\n\n * lightIntensity: color/intensity of the light\n\n *\n\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n\n */\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n\n                         vec3 lightPos, vec3 lightIntensity) {\n\n   vec3 N = estimateNormal(p);\n\n   vec3 L = normalize(lightPos - p);\n\n   vec3 V = normalize(eye - p);\n\n   vec3 R = normalize(reflect(-L, N));\n\n\n\n   float dotLN = dot(L, N);\n\n   float dotRV = dot(R, V);\n\n\n\n   if (dotLN < 0.0) {\n\n       // Light not visible from this point on the surface\n\n       return vec3(0.0, 0.0, 0.0);\n\n   }\n\n\n\n   if (dotRV < 0.0) {\n\n       // Light reflection in opposite direction as viewer, apply only diffuse\n\n       // component\n\n       return lightIntensity * (k_d * dotLN);\n\n   }\n\n   return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n\n}\n\nfloat rand(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\n\n\n/**\n\n * Lighting via Phong illumination.\n\n *\n\n * The vec3 returned is the RGB color of that point after lighting is applied.\n\n * k_a: Ambient color\n\n * k_d: Diffuse color\n\n * k_s: Specular color\n\n * alpha: Shininess coefficient\n\n * p: position of point being lit\n\n * eye: the position of the camera\n\n *\n\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n\n */\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n\n   float itm = iTime / 4.0;\n\n   const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n\n   vec3 color = ambientLight * k_a;\n\n\n\n   vec3 light1Pos = vec3(4.0 * sin(itm),\n\n                         2.0,\n\n                         4.0 * cos(itm));\n\n   vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\n\n\n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n\n                                 light1Pos,\n\n                                 light1Intensity);\n\n\n\n   vec3 light2Pos = vec3(2.0 * sin(0.37 * itm),\n\n                         2.0 * cos(0.37 * itm),\n\n                         2.0);\n\n   vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n\n\n\n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n\n                                 light2Pos,\n\n                                 light2Intensity);   \n\n   return color;\n\n}\n\n\n\n/**\n\n * Return a transform matrix that will transform a ray from view space\n\n * to world coordinates, given the eye point, the camera target, and an up vector.\n\n *\n\n * This assumes that the center of the camera is aligned with the negative z axis in\n\n * view space when calculating the ray marching direction. See rayDirection.\n\n */\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\n   // Based on gluLookAt man page\n\n   vec3 f = normalize(center - eye);\n\n   vec3 s = normalize(cross(f, up));\n\n   vec3 u = cross(s, f);\n\n   return mat4(\n\n       vec4(s, 0.0),\n\n       vec4(u, 0.0),\n\n       vec4(-f, 0.0),\n\n       vec4(0.0, 0.0, 0.0, 1)\n\n   );\n\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n\n   vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n   vec3 eye = vec3(8.0, 5.0, 7.0);\n\n\n\n   mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n\n\n   vec3 worldDir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n\n\n\n   float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n\n\n   if (dist > MAX_DIST - EPSILON) {\n\n       // Didn't hit anything\n\n       fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n      return;\n\n   }\n\n\n\n   // The closest point on the surface to the eyepoint along the view ray\n\n   vec3 p = eye + dist * worldDir;\n \n   \n   vec3 K_a = vec3(rand(4.0), 0.2, 0.2);\n\n   vec3 K_d = vec3(rand(3.0), 0.2, 0.7);\n\n   vec3 K_s = vec3(rand(2.0), 1.0, 1.0);\n    \n\n   float shininess = 10.0;\n\n\n\n   vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n    \n\n   fragColor = vec4(color, 1.0);\n   \n\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3Bz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 465, 488, 639, 1068], [1070, 1070, 1110, 1110, 1235], [1330, 1396, 1422, 1422, 1463], [1467, 1467, 1493, 1493, 1558], [1562, 1562, 1588, 1588, 1660], [1667, 1667, 1703, 1703, 1775], [1779, 1873, 1919, 1919, 1952], [1956, 2043, 2085, 2085, 2118], [2122, 2214, 2261, 2261, 2295], [2297, 2297, 2324, 2324, 2472], [2474, 2474, 2501, 2501, 2649], [2651, 2651, 2678, 2678, 2826], [2829, 3075, 3109, 3109, 3480], [3486, 3916, 4007, 4007, 4321], [4323, 4323, 4343, 4343, 4415], [4421, 4681, 4746, 4746, 4879], [4883, 4975, 5004, 5004, 5314], [5318, 5825, 5965, 5965, 6546], [6548, 6548, 6568, 6568, 6609], [6613, 6995, 7080, 7080, 7889], [7893, 8227, 8276, 8311, 8538], [8544, 8544, 8602, 8602, 9465]], "test": "error"}
{"id": "4d3BzB", "name": "needle", "author": "lennyjpg", "description": "pushing pixels", "tags": ["mono"], "likes": 5, "viewed": 468, "published": "Public API", "date": "1525624411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.1;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 center = vec2(1);\n    center.x+=sin(uv.y*3.7+t);\n    center.y+=cos(uv.x*3.7+t);\n    float d = distance(uv,center);\n     t += uv.y;\n     t *= cos(fragCoord.x*37.123);\n    float k = mod(d-t, .1 )*12.0*(.5+uv.y*.5);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3BzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 369]], "test": "valid"}
{"id": "4d3BzX", "name": "Circle packing 2 (loop free)", "author": "akhgary", "description": "I think that every loop can be removed when the variable changes inside loop are only dependent on loop counter.\n\nIts just matter of translating coordinates into loop counter. I could be wrong.\n\nThis circle packing is not as dense as possible by the way.", "tags": ["spiral", "circle", "plot", "draw", "sunflower", "circlepacking", "loopfree", "vogal"], "likes": 9, "viewed": 435, "published": "Public", "date": "1526056353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Circle packing\n// https://en.wikipedia.org/wiki/Circle_packing\n\n// Hue taken from https://www.shadertoy.com/view/4tlBWB\n\n#define tau 6.28318\n#define pi 3.14159\n#define ep 1e-2  // epsilon (fix edge cases)\n\nvec3 hue( in vec3 c )\n{\n\treturn c.z*(1.-c.y*smoothstep(2.,1.,abs(mod(c.x*6.+vec3(0,4,2),6.) -3.)));\n}\n\nfloat circle(vec2 xy, vec2 c, float r, bool fill){\n    float dist = length(xy-c)-r;\n    return 1.-smoothstep(-2./iResolution.y,3./iResolution.y,fill?dist:abs(dist));\n}\n\nvec3 circles(vec2 xy, vec2 C, float R, float r, float ph){\n    \n\tfloat t = 2.*asin(r/(R+r)); \t\t// theta for each surrounding circle\n    \n    float div = abs(tau/t)+ep;\n\tint n = int(div); \t\t\t\t\t// number of surrounding circles\n    float pad = fract(div)*t/float(n);\t// circles padding                                       \n    \n    float rt = -t/2.-pad/2.+ph;\t\t\t// plane rotation\n    mat2 rm = mat2(cos(rt),-sin(rt),sin(rt),cos(rt));\n    vec2 zw = rm*(xy-C);\t\t\t\t// rotated plane\n    \n    float i = floor((atan(zw.y,zw.x))/(t+pad));                 // i-th circle\n    vec2 c = vec2(cos(i*(t+pad)+ph),sin(i*(t+pad)+ph))*(r+R)+C; // center of surrounding circles\n\t\n    vec3 hsl = vec3(i/float(n),1.,.75); // color for each surrounding circle\n    return circle(xy,c,r,true)*hue(hsl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n        \n    vec2 C = vec2(0); // center\n    float R = .175;\t// central circle radius\n\tfloat r = .075;\t// surrounding circle radius\n\n    col+=circle(xy, C, R, false);// draw central circle\n    \n    float n = 20.; // number of layers\n    float i = floor((min(r*2.*(n-1.)+ep,length(xy-C)-R))/(r*2.)); // i-th layer\n    \n    if(i>=0.)\n        col+=circles(xy, C, R+r*i*2., r,pi*sin(iTime)/n*i);  // draw surrounding circles\n    \n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3BzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 209, 232, 232, 310], [312, 312, 362, 362, 479], [481, 481, 539, 539, 1261], [1263, 1263, 1320, 1320, 1865]], "test": "valid"}
{"id": "4d3cWn", "name": "3d training", "author": "malezoltekrety", "description": "g", "tags": ["g"], "likes": 0, "viewed": 52, "published": "Public", "date": "1526326057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 0.05;\n */\nfloat sphereSDF(vec3 samplePoint, vec3 sphereCenter) {\n    return length(sphereCenter - samplePoint) - 0.4;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    /*float d = unionSDF(sphereSDF(samplePoint, vec3(0., 0., 0.)), sphereSDF(samplePoint, vec3(0., 0.5, 0.)));\n    d = unionSDF(d, sphereSDF(samplePoint, vec3(0.5, 0., 0.)));\n    d = unionSDF(d, sphereSDF(samplePoint, vec3(0.5, 0.5, 0.)));\n    d = unionSDF(d, sphereSDF(samplePoint, vec3(0.5, 0.5, 0.5)));\n    d = unionSDF(d, sphereSDF(samplePoint, vec3(0., 0.5, 0.5)));   \n    d = unionSDF(d, sphereSDF(samplePoint, vec3(0., 0., 0.5)));\n    d = unionSDF(d, sphereSDF(samplePoint, vec3(0.5, 0., 0.5)));\n*/\n    float d = sphereSDF(samplePoint, vec3(0., 0., 0.));\n    float displacement =  sin(20.*samplePoint.x*sin(iTime*0.01))* sin(20.*samplePoint.y*sin(iTime*0.01))* sin(20.*samplePoint.z*sin(iTime*0.01));\n    return d+displacement;\n}\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * ro: the eye point, acting as the origin of the ray\n * rd: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(ro + depth * rd);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvec3 CalculateRayDirection(vec2 uv, vec3 ro, float cameraZoom, vec3 cameraLookPoint){\n    vec3 forward = normalize(cameraLookPoint - ro);\n    vec3 right = cross(vec3(0., 1., 0.), forward);\n    vec3 up = cross(forward, right);\n    vec3 centerOfTheScreen = ro+forward*cameraZoom;\n    vec3 intersection = centerOfTheScreen + uv.x*right + uv.y*up;\n    \n    //ray direction = intersection with plane - rayOrifin\n    return intersection-ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t = iTime;\n    \n    // camera\n    //we only modify lookat ro (which is camera position) and zoom\n    vec3 lookAt = vec3(.0, .0, 0.);\n    float zoom = 1.;\n    //make camera mouse responsive\n    //vec2 mo = 0.1*iMouse.xy/iResolution.xy;\n    vec2 mo = vec2(sin(iTime*0.01), cos(iTime*0.01));\n\t\n\n\tfloat an1 = 0.2-6.2831*mo.x;\n\tfloat an2 = clamp( 0.8 + 0.6  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2), 1.));\n    \n\n    vec3 rd = CalculateRayDirection(uv, ro, zoom, lookAt);\n    \n    float d = 0.;\n   \n    fragColor = vec4(d);\n    \n    float dist = shortestDistanceToSurface(ro, rd, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n        // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = ro + dist * normalize(rd);\n    \n    vec3 K_a = vec3(0.2, 0.9, 0.2);\n    vec3 K_d = vec3(0.0, 0.9, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, ro);\n    \n    fragColor = vec4(color, 1.0);\n    \n    //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3cWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 172, 172, 204], [206, 206, 248, 248, 280], [282, 282, 329, 329, 362], [364, 454, 508, 508, 563], [565, 805, 839, 1345, 1576], [1577, 1577, 1606, 1606, 1916], [1920, 2325, 2400, 2400, 2690], [2692, 3184, 3324, 3324, 3914], [3916, 4286, 4371, 4371, 5171], [5174, 5174, 5259, 5259, 5610], [5612, 5612, 5669, 5719, 7032]], "test": "valid"}
{"id": "4d3fWf", "name": "Equi ⠁⣹|", "author": "lejeunerenard", "description": "Daily post for 2018-05-20\n\n[url=https://www.instagram.com/p/BjBxiCUgYAl/]Instagram Post[/url]", "tags": ["noise", "triangle", "abstract", "design", "daily"], "likes": 18, "viewed": 419, "published": "Public", "date": "1526941707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n#define time iTime\n\n// --- Config ---\n#define totalT 5.0\n#define spread 0.5\n// Triangle\n#define triRadius 0.75\n\nmat2 rotMat2 (in float a);\nfloat vfbmWarp(in vec2 p);\n\nvec3 pattern (in vec2 uv) {\n  vec3 color = vec3(0);\n\n  float modT = mod(time, totalT);\n  float cosT = TWO_PI / totalT * modT;\n\n  // --- Space warp ---\n  vec2 qW = uv;\n  qW += vec2(0.3, -0.1);\n  qW += 0.050 * cos(3.0 * qW.yx + cosT);\n  qW += 0.025 * cos(5.0 * qW.yx + cosT);\n  qW *= 1.075 * vfbmWarp(vec2(0.05) * qW);\n\n  const float edge = 0.2;\n  const float thickness = 0.5;\n  vec2 axis = vec2(0, 1);\n\n  // --- Rotate axis over time ---\n  axis *= rotMat2(PI * 0.0625 * sin(TWO_PI * (modT / totalT + 0.5 * dot(qW, vec2(1)))));\n  axis *= rotMat2(PI * 0.25 * sin(TWO_PI * (modT / totalT - 0.5 * length(qW))));\n\n  // --- Render lines ---\n  float n = smoothstep(thickness, thickness + edge, sin(TWO_PI * 24.0 * dot(qW, axis)));\n  color.r = n;\n  n = smoothstep(thickness, thickness + edge, sin(TWO_PI * 24.0 * dot(qW, axis) + 0.5 * spread));\n  color.g = n;\n  n = smoothstep(thickness, thickness + edge, sin(TWO_PI * 24.0 * dot(qW, axis) + spread));\n  color.b = n;\n\n  // --- Triangle crop ---\n  vec2 q = uv;\n  const float cropEdge = 0.01;\n  const vec2 point1 = vec2(0, triRadius * 1.414214);\n  const vec2 point2 = vec2(0.5 * triRadius, 0);\n  // Point 3 is created via horizontal mirror\n  q.x = abs(q.x);\n\n  // Height adjustment (Number is tan(30º))\n  q.y += 0.5 * triRadius * 0.5773502692;\n  q.y += triRadius * 0.333333; // Manual adjustment\n\n  float m = 1.0; // Start w/ everything included\n  m *= smoothstep(point2.y - cropEdge, point2.y, q.y); // Bottom edge\n  vec2 midPoint = 0.5 * (point1 + point2);\n  float d = length(midPoint);\n\n  // Find Perpendicular vector pointing outward\n  vec2 midPointPerpendicular = vec2(0, 1) * rotMat2(-0.333333 * PI);\n\n  m *= smoothstep(d, d - cropEdge, dot(q, midPointPerpendicular));\n  color *= m;\n\n  return color;\n}\n\n// --- Utility functions & noise ---\nmat2 rotMat2 (in float a ) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n// source: https://www.shadertoy.com/view/lsl3RH\nfloat noise( in vec2 x ) {\n  return sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat vfbm4 (vec2 p) {\n  float f = 0.0;\n  float a = PI * 0.173;\n  mat2 m = rotMat2(a);\n\n  f += 0.500000 * noise( p ); p *= m * 2.02;\n  f += 0.250000 * noise( p ); p *= m * 2.03;\n  f += 0.125000 * noise( p ); p *= m * 2.01;\n  f += 0.062500 * noise( p ); p *= m * 2.025;\n\n  return f * 0.9375;\n}\n\nfloat vfbm6 (vec2 p) {\n  float f = 0.0;\n  float a = 1.123;\n  mat2 m = rotMat2(a);\n\n  f += 0.500000 * (0.5 + 0.5 * noise( p )); p *= m * 2.02;\n  f += 0.250000 * (0.5 + 0.5 * noise( p )); p *= m * 2.03;\n  f += 0.125000 * (0.5 + 0.5 * noise( p )); p *= m * 2.01;\n  f += 0.062500 * (0.5 + 0.5 * noise( p )); p *= m * 2.025;\n  f += 0.031250 * (0.5 + 0.5 * noise( p )); p *= m * 2.011;\n  f += 0.015625 * (0.5 + 0.5 * noise( p )); p *= m * 2.0232;\n\n  return f * 0.9375;\n}\n\nfloat vfbmWarp (vec2 p, out vec2 q, out vec2 s, vec2 r) {\n  const float scale = 4.0;\n  const float angle = 0.01 * PI;\n  const float si = sin(angle);\n  const float c = cos(angle);\n  const mat2 rot = mat2(c, si, -si, c);\n\n  q = vec2(\n        vfbm4(p + vec2(0.0, 0.0)),\n        vfbm4(p + vec2(3.2, 34.5)));\n  q *= rot;\n\n  s = vec2(\n        vfbm4(p + scale * q + vec2(23.9, 234.0)),\n        vfbm4(p + scale * q + vec2(7.0, -232.0)));\n  s *= rot;\n\n  return vfbm6(p + scale * s);\n}\n\n// Overload for 1 argument\nfloat vfbmWarp (vec2 p) {\n  vec2 q = vec2(0);\n  vec2 s = vec2(0);\n  vec2 r = vec2(0);\n\n  return vfbmWarp(p, q, s, r);\n}\n\n// --- Render ---\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize to [-1, -1] -> [1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    // Output to screen\n    fragColor = vec4(pattern(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3fWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 219, 246, 246, 1966], [1968, 2005, 2033, 2033, 2103], [2105, 2154, 2180, 2180, 2218], [2220, 2220, 2242, 2242, 2512], [2514, 2514, 2536, 2536, 2978], [2980, 2980, 3037, 3037, 3455], [3457, 3484, 3509, 3509, 3603], [3605, 3623, 3680, 3719, 3848]], "test": "error"}
{"id": "4d3fWM", "name": "sine wave", "author": "yasirtug", "description": "{}", "tags": ["sine"], "likes": 0, "viewed": 93, "published": "Public", "date": "1525289108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define invFrequency 80.0\n#define amplitude 60.0\n#define speed 100.0\n#define pi 3.1415\n#define space 10.0\n#define red vec3(1.0,0.0,0.0)\n#define green vec3(0.0,1.0,0.0)\n#define blue vec3(0.0,0.0,1.0)\n\nfloat plotx(float y, vec2 coord, float thickness)\n{\t\n   \tfloat diff = abs(coord.y - y);\n    return 1.0 - smoothstep(thickness * 0.5, thickness, diff);\n}\nfloat ploty(float x, vec2 coord, float thickness)\n{\t\n   \tfloat diff = abs(coord.x - x);\n    return 1.0 - smoothstep(thickness - thickness/2.0, thickness, diff);\n}\nfloat plot2(vec2 xy, vec2 coord)\n{\n    float diff = length(xy - coord);\n    return 1.0 - smoothstep(1.0, 3.0, diff);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col;\n   \t\n    fragCoord.x -= iResolution.x - (amplitude + space);\n    fragCoord.y -= iResolution.y / 2.0;\n    \n   \tfloat floatingX = fragCoord.x + (amplitude + space);\n    float modi = mod(iTime * speed, invFrequency * pi * 2.0);\n    float degree = modi / invFrequency;\n    floatingX += modi;\n    //col += green * plotx(cos(floatingX/invFrequency)*amplitude, fragCoord,1.0);\n    \n    float lenFrag = length(fragCoord);\n    \n    //circle\n    col += blue * smoothstep(amplitude - 2.0, amplitude, lenFrag)\n        - blue * smoothstep(amplitude, amplitude + 2.0, lenFrag);\n    \n    vec2 whiteDot = vec2(cos(degree), sin(degree)) * amplitude;\n   \tvec2 redDot = vec2(-(amplitude + space), whiteDot.y);\n    //-invFrequency * pi * 2.0\n    col += plot2(whiteDot, fragCoord);\n    col += plot2(redDot, fragCoord);\n    col += plot2(vec2(0.0), fragCoord);\n\t\n    //sine wave\n    if(fragCoord.x < -(amplitude + space))\n    {\n    \tcol += red * plotx(sin(floatingX / invFrequency) * amplitude, fragCoord, 3.4);\n    }\n    //white line\n    else if(fragCoord.x < whiteDot.x)\n    {\n        col += plotx(whiteDot.y,fragCoord, 1.4);\n    }\n    //inner circle line\n    mat2 rotator = mat2(cos(degree),sin(degree),\n                        -sin(degree),cos(degree));\n    if(length(fragCoord) < amplitude)\n    {\n        fragCoord *= rotator;\n        if(fragCoord.x > 0.5)\n        col += plotx(0.0, fragCoord, 1.4);\n    }\n    //seperator line\n    if(abs(fragCoord.y) < amplitude + space * 2.0)\n    col += vec3(1.0) * ploty(-(amplitude + space),fragCoord,1.0);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3fWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 251, 251, 352], [353, 353, 404, 404, 515], [516, 516, 550, 550, 634], [635, 635, 692, 692, 2263]], "test": "valid"}
{"id": "4d3fzl", "name": "Constructive_Interference_test", "author": "PGrad", "description": "A small test with waves", "tags": ["waves"], "likes": 4, "viewed": 152, "published": "Public", "date": "1526283786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getColor(vec2 center, vec2 uv);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 wave1 = getColor(vec2(.9, .5), uv);\n    vec3 wave2 = getColor(vec2(.5,.3), uv);\n    \n   \tvec3 color = clamp(\n        mix(wave1 + wave2, (wave1 * wave2 * vec3(1,0,0)), .7),\n        0., 1.);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\nvec3 getColor(vec2 center, vec2 uv)\n{\n    float r = length(uv - center);\n    \n    float s = clamp( (sin(r * 60. - iTime * 5.) + 1.) * .5, 0., 1.);\n    \n    return vec3(smoothstep(.9, 1., s));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d3fzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 94, 144, 450], [452, 452, 489, 489, 645]], "test": "valid"}
{"id": "4dBfD3", "name": "Analytic distortion Debugger", "author": "asiJa", "description": "Shader made to get insight into recursive wrap functions with analytic derivatives. Long term goal is to do nice turbulences. \nLeft : distorted grid texture; \nRight :  derivatives encoded as x=Red,y=Green; Top: finite difference; Bottom: analytic;", "tags": ["2d", "distortion", "wrapping", "derivaties"], "likes": 4, "viewed": 160, "published": "Public", "date": "1527270986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \n\nvec3 lorenz( vec2 p, float w2 ){\n\tfloat D  = 1.0/(w2+dot(p,p));\n\treturn vec3( p*(-2.0*D*D), D );\n}\n\nvec3 sin_fd( vec2 p, vec2 freq ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p) * freq;\n    return vec3( cp.x*sp.y, sp.x*cp.y, sp.x*sp.y );\n}\n\nvec3 sin_poles( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    float D = 1.0/(w2 + dot(sp,sp) );\n    return vec3( -2.0*freq*D*D*cp*sp, D )*w2;\n}\n\nvec3 sin_poles_signed( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    float s = cp.x*cp.y;\n    float D = 1.0/(w2 + dot(sp,sp) );\n    //return vec3( -2.0*freq*D*D*cp*sp*s - freq*sp*cp.yx*D, D*s )*w2;\n    return vec3( (-2.0*D*cp*s - cp.yx)*freq*sp, s )*D*w2;\n}\n\nvec3 sin_net( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    // --- type 1 - with singularities\n    //float D  = 1.0/(w2 + sp.x*sp.y );\n    //cp*=-2.0*freq*D*D;\n    //return vec3( cp.x*sp.y, sp.x*cp.y, D )*w2;\n    \n    // --- type 2 - without nodes\n    //vec2  D  = 1.0/(w2 + sp );\n    //float D2 = dot(D,D);\n    //cp*=-3.0*freq*D*D*D;\n    //return vec3( cp.x, cp.y, D2 )*w2*w2;\n    \n    // --- type 3 - with nodes\n    vec2  D  = 1.0/(w2 + sp*sp );\n    float D2 = D.x*D.y;\n    cp*=-freq*freq*D;\n    return vec3( cp*sp, 1.0 )*D2*w2*w2;\n\n}\n\nvec3 func( vec2 p ){\n/*\n    return   0.5 *lorenz( p+vec2( 1.0, 0.5), 1.0 ) \n           - 1.5 *lorenz( p+vec2(-1.0,-0.5), 2.0 )\n           - 0.5 *lorenz( p+vec2(-1.0,4.5), 0.5 );    \n*/\n//    return sin_fd( p, vec2(1.5) )*0.3;\n//    return lorenz   ( p, 1.0 );\n//    return sin_poles( p, vec2(1.5), 0.4 )*0.1;\n//    return sin_net( p, vec2(1.5), 0.4 )*0.1;\n//    return sin_poles_signed( p, vec2(1.5), 0.4 )*0.1;\n\n//    return sin_poles_signed( p, vec2(1.5), 0.8 )*0.1 + lorenz( p, 8.0 )*8.0;\n        return sin_poles_signed( p, vec2(1.0), 0.8 )*0.1 + sin_poles_signed( p, vec2(2.0), 0.4 )*0.02;\n}\n\nvoid move( inout vec2 p, float dt ){\n    vec3 fd = func( p );\n    //p += fd.xy*dt;                // gradient  move\n    p += vec2( -fd.y, fd.x ) * dt;  // vorticity move     \n}\n\nvec3 bgtex( vec2 p ){\n    vec2 sp = sin(p*10.0); \n    float w2 = 0.16;\n    //float grid = w2/(w2 + dot(sp,sp));              // grid only nodes\n    sp = w2/(w2 + sp*sp); float grid = dot(sp,sp);    // grid only lines\n    //sp = w2/(w2 + sp*sp); float grid = sp.x*sp.y;   // grid with nodes, lines\n    //return vec3( val );\n    vec2 bg = sin(p*2.0)*0.5 + 0.5;\n    //return vec3( bg.x, grid*0.5, bg.y ); \n    return vec3( bg.x, (bg.x+bg.y)*0.4, bg.y ) + vec3(grid*0.3); \n}\n\nvec2 checkFuncDeriv( vec2 p ){\n    vec3 fd = func( p );\n    if(p.x>0.0){\n        float dd = 0.001;\n        fd.xy=vec2(\n            func( p + vec2(dd,0.0) ).z - fd.z ,\n            func( p + vec2(0.0,dd) ).z - fd.z\n        )/dd;\n    }\n    //return vec4( vec3(fd.xy,0.0)*0.1 + vec3(fd.z*0.5+0.5), 0.0);\n    //return vec4( vec3(fd.z*0.5+0.5), 0.0);\n    //return vec4( vec3(fd.xy,0.0)*0.1 + 0.5, 0.0);\n    return fd.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p0    = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n\tvec2 p     = 6.0*p0;\t\n\t\n\tfloat val = func( p ).z;\n\t//float dt = 0.0625;\n\tfloat sint = sin(iTime*0.1);\n\tfloat wt2 = 0.4;\n\tfloat dt = (wt2/(wt2+sint*sint)-(wt2/(1.0+wt2)))*0.0625*32.0;\n\tvec4 clr = vec4(0.0,0.0,0.0,1.0);\n\tfloat t = 0.0;\n\tfor(int i=0; i<32; i++){ \n\t    move( p, dt ); \n\t    //clr.xyz += bgtex( p )*vec3(t,0.5,1.0-t)*dt*4.0;\n\t    //clr.xyz += bgtex( p )*t*dt*4.0;\n\t    t += dt;\n\t};\n        \n    clr.xyz = func( p )*10.0;\n    if( p0.y > 0.0 ) clr.xy = checkFuncDeriv( p )*5.0;\n    clr.xy +=vec2(0.5,0.5);\n    if( p0.x > 0.0 )clr.xyz = bgtex( p ); \n    fragColor = clr;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 5, 37, 37, 103], [105, 105, 138, 138, 257], [259, 259, 305, 305, 449], [451, 451, 504, 504, 755], [757, 757, 801, 801, 1340], [1342, 1342, 1362, 1833, 1938], [1940, 1940, 1976, 1976, 2116], [2118, 2118, 2139, 2139, 2588], [2590, 2590, 2620, 2620, 3006], [3008, 3008, 3064, 3064, 3715]], "test": "valid"}
{"id": "4dcBDH", "name": "Superellipsoid", "author": "Holeum", "description": "Superellipsoid formula visualization (convex case). Surface color based on Gaussian curvature.", "tags": ["raytracing", "reflection", "refraction", "superformula", "curvature", "superellipse", "superquadric", "supershape", "superellipsoid"], "likes": 4, "viewed": 392, "published": "Public", "date": "1525203704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  Written by Ivan Shevchenko\n  \n  Superellipsoid with refraction in Cornell Box: https://www.shadertoy.com/view/7sSXRR\n*/\n\n\n#define M_PI 3.1415926535\n#define M_EPSILON 0.0001\n\n#define MAXIters 24\n#define InitialStepFactor 1.0 / 128.0\n#define SKYColor vec3(0.85, 1.05, 1.20)\n#define FOGColor vec3(0.70, 0.80, 1.00)\n\n\n// ------------------ Miscellaneous ----------------------\nfloat deg2rad(float deg)\n{\n    return(deg * M_PI / 180.0);\n}\n\nfloat infinite2Unit(float x)\n{\n    x = abs(x);\n    return(sqrt(x / (1.0 + x)));\n}\n\n// Viridis approximation - https://www.shadertoy.com/view/XtGGzG\nvec3 plasmaQuintic(float x)\n{\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\n\t\tdot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\n\t\tdot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 Linear2sRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n// ------------------ Miscellaneous ----------------------\n\n\n// ------------------ BLAS/LAPACK elements ----------------------\nmat4 QuaternionToMatrix(vec4 q)\n{\n    mat4 m1 = mat4( q.w,  q.z, -q.y, q.x,\n                   -q.z,  q.w,  q.x, q.y,\n                    q.y, -q.x,  q.w, q.z,\n                   -q.x, -q.y, -q.z, q.w);\n\n    mat4 m2 = mat4( q.w,  q.z, -q.y, -q.x,\n                   -q.z,  q.w,  q.x, -q.y,\n                    q.y, -q.x,  q.w, -q.z,\n                    q.x,  q.y,  q.z,  q.w);\n\n    mat4 m = m1 * m2;\n\n    return(m);\n}\n\nmat4 AxisAngleToMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle / 2.0);\n    float c = cos(angle / 2.0);\n\n    vec4 q = vec4(s, s, s, c);\n    q.x *= axis.x;\n    q.y *= axis.y;\n    q.z *= axis.z;\n\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n\n// pitch (attitude) - rotation around X-axis\n// yaw (heading)    - rotation around Y-axis\n// roll (bank)      - rotation around Z-axis\nmat4 EulerToMatrix(float pitch, float yaw, float roll)\n{\n    // The definition can be found in glm/gtc/quaternion.hpp\n    vec3 c = vec3(cos(pitch / 2.0), cos(yaw / 2.0), cos(roll / 2.0));\n    vec3 s = vec3(sin(pitch / 2.0), sin(yaw / 2.0), sin(roll / 2.0));\n\n    vec4 q = vec4(0.0);\n\n    // XYZ ordering\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n\n    //q = normalize(q);\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n// ------------------ BLAS/LAPACK elements ----------------------\n\n\n// ------------------ Ray ------------------\nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\nRay rayConstruct(vec2 uv, mat4 invProj, mat4 invView)\n{\n    // Ray in screen space\n    vec2 sXY = 2.0 * uv - 1.0;\n    vec4 sP0 = vec4(sXY, -1.0, 1.0);\n    vec4 sP1 = vec4(sXY,  1.0, 1.0);\n\n    // Ray in world space\n    vec4 wP0 = invProj * sP0; wP0 /= wP0.w;\n    vec4 wP1 = invProj * sP1; wP1 /= wP1.w;\n   \n    wP0 = invView * wP0;\n    wP1 = invView * wP1;\n    \n    Ray ray = Ray(invView[3].xyz, normalize(wP1.xyz - wP0.xyz));\n    return(ray);\n}\n// ------------------ Ray ------------------\n\n\n// ------------------ Plane ------------------\nstruct Plane\n{\n\tvec3 M;\n\tvec3 Normal;\n};\n\nPlane planeConstruct(vec3 point, vec3 normal)\n{\n    Plane pl;\n    pl.M = point;\n    pl.Normal = normal;\n   \n    return(pl);\n}\n\nbool planeIntersect(Plane pl, Ray ray)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nbool planeIntersect(Plane pl, Ray ray, out vec3 ipos, out vec3 norm)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    ipos = ray.Origin + t * ray.Direction;\n    norm = pl.Normal;\n\n    return(true);\n}\n// ------------------ Plane ------------------\n\n\n// ------------------ Superellipsoid ------------------\nstruct Superellipsoid\n{\n\tvec3 Center;\n\tvec3 Radius;\n    vec2 Exponent;\n    mat3 Orientation;\n};\n\nSuperellipsoid superellipsoidConstruct(vec3 pos, vec3 radius)\n{\n    vec3 arg = 0.5 + 0.5 * sin(vec3(iTime) / vec3(2.0, 4.0, 3.0));\n    \n    // 0.1 - near to square form, 2.00 - diamond form\n    vec2 e = mix(vec2(0.1), vec2(2.0), arg.xy);\n    \n    vec3 axis0 = vec3(1.0, 0.0, 0.0);\n    vec3 axis1 = vec3(0.0, 1.0, 1.0);\n    vec3 axis2 = vec3(0.0, 0.0, 1.0);\n    vec3 axis = mix(axis0, mix(axis1, axis2, max(0.0, 2.0 * arg.z - 1.0)), min(1.0, 2.0 * arg.z));\n    mat4 o = AxisAngleToMatrix(normalize(axis), deg2rad(360.0 * mod(0.05 * iTime, 1.0)));\n    \n    Superellipsoid se;\n    se.Center = pos;\n    se.Radius = radius;\n    se.Exponent = e;\n    se.Orientation = mat3(o);\n    \n    return(se);\n}\n\n// Superellipsoid Inside-Outside Function\nfloat superellipsoidIOF(vec3 pos, vec3 dir, float t, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 invr = vec3(1.0) / se.Radius;\n    vec3 p = pos + t * dir;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float P = F + B.z;\n\n    float K = P - 1.0;\n    return(K);\n}\n\nvec3 superellipsoidNormal(vec3 p, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 g = 2.0 * e;\n    vec3 invr = vec3(1.0) / se.Radius;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    vec3 C = B / A;\n\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float G = e.z * (F / E);\n\n    vec3 n = g.xxy * C * invr;\n    n.xy *= G;\n\n    n = normalize(n);\n    return(n);\n}\n\n// Ron Goldman \"Curvature formulas for implicit curves and surfaces\"\nfloat superellipsoidGaussianCurvature(Superellipsoid se, vec3 pos)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 invr = vec3(1.0) / se.Radius;\n    \n    vec3 p = (pos - se.Center) * se.Orientation;\n    \n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float P = F + B.z;\n\n    float Fx = e.z * (F / E) * (2.0 * e.x * (B.x / A.x) * invr.x);\n    float Fy = e.z * (F / E) * (2.0 * e.x * (B.y / A.y) * invr.y);\n    float Fz = 2.0 * e.y * (B.z / A.z) * invr.z;\n\n    float Fxx = Fx * (e.z - 1.0) * (1.0 / E) * (2.0 * e.x * (B.x / A.x) * invr.x) + Fx * (2.0 * e.x - 1.0) * (1.0 / A.x) * invr.x;\n    float Fyy = Fy * (e.z - 1.0) * (1.0 / E) * (2.0 * e.x * (B.y / A.y) * invr.y) + Fy * (2.0 * e.x - 1.0) * (1.0 / A.y) * invr.y;\n    float Fzz = Fz * (2.0 * e.y - 1.0) * (1.0 / A.z) * invr.z;\n\n    float Fyx = Fx * (e.z - 1.0) * (1.0 / E) * (2.0 * e.x * (B.y / A.y) * invr.y);\n    float Fxy = Fyx;\n\n    float Fxz = 0.0;\n    float Fzx = 0.0;\n\n    float Fyz = 0.0;\n    float Fzy = 0.0;\n    \n    vec3 nf = vec3(Fx, Fy, Fz);\n    mat3 hs = mat3(vec3(Fyy * Fzz - Fyz * Fzy, Fxz * Fzy - Fxy * Fzz, Fxy * Fyz - Fxz * Fyy),\n                   vec3(Fyz * Fzx - Fyx * Fzz, Fxx * Fzz - Fxz * Fzx, Fyx * Fxz - Fxx * Fyz),\n                   vec3(Fyx * Fzy - Fyy * Fzx, Fxy * Fzx - Fxx * Fzy, Fxx * Fyy - Fxy * Fyx));\n    \n    float D = dot(nf, nf);\n    float Kg = dot(nf, hs * nf) / (D * D);\n\n    return(Kg);   \n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (vmin - pos) / dir;\n    vec3 v2 = (vmax - pos) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid    \n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = tn - 2.0 * dt;\n    float t1 = tn - dt;\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n            break;\n        }\n    }    \n    return(success);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance, out vec3 ipos, out vec3 norm)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (vmin - pos) / dir;\n    vec3 v2 = (vmax - pos) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid\n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = tn - 2.0 * dt;\n    float t1 = tn - dt;\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n        \n            vec3 lpos = pos + t1 * dir;\n            norm = superellipsoidNormal(lpos, se);\n            ipos = se.Orientation * lpos + se.Center;\n            norm = se.Orientation * norm;\n            break;\n        }\n    }\n\n    return(success);\n}\n// ------------------ Superellipsoid ------------------\n\n\n// ------------------ Camera ----------------------\nstruct Camera\n{\n    mat4 invProj;\n    mat4 invView;\n};\n\nCamera cameraConstruct(float fovy, float aspect, float near, float far)\n{\n    fovy = deg2rad(fovy);\n\n    Camera camera;\n    camera.invView = mat4(1.0);\n\n    float d = 1.0 / tan(0.5 * fovy);\n    camera.invProj = mat4(aspect / d, 0.0,      0.0, 0.0,\n                          0.0,   1.0 / d,  0.0, 0.0,\n                          0.0,   0.0,      0.0, (near - far) / (2.0 * near * far),\n                          0.0,   0.0,     -1.0, (near + far) / (2.0 * near * far));\n\n    return(camera);\n}\n\nvoid cameraSetOrientation(inout Camera camera, float pitch, float yaw, float roll)\n{\n    pitch = deg2rad(pitch);\n    yaw = deg2rad(yaw);\n    roll = deg2rad(roll);\n    \n    mat4 m = camera.invView;\n    camera.invView = EulerToMatrix(pitch, yaw, roll);\n    camera.invView[3] = m[3];\n}\n\nvoid cameraSetPosition(inout Camera camera, vec3 origin)\n{\n    camera.invView[3] = vec4(origin, 1.0);\n}\n\nRay cameraGetRay(Camera camera, vec2 uv)\n{\n    Ray ray = rayConstruct(uv, camera.invProj, camera.invView);\n    return(ray);\n}\n// ------------------ Camera ----------------------\n\n\n// ------------------ Lighting ------------------\nstruct Light\n{\n\tvec3 Color;\n\tvec3 Position;\n\tvec3 Direction;\n};\n\nLight constructLight(vec3 c, vec3 o, float theta, float phi)\n{\n    // https://en.wikipedia.org/wiki/Spherical_coordinate_system\n    float ct = cos(theta);\n    float st = sin(theta);\n\n    float cp = cos(phi);\n    float sp = sin(phi);\n    \n    float r = 1.0;\n    float x = r * st * cp;\n    float y = r * st * sp;\n    float z = r * ct;\n\n    Light l;\n    l.Color = c;\n\tl.Position = o;\n\tl.Direction = vec3(x, y, z);\n    \n    return(l);\n}\n\n// Ashikhmin Shirley 2000 (isotropic case)\nvec3 calculateLighting(vec3 I, vec3 L, vec3 V, vec3 N, float Rd, float Rs, float exponent)\n{\n    vec3 H = normalize(L + V);\n    float HdotV = dot(H, V);\n    float NdotH = dot(N, H);\n    float NdotV = dot(N, V);\n    float NdotL = dot(N, L);\n\n    float rho_d = 28.0 / (23.0 * M_PI) * Rd * (1.0 - pow(1.0 - NdotV / 2.0, 5.0)) * (1.0 - pow(1.0 - NdotL / 2.0, 5.0));\n    rho_d *= (1.0 - Rs); // coupled diffuse\n\n    float F = Rs + (1.0 - Rs) * pow(1.0 - HdotV, 5.0);\n    float rho_s = ((exponent + 1.0) / (8.0 * M_PI)) * F * pow(max(NdotH, 0.0), exponent) / (HdotV * max(NdotV, NdotL));\n\n    vec3 brightness = max(0.0, NdotL) * I * (rho_d + rho_s);\n    return(brightness);\n}\n\nfloat calcShadowAttenuation(vec3 ipoint, Light dl, Superellipsoid se)\n{\n    Ray ray = Ray(ipoint, dl.Direction);\n    bool isIntersect = superellipsoidIntersect(se, ray, 1.0e-06);\n    \n    return((isIntersect)? 0.25: 1.0);\n}\n// ------------------ Lighting ------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P = vec3(0.0, 0.0, 0.0); // default viewer position\n    float aspect = iResolution.x / iResolution.y;\n    float near = 0.1;\n    float far = 32.0;\n\n    Camera camera = cameraConstruct(45.0, aspect, near, far);\n    cameraSetOrientation(camera, 0.0, 0.0, 0.0);\n    cameraSetPosition(camera, P);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray ray = cameraGetRay(camera, uv);\n\n    // scene rendering\n    vec3 pos = vec3(0.0, 1.0, 0.0);\n    vec3 normal = vec3(0.0, -1.0, 0.0);\n    Plane spl = planeConstruct(pos, normal); // sky plane\n\n    pos = vec3(0.0, -1.0, 0.0);\n    normal = vec3(0.0, 1.0, 0.0);\n    Plane gpl = planeConstruct(pos, normal); // ground plane\n\n    pos = vec3(0.0, 0.0, -2.5);\n    vec3 radius = vec3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 2.0);\n    Superellipsoid se = superellipsoidConstruct(pos, radius); // object\n\n    vec3 ipoint = ray.Direction * far;\n    vec3 color = SKYColor + ray.Direction.y * 0.72;\n    \n    Light sun;\n    sun.Color = 1.85 * vec3(1.0, 1.0, 1.0);\n    sun.Direction = normalize(vec3(0.5, 0.5, 1.0));\n\n    // ray vs superellipsoid\n    normal = vec3(0.0);\n    bool isIntersect = superellipsoidIntersect(se, ray, 1.0e-06, ipoint, normal);\n    if(isIntersect)\n    {\n        float gc = superellipsoidGaussianCurvature(se, ipoint);\n        vec3 albedo = plasmaQuintic(infinite2Unit(gc));\n\n        // account sun lighting \n        vec3 brightness = calculateLighting(sun.Color, sun.Direction, -ray.Direction, normal, 1.0, 0.25, 128.0);\n\n        Ray ray2 = Ray(ipoint, reflect(ray.Direction, normal));\n        vec3 ipoint2 = vec3(0.0);\n        vec3 normal2 = vec3(0.0);\n\n        // account sky plane lighting \n        isIntersect = planeIntersect(spl, ray2, ipoint2, normal2);\n        if(isIntersect)\n        {\n            brightness += calculateLighting(SKYColor, -spl.Normal, ray2.Direction, normal, 1.0, 0.25, 32.0);\n        }\n\n        // account ground plane lighting (used fake ground colour)\n        isIntersect = planeIntersect(gpl, ray2, ipoint2, normal2);\n        if(isIntersect)\n        {\n            float f = mod(floor(6.0 * ipoint2.z) + floor(6.0 * ipoint2.x), 2.0);\n            vec3 GNDColor = 0.4 + f * vec3(0.6);\n            brightness += calculateLighting(SKYColor * GNDColor, -gpl.Normal, ray2.Direction, normal, 1.0, 0.25, 32.0);\n        }\n\n        color = albedo * brightness;\n    }\n    else\n    {\n        //ray vs ground plane\n        isIntersect = planeIntersect(gpl, ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting \n            vec3 brightness = calculateLighting(sun.Color, sun.Direction, -ray.Direction, normal, 1.0, 0.0, 32.0);\n\n            // account sky plane lighting \n            brightness += calculateLighting(SKYColor, -spl.Normal, -ray.Direction, normal, 1.0, 0.0, 32.0);\n\n            // calculate albedo of ground plane\n            float f = mod(floor(6.0 * ipoint.z) + floor(6.0 * ipoint.x), 2.0);\n            vec3 albedo = 0.4 + f * vec3(0.6);\n\n            color = albedo * brightness;\n\n            // shadow\n            float attenuation = calcShadowAttenuation(ipoint, sun, se);\n            color *= attenuation;\n        }\n    }\n\n    // Tone mapping\n    color = ACESFilm(color);\n    \n    // Exponential distance fog\n    float distance = length(ipoint - P);\n    color = mix(color, 0.85 * FOGColor, 1.0 - exp2(-0.0055 * distance * distance));\n\n    // Gamma correction\n    color = Linear2sRGB(color);\n\n    float vignette = pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.05);\n    fragColor = vec4(color * vignette, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 378, 404, 404, 438], [440, 440, 470, 470, 521], [523, 588, 617, 617, 1133], [1135, 1187, 1210, 1210, 1388], [1390, 1390, 1427, 1427, 1470], [1532, 1598, 1631, 1631, 2015], [2017, 2017, 2065, 2065, 2272], [2274, 2409, 2465, 2526, 2970], [3039, 3132, 3187, 3214, 3577], [3625, 3714, 3761, 3761, 3839], [3841, 3841, 3881, 3881, 4128], [4130, 4130, 4200, 4200, 4513], [4563, 4716, 4779, 4779, 5408], [5410, 5452, 5525, 5525, 5842], [5844, 5844, 5898, 5898, 6282], [6284, 6353, 6421, 6421, 7845], [7847, 7847, 7922, 7941, 9276], [9278, 9278, 9383, 9402, 10926], [10985, 11093, 11166, 11166, 11583], [11585, 11585, 11669, 11669, 11867], [11869, 11869, 11927, 11927, 11972], [11974, 11974, 12016, 12016, 12099], [12154, 12269, 12331, 12396, 12701], [12703, 12746, 12838, 12838, 13415], [13417, 13417, 13488, 13488, 13640], [13641, 13693, 13750, 13750, 17293]], "test": "valid"}
{"id": "4dcBzX", "name": "techTranscendence", "author": "netgrind", "description": "techTranscendence \nusing some nice voronoi maths from here by csbdev https://www.shadertoy.com/view/MdtBz2", "tags": ["tech"], "likes": 34, "viewed": 911, "published": "Public API", "date": "1526408864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//using some nice voronoi maths from here by csbdev https://www.shadertoy.com/view/MdtBz2\n\n#define speed .2\n\nfloat chebychev(vec3 a, vec3 b)\n{\n    return max(max(abs(a.x - b.x), abs(a.y - b.y)), abs(a.z - b.z));\n}\n\n\nfloat manhattan(vec3 a, vec3 b)\n{\n    vec3 d = abs(a - b);\n    return d.x + d.y + d.z;\n}\n\n// iq\nvec3 random3f( vec3 p )\n{\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nfloat voronoi3(vec3 p)\n{\n    vec3 fp = floor(p);\n    \n    float d1 = 1./0.;\n    float d2 = 1./0.;\n    \n    for(int i = -1; i < 2; i++)\n    {\n        for(int j = -1; j < 2; j++)\n        {\n            for(int k = -1; k < 2; k++)\n            {\n                vec3 cur_p = fp + vec3(i, j, k);\n                \n                vec3 r = random3f(cur_p);\n                \n                float cd = 0.0;                    \n                cd = chebychev(p, cur_p + r);\n                d2 = min(d2, max(cd, d1));\n                d1 = min(d1, cd);\n            }\n        }\n    }\n    return clamp(max(0.0, 16.0 * (d2-d1)), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float piT = iTime*3.14159*speed;\n    float linearT = iTime*speed;\n    fragCoord -= iResolution.xy*.5;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv*=20.+pow(smoothstep(.3, -.3, sin(piT+.8-length(uv)*.1)), 1.)*100.;\n    \n    \n\tvec3 c = vec3(0.);\n    uv = abs(uv);\n    uv.x-=linearT*.5;\n    float d = uv.x + uv.y;\n    linearT-= d*.1;\n    uv-=33.333;\n    vec2 off = vec2(sin(cos(piT)-d), cos(sin(piT)+d))*.05;\n    float amp = 1.;\n    for(float i = 2.; i<8.; i++){\n        vec3 m = vec3(\n    \tvoronoi3(vec3(uv,i*5.+ abs(mod(linearT+.15, 2.5)-1.25))),\n    \tvoronoi3(vec3(uv,i*5.+ abs(mod(linearT+.1, 2.5)-1.25))),\n    \tvoronoi3(vec3(uv,i* 5.+ abs(mod(linearT+.05, 2.5)-1.25)))  //*/      \n        );\n        m = pow(m, vec3(2.));\n    \tuv*= .666;\n        uv+=i;\n        if(floor(mod(i, 2.))==1.){\n            c*=m;\n            uv.x+=sin(piT)*amp;\n            //uv.y+=cos(t)*amp;\n        }else{\n            c+=m;\n            uv.x-=sin(piT)*amp;\n            //uv.y-=cos(t)*amp;\n        }\n    \n    }\n    c = c*.333;\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 142, 142, 213], [216, 216, 249, 249, 304], [306, 312, 337, 337, 522], [524, 524, 548, 548, 1150], [1153, 1153, 1210, 1210, 2286]], "test": "valid"}
{"id": "4ddBD4", "name": "My Symbol", "author": "chao_mu", "description": "This is based on my tattoo and personal symbol.", "tags": ["symbol"], "likes": 2, "viewed": 64, "published": "Public", "date": "1525177874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Produce a 1 if the provided value is <= 0, with a small transitional blur\n#define S(v) smoothstep(blur, 0., v)\n\n// Draw (return 1) a circle at the origin with the radius of r. \n#define circle(U, r) S(length(U) - r)\n\n// Draw (return 1) a crescent made from two overlapping circles.\n// The overlap is controlled by the provided offset. The two radiuses are determined by r.\n#define crescent(U, offset, r) circle(U, r) - circle( U - vec2(offset,0), r)\n\n// Draw a line segment of length and width. \n#define segment(U, len, width)  S(abs(U.x) - width) * S(abs(U.y) - len)\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat background(vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float timeMultiplier = random(vec2(uv.y)) / 2.;\n    float seed = uv.x + (iTime * timeMultiplier) * 2.;\n    seed = floor(seed);\n    \n    return random(vec2(seed));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1), so that we can\n    // draw around the origin and be at the center.\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    // Define a gradient to use at edges that is small relative to the size of the screen\n    // this allows to work on multiple resolutions\n    // This value is used in our macros.\n    float blur = 2./iResolution.y;\n    \n    // Draw on either side of the y axis.\n    uv.x = abs(uv.x);\n    \n    float mask = 0.;\n    mask += crescent(uv - vec2(.37, 0.1),  .18, .4);\n    mask += segment(uv, .75, .075);\n    mask += segment((uv + vec2(0, 0.47)), .075, .35);\n    mask = clamp(mask, 0., 1.);\n    \n    mask += background(fragCoord);\n    \n    // Output to screen\n    fragColor = vec4(vec3(mask),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 572, 596, 596, 670], [672, 672, 706, 756, 966], [968, 968, 1025, 1144, 1806]], "test": "valid"}
{"id": "4ddBDl", "name": "2D Moire test 001", "author": "kaiware007", "description": "2D Moire test 001", "tags": ["2d", "noise"], "likes": 4, "viewed": 110, "published": "Public", "date": "1527242424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 pos) {\n\treturn length(uv - pos);\n}\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat circleNoise(vec2 uv, vec2 dotUV, float noiseSize, float noiseVelocity, vec2 noiseOffset)\n{\n    float dotSize = 0.5 + 0.5 * snoise(vec3(dotUV.xy * noiseSize + noiseOffset, iTime * noiseVelocity)); \n    \n    return smoothstep(dotSize, clamp(dotSize - 0.1, 0.0, 1.0), circle(uv, vec2(0.5,0.5)));\n}\n\n// hue/saturate/value\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n\n    uv.x *= iResolution.x / iResolution.y;\t// aspect\n\n    float gridNum = iResolution.x / mix(8.0, 24.0, (0.5 + 0.5 * sin(iTime * 0.1)));\n    vec2 tileUV = fract(uv * gridNum);\n\n    float c1 = circleNoise(tileUV, uv, 2.0, -0.03, vec2(20.8932984, 0.9284));\n    float c2 = circleNoise(tileUV, uv, 3.5, 0.07, vec2(48.3532, 888.242332));\n    float c3 = circleNoise(tileUV, uv, 1.75, -0.1, vec2(120.3145323, 398.3957293));\n    \n    vec3 col1 = hsv2rgb(vec3(iTime * 0.1,       0.25, 1)) * c1;\n\tvec3 col2 = hsv2rgb(vec3(iTime * 0.101 + 0.1, 0.5, 1)) * c2;\n  \tvec3 col3 = hsv2rgb(vec3(iTime * 0.102 + 0.2, 0.75, 1)) * c3;\n\n    vec3 col = mix(mix(col1, col2, c2), col3, c3);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddBDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 61], [63, 117, 138, 138, 175], [176, 176, 203, 203, 251], [253, 253, 274, 274, 2110], [2112, 2112, 2208, 2208, 2412], [2414, 2436, 2458, 2458, 2627], [2629, 2629, 2686, 2686, 3440]], "test": "valid"}
{"id": "4ddBDr", "name": "Mandelbrot generator 2018", "author": "lokmeinmatz", "description": "gens a set", "tags": ["imaginary"], "likes": 3, "viewed": 77, "published": "Public", "date": "1527626946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_IT = 255;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    float ZOOM = 10.0 / (iTime * 1.0 + 1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y) * vec2(ZOOM);\n    uv = uv - vec2(ZOOM / 2.0);\n    uv += vec2(-1.0 - sqrt(iTime) * 0.08, 0.0);\n    \n    int n = 0;\n    vec2 C = uv;\n    \n    while(n < MAX_IT) {\n    \t\n        float aa = uv.x * uv.x - uv.y * uv.y;\n        float bb = 2.0 * uv.x * uv.y;\n        \n        uv.x = aa + C.x;\n        uv.y = bb + C.y;\n        \n        if(abs(uv.x + uv.y) > 16.0) {\n        \tbreak;   \n        }\n        \n        n += 1;\n        \n    }\n\t\n    float brightness = mix(0.0, 1.0, float(n) / float(MAX_IT));\n    \n    \n    vec3 col = vec3(brightness);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 88, 88, 815]], "test": "valid"}
{"id": "4ddBzl", "name": "Cloud/Noise Testing", "author": "noxbuds", "description": "Testing out noise generation.", "tags": ["raymarch", "clouds"], "likes": 1, "viewed": 416, "published": "Public", "date": "1526480110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////\n//                                             //\n//  Raymarching clouds for fun                 //\n//                                  - Noxbuds  //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14159\n#define PHI 1.57080\nfloat cloudCoverage = 0.2;\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\nfloat brightness = 1.0;\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//            RAYMARCHING ALGORITHMS           //\n//                                             //\n/////////////////////////////////////////////////\n\nfloat tHeight1(vec3 p)\n{\n    float h = fbm(p.xz * 0.1) * 9.0;\n    h -= 21.0;\n    return h;\n}\n\n// Calculate terrain height at a point\nfloat tHeight(vec3 p)\n{\n    // Add some bigger shapes, then cut out some\n    // smaller details\n    float h = fbm(p.xz * 0.1) * 8.0;\n    h -= fbm(p.xz * 0.5) * 0.2;\n    h -= fbm(p.xz * 2.0) * 0.1;\n    //h += fbm(p.xz * 0.5) * 2.0;\n    //h += fbm(p.xz * 1.0) * 0.5;\n    //h += fbm(p.xz * 1.5) * 0.2;\n    //h += fbm(p.xz * 2.0) * 0.1;\n    \n    // Move it down\n    h -= 21.0;\n    \n    // Return h\n    return h;\n}\n\n// Calculate distance from terrain\nfloat tMap(vec3 p)\n{\n    // Just do some basic terrain\n    float h = tHeight(p);\n    \n    if (p.y < h)\n        return 0.0;\n    else\n    \treturn p.y - h;\n}\n\nvec3 tNormal(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        tMap(p + eps.xyy) - tMap(p - eps.xyy),\n        2.0 * eps.x,\n        tMap(p + eps.yyx) - tMap(p - eps.yyx)\n    ));\n}\n\nvec3 cNormal(vec3 p)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        tHeight1(p + eps.xyy) - tHeight1(p - eps.xyy),\n        2.0 * eps.x,\n        tHeight1(p + eps.yyx) - tHeight1(p - eps.yyx)\n    ));\n}  \n\n/////////////////////////////////////////////////\n//                                             //\n//             RAYMARCHING ATTEMPTS            //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculates clouds at a point and increments density\nfloat cloudsSS(vec3 cp, out float d)\n{\n    // Grab the cloud height here\n    float chm = 10.0;\n    float h = chm * (max(fbm((cp.xz - iTime * 0.8) * 0.1) + cloudCoverage - 0.2, 0.5) - 0.5);\n    float lh = h * 0.2;\n\n    // Raymarching step size\n    float stepSize = 0.0;\n\n    // If the point is inside a cloud,\n    // increase the density\n    if (cp.y > 1.0 - lh && cp.y < h + 1.0)\n    {\n        float ss = smoothstep(0.0, 0.8, 1.0 + h / chm - cp.y);\n        d += ss;\n    }\n\n    // Set the step size\n    if (cp.y > 0.9 - lh && cp.y < h + 1.1)\n        stepSize = 0.02 + d * 0.1;\n    else\n        stepSize = 0.1 * (1.0 - lh - cp.y);\n    \n    // Return step size\n    return stepSize;\n}\n\n// The core of the code; the raymarcher\nvec3 raymarch(vec2 uv)\n{\n    // Setup sky colour\n    vec3 skyCol1 = vec3(0.53, 0.81, 0.92);\n    vec3 skyCol2 = vec3(0.47, 0.6, 0.85);\n    vec3 col = mix(skyCol1, skyCol2, abs(uv.y) * 0.5);\n    \n    // Make sky colour darker with time\n    col = mix(vec3(mix(0.1, 1.0, abs(uv.y + 0.15) * 0.5)), col, brightness);\n    \n    // Setup raytracing variables\n    float ct = 0.0;\n    float tt = 0.0;\n    float d = 0.0;\n    float maxt = 75.0;\n    \n    // Making the camera hover above the terrain\n    vec2 lp = vec2(0.0, iTime);\n    float h = tHeight1(vec3(lp.x, 0.0, lp.y)) + 22.0;\n    \n    // Setup ray\n    vec3 o = vec3(lp.x, h-20.0, lp.y);\n    vec3 r = vec3(uv, 0.5 * PI);\n    \n    // Run raytracing\n    for (int i = 0; i < 256; i++)\n    {\n        // Setup points to test\n        vec3 cp = o + r * ct;\n        vec3 tp = o + r * tt;\n        \n        // Cutoff terrain further than a certain\n        // amount of units\n        if (length(tp.xz - o.xz) < maxt)\n        {\n            // Normal raymarching\n            // Handle terrain\n            \n            // Distance to terrain\n            float d = tMap(tp);\n            float th = tHeight(tp);\n            \n            // If we hit terrain, colour it in\n            if (d < 0.01)\n            {\n                // Calculate the normal\n                vec3 n = tNormal(tp);\n                vec3 cn = cNormal(tp);\n                \n                // Set a base colour\n                // 0.2, 0.8, 0.3\n                float blend = min((tp.y - th) * 9.0, 1.0);\n                \n                //col = vec3(0.2, 0.8, 0.3) * (1.0 - blend);\n                //col += vec3(1.0) * blend;\n                float angle = dot(vec3(0.0, 1.0, 0.0), cn);\n                \n               \tif (angle > 0.85)\n                    col = vec3(1.0);\n                else\n                    col = vec3(0.5);\n                \n                // Calculate the diffuse colour\n                col *= max(dot(-lightDir, n), 0.0);\n                \n                // Multiply colour by brightness\n                col *= 0.4 + 0.6 * brightness;\n                \n                // Cloud shadows would be nice but\n                // probably pretty expensive!\n                \n                // Stop raytracing when we hit terrain\n                break;\n            }\n            \n            // Increment tt\n            tt += d * 0.3;\n        }\n        \n        // Do cloud things\n        float fi = float(i);\n        float stepSize = cloudsSS(cp + vec3(0.0, (fi * fi * 0.2) / 256.0, 0.0), d);\n        \n        // Increment t.\n        ct += stepSize;\n    }\n    \n    // Cloud colour\n    vec3 cloudCol = vec3(1.1 - cloudCoverage * cloudCoverage);\n    \n    // Blend cloud colour and background\n    if (col == mix(skyCol1, skyCol2, abs(uv.y) * 0.5))\n    \tcol = mix(cloudCol, col, (1.0 / (1.0 + d)));\n    \n    // Return the colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE COMPOSITION              //\n//                                             //\n/////////////////////////////////////////////////\n// Main image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Modify brightness\n    //brightness = 0.5 + 0.5 * sin(iTime + PI);\n    \n    // Cloud coverage\n    //cloudCoverage = 0.3 + 0.3 * sin(iTime);\n    cloudCoverage = 0.4;\n    \n    // Setup colour\n    vec3 col = raymarch(uv);\n    col = 0.2 * col + 0.8 * sqrt(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[943, 961, 983, 983, 1046], [1048, 1066, 1088, 1108, 1621], [1623, 1639, 1658, 1658, 1911], [1913, 2164, 2188, 2188, 2256], [2258, 2297, 2320, 2392, 2706], [2708, 2743, 2763, 2797, 2897], [2899, 2899, 2921, 2921, 3103], [3105, 3105, 3127, 3127, 3325], [3580, 3635, 3673, 3707, 4315], [4317, 4357, 4381, 4405, 7218], [7220, 7495, 7552, 7602, 8033]], "test": "valid"}
{"id": "4ddBzS", "name": "Colors of the wind", "author": "Flopine", "description": "Still experimenting with 2D drawings :)", "tags": ["2d", "fractal"], "likes": 4, "viewed": 112, "published": "Public", "date": "1525734775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, XT95, lamogui for teaching me <3 :)\n\nmat2 rot (float a)\n{float c = cos(a); float s = sin(a); return mat2 (c,s,-s,c);}\n\nvec2 moda (vec2 uv, float per)\n{\n    float a = atan(uv.y,uv.x);\n    float l = length(uv);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nfloat circle (vec2 uv, float r)\n{return smoothstep(r,r+0.01,length(uv));}\n\nvec3 map (vec2 uv)\n{\n    float r = 0.03;\n    float c = circle(uv,r);\n    for (int i=0;i<3;i++)\n    {\n        uv = moda(uv, 3.141592/6.);\n        uv = abs(uv);\n        uv *= rot(3.141592/6.);\n        r += 0.06;\n \t\tuv.x -= 0.45;\n        uv *= rot(iTime*0.3);\n        c *=circle(uv,r);\n    }\n    return ((1.-c)*mix(vec3(1.,0.,0.),vec3(0.3,0.,1.),length(uv)*2.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = map(uv*1.6);\n    \n    // for edges\n    //if (col.b <= 0.5) col = vec3(0.,uv.y+0.3,uv.y+1.1);\n    \n    if (col.b <= 0.0) col = vec3(0.,uv.y+0.3,uv.y+1.1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 112, 112, 172], [174, 174, 206, 206, 333], [335, 335, 368, 368, 408], [410, 410, 430, 430, 772], [774, 774, 831, 881, 1199]], "test": "valid"}
{"id": "4ddfz4", "name": "Pierced_torus", "author": "balkhan", "description": " ", "tags": ["raymarching", "torus"], "likes": 8, "viewed": 450, "published": "Public API", "date": "1526272544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t150\n#define E\t\t0.00001\n\nfloat\tsdTorus( vec3 p, vec2 t );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec2\trot(vec2 p, vec2 ang);\nfloat\tmylength(vec3 p);\nfloat\tmylength(vec2 p);\nvoid\trotate(inout vec2 v, float angle);\n\nfloat\tt;\nvec3\th;\nfloat\tmind;\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    h = vec3(0.);\n    t = iTime;\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(.0, .0, 5.0);\n\n    vec2\tinter = (march(pos, dir));\n\n    col.xyz += h;\n    o.xyz = col.xyz;\n}\n\nfloat\tscene(vec3 p)\n{\n    mind = 1e5;\n    p.z-= -30.;\n    rotate(p.zy, iTime*.25);\n\tvec3\tap = p;\n    \n    vec2 q = vec2(length(p.xy)-25., p.z);\n    float at = atan(ap.x, ap.y);\n\n    float to = cos(at*40.);\n    to = cos(iTime*3.+ ( atan(q.x, q.y)*8.) +at*20.);\n    \n    mind = length(q)-14.-to*.025;\n    mind = max(mind, to);\n    mind = max(mind, -(length(q)-13.998) );\n    h += .00125*vec3(.8, .62, 1.1)*1./max(mind*mind*.1+0.071, .00001);\n    return(mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\tvec3\tdirr;\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n        #ifdef WOBBLY\n        rotate(dirr.xz, sin(t*2.+dist.y*.07)*.07);\n        rotate(dirr.zy, sin(t*3.+dist.y*.07)*.07);\n        #endif\n        //rotate(dirr.xz, +dist.y*.000+.25*sin(t*.25+dist.y*.005) );\n    \tp = pos + dirr * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 500.)\n        {\n           break;\n\t    }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat\tmylength(vec2 p)\n{\n\treturn max(abs(p.x), abs(p.y));\n}\n\nfloat\tmylength(vec3 p)\n{\n\treturn max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddfz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 387, 427, 427, 688], [690, 690, 711, 711, 1149], [1151, 1151, 1183, 1183, 1758], [1760, 1760, 1793, 1793, 1860], [1862, 1862, 1902, 1902, 1977], [1979, 1979, 2003, 2003, 2038], [2040, 2040, 2064, 2064, 2114], [2116, 2116, 2138, 2138, 2345]], "test": "error"}
{"id": "4ddfzs", "name": "Minimalist Galaxy", "author": "rodousse", "description": "Simple addition of strange lights.\nThe lights are only a sum of the absolute value of inverse functions in 2D with the \"planets\" centers for origins.\nReally easy to do.\nPretty chill !\n\n", "tags": ["space"], "likes": 8, "viewed": 513, "published": "Public API", "date": "1526416295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define ROWS 3\n#define NB_BALLS_PER_ROW 7\n#define ROTATION_ANGLE PI/7.0\n\n\nfloat ballProximity(float radius, float time, vec2 fragCoord)\n{\n    float proximity = 0.0;\n\tvec2 circleCenter = vec2(0.0,0.0);\n    \n    //New galaxy center position\n    circleCenter = vec2(cos(time)*radius , sin(time)*radius);\n    \n    //squeeze the galaxy vertically\n    circleCenter /= vec2(1.0,2.5);\n    \n    float cosRot = cos(ROTATION_ANGLE);\n    float sinRot = sin(ROTATION_ANGLE);\n    //Rotate\n    circleCenter = vec2(cosRot* circleCenter.x + -sinRot*circleCenter.y,\n    \t\t\t\t\tsinRot*circleCenter.x + cosRot*circleCenter.y);\n    \n    //Center on the screen\n    circleCenter += vec2(iResolution.x/2.0,iResolution.y/2.0);\n    \n    proximity = distance(fragCoord, circleCenter);\n    \n    ///lol looks like eyes without this line commented\n    //proximity -= distance(fragCoord, (iResolution.xy/2.0))/50.0;\n    return 1.0/proximity;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    float proximity = abs(1.0/(fragCoord.x - iResolution.x/2.0));\n    vec3 col = vec3(0.0);\n    \n    float time= (1.0*iTime);\n    float radius = 50.0;\n    float lightReduce = 0.5;\n    \n    //add center of galaxy\n    col = col + vec3(2.0*ballProximity(0.0, time, fragCoord));\n    \n    //add all the other planets/Suns/whateveryouwant\n    for(int i = 0; i < ROWS; i++)\n    {\n        \n        for(int j = 0; j < NB_BALLS_PER_ROW; j++)\n        {\n            col = col + vec3(lightReduce*ballProximity(radius, time + (2.0*PI*float(j))/ float(NB_BALLS_PER_ROW), fragCoord));\n        }\n        \n        radius = radius*2.0;\n    \ttime = time/2.0;\n        lightReduce *= 2.0;\n    }\n    \n    //Mid Clip to negative color\n    //col = mix(col, 1.0-col, clamp(fragCoord.x-iResolution.x/2.0,0.0,1.0));\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddfzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 157, 157, 930], [933, 933, 990, 990, 1871]], "test": "valid"}
{"id": "4dtfDB", "name": "PBR_MP/MR", "author": "Ripoll97", "description": "A testing shader for PBR light", "tags": ["pbr"], "likes": 2, "viewed": 123, "published": "Public", "date": "1526598864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nTaking IQ's https://www.shadertoy.com/view/Xds3zN and commenting it extensively to make it easier to learn from.\n*/\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 1   // make this 1 if your machine is too slow\n\n//------------------------------------------------------------------\n// Distance functions\n//\n// Each function gives the distance from p to a primitive centered at the origin.\n// The position and orientation of the primitive is fixed. To simulate moving\n// the primitive, transform p in the opposite way.\n//\n// The s and u prefixes tell whether the result is signed or unsigned.\n// A signed function will return negative values for p inside the primitive;\n// an unsigned function will return 0.\n\n// Distance from p to plane (at y = 0)\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Distance from p to sphere of radius s (centered at origin)\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// Distance from p to box whose half-dimensions are b.x, b.y, b.z\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Distance from p to ellipsoid the length of whose semi-principal axes is r.x, r.y, r.z\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// Distance from p to box of half-dimensions b.x,y,z plus buffer radius r\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// Distance from p to horizontal torus with major radius t.x and minor radius t.y\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// Distance from p to cylinder of radius r with spherical ends centered at a and b.\n// This is a rare exception to the rule that all primitives are centered at the origin.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n// Distance from p to cylinder with radius h.x and half-length h.y.\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance from p to a cone of height c.z whose vertex is at the origin\n// and is pointing up.\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2(length(p.xz), p.y );\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\n// Euclidean distance function (same as builtin length(p)?)\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// Non-Euclidean distance function, so the sphere \"length6(p) = k\" is squarish.\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// Non-Euclidean distance function, so the sphere \"length8(p) = k\" is more squarish.\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// A torus with a squarish minor cross section, using non-Euclidean distance function.\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// A torus with squarish major and minor cross sections, using non-Euclidean distance function.\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\n// a cylinder with squarish horizontal cross-section, with radius h.x and half-length h.y.\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n// CSG operations\n\n// subtract primitive 2 from primitive 1, where d1 is distance to primitive 1.\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n// union primitives 1 and 2\n// d1 is a vec2 where .x is the distance, and .y is the color/material code.\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// intersection of two primitives\nfloat opI( float d1, float d2 )\n{\n    return max(d1, d2);\n}\n\n// Smooth minimum (polynomial smin())\n// See http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat opBlend( float d1, float d2 ) {\n    const float k = 0.1;\n    float h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n// -------------------------------- \t\tLIGHT PBR FUNCTIONS \t-------------------------- \n\n\nfloat roughness;\n\nvec3 fresnelPBR(vec3 q, vec3 l, vec3 h) {\n    float lh = dot(h, l);\n\treturn (q+(1.0 - q)*(1.0 - lh)); \n}\n\nfloat distributionPBR(float a, vec3 n, vec3 h) {\n    float aa = a * a;\n    float numerator = a * a;\n    float nh2  = dot(n, h) * dot(n, h);\n\t\n    float denominator  = (nh2 * (numerator - 1.0) + 1.0);\n    denominator        = 3.1415 * (denominator * denominator);\n\t\n    return numerator/denominator;\n}\n \t\nfloat geometryPBR(float q, vec3 n, vec3 l, vec3 v)\n{\n   /* float nom = pow((q + 1.0), 10.0);\n    nom = nom / 8.0;\n    float nl = dot(n,l);\n\t\n    return nl / (nl * (1.0 - nom) + nom);*/\n    \n    float NL = dot(n, l);\n    float NV = dot(n, v);\n    float numerator = NL * NV;\n    return numerator / max(NL, NV);\n}\n\n\n//------------------------------------------------------------------\n// Domain operations\n\n// Repetition over grid with spacing c.x, c.y, c.z\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Domain deformation: transform the input point p before passing to distance function.\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(20.0 * p.y);\n    float s = sin(20.0 * p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\n\n//------------------------------------------------------------------\n// Return (x,y) where x is minimum distance from pos to objects in the scene, and\n// y is the material of the closest object.\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\tres = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opI( sdBox(    pos-vec3( 2.0,0.2, 1.0), vec3(0.20)),\n\t                           sdSphere( pos-vec3( 2.0,0.2, 1.0), 0.25)), 113.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    // distance deformation (knobbly sphere):\n\tres = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 )\n                           + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z)\n                         , 65.0 ) );\n    \n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(    pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\tres = opU( res, vec2( 0.3*sdTorus( opCheapBend(pos-vec3( 2.0,0.25,-1.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n    // scaled primitive:\n    const float scale = .4;\n    res = opU( res, vec2( sdSphere((pos - vec3(-2.0, 0.25, -2.0))/scale, 0.25)*scale, 70. ) );\n    \n    res = opU( res, vec2( opBlend( sdBox(      pos-vec3( 2.0,0.25, 0.0), vec3(.15,.05,.15) ),\n                                   sdCylinder( pos-vec3( 2.0,0.25, 0.0), vec2(0.04,0.2))), 75. ) );\n    return res;\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal( in vec3 pos )\n{\n    // epsilon = a small number\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    // background sky color gradient\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    // cast ray to nearest object\n    vec2 res = castRay(ro,rd);\n    float t = res.x; // distance\n\tfloat m = res.y; // material code\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor ); // reflected ray\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m < 1.5 )\n        {\n            // gray checkerboard floor material\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n        \n\n    \tvec3 q = vec3(0.99, 0.86, 0.57);\n   \t\tvec3 lig = normalize( vec3(-0.4, 0.3, -0.6) ); // direccio del llum\n\t\tvec3 h = normalize(lig - rd); // half vector\n \t\tfloat occ = calcAO( pos, nor );\n\t\tvec3 ambient = col*vec3(0.01,0.02,0.04); // ambient light\n        \n        float roughness = 0.3;\n        \n        vec3 F =  fresnelPBR(q, lig, nor);\n    \tfloat D = distributionPBR(roughness, nor, h);\n        //float D = (roughness*roughness)/3.1415*(pow(pow(dot(nor, h),2.0)* ((roughness*roughness)-1.0)+1.0,2.0));\n    \tfloat G = - geometryPBR(roughness, nor, lig, rd);\n        \n    \tvec3 res = vec3(0.0);\n        //PBR\n  \t\tvec3 specular = F * D * G;\n       \tfloat denominator = 4.0 * dot(nor, rd) * dot(nor, lig);\n\t\t//specular = specular / denominator;\n        //col = F * ambient;\n        col = ambient * 5.0 + col * specular + col*max(0.0,dot(lig,nor))*(2.5);\n        \n    \t//vec3 PBR = numerator / max(denominator, 0.001);\n        \n    \t//res += PBR;\n        //col += 0.4 * ambient;\n\t\t//col *= res;\n\t\t\n\t\t// H = normalize(L, V)\n\t\t// Trobar posició llum\n        \n        // lighting        \n        /*float occ = calcAO( pos, nor ); // ambient occlusion\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) ); // sunlight\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 ); // ambient light\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); // diffuse reflection from sunlight\n        // backlight\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y ); // dome light\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 ); // fresnel\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0); // specular reflection\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        //lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\t//lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        //lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        //lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n        // mix in fog?*/\n    \t//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera (ro = ray origin)\t\n        vec3 ro = vec3( 4.0*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtfDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1110, 1149, 1174, 1174, 1189], [1191, 1253, 1288, 1288, 1314], [1316, 1382, 1413, 1413, 1504], [1506, 1595, 1638, 1638, 1698], [1700, 1774, 1819, 1819, 1861], [1863, 1945, 1978, 1978, 2035], [2037, 2037, 2073, 2073, 2315], [2317, 2489, 2541, 2541, 2655], [2657, 2657, 2693, 2693, 2941], [2943, 3011, 3047, 3047, 3146], [3148, 3244, 3282, 3282, 3451], [3453, 3453, 3525, 3525, 3740], [3742, 3742, 3809, 3848, 4220], [4222, 4282, 4307, 4307, 4344], [4346, 4426, 4451, 4451, 4509], [4511, 4596, 4621, 4621, 4686], [4688, 4775, 4810, 4810, 4881], [4883, 4979, 5014, 5014, 5085], [5087, 5178, 5215, 5215, 5268], [5358, 5437, 5470, 5470, 5496], [5498, 5603, 5633, 5633, 5666], [5668, 5702, 5735, 5735, 5761], [5763, 5861, 5898, 5898, 6020], [6023, 6130, 6171, 6171, 6234], [6236, 6236, 6284, 6284, 6536], [6540, 6540, 6592, 6724, 6850], [6944, 6995, 7025, 7025, 7054], [7056, 7145, 7169, 7169, 7301], [7303, 7303, 7331, 7331, 7454], [7457, 7652, 7677, 7677, 10518], [10520, 10694, 10734, 10734, 11353], [11355, 11578, 11652, 11652, 11912], [11914, 11992, 12024, 12056, 12500], [12502, 12562, 12604, 12604, 12903], [12905, 12980, 13019, 13057, 16010], [16012, 16055, 16107, 16107, 16286], [16288, 16288, 16345, 16345, 17321]], "test": "valid"}
{"id": "4dtfRB", "name": "aléatoire_bruit_01", "author": "louis_C", "description": "test d'éléments 2d avec bruit", "tags": ["randomnoise"], "likes": 6, "viewed": 196, "published": "Public", "date": "1526307212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand ( vec2 uv) {return  fract(sin(dot(floor(uv),vec2(75.365,12.365)))*4285.365);}\nfloat noise ( vec2 uv) {\nfloat a = rand(uv+iTime);\nfloat b = rand (uv+vec2(1,0)-iTime);\n float c  = rand (uv+vec2(0,1)+iTime);\n float d  = rand ( uv+vec2(1,1)-iTime);\nvec2 u = smoothstep (0.0,1.0,fract(uv));\nreturn mix (a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv =-1.+2.* fragCoord/iResolution.xy;\n  float noi = noise(vec2(noise(uv*15.),noise(uv*10.))*25.);\n         float random = (fract((sin(dot(vec2(75.2654,12.3625),floor(uv*200.))))*4593.39+iTime*10.)); \n    float random2 = fract(sin(iTime)*45886.3265+iTime);\n    vec2 uv2 = uv*distance(vec2(0),uv*random2*2.)+noi;\n    \n    float bl1 = 0.05;\n    float h1 = -0.8;\n    float int01 = 0.1;\n    float nbr1 =1.;\n    float li01 = 0.;\n    float resu = 0.;\n    \n    for( int i =0 ;i<40;i++){\n        float j = float (i);\n      h1 = -0.8*(0.025*j);\n      nbr1 = mix(12.,25.,iTime*5.);\n      nbr1 +=(40.-j)*0.5;\n      int01 = 0.1;\n      int01=j*0.01;\n     li01 = smoothstep(h1+bl1,h1-bl1,uv2.g+=sin(uv.r*nbr1+(sin(uv2.g*20.+iTime)*(1.))+(sin(uv2.g*20.-iTime)*0.1)+sin(iTime)+random2*10.)*int01)*0.025;\n     resu +=li01;\n     \n   }\n   float resu3 = mix(1.-resu,resu,random2);\n   \n   float pt01 = mod(smoothstep(0.5,mix(0.1,0.9,sin(iTime*10.)),distance (vec2(0.),uv*random2*vec2(2.,1.))),sin(iTime)+random);\n   float resu2 = mix(1.-resu3,resu3,pt01);\n    \n    fragColor = vec4(resu2,resu2,resu2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dtfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 88], [89, 89, 113, 113, 354], [355, 355, 412, 412, 1511]], "test": "valid"}
{"id": "4dVBR1", "name": "Golfing Ribbon Assault - 277c", "author": "GregRostami", "description": "This is the golfed version of Dave_Hoskins' gorgeous shader.\n[url]https://www.shadertoy.com/view/MdBGDK[/url]\nTry moving the mouse in full-screen!\nA BIG thanks to Fabrice Neyret for his brilliant help in reducing this.", "tags": ["ribbon", "twotweets", "ribbonassault", "short", "golf"], "likes": 10, "viewed": 643, "published": "Public API", "date": "1527616116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 277 chars - Reduced by Greg Rostami and Fabrice Neyret (AKA Yoda).  ;-)\n\nvoid mainImage(out vec4 o, vec2 U) {                                                    \\\n    float T = iTime*.2, i=0.;\n\tfor( vec2 f = vec2(-3,3), r = iResolution.xy, u = (U+U-r) / r.y,\n        p = ( iMouse.z < .5\n               ? r*cos(T)\n               : iMouse.xy -r)/r.y;\n         i++ < 20. ;\n         o = abs( log(f*f)/vec2(16,7)).xxyy )\n             u = vec2( u.x, -u.y ) / dot(u,u) + p,\n             u.x =  abs(u.x),\n             f = max( f, vec2( -sin(dot(u+p,u+p))-1., dot(u-p,u-p) ));\n\n         o.g *= o.a;} /*      \n\n        \n// 565 chars - Original Shader by Dave Hoskins\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gTime = iTime+11.0;\n\n    float f = 3., g = 3.;\n\tvec2 res = iResolution.xy;\n\tvec2 mou = iMouse.xy;\n\tif (iMouse.z < 0.5)\n\t{\n\t\tmou = vec2(sin(gTime * .3)*sin(gTime * .17) * 1. + sin(gTime * .3),(1.0-cos(gTime * .632))*sin(gTime * .131)*1.0+cos(gTime * .3));\n\t\tmou = (mou+1.0) * res;\n\t}\n\tvec2 z = ((-res+2.0 * fragCoord.xy) / res.y);\n\tvec2 p = ((-res+2.0+mou) / res.y);\n\tfor( int i = 0; i < 20; i++) \n\t{\n\t\tfloat d = dot(z,z);\n\t\tz = (vec2( z.x, -z.y ) / d) + p; \n\t\tz.x =  abs(z.x);\n\t\tf = max( f, (dot(z-p,z-p) ));\n\t\tg = min( g, sin(dot(z+p,z+p))+1.0);\n\t}\n\tf = abs(-log(f) / 3.5);\n\tg = abs(-log(g) / 8.0);\n\tfragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 112, 112, 593]], "test": "valid"}
{"id": "4dVBzz", "name": "Toolbox of Noisey Goodness", "author": "James_Harnett", "description": "32 bit Integer Hash Functions that seem to have about 27 visually random bits\nhash1 uses the max number of bits for a float\nhash2 uses 14 good bits each component\nhash3 uses 9 good bits each component\nhash4 uses 7 good bits each component", "tags": ["noise", "hash", "rand", "rng"], "likes": 11, "viewed": 489, "published": "Public", "date": "1527492499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//This is free and unencumbered software released into the public domain. http://unlicense.org/\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(ivec2(fragCoord)+2*iFrame);\n\tint cx = int(fragCoord.x) - (int(iResolution.x)>>1);\n    int cy = int(fragCoord.y) - (int(iResolution.y)>>1);\n    \n    float h1 = hash1(coord2(p));\n    vec2 h2 = hash2(coord2(p));\n    vec3 h3 = hash3(coord2(p));\n    vec4 h4 = hash4(coord2(p));\n    \n    vec3 col;\n   \tif(cx < 0 && cy < 0)col = vec3(h1);\n    if(cx > 0 && cy < 0)col = vec3(h2.x * h2.y);\n   \tif(cx < 0 && cy > 0)col = vec3(h3);\n    if(cx > 0 && cy > 0)col = vec3(h4.xyz * h4.w);\n       \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVBzz.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 393, 413, 413, 439], [440, 440, 459, 459, 504], [505, 505, 524, 524, 577], [578, 578, 597, 597, 658], [660, 660, 717, 717, 1250]], "test": "valid"}
{"id": "4dyfzh", "name": "Szívverés", "author": "meszarosanna", "description": "1", "tags": ["1"], "likes": 1, "viewed": 66, "published": "Public", "date": "1527801311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    float x=uv.x;\n    float m;\n    if (x<-0.2)\n    {m=0.0;}\n    if (-0.2<= x && x<-0.15)\n    {m= abs(x+0.175)-0.025;}\n    if(-0.1<x && x<= -0.05)\n    {m=-abs(5.0*x+0.25)+0.25;}\n    if (-0.05<x && x<=0.05)\n    {m=-6.3*x-0.08;}\n    if(0.05<x && x<=0.1)\n    {m= abs(8.0*x-0.4)-0.4;}\n    if(0.1<x && x<=0.17)\n    {m=-abs(10.0*x-1.35)+0.35;}\n    if(0.25<x && x<=0.35)\n    {m=abs(2.0*x-0.6)-0.1;}\n    uv.y+=m;\n\tfloat b1 =smoothstep(-0.015, -0.005, uv.y);\n    float b2 =smoothstep(0.015, 0.005, uv.y);\n    vec3 color;\n    if((abs(sin(iTime)))<=(100.0*sin(2.0*(iTime))) && x<=(abs(sin(iTime))-0.5))\n    {\n        color = vec3(0.0,0.5,0.0)*b1*b2;\n        fragColor=vec4(color, 1.0);\n    }\n    else if ((abs(sin(iTime)))> (100.0*sin(2.0*(iTime))))\n    {\n        color = vec3(0.0,abs(sin(iTime))-0.5,0.0)*b1*b2;\n        fragColor=vec4(color, 1.0);\n    }\n    \n    \n    \n     \n    \n    \n         \n    \n    \n    \n    \n    \n}", "image_inputs": [{"id": "lsjSzV", "previewfilepath": "https://soundcloud.com/user-672722652/heart-beat", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-672722652/heart-beat", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyfzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1021]], "test": "valid"}
{"id": "4l2BRD", "name": "aafloor", "author": "dahart", "description": "Anti-aliased floor & fract functions", "tags": ["antialias", "floor"], "likes": 2, "viewed": 56, "published": "Public", "date": "1525556889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define S(a,b,t) smoothstep(a,b,t)\n#define L(a,b,t) S(a,b,t*2.)*S(a,b,2.-t*2.)\nconst vec2 X = vec2(1.0, 0.0);\nconst vec3 nop = vec3(-1.0, 0.0, 1.0);\nconst float PI = 3.14159265358979323;\nconst float fMaxFloat = intBitsToFloat(0x7f7fffff);\nconst vec3 white = X.xxx;\nconst vec3 blue = vec3(.1, .5, 1.);\nconst vec3 black = X.yyy;\n\n// remap v from range [min1,max1] to range [min2,max2]\n// this is unlerp+lerp combined\nfloat remap(float v, float min1, float max1, float min2, float max2) {\n    return min2 + (max2 - min2) * (v - min1) / (max1 - min1);\n}\n\nfloat bias(float x, float b) { return pow(x,log(b)/log(0.5)); }\nfloat gain(float x, float g) { return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.; }\n\n// aaFloor is similar to floor() but has a 2-pixel wide gradient between clamped steps\n// to allow the edges in the result to be anti-aliased.\nfloat aaFloor(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? x - fx : remap(fx, idx, 1., x-fx, x);\n}\n\n// Same as aaFloor; clamp except for a 2-pixel wide gradient along the edge\nfloat aaFract(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? fx : remap(fx, idx, 1., fx, 0.);\n}\n\n// escalator() is similar to aaFloor(), but takes a phase offset for animating\nfloat escalator(float x, float steps, float o) {\n    float dx = 1. / steps;\n    x = remap(x, 0., 1., -dx/2., 1.+dx/2.) + dx/2.;\n    float ex = (x - o*dx) * steps;\n    float ey = (aaFloor(ex) + o) * dx;\n    return clamp(ey, 0., 1.);\n}\n\nvec3 Void( vec2 uv )\n{\n    vec4 d, e;\n    float time = iTime + iMouse.x/iResolution.y;\n\tfloat color = 0.;\n    float dx = dFdx(uv).x * 2.;\n\n    float bx0 = -.1;\n    float bx1 = 1.1;\n    float by0 = -.1;\n    float by1 = 1.1;\n    vec2 buv = vec2(remap(uv.x, 0., 1., bx0, bx1), remap(uv.y, 0., 1., by0, by1));\n    float x = buv.x;\n    float y;\n    \n    float sx = sin(time);\n    float sy = cos(time);\n    \n    if (bool(0)) \n    {\n        // render a grating with increasing frequency, to force aliasing\n        y = 1./6. * aaFloor(4.+2.5*sin(pow(buv.x*sx*6. + buv.y*sy*6., 3.5)));\n        // compare aaFract() to regular fract()\n        if (bool(1)) y = aaFract(pow(buv.x*sx*10. + buv.y*sy*10., 2.5));\n        else         y = fract(pow(buv.x*sx*10. + buv.y*sy*10., 2.5));\n        return mix(black, white, y);\n    }\n    else\n    {\n        // render a plot of the escalator function\n        y = escalator(buv.x, 5., time);\n        //y = aaFloor(buv.x*5.)/5.;\n\n        if (abs(buv.y - y ) < dx) return white;\n        if (abs(buv.x - 0.) < dx) return blue;\n        if (abs(buv.x - 1.) < dx) return blue;\n        if (abs(buv.y - 0.) < dx) return blue;\n        if (abs(buv.y - 1.) < dx) return blue;\n        return black;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float margin = .5 * (iResolution.x - iResolution.y);\n\tvec2 uv = (fragCoord.xy - X*margin) / iResolution.yy;\n    if (uv.x >= 0.0 && uv.x <= 1.0) fragColor = vec4(Void(uv), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2BRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 416, 486, 486, 550], [552, 552, 582, 582, 615], [616, 616, 646, 646, 714], [716, 859, 883, 883, 1039], [1041, 1117, 1141, 1141, 1292], [1294, 1373, 1421, 1421, 1606], [1608, 1608, 1630, 1630, 2828], [2830, 2830, 2887, 2887, 3070]], "test": "error"}
{"id": "4s3BDf", "name": "Spirit ⠁⣚|", "author": "lejeunerenard", "description": "Daily for 2018-04-19\n\n[url=https://www.instagram.com/p/Bhx8bragKzM/]Instagram Post[/url]", "tags": ["noise", "color", "gradient", "additivemixing"], "likes": 2, "viewed": 123, "published": "Public", "date": "1526944927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n#define time iTime\n#define slowTime (0.2 * iTime)\n\nfloat cnoise2 (in vec2);\n\nvec3 pattern (in vec2 uv) {\n  vec3 color = vec3(0);\n\n  float modT = mod(time, 10.0);\n\n  // Circle params\n  const float cropD = 0.7;\n\n  uv += 0.1 * cnoise2(371.8 * uv.yx + time);\n  vec2 q = uv;\n\n  const float cycleR = 0.125;\n  const float startR = 0.3;\n  const float endR = 0.5;\n  q += vec2(\n      cycleR * cos(PI * slowTime),\n      cycleR * sin(PI * slowTime));\n\n  color.r += smoothstep(endR, startR, length(q));\n\n  q = uv;\n  q += vec2(\n      cycleR * cos(PI * (slowTime + 0.5)),\n      cycleR * sin(PI * (slowTime + 0.5)));\n\n  color.g += smoothstep(endR, startR, length(q));\n\n  q = uv;\n  q += vec2(\n      cycleR * cos(PI * (slowTime + 1.0)),\n      cycleR * sin(PI * (slowTime + 1.0)));\n\n  color.b += smoothstep(endR, startR, length(q));\n\n  return color;\n\n}\n\nvoid colorMap (inout vec3 color) {\n  float l = length(vec4(color, 1.));\n  // Light\n  color = mix(vec3(0, 0.701961, 0.784314), color, 1. - l * .05125);\n  // Dark\n  color = mix(vec3(0.623529, 0.403922, 0.278431), color, clamp(exp(l) * .255, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalize to [-1, -1] -> [1, 1]\n  vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n  vec3 color = pattern(uv);\n\n  // Post process\n  vec3 colorBefore = color;\n  colorMap(color);\n  color = mix(color, colorBefore, 0.85);\n\n  const vec3 gammaEnc = vec3(0.454545);\n  color = pow(color, gammaEnc);\n    \n  // Output to screen\n  fragColor = vec4(color,1.0);\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise2(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3BDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 156, 156, 885], [887, 887, 921, 921, 1137], [1139, 1139, 1196, 1233, 1563], [1565, 2010, 2031, 2031, 2080], [2082, 2082, 2104, 2104, 2141], [2143, 2143, 2171, 2171, 2223], [2225, 2225, 2244, 2244, 2284], [2286, 2310, 2333, 2333, 3367]], "test": "error"}
{"id": "4s3Bzs", "name": "Aliasing noise", "author": "Orpheon", "description": "Random flimmering noise construction from a boring lecture.", "tags": ["noise", "simple", "aliasing", "abstract", "flimmering"], "likes": 3, "viewed": 97, "published": "Public", "date": "1526302319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sigmoid(float x) \n{\n\tfloat expx = exp(x);\n    return expx/(expx+1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = ( 2.*fragCoord - iResolution.xy ) / iResolution.x;\n    \n    float angle = atan(xy.y, xy.x);\n    if (abs(angle) < 3.1415/2.0)\n    {\n    \tangle += sign(angle)*3.1415/2.0;\n    }\n    angle = pow(abs(angle), 4.0);\n    \n    vec2 pattern = vec2(mod(angle,\n                            pow(abs(sigmoid(sin(length(xy)*(3.0+sin(iTime*0.3))+1.0))-1.0), 3.0)\n                           ))*20.0;\n    float s = pow(1.0 - length(pattern), 2.0);\n    float d = min(1./length(xy), 1.0);\n    vec3 col = vec3(\n        sigmoid(0.3*d)*s,\n        sigmoid(0.2*d)*s,\n        sigmoid(0.1*d)*s);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 77], [79, 79, 136, 136, 753]], "test": "valid"}
{"id": "4s3fzs", "name": "bang bang portal", "author": "jes5199", "description": "sorry I haven't curated these yet, but this is a slowly zooming version of the portal at the end of my talk!\n\nI'm writing up some detailed notes now, and should have those up sometime this week. Thanks for watching!\n\n", "tags": ["demo", "2018", "bangbangcon"], "likes": 4, "viewed": 230, "published": "Public", "date": "1526309340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 30.0 + iTime / 3.;\n    \n    // convert the screen coordinates into something more mathy\n\tvec2 uv = zoom * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    float breathe = iTime;\n    float value = breathe + (uv.x * sign(uv.y) + uv.y * sign(uv.x)) * sin(uv.x) * sin(uv.y);\n               \n    float color = sin(value);\n    color = color * sign(uv.x) * sign(uv.y); // alternate colors by corner\n\n    \n    // this is not the cleanest way to\n    // make the white-blue-black-red-white gradient\n    // but it works\n    color = color * 3.;\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.0;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, high,1.0);\n    } else {\n      fragColor = vec4(high, high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s3fzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 853]], "test": "valid"}
{"id": "4scBDB", "name": "basemodel", "author": "louis_C", "description": "modeling", "tags": ["raymarching"], "likes": 20, "viewed": 295, "published": "Public", "date": "1526995686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sph (vec3 pos, float radius){\nreturn length(pos)-radius;\n}\nfloat cyl (vec3 pos , vec2 h){\n    vec2 d = abs (vec2(length(pos.xz),pos.y))-h;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.));\n}\nfloat cyl2 (vec3 pos , vec2 h){\n    vec2 d = abs (vec2(length(pos.xz),pos.y))-h;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.))-0.15;\n}\nfloat plane (vec3 pos , vec4 n){\n    return dot(pos,n.xyz)+n.w;}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nvec4 map (vec3 pos){\nvec4 scene = vec4(1.);\nfloat s1 = Sph(pos,2.);\nfloat s1bis = Sph(pos,2.15);\nfloat s2 = cyl(pos+vec3(0.,-3.8,0.),vec2(2.,2.));\n    float s2bis = cyl2(pos+vec3(0.,-3.8,0.),vec2(2,2));\nfloat s3 = min(s1,s2);\n    float s3bis = smin(s1bis,s2bis,0.5);\n    float reg = smoothstep(0.75,0.6,fract(iTime*0.2));\n float s4 = distance(pos.y,mix(-10.,10.,fract(iTime*0.2)))-3.\n     +(sin(pos.x*5.)+sin(pos.z*5.));   \n    float s6 = length(pos.xz-vec2(0.))-2.;\n    float s8 = distance(pos.xz,vec2(0.))-0.5;\n    float s9 = smin (s3bis,s8,1.);\n    float s7 = max (s4,s9);\n    float s5 = min (s3,s7);\n    float sepa = mix(0.,1.,smoothstep(0.,0.1,s2));\n    float sepa2 = mix(0.,1.,smoothstep(0.,0.1,s7));\n scene = vec4(vec3(length(pos.xz)*0.5,sepa,sepa2),s5);\n \nreturn scene;\n}\nvec3 getN (vec3 pos) {\n    float e = 0.01;\n    return normalize(vec3(map(pos+vec3(e,0,0)).w-map(pos-vec3(e,0,0)).w,\n                          map(pos+vec3(0,e,0)).w-map(pos-vec3(0,e,0)).w,\n                          map(pos+vec3(0,0,e)).w-map(pos-vec3(0,0,e)).w));}\nfloat getShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 1.;\n    float t =.001*1000.;\n    for (float i = 0.; i <= 1.; i += 1./64.) {\n        float dist = map(pos + dir * t).w;\n        if (dist < .001) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\nfloat overlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\nvec3 overlay(vec3 base, vec3 blend) {\n\treturn vec3(overlay(base.r,blend.r),overlay(base.g,blend.g),overlay(base.b,blend.b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv =1.-2.* fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0.,0.,-4.);\n    vec3 ray = normalize(vec3(uv,1.));   \n    vec3 pos = eye;\n    float shade = 0.;\n    for (int i=0; i<64;++i){\n    float dist = map(pos).w;\n    if(dist<0.001){\n    shade = 1.-float(i)/64.;\n    break;\n    }\n    pos += ray*dist;\n    }\n    vec3 lipos = vec3(-3.,-1.,-5.);\n    vec3 lidir = normalize(lipos-pos);\n    vec3 nor = getN(pos);\n \tfloat shadow =getShadow(pos, lipos, 64.)*clamp(dot(lidir,nor),0.,1.);\n   float test =clamp( map(pos).w,0.,1.);\n    float fres = 1.-clamp(-dot(nor,vec3(0.,0.,1.)),0.,1.);\nfloat test2 =smoothstep(0.,1.,mix(map(pos).x,mix(map(pos).x,1.,step(0.,-nor.y)),\n                                   map(pos).y));\n    vec3 col1 = mix(clamp(mix(vec3(0.5,0.5,0.59),vec3(1.),(shadow*0.8)*test2)+\n              (fres*0.4)-(clamp(-nor.y,0.,1.))*0.2*(1.-map(pos).y),0.,1.),\n        mix(vec3(1.),vec3(0.5,0.5,0.59),distance(vec2(0.),uv*0.5)),test)\n        *clamp(test2+vec3(0.42,0.42,0.45),0.,1.);\n    vec3 col2 = (col1-0.5)*0.5+0.5+0.25; \n    float spec = pow(clamp(dot(nor,vec3(0.,0.,-1.)),0.,1.),200.);\n    vec3 col3 = clamp(mix(vec3(1.,0.,1.),vec3(1.,0.5,1.),shadow)+fres*clamp\n                      (-uv.y*2.+1.,0.,1.)+spec*0.5,0.,1.);\n    vec3 col4 = mix (col3,col2,map(pos).z);\n        vec2 uv2 = uv*nor.xy*3. ;\n    float col5 =clamp(smoothstep(1.5,0.5,distance(vec2(0.),uv2))+0.3,0.,1.)*\n        clamp(smoothstep(0.8,0.2,distance(vec2(0.),uv2))+0.5,0.,1.)*\n        clamp(smoothstep(0.4,0.,distance(vec2(0.),uv2))+0.9,0.,1.); \n    vec3 col6 = overlay(col4,vec3(mix(mix(1.-col5,0.5,0.8),0.5,map(pos).z)));\n   \n    fragColor = vec4(col6,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 64], [65, 65, 95, 95, 198], [199, 199, 230, 230, 338], [339, 339, 371, 371, 403], [404, 404, 445, 445, 538], [539, 539, 567, 567, 596], [597, 597, 617, 617, 1376], [1377, 1377, 1399, 1399, 1641], [1642, 1642, 1688, 1688, 2033], [2034, 2034, 2074, 2074, 2144], [2145, 2145, 2182, 2182, 2271], [2273, 2273, 2330, 2330, 4023]], "test": "valid"}
{"id": "4scBDf", "name": "fake fresnel'ed blinn-phong blob", "author": "MacSlow", "description": "This is an idea for combining standard Blinn-Phong shading with (fake) fresnel... a poor-man's PBR so to speak :) What do you think? See line 197 for the faked fresnel.", "tags": ["3d", "raymarching", "phong", "metaballs", "shadow", "fog", "blinn", "fresnel"], "likes": 8, "viewed": 668, "published": "Public API", "date": "1526969049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"fake frenel'ed blinn-phong blob\" - poor man's PBR ;) \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .0001;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .7;\n\nmat2 r2d (in float a) {\n    float c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nvec2 opRepeat2 (inout vec2 p, in vec2 size) {\n    vec2 hsize = .5 * size;\n    vec2 cell = floor ((p + hsize) / size);\n    p = mod (p + hsize, size) - hsize;\n    return cell;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat sdHexPrism (in vec3 p, in vec2 h) {\n    vec3 q = abs (p);\n    return max (q.z - h.y, max ((q.x * .866025 + q.y * .5), q.y) - h.x);\n}\n\nfloat scene (in vec3 p) {\n    vec3 pBottom = p;\n    vec3 pTop = p;\n\n    float r1 = .1 + .3 * (.5 + .5 * sin (2. * iTime));\n    float r2 = .1 + .25 * (.5 + .5 * sin (3. * iTime));\n    float r3 = .1 + .3 * (.5 + .5 * sin (4. * iTime));\n    float r4 = .1 + .25 * (.5 + .5 * sin (5. * iTime));\n\n    float t = 2. * iTime;\n    vec3 offset1 = vec3 (-.1*cos(t), .1, -.2*sin(t));\n    vec3 offset2 = vec3 (.2, .2*cos(t), .3*sin(t));\n    vec3 offset3 = vec3 (-.2*cos(t), -.2*sin(t), .3);\n    vec3 offset4 = vec3 (.1, -.4*cos(t), .4*sin(t));\n    vec3 offset5 = vec3 (.4*cos(t), -.2, .3*sin(t));\n    vec3 offset6 = vec3 (-.2*cos(t), -.4, -.4*sin(t));\n    vec3 offset7 = vec3 (.3*sin(t), -.6*cos(t), .6);\n    vec3 offset8 = vec3 (-.3, .5*sin(t), -.4*cos(t));\n\n    float ball1 = sdSphere (p + offset1, r4);\n    float ball2 = sdSphere (p + offset2, r2);\n    float metaBalls = opCombine (ball1, ball2, r1);\n\n    ball1 = sdSphere (p + offset3, r1);\n    ball2 = sdSphere (p + offset4, r3);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);\n\n    ball1 = sdSphere (p + offset5, r3);\n    ball2 = sdSphere (p + offset6, r2);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);\n\n    ball1 = sdSphere (p + offset7, r3);\n    ball2 = sdSphere (p + offset8, r4);\n    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);\n\n    pBottom.yz *= r2d(90.);\n    vec2 cellBottom = opRepeat2 (pBottom.yx, vec2 (.75));\n\n    pTop.yz *= r2d(270.);\n    vec2 cellTop = opRepeat2 (pTop.yx, vec2 (.75));\n\n    float hexBottom = sdHexPrism (pBottom + vec3 (.0, .0, -3.), vec2 (.25, .75 + .2 * sin(cellBottom.y)*cos(cellBottom.x)));\n    float hexTop = sdHexPrism (pTop + vec3 (.0, .0, -3.), vec2 (.25, .75 + .2 * sin(cellTop.y)*cos(cellTop.x)));\n\n    return min (metaBalls, min (hexBottom, hexTop));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        t = scene (ro + d*rd);\n        if (abs (t) < EPSILON * (1. + .125*t)) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n    float d = scene (p);\n    vec3 e = vec3 (epsilon, .0, .0);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 lPos) {\n    float distanceToLight = distance (p, lPos);\n    vec3 n = normal (p, EPSILON);\n    float distanceToObject = raymarch (p + .01*n, normalize (lPos - p));\n    bool isShadowed = distanceToObject < distanceToLight;\n    return isShadowed ? .1 : 1.;\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d) {\n    vec3 p = ro + d*rd;\n    vec3 amb = vec3 (.1);\n    vec3 diffC = vec3 (1., .5, .3);\n    vec3 specC = vec3 (1., .95, .9);\n    vec3 diffC2 = vec3 (.3, .5, 1.);\n    vec3 specC2 = vec3 (.9, .95, 1.);\n\n    vec3 n = normal (p, d*EPSILON);\n    vec3 lPos = ro + vec3 (.5, 1.0, -3.);\n    vec3 lPos2 = ro + vec3 (-1., 1.2, 2.);\n    vec3 lDir = lPos - p;\n    vec3 lDir2 = lPos2 - p;\n    vec3 lnDir = normalize (lDir);\n    vec3 lnDir2 = normalize (lDir2);\n    float sha = shadow (p, lPos);\n    float sha2 = shadow (p, lPos2);\n    float lDist = distance (p, lPos);\n    float lDist2 = distance (p, lPos2);\n    float attenuation = 8. / (lDist*lDist);\n    float attenuation2 = 8. / (lDist2*lDist2);\n\n    float diff = max (dot (n, lnDir), .0);\n    float diff2 = max (dot (n, lnDir2), .0);\n    vec3 h = normalize (lDir - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec = pow (max (dot (h, n), .0), 20.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    vec3 diffTerm = sha * attenuation * diff * diffC;\n    vec3 diffTerm2 = sha2 * attenuation2 * diff2 * diffC2;\n    vec3 specTerm = (sha > .1) ? attenuation * spec * specC : vec3 (.0);\n    vec3 specTerm2 = (sha2 > .1) ? attenuation2 * spec2 * specC2 : vec3 (.0);\n\n    return amb + diffTerm + specTerm + diffTerm2 + specTerm2;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv *2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float angle = radians (300. + 55. * iTime);\n    float dist = 3. + cos (1.5*iTime);\n    vec3 ro = vec3 (dist * cos (angle), .0, dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.05);\n    vec3 p = ro + d * rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (ro, rd, d);\n\n    // the reflection with the faked fresnel\n    vec3 refl = normalize (reflect (rd, n));\n    float refd = raymarch (p + .01*n, refl);\n    vec3 refc = shade (p, refl, refd);\n    float fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.75);\n    col += .35*fakeFresnel*fakeFresnel*refc;\n\n    col *= fog;\n    col = mix (col, vec3 (.95, .85, .7), pow (1. - 1. / d, 17.));\n    col = col / (.75 + col);\n    col = .2 * col + .8 * sqrt (col);\n    col *= .7 + .3 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBDf.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1021, 1044, 1044, 1143], [1145, 1145, 1190, 1190, 1320], [1322, 1322, 1378, 1378, 1482], [1484, 1484, 1524, 1524, 1553], [1555, 1555, 1596, 1596, 1693], [1695, 1695, 1720, 1720, 3507], [3509, 3509, 3550, 3550, 3761], [3763, 3763, 3806, 3806, 4017], [4019, 4019, 4059, 4059, 4307], [4309, 4309, 4358, 4358, 5638], [5640, 5640, 5706, 5706, 6035], [6037, 6037, 6092, 6092, 7187]], "test": "valid"}
{"id": "4scBDX", "name": "switching side", "author": "FabriceNeyret2", "description": "reference: [url]http://www.thisiscolossal.com/wp-content/uploads/2017/08/Switching_Sides.gif[/url]", "tags": ["2d", "short", "reproduction"], "likes": 7, "viewed": 437, "published": "Public API", "date": "1526932776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// blend color * mask ( antialiased ellipse )\n#define B(c,a) o = mix( o, c, smoothstep( 1.5, 0., (length(a)-1.) / fwidth(length(a))))\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, V;\n    U = ( (U+U-R)/R.y + vec2(0,1) ) / vec2(.4,.2);\n    float o = 0., a;\n    \n    for (float y = -18.-fract(iTime); y < 19.; y++)\n        V = U,\n        V.y +=  -.3*( y+19. ),\n        a = y<=-2. ? 0. : y >= 2. ? 3.14 : 3.14*(y+2.)/4., // angle\n        V.x -= .5*cos(a)/.4 , V -= .2*sin(a)/.2, // horizontal rotation\n        B(.4+.4*V.x, V+vec2(0,.27)),             // blend bottom\n        B(.5+.1*V.y, V   ),                      // blend top disk\n        B(0.,        V/.2);                      // blend hole\n\n    O = o* vec4(1,.9,.8,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 173, 173, 746]], "test": "valid"}
{"id": "4scBRf", "name": "Voronoi Scales", "author": "nr4", "description": "Visuals using voronoi distances. The function vor() can compute distance to edges and nearest voronoi control point.\n", "tags": ["raymarching", "voronoi", "sdf"], "likes": 11, "viewed": 247, "published": "Public", "date": "1526222640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Voronoi Scales\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1., 0.);\n\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n\nmat3 rot(vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nfloat norm(vec2 x)\n{\n    return length(x);\n}\n\n/* compute voronoi distance and closest point.\n * x: coordinate\n * return value: vec3(distance, coordinate of control point)\n */\nvec3 vor(vec2 x)\n{\n    vec2 y = floor(x);\n   \tfloat ret = 1.;\n    \n    //find closest control point. (\"In which cell am I?\")\n    vec2 pf=c.yy, p;\n    float df=10., d;\n    \n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            p += rand(p);\n            \n            d = norm(x-p);\n            \n            if(d < df)\n            {\n                df = d;\n                pf = p;\n            }\n        }\n    \n    //compute voronoi distance: minimum distance to any edge\n    for(int i=-1; i<=1; i+=1)\n        for(int j=-1; j<=1; j+=1)\n        {\n            p = y + vec2(float(i), float(j));\n            p += rand(p);\n            \n            vec2 o = p - pf;\n            d = norm(.5*o-dot(x-pf, o)/dot(o,o)*o);\n            ret = min(ret, d);\n        }\n    \n    return vec3(ret, pf);\n}\n\nvec2 scene(vec3 x)\n{\n    x = rot(1.e-1*iTime*c.yyx)*x-c.yxy;\n    \n    vec3 v = vor(6.*x.xy);\n    \n    vec2 sda = vec2(-.05*v.x-.0+abs(x.z), rand(v.yz)),\n        sdb = vec2(abs(.03*v.x-.0+abs(x.z)-.01*sin(2.5*length(x.xy+c.xy)-5.*iTime-pi)), 3.);\n\tvec2 sdf = mix(sda, sdb, step(sdb.x, sda.x));\n    \n    return sdf;\n}\n\nconst float dx = 1.e-5;\nvec3 normal(vec3 x)\n{\n    float s = scene(x).x;\n    return normalize(vec3(\n        scene(x+dx*c.xyy).x-s, \n        scene(x+dx*c.yxy).x-s, \n        scene(x+dx*c.yyx).x-s\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5, s = c.yy;\n    \n    //raymarching\n    vec3 o = 3.*c.yyx, t = 2.*c.yxy, d = normalize(t-o), r = c.xyy, u = cross(d, r), x = c.yyy, \n        ro = o + uv.x * r + uv.y * u;\n    \n    float depth = 0.;\n    \n    for(int i=0; i<100; ++i)\n    {\n        x = ro + depth * d;\n        s = scene(x);\n        if(s.x < 1.e-4) break;\n        if(depth > 1000.) \n        {\n\t\t\tfragColor = c.yyyx;\n            return;\n        }\n        depth += s.x;\n    }\n    \n    //colorize\n    vec3 n = normal(x), l = c.yyx, re = normalize(reflect(-l, n)), v = normalize(x-ro),\n        col;\n    if(s.y == 1.)\n        col = .3*c.xyy+.3*c.xyy*dot(l,n)+.7*c.xxy*pow(abs(dot(re,v)), 4.);\n\telse\n    \tcol = .1*c.yyx+.1*c.yyx*dot(l,n)+c.yxx*pow(abs(dot(re,v)), 4.);\n\n    col = abs(.7*rot(vec3(1.1,1.2,1.3)*iTime+s.y)*col);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBRf.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[0, 868, 886, 886, 1095], [1097, 1097, 1117, 1117, 1141], [1143, 1272, 1290, 1290, 2131], [2133, 2133, 2153, 2153, 2448], [2474, 2474, 2495, 2495, 2652], [2654, 2654, 2711, 2711, 3576]], "test": "error"}
{"id": "4scBRs", "name": "3d Vector Field Ray Test...", "author": "Chris_M_Thomasson", "description": "I want to ray march this 3d volume! Need to get to work! ;^)", "tags": ["fractal", "field", "vector"], "likes": 4, "viewed": 633, "published": "Public API", "date": "1526328327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.7\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n\nCreate an attractor by clicking and dragging it around. \nCopyright (c) 2018\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 10\n#define CT_LINES 32\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec3 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec3 ct_vfield_normal(\n    in vec3 p,\n    float npow\n){\n    vec3 g = vec3(0.0, 0.0, 0.0);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec3 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1] + dif[2] * dif[2];\n        float mass = pow(sum, npow);\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n        g[2] = g[2] + g_vfp[i].m * dif[2] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec3 z,\n    in int n,\n    in float npow\n){\n    vec3 vn = ct_vfield_normal(z, npow);\n    \n    float a = cos(iTime * .25) * 3.14;\n\n    //vec2 rc = vec2(\n    //    vn[0] * cos(a) - vn[1] * sin(a),\n    //    vn[0] * sin(a) + vn[1] * cos(a)\n    //);\n    \n    float color = ct_normal_pi(vn.xy, a) * float(CT_LINES);\n    color = mod(color, 1.0);\n    float color2 = 0.0;\n    if (color < .5)// + abs(cos(iTime * .5)) * .2)\n    {\n        color = 1.0 - color;\n        color2 = mod(vn.z * 3.0, 1.0);\n    }\n    \n    else\n    {\n        color = 0.0;\n        color2 = 0.0;\n    }\n    \n\n    return vec4(\n        color2, //mod(color * 4.0, 1.0), \n        mod(color * 3.0, 1.0), \n        mod(color * 2.0, 1.0),\n        1.0\n    );\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    const int n = CT_N;\n    float scale = 1.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec3(cos(angle), sin(angle), sin(angle * 2.)), \n            1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cm = ct_plane2d_project(plane, vec2(iMouse));\n        g_vfp[n] = ct_vfpoint(\n            vec3(cm, .0), \n            -1.6\n        );\n    }\n    \n    vec3 z = vec3(c, sin(iTime * .5));\n    \n    return ct_vpixel(z, 128, 1.0 + abs(sin(iTime * 3.5)) * 2.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0.0, \n        0.0, \n        2.0\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 480, 532, 532, 692], [695, 799, 851, 851, 1540], [1543, 1543, 1605, 1605, 1713], [1851, 1914, 1969, 1969, 2425], [2428, 2428, 2481, 2481, 2583], [2586, 2612, 2677, 2677, 3346], [3349, 3369, 3424, 3424, 4041], [4044, 4058, 4119, 4119, 4426]], "test": "valid"}
{"id": "4scBW2", "name": "Infinity Matrix Lite", "author": "KilledByAPixel", "description": "I made a version of my pixel fractal code that supports older GLSL versions!\nJust had to get rid of all the arrays, % symbols, and fix up some other stuff.", "tags": ["fractal", "zoom", "pixel", "matrix", "recursion"], "likes": 24, "viewed": 762, "published": "Public API", "date": "1526692719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinity Matrix - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 1.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 2.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 2;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\n\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n    \n    // get if bit is on for this pixel in the glyph\n    // 0x01110, 0x01110, \n\t// 0x11011, 0x11110,\n\t// 0x11011, 0x01110, \n\t// 0x11011, 0x01110,\n\t// 0x01110, 0x11111\n\t//  0        1\n    \n    if (g == 0)\n    {\n     \tif (pos.x > 0 && pos.x < 4 && (pos.y == 0 || pos.y == 4))\n            return 1;\n     \tif (pos.y > 0 && pos.y < 4 && pos.x != 2)\n            return 1;\n  \t    return 0;\n    }\n    else\n    {\n        if (pos.x == 0 && (pos.y == 4 || pos.y == 2 || pos.y == 1))\n            return 0;\n        if (pos.x == 4 && pos.y > 0)\n            return 0;\n        return 1;\n    }\n    \n    return 0;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst float gsfi = 1.0 / glyphSizeF;\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3(1.0);\n        \n    myColor.r *= mix(0.3, 1.0, RandFloat(i + r + 11*glyphPosLast.x + 13*glyphPosLast.y));\n    myColor.b *= mix(0.3, 1.0, RandFloat(i + r + 17*glyphPosLast.x + 19*glyphPosLast.y));\n    myColor *= mix(0.2, 0.7, RandFloat(i + r + 31*glyphPosLast.x + 37*glyphPosLast.y));\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // brighten\n    color += vec3(0.05);\n    \n    // make green\n    color *= vec3(0.7, 1.0, 0.7);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.1*sin(2.0*uv.y + 1.0*iTime);\n\tuv.y += 0.1*sin(2.0*uv.x + 0.8*iTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint imod(int a, int b) { return int(mod(float(a), float(b))); }\nint GetFocusGlyph(int i) { return imod(RandInt(i), glyphCount); }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 18;\t// OPT - 1 and 0 glyps both have 18 pixels\n\n    // find a random valid pixel in glyph\n    c -= imod(RandInt(iterations), c);\n    for (int y = 0; y < glyphSize; ++y)\n    for (int x = 0; x < glyphSize; ++x)\n    {\n            c -= GetGlyphPixel(ivec2(x, y), g);\n            if (c == 0)\n                return ivec2(x, y);\n    }\n    \n    return ivec2(0);\n}\n  \nivec2 GetFocusPos(int i) { return CalculateFocusPos(i); }\n\nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return imod(RandInt(seed), glyphCount); \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(iterations-2);\n\tivec2 glyphPos =     GetFocusPos(iterations-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(iterations+r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n\treturn color;\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += ((vec2(GetFocusPos(iterations+i)) + vec2(glyphMargin)) * gsfi) * pow(gsfi, float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[333, 784, 821, 821, 1482], [1484, 1804, 1828, 1828, 1874], [1875, 1875, 1895, 1895, 1932], [1934, 2050, 2100, 2100, 2344], [2346, 2346, 2369, 2369, 2387], [2388, 2388, 2503, 2503, 2932], [2934, 2934, 2973, 2989, 3091], [3093, 3093, 3115, 3124, 3221], [3224, 3329, 3353, 3353, 3392], [3393, 3393, 3419, 3419, 3458], [3460, 3460, 3501, 3536, 3946], [3950, 3950, 3976, 3976, 4007], [4009, 4009, 4106, 4106, 4379], [4387, 4444, 4511, 4511, 5728], [5731, 5816, 5873, 5901, 6769]], "test": "error"}
{"id": "4scBWN", "name": "Humanoid Silhouettes", "author": "TekF", "description": "Scaramouche, scaramouche, can you do the fandango?", "tags": ["2d", "sdf", "human", "figure", "people"], "likes": 48, "viewed": 1928, "published": "Public API", "date": "1525290947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cheap 2D Humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nfloat RoundMax( float a, float b, float r )\n{\n    a += r; b += r;\n    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);\n    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r )\n{\n    return -RoundMax(-a,-b,r);\n}\n\n// Humanoid, feet placed at <0,0>, with height of ~1.8 units on y\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase*2.)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase*4.)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase*8.)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    //torso += .2*(1.-cos((uv.y-1.)*3.));\n    //torso = RoundMax( torso, abs(uv.y-1.1)-.4, .2*(uv.y-.7)/.8 );\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.2*Rand(2));\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    return max( f, -uv.y );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*vec2(.5,0))/iResolution.y;\n    uv = uv*2.-vec2(0,0);\n//    float phase = floor(iTime*3.)*2.; // randomise\n    uv.x += iTime;\n    float w = .7;\n    float sss = floor(uv.x/w);\n    uv.x = uv.x - (sss + .5)*w;\n    float phase = 2.*sss;\n    float sdf = Humanoid( uv, phase );\n    \n    fragColour = vec4(.5+.5*sdf/(abs(sdf)+.002)); // map SDF to slightly soft black & white image\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBWN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[0, 263, 308, 308, 421], [423, 423, 468, 468, 501], [503, 569, 615, 615, 1715], [1718, 1718, 1776, 1776, 2192]], "test": "valid"}
{"id": "4scBWS", "name": "fnorf23", "author": "dls", "description": "procrastination", "tags": ["foobar"], "likes": 1, "viewed": 74, "published": "Public", "date": "1526462174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.1415\n\nvec3 colorize(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    vec3 col = 2.5 * a * b * (cos(2.0*M_PI*(c*t+d))); \n   \treturn col;\n}\n\n\nvec3 pal01(float t) {\n\tvec3 col = colorize(t,\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(1.0, 1.0, 0.5),\n                        vec3(0.80, 0.90, 0.30));   \n    return col;\n}\n\nvec3 pal02(float t) {\n \tvec3 col = colorize(t,\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(1.0, 1.0, 1.0),\n                        vec3(0.30, 0.20, 0.20));\n    return col;\n}\n\nvec3 pal03(float t) {\n    vec3 col = colorize(t,\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(2.0, 1.0, 0.0),\n                        vec3(0.50, 0.20, 0.25));\n    return col;\n}\n\nvec3 pal04(float t) {\n \tvec3 col = colorize(t, \n                        vec3(0.5, 0.5, 0.5),\n                        vec3(0.5, 0.5, 0.5),\n                        vec3(1.0, 1.0, 1.0),\n                        vec3(0.30, 0.20, 0.20));\n    return col;\n        \n}\n\n\nvec2 rot(vec2 p, float a) {\n    return vec2(p.x * cos(a) - p.y * sin(a),\n                p.x * sin(a) + p.y * cos(a));\n    \n}\n\nvec2 scale(vec2 p, float v) {\n \treturn p;   \n}\n\n\nfloat p01(vec2 xy, float t) {\n    float f = 23.0;\n    return  1.0 * sin(xy.x*f) - 1.0 * cos(xy.y*f);\n}\n\nfloat p02(vec2 xy, float t) {\n   t = 2.5 + 2.0 * (0.5 + 0.5 * sin(t));\n   return p01(rot(xy, t*0.1), t) - p01(rot(xy, -t*0.1), t);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n   \t// Center\n    uv.x -= 0.5; uv.y -= 0.5;\n\n    // Aspect\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.xy *= 1.25;\n    \n    vec3 col = pal04(p02(scale(rot(uv.xy, iTime*0.5), 1.5 + 0.2*sin(iTime)), iTime));\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 78, 78, 151], [154, 154, 175, 175, 404], [406, 406, 427, 427, 654], [656, 656, 677, 677, 906], [908, 908, 929, 929, 1166], [1169, 1169, 1196, 1196, 1294], [1296, 1296, 1325, 1325, 1342], [1345, 1345, 1374, 1374, 1447], [1449, 1449, 1478, 1478, 1581], [1586, 1586, 1643, 1693, 2018]], "test": "valid"}
{"id": "4scBz2", "name": "RotatingShine", "author": "OursBleu", "description": "Animated shine.", "tags": ["shine"], "likes": 0, "viewed": 86, "published": "Public", "date": "1525870628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = .1;\n    float rayCount = 10.;\n    float gradientLenght = 2.;\n    vec3 color = vec3(1.0,1.0,0.);\n    \n    vec2 uv = fragCoord/iResolution.y;\n    \n    // center uv\n    uv.x -= .5 * (iResolution.x/iResolution.y);\n\tuv.y -= .5;\n    \n    // convert cartesian to polar\n\tfloat angle = atan(uv.y, uv.x);\n    \n    // normalize angle\n    angle += PI;\n    angle /= (2.*PI);\n    \n    // animate angle\n    angle += iTime * speed;\n    \n    // fraction angle\n    float mask = fract(angle * rayCount);\n    \n    // smooth fract output\n    mask = min(1. - mask, mask) * 2.;\n    mask = smoothstep(.4, .6, mask);\n    \n    // substract gradient\n    float grad = distance(vec2(0.), uv);\n    \n    //animate gradient\n    grad *= gradientLenght * (2. - ((sin(iTime * 2.) + 1.0) * .5));\n    \n    mask -= grad;\n    \n    // Output to screen\n    fragColor = vec4(vec3(color * mask),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4scBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 981]], "test": "valid"}
{"id": "4sdfW4", "name": "number (or anything) printer", "author": "akhgary", "description": "a simple digit printer using table of tables. each row in this table is itself a table.\nfor example row 5 contains a table for digit 5, and row 11 contains a table for negative sign.", "tags": ["text", "number", "numbers", "map", "string", "digit", "table", "digits", "show", "print"], "likes": 2, "viewed": 128, "published": "Public", "date": "1525172558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ==========================================\n// Digit printer\n//\n// the table contains twoelve 5x6 tables.\n// a 5x6 grid contains fair amount of detail \n// for mapping letters and more symbols as well.\n//\n// the grid size and patterns was taken from a calculator :P\n//\n// ==========================================\n//\n// if you want to add more characters, for example \"A\"\n//\n// 0###0\n// #000#\n// #000#\n// #####\n// #000#\n// #000#\n//\n// write the bitmask for it and convert them to base 10.\n//\n// 01110 = 14\n// 10001 = 17\n// 10001 = 17\n// 11111 = 31\n// 10001 = 17\n// 10001 = 17\n//\n// then put them in the table from bottom to top.\n//\n// 17, 17, 31, 17, 17, 14\n//\n// number of row in the table indicates the index of this character.\n//\n// ==========================================\n// rectangle drawing:\n// https://thebookofshaders.com/07/\n// ==========================================\n\n// display properties\nconst float scale = 1.;\nconst bool separator = false;\n\n// number properties\nconst float width = 0.5;\nconst float height = 0.5;\nconst float spacing = 0.1;\nconst int decimals = 2;\nconst vec2 position = vec2(0);\nconst bool putCenter = true;\n\n// table properties\nconst int columns = 5;\nconst int rows = 6;\nconst int tableCol = 6;\nint[] table = int[](\n14, 17, 25, 21, 19, 14, // 0\n14,  4,  4,  4, 12,  4, // 1\n31,  8,  4,  2, 17, 14, // 2\n14, 17,  1,  6,  1, 31, // 3\n 2, 31, 18, 10,  6,  2, // 4\n14, 17,  1, 30, 16, 31, // 5\n14, 17, 17, 30, 16, 14, // 6\n 4,  4,  4,  2,  1, 31, // 7\n14, 17, 17, 14, 17, 14, // 8\n14,  1, 15, 17, 17, 14, // 9\n12, 12,  0,  0,  0,  0, // .\n 0,  0, 31,  0,  0,  0, // -\n 4,  4, 31,  4,  4,  0);// +\n\nvec2 uvmap(vec2 uv){\n    return (2.*uv-iResolution.xy)/iResolution.y;\n}\n\n//    print(uv, center, width, height, index)\nfloat print(vec2 uv, vec2 c, float w, float h, int ind)\n{\n    float r = 0.;\n    vec2 wh = vec2(w/float(columns),h/float(rows));\n    vec2 o =  vec2(w,h)/2.; // origin\n    vec2 bmin=c-o, bmax=c+o; // min and max boundaries\n    \n    // no need to render ouside boundaries.\n    if(uv.x<bmin.x||uv.y<bmin.y|| \n       uv.x>bmax.x||uv.y>bmax.y) return 0.;\n    \n    c = bmin; // move center to the origin\n    for(int row=0;row<rows;row++){\n        int map = table[ind*tableCol+row];\n        for(int col=0;col<columns;col++){\n            vec2 p0 = c+wh*vec2(col,row), p1 = p0+wh;\n            vec2 lb = step(p0,uv);\n            vec2 ub = 1.-step(p1,uv);\n            \n            int shift = columns-col-1;\n            if(((map&(1<<shift))>>shift)==1) \n                r += lb.x*lb.y*ub.x*ub.y;\n        }\n    }\n    return r;\n}\n\nfloat printNumber(vec2 uv, vec2 c, float w, float h, float num, int decN, float spacing, bool center)\n{\n    w*=iResolution.y/iResolution.x; // keep aspect ratio\n    spacing*=iResolution.y/iResolution.x;\n    \n    float r = 0.;\n    bool neg = num<0.; num=abs(num);\n    float cd = float(decN);\n    float cn = max(ceil(log(num)/log(10.)),1.);\n    float dec = fract(num)*pow(10.,float(decimals));\n    \n    if(center) // move to origin\n    {\n        c.x += (cn+cd-1.)*(w+spacing)/2.;\n        if(decN>0) c.x+=spacing;\n        if(neg)c.x+=(w+spacing)/2.;\n    }\n    else\n    {\n        c.x += (cn+cd-1.)*(w+spacing)+w;        \n        if(decN>0) c.x+=spacing*2.;\n        if(neg)c.x+=w+spacing;\n    }\n        \n    // print fractions\n    for(int i=0;i<decN;i++,dec/=10.){\n        int val = int(mod(dec,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(decN>0) // print dot separator\n    {\n        c.x+=spacing;\n        r += print(uv, c, w, h, 10);\n        c.x-=w;\n    }\n    // print whole part\n    for(int i=0;i<int(cn);i++,num/=10.){\n        int val = int(mod(num,10.));\n        r += print(uv, c, w, h, val);\n        c.x-=w+spacing; // move left\n    }\n    if(neg) r+=print(uv, c, w, h, 11); // print sign\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = uvmap(fragCoord.xy)*scale;\n    vec3 col = vec3(0);\n    \n    col += printNumber(uv,position,width,height,iTime,decimals,spacing,putCenter);\n    \n    if(separator)\n        if(uv.x<0.02&&uv.x>-0.02) \n            col = vec3(0.5,0,0);\n    \n    fragColor = vec4(col*(.5+.5*cos(iTime+uv.xyx+vec3(0,2,4))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1627, 1633, 1653, 1653, 1704], [1706, 1752, 1809, 1809, 2567], [2569, 2569, 2672, 2672, 3823], [3825, 3825, 3882, 3882, 4202]], "test": "error"}
{"id": "4sdfzS", "name": "Cannon-Thurston on Poincare ball", "author": "DaveBachman", "description": "Joint work with Henry Segerman. An approximation to the Cannon-Thurston map from the boundary circle of the universal cover of the fiber of the figure eight knot complement to the boundary of 3D hyperbolic space, modeled on the Poincare ball.\n", "tags": ["fractal", "hyperbolic"], "likes": 16, "viewed": 367, "published": "Public", "date": "1525743495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Joint work with Dave Bachman. \n// An approximation to the Cannon-Thurston map from the boundary circle of the \n// universal cover of the fiber of the figure eight knot complement to the \n// boundary of 3D hyperbolic space.\n\n// This is a view of a horizontal slice through the upper half space model \n// of three-dimensional hyperbolic space. The height varies with time from \n// 0.001 to 0.201. The pattern is made as follows: Each pixel is inside of \n// a tetrahedron of the lift of the triangulation of the figure eight knot\n// complement to H^3. We move it by elements of the fundamental group until\n// it is inside of the fundamental domain, which consists of two tetrahedra\n// with vertices (infinity, 0, 1, e^(i pi/6)), and (infinity, 0, 1, e^(-i pi/6)).\n// As we go, we track how many times we cross through the fiber. If the answer is\n// zero we colour the pixel grey (0.5,0.5,0.5). If the number of times we\n// cross through is positive then the pixel gets more white, and if it\n// is negative then the pixel gets more black. \n\n// The result is that as we decrease the height of the horizontal slice down\n// towards zero, the points coloured (0.5,0.5,0.5) form a better and better\n// approximation to the image of the Cannon-Thurston map, a sphere-filling curve.\n\nvec4 c2q(in vec2 a){\n    return vec4(a.x, a.y, 0.0, 0.0);\n}\n\nvec4 qonj(in vec4 q){\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 qinv(in vec4 q){\n \treturn qonj(q) / (q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);\n}\n\nvec4 qmul(in vec4 p, in vec4 q){\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\n\nvec4 qdiv(in vec4 p, in vec4 q){\n    return qmul(p, qinv(q));\n}\n\nvec4 qmob(in vec2[4] M, in vec4 z){ // see Ahlfors 1981 Mob tsfms p14\n    vec4 a = c2q(M[0]);\n    vec4 b = c2q(M[1]);\n    vec4 c = c2q(M[2]);\n    vec4 d = c2q(M[3]);\n    return qdiv( qmul(a,z)+b, qmul(c,z)+d ); // if z.w = 0 then result.w = 0\n}\n\nconst float sqrt3 = sqrt(3.0);\nconst vec2 w = vec2(0.5, 0.5*sqrt3);\nconst vec2 winv = vec2(0.5, -0.5*sqrt3);\nconst vec2 c0 = vec2(0.0,0.0);\nconst vec2 c1 = vec2(1.0,0.0);\nconst vec2 ci = vec2(0.0,1.0);\nconst vec4 qj = vec4(0.0,0.0,1.0,0.0);\n\nbool needt1(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 1\n\treturn q.x*(-0.5*sqrt3) + q.y*0.5 > 0.0;\n}\nbool needt1inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 1\n    vec4 center = c2q((c1 + winv)/3.0);\n    vec4 qmc = q - center;\n    return qmc.x*qmc.x + qmc.y*qmc.y + qmc.z*qmc.z < 1.0/3.0;\n}\nbool needt2(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 2\n\treturn q.x*(-0.5*sqrt3) + q.y*(-0.5) > 0.0;\n}\nbool needt2inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 2\n\treturn (q.x-1.0)*(0.5*sqrt3) + q.y*(0.5) > 0.0;\n}\nbool needt3(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 3\n\treturn (q.x-1.0)*(0.5*sqrt3) + q.y*(-0.5) > 0.0;\n}\nbool needt3inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 3\n    vec4 center = c2q((c1 + w)/3.0);\n\tvec4 qmc = q - center;\n    return qmc.x*qmc.x + qmc.y*qmc.y + qmc.z*qmc.z < 1.0/3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t1[4];\n\tt1[0] = c1;\n\tt1[1] = -w;\n\tt1[2] = c1;\n\tt1[3] = winv;  // is this really the only way to assign values to the array??\n    vec2 t1inv[4];\n    t1inv[0] = winv;\n    t1inv[1] = w;\n    t1inv[2] = -c1;\n    t1inv[3] = c1;\n    vec2 t2[4];\n    t2[0] = c1;\n    t2[1] = w;\n    t2[2] = c0;\n    t2[3] = c1;\n    vec2 t2inv[4];\n    t2inv[0] = c1;\n    t2inv[1] = -w;\n    t2inv[2] = -c0;\n    t2inv[3] = c1;\n    vec2 t3[4];\n    t3[0] = -winv;\n    t3[1] = -w;\n    t3[2] = w;\n    t3[3] = -w - c1;\n    vec2 t3inv[4];\n    t3inv[0] = -w - c1;\n    t3inv[1] = w;\n    t3inv[2] = -w;\n    t3inv[3] = -winv; //all these should have det 1 now\n    \n    vec2 p = vec2(0.1,0.001) + (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    //vec4 q = vec4(p, 0.001+0.1*(0.75 + cos(iTime) + 0.25*cos(2.0*iTime)), 0.0);\n\t//vec4 q = vec4(0.0,1.0, 0.0001, 0.0);\n    \n    float ball_radius = 0.9999;\n    bool inside_ball = false;\n    \n    vec4 q;\n    \n    if(length(p)<1.0){\n\t\tvec4 ball_pt = vec4(sqrt(1.0-length(p)*length(p)),p,0.0);\n        ball_pt = vec4(ball_pt.x * cos(iTime) + ball_pt.y * sin(iTime), -ball_pt.x * sin(iTime) + ball_pt.y * cos(iTime), ball_pt.z, ball_pt.w);\n        ball_pt = vec4(ball_pt.x, ball_pt.y * cos(0.5*iTime) + ball_pt.z * sin(0.5*iTime), -ball_pt.y * sin(0.5*iTime) + ball_pt.z * cos(0.5*iTime), ball_pt.w);\n        //ball_pt = (0.999-0.15*cos(iTime))*ball_pt;\n        ball_pt = 0.999*ball_pt;\n      \tq = qdiv(ball_pt + qj,qmul(qj,ball_pt)+c2q(c1));\n        inside_ball = true;\n    }\n    else{\n        vec4 q = vec4(0.0,0.0,0.01,0.0);\n    }\n            \n    int crossing_count = 0;\n    bool inside_fund_dom = false;\n    for(int i=0;i<512;i++){\n        if (needt1(q)){\n            q = qmob(t1, q);\n        }\n        else if (needt1inv(q)){\n            q = qmob(t1inv, q);\n        }\n        else if (needt2(q)){\n            q = qmob(t2, q);\n            crossing_count -= 1;\n        }\n        else if (needt2inv(q)){\n            q = qmob(t2inv, q);\n            crossing_count += 1;\n        }\n        else if (needt3(q)){\n            q = qmob(t3, q);\n            crossing_count -= 1;\n        }\n        else if (needt3inv(q)){\n            q = qmob(t3inv, q);\n            crossing_count += 1;\n        }\n        else{\n            inside_fund_dom = true;\n            break;\n        }\n    }\n    vec3 col;\n    if (inside_ball){\n\t    if (inside_fund_dom){\n    \t    float c = 0.5 + float(crossing_count)/10.0;\n    \t    col = vec3(c,c,c);\n   \t\t}\n    \telse{\n        \tcol = vec3(0.0,1.0,0.0);\n    \t}\n    }\n    else{\n        col = vec3(0.0,0.0,0.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sdfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1040, 1276, 1296, 1296, 1335], [1337, 1337, 1358, 1358, 1400], [1402, 1402, 1423, 1423, 1485], [1487, 1487, 1519, 1519, 1742], [1744, 1744, 1776, 1776, 1807], [1809, 1809, 1844, 1878, 2053], [2297, 2297, 2320, 2397, 2441], [2442, 2442, 2468, 2549, 2680], [2681, 2681, 2704, 2781, 2828], [2829, 2829, 2855, 2936, 2987], [2988, 2988, 3011, 3088, 3140], [3141, 3141, 3167, 3248, 3373], [3375, 3375, 3432, 3432, 6017]], "test": "error"}
{"id": "4sGcWy", "name": "Tunnel_0", "author": "balkhan", "description": " ", "tags": ["raymarching", "tunnel"], "likes": 18, "viewed": 794, "published": "Public API", "date": "1526139826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n#define I_MAX\t150\n#define E\t\t0.00001\n\nfloat\tsdTorus( vec3 p, vec2 t );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec2\trot(vec2 p, vec2 ang);\nfloat\tmylength(vec3 p);\nfloat\tmylength(vec2 p);\nvoid\trotate(inout vec2 v, float angle);\n\nfloat\tt;\nvec3\th;\nfloat\tmind;\nfloat\tlit;\nfloat\ttest;\nvec3\t_color_one, _color_two;\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    h = vec3(0.);\n    t = iTime;\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    \n    _color_two = vec3(\n\t\tsin(.25*iTime*.25+2.08)\n        ,\n        sin(.25*iTime*.5+2.57)\n        ,\n        sin(.25*iTime*.75+3.00)\n    );\n    \n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3 pos = vec3(.01, .01, 5.0);\n\n    vec2\tinter = (march(pos, dir));\n    col.xyz = 1.*blackbody((inter.y*.06125)*100.);\n   \tcol.xyz += h;\n    col.xyz += vec3(.2, .2, .2) * inter.x * .0125 * max(.01, 70./max(inter.y, .001) );\n    col.xyz += (1.-_color_one) * min(inter.y, 70.) * .003;\n    o.xyz = col.xyz;\n}\n\nfloat\tscene(vec3 p)\n{\n    mind = 1e5;\n    lit  = 1e5;\n    p.z-= -30.;\n    p.z -= iTime*5.;\n\tvec3\tap = p;\n    \n    \n    p.xy += vec2(cos(p.z*.25), sin(p.z*.25 ) );\n    p.xy += vec2(cos(-p.z*.125), sin(-p.z*.125 ) );\n    p.xy += vec2(cos(p.z*.0625), sin(p.z*.0625 ) );\n    p.xy += vec2(cos(-p.z*.03), sin(-p.z*.03 ) );\n    \n    p.xy += \n        .175\n        *\n        vec2(\n            cos(iTime*5.+50.*(atan(ap.x, ap.y)*1.-iTime*-.05+p.z*.0251*1.0) )\n            ,\n            sin(iTime*5.+50.*(atan(ap.x, ap.y)*1.+iTime*-.05+p.z*.0251*1.0) )\n        );\n    \n    float ata = atan(p.x,p.y);\n    _color_one = vec3(\n    \tsin(cos(3.*ata+(p.z*2.)/4.)+7.7+0.00)\n        ,\n        sin(cos(3.*ata+(p.z*2.)/8.)+7.7-.57)\n        ,\n        sin(cos(3.*ata+(p.z*2.)/16.)+7.7-1.04)\n    );\n    \n    mind = min(mind\n               ,\n               max( (length(p.xy)-10.), -(length(p.xy)-9.) )\n               );\n    \n    lit = min(lit, length( (p.xy))-10.);\n    lit = max(lit, -(length(p.xy)-9.125) );\n    \n    lit = max(lit, (length(-1.+1.*cos(p.zz*5.+iTime*.5) )-.2) );\n    h += 1.*_color_two*1./max(lit*lit*10000.1+.0+test*.1251, .1);\n\n    mind = max(mind, -(length(-1.+1.*cos(p.zz*5.+iTime*.5) )-.2) );\n\tfloat tmp = mind;\n    \n    mind = min(mind, lit);\n    \n    h += _color_one * 1./max(tmp*tmp*100. + 50. + test, .01);\n\n    return(mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\tvec3\tdirr;\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n        dirr = dir;\n        rotate(dirr.xz, +dist.y*.000+.25*sin(t*.25+dist.y*.005) );\n    \tp = pos + dirr * dist.y;\n        test = dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E)\n        {\n           break;\n\t    }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat\tmylength(vec2 p)\n{\n\treturn max(abs(p.x), abs(p.y));\n}\n\nfloat\tmylength(vec3 p)\n{\n\treturn max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGcWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[227, 449, 477, 477, 802], [804, 1175, 1215, 1215, 1823], [1825, 1825, 1846, 1846, 3153], [3155, 3155, 3187, 3187, 3627], [3629, 3629, 3669, 3669, 3744], [3746, 3746, 3770, 3770, 3805], [3807, 3807, 3831, 3831, 3881], [3883, 3883, 3916, 3916, 3983], [3985, 3985, 4007, 4007, 4214]], "test": "error"}
{"id": "4sGfRD", "name": "Simple 3D spheres", "author": "artyomabramov", "description": "Simple 3D spheres", "tags": ["3d", "sphere"], "likes": 9, "viewed": 221, "published": "Public", "date": "1527712531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float radius = 0.1;\n\nfloat remap(float a, float b, float t) {\n    return (t - a) / (b - a);\n}\n\nvec4 drawSphere(vec3 ro, vec3 rd, vec3 s) {\n    float t = dot(s - ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float y = length(p - s);\n    float d = -1.0;\n    \n    float col = 0.0;\n    \n    if (y < radius) {\n        float x = sqrt(radius * radius - y * y);\n        float t1 = t - x;\n        \n\t\td = 1.0 - t1 / 5.0;\n        \n        float dist = length(s - ro);\n        t1 = remap(dist, dist - radius, t1);\n        t1 = t1 / 2.0 + 0.5;\n        \n        col = t1;\n    }\n    \n    return vec4(p * col, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float speed = 1.0;\n    \n    vec3 ro = vec3(0.5 + 3.0 * sin(iTime * speed), 1.5, 0.5 + 3.0 * cos(iTime * speed));\n    \n    vec3 lookat = vec3(0.5, 0.5, 0.5);\n     \n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = cross(f, r);\n    \n    float zoom = 1.0;\n    \n    vec3 c = ro + f * zoom;\n    \n    vec3 i = c + uv.x * r + uv.y * u;\n    \n    vec3 rd = normalize(i - ro);\n    \n\tvec4 res = vec4(0.95);\n    res.a = 0.0;    \n    \n    const int n = 5;\n    \n    for (int x = 0; x < n; x++) {\n        for (int y = 0; y < n; y++) {\n            for (int z = 0; z < n; z++) {\n                vec3 coord = vec3(float(x) / float(n - 1), \n                                  float(y) / float(n - 1),\n                                  float(z) / float(n - 1));\n                vec4 point = drawSphere(ro, rd, coord);\n                \n                if (point.a > res.a) {\n                    res = point;\n                }\n            }\n        }\n    }\n    \n    float m = 1.0 - iMouse.x / iResolution.y - 0.1;\n    \n    fragColor = vec4(mix(vec3(res.a) * 1.5, res.rgb, smoothstep(0.4, 0.6, uv.x + 0.5 + m)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGfRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 61, 61, 93], [95, 95, 138, 138, 597], [599, 599, 656, 656, 1915]], "test": "valid"}
{"id": "4stBWj", "name": "Dellen Tartan", "author": "xinux", "description": "https://www.tartanregister.gov.uk/tartanDetails?ref=11271", "tags": ["tartan", "kilt"], "likes": 4, "viewed": 158, "published": "Public", "date": "1526761771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// thanks to mercury (hg_sdf)\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 repeat(inout vec2 uv, float times)\n{\n    uv *= times;\n    vec2 cell = floor(uv);\n    uv = fract(uv);\n    return cell;\n}\n\nfloat hline(vec2 uv, float startY, float endY)\n{\n    float line = step(uv.y, startY) * step(-uv.y, -endY);\n    line *= smoothstep(0.43, 0.5, fract((uv.x + uv.y) * 100.)); // diagonal line skip\n    line *= smoothstep(0.45, 0.55, fract(uv.y * 540.)); // horizontal line skip\n    return line;\n}\n\nvec3 dellenline(vec2 uv)\n{\n    uv *= 0.7;\n    vec3 red = vec3(0.680,0.129,0.123);\n    vec3 green = vec3(0.000,0.170,0.000);\n    vec3 white = vec3(0.910,0.910,0.910);\n    \n    vec3 c = vec3(0.);\n    c += hline(uv, 0.573, 0.542) * red;\n    c += hline(uv, 0.542, 0.527) * green;\n    c += hline(uv, 0.527, 0.46) * red;\n    c += hline(uv, 0.45, 0.44) * white;\n    c += hline(uv, 0.43, 0.366) * red;\n    c += hline(uv, 0.366, 0.352) * green;\n    c += hline(uv, 0.352, 0.32) * red;\n    \n    return c;\n}\n\nfloat rand1d(float n)\n{\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float intensity)\n{\n    return min(1., (1. / (rand1d(uv.x * 20. + 1.) + rand1d(uv.y * 40.))) * intensity);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - (iResolution.xy * 0.5)) / iResolution.yy;\n    float ltrbox = step(0.35, abs(uv.y));\n    float vignette = \n        smoothstep(0.5, 1.2, abs(uv.x)) + \n        smoothstep(0.2, 0.6, abs(uv.y)) * 1.;\n    float ambient = sin(iTime * 0.5) * 0.013;\n    \n    pR(uv.xy, 0.2 + iTime * 0.02);\n\n    uv *= sin(iTime * 0.3 + 1.) * 0.5 + 1.4;\n    float ray = 1. - smoothstep(0., 0.9, abs(uv.x - uv.y * 0.5 + tan(iTime * 0.1)));\n    uv.x += iTime * 0.05;\n    uv.y -= iTime * 0.02;\n    \n    uv.y += sin(iTime * 0.4 + uv.x * 1.) * 0.07;\n    uv.x += sin(iTime * 0.3 + uv.x + uv.y) * 0.02;\n    \n    repeat(uv, 1.);\n    \n    vec3 black = vec3(0.025, 0.005, 0.);    \n    vec3 c = black;\n    \n    c += dellenline(uv);\n    uv = vec2(-uv.y, 1. -uv.x); // flip\n    c += dellenline(uv);\n\t\n    float pattern = 0.;\n    pattern += fract((uv.x + uv.y) * 150.) * 0.17;\n    pattern += fract((uv.x) * 120.) * 0.12;\n    \n    c += noise(uv, 0.5) * 0.02;\n    c = mix(c, black, 0.15);\n    c = mix(c, vec3(0.5), pattern - 0.1);\n    \n    c += ambient;\n    c += ray * 0.03;\n    c *= 1. - ltrbox;\n    c *= 1. - vignette;\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stBWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 62, 62, 104], [106, 106, 147, 147, 230], [232, 232, 280, 280, 523], [525, 525, 551, 551, 1020], [1022, 1022, 1045, 1045, 1083], [1085, 1085, 1124, 1124, 1213], [1215, 1215, 1270, 1270, 2415]], "test": "valid"}
{"id": "4stBzl", "name": "Birthday Elle", "author": "pudding", "description": "I made her a valentine's day shader but I cheated and used a few textures. This one is all procedural - as you can tell by the GPU fans - and I had to disable reflections to keep it at 60FPS full-screen. On the plus side, I have optimisation targets :)", "tags": ["raymarch", "birthday", "elle"], "likes": 0, "viewed": 427, "published": "Public API", "date": "1526556748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int STEPS = 90;\nconst float MIN_D = 0.001;\nconst float MAX_D = 40.0;\nconst float MAX_D_REFL = 25.0;\nconst float EPS = 0.001;\n\n/*\nI have a bajillion people to thank for either teaching me tricks from reading their code or in some cases reusing bits\n\nHopefully I'm not missing anyone out - iq, Shane, Dave_Hoskins, BigWIngs, Jamie Wong, and everyone who has \n\tposted code here - it's been extremely informative (as well as challenging!)\n\nps I know I'm doing the uv normalisation the naive way Fabrice but I'm not sure I understand the method you suggest :(\n*/\n\n\nfloat hash21(in vec2 p) {\n\treturn fract(sin(p.x * 172. + p.y * 153.5) * 1234.563);   \n}\n\nfloat noise11(in float x) {\n\treturn fract(sin(x)*5346.1764); \n}\n    \n\nfloat snoise(in vec2 p) {\n    \n    vec2 luv = fract(p);\n    vec2 id = floor(p);\n\n    luv = luv * luv * (3. - 2. * luv);\n    \n    float bl = hash21(id);\n    float br = hash21(id + vec2(1, 0));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = hash21(id + vec2(0, 1));\n    float tr = hash21(id + vec2(1, 1));\n    float t = mix(tl, tr, luv.x);\n    \n    return mix(b, t, luv.y);\n}\n\nvec3 rgb(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\n\nmat3 RotateY(in float theta){\n \n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c,\t\t\t0.0,\ts,\n        0.0,\t\t1.0,\t0.0,\n        -s,\t\t\t0.0,\tc);\n}\n\nfloat SinPlasma(in vec3 p){\n    return sin(p.x+iTime*2.)*cos(p.y+iTime*3.1)*sin(p.z+iTime*4.3) + 0.25*sin(p.x*2.)*cos(p.y*2.)*sin(p.z*2.);\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) {\n \treturn d1.x < d2.x ? d1 : d2;\n}\n\nfloat Cylinder(in vec3 p, in vec2 h) {\n \tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat NoiseCylinder(in vec3 p, in vec2 h) {\n \tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + snoise(p.xz * 5.) * 0.1 * min(1., (iTime / 10.));\n}\n\nfloat Candle(in vec3 p) {\n return Cylinder(p, vec2(.1, 0.75));   \n}\n\nfloat Box(in vec3 p, in vec3 b, in float r){\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nconst float CH = -1.1; // candle height\n\nvec2 Map(in vec3 p) {\n    \n    vec2 result = opU(vec2(NoiseCylinder(p + vec3(0, 0.1, 0), vec2(3., 1.)), 1.0), vec2(Box(p + vec3(0, 1, 0), vec3(4.0, 0.1, 4.), 0.05), 3.));\n    for (float i = 1.; i < 31.; i+= 1.) {\n        vec2 offset = vec2(i, i) * 0.09;\n        result = opU(result, vec2(Candle(p + vec3(sin(i) * offset.x, CH, cos(i) * offset.y)), 2.)); \n        result = opU(result, vec2(Cylinder(p + vec3(sin(i) * offset.x, -2., cos(i) * offset.y), vec2(0.05)), 4. + i)); // we use the differing .y values to randomly flicker candles\n    }   \n    return result;\n}\n\nvec2 DistanceToSurface(in vec3 ro, in vec3 rd, in float start, in float end) {\n \n    float depth = start;\n    for (int i = 0; i < STEPS; i++) {\n     \tvec2 dist = Map(ro + rd * depth);\n        \n        if (dist.x < EPS) {\n            return vec2(depth, dist.y);\n        }\n        \n        depth += dist.x;\n        if (depth >= end) {\n            return vec2(end, 1e3);\n        }\n    }\n    return vec2(end, 1e3);\n}\n\nvec3 RayDirection(in float fov, in vec2 size, in vec2 fragCoord) {\n \tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 ViewMatrix(in vec3 eye, in vec3 center, in vec3 up) {\n \tvec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 CalculateNormal(in vec3 p) {\n \tvec2 tmp = vec2(EPS, 0.0);\n    return normalize(\n        vec3(\n        \tMap(p + tmp.xyy).x - Map(p - tmp.xyy).x,\n        \tMap(p + tmp.yxy).x - Map(p - tmp.yxy).x,\n        \tMap(p + tmp.yyx).x - Map(p - tmp.yyx).x\n       \t)\n    );\n}\n\nvec3 PhongContribForLight(in vec3 k_d, in vec3 k_s, in float shininess, in vec3 p, in vec3 eye, in vec3 lightPos, in vec3 lightIntensity, bool doShadow) {\n \t\n    vec3 N = CalculateNormal(p);\t\t\t// surf norm\n    vec3 L = normalize(lightPos - p);\t\t// light\n    vec3 V = normalize(eye - p);\t\t\t// view\n    vec3 R = normalize(reflect(-L, N));\t\t// reflection\n    \n    float NdotL = dot(N, L);\n    float VdotR = dot(R, V);\n    \n    if (NdotL < 0.0) {\t// not visible\n        return vec3(0.);\n    }\n    \n    vec3 nLightPos = normalize(lightPos);\n    float shadow;\n    \n    shadow = doShadow ? DistanceToSurface(p + nLightPos , -nLightPos, MIN_D, MAX_D).x : 1.;\n    \n    if (VdotR < 0.0) { // refl is opposite direction to view\n        return lightIntensity * (k_d * shadow * NdotL);\n    }\n   \n    return lightIntensity * (k_d * shadow * NdotL + k_s * pow(VdotR, shininess));   \n}\n\nvec3 PhongLight(vec3 k_a, vec3 k_d, vec3 k_s, float shininess, vec3 p, vec3 eye, bool doShadow) {\n \t\n    const vec3 ambientLight = 0.5 * vec3(0.3, 0.3, 0.35);\n    vec3 color = ambientLight * k_a;\n    vec3 lightPos = vec3(6. * sin(iTime), 5.0, 2.);\n    vec3 lightIntensity = vec3(0.94);\n    \n    // hack: flame has shininess 0 to shortcut lighting\n    color += (shininess == 0.) ? k_a : PhongContribForLight(k_d, k_s, shininess, p, eye, lightPos, lightIntensity, doShadow);\n    return color;  \n}\n\nfloat Heart(in vec2 st){\n    st.y /= 0.5;\n    st.y -= sqrt(abs(st.x)) * 0.25;\n    return length(st) / 4.5;\n}\n\nvec3 Confetti(in vec2 uv, float t) {\n    t /= 2.;\n    uv *= 3.;\n    vec2 aspect = vec2(3., 1.);\n    vec2 st = uv * aspect;\n    float id = floor(st.x);\n    \n    st.y -= t * (noise11(floor(id)) + 1.);\n    st = fract(st) - 0.5; \n    float mask = smoothstep(0.11, 0.1, Heart(st));\n \treturn mask * rgb(abs(sin(id)));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n   \tvec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 color;\n    \n    //vec3 eye = vec3(-5.0 + 10.0 * (1.- iMouse.x / iResolution.x), 8. + 10.0 * (iMouse.y / iResolution.y), 15.) * RotateY(mod(iTime * 0.5, 6.28));\n    vec3 eye = vec3(-5.0 + 10.0, 8. + 10.0 * sin(iTime * 0.3) + 2., 15.) * RotateY(mod(iTime * 0.5, 6.28));\n    \n    mat3 viewToWorld = ViewMatrix(eye, vec3(0.), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    vec2 dist = DistanceToSurface(eye, worldDir, MIN_D, MAX_D);    \n     \n    vec2 uv = fragCoord.xy /iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;           \n    \n    if (iTime < 2. || dist.x > MAX_D - EPS) // no hit or in intro pre-roll\n    {\n        color = Confetti(uv, iTime);\n        color += Confetti(uv * 0.8, iTime * 1.1);\n        //color = pow( clamp(color,0.0,1.0), vec3(0.4545) );\n       \tfragColor = vec4(color, 1.0);\n        return;\n    }\n       \n    // Closest point on eye ray\n    vec3 p = eye + dist.x * worldDir;\n \n    vec3 k_a, k_d, k_s;\n    float shininess, reflection;\n        \n    // Figure out what material this is and render\n    if (dist.y < 1.1) // cake 1.0\n    {\n        k_a = vec3(0.8) + vec3(SinPlasma(p), SinPlasma(p*1.8), SinPlasma(p * 1.5));\n        k_d = k_a;\n        k_s = k_a * 2.;\n        shininess = 20.;\n       // reflection = DistanceToSurface(p, reflect(worldDir, CalculateNormal(p)), EPS, MAX_D_REFL).x;\n        reflection = 0.;\n        color = PhongLight(k_a, k_d, k_s, shininess, p, eye, true);\n    } else if (dist.y < 2.1) // candle 2.0\n    {\n        k_a = vec3(0.65, 0.7, 0.72);\n        k_d = vec3(0.3, 0.7, 0.7);\n        k_s = k_a * 2.;\n        shininess = 10.;\n        reflection = 0.;\n        color = PhongLight(k_a, k_d, k_s, shininess, p, eye, false);\n    } else if (dist.y < 3.1) // tray\n    {\n        k_a = vec3(0.1, 0.7, 0.6);\n        k_d = k_a;\n        k_s = k_a;\n        shininess = 5.;\n        //reflection = DistanceToSurface(p, reflect(worldDir, CalculateNormal(p)), EPS, MAX_D_REFL).x;\n        reflection = 0.;\n    \tcolor = PhongLight(k_a, k_d, k_s, shininess, p, eye, true);\n    } else if (dist.y > 4.1) // flame\n    {\n    \tk_a = mix(vec3(0.8, 0.8, 0.01), vec3(0.6, 0.2, 0.01), abs(sin(iTime * 10. + noise11(dist.y))));\n        k_d = k_a * 1.1;\n        k_s = k_a;\n        shininess = 0.;\n        reflection = 0.;\n        color = PhongLight(k_a, k_d, k_s, shininess, p, eye, false);\n    }\n   \n    if (iTime < 22.) {\n        \tfloat scale = iTime - (1.0455 * iTime) + 1.;\n        \t\n        \t// fade in color which has been set by raymarch\n        \tcolor = color * (1. - scale);\n        \n        \t// fade out confetti in foreground. raymarch miss pixels will be confettied throughout\n        \tcolor += Confetti(uv, iTime)  * scale;\n    \t\tcolor += Confetti(uv * 0.8, iTime /2.) * scale;\n   \t}\n        \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 566, 591, 591, 653], [655, 655, 682, 682, 718], [725, 725, 750, 750, 1105], [1107, 1107, 1131, 1212, 1326], [1329, 1329, 1358, 1358, 1499], [1501, 1501, 1528, 1528, 1641], [1643, 1643, 1677, 1677, 1711], [1713, 1713, 1751, 1751, 1856], [1858, 1858, 1901, 1901, 2057], [2059, 2059, 2084, 2084, 2126], [2128, 2128, 2172, 2172, 2219], [2244, 2262, 2283, 2283, 2827], [2829, 2829, 2907, 2907, 3241], [3243, 3243, 3309, 3309, 3431], [3433, 3433, 3491, 3491, 3620], [3622, 3622, 3655, 3655, 3888], [3890, 3890, 4044, 4044, 4759], [4761, 4761, 4858, 4858, 5255], [5257, 5257, 5281, 5281, 5365], [5367, 5367, 5403, 5403, 5684], [5686, 5686, 5742, 5742, 8627]], "test": "valid"}
{"id": "4stBzS", "name": "Gradient operator fun", "author": "nathsou", "description": "Gradient operator fun", "tags": ["gradient", "convolution", "operator"], "likes": 0, "viewed": 122, "published": "Public", "date": "1525735476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grayScale(vec2 uv) {\n\treturn dot(texture(iChannel0, mod(uv, iResolution.xy)).rgb, vec3(0.21, 0.72, 0.07));\n}\n\nfloat convolution(vec2 uv, mat3 kernel) {\n    float sum = 0.0;\n    float scale = 1.0;\n    vec2 stepSize = scale / iResolution.xy;\n \n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            sum += kernel[i + 1][j + 1] * grayScale(uv + vec2(i, j) * stepSize);\n        }\n    }\n    \n    return sum;\n}\n\nfloat kernelNormalizationFactor(mat3 kernel) {\n    float factor = 0.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            factor += abs(kernel[i][j]);\n        }\n    }  \n    \n    return 1.0 / factor;\n}\n\nvec2 grad(vec2 uv) {\n   \n    mat3 grad_x = (1.0 / 3.0) * mat3(\n    \t1.0, 0.0, -1.0,\n        2.0, 0.0, -2.0,\n        1.0, 0.0, -1.0\n    );\n    \n    mat3 grad_y = (1.0 / 3.0) * mat3(\n    \t1.0, 2.0, 1.0,\n        0.0, 0.0, 0.0,\n        -1.0, -2.0, -1.0\n    );\n    \n    return vec2(\n        convolution(uv, grad_x), //values between -1 and 1\n        convolution(uv, grad_y)\n    );\n}\n\nfloat gradMag(vec2 uv) {\n \treturn length(grad(uv)); \n}\n\nfloat gradAngle(vec2 uv) {\n    vec2 gr = grad(uv);\n \treturn atan(gr.y, gr.x);   \n}\n\n\n// iq's smooth hsv to rgb\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 colorWheel(float mag, float angle) {\n\t//float hue = ((angle / 3.1415926) + 1.0) / 2.0;\n    float hue = (sin(iTime * 0.1) + 1.0) / 2.0;\n    float q = 0.001;\n    float m = pow(q, mag);\n \treturn hsv2rgb(vec3(hue, 1.0, m - mod(m, 0.15)));   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //vec3 col = vec3(gradMag(uv));\n    \n    float phase = -0.2;\n    vec3 col = colorWheel(gradMag(uv), mod(gradAngle(uv) + phase, 6.283185));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4stBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 114], [116, 116, 157, 157, 443], [445, 445, 491, 491, 682], [684, 684, 704, 704, 1061], [1063, 1063, 1087, 1087, 1117], [1119, 1119, 1145, 1145, 1201], [1204, 1230, 1255, 1255, 1417], [1419, 1419, 1460, 1510, 1663], [1665, 1665, 1720, 1770, 2019]], "test": "error"}
{"id": "4tXBW7", "name": "Quadratic vs cubic Bspline", "author": "dahart", "description": "Comparison of quadratic and cubic bsplines. ", "tags": ["cubic", "quadratic", "bspline", "chaikin"], "likes": 2, "viewed": 162, "published": "Public", "date": "1525557796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const bool showCps   = bool(0);\nconst bool showQuad  = bool(1);\nconst bool showCubic = bool(1);\n\nmat3x3 qm = mat3x3(\n    vec3(1.0, 0.0, 0.0),\n    vec3(-2.0, 2.0, 0.0),\n    vec3(1.0, -2.0, 1.0)\n    );\n\nmat3x3 qi = mat3x3(\n    vec3(0.5, 0.5, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.5, 0.5)\n    );\n\nvec2 quadratic(vec2 a, vec2 b, vec2 c, float u) {\n    vec3 uu = vec3(1.0, u, u*u);\n    mat3x2 abc = mat3x2(a, b, c);\n    vec2 p = abc * qi * qm * uu;\n    return p;\n}\n\nmat4x4 cm = (1.0 / 6.0) * mat4x4(\n    vec4(1.0, 4.0, 1.0, 0.0),\n    vec4(-3.0, 0.0, 3.0, 0.0),\n    vec4(3.0, -6.0, 3.0, 0.0),\n    vec4(-1.0, 3.0, -3.0, 1.0)\n);\n\nvec2 cubic(vec2 a, vec2 b, vec2 c, vec2 d, float u) {\n    vec4 uu = vec4(1.0, u, u*u, u*u*u);\n    mat4x2 abcd = mat4x2(a, b, c, d);\n    vec2 p = abcd * cm * uu;\n    return p;\n}\n\nconst float cptXStart = 20.f;\nconst float cptXSpread = 30.f;\nconst int cptCount = 20;\n    \nvec2 getCpt(int i) {\n    float fi = float(i);\n    return vec2(cptXStart + fi * cptXSpread, 200.0 + 100.0 * sin(exp(fi/5.0) + 5.0 * sin(iTime)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec2 pts[cptCount];\n    \n    float cptX = (fragCoord.x - cptXStart) / cptXSpread;\n    int cptIdx = int((fragCoord.x - cptXStart) / cptXSpread + .5);\n    int offset = (fragCoord.x < cptX) ? 0 : 0;\n    int cptIdxm2 = max(0, cptIdx - 2 + offset);\n    int cptIdxp2 = min(cptCount - 1, cptIdx + 2 + offset);\n    \n    for (int i = 0; i < cptCount; i++) pts[i] = getCpt(i);\n    //for (int i = cptIdxm2; i <= cptIdxp2; i++) pts[i] = getCpt(i);\n   \n    //if (cptIdx % 2 == 0) fragColor = vec4(.2, .2, .2, 1.);\n    //if (cptIdx == 0)     fragColor = vec4(.2, .0, .0, 1.);\n    \n    if (showCps) { \n        if (distance(fragCoord.xy, pts[cptIdx]) < 6.0) fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n\n    if (showCubic) {\n        for (int i = cptIdxm2; i <= cptIdxp2; i++) \n        {\n            for (float u = 0.; u < 1.; u += .05) {\n                vec2 p = cubic(pts[i-2], pts[i-1], pts[i-0], pts[i+1], u);\n                if (distance(fragCoord.xy, p) < 2.0) fragColor = vec4(1.0, u, 1.0-u, 1.0);\n            }\n        }\n    }\n\n    if (showQuad) {\n        for (int i = cptIdxm2+1; i <= cptIdxp2-1; i++) {\n            for (float u = .0; u < 1.; u += .05) {\n                vec2 p = quadratic(pts[i-1], pts[i], pts[i+1], u);\n                if (distance(fragCoord.xy, p) < 2.0) fragColor = vec4(u, 1.0-u, 1.0, 1.0);\n            }\n        }\n    }\n\n    if (showCps) {\n        for (int i = cptIdxm2; i <= cptIdxp2; i++) {\n            vec2 a = 0.5 * (pts[i-1] + pts[i]);\n            vec2 b = pts[i];\n            vec2 c = 0.5 * (pts[i] + pts[i+1]);\n\n            if (distance(fragCoord.xy, a) < 4.0) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            if (distance(fragCoord.xy, b) < 6.0) fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n            if (distance(fragCoord.xy, c) < 8.0) fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 352, 352, 468], [631, 631, 684, 684, 807], [900, 900, 920, 920, 1046], [1048, 1048, 1105, 1105, 2973]], "test": "valid"}
{"id": "ld3fDM", "name": "MovingGradients", "author": "gilesruscoe", "description": "grads", "tags": ["test"], "likes": 1, "viewed": 74, "published": "Public", "date": "1525357013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Shadertoy code//\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.y *= aspectRatio;\n\n    //Matrix shader code//\n    \n    float tiles = 200.0; //number of tiles\n    float xGrad = fract(uv.x * tiles); //x patches\n    float yGrad = fract(0.5+uv.y * tiles); //y patches\n    float cellWidth = 0.75; //width of cells\n    \n    //Colours to blend between\n    vec3 colA = vec3(0.5, 0.82, 0.0);\n    vec3 colB = vec3(0.750, 0.65, 0.15);\n    vec3 colC = vec3(0.5, 0.25, 0.86);\n    \n    //Grid shape\n    vec2 grid = vec2(step(xGrad, cellWidth), step(yGrad, cellWidth)); //the grid x and y stripes\n    float gridMask = grid.x - (1.0-grid.y); //make grid pattern from x and y stripes\n    float cellIdX = floor(uv.x * tiles) / tiles; //create a 0 to 1 stepped index for each tile to vary X gradients\n    \n    //Quick hash function for semi-random X tiles\n    float randMask = fract(sin(cellIdX * 15234.23491) * 252312.523491292);\n\n    float tailSize = 2.5; //Length of vertical gradients\n    float randomness = 22.0; //Amount of X variation\n    float speedRandomness = 0.5;\n    float speed = 0.5 + randMask * speedRandomness; //Scroll speed\n    float animWave = fract(iTime * speed + (uv.y * tailSize) + randMask * randomness); //The animation controller\n    \n    \n    //Colour blending masks\n    float ABMask = min(1.0, animWave * 2.0);\n    float BCMask = max(0.0, animWave - 0.5) * 1.5;\n    \n    //Blend Colours\n    vec3 cellCol = mix(mix(colA, colB, ABMask), colC, BCMask);\n\tcellCol *= gridMask;\n    \n    //final output\n\tvec3 col = cellCol;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3fDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 80, 1711]], "test": "valid"}
{"id": "ld3fDs", "name": "3D Grid Traversal w/ Refraction", "author": "glk7", "description": "Traversal of a 3d grid with refraction. Code and visuals are based on the 2d analogous shader \n[url=https://www.shadertoy.com/view/ltXBz7] 2D Grid Traversal w/ Refraction [/url].\n\nThe mouse can be used to rotate the view.\n", "tags": ["3d", "grid", "refraction", "traversal"], "likes": 29, "viewed": 1014, "published": "Public API", "date": "1527529407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nfloat iRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in float b) \n{\n    vec3 t0 = (-vec3(b) - ro) * invrd;\n    vec3 t1 = (vec3(b) - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    return fmin * sign(fmax - fmin);\n}\n\nfloat segment(vec2 uv, float e, float w, vec2 a, vec2 b)\n{         \n    b -= a;\n    uv -= a;\n    return smoothstep(-e, e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)) - w);\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(-e, e, length(uv - p) - 0.0025); \n}\n\nfloat draw_cell(vec2 uv, float e, float w, vec3 c, float s, mat4 T) \n{\n    vec4 b1 = T * vec4(c + vec3(-0.5, -0.5, -0.5)*s, 1.0);\n    vec4 b2 = T * vec4(c + vec3(-0.5, -0.5, 0.5)*s, 1.0);\n    vec4 b3 = T * vec4(c + vec3(0.5, -0.5, 0.5)*s, 1.0);\n    vec4 b4 = T * vec4(c + vec3(0.5, -0.5, -0.5)*s, 1.0);\n   \n    vec4 t1 = T * vec4(c + vec3(-0.5, 0.5, -0.5)*s, 1.0);\n    vec4 t2 = T * vec4(c + vec3(-0.5, 0.5, 0.5)*s, 1.0);\n    vec4 t3 = T * vec4(c + vec3(0.5, 0.5, 0.5)*s, 1.0);\n    vec4 t4 = T * vec4(c + vec3(0.5, 0.5, -0.5)*s, 1.0);\n    \n    b1.xy /= b1.z;\n    b2.xy /= b2.z;\n    b3.xy /= b3.z;\n    b4.xy /= b4.z;\n    \n    t1.xy /= t1.z;\n    t2.xy /= t2.z;\n    t3.xy /= t3.z;\n    t4.xy /= t4.z;\n    \n    float v = 1.0;\n    v *= segment(uv, e, w, b1.xy, b2.xy);\n    v *= segment(uv, e, w, b2.xy, b3.xy);\n    v *= segment(uv, e, w, b3.xy, b4.xy);\n    v *= segment(uv, e, w, b4.xy, b1.xy);\n    \n    v *= segment(uv, e, w, t1.xy, t2.xy);\n    v *= segment(uv, e, w, t2.xy, t3.xy);\n    v *= segment(uv, e, w, t3.xy, t4.xy);\n    v *= segment(uv, e, w, t4.xy, t1.xy);\n    \n    v *= segment(uv, e, w, b1.xy, t1.xy);\n    v *= segment(uv, e, w, b2.xy, t2.xy);\n    v *= segment(uv, e, w, b3.xy, t3.xy);\n    v *= segment(uv, e, w, b4.xy, t4.xy);\n    \n\treturn v;\n}\n\nfloat draw_arrow(vec2 uv, float e, float w, vec3 p, vec3 d, mat4 T)\n{\n\tvec4 a = T * vec4(p, 1.0);\n    vec4 b = T * vec4(p - d, 1.0);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    \n    vec2 pd = normalize(b.xy - a.xy);\n    vec2 ppd = vec2(-pd.y, pd.x);\n    \n    return point(uv, e, a.xy)\n        * segment(uv, e, w, a.xy, a.xy + pd*0.005 + ppd*0.003) \n        * segment(uv, e, w, a.xy, a.xy + pd*0.005 - ppd*0.003)\n        * segment(uv, e, w, a.xy, a.xy + pd*0.02);\n    \n}\n\nfloat draw_segment(vec2 uv, float e, float w, vec3 p0, vec3 p1, mat4 T) \n{\n    vec4 a = T * vec4(p0, 1.0);\n    vec4 b = T * vec4(p1, 1.0);\n    \n    a.xy /= a.z;\n    b.xy /= b.z;\n    \n    return segment(uv, e, w, a.xy, b.xy) * point(uv, e, b.xy);\n}\n\nfloat draw_point(vec2 uv, float e, vec3 p, mat4 T)\n{\n    vec4 a = T * vec4(p, 1.0);\n    \n    a.xy /= a.z;\n    \n    return point(uv, e, a.xy);\n}\n\nfloat refract_index(vec3 c) \n{\n    return 1.0 + step(-2.1, -length(c + vec3(0.5)))*1.7;\n}\n\nvec2 traversal(vec2 uv, float e, vec3 ro, vec3 rd, vec3 cro, vec3 crd, mat4 T)\n{\n    vec3 icrd = 1.0 / crd;\n    \n    const float size = 4.0;\n    \n    if (iRayAABox(cro, crd, icrd, size + 1.0) < 0.0) {\n        return vec2(1.0, 0.0);\n    }\n        \n    float b = iRayAABox(ro, rd, 1.0/rd, size);\n    if (b < 0.0) return vec2(1.0, 0.0);\n    \n    ro += b*rd; \n    \n    vec3 c = floor(ro + rd*0.001) + 0.5;\n    ro -= c;\n\n    vec2 v = vec2(draw_arrow(uv, e, 0.001, ro + c, rd, T), 0.0);\n    \n    float refri = refract_index(c - 0.5);\n    \n    for( int i = 64; i > 0; --i ){\n       \t\n        vec3 d = (sign(rd)*0.5 - ro) / rd;\n    \tvec3 n = -sign(rd) * step(d.xyz, d.yxx) * step(d.xyz, d.zzy);\n        \n        vec3 pro = ro;\n        ro += min(d.x, min(d.y, d.z)) * rd;\n        \n        v.x *= draw_segment(uv, e, 0.001, pro + c, ro + c, T);\n        v.x *= 1.0 - ((1.0 - draw_cell(uv, e, 0.0005, c, 1.0, T)) * 0.75);\n        v.y = max(v.y, step(0.0, iRayAABox(cro - c, crd, icrd, 0.5)));\n        \n        // Refraction part.\n        #if 1\n        float nrefri = refract_index(c - 0.5 - n);\n        \n        vec3 reflrd = reflect(rd, n);\n        rd = refract(rd, n, refri/nrefri);\n        \n        float t = step(0.0, -dot(rd, rd));\n       \trefri = mix(nrefri, refri, t);\n        rd += reflrd*t;\n        n *= 1.0 - t;\n        #endif\n        \n        c -= n;\n        ro += n;\n       \n        if (any(greaterThan(abs(c), vec3(size - 0.5)))) break;\n        \n    }\n    \n    return v;\n}\n\nvec4 grid(vec2 uv, float e, vec3 ro, vec3 rd, mat4 T)\n{\n\tvec3 ird = 1.0/rd;\n    vec3 srd = sign(rd);\n    \n    const float size = 4.0;\n    \n    vec3 col = vec3(0.3, 0.5, 1.0);\n    float v = 1.0 - draw_cell(uv, e, 0.0015, vec3(0.0), 2.0*size, T);\n    \n    float b = iRayAABox(ro, rd, ird, size);\n    if (b < 0.0) return vec4(vec3(1.0), (1.0 - v) * 0.2);\n    \n    ro += b*rd; \n    \n    vec3 c = floor(ro + rd*0.001) + 0.5;\n    ro -= c;\n\n    //float dist = 0.0;\n    \n    for( int i = 64; i > 0; --i ){\n        float h =  step(1.5, refract_index(c - 0.5));\n        col = mix(col, vec3(1.0, 0.5, 0.3), h);\n        v = max(v, (1.0 - draw_cell(uv, e, 0.00015, c, 1.0, T)) * mix(0.5, 0.9, h));\n        \n        vec3 d = (srd*0.5 - ro) * ird;\n    \tvec3 n = -srd * step(d.xyz, d.yxx) * step(d.xyz, d.zzy);\n        \n        c -= n;\n        \n        if (any(greaterThan(abs(c), vec3(size - 0.5)))) break;\n        \n       \tfloat inc = min(d.x, min(d.y, d.z));\n        //dist += inc;\n        ro += inc * rd;\n        ro += n;\n    }\n    \n    return vec4(col, 1.0 - v);\n}\n\nconst float PI = 3.14159;\n\nconst float cam_dist = 25.0;\nmat4 camera() \n{\n\tvec2 m = -vec2(((iMouse.xy + 0.01) / iResolution.xy) * 2.0*PI) - vec2(PI, 0.0);\n    \n    if (all(lessThan(iMouse.xy, vec2(10.0)))) {\n        m = vec2(sin(iTime*0.1), cos(iTime*0.1));\n    }\n    \n    vec2 c = cos(m);\n    vec2 s = sin(m);\n    \n   \tmat4 t = mat4(c.x, 0.0, -s.x, 0.0, \n                  s.x*s.y, c.y, c.x*s.y, 0.0, \n                  s.x*c.y, -s.y, c.x*c.y, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    \n    t[3] = vec4(t[2].xyz * -cam_dist, 1.0); \n    \n    return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat e = 1.0 / iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    vec3 ro = vec3(0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    \n    mat4 T = camera();\n    \n    ro = (T * vec4(ro, 1.0)).xyz;\n    rd = mat3(T) * rd;\n    \n    //mat4 iT = inverse(T);\n    mat4 iT = mat4(transpose(mat3(T)));\n    iT[3] = vec4(0.0, 0.0, cam_dist, 1.0);\n    \n    vec4 v = grid(uv, e, ro, rd, iT);\n    \n    vec3 tro = vec3(cos(iTime*0.1)*5.0, sin(iTime*0.1)*5.0, 6.0);\n    \n    vec2 tv = traversal(uv, e,tro, normalize(-tro + 1.333), ro, rd, iT);\n    v.rgb += tv.y*0.2;\n    v.rgb *= tv.x * v.w;\n \n    fragColor = vec4(pow(clamp(v.rgb, 0.0, 1.0), vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3fDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 117, 186, 186, 473], [475, 475, 533, 533, 685], [687, 687, 727, 727, 782], [784, 784, 854, 854, 2036], [2038, 2038, 2107, 2107, 2506], [2508, 2508, 2582, 2582, 2755], [2757, 2757, 2809, 2809, 2900], [2902, 2902, 2932, 2932, 2991], [2993, 2993, 3073, 3073, 4466], [4468, 4468, 4523, 4523, 5521], [5579, 5579, 5595, 5595, 6086], [6088, 6088, 6145, 6145, 6816]], "test": "valid"}
{"id": "ld3fzf", "name": "Rainbow Things", "author": "aiekick", "description": "Rainbow Things", "tags": ["rainbow", "things"], "likes": 1, "viewed": 397, "published": "Public API", "date": "1526142147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 GetRainBow(float r)\n{\n\tint i = int(3.*fract(r)); \n\tvec4 c = vec4(.25);   \n\tc[(i+1)%3] += r = fract(3.*r);\n\tc[i] += 1.-r;\n\treturn c.rgb;\n}\n\nvec3 bg(vec2 uv)\n{\n\tfloat t = iTime;\n\tuv += iTime*0.01;\n\tuv *= 3.;\n\tfloat id = cos(uv.x) * cos(uv.y) + length(uv + t*0.2);\n\treturn GetRainBow(id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 g )\n{\n   \tvec2 si = iResolution.xy;\n    vec2 uv = (g+g - si)/si.y;\n\tfloat t = iTime * 0.2;\n\tuv.x += cos(t)*2.;\n\tuv.y += sin(t)*cos(t)*2.;\n\tfloat a = cos(uv.x) * sin(uv.y) * sin(t) * 0.5;\n    uv *= mat2(cos(a),-sin(a),sin(a),cos(a)) * 3.;\n\tuv = floor(cos(uv)*30.) / 30.;\n\tfragColor = vec4(bg(uv * (length(uv) - 0.5)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld3fzf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 138, 164, 164, 280], [282, 282, 300, 300, 430], [432, 432, 481, 481, 798]], "test": "valid"}
{"id": "ldcBRs", "name": "gimme all your money", "author": "FabriceNeyret2", "description": "historical ref: [url]https://youtu.be/vUebXhOspyE?t=27s[/url]", "tags": ["illusion", "perception", "onetweet", "golf"], "likes": 8, "viewed": 517, "published": "Public API", "date": "1526324976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**  // 139 chars 1-tweet version\n\n#define mainImage(O,u)                              \\\n    vec2 R  = iResolution.xy, U = u+u-R;            \\\n    float l = length(U)/R.y;                        \\\n    O += .5 + sin( 3. * atan(U.y,U.x) + 12.*iTime   \\\n                         + l* (   l < .7  ?  60.    \\\n                                : l < 1.4 ? -45.    \\\n                                :            36. ) )\n/**/        \n        \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U = (U+U-R)/R.y;\n    float t = 4.*iTime, l = length(U), a = atan(U.y,U.x);\n    O = vec4(.5 + sin(  l < .7  ? 3.*(a+20.*l+t)\n                      : l < 1.4 ? 3.*(a-15.*l+t)\n                      :           3.*(a+12.*l+t) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 434, 472, 472, 734]], "test": "valid"}
{"id": "ldcBWs", "name": "Cloudy Movement", "author": "Squiggle", "description": "Voronoi & Flow Noise for shape + Flow Noise for distortion + gradient map for colors.\nUsed Voronoi and Flow Noise because they allow for non-directional movement.\nShout outs to https://www.shadertoy.com/view/MstXWn and iq's website/articles!", "tags": ["voronoi", "noise", "clouds", "sky", "flownoise"], "likes": 8, "viewed": 868, "published": "Public API", "date": "1527188559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    \nvec2 hash2( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat voronoi( in vec2 x, float phase )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n    \n    float md = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        o = 0.5 + 0.5*sin( phase + 6.2831*o );\n        vec2 r = g - f + o;\n        float d = dot( r, r );\n        \n       \tmd += 1.0/pow( d, 8.0 );\n    }\n    return 1.0-pow( 1.0/md, 1.0/8.0 );\n}\n\nfloat flowNoise( in vec2 p, float t )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    mat2 R = mat2(cos(t),-sin(t),sin(t),cos(t));\n    if (mod(i.x+i.y,2.)==0.) R=-R;\n\n    float g = 2.*mix( mix( dot( hash2( i + vec2(0,0) ), (f - vec2(0,0))*R ), \n                     dot( hash2( i + vec2(1,0) ),-(f - vec2(1,0))*R ), u.x),\n                mix( dot( hash2( i + vec2(0,1) ),-(f - vec2(0,1))*R ), \n                     dot( hash2( i + vec2(1,1) ), (f - vec2(1,1))*R ), u.x), u.y);\n    return mix( 0.0, 1.0, .5 + .5* g );\n}\n\nfloat fbm4Voronoi( vec2 p, float t )\n{\n    mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    \n    float f = 0.0;\n    f += 0.5000*voronoi( p, t*0.1 ); p = m*p*2.02;\n    f += 0.2500*voronoi( p, t*0.2 ); p = m*p*2.03;\n    f += 0.1250*voronoi( p, t*0.5 ); p = m*p*2.01;\n    //f += 0.0625*voronoi( p, t*1.0 );\n    f += 0.0625;\n    f = f/0.9375;\n    \n    return f;\n}\n\nfloat fbm4FlowNoise( vec2 p, float t )\n{\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float g = 0.0;\n    g += 0.5000*flowNoise( p, t*0.1 ); p = m*p;\n\tg += 0.2500*flowNoise( p, t*0.4 ); p = m*p;\n\tg += 0.1250*flowNoise( p, t*0.7 ); p = m*p;\n\tg += 0.0625*flowNoise( p, t*0.3 ); p = m*p;\n    g += 0.0325*flowNoise( p, t*0.3 ); p = m*p*2.;\n\tg = g * 1.2;\n\n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    uv.y = 0.5 - uv.y;\n    \n    float scale = 8.;\n    float gTime = iTime * 1.;\n    float speed = gTime*0.5;\n    float movement = gTime*0.15;\n    float offset = 0.6;\n    \n    uv += fbm4FlowNoise( uv * vec2(scale*1.,scale*1.) + vec2(0., speed*0.5), speed ) * 0.025;\n\tfloat f = fbm4Voronoi( uv*scale + vec2(0.0,movement), speed*10.0 );\n    float g = fbm4FlowNoise( uv*scale + vec2(0.0,movement), speed*10.0 );\n    \n    \n    float uvy = clamp( 0.0, 1.0, uv.y * 1.0 );\n    \n    g = smoothstep( 0.0, 1.0, g ) * uvy + offset;\n    f = smoothstep( 0.0, 1.0, f ) * uvy + offset;\n    \n    float dist = 0.5;\n    float threshold = 0.5;\n    float lowerLimit = (1.0-dist)-threshold;\n\tfloat upperLimit = (1.0-dist)+threshold;\n    \n    float val = f*g;\n    val *= smoothstep( lowerLimit,upperLimit, val);\n    vec4 col = vec4(0.0);\n    \n    vec4 sky = vec4(vec3(110.0/255.0, 173.0/255.0, 222.0/255.0)-0.01, 1.0);\n    float skyFlag = 0.2;\n    \n    vec4 white = vec4(1.0);\n    float whiteFlag = 0.5;\n    \n    vec4 interior = vec4(vec3(210.0/255.0), 1.0);\n    float intFlag = 0.99;\n    \n    \n    if( val < skyFlag ) col = sky;\n    else if( val < whiteFlag ) col = mix( sky, white, smoothstep(0.0,1.0,(val-skyFlag)/(whiteFlag-skyFlag)) );\n    else if( val < intFlag ) col = mix( white, interior, smoothstep(0.0,1.0,(val-whiteFlag)/(intFlag-whiteFlag)) );\n    else col = interior;\n      \n    fragColor = col;\n    \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5, 5, 27, 27, 145], [147, 147, 188, 188, 601], [603, 603, 642, 642, 1158], [1160, 1160, 1198, 1198, 1518], [1520, 1520, 1560, 1560, 1888], [1890, 1890, 1947, 1947, 3383]], "test": "valid"}
{"id": "ldcBzB", "name": "Lavatexture", "author": "ihal", "description": "Lava.", "tags": ["lava"], "likes": 5, "viewed": 198, "published": "Public", "date": "1525946163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nLava texture based on Fractal Brownian motion + domain warping as described by\nhttps://thebookofshaders.com/13/\n\nThe fbm is thresholded to generate floating rocks.\n\nColorblending modes (for glow etc) are based on their implementations in Adobe Photoshop.\n*/\n\n//-------------------------------------------------\n// Define colorscheme\n//-------------------------------------------------\nconst vec3 orange = vec3(0.65, 0.37, 0);\nconst vec3 middleRed1 = vec3(.5882, .2451, .1922);\nconst vec3 middleRed2 = vec3(.8196, .3451, .3176);\n\n//-------------------------------------------------\n// Noise & random-functions\n//-------------------------------------------------\n\nfloat rand(vec2 st){\n    //https://thebookofshaders.com/13/\n    return fract(sin(dot(st,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise(vec2 x) {\n    //https://thebookofshaders.com/11/\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float y = rand(vec2(.5));\n    float a = rand(i);\n    float b = rand(i + vec2(1., 0.0));\n    float c = rand(i + vec2(0.0, 1.));\n    float d = rand(i + vec2(1., 1.));\n    vec2 u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 st) {\n    //https://thebookofshaders.com/13/\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    // Loop of octaves\n    for (int i = 0; i < 10; i++) {\n        value += amplitude * noise(st);\n        st *= 2.2;\n        amplitude *= .5;\n    }\n    return value;\n}\n//-------------------------------------------------\n// Some useful functions for changing colors etc\n//-------------------------------------------------\nvec3 rgbToYuv(vec3 rgb) {\n    mat3 transformation = mat3(0.299, 0.587, 0.114, \n                               -0.14713, -0.28886, 0.436,\n                              0.615, -0.51499, -0.10001);\n    return transformation * rgb;\n}\nvec3 yuvToRgb(vec3 yuv) {\n    mat3 transformation = mat3(1.0, 0.0, 1.13983, \n                               1.0, -0.39465, -0.5806,\n                              1.0, 2.03211, 0.0);\n    return transformation * yuv;\n}\nvec3 colorDodge(vec3 color) {\n    //https://photoblogstop.com/photoshop/photoshop-blend-modes-explained\n    vec3 dodgeBy = vec3(.5, .5, .5);\n    dodgeBy = vec3(1.0, 1.0, 1.0) - dodgeBy;\n    color /= dodgeBy;\n    return color;\n}\nvec3 colorBurn(vec3 color, vec3 burnBy) {\n    color = vec3(1.0, 1.0, 1.0) - color;\n    color /= burnBy;\n    return vec3(1.0, 1.0, 1.0) - color;\n}\nvec3 colorBurn(vec3 color) {\n    return colorBurn(color, vec3(.6));\n}\nvec3 colorScreen(vec3 bgcolor, vec3 addcolor) {\n    vec3 onevector = vec3(1.0, 1.0, 1.0);\n    bgcolor = onevector - bgcolor;\n    addcolor = onevector - bgcolor;\n    return onevector - (bgcolor * addcolor);\n}\nvec3 colorMultiply(vec3 bgcolor, vec3 addcolor) {\n    return bgcolor * addcolor;\n}\nvec3 colorOverlay(vec3 bgcolor, vec3 addcolor) {\n   \tvec3 yuvBg = rgbToYuv(bgcolor);\n    if (yuvBg.x > 0.5) {\n        return colorScreen(bgcolor, addcolor);\n    }\n    else {\n        return colorMultiply(bgcolor, addcolor);\n    }    \n}\n\n//-------------------------------------------------\n// Start of lava-specific stuff\n//-------------------------------------------------\n\nfloat getFlowSpots(vec2 uv, float sizeOfTexture) {\n    //Based on https://thebookofshaders.com\n    vec2 q = vec2(0.);\n    q.x = fbm( uv + .5 * iTime); //Some wobbliness (fake heat)\n    q.y = fbm( uv + vec2(1.0));\n    \n\tfloat speed = .1;\n    float wobbliness = .02;\n    vec2 r = vec2(0.);\n    r.x = .5 * fbm(.1* (uv + 1.0*q + vec2(5.,1.2) + wobbliness*iTime) );\n    r.y = speed * iTime + 1.01 * fbm(.1 * uv + wobbliness * iTime);\n\tfloat flowFactor = fbm(sizeOfTexture * (uv + r));\n    return flowFactor;\n}\n\nfloat getFlowSpots(vec2 uv, float sizeOfTexture, float speed) {\n    //Based on https://thebookofshaders.com\n    uv.y /= 1.2;\n    //uv.x /= 1.5;\n    vec2 q = vec2(0.);\n    q.x = fbm( uv + .5 * iTime); //Some wobbliness (fake heat)\n    q.y = fbm( uv + vec2(1.0));\n    \n\t//float speed = .4;\n    float wobbliness = .05;\n    vec2 r = vec2(0.);\n    r.x = .5 * fbm(.2* (uv + 1.0 * q + vec2(5.,1.2) + wobbliness*iTime) );\n    r.y = speed * iTime + .2 * fbm(3.8 * uv + wobbliness * iTime);\n\tfloat flowFactor = fbm(1.5 * (uv + r) * .9);\n    //flowFactor = clamp(flowFactor, .4, 1.7);\n    return flowFactor;\n}\n\n//Something more interesting can be done here\nfloat getLavaStoneTexture(vec2 uv, float f) {\n    return getFlowSpots(uv, f);\n}\n\nvec3 getColorOfDots(vec2 uv, float f) {\n    vec3 flowColor = colorBurn(middleRed1, .8 * vec3(f));\n\tfloat f2 = smoothstep(.4, 1., f);\n    f2 = smoothstep(0., 1., f);\n    flowColor = mix(colorDodge(orange), flowColor, f2);\n    f = smoothstep(.4, 1., f);\n    flowColor = mix(flowColor, flowColor * .3, f);\n    flowColor = mix(flowColor, colorMultiply(flowColor, vec3(.5)), getLavaStoneTexture(uv, 94.4));\n    return flowColor;\n}\n\n//Not entirely happy with the look; looks too much like clouds rather than a fluid.\nvec3 getColorOfBackgroundFlow(vec2 uv, float f) {\n    f = 1. - sin(f);\n    vec3 flowColor = colorBurn(middleRed1, vec3(f));\n\tfloat f2 = smoothstep(.4, 1., f);\n    f2 = smoothstep(0., 1., f);\n    flowColor = mix(colorDodge(orange), flowColor, f2);\n    f = smoothstep(.2, 1., f);\n    flowColor = mix(flowColor, flowColor * .3, f);\n    //flowColor = mix(flowColor, colorMultiply(flowColor, vec3(.5)), getLavaStoneTexture(uv, 10.));\n    \n    return  flowColor;\n}\n\nvec3 addGlowOfSpots(vec2 uv, float f, vec3 flowColor) {\n    vec3 glowColor = mix(orange, flowColor, smoothstep(.7, 1., f));\n    glowColor = mix(colorDodge(glowColor), flowColor, smoothstep(.9, 1., f));\n    return mix(flowColor, glowColor, smoothstep(.1, .8, f));\n}\n\nfloat lavaEdgeAnimator(float edge, vec2 uv) {\n\tfloat edgeMovement = 0.5 * (sin(iTime/2.0 + uv.y) + 1.0) * 0.3;\n    float mySin = .7 * (sin(iTime + uv.y) + 1.0);\n    float mySin2 = .7 * (sin(iTime + uv.y + 2.1415) + 1.0);\n    edge += mySin * edgeMovement; \n    edge += mySin2 * edgeMovement;\n\treturn edge;\n}\n\nvec3 addGlowToEdges(vec2 uv, float f, vec3 flowColor) {\n    float uvScaler = iResolution.x/iResolution.y;\n    float MWF = .1 * f * getFlowSpots(uv, 30.); \n    float edges = smoothstep(0.0 + .1 * MWF, MWF * 2., uv.x) - \n        smoothstep((1. - MWF) * uvScaler, (1.0 - .1 * MWF) * uvScaler, uv.x);\n    float edges2 = smoothstep(0.0 + .1 * MWF, MWF, uv.x) - \n        smoothstep((1. - MWF * .5) * uvScaler, (1.0 - .05 * MWF) * uvScaler, uv.x);\n    edges = lavaEdgeAnimator(edges, uv);\n    edges2 = lavaEdgeAnimator(edges2, uv);\n    //flowColor = mix(orange, flowColor, clamp(edges, .0, 1.));\n    flowColor = mix(orange, flowColor, clamp(edges2, .2, 1.));\n    return mix(colorDodge(flowColor), flowColor, clamp(edges, .2, 1.));\n}\n\nfloat filterEdgesOfLava(float f, vec2 uv) {\n    //We want the floating stuff to stay out of the edges.\n    //There should be a better way to do this though!\n    float uvScaler = iResolution.x/iResolution.y;\n    float MWF = .003 + .2 * f; \n    float edges = smoothstep(0.0 + .7 * MWF, MWF, uv.x) - \n        smoothstep((1. - MWF) * uvScaler, (1.0 - .3 * MWF) * uvScaler, uv.x);\n    f = mix(1.0, f, clamp(edges, .0, 1.));\n    return f;\n}\n\nfloat filterFlowToTexture(float f, vec2 uv) {\n    f += smoothstep(.3, .5, f) * .8 * (1. - f);\n    f = smoothstep(0., 1., f);\n    f = filterEdgesOfLava(f, uv);\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tfloat textureFlowSpots = getFlowSpots(uv, 4.4);\n    float textureBg = getFlowSpots(uv, 2.4, .13);\n    float spotBgDivider = 1. - textureFlowSpots;\n    spotBgDivider = filterFlowToTexture(spotBgDivider, uv);\n    \n    vec3 color = mix(getColorOfBackgroundFlow(uv, textureBg), getColorOfDots(uv, textureFlowSpots), step(spotBgDivider, .5));\n\tcolor = addGlowOfSpots(uv, spotBgDivider, color);\n    color = addGlowToEdges(uv, textureFlowSpots, color);\n    \n    fragColor = vec4(color, 1.);\n    /*\n\t//PRESENTATION DEMOS\n    //Thresholded demo\n    fragColor = vec4(vec3(spotBgDivider), 1.);\n    //Background FBM + warping demo\n    fragColor = vec4(vec3(textureBg), 1.);\n    //FBM + warping demo\n    fragColor = vec4(vec3(textureFlowSpots), 1.);\n    //FBM demo\n    fragColor = vec4(vec3(fbm(uv * 5.)), 1.);\n    //Noise demo\n    fragColor = vec4(vec3(noise(uv * 5.)), 1.);\n\t*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[532, 665, 685, 724, 828], [830, 830, 851, 890, 1247], [1249, 1249, 1269, 1308, 1551], [1552, 1705, 1730, 1730, 1934], [1935, 1935, 1960, 1960, 2151], [2152, 2152, 2181, 2255, 2379], [2380, 2380, 2421, 2421, 2525], [2526, 2526, 2554, 2554, 2595], [2596, 2596, 2643, 2643, 2803], [2804, 2804, 2853, 2853, 2886], [2887, 2887, 2935, 2935, 3121], [3123, 3260, 3310, 3354, 3764], [3766, 3766, 3829, 3873, 4364], [4366, 4412, 4457, 4457, 4491], [4493, 4493, 4532, 4532, 4918], [4920, 5004, 5053, 5053, 5462], [5464, 5464, 5519, 5519, 5728], [5730, 5730, 5775, 5775, 6036], [6038, 6038, 6093, 6093, 6763], [6765, 6765, 6808, 6921, 7199], [7201, 7201, 7246, 7246, 7375], [7377, 7377, 7434, 7484, 8440]], "test": "valid"}
{"id": "ldcfz2", "name": "Test fmenozzi", "author": "fmenozzi", "description": "This is a test", "tags": ["test"], "likes": 0, "viewed": 297, "published": "Public API", "date": "1525918295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldcfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "valid"}
{"id": "lddBDj", "name": "Dellen Tartan r2", "author": "xinux", "description": "https://www.tartanregister.gov.uk/tartanDetails?ref=11271\nsmoothened & optimized. \nhalfpattern() is easily editable to create new patterns :) ", "tags": ["tartan", "kilt"], "likes": 11, "viewed": 132, "published": "Public", "date": "1526832068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nconst vec3 red = vec3(0.680,0.129,0.123);\nconst vec3 green = vec3(0.000,0.150,0.000);\nconst vec3 white = vec3(0.910,0.910,0.910);\n\n// thanks to mercury (hg_sdf)\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat line(vec2 p, inout float i, float count)\n{\n    float v = step(-p.y, -i) * step(p.y, i+count);\n    i += count;\n    \n    v *= min(1., abs(sin(p.y * PI)) + 0.2); // smooth horizontal skip\n    \n    float lc = fract((p.x + floor(p.y)) * (1. / 6.)); // local x coordinate\n    v *= clamp(abs(lc - 0.5) - 0.15, 0., 0.2) * 5.; // smooth diagonal skip\n    \n    return v;\n}\n\nvoid halfpattern(vec2 p, inout vec3 c)\n{\n    float i = 0.;\n    c += line(p, i, 2.) * white;\n    i += 4.;\n    c += line(p, i, 25.) * red;\n    c += line(p, i, 5.) * green;\n    c += line(p, i, 12.) * red;\n    \n}\n\nvoid pattern(vec2 p, inout vec3 c)\n{\n    halfpattern(p, c);\n    p = vec2(-p.x+1., -p.y);\n    halfpattern(p, c);\n}\n\nfloat overlay(vec2 p)\n{\n    float ltrbox = step(0.35, abs(p.y));\n    float vignette = \n        smoothstep(0.5, 1.2, abs(p.x)) + \n        smoothstep(0.2, 0.6, abs(p.y));\n    float ambient = sin(iTime * 0.4) * 0.05;\n    \n    return 0. -ltrbox -vignette +ambient;\n}\n\nfloat bgtexture(vec2 p)\n{\n    float bg = 0.;\n    bg += fract((p.x + p.y) * 0.5) * 0.05;\n    bg += fract(p.x * 0.5) * 0.05;\n    return bg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy - (iResolution.xy * 0.5)) / iResolution.yy;\n    float ol = overlay(p);\n    \n    // animation\n    pR(p.xy, -0.4 + iTime * 0.02);\n    p *= sin(iTime * 0.3 + 1.) * 0.5 + 1.3;\n    p.x += iTime * 0.05;\n    p.y -= iTime * 0.02;\n    p.y += sin(iTime * 0.4 + p.x * 1.) * 0.04;\n    p.x += sin(iTime * 0.3 + p.x + p.y) * 0.02;\n\n    p = fract(p); //repeat\n    \n    vec3 c = vec3(0.);\n    \n    p *= 300.;\n    c += bgtexture(p);\n    p -= 100.;\n    pattern(p, c);\n    p = vec2(-p.y, -p.x) - 1.;\n    pattern(p, c);\n    \n    c *= 1. + ol;\n    \n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 196, 228, 228, 270], [272, 272, 320, 320, 640], [642, 642, 682, 682, 850], [852, 852, 888, 888, 965], [967, 967, 990, 990, 1229], [1231, 1231, 1256, 1256, 1370], [1372, 1372, 1427, 1427, 2014]], "test": "valid"}
{"id": "lddfDl", "name": "isovalues 4c", "author": "FabriceNeyret2", "description": "reference: [url]https://www.the-scientist.com/May2018/Abstract-3d.jpg[/url]\nadapting [url]https://shadertoy.com/view/ldfcRS[/url] + 3D + pseudo depth of field", "tags": ["noise", "dof", "depthoffield", "contour"], "likes": 8, "viewed": 483, "published": "Public API", "date": "1527281240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"isovalues 5\" by FabriceNeyret2. https://shadertoy.com/view/MstfDl\n// 2018-05-25 20:45:49\n\n// Fork of \"isovalues 4\" by FabriceNeyret2. https://shadertoy.com/view/MdtfDl\n// 2018-05-25 20:28:14\n\n// variant of https://shadertoy.com/view/ldfcRS\n\n// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nfloat noise2( vec2 x ) {\n    vec2 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash2(p)  fract(sin(1e3*dot(p,vec2(1,57)))*4375.5453)        // rand\n    \n    return mix(mix( hash2(p+vec2(0,0)), hash2(p+vec2(1,0)),f.x),     // triilinear interp\n               mix( hash2(p+vec2(0,1)), hash2(p+vec2(1,1)),f.x),f.y);\n}\n\n#define noise(x) (noise2(x)+noise2(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    vec2 u = U/iResolution.y;\n    U = 6.*u - iTime;\n    O -= O; \n    for (float z=0.; z<=1.; z+=.05, U.y -= .1) { // consider 1 isovalue per altitude\n        float n = ( noise(vec2(U.x-U.y*.1,U.y/.6))-.2) / .6,\n              v = smoothstep(0.,1.5+20.*abs(u.y-.5), (n-z)/fwidth(n));\n\t    O = mix(O, vec4(n), v);\n\t // O = mix(O, z*vec4(.5,1,1,1), v);\n\t // O = mix(O, z*(.5+.5*cos(6.3*z + vec4(0,23,21,0) )), v);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 387, 411, 411, 782], [881, 881, 950, 950, 1368]], "test": "valid"}
{"id": "lddfDs", "name": "Sea of cubes with smooth-minimum", "author": "MacSlow", "description": "A nice way to visualize the influence-area of smooth-minimum aka opCombine(). The visuals are pretty self-explanatory I guess. The discontinuities in the red influence-area also show the domain-repetition cells nicely.", "tags": ["3d", "raymarching", "domain", "repetition", "spheretracing", "smoothminimum"], "likes": 13, "viewed": 905, "published": "Public API", "date": "1527321893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// smooth-min influence visualized with a sea of cubes\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 80;\nconst float EPSILON = .00025;\nconst float STEP_BIAS = .6;\n\nfloat sdSphere (in vec3 p, in float r)\n{\n\treturn length (p) - r;\n}\n\nfloat sdPlane (in vec3 p, in float h)\n{\n\treturn p.y - h;\n}\n\nfloat udBox (in vec3 p, in vec3 size, in float r)\n{\n\treturn length (max (abs (p) - size, .0)) - r;\n}\n\nfloat opCombine (in float d1, in float d2, in float r, inout int matIndex)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    float result = mix (d2, d1, h) - r * h * (1. - h);\n    float threshold = r*.001;\n\n\tmatIndex = 2;\n\n    if (abs (result - d1) <= threshold) {\n        matIndex = 0;\n    }\n\n    if (abs (result - d2) <= threshold) {\n        matIndex = 1;\n    }\n\n    return result;\n}\n\nvec2 opRepeat2 (inout vec2 p, in float size)\n{\n\tfloat h = size*.5;\n\tvec2 cell = floor ((p + h) / size);\n\tp = mod (p + h, size) - h;\n\treturn cell;\n}\n\nstruct HitResult {\n    float dist;\n    int matId;\n};\n\nHitResult scene (in vec3 p)\n{\n\tvec3 p2 = p + vec3 (-.1, -.3 - .1*(.5+.5*cos (3.*iTime)), .5);\n\tvec3 p3 = p + vec3 (.4, .0, 1.);\n\tfloat ball = sdSphere (p2, .1 + .1 * (.5+.5*cos(4.*iTime)));\n\tvec2 cell = opRepeat2 (p3.xz, .2);\n\tp3.y += .3*sin (.1*cell.x+1.5*iTime)*cos(.2*cell.y+2.*iTime);\n\tp3.y += .15*sin (.5*cell.y+3.*iTime)*cos(.5*cell.x+3.*iTime);\n\tfloat boxes = udBox (p3, vec3 (.075), .02);\n\n    int matIndex = 0;\n    float dist = opCombine (boxes, ball, .1, matIndex);\n    int cellId = int (mod (floor (cell.y+cell.x), 2.)) + 1;\n    int matIds[3] = int[3] (cellId, 0, 3);\n    HitResult result = HitResult (dist, matIds[matIndex]);\n    return result;\n}\n\nHitResult raymarch (in vec3 ro, in vec3 rd)\n{\n\tfloat d = .0;\n\tfloat t = .0;\n    HitResult result = HitResult (.0, -1);\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\tresult = scene (ro + t*rd);\n\t\td = result.dist;\n\t\tif (abs (d) < EPSILON*(1. + .125*d)) break;\n\t\tt += d*STEP_BIAS;\n\t}\n    result.dist = t;\n\treturn result;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n\tvec2 e = vec2 (epsilon, .0);\n\tfloat d = scene (p).dist;\n\treturn normalize (vec3 (scene (p + e.xyy).dist,\n\t\t\t\t\t\t\tscene (p + e.yxy).dist,\n\t\t\t\t\t\t\tscene (p + e.yyx).dist) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n\tfloat distanceToLight = distance (p, lPos);\n\tfloat distanceToObject = raymarch (p + .01*n, normalize (lPos - p)).dist;\n\tbool isShadowed = distanceToObject < distanceToLight;\n\treturn isShadowed ? .1 : 1.;\n}\n\n// coder-colors ;)\nvec3[4] materials = vec3[4] (vec3 (.0, 1., .0),  // green\n                             vec3 (1., .5, .25), // orange\n                             vec3 (.25, .5, 1.), // purple\n                             vec3 (1., .0, .0)); // red\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in vec3 n, in int matId)\n{\n\tvec3 p = ro + d*rd;\n\tvec3 amb = vec3 (.1);\n\tvec3 diffC = vec3 (1., .5, .3);\n\tvec3 specC = vec3 (1., .95, .9);\n\tvec3 diffC2 = vec3 (.3, .5, 1.);\n\tvec3 specC2 = vec3 (.9, .95, 1.);\n\n    vec3 lPos = ro + vec3 (.5, 1.0, -3.);\n    vec3 lPos2 = ro + vec3 (-1., 1.2, 2.);\n    vec3 lDir = lPos - p;\n    vec3 lDir2 = lPos2 - p;\n    vec3 lnDir = normalize (lDir);\n    vec3 lnDir2 = normalize (lDir2);\n    float sha = shadow (p, n, lPos);\n    float sha2 = shadow (p, n, lPos2);\n    float lDist = distance (p, lPos);\n    float lDist2 = distance (p, lPos2);\n    float attenuation = 8. / (lDist*lDist);\n    float attenuation2 = 8. / (lDist2*lDist2);\n\n    float diff = max (dot (n, lnDir), .0);\n    float diff2 = max (dot (n, lnDir2), .0);\n    vec3 h = normalize (lDir - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec = pow (max (dot (h, n), .0), 20.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    vec3 diffTerm = sha * attenuation * diff * diffC;\n    vec3 diffTerm2 = sha2 * attenuation2 * diff2 * diffC2;\n    vec3 specTerm = (sha > .1) ? attenuation * spec * specC : vec3 (.0);\n    vec3 specTerm2 = (sha2 > .1) ? attenuation2 * spec2 * specC2 : vec3 (.0);\n\n    vec3 color = materials[matId];\n\n    return amb + diffTerm*color + specTerm + diffTerm2*color + specTerm2;\n}   \n\nvec3 camera (in vec2 uv, in vec3 ro, in float zoom, in vec3 aim)\n{\n\tvec3 forward = normalize (aim - ro);\n\tvec3 worldUp = vec3 (.0, 1., .0);\n\tvec3 right = normalize (cross (forward, worldUp));\n\tvec3 up = normalize (cross (right, forward));\n\tvec3 center = normalize (ro + forward*zoom);\n\treturn normalize ((center + uv.x*right + uv.y*up) - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tfloat offset = 1.75;\n\tvec3 ro = vec3 (offset*cos(.2*iTime), .9, offset*sin(.2*iTime));\n\tvec3 aim = vec3 (-offset*.1*cos (iTime),.1,-offset*.1*sin (iTime));\n\tfloat zoom = 2.;\n\tvec3 rd = camera (uv, ro, zoom, aim);\n\n\tHitResult result = raymarch (ro, rd);\n\tfloat d = result.dist;\n\tfloat fog = 1. / (1. + d*d*.2);\n\tvec3 p = ro + d*rd;\n\tvec3 n = normal (p, d*EPSILON);\n\tvec3 col = shade (ro, rd, d, n, result.matId);\n\n\tcol *= fog;\n\t//vec3 sky = mix (vec3 (.1, .2, .5), vec3 (1., 1., .3), 1. - .05*p.y*p.y);\n\t//col = mix (col, sky, pow (1. - 1. / d, 20.));\n\tcol = mix (col, vec3 (.65, .7, .9), pow (1. - 1. / d, 20.));\n\tcol = col / (1. + col);\n\tcol *= vec3 (.8, .7, .6);\n\tcol = .2*col + .8*sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddfDs.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1019, 1059, 1059, 1085], [1087, 1087, 1126, 1126, 1145], [1147, 1147, 1198, 1198, 1247], [1249, 1249, 1325, 1325, 1645], [1647, 1647, 1693, 1693, 1794], [1850, 1850, 1879, 1879, 2508], [2510, 2510, 2555, 2555, 2823], [2825, 2825, 2868, 2868, 3044], [3046, 3046, 3097, 3097, 3304], [3550, 3558, 3632, 3632, 4912], [4917, 4917, 4983, 4983, 5261], [5263, 5263, 5320, 5320, 6151]], "test": "valid"}
{"id": "lddfRl", "name": "cubezoomer", "author": "halcy", "description": "zooms into a cube.\n\nreduce levels a little if too slow. if your computer complains about loop variables, undef OVERSAMPLE (you'll get aliasing / anisotropy problems, though)", "tags": ["cube", "zoom"], "likes": 11, "viewed": 533, "published": "Public API", "date": "1527067526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Various knobs to twiddle\n#define MIN_DIST 0.001\n#define STEP_MULTIPLIER 1.0\n#define NORMAL_OFFSET 0.001\n#define MAX_STEPS 128\n#define LEVELS 5\n#define SPEED 10.0\n#define OVERSAMPLE\n\n// Timing\nfloat zoomtimer() {\n    return(sin(iTime * 0.2) * SPEED);\n}\n\n// Palette helper\nvec3 color(float inVal) {\n\tvec3 a = vec3(0.5, 0.5, 0.5);\n\tvec3 b = vec3(0.5, 0.5, 0.5);\n\tvec3 c = vec3(1.0, 1.0, 0.5);\n\tvec3 d = vec3(0.8, 0.9, 0.3);\n\treturn(a + b * cos(6.28318 * (c * inVal + d)));\n}\n\n// World\nvec4 distfunc(vec3 pos) {\n  \tvec4 box = vec4(0.0);\n    box.a = max(max(abs(pos.y) - 0.5, abs(pos.z) - 0.5), abs(pos.x) - 0.5);\n    return(box);\n}\n\n// For fuzzing up stuff\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// View setup\nvoid camera(vec2 coords, out vec3 eye, out vec3 ray, float level) {\n    // Zoom-in\n    float zoomtime = zoomtimer();\n    float zoom = mod(zoomtime, 1.0) - level;\n    float zoomlevel = floor(zoomtime) + level;\n    \n    // Calculate an eye position\n    eye = normalize(vec3(\n        sin(zoomlevel), \n        sin(iTime + zoomlevel),\n        cos(zoomlevel * 2.0))) * 1.75;\n    \n    float tolevel = zoomlevel;\n    vec3 eyeto = normalize(vec3(\n        sin(tolevel), \n        sin(iTime + zoomlevel),\n        cos(tolevel * 2.0))) * 1.75;\n    \n    if(abs(eyeto.x) > abs(eyeto.z)) {\n    \teyeto = vec3(sign(eyeto.x),  0.0, 0.0);\n    }\n    else{\n        eyeto = vec3(0.0, 0.0, sign(eyeto.z));\n    }\n    \n    // Camera as eye + imaginary screen at a distance\n    eye = mix(eye, eyeto, zoom);   \n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    ray = normalize(pixelpos - eye);\n}\n\n// Raymarch one hit\nvec4 march(vec2 coords, out float iters, float level) {\n    // Set up view\n    vec3 eye, ray;\n    camera(coords, eye, ray, level);   \n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n    // Check hit\n    if(int(iters) == MAX_STEPS) {\n    \t return(vec4(pos, -1.0));  \n    }\n    \n    return(vec4(pos, dist));\n}\n\n// Colour a hit\nvec3 shade(vec2 coords, vec3 pos, float dist, float iters, vec3 matColor, float level) {\n    // Set up view, again\n    vec3 eye, ray;\n    camera(coords, eye, ray, level);\n    vec3 lightpos = eye;\n    \n    // Finite-difference normals\n   \tvec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n        distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n        distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n    ));\n    \n    // Shading\n    vec3 shadowray = normalize(lightpos - pos);    \n    float light = max(0.0, dot(normal, shadowray)) + 0.1;\n    vec3 itershade = vec3(iters / float(MAX_STEPS));\n    vec3 colorval = light * matColor + itershade * 0.3;\n    \n\treturn(colorval);\n}\n\n// Colour a non-hit\nvec3 background(vec2 coords, float level) {\n    float zoom = 0.0;\n    float zoomtime = zoomtimer();\n    zoom = mod(zoomtime, 1.0) - level;\n\t\n    // Try to deal with anisotropy / aliasing\n    // Might need more tuning\n    vec3 backColorFinal = vec3(0.0);\n    float fuzzReq = level -  mod(zoomtime, 1.0);\n    float fuzzPow = pow(fuzzReq * 0.24, 3.0);\n    float fuzzIters = floor(pow(zoom * 2.0, 2.0) + 1.0);\n    \n    // Level 0 gets extra zoomy\n    if(level == 0.0) {\n        coords /= (1.0 + zoom);\n        fuzzPow = 0.001;\n    }\n    fuzzPow *= 0.1;\n    \n#ifdef OVERSAMPLE\n    for(float s = 0.0; s < 100.0; s += 1.0) {\n        if(s >= fuzzIters) { break; } // Probably better in some implementations\n        vec2 scoords = coords + hash33(vec3(coords.x, coords.y, s)).xy * fuzzPow;\n        float shade = sin((scoords.x - scoords.y * 0.7 + iTime * 0.03) * 30.0) * 0.5;\n        shade += sin((0.7 * scoords.x + scoords.y + iTime * 0.1) * 100.0) * 0.1;\n        vec3 backColor = color(0.2);\n        if(shade > 0.0) {\n            backColor = color(0.8);\n        }\n        if(abs(shade) < 0.1) {\n            backColor = color(0.9);\n        }\n        backColorFinal += backColor;\n    }\n    backColorFinal /= fuzzIters;\n#else\n    vec2 scoords = coords;\n    float shade = sin((scoords.x - scoords.y * 0.7 + iTime * 0.03) * 30.0) * 0.5;\n    shade += sin((0.7 * scoords.x + scoords.y + iTime * 0.1) * 100.0) * 0.1;\n    vec3 backColor = color(0.2);\n    if(shade > 0.0) {\n        backColor = color(0.8);\n    }\n    if(abs(shade) < 0.1) {\n        backColor = color(0.9);\n    }\n    backColorFinal = backColor;\n#endif\n    return(backColorFinal);\n}\n\n// Texture a cube\nvec2 hitCoords(vec3 hitPos) {\n    vec2 coords;\n\tif(abs(abs(hitPos.x) - 0.5) < MIN_DIST) {\n        coords = hitPos.zy * 2.0;\n        coords.x *= -sign(hitPos.x);\n    }\n    if(abs(abs(hitPos.y) - 0.5) < MIN_DIST) {\n        coords = hitPos.xz * 2.0;\n    }\n    if(abs(abs(hitPos.z) - 0.5) < MIN_DIST) {\n        coords = hitPos.xy * 2.0;\n    }   \n    return(coords);\n}\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coords[LEVELS + 2];\n    float iters[LEVELS + 1];\n\tvec4 hit[LEVELS + 1];\n   \tcoords[1] = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    // Trace all hits\n    for(int i = 1; i < LEVELS + 1; i++) {\n        if(i == 1 || hit[i - 1].w > 0.0) {\n    \t\thit[i] = march(coords[i], iters[i], float(i - 1));\n            coords[i+1] = hitCoords(hit[i].xyz);\n        }\n        else {\n        \thit[i].w = -1.0;   \n        }\n    }\n    \n    // Shade\n    vec3 stackColor = color(0.2);\n    for(int i = LEVELS; i >= 1; i--) {\n        if(hit[i].w > 0.0) {\n            stackColor = shade(coords[i], hit[i].xyz, hit[i].w, iters[i], stackColor, float(i - 1));\n        }\n        else {\n            stackColor = background(coords[i], float(i));   \n        }\n    }\n    fragColor = vec4(stackColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddfRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 195, 214, 214, 254], [256, 274, 299, 299, 474], [476, 485, 510, 510, 630], [632, 656, 676, 676, 780], [782, 796, 863, 878, 1910], [1912, 1932, 1987, 2006, 2557], [2559, 2575, 2663, 2689, 3330], [3332, 3352, 3395, 3395, 4980], [4982, 5000, 5029, 5029, 5363], [5365, 5374, 5429, 5429, 6254]], "test": "error"}
{"id": "lddfz2", "name": "Color illusion", "author": "Ultraviolet", "description": "The famous color illusion (ref:[url]https://nerdist.com/wp-content/uploads/2015/02/DressIllusion_FEAT-970x545.png[/url]).\nThe bright tile color in the dark area is the same as the dark tile color in the light area.\nUse mouse to move cam.", "tags": ["3d", "illusion", "isometric"], "likes": 14, "viewed": 240, "published": "Public", "date": "1526053748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI\t\t\t\t3.1415926535\n#define SQRT2\t\t\t0.707\n\n#define LIGHT_DIR\t\tnormalize(vec3(1., -2., 1.))\n#define CAM_SPEED\t\t.3\n#define CAM_POS \t\tvec3(4.*cos(-iTime*CAM_SPEED), 4.0, 4.*sin(-iTime*CAM_SPEED))\n\n\n\n#define CYL_POS  vec3(0.56, 0.0, 0.56)\n#define CYL_DIR  normalize(vec3(0., 1., 0.))\n#define CYL_RAD  0.35\n#define CYL_HEI  2.\n\n#define SHADOW_SHARPNESS\t.05\n\n#define AA\t4.\n\n\n// strait from http://www.iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\n// added a parameter for the far intersection normal computation\nvec2 boxIntersection( vec3 ro, vec3 rd, vec3 boxSize, mat4 txx, out vec3 outNormal, out vec3 outNormal2 )\n{\n    // convert from ray to box space\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    if( tN > tF) return vec2(-1.0); // no intersection\n\n    outNormal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    vec3 d = abs(roo+rdd*tF);\n    outNormal2 = -sign(rdd)*vec3(d.x>d.y&&d.x>d.z?1.:0., d.y>d.x&&d.y>d.z?1.:0., d.z>d.y&&d.z>d.x?1.:0.);\n\n    return vec2( tN, tF );\n}\n\n\nvec2 traceCylindre(vec3 ro, vec3 rd, out vec3 n0, out vec3 n1)\n{\n    vec3 A = rd - CYL_DIR*dot(rd,CYL_DIR);\n    vec3 B = ro - CYL_POS - CYL_DIR*dot(ro-CYL_POS,CYL_DIR);\n    \n    float delta = dot(A,B)*dot(A,B) - dot(A,A)*(dot(B,B)-CYL_RAD*CYL_RAD);\n    \n    if(delta < 0.)\n        return vec2(1., 0.);\n        \n    delta = sqrt(delta);\n    \n    float t0 = (-dot(A,B)-delta)/dot(A,A);\n    float t1 = (-dot(A,B)+delta)/dot(A,A);\n    \n    vec2 t = vec2(t0, t1);\n    \n    vec3 p0 = ro+rd*t0;\n    float h0 = dot(CYL_DIR,p0 - CYL_POS);\n    n0 = normalize(p0 - (CYL_POS+CYL_DIR*h0));\n    if(h0 > 0.)\n    {\n        return vec2(1., 0);\n    }\n    \n    if(h0 < -CYL_HEI)\n    {\n        n0 = vec3(0., -1., 0.);\n        float tt = (-CYL_HEI-ro.y)/rd.y;\n        \n        vec3 p = ro+rd*tt;\n        if(length(p - (CYL_POS - CYL_DIR*CYL_HEI))<CYL_RAD)\n        {\n            return vec2(tt, 100.);\n        }\n        return vec2(1., 0);\n    }\n    \n    vec3 p1 = ro+rd*t1;\n    float h1 = dot(CYL_DIR,p1 - CYL_POS);\n    n1 = normalize(p1 - (CYL_POS+CYL_DIR*h1));\n    \n    return t;\n}\n\n\n// from iq   https://www.shadertoy.com/view/XlcSz2\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    float ret = mod( q.x+q.y, 2.0 );            // xor pattern\n    \n    if(p.x>2. && p.x<3. && p.y>2. && p.y<3.)\n    {\n        vec2 uv = p-vec2(2.);\n        uv = uv.yx/16. + vec2(1., 11.)/16.;\n        if(texture(iChannel0, uv).w<.5)\n        \tret = 1.-ret;\n    }\n    \n    if(p.x>4. && p.x<5. && p.y>1. && p.y<2.)\n    {\n        vec2 uv = p-vec2(4., 1.);\n        uv = uv.yx/16. + vec2(2., 11.)/16.;\n        if(texture(iChannel0, uv).w<.5)\n        \tret = 1.-ret;\n    }\n    \n    return ret;\n}\n\n\n// distance between lines + param along each vector to reach closest point\nvec3 LineLineDist(vec3 P0, vec3 d0, vec3 P1, vec3 d1)\n{\n    vec3 d0c = d0 / dot(d0, d0);\n    vec3 X = d1 - d0 * dot(d1, d0c);\n    vec3 Y = P1 - P0 - d0*dot(P1, d0c);\n\n    float t1 = -dot(Y, X) / dot(X, X);\n    \n    t1 = clamp(t1, -CYL_HEI, 0.);\n\n    vec3 Pd1 = P1 + t1 * d1;\n    \n    float t0 = dot((Pd1 - P0), d0) / dot(d0, d0);\n    vec3 Pd0 = P0 + t0 * d0;\n    \n    return vec3(length(Pd1-Pd0), dot(Pd0-P0,d0)/dot(d0,d0), dot(Pd1-P1, d1)/dot(d1,d1));\n}\n\n// simulates a circular focal\nfloat shadowFunction(float x)\n{\n    //return x;\n    x *= 0.999;\n    x += 0.0005;\n    return .5+(asin(x*2.-1.)+(x*2.-1.)*sqrt(1.-(x*2.-1.)*(x*2.-1.)))/PI;\n}\n\n// ray casting\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    \n    float t = 10000.;\n    vec3 col = vec3(1.);\n    \n    \n    //--------------------------------------\n    // Board\n    vec3 n_1_box, n_2_box;\n    vec2 t_box = boxIntersection(ro, rd, vec3(1., .12, 1.), mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.), n_1_box, n_2_box);\n    \n    if(t_box.x < t_box.y)\n    {\n        t = t_box.x;\n        \n        float f = max(0., dot(n_1_box, LIGHT_DIR));\n        f = f*.6+.4;\n        \n        vec3 pos = ro+rd*t;\n        \n        float checker = checkersTexture((pos.xz-vec2(-1.0001))*.5*4.999);\n        \n        \n        \n        //--------------------------------------\n        // Shadow\n\n        vec3 d_sha = LineLineDist(ro+rd*t, LIGHT_DIR, CYL_POS, CYL_DIR);\n        \n        float f_sha = 1.;\n        if(d_sha.y > 0.)\n        {\n            f_sha = clamp(d_sha.x-CYL_RAD, -d_sha.y*SHADOW_SHARPNESS, d_sha.y*SHADOW_SHARPNESS)/d_sha.y/SHADOW_SHARPNESS * .5 + .5;\n            f_sha = shadowFunction(f_sha);\n            //col *= .5+.5*f_sha;\n        }\n\n        vec3 col_0 = vec3(0.9);\n        vec3 col_1 = vec3(0.6);\n        vec3 col_2 = vec3(0.2);\n        \n\t\tvec3 colShadow = mix(col_1, col_2, checker);\n\t\tvec3 colLight  = mix(col_0, col_1, checker);\n\t\tvec3 baseCol   = mix(colShadow, colLight, f_sha);\n        \n        \n        col = baseCol * f;\n    }\n    \n    \n    //--------------------------------------\n    // Moving tile\n    \n    float t_tile = (-.12-ro.y)/rd.y;\n    vec3 pos = ro+rd*t_tile;\n    //vec2 tile_pos = mix(vec2(0.), vec2(.8, -.4), .5+.5*sin(iTime));\n    vec2 tile_pos = mix(vec2(0., -.4), vec2(.8, -.8), .5+.5*sin(iTime));\n    vec2 diff = pos.xz - tile_pos;\n\n    if(abs(diff.x)<.2 && abs(diff.y)<.2)\n    {\n        vec3 n = vec3(0., -1., 0.);\n        float f = max(0., dot(n, LIGHT_DIR));\n        f = f*.6+.4;\n        col = vec3(0.6)* f;\n    }\n    \n    \n    \n    //--------------------------------------\n    // Cylindre\n    \n    \n    vec3 n_1_cyl, n_2_cyl;\n    vec2 t_cyl = traceCylindre(ro, rd, n_1_cyl, n_2_cyl);\n    \n    if(t_cyl.x < t_cyl.y && t_cyl.x < t)\n    {\n        t = t_cyl.x;\n        \n        float f = max(0., dot(n_1_cyl, LIGHT_DIR));\n        f = f*.6+.4;\n        \n        vec3 baseCol = vec3(28., 83., 48.)*2./255.;\n        \n        col = baseCol * f;\n    }\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    \n    vec3 ca = normalize(vec3(-2., 3., 1.));\n    \n    if(iMouse.z > 0.)\n    {\n        float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n        float psi = ((iMouse.y-0.5)/iResolution.y) * PI * .5;\n\n        ca = 5.0*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    }\n        \n    vec3 ta = vec3(0., .0, .0);\n    mat3 m = setCamera(ca, ta, 0.0);\n\t\n    float zoom = 1.;\n    //vec3 ro = (m[0]*p.x + m[2]*p.y) / zoom;\n    vec3 rd = m[1];\n    \n    \n    // scene rendering\n    vec3 col = vec3(0.);\n    \n    for(float i=0.; i<AA; ++i)\n    for(float j=0.; j<AA; ++j)\n    {\n        vec2 o = vec2(i,j) / AA - 0.5;\n        p += o/iResolution.y;\n    \tvec3 ro = (m[0]*p.x + m[2]*p.y) / zoom;\n    \tcol += render( ro, rd);\n    }\n    \n    col /= AA*AA;\n    \n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 526, 633, 670, 1255], [1258, 1258, 1322, 1322, 2320], [2323, 2374, 2410, 2410, 2921], [2924, 2999, 3054, 3054, 3453], [3455, 3485, 3516, 3532, 3640], [3642, 3657, 3694, 3694, 5970], [5973, 5973, 6025, 6025, 6202], [6204, 6204, 6261, 6261, 7120]], "test": "error"}
{"id": "lddfzj", "name": "psychedelic ", "author": "murderball", "description": "Simple modification of default shader.", "tags": ["simple"], "likes": 1, "viewed": 61, "published": "Public", "date": "1526002495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = col * 10.0 * (pow(uv.x - 0.5,2.0) + pow(uv.y - 0.5,2.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lddfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 362]], "test": "valid"}
{"id": "ldtBD4", "name": "web cam shader", "author": "maysssam", "description": "web cam shader", "tags": ["shader"], "likes": 3, "viewed": 219, "published": "Public", "date": "1525233619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DOTSIZE 1.48\n#define D2R(d) radians(d)\n#define MIN_S 2.5\n#define MAX_S 19.0\n#define SPEED 0.57\n\n#define SST 0.888\n#define SSQ 0.288\n\n#define ORIGIN (0.5 * iResolution.xy)\nfloat R;\nfloat S;\n\nvec4 rgb2cmyki(in vec3 c)\n{\n\tfloat k = max(max(c.r, c.g), c.b);\n\treturn min(vec4(c.rgb / k, k), 1.0);\n}\n\nvec3 cmyki2rgb(in vec4 c)\n{\n\treturn c.rgb * c.a;\n}\n\nvec2 px2uv(in vec2 px)\n{\n\treturn vec2(px / iResolution.xy);\n}\n\nvec2 grid(in vec2 px)\n{\n\treturn px - mod(px,S);\n}\n\nvec4 ss(in vec4 v)\n{\n\treturn smoothstep(SST-SSQ, SST+SSQ, v);\n}\n\nvec4 halftone(in vec2 fc,in mat2 m)\n{\n\tvec2 smp = (grid(m*fc) + 0.5*S) * m;\n\tfloat s = min(length(fc-smp) / (DOTSIZE*0.5*S), 1.0);\n    vec3 texc = texture(iChannel0, px2uv(smp+ORIGIN)).rgb;\n    texc = pow(texc, vec3(2.2)); // Gamma decode.\n\tvec4 c = rgb2cmyki(texc);\n\treturn c+s;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = SPEED*0.333*iTime;\n    S = MIN_S + (MAX_S-MIN_S) * (0.5 - 0.5*cos(SPEED*iTime));\n    \n\tif (iMouse.z > 0.5)\n\t{\n\t\tS = MIN_S + (MAX_S-MIN_S) * 2.0*abs(iMouse.x-ORIGIN.x) / iResolution.x;\n\t\tR = D2R(180.0 * (iMouse.y-ORIGIN.y) / iResolution.y);\n\t}\n\t\n\tvec2 fc = fragCoord.xy - ORIGIN;\n\t\n\tmat2 mc = rotm(R + D2R(15.0));\n\tmat2 mm = rotm(R + D2R(75.0));\n\tmat2 my = rotm(R);\n\tmat2 mk = rotm(R + D2R(45.0));\n\t\n\tfloat k = halftone(fc, mk).a;\n\tvec3 c = cmyki2rgb(ss(vec4(\n\t\thalftone(fc, mc).r,\n\t\thalftone(fc, mm).g,\n\t\thalftone(fc, my).b,\n\t\thalftone(fc, mk).a\n\t)));\n    \n    c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n\tfragColor = vec4(c, 1.0);\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 225, 225, 301], [303, 303, 330, 330, 353], [355, 355, 379, 379, 416], [418, 418, 441, 441, 467], [469, 469, 489, 489, 532], [534, 534, 571, 571, 815], [817, 817, 840, 840, 918], [920, 920, 977, 977, 1619]], "test": "error"}
{"id": "ldtfWs", "name": "Some kind of clover", "author": "lowww", "description": "Another glsl exercise.\nNot really sure what I'm trying to do here, just playing around", "tags": ["random", "bw"], "likes": 4, "viewed": 138, "published": "Public API", "date": "1527294278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FREQUENCY 100.0\n#define SPEED 10.0\n#define PI 3.141592653589793\n\nfloat drawCircle(vec2 uv) {\n\tfloat a = atan(uv.y, uv.x);\n\ta = a - PI / 4.0;\n\t\n    vec2 newuv = vec2(uv.x * cos(a), uv.y * sin(a));\n\tfloat d = length(newuv);\n\tfloat c = cos(d * FREQUENCY - iTime * SPEED);\n\tc *= 100.0;\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord/iResolution.y;\n    \n    // centering\n    vec2 uv2 = uv - vec2(0.5 * ratio, 0.5);\n\t\n    // shape\n    float c = drawCircle(uv2);\n    \n    // antialias\n\tc = c / fwidth(c);\n\n    fragColor = vec4(vec3(c), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldtfWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 100, 100, 302], [304, 304, 359, 359, 637]], "test": "valid"}
{"id": "ldVBRh", "name": "Animated Vornoi", "author": "kubamaruszczyk1604", "description": "Vornoi diagram with  animation.", "tags": ["animated", "vornoi", "fx", "effects", "diagram"], "likes": 4, "viewed": 189, "published": "Public", "date": "1527638276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec2 Points[9] = vec2[]\n(\n        vec2(-1.3,0.6),vec2(-0.2,0.3), vec2(0.1,0.8),\n        vec2(0.6,0.5), vec2(1.3,-0.2), vec2(0.2,0.4),\n        vec2(0.4,-0.9),vec2(-0.3, -0.9), vec2(-0.5, -0.61)\n);\n\n\nconst vec3 Colors[9] = vec3[]\n(\n        vec3(0.1,0.2,1.0),vec3(1.0,0.3,0.5), vec3(0.0,1.0,0.0),\n        vec3(1.0,0.2,0.0),vec3(1.0,1.0,0.5), vec3(1.0,1.0,0.0),\n        vec3(0.1,0.2,0.0),vec3(0.98,0.5,0.0), vec3(0.0,0.8,0.3)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Move coords to -1..1 space    \n    uv = uv * 2.0 - 1.0;\n    \n    // aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float s = sin(iTime*0.5);\n    float c = cos(iTime);\n    \n    \n    mat2 rmat = mat2(c,-s,s,c);\n    \n    vec3 colr = vec3(0.0);\n    float lastDist = 100.0;\n    for(int i = 0; i < 9;++i)\n    {\n       vec2 p = rmat*Points[i]+ 0.25*sin(iTime)*vec2(Points[i].x,Points[i].x);\n       float dist = length(uv - p);\n       if(dist<lastDist)\n       {\n           colr = Colors[i]/dist/(5.0+10.0*abs(sin(iTime*0.5)));\n           lastDist = dist;\n           \n           if(dist<0.03) colr = vec3(0.0);\n       }\n    }\n\n    vec3 col = colr+ 0.1*cos(iTime+uv.xyx+vec3(0,12,14));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVBRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 434, 491, 542, 1347]], "test": "valid"}
{"id": "ldVBRR", "name": "wwwwwwwww", "author": "lennyjpg", "description": "wwwww", "tags": ["waves", "lines", "pattern"], "likes": 19, "viewed": 845, "published": "Public API", "date": "1527631881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    uv.x+=1.5;  \n    uv.y += cos(uv.x*10.0)*0.15;\n    uv.y*=1.5;\n    float r = 7.3,\n    e = uv.x-iTime*0.5,\n    t = e + abs(uv.y),\n   //s = step( fract(t*r),f);\n   // s = smoothstep(1.5,0., (fract(t*r)-f)/fwidth(t*r-f)); \n   //O = vec4(s);\n   f = (1.0+sin(uv.x*3.0))*0.4+0.1, \n   d = f - abs(fract(t*r) - .5)*2.,\n   s = smoothstep(0., .05/max(d + .5, 0.), d + .1);    \n   O = vec4(sqrt(s));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVBRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 506]], "test": "valid"}
{"id": "ldyBzz", "name": "Very fast 2D Mist / fog", "author": "Lovax", "description": ".", "tags": ["mist"], "likes": 1, "viewed": 128, "published": "Public", "date": "1527431568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DPI 6.28318530718\n\n// Amplitude coefficients\n#define CA 0.31 \n#define CB 0.3\n#define CC 0.2\n#define CD 0.10\n\n// Phase modulating wave\nfloat wave(float x, float t) {\n    return CA*sin(1.8*x-(t*0.2))\n        + CB*sin(2.0*x+(t*0.4))\n        + CC*sin(2.8*x-t)\n        + CD*sin(5.6*x-t);\n}\n\n// One horizontal wave, one diagonal bl - tr wave summed\nfloat s(float x, float t) {\n    float w = wave(x * DPI, t);\n \t// simplified (w/(2*coeff sum) + (w+x)/(2*(coeff sum + 1)) + 1)/2.0;\n    return 0.4520302392*w + 0.1773049646*x + 0.5;\n}\n\n\n// Smooth the function to plot on the y axis\nfloat ssmooth(vec2 uv, float t) {\n    float y = s(uv.x, t);\n    return smoothstep( y-0.8, y, uv.y) - \n          smoothstep( y, y+0.8, uv.y);\n}\n\n// Rotation matrix\nmat2 rot(float alpha) {\n    float ca = cos(alpha);\n    float sa = sin(alpha);\n\treturn mat2(ca, -sa,\n                sa, ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    uv = rot(DPI*iTime/100.0) * (uv - vec2(0.5)) + vec2(0.5);\n    float c = ssmooth(uv, iTime);\n    //c = clamp(c, 0.0,0.3)+0.5;\n    vec4 fog = vec4(c,c-0.05,c-0.05,1.0);\n    fragColor = mix(tex, fog, 0.6);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyBzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 142, 172, 172, 292], [294, 351, 378, 378, 533], [536, 581, 614, 614, 723], [725, 744, 767, 767, 870], [872, 872, 929, 929, 1222]], "test": "error"}
{"id": "ldyfRh", "name": "Crossing Cross", "author": "AlphaRogue", "description": "Dark on bright or bright on dark ?", "tags": ["2d", "cross"], "likes": 8, "viewed": 214, "published": "Public", "date": "1527683839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define I 6.\n#define BLUE vec4(.11, .15, .2, 1.)\n#define WHITE vec4(1., .98, .9, 1.)\n\nfloat crosses (vec2 pos, float speed, bool back, bool still){\n    float angle;\n    vec2 crrt;\n    \n    float temp;\n    float rtn;\n    vec2 i = vec2(0.);\n    \n    for(float x = 0.; x > -10.; x--){\n        for(float y = 0.; y > -8.; y--){\n            crrt = pos + I * vec2(x, y) + i;\n            \n            temp = (I * x - 2. * y) / -100.;\n            \n            if (mod(speed + temp + (back ? 1.: 0.), 2.) < 1.) rtn = -1.;\n            else {\n                angle = max(0., mod(speed + temp - (back ? 1. : 0.), 1.) - .5) * PI * (back ? -1. : 1.);\n                if (!still) crrt *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n                rtn = 1.;\n            }\n            \n            if (abs(crrt.x) < 1. && abs(crrt.y) < 3. || abs(crrt.x) < 3. && abs(crrt.y) < 1.) return rtn;\n            i.x += 2.;\n        }\n        i = vec2(0., i.y - 2.);\n    }\n    return 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 lM = vec2(max(iResolution.x, iResolution.y), min(iResolution.x, iResolution.y));\n    vec2 pos = (fragCoord -.5 * lM) / lM.x;\n    float speed = iTime * .4;\n    pos = pos / .02 + vec2(18.,26.);\n    \n    float crossed = crosses(pos, speed, false, false);    \n    if (crossed != 0.) fragColor = BLUE;\n    if (crossed != 1.){\n        if (crosses(pos + vec2(2., 4.), speed, true, false) != 0.) fragColor = WHITE;\n        else if (crossed == 0.) fragColor = crosses(pos, speed, false, true) == 1. ? WHITE : BLUE;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 169, 169, 992], [994, 994, 1049, 1049, 1572]], "test": "valid"}
{"id": "ldyfzD", "name": "Kaleido lights", "author": "NuSan", "description": "Hypnotic patterns with lights and mirrors", "tags": ["2d"], "likes": 21, "viewed": 594, "published": "Public", "date": "1527777631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define KALEIDO 1\n#define LIGHTCOUNT 100\n\n#define v2Resolution iResolution\n#define out_color fragColor\n#define time iTime\n\n#define pi 3.141592\n\n\nvec2 r2(vec2 uv) {\n  return fract(sin(uv*vec2(1236.512,2975.233)+uv.yx*vec2(4327.135,6439.123)+vec2(1234.93,1347.367))*vec2(4213.523744,974.93242));\n}\n\nvec2 r2(int i) {\n  return fract(sin(float(i)*vec2(1236.512,2975.233)+vec2(1234.93,1347.367))*vec2(4213.523744,974.93242));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec2 mir(vec2 uv, float a) {\n\n  mat2 ra=rot(a);\n  uv *= ra;\n  uv.y=abs(uv.y);\n  uv *= ra;\n\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / v2Resolution.x, fragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  float mt=time*0.2;\n#if KALEIDO\n  uv = mir(uv, mt*0.2);\n  uv = mir(uv, -mt*0.4);\n  uv = mir(uv, mt*0.6);\n  uv = mir(uv, -mt*0.9);\n#endif\n\n  float ht=time*0.2;\n  uv += abs(vec2(sin(ht),cos(ht)))*(sin(time*0.3)*0.5+0.5)*0.3;\n\n  vec3 tcol=mix(vec3(0.8,0.2,0.2),vec3(0.2,0.8,0.9),sin(1234.12134+time*vec3(0.5,1.3,2.8)));\n  float pt=time*0.1;\n  float pulse = abs(fract(pt*floor(abs(fract(pt*4.0)*4.0-0.5)*2.0))-0.5)*2.0;\n\n  float st=time*0.2;\n\n  float d=10000.0;\n  vec3 col = vec3(0);\n  for(int i=0; i<LIGHTCOUNT; ++i) {\n\n    vec2 rr=r2(i*10);\n    float a=rr.x*pi*2.0 + st + sin(st*0.6+rr.y)*1.3 + sin(st*0.2+rr.y)*0.6;\n    vec2 p = uv+(r2(i)-0.5)*0.5 + vec2(cos(a),sin(a))*0.2;\n    float lp=length(p);\n    d=min(d,lp-0.01);\n\n    vec3 lcol=mix(vec3(0.8,0.2,0.2),vec3(0.2,0.8,0.9),sin(rr.y*100.0*vec3(0.5,1.3,2.8)));\n    lcol = mix(lcol,tcol,pulse);\n    float bd = 0.0015/lp;\n    col += lcol*bd;\n\n  }\n\n  //col = vec3(0.003)/max(0.001,d);\n  float gt=time*0.2;\n  vec3 lcol=mix(vec3(0.8,0.2,0.2),vec3(0.2,0.8,0.9),sin(time*vec3(0.5,1.3,2.8)));\n  col += abs(fract(gt*floor(abs(fract(gt*4.0)*4.0)-0.5)*2.0)-0.5)*2.0*lcol*pow(abs(fract(d*30.0-time*1.0)-0.5)*2.0,8.0)*max(0.0,0.6 / length(uv)-0.9);\n\n  out_color = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 163, 163, 295], [297, 297, 313, 313, 421], [423, 423, 442, 442, 511], [513, 513, 541, 541, 618], [620, 620, 677, 677, 2036]], "test": "valid"}
{"id": "ls3BD2", "name": "beach ballz", "author": "spenot", "description": "beach ballz", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 110, "published": "Public", "date": "1526741170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nconst vec3 ballColors[6] = vec3[6]( vec3(0.0, 0.0, 1.0),\n                         \t\t\tvec3(0.0, 1.0, 0.0),\n                         \t\t\tvec3(0.0, 1.0, 1.0),\n                         \t\t\tvec3(1.0, 0.0, 0.0),\n                         \t\t\tvec3(1.0, 0.0, 1.0),\n                         \t\t\tvec3(1.0, 1.0, 0.0) );\n\nfloat seaLevel(vec3 position) {\n    return (sin((position.x + iTime * 1.3) * 3.0) * 0.111 +\n            sin((position.z + iTime * 1.5) * 2.0) * 0.23 +\n            cos((position.x - iTime * 0.7) * 2.2) * 0.14 +\n            cos((position.z - iTime * 1.3) * 1.4) * 0.3) * 0.10;\n}\n\nfloat scene(out vec3 color, out float reflectivity, vec3 rayPosition) {\n    float sceneDistance = 1.0 / 0.0;\n    \n    float floorSeaLevel = seaLevel(rayPosition);\n    float floorDistance = rayPosition.y - (floorSeaLevel - 1.0);\n    if (floorDistance < sceneDistance) {\n        sceneDistance = floorDistance;\n        color = vec3(0.3, 0.7, 0.9);\n        reflectivity = 0.1;\n    }\n    \n    for (int i = 0; i < 6; ++i) {\n        float degree = (2.0 * M_PI) / float(6) * float(i);\n\t    vec3 ballPosition = vec3(2.0 * cos(-iTime*0.2 + degree), -0.6, 6.0 + 2.0 * sin(-iTime*0.2 + degree));\n\t    ballPosition.y += seaLevel(ballPosition);\n\t    float ballDistance = distance(rayPosition, ballPosition) - 0.7;\n\t    if (ballDistance < sceneDistance) {\n    \t    sceneDistance = ballDistance;\n            color = ballColors[i];\n\t        reflectivity = 0.1;\n        }\n    }\n    \n    return sceneDistance;\n}\n\nfloat scene(vec3 rayPosition) {\n    vec3 color;\n    float reflectivity;\n    return scene(color, reflectivity, rayPosition);\n}\n\nvec3 surfaceNormal(vec3 p) { // ray position\n    float e = 0.0001;\n    return normalize(vec3(scene(vec3(p.x+e, p.y, p.z)) - scene(vec3(p.x-e, p.y, p.z)),\n                          scene(vec3(p.x, p.y+e, p.z)) - scene(vec3(p.x, p.y-e, p.z)),\n                          scene(vec3(p.x, p.y, p.z+e)) - scene(vec3(p.x, p.y, p.z-e))));\n}\n\nfloat shadow(vec3 rayPosition, vec3 lightPosition, vec3 surfaceNormal) {\n    const int maxSteps = 256;\n    \n    vec3 rayDirection = normalize(lightPosition - rayPosition);\n    float distanceLeft = distance(lightPosition, rayPosition);\n    \n    rayPosition += rayDirection * 0.2;\n    \n    for (int i = 0; i < maxSteps; ++i) {\n        float sceneDistance = scene(rayPosition);\n        if (sceneDistance < 0.001) {\n            return 0.7;\n        }\n        rayPosition += rayDirection * sceneDistance;\n        distanceLeft -= sceneDistance;\n        if (distanceLeft <= 0.0) {\n            break;\n        }\n    }\n    \n    return 1.0;\n}\n\nvec4 reflection(vec3 rayPosition, vec3 rayDirection, vec3 lightPosition, vec3 sceneSurfaceNormal) {\n    const int maxSteps = 100;\n    \n    rayDirection = reflect(rayDirection, sceneSurfaceNormal);\n    \n    rayPosition += rayDirection * 0.001;\n    \n    for (int i = 0; i < maxSteps; ++i) {\n        vec3 sceneColor;\n        float reflectivity;\n        float sceneDistance = scene(sceneColor, reflectivity, rayPosition);\n        if (sceneDistance < 0.001) {\n            vec3 reflectionSurfaceNormal = surfaceNormal(rayPosition);\n\t\t    vec3 lightDirection = normalize(lightPosition - rayPosition);\n            vec3 shadowColor = vec3(shadow(rayPosition, lightPosition, reflectionSurfaceNormal));\n            sceneColor *= vec3(0.0 + 1.0 * dot(reflectionSurfaceNormal, lightDirection));\n            sceneColor *= shadowColor;\n            return vec4(sceneColor, 1.0);\n        }\n        rayPosition += rayDirection * sceneDistance;\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int maxSteps = 2048;\n    \n\tvec2 screenPosition = fragCoord / iResolution.xy - vec2(0.5);\n\tscreenPosition.x *= iResolution.x / iResolution.y;\n    \n    const float cameraDistance = 1.0;\n    \n    vec3 rayPosition = vec3(0.0);\n//    vec3 rayPosition = vec3(sin(iTime/8.0)*10.0, 0.0, 0.0);\n//    vec3 rayPosition = vec3(0.0, 0.0, sin(iTime/8.0)*9.0);\n    \n    vec3 rayDirection = normalize(vec3(screenPosition, cameraDistance));\n    \n    const vec3 backgroundColor = vec3(0.0, 1.0, 0.0);//vec3(1.0, 0.01, 0.35);\n    \n    vec3 lightPosition = vec3(5.0, 2.3, -3.0);\n//    vec3 lightPosition = vec3(sin(iTime/2.0)*8.2, 2.3, 4.0 + cos(iTime/2.0)*8.2);\n    \n    vec3 skyColor = vec3(0.3, 0.5, 0.7);\n    vec3 color = mix(vec3(1.0), skyColor, screenPosition.y + .6);\n    \n    if (screenPosition.y < 0.2)\n    {\n    for (int i = 0; i < maxSteps; ++i) {\n        vec3 sceneColor;\n        float reflectivity;\n        float sceneDistance = scene(sceneColor, reflectivity, rayPosition);\n        if (sceneDistance < 0.001) {\n            vec3 surfaceNormal = surfaceNormal(rayPosition);\n\t\t    vec3 lightDirection = normalize(lightPosition - rayPosition);\n            vec3 shadowColor = vec3(shadow(rayPosition, lightPosition, surfaceNormal));\n            color = sceneColor;\n            color *= vec3(0.0 + 1.0 * dot(surfaceNormal, lightDirection));\n            color *= shadowColor;\n            if (reflectivity > 0.0) {\n\t            vec4 reflectionColor = reflection(rayPosition, rayDirection, lightPosition, surfaceNormal);\n\t            color = mix(color, reflectionColor.rgb, reflectionColor.a * reflectivity);\n            }\n            \n//            color = rayPosition;\n//            color = vec3(rayPosition.x / 5.0);\n//            color = vec3(rayPosition.z / 15.0);\n//            color = vec3(float(i) / float(maxSteps));\n//            color = vec3(distance(vec3(0.0), rayPosition) / 15.0);\n            \n            break;\n        }\n        rayPosition += rayDirection * sceneDistance;\n        if (rayPosition.z > 55.0) {\n            break;\n        }\n    }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3BD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 384, 384, 629], [631, 631, 702, 702, 1523], [1525, 1525, 1556, 1556, 1650], [1652, 1652, 1680, 1696, 1983], [1985, 1985, 2057, 2057, 2615], [2617, 2617, 2716, 2716, 3572], [3574, 3574, 3631, 3631, 5733]], "test": "valid"}
{"id": "ls3BWf", "name": "Weird Raspberry", "author": "Moumou38", "description": "I don't know where this was supposed to go, kinda of an impro, trying to manipulate Voronoi. I which I could have done more, I need to learn more. I wanted to make some kind of blurred light flows coming out of the \"cracks\", I don't know how.", "tags": ["voronoi", "raspberry"], "likes": 8, "viewed": 261, "published": "Public", "date": "1527076459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by Monia A. (Moumou38) - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 15.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159;\n\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZ(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 scale(float a ) {\n    return mat4(\n        a,0, 0, 0,\n        0, a, 0, 0,\n        0, 0, a, 0,\n        0, 0, 0, 1\n    );\n}\n\nfloat sdSphere( vec3 p, float s)\n{\n  \n  return length(p)-s;\n}\n\n\nfloat rand_1_05(in vec2 uv)\n{\n    float noise = (fract(sin(dot(uv ,vec2(12.9898,78.233)*2.0)) * 43758.5453));\n    return noise;\n}\t\n\n\n// Voronoi from iq\nvec3 Voronoi( in vec3 x )\n{\n    x.y *= 15. * (1.+ cos(iTime)/15.); // scale of my voronoi\n    x.x *= 15. * (1.- sin(iTime)/10.); \n    \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 1.;\n    vec2 res = vec2( .8 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + rand_1_05( 10.*vec2(p + b) );\n\n\n        float d = dot( r, r ) ;\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            \n            res = vec2( d, res.x );\n\n            \n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( res, abs(id));\n}\n\n\n// Sphere uv mapping from aiekick : https://www.shadertoy.com/view/MtS3DD\nvec3 sphere_map(vec3 p)\n{\n    vec2 uv;\n    uv.x = 1. + atan(p.z, p.x) / (2.*3.14159);\n    uv.y = 1. - asin(p.y) / 3.14159;\n    return Voronoi(vec3(uv,0.0));\n}\n\n\nfloat map(vec3 originPos)\n{\n    vec3 ret = sphere_map(normalize(originPos));\n\treturn length(originPos) - 1. - .5*ret.x * (-.5) * (.5+sin(iTime)/5.) ; //*(sin(iTime)/2.-2.);  // peaks variation   \n}\n\nfloat trace(vec3 o, vec3 r)\n{\n float t= 0.0;\n    for(int i=0; i< 45; ++i) // for number of iteration\n    {\n    \tvec3 p = o + r*t; // until we find intersection\n        float d = map(p);\n        if (d < EPSILON) break;\n        t += d ; // advancing on ray\n    }\n    return t;\n        \n}\n\nfloat applyFog( float b ) \n{\n    return pow(1.0 / (1.0 + b), 1.0);;\n}\n\nvec3 estimateNormal(vec3 p) \n{ float d = map(p); \n return normalize(vec3( map(vec3(p.x + EPSILON, p.y, p.z)), map(vec3(p.x, p.y + EPSILON, p.z)), map(vec3(p.x, p.y, p.z + EPSILON)) ) - d); \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3( 0.0, 0.0, -3.0 );      \n    vec3 rd = normalize(vec3(uv,3.0)) ; // normalized so it does not poke geometry close to camera\n    float t = trace(ro, rd); // distance\n\tvec3 intersection = ro + rd * t;     \n    vec3 vNormal = estimateNormal(intersection);\n    \n    vec3 col = vec3(0.2);\n\tif(t < MAX_DIST)\n    {\n        // Determine light direction \n        vec3 ld = intersection - ro; // where the camera is (?)        \n        ld = normalize(ld);\n\n        // Spec\n        float spec = pow(max(dot( reflect(-ld, vNormal), -rd), 0.), 16.); \n      \tcol *= sqrt( spec  * vec3(10.,10.0,10.0));\n        col += sphere_map(normalize(intersection)) * vec3(1.,0.001,0.00005) * (1.+sin(iTime)/2.);\n\n    }\n    else // background\n    {\n     \tcol = vec3(0.2);\n\n\n        vec3 light_color = vec3(0.9, 0., 0.1);\n        float light = .0;\n\n        light = (1.+cos(iTime)/10.)*0.1 / distance(normalize(uv)*(1.+cos(iTime)/5.)*0.68, uv);\n\n        col+= light * light_color;\n    }\n\t\n\t\n\tcol = sqrt( col ) ;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3BWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 245, 272, 272, 455], [457, 457, 484, 484, 667], [669, 669, 693, 693, 846], [848, 848, 870, 870, 974], [976, 976, 1010, 1010, 1037], [1040, 1040, 1069, 1069, 1169], [1173, 1192, 1219, 1219, 1935], [1938, 2012, 2037, 2037, 2170], [2173, 2173, 2200, 2200, 2370], [2372, 2372, 2401, 2401, 2657], [2659, 2659, 2687, 2687, 2728], [2730, 2730, 2760, 2760, 2921], [2924, 2924, 2981, 3031, 4200]], "test": "valid"}
{"id": "ls3BWN", "name": "SoftNoise test", "author": "paulbaron", "description": "test noise 3d", "tags": ["noise3d"], "likes": 1, "viewed": 114, "published": "Public", "date": "1525263340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define X_NOISE_GEN 1619\n#define Y_NOISE_GEN 31337\n#define Z_NOISE_GEN 6971\n#define SEED_NOISE_GEN 6971\n\nint \tIntValueNoise3D(ivec3 position, int seed)\n{\n    // All constants are primes and must remain prime in order for this noise\n    // function to work correctly.\n    int n = (\n        X_NOISE_GEN    * position.x\n      + Y_NOISE_GEN    * position.y\n      + Z_NOISE_GEN    * position.z\n      + SEED_NOISE_GEN * seed)\n      & 0x7fffffff;\n\n    n = (n >> 13) ^ n;\n    int noise = (n * (n * n * 60493 + 19990303) + 1376312589) & 0x7fffffff;\n    return noise;\n}\n\nfloat valueNoise3D(vec3 position, int seed)\n{\n    ivec3 \tiPosition = ivec3(floor(position));\n\n    float \tcurCellNoise = float(IntValueNoise3D(iPosition, seed)) / 1073741824.0 * 0.5f;\n\n    ivec3 \tiClosest = ivec3(position + normalize(fract(position) - vec3(0.5f)));\n    \n    float \tclosestNoise = float(IntValueNoise3D(iClosest, seed)) / 1073741824.0 * 0.5f;\n    \n    vec3 \tcurCellCenter = vec3(iPosition) + vec3(0.5f);\n    vec3 \tclosestCellCenter = vec3(iClosest) + vec3(0.5f);\n    \n    float \tdistToCur = distance(curCellCenter, position);\n    float \tdistToClosest = distance(closestCellCenter, position);\n    \n\n    float \tclosestInfluence;\n    float \tcurInfluence;\n\t\n    if (distToCur < distToClosest)\n    {\n\t    closestInfluence = distToCur / distToClosest;\n    \tcurInfluence = 1.0f - closestInfluence;\n    }\n    else\n    {\n\t    curInfluence = distToClosest / distToCur;\n    \tclosestInfluence = 1.0f - curInfluence;\n    }\n    \n\tfloat noise = curInfluence * curCellNoise + closestInfluence * closestNoise;\n\n    return noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(valueNoise3D(vec3(uv * 20.0f + 5.0f, iTime * 1.0f), 156846), 0, 0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ls3BWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 154, 267, 560], [562, 562, 607, 607, 1590], [1592, 1592, 1649, 1699, 1859]], "test": "valid"}
{"id": "lscBRB", "name": "Ozymandias Redux", "author": "dr2", "description": "Just like the poem, but more... (mouse to look around)", "tags": ["terrain", "android", "desert", "poetry"], "likes": 7, "viewed": 464, "published": "Public API", "date": "1525690083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ozymandias Redux\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nmat3 QtToRMat (vec4 q);\nvec4 EulToQt (vec3 e);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2s (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 orMat;\nvec4 dateCur;\nvec3 sunDir, qHit, rPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize, rAngA, gFac, hFac, fWav, aWav, szFac;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * fWav;\n  q = gFac * p;\n  wAmp = 4. * hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd, float dstMax)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0. || s > dstMax) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId * hgSize);\n  p -= rPos;\n  p = orMat * p;\n  p /= szFac;\n  dMin /= szFac;\n  p.yz = p.zy;\n  p.z -= -1.6;\n  q = p;  q.z -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.z - 0.2);\n  q = p;  q.z -= 1.55;\n  d = min (d, PrRoundCylDf (q, 0.9, 0.28, 0.7));\n  DMINQ (1);\n  q = p;  q.y = abs (q.y) - 0.3;  q.z -= 3.1;\n  q.yz = Rot2D (q.yz, 0.2 * pi);\n  q.z -= 0.25;\n  d = PrRoundCylDf (q, 0.06, 0.04, 0.3);\n  DMINQ (1);\n  q = p;  q.y = abs (q.y) - 1.08;  q.z -= 2.;\n  q.zx = Rot2D (q.zx, rAngA);\n  q.z -= -0.5;\n  d = PrRoundCylDf (q, 0.2, 0.15, 0.6);\n  DMINQ (1);\n  q = p;  q.y = abs (q.y) - 0.4;  q.z -= 0.475;\n  d = PrRoundCylDf (q, 0.25, 0.15, 0.55);\n  DMINQ (1);\n  q = p;  q.y = abs (q.y) - 0.4;  q.zx -= vec2 (2.7, 0.7);\n  d = PrSphDf (q, 0.15);\n  DMINQ (2);\n  dMin *= szFac;\n  return dMin;\n}\n\nvoid SetGrdConf ()\n{\n  vec4 h4;\n  float a, phi, theta, psi;\n  h4 = Hashv4v2 (17.1 * gId + 0.3);\n  a = smoothstep (-0.7, 0.7, 2. * h4.x - 1.);\n  psi = pi * (a - 0.5);\n  a = h4.y - 0.5;\n  theta = 0.2 * pi * tCur * max (0.2, abs (a)) * sign (a);\n  phi = 0.5 * pi * (2. * step (0.5, h4.z) - 1.);\n  orMat = QtToRMat (EulToQt (vec3 (phi, theta, psi)));\n  rAngA = pi * h4.w;\n  a = 2. * pi * (h4.x + h4.y);\n  rPos.xz = 0.5 * hgSize * sin (a + vec2 (0.5 * pi, 0.));\n  szFac = 1.2 - 0.2 * (h4.z + h4.w);\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz) + 0.1 * sign (phi) * sign (psi);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + 0.001;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = 0; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += min (0.05, 3. * h);\n    if (h < 0.005) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2s (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2s (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2s (0.1 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nfloat ObjGrndMix (vec3 p)\n{\n  gId = PixToHex (p.xz / hgSize);\n  SetGrdConf ();\n  return smoothstep (1., 1.3, length (p.xz - HexToPix (gId * hgSize) - rPos.xz) / szFac);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dstGrnd, dstObj, sh, spec, f, dFac;\n  bool isBg;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd, dstObj);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    dFac = 1. - smoothstep (0.15, 0.35, min (dstObj, dstGrnd) / dstFar);\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      gId = PixToHex (ro.xz / hgSize);\n      vn = ObjNf (ro);\n      if (idObj == 1) vn = VaryNf (8. * qHit.xzy, orMat * vn, 4. * dFac) * orMat;\n      col = vec3 (0.7, 0.75, 0.8);\n      spec = (idObj == 2) ? 0.2 : 0.05;\n      sh = 1.;\n    } else {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.9, 0.7, 0.4), smoothstep (1., 3., ro.y));\n      col *= 1. - 0.3 * dFac * Fbm2s (128. * ro.xz);\n      if (dFac > 0. && vn.y > 0.85) {\n        f = smoothstep (0.5, 2., ro.y) * smoothstep (0.85, 0.9, vn.y) * dFac;\n        vn4 = RippleNorm (ro.xz, vn, 8. * f * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n        vn = vn4.xyz;\n        col *= mix (1., 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w), f);\n      }\n      if (dFac > 0.) {\n        f = ObjGrndMix (ro);\n        vn = VaryNf (8. * ro, vn, dFac * (3. - 2. * f));\n        col *= 0.8 + 0.2 * f;\n      }\n      spec = 0.01;\n      sh = ObjSShadow (ro, sunDir);\n    }\n    sh = min (sh, 1. - 0.5 * smoothstep (0.3, 0.7, Fbm2s (0.05 * ro.xz - tCur * vec2 (0.15, 0.))));\n    col *= 0.2 + sh * (0.1 * vn.y + 0.7 * max (0., dot (vn, sunDir)) +\n       0.1 * max (0., dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy)) +\n       spec * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n    col *= 0.7 + 0.3 * dFac;\n    col = mix (col, SkyBg (rd), pow (min (dstObj, dstGrnd) / dstFar, 4.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (2. * (v.z * a.x - v.x * a.z), -0.2 * pi, 0.2 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv, uvv, ori, ca, sa;\n  float el, az, sunEl, sunAz, dt, flyVel, mvTot, hSum, nhSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  }\n  hgSize = 10.;\n  gFac = 0.07;\n  hFac = 1.3;\n  fWav = 1.9;\n  aWav = 0.45;\n  flyVel = 3.;\n  dstFar = 150.;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  mvTot = flyVel * tCur;\n  ro = TrackPath (mvTot);\n  dt = 1.;\n  fpF = TrackPath (mvTot + dt);\n  fpB = TrackPath (mvTot - dt);\n  flMat = EvalOri ((fpF - fpB) / (2. * dt), (fpF - 2. * ro + fpB) / (dt * dt));\n  hSum = 0.;\n  nhSum = 0.;\n  for (float fk = -1.; fk <= 5.; fk ++) {\n    hSum += GrndHt (TrackPath (mvTot + 0.5 * fk).xz);\n    ++ nhSum;\n  }\n  ro.y = 8. * hFac + hSum / nhSum;\n  sunAz = 0.01 * 2. * pi * tCur;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunAz) * cos (sunEl), sin (sunEl), sin (sunAz) * cos (sunEl));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.), 0.5 * pi * (a + 0.5));\n    rd = normalize (vec3 (uvv, 2.5));\n    rd = vuMat * rd;\n    rd = flMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p, cHashVA2), dot (p + e.xy, cHashVA2),\n     dot (p + e.yx, cHashVA2), dot (p + e.xx, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscBRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 718, 741, 741, 985], [987, 987, 1035, 1035, 1515], [1517, 1517, 1539, 1539, 1678], [1751, 1751, 1773, 1773, 2620], [2622, 2622, 2642, 2642, 3204], [3206, 3206, 3239, 3239, 4520], [4522, 4522, 4543, 4543, 4743], [4745, 4745, 4782, 4782, 5205], [5207, 5207, 5232, 5232, 5613], [5615, 5615, 5659, 5659, 5853], [5855, 5855, 5877, 5877, 5971], [5973, 5973, 6005, 6005, 6335], [6337, 6337, 6364, 6364, 6507], [6509, 6509, 6544, 6544, 8300], [8302, 8302, 8333, 8333, 8602], [8604, 8604, 8630, 8630, 8743], [8745, 8745, 8801, 8801, 10569], [10571, 10571, 10604, 10604, 10631], [10633, 10633, 10690, 10690, 10854], [10856, 10856, 10878, 10878, 10916], [10918, 10918, 10942, 10942, 11172], [11174, 11174, 11198, 11198, 11258], [11260, 11260, 11290, 11290, 11403], [11405, 11405, 11430, 11430, 11826], [11828, 11828, 11851, 11851, 12075], [12109, 12109, 12133, 12133, 12263], [12265, 12265, 12289, 12289, 12492], [12494, 12494, 12519, 12519, 12705], [12707, 12707, 12728, 12728, 12883], [12885, 12885, 12907, 12907, 13060], [13062, 13062, 13091, 13091, 13303], [13305, 13305, 13344, 13344, 13524]], "test": "error"}
{"id": "lscBRf", "name": "Rainbow Showoff", "author": "akufishi", "description": "silly stuff", "tags": ["2d", "rainbow"], "likes": 31, "viewed": 10732, "published": "Public API", "date": "1526122579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FALLING_SPEED  0.25\n#define STRIPES_FACTOR 5.0\n\n//get sphere\nfloat sphere(vec2 coord, vec2 pos, float r) {\n    vec2 d = pos - coord; \n    return smoothstep(60.0, 0.0, dot(d, d) - r * r);\n}\n\n//main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalize pixel coordinates\n    vec2 uv         = fragCoord / iResolution.xy;\n    //pixellize uv\n    vec2 clamped_uv = (round(fragCoord / STRIPES_FACTOR) * STRIPES_FACTOR) / iResolution.xy;\n    //get pseudo-random value for stripe height\n    float value\t\t= fract(sin(clamped_uv.x) * 43758.5453123);\n    //create stripes\n    vec3 col        = vec3(1.0 - mod(uv.y * 0.5 + (iTime * (FALLING_SPEED + value / 5.0)) + value, 0.5));\n    //add color\n         col       *= clamp(cos(iTime * 2.0 + uv.xyx + vec3(0, 2, 4)), 0.0, 1.0);\n    //add glowing ends\n    \t col \t   += vec3(sphere(fragCoord, \n                                  vec2(clamped_uv.x, (1.0 - 2.0 * mod((iTime * (FALLING_SPEED + value / 5.0)) + value, 0.5))) * iResolution.xy, \n                                  0.9)) / 2.0; \n    //add screen fade\n         col       *= vec3(exp(-pow(abs(uv.y - 0.5), 6.0) / pow(2.0 * 0.05, 2.0)));\n    // Output to screen\n    fragColor       = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscBRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 69, 114, 114, 196], [198, 205, 262, 296, 1218]], "test": "valid"}
{"id": "lscBRS", "name": "Vintage is the new sexy", "author": "Flopine", "description": "Having fun with 2D techniques :D ", "tags": ["2d", "pixels", "rotozoom"], "likes": 3, "viewed": 138, "published": "Public", "date": "1525636390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, XT95, lamogui for teaching me :) <3\n\n#define PI 3.141592\n\nmat2 rot (float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat poumpoum (float time)\n{\n    return exp(-fract(time));\n}\n\n/////////////////////////// 2D\nfloat line (float uv, float height)\n{\n    return step(height,abs(uv));\n}\n\nfloat circle (vec2 uv, float r)\n{\n    return smoothstep(0.1,0.11, length(uv)-r);\n}\n\nfloat prim1 (vec2 uv)\n{\n    uv *= 2.;\n    return (line(uv.y, 0.04)*line(uv.x, 0.04) - circle(uv,0.3));\n}\n\nfloat layer1 (vec2 uv)\n{\n    float per = .2;\n    uv *= rot(PI/4.);\n    uv = mod(uv-per/2.,per)-per/2.;\n\n    return prim1(uv);\n}\n\nfloat layer2 (vec2 uv)\n{\n    float per = 0.5  - (uv.y*0.2);\n    uv = mod(uv-per/2.,per)-per/2.;\n    float l = layer1(uv);\n    return l*circle(uv,0.05*poumpoum(iTime));\n}\n\n///////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float power = 60.* (1./poumpoum(iTime));\n    uv = floor(uv*power)/power;\n\n    uv *= rot(iTime+poumpoum(iTime));\n    \n    uv *= sin(iTime/0.8)+1.5;\n    \n    uv = vec2(layer2(uv*1.5))*vec2(0.5,abs(uv.y-0.5)-0.3);\n\t\n    \n    // Output to screen\n    fragColor = vec4(uv,0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 113, 133, 133, 182], [184, 184, 213, 213, 245], [247, 278, 315, 315, 350], [352, 352, 385, 385, 434], [436, 436, 459, 459, 540], [542, 542, 566, 566, 669], [671, 671, 695, 695, 840], [842, 876, 933, 983, 1365]], "test": "valid"}
{"id": "lscfDs", "name": "Wiggle wiggle", "author": "frostbytes89", "description": "just a little bit", "tags": ["rotation"], "likes": 1, "viewed": 186, "published": "Public", "date": "1527206470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat box(in vec2 uv, in vec2 size)\n{\n    //size = vec2(0.5) - size * 0.5;\n   // vec2 uv = smoothstep(size,\n    //                    size + vec2(1. / iResolution.y),\n   //                    st);\n   // uv *= smoothstep(size,\n    //                size + vec2(1. / iResolution.y),\n    //                vec2(1.0) - st);\n    \n    uv = smoothstep(0., -1.5/iResolution.y, abs(uv - .5) - size);\n    return uv.x * uv.y;\n}\n\n//------------------------------------------------------------------------------\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat getPulseWave()\n{\n    float test = (sin(iTime/.5) * 2.) - 10000. * .5 ;\n    return test;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // move space from the center to the vec2(0.0)\n    uv -= .5;\n    \n\tfloat angle = 2.53;\n    float radians = (PI / 180.) * angle;\n    \n    // rotate the space\n    uv = (rotate2d( cos(getPulseWave()/.1) * radians )) * uv;        \n\n    \n    // move it back to the original place\n    uv += .5;\n    \n    // To move the cross we move the space\n    vec2 translate = vec2(cos(0.0),sin(iTime/.1));\n    uv += translate * -0.010 ;\n    \n    // Add the shape on the foreground\n    color += vec3( box(uv, vec2(.4)));\n\n    // Output to screen\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lscfDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 63, 345, 442], [444, 526, 554, 554, 638], [640, 640, 662, 662, 735], [737, 737, 794, 844, 1483]], "test": "valid"}
{"id": "lsdBW2", "name": "Dragon Curve 3D", "author": "BenDrews", "description": "Partial extension of the Dragon Curve into 3D. ", "tags": ["fractal"], "likes": 2, "viewed": 159, "published": "Public", "date": "1526861148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Ben Drews\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// 3D extenstion of the Dragon Curve.\n//\n// Raymarching skeleton taken from iq's shader \"Apollonian\"\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nfloat longTime = 20.0;\nvec3 far = vec3(10.0);\nfloat maxIters = 5.0;\nint iters = 12;\n\nfloat invRt2 = 0.70710678118;\nfloat rng = 0.0;\nfloat random() {\n    rng += iTime;\n return fract(sin(rng)*1000000000.0);\n}\n\nvec3 orb;\nvec3 orb2;\n\nvoid getIPoints(vec3 p1, vec3 p2, inout vec3 n1, out vec3 p3, out vec3 p4, out vec3 n2, out vec3 n3) {\n \tfloat l = length(p2 - p1) * 0.57735026919;\n    vec3 b1 = normalize(n1 - p1);\n    vec3 i1 = normalize(p2 - n1);\n    vec3 i2 = cross(b1, i1);\n    vec3 i3 = cross(i1, b1);\n    vec3 b2 = invRt2 * (i1 + i2);\n    vec3 b3 = invRt2 * (i1 + i3);\n    \n    p3 = p1 + l*b1;\n    p4 = p3 + l*b2;\n    \n    n1 = p1 + (invRt2 * (b1 + (-invRt2 * (b2 + b3))));\n    n2 = p3 + (invRt2 * (b2 + (-invRt2 * (b1 + b3))));\n    n3 = p4 + (invRt2 * (b3 + (-invRt2 * (b1 + b2))));\n}\n\n\nfloat rayCylinder(vec3 X, float r, vec3 a, vec3 p2) {\n \tvec3 n = normalize(p2 - a);\n    vec3 toLine = (a - X) - (dot((a - X), n)*n);\n    if(length(X + toLine - ((a + p2)/2.0)) > 0.5*length(p2 - a)) return min(length(a-X) - r, length(p2-X) - r);\n    return length(toLine) - r;\n}\n\nvec3 normCylinder(vec3 X, float r, vec3 p1, vec3 p2) {\n   vec3 n = normalize(p2 - p1);\n   return normalize(-(p1 - X) + (dot((p1 - X), n)*n));\n}\n\nvoid chooseCylinder(vec3 X, float r, inout float t1, inout vec3 n, inout vec3 p1, inout vec3 p2, inout vec3 n1, vec3 p3, vec3 p4, inout vec3 n2, vec3 color) {\n    float t2 = rayCylinder(X, r, p3, p4);\n    if(t2 < t1) {\n     \tp1 = p3;\n        p2 = p4;\n        n1 = n2;\n        t1 = t2;\n        n = normCylinder(X, r, p1, p2);\n        orb2 = color;\n    }\n}\n\nvec3 o1 = vec3(0.0, -1.0, 0.0);\nvec3 o2 = vec3(2.0, 1.0, 2.0);\nvec3 o3 = vec3(0.0,-1.0, 2.0);\n\nfloat map( vec3 P, vec3 w, float s, inout vec3 n, inout int level)\n{\n    orb = vec3(0.0);\n    float t = longTime;\n    float r = 0.01;\n    vec3 p1 = o1;\n    vec3 p2 = o2;\n    vec3 p3 = vec3(0.0);\n    vec3 p4 = vec3(0.0);\n    vec3 n1 = o3;\n    vec3 n2 = vec3(0.0);\n    vec3 n3 = vec3(0.0);\n    vec3 r1 = p1;\n    vec3 r2 = p2;\n    getIPoints(p1, p2, n1, p3, p4, n2, n3);\n    for(int i=0; i<iters; i++) {\n        t = longTime;\n   \t    chooseCylinder(P, r, t, n, r1, r2, n, p1, p3, n1, 1.0/float(iters)*vec3(0.0, 0.0, 1.0));\n  \t\tchooseCylinder(P, r, t, n, r1, r2, n, p3, p4, n2, 1.0/float(iters)*vec3(0.0, 1.0, 0.0));\n        chooseCylinder(P, r, t, n, r1, r2, n, p4, p2, n3, 1.0/float(iters)*vec3(1.0, 0.0, 0.0));\n        p1 = r1;\n        p2 = r2;\n        n1 = n;\n        orb += orb2;\n        getIPoints(p1, p2, n1, p3, p4, n2, n3);\n    }\n    \n    return t;\n}\n\n\n//Ray marching\nfloat trace( in vec3 ro, in vec3 rd, float s, inout vec3 n)\n{\n    rd = normalize(rd);\n\tfloat maxd = longTime;\n    float t = 0.01;\n    int level = 0;\n    for( int i=0; i<100; i++)\n    {\n\t    float precis = 0.001 * t;\n\t    float h = map( ro+rd*t, rd, s, n, level);\n        if(t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd) t=-1.0;\n    return t;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float t = trace( ro, rd, anim, n);\n    if( t>0.0 )\n    {\n        vec3 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = n;\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(1.0,1.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.0,0.0), clamp(tra.x,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,1.0,0.0), clamp(tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,0.0,1.0), clamp(tra.z,0.0,1.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = maxIters * (1.0 + cos(0.2*iTime));\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n\n        // camera\n         vec2 mo = iMouse.xy/iResolution.xy;\n\t\t vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdBW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[217, 428, 444, 444, 502], [526, 526, 628, 628, 1084], [1087, 1087, 1140, 1140, 1364], [1366, 1366, 1420, 1420, 1509], [1511, 1511, 1669, 1669, 1865], [1962, 1962, 2030, 2030, 2817], [2820, 2835, 2896, 2896, 3187], [3189, 3189, 3243, 3257, 4281], [4283, 4283, 4335, 4335, 4512], [4514, 4514, 4571, 4571, 5401]], "test": "valid"}
{"id": "lsdBWs", "name": "Julia Set Rotator", "author": "Julius", "description": "Julia sets for f(z) = z^2+0.7885e^(i*t)", "tags": ["fractals"], "likes": 0, "viewed": 72, "published": "Public", "date": "1527287632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 complex_mul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    float time = iTime * .3;\n    \n    vec2 center = .7785 * vec2(cos(time), sin(time));\n    \n    float zoom = .35; \n    \n    vec2 z = (uv - vec2(.85, .5)) / zoom;\n    float iterations = 40.;\n    \n    bool is_out = false;\n    float i = 0.;\n    for(i=0.;i<iterations && !is_out;i++) {\n        z = complex_mul(z, z) + center;\n    \tis_out = length(z) > 2.;\n    }\n    \n    vec3 color = vec3(0,0,0);\n    if(is_out)\n        color = vec3(1, 1, 1) * i / float(iterations);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 102], [104, 104, 161, 161, 710]], "test": "valid"}
{"id": "lsdBzX", "name": "Spiral of Spirals 2", "author": "KilledByAPixel", "description": "Anther experiment with something like a Vogel spiral. Can produce some cool spiral patterns and mess with your vision after a while. Really interesting to watch how it continues to develop over time.\n\nmouse.x = skip ahead\nmouse.y = zoom", "tags": ["spiral", "sunflower", "vogel"], "likes": 21, "viewed": 6405, "published": "Public API", "date": "1526232902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Spiral of Spirals - Copyright 2018 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float pi = 3.14159265359;\n\nvec3 hsv2rgb(vec3 c)\n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv -= iResolution.xy / 2.0;\n    uv /= iResolution.x;\n   \n    vec4 mousePos = (iMouse.xyzw / iResolution.xyxy);\n \tuv *= 100.0;\n    if (mousePos.y > 0.0)\n    \tuv *= 4.0 * mousePos.y;\n    \n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    \n    // make spiral\n    float i = d;\n    float p = a/(2.0*pi) + 0.5;\n    i -= p;\n    a += 2.0*pi*floor(i);\n    \n    // change over time\n    float t = .05*(iTime +  400.0*mousePos.x);\n    //t = pow(t, 0.4);\n    \n    float h = 0.5*a;\n    h *= t;\n    //h *= 0.1*(floor(i)+p);\n    h = 0.5*(sin(h) + 1.0);\n    h = pow(h, 3.0);\n    h += 4.222*t + 0.4;\n    \n    float s = 2.0*a;\n    s *= t;\n    s = 0.5*(sin(s) + 1.0);\n    s = pow(s, 2.0);\n    \n    //float h = d*.01 + t*1.33;\n    //float s = sin(d*.1 + t*43.11);\n    //s = 0.5*(s + 1.0);\n    \n    // fixed size\n    a *= (floor(i)+p);\n    \n    // apply color\n    float v = a;\n    v *= t;\n    v = sin(v);\n    v = 0.5*(v + 1.0);\n    v = pow(v, 4.0);\n    v *= pow(sin(fract(i)*pi), 0.4); // darken edges\n    v *= min(d, 1.0); // dot in center\n    \n    //vec3 c = vec3(h, s, v);\n    vec3 c = vec3(h, s, v);\n\tfragColor = vec4(hsv2rgb(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsdBzX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 337, 359, 359, 499], [501, 501, 558, 558, 1719]], "test": "valid"}
{"id": "lstBDN", "name": "Fake Dynamic Clouds", "author": "nr4", "description": "2D multifreq smoothstep noise. Each frequency is shifted a little with time and frag coord to achieve the motion-like effect.", "tags": ["noise", "clouds", "smoothstep"], "likes": 1, "viewed": 118, "published": "Public", "date": "1525277137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Fake Dynamic Clouds\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1.,0.);\n\nfloat rand(vec2 a0)\n{\n    return -1.+2.*fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat smoothstep_noise(float x)\n{\n    float r1 = -1.+2.*rand(floor(x)*c.xx), r2 = -1.+2.*rand(ceil(x)*c.xx);\n    return mix(r1, r2, smoothstep(0., 1., fract(x)));\n}\n\nfloat mfsmoothstep_noise(float x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise(f*x) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nfloat smoothstep_noise2d(vec2 x)\n{\n    vec2 d = floor(x);\n    x = fract(x);\n    float x00 = rand(d),\n        x01 = rand(d+c.yx),\n        x10 = rand(d+c.xy), \n        x11 = rand(d+c.xx);\n    return mix(mix(x00, x01, smoothstep(0.,1., x.y)), mix(x10, x11, smoothstep(0.,1., x.y)), smoothstep(0.,1., x.x));\n}\n\nfloat mfsmoothstep_noise2d(vec2 x, float f0, float f1, float phi)\n{\n    float sum = 0.;\n    float a = 1.2;\n    \n    for(float f = f0; f<f1; f = f*2.)\n    {\n        sum = a*smoothstep_noise2d(f*x+.2*smoothstep_noise(5.e-1*iTime+1.e-1*length(x))*c.yx-5.e-1*iTime*c.xy) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\nmat3 rot(vec3 p)\n{\n    vec3 cp = cos(p), sp = sin(p);\n    mat3 m = mat3(cp.y*cp.x, cp.x*sp.z+cp.z*sp.x*sp.y, sp.x*sp.z-cp.x*cp.z*sp.y, \n           -cp.y*sp.z, cp.x*cp.z-sp.x*sp.y*sp.z, cp.z*sp.x+cp.x*sp.y*sp.z, \n           sp.y, -cp.y*sp.x, cp.x*cp.y);\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy+1.2;\n\t\n    vec3 bg = mix(vec3(255.,20.,0.)/255., vec3(222.,83.,14.)/255., uv.y);\n    vec3 col = mix(bg, vec3(254.,44.,0.)/255., clamp(.5+.5*mfsmoothstep_noise2d(uv, 5.e0, 1.e2, .45), 0., 1.));\n\tcol = mix(col, vec3(222., 255., 14.)/255., clamp(.5+.5*mfsmoothstep_noise2d(uv, 5.e0, 1.e2, .45),0.,1.));\n    col = mix(col,c.xxx, clamp(.5+.5*mfsmoothstep_noise2d(uv, 5.e0, 1.e2, .45),0.,1.));\n    col = mix(col, vec3(255., 255., 0.)/255., clamp(.1+.2*mfsmoothstep_noise2d(uv, 5.e0, 1.e2, .45),0.,1.));\n    col = mix(clamp(.5*rot(vec3(1.2141235,2.215352,3.123532)*2.e-1*iTime)*(col), 0., 1.), col, clamp(.5+1.2*mfsmoothstep_noise2d(uv, 5.e0, 1.e2, .45),0.,1.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstBDN.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[0, 798, 819, 819, 896], [898, 898, 931, 931, 1062], [1064, 1064, 1130, 1130, 1310], [1312, 1312, 1346, 1346, 1617], [1619, 1619, 1686, 1686, 1940], [1942, 1942, 1960, 1960, 2210], [2212, 2212, 2269, 2269, 3002]], "test": "error"}
{"id": "lstBzs", "name": "Funky plasma - Issues CMAP", "author": "Lovax", "description": ".", "tags": ["plasma"], "likes": 2, "viewed": 98, "published": "Public", "date": "1527430793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 red = vec3(255,179,186); //red\nvec3 yellow = vec3(255,255,186); //yellow\nvec3 green = vec3(186,255,201); //green\nvec3 blue = vec3(186,255,255); //blue\n\nfloat fastdist(in vec3 a, in vec3 b)\n{\n    return (a[0]-b[0])*(a[0]-b[0])\n            \t+(a[1]-b[1])*(a[1]-b[1])\n                +(a[2]-b[2])*(a[2]-b[2]);\n}\n\nvec3 quantize(in vec3 c) \n{\n    c = c*255.0;\n    vec3 o = red;\n    float d = fastdist(c, red);\n    float d2 = fastdist(c, yellow);\n    if (d2 < d) {\n        o = yellow;\n        d = d2;\n    }\n    d2 = fastdist(c, green);\n    if (d2 < d) {\n        o = green;\n        d = d2;\n    }\n    d2 = fastdist(c, blue);\n    if (d2 < d) {\n        o = blue;\n        d = d2;\n    }\n    return o;\n}\n\nfloat radial(in vec2 uv)\n{    \n    float cx = cos(2.0*iTime)/2.0+uv.x;\n    float cy = sin(iTime)/2.0-0.5+uv.y;\n    return 1.5*sqrt(cx*cx+cy*cy);\n}\n\nfloat trigofield(in vec2 uv)\n{    \n    vec2 offset = vec2(6.0*cos(iTime), 3.0*sin(2.0*iTime));\n    return sin(2.0*PI*uv.x+offset.x)*cos(2.0*PI*uv.y+offset.y);\n}\n\nfloat trigofield2(in vec2 uv)\n{\n    return 0.6*cos(uv.x*exp(sin(uv.y))+iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/min(iResolution.x, iResolution.y)*0.6;\n    \n    float c = radial(uv);\n    c += trigofield(uv);\n    c += trigofield2(uv);\n    \n\tfloat r = c;\n    float g = sin(exp(c)/2.0);\n    float b = cos(c*2.0);\n    \n    fragColor = vec4(quantize(vec3(r,g,b))/255.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstBzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 183, 221, 221, 338], [340, 340, 367, 367, 720], [722, 722, 748, 748, 868], [870, 870, 900, 900, 1030], [1032, 1032, 1063, 1063, 1112], [1114, 1114, 1171, 1171, 1457]], "test": "valid"}
{"id": "lstfDS", "name": "Rainbow seaweed", "author": "pudding", "description": "I was twiddling around with colours and shaping and sidetracked onto this", "tags": ["rainbow", "peaceful", "uvstretch"], "likes": 4, "viewed": 544, "published": "Public API", "date": "1526832505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise11(in float x) {\n\treturn fract(sin(x)*35746.1764); \n}\n    \nvec3 rgb(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 point(in vec2 uv) {\n    float id = floor(uv.x);\n    uv = fract(uv) + vec2(0.5);\n    vec2 pos = uv + vec2(sin(uv.y * 3. + noise11(id) * 2004.) * 0.3 - 1., cos(iTime * 2.));\n    return rgb(id / 16.5) / length((pos) * vec2(1., 0.05)) * 0.1; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv *= vec2(iResolution.x / iResolution.y * 9., 0.5);\n    fragColor = vec4(point(vec2(uv.x, uv.y * cos(iTime) + 0.5)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 64], [70, 70, 94, 175, 289], [291, 291, 315, 315, 536], [538, 538, 595, 595, 772]], "test": "valid"}
{"id": "lstfRj", "name": "One Wolf Logo I", "author": "oalpha", "description": "First version of my logo in webgl. Uses implicitized bezier curves.", "tags": ["logo", "wolf"], "likes": 2, "viewed": 209, "published": "Public", "date": "1525984197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nmat2 invert(mat2 m) {\n    return (1.0 / determinant(m)) * mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);\n}\nstruct line2 {\n    vec2 start;\n    vec2 end;\n};\nvec2 intersect(line2 a, line2 b, out vec2 s) {\n    mat2 Ai = invert(mat2(a.end - a.start, b.start - b.end));\n    s = Ai * (b.start - a.start);\n    return a.start + s.x * (a.end - a.start);\n}\nfloat triarea(vec2 a, vec2 b, vec2 c) {\n    vec3 ab = vec3(b - a, 0.0);\n    vec3 bc = vec3(c - b, 0.0);\n    vec3 ca = vec3(a - c, 0.0);\n    vec3 n = cross(ab, bc);\n    float A = length(bc);\n    float B = length(ca);\n    float C = length(ab);\n    float S = (A + B + C) * 0.5;\n    return sign(n.z) * S * (S - A) * (S - B) * (S - C);\n}\nstruct bezier2{\n    vec2 start;\n    vec2 control1;\n    vec2 control2;\n    vec2 end;\n};\nfloat prod_e(vec3 v) {\n    return v.x * v.y * v.z;\n}\nfloat plotBezier(\n    bezier2 bezier,\n    vec2 p,\n    float tolerance,\n    float fade,\n    bool smoothedge,\n    bool cap,\n    bool smoothcap\n) {\n    vec2 n;\n    vec2 p0 = bezier.start;\n    vec2 p1 = intersect(\n        line2(bezier.start, bezier.control1),\n        line2(bezier.end, bezier.control2),\n        n);\n    vec2 p2 = bezier.end;\n    float t3 = triarea(p0, p1, p2);\n    vec3 t = vec3(\n        triarea(p, p1, p2),\n        triarea(p0, p, p2),\n        triarea(p0, p1, p)\n    ) / t3;\n    float l1 = 1.0 / n.x;\n    float l2 = 1.0 / n.y;\n    float a1 = 3.0 * (1.0 - l1);\n    float a2 = 3.0 * (1.0 - l2);\n    float b1 = 3.0 * l1;\n    float b2 = 3.0 * l2;\n    float A = -b1 * b1 * (b1 - b2 * a2);\n    float B = -b2 * b2 * (b2 - b1 * a1);\n    float C = -3.0 * b1 * b2 +\n        2.0 * b1 * b1 * a1 +\n        2.0 * b2 * b2 * a2 -\n        b1 * b2 * a1 * a2;\n    float D = a2 * (b1 - b2 * a2);\n    float E = a1 * (b2 - b1 * a1);\n    float F = 1.0 - a1 * a2;\n    float d = \n        A * t[0] * t[0] * t[2] +\n        B * t[0] * t[2] * t[2] +\n        C * t[0] * t[1] * t[2] +\n        D * t[0] * t[1] * t[1] +\n        E * t[1] * t[1] * t[2] +\n        F * t[1] * t[1] * t[1];\n    d = d / tolerance + 0.5;\n    float b = smoothedge ? smoothstep(0.0, 0.5, d) - smoothstep(0.5, 1.0, d) : step(0.0, d) - step(1.0, d);\n    return cap ? (smoothcap ? mix(0.0, b, prod_e(smoothstep(-fade, fade, t))) : b * prod_e(0.5 * (sign(t) + 1.0))) : b;\n}\nvec3 pixel(vec2 st) {\n    vec3 st3 = vec3(st, 0.0);\n    float rt = 1.0 * iTime * PI / 15.0;\n    st = mat2(cos(rt), sin(rt), -sin(rt), cos(rt)) * (st - 0.5) + 0.5;\n    float polar = length(st - 0.5);\n    vec3 color = vec3(st.x, st.y, 0.0);\n    \n    vec3 b = vec3(0.0);\n    mat3 t = mat3(\n        0.002,  0.00000, 0.000,\n        0.00000, -0.002, .000,\n        0.51,  0.555, 1.000\n    );\n    float ut;\n    vec2 str;\n    const int N = 7;\n    const float fN = float(N);\n    for(int i = 0; i < N; i++) {\n        ut = 1.0 + 2.0 * float(i) * PI / fN;\n        str = mat2(cos(ut), sin(ut), -sin(ut), cos(ut)) * (st - 0.5) + 0.5;\n    \tb += plotBezier(bezier2((t * vec3(-252.4,   27.4, 1.0)).xy, (t * vec3(-252.4, -107.7, 1.0)).xy, (t * vec3(-142.4, -217.2, 1.0)).xy, (t * vec3(  -6.6, -217.2, 1.0)).xy), str,  0.0005, 0.0001, true, false, true) * pow(polar * 2.0, 4.0);\n    }\n    \n    t = mat3(\n        0.00195,  0.00000, 0.000,\n        0.00000, -0.00195, .000,\n        0.05500,  0.87500, 1.000\n    );\n    bool smoothedge = true, cap = false, smoothcap = true;\n    b += color * plotBezier(bezier2((t * vec3(169.2, 421.3, 1.0)).xy, (t * vec3( 119.9, 406.4, 1.0)).xy, (t * vec3( 49.6, 375.8, 1.0)).xy, (t * vec3( 10.7, 284.5, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);// * pow(polar * 2.0, 4.0);\n    b += color * plotBezier(bezier2((t * vec3( 10.7, 284.5, 1.0)).xy, (t * vec3( -28.3, 193.1, 1.0)).xy, (t * vec3(  1.1,  96.1, 1.0)).xy, (t * vec3( 42.0,  48.8, 1.0)).xy), st,  0.002, 0.001, smoothedge, cap, smoothcap);// * pow(polar * 2.0, 4.0);\n    b += color * plotBezier(bezier2((t * vec3( 42.0,  48.8, 1.0)).xy, (t * vec3(  82.8,   1.6, 1.0)).xy, (t * vec3(127.5, -34.8, 1.0)).xy, (t * vec3(208.6, -41.2, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);// * pow(polar * 2.0, 4.0);\n    b += color * plotBezier(bezier2((t * vec3(208.6, -41.2, 1.0)).xy, (t * vec3( 289.7, -47.6, 1.0)).xy, (t * vec3(319.9,  -5.6, 1.0)).xy, (t * vec3(327.5,  63.4, 1.0)).xy), st,  0.002, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(327.5,  63.4, 1.0)).xy, (t * vec3( 337.9, 210.7, 1.0)).xy, (t * vec3(310.2, 349.2, 1.0)).xy, (t * vec3(212.2, 380.3, 1.0)).xy), st, 0.0005, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(212.2, 380.3, 1.0)).xy, (t * vec3( 244.0, 388.4, 1.0)).xy, (t * vec3(273.8, 388.1, 1.0)).xy, (t * vec3(295.4, 383.8, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(295.4, 383.8, 1.0)).xy, (t * vec3( 278.9, 401.8, 1.0)).xy, (t * vec3(252.0, 414.7, 1.0)).xy, (t * vec3(210.0, 428.1, 1.0)).xy), st,  0.005, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(210.0, 428.1, 1.0)).xy, (t * vec3( 293.6, 432.6, 1.0)).xy, (t * vec3(355.0, 398.8, 1.0)).xy, (t * vec3(390.0, 364.9, 1.0)).xy), st,  0.001, 0.001, smoothedge, cap, smoothcap);\n    b += color * plotBezier(bezier2((t * vec3(390.0, 364.9, 1.0)).xy, (t * vec3( 425.1, 331.1, 1.0)).xy, (t * vec3(484.3, 254.2, 1.0)).xy, (t * vec3(458.2, 137.8, 1.0)).xy), st,  0.001, 0.001, smoothedge, cap, smoothcap);\n    float r = 0.15, f = 0.005;\n    b += 1.0 - smoothstep(r - f, r + f, polar);\n\treturn b;// * (1.0 - smoothstep(0.5, 0.51, polar));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 rem = iResolution.xy - min(iResolution.x, iResolution.y);\n\t//vec2 st = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);\n    const int SAMPLES = 3;\n    const float fSAMPLES = float(SAMPLES);\n    float shifta = 1.0 / fSAMPLES, shiftb = 0.5 - 0.5 / fSAMPLES;\n\tvec2 st = gl_FragCoord.xy;\n    vec3 p = vec3(0.0);\n    for(int i = 0; i < SAMPLES; i++)\n        for(int j = 0; j < SAMPLES; j++)\n            p += pixel((st - rem * 0.5 + vec2(i, j) * shifta - shiftb) / min(iResolution.x, iResolution.y)) / (fSAMPLES * fSAMPLES);\n\tfragColor = vec4(vec3(p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 247], [296, 296, 342, 342, 486], [487, 487, 526, 526, 819], [907, 907, 929, 929, 959], [960, 960, 1104, 1104, 2383], [2384, 2384, 2405, 2405, 5646], [5648, 5648, 5705, 5705, 6297]], "test": "error"}
{"id": "lstfW2", "name": "Planet With Glow", "author": "lordnoriyuki", "description": "Raytraced planet (based on [url]https://www.shadertoy.com/view/ltXSRr[/url])", "tags": ["planet", "glow", "moon", "atmosphere"], "likes": 30, "viewed": 707, "published": "Public", "date": "1526860676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 256;\nconst float CLOSENESS = 0.00001;\nconst float EPSILON = 0.005;\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\t\n    float n = p.x + p.y*157. + 113.*p.z;\n    \n    vec4 v1 = fract(753.5453123*sin(n + vec4(0., 1., 157., 158.)));\n    vec4 v2 = fract(753.5453123*sin(n + vec4(113., 114., 270., 271.)));\n    vec4 v3 = mix(v1, v2, f.z);\n    vec2 v4 = mix(v3.xy, v3.zw, f.y);\n    return mix(v4.x, v4.y, f.x);\n}\n\nfloat field(vec3 p) {\n   // random rotation reduces artifacts\n   mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                 0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                 -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n   vec3 p1 = M*p;\n   vec3 p2 = M*p1;\n   float n1 = noise(p1*5.);\n   float n2 = noise(p2*10.);\n   float n3 = noise(p1*20.);\n   float n4 = noise(p1*40.);\n   float rocky = 0.1*n1*n1 + 0.05*n2*n2 + 0.02*n3*n3 + 0.01*n4*n4;\n   float sph_dist = length(p) - 1.0;\n   return sph_dist + (sph_dist < 0.1 ? rocky*0.2 : 0.);\n}\n\nfloat field_lores(vec3 p) {\n   // random rotation reduces artifacts\n   mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                 0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                 -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n   vec3 p1 = M*p;\n   float n1 = noise(p1*5.);\n   float rocky = 0.1*n1*n1;\n   return length(p) - 1.0 + rocky*0.2;\n}\n\n\nvec3 getNormal(vec3 p, float value, mat3 rot) {\n    vec3 n = vec3(field(rot*vec3(p.x+EPSILON,p.y,p.z)),\n                  field(rot*vec3(p.x,p.y+EPSILON,p.z)),\n                  field(rot*vec3(p.x,p.y,p.z+EPSILON)));\n    return normalize(n - value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 src = vec3(3. * (fragCoord.xy - 0.5*iResolution.xy) / iResolution.yy, 2.0);\n    vec3 dir = vec3(0., 0., -1.);\n    \n    float ang = iTime*0.2;\n    mat3 rot = mat3(-sin(ang),0.0,cos(ang),0.,1.,0.,cos(ang),0.,sin(ang));\n\n    \n    float t = 0.0;\n    float atmos = 0.0;\n\n    vec3 loc = src;\n    float value;\n    int steps = 0;\n    for (int i=0; i < MAX_STEPS; i++) {\n        steps++;\n        loc = src + t*dir;\n        if (loc.z < -1.) break;\n        value = field(rot*loc);\n        if (value <= CLOSENESS) break;\n                if (value > 0.00001)\n            atmos += 0.03;\n\n\n        t += value*0.5;\n    }\n    // attempt at self-occlusion\n    float shad1 = max(0.,field_lores(rot*(loc+normalize(vec3(0.,5.,1.))*0.1)))/0.1;\n    float shad2 = max(0.,field_lores(rot*(loc+normalize(vec3(0.,5.,1.))*0.15)))/0.15;\n    float shad3 = max(0.,field_lores(rot*(loc+normalize(vec3(0.,5.,1.))*0.2)))/0.2;\n    float shad = clamp(shad1*0.333333 + shad2*0.333333 + shad3*0.333333, 0., 1.);\n    shad = mix(shad, 1.0, 0.3);\n    // attempt at some sort of ambient \"glow\"\n    float ambient = clamp(field(rot*(loc - 0.5 * dir))/0.5*1.2, 0., 1.);\n        \n\n    if (value > CLOSENESS) fragColor = vec4(0., 0., 0., 1.);\n    else {\n      vec3 normal = getNormal(loc, value, rot);\n      float light = dot(normal, normalize(vec3(0.,3.,1.)));\n\n      float totalLight = mix(ambient, 1.0*max(0.,shad*light), 0.7);\n\n    \n      vec3 color = mix(vec3(0.1,.3,0.5), vec3(0.5,.6,1.2), 1.-(1.0-length(loc))*20.);\n      fragColor = vec4(1.0*color*totalLight, 1.0);\n    }\n\tvec2 p = 2.0* (fragCoord.xy / iResolution.yy - vec2(0.5 /  iResolution.y * iResolution.x, 0.5));\n\tfloat q = max(0.1, min(1.0, dot(vec3(p, sqrt(1. - dot(p,p))), vec3(0., 2., 1.))));\n        fragColor += q * vec4(shad * max(0.0, pow(dot(normalize(src), normalize(vec3(0.,2., 1))),1.0)) * pow(atmos,1.5) * vec3(0.5, 0.5, 0.9), 1.0);\n\n\t//fragColor += vec4(q, 0.0, 0.0, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstfW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 111, 111, 473], [475, 475, 496, 536, 1088], [1090, 1090, 1117, 1157, 1510], [1513, 1513, 1560, 1560, 1764], [1766, 1766, 1823, 1823, 3739]], "test": "valid"}
{"id": "lstfzX", "name": "Bismuth Sunshine", "author": "BeardThings", "description": "Just drew a fun little shader logo", "tags": ["time", "logo", "rotate", "fun", "polar", "playground", "chill", "bismuth"], "likes": 2, "viewed": 507, "published": "Public API", "date": "1526233875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROTATE 0\n\nconst float PI = 3.1415926535897932384828433832795028841971693993751058209749445;\n\nfloat DrawGrid(vec2 coord)\n{\n    vec2 gridDist = abs(coord - round(coord)) * 2.0;\n    vec2 gridActive = smoothstep(vec2(0.1), vec2(0.0), gridDist);\n    return min(gridActive.x + gridActive.y, 1.0);\n}\n\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x), length(v));\n}\n\nfloat f(float r)\n{\n    return mod(r * 10.0 + iTime, 1.0);\n}\n\nvec4 Polar(vec2 polar)\n{\n    polar.x = polar.x + PI;\n    polar.x /= PI * 2.0;\n    \n    //polar.y = mod(polar.y, 2.0);\n    \n    float r = 5.0 + f(polar.x);\n    float d = pow(max(1.0 - abs(polar.y - r), 0.0), 10.0) * 2.0;\n    float d2 = pow(max(1.0 - abs(polar.y - r + 0.5), 0.0), 1.0) * 0.3;\n    \n    float rc = (sin(polar.x * PI * 2.0 + iTime) * 0.5 + 0.5);\n    float gc = (sin(polar.x * PI * 2.0 + PI * 0.5 + iTime) * 0.5 + 0.5);\n    float bc = (sin(polar.x * PI * 2.0 + PI + iTime) * 0.5 + 0.5);\n    \n    vec4 c = vec4(rc, gc, bc, 1.0);\n    return c * d + c * d2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 coord = fragCoord/iResolution.xy * 2.0 - 1.0;\n    coord.x /= iResolution.y / iResolution.x;\n    \n    #if ROTATE\n    coord *= 50.0;\n    \n    float t = iTime * 0.2;\n    mat2 m = mat2(cos(t), sin(t), -sin(t), cos(t));\n    vec2 rcoord = coord * m;\n    rcoord = mod(rcoord, vec2(20.0, 20.0)) - 10.;\n    \n    vec4 baseGrid = vec4(DrawGrid(coord * 0.3));\n    \n    fragColor = baseGrid * 0.15 + Polar(ToPolar(rcoord));\n    #else // ROTATE\n    \n    coord *= 10.0;\n    vec4 baseGrid = vec4(DrawGrid(coord * 0.5));\n    \n    fragColor = baseGrid * 0.15 + Polar(ToPolar(coord));\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lstfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 129, 129, 300], [302, 302, 324, 324, 370], [372, 372, 390, 390, 431], [433, 433, 457, 457, 1000], [1002, 1002, 1059, 1059, 1650]], "test": "valid"}
{"id": "lsVBR1", "name": "moutain car", "author": "asis5528", "description": "just made simple moving cart by combining shapes", "tags": ["shader", "car"], "likes": 3, "viewed": 195, "published": "Public", "date": "1527670801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle(vec2 uv){\n    return smoothstep(0.1,0.09,length(uv))-smoothstep(0.09,0.08,length(uv));\n}\n\nfloat body(vec2 st,float pos){\n    float k;\n    vec2 uv = st;\n    st = vec2(st.x*1.7,st.y)-vec2(pos*1.7,0.6-sin(time*3.+(pos*3.)+0.5)*0.1);\n    \n    if (st.x>0.2 && st.x <0.8){\n    \n    k = smoothstep(0.4,0.38,st.y)-smoothstep(0.6,0.5,st.y);\n    }\n    return k;\n}\n\nvec4 tire(vec2 st,float pos){\n    vec2 lst = vec2(st.x*1.7,st.y)-vec2(pos*1.7,0.6-sin(time*3.+pos*3.)*0.1);\n    float c = circle(lst);\n      \n   \n    float r = 0.08+0.03*cos(atan(lst.y,lst.x)*10.+time*23.);\n    float circle = smoothstep(r,r-0.05,length(lst));\n   \n    r = 0.05;\n    st.y+= -0.3;\n    float cl=circle;\n    return vec4(c)+vec4(cl)*vec4(1.,0.,0.,0.);\n\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    \n \n    uv.y+= sin(uv.x*3.+time*3.)*0.1;\n       \n        \n    float col = 1.-smoothstep(0.5,0.52,uv.y);\n    vec3 terrain = vec3(0.1,col*0.7,0.1);\n    vec4 tir = tire(st,0.3);\n    tir += tire(st,0.5);\n    //tir += vec4(body(st+vec2(0.0,0.5),0.0))*vec4(0.2,1.3,0.3,1.);\n    vec3 back = vec3(0.0,0.0,1.)*texture(iChannel0,st).r;\n    fragColor = mix(vec4(terrain,1.)+tir,vec4(back,1.),1.-uv.y);\n     st -= vec2(0.3,0.6-0.29-sin(time*3.+(0.3*3.)+0.5)*0.1);\n   \n    st = rotate2d( (sin(time*3.+(0.3*3.)+0.5)*0.1)/3. ) * st;\n\n    st += vec2(0.3,0.60-.29-sin(time*3.+(0.3*3.)+0.5)*0.1);\n    fragColor += vec4(body(st+vec2(0.0,0.29),0.1))*vec4(0.2,1.3,0.3,1.);\n    \n    }", "image_inputs": [{"id": "MsjXRV", "previewfilepath": "https://soundcloud.com/sergio-sergio-815961212/twice-tt-mv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sergio-sergio-815961212/twice-tt-mv", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 47, 47, 133], [135, 135, 157, 157, 236], [238, 238, 268, 268, 501], [503, 503, 532, 532, 872], [873, 873, 929, 929, 1653]], "test": "error"}
{"id": "lsyBzD", "name": "Butterfly 01", "author": "peko", "description": "Simple butterfly forked from https://www.shadertoy.com/view/4sfyWB", "tags": ["butterfly"], "likes": 2, "viewed": 390, "published": "Public API", "date": "1527773361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fork of https://www.shadertoy.com/view/4sfyWB\n\nconst float PI = 3.1415926;\nvec3 butterfly(vec2 frag);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = 0.5+vec4(butterfly(uv)/2.0,1.0);\n}\n\n\nvec3 butterfly(vec2 uv) {\n    uv-= 0.5;\n    uv*= 1.5;\n    uv.x*=1.5;\n    uv.x *= 1.0 -sin(iTime*2.)*.2;\n    vec2 p =uv*20.0;\n\n   \tfloat r = length(p);\n\tfloat t = atan(p.y, p.x);\n    \n    float butterfly = \n        7. - 0.5*sin( 1.*t) \n           + 2.5*sin( 3.*t) \n           + 2.0*sin( 5.*t) \n           - 1.7*sin( 7.*t) \n           + 3.0*cos( 2.*t) \n           - 2.0*cos( 4.*t) \n           - 0.4*cos(16.*t) - r;\n    \n    float a =-2.0;\n    float b = 0.0;\n    float c = smoothstep(a, b, butterfly);\n    vec2 g = normalize(p);\n    return vec3(g*c, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyBzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 107, 164, 219, 426], [429, 429, 454, 454, 983]], "test": "valid"}
{"id": "lt2cDK", "name": "SIMPLEX 3D + FBM", "author": "Txoka", "description": ":D", "tags": ["3d", "noise", "fbm", "simplex"], "likes": 6, "viewed": 545, "published": "Public API", "date": "1525851677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime/2.\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n\n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*simplex3D( p ); p = p*2.01;\n    f += 0.25000*simplex3D( p ); p = p*2.02;\n    f += 0.12500*simplex3D( p ); p = p*2.03;\n    f += 0.06250*simplex3D( p ); p = p*2.04;\n    f += 0.03125*simplex3D( p );\n\treturn f*0.5+0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy*2.0-1.0;\n    uv.x*=(iResolution.x/iResolution.y);\n    float n = fbm(vec3(time,uv*5.));\n\tfragColor = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 45, 45, 126], [128, 128, 153, 153, 2260], [2262, 2262, 2281, 2281, 2525], [2526, 2526, 2583, 2583, 2733]], "test": "valid"}
{"id": "Md3BDj", "name": "Cartoon Road 2", "author": "Kats", "description": "Playing around with skewing circles and rectangles", "tags": ["cartoon", "road"], "likes": 9, "viewed": 322, "published": "Public", "date": "1526963971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x,0.,1.)\nvec2 within(vec2 uv,vec4 rect){\n\treturn (uv - rect.xy)/(rect.zw-rect.xy);\n}\n\nvec2 Rotation(vec2 uv,float angle){\n\tfloat d = length(uv);\n    \n    vec2 dc = uv - vec2(0.,0.);\n    vec2 right = normalize(vec2(dc.y,-dc.x));\n    \n    uv += (vec2(d)*right*angle);\n\n    return uv;\n}\n\nfloat band(float t,float start,float end,float blur){\n\tfloat step1 = S(start-blur,start,t);\n    float step2 = S(end,end-blur,t);\n    return step1*step2;\n}\n\nfloat Rectangle(vec2 uv,float h,float b,float l,float r,float blur){\n\tfloat x = band(uv.x,l,r,blur);\n    float y = band(uv.y,h,b,blur);\n    return x*y;\n}\n\nvec4 Rays(vec2 uv){\n    uv.y += 0.01;\n    float x = uv.x;\n    float y = uv.y;\n    uv.x = abs(uv.x);\n    \n    float d = length(uv); \n    \n\tvec4 rayLight = vec4(0.9,0.7,0.2,1.)*1.4;\n    float rayMask = Rectangle(uv,0.,0.85,-0.01-y*0.1,0.01+y*0.1,0.01);\n    \n    rayMask += Rectangle(Rotation(uv,-0.7),0.,0.85,-0.005-y*0.1,0.005+y*0.1,0.01);\n    rayMask += Rectangle(Rotation(uv/2.4,-1.7),0.,0.85,-0.001-y*0.1,0.001+y*0.1,0.01);\n    rayMask += Rectangle(Rotation(uv/7.4,-5.7),0.,0.85,-0.001-y*0.1,0.001+y*0.1,0.01);\n   \n    \n    rayLight.a = rayMask*S(0.4,0.9,d)*(sin(iTime*0.5)-1.-0.5)*0.07;\n    return rayLight;\n}\n\nvec4 Sky(vec2 uv){\n    vec4 c = vec4(0.9,0.96,0.78,1.);\n    float d = length(uv+vec2(0.,0.09));\n    float skyMask = S(0.2*(sin(iTime)+1.)/2.,1.,d)*0.8;\n\tc = mix(c,vec4(0.2,0.65,0.9,1.),skyMask);\n    return c;\n}\n\nvec4 Grass(vec2 uv,float height){\n    vec4 c = vec4(0.);\n    \n    c.rgb = vec3(109./255.,172./255.,29./255.);\n    c.a = 1. - step(height,uv.y);\n    \n\treturn c;\n}\n\nvec4 Road(vec2 uv){    \n    \n    uv.x = abs(uv.x);\n    float x = uv.x;\n    float y = uv.y;\n    \n    vec4 back = vec4(144./255.,138./255.,126./255.,1.);\n    float rect = Rectangle(uv,-0.52,0.2,-0.05+y*0.8,0.05-y*0.8,0.02);\n    \n    back.a = rect;\n    back *= rect;\n    \n    float size = S(0.,-0.5,uv.y)*2.9;\n    \n    vec4 line = vec4(0.9,0.6,0.2,1.)*1.2;\n    float lineMask = Rectangle(uv+(vec2(y*0.75,0.))+vec2(-0.029,0.),-0.52,0.2,-0.01*size*0.8+y*0.04,0.01*0.8,0.01);\n    back = mix(back,line,lineMask);\n    \n    vec4 Wline = vec4(.95);\n    float WlineMask = Rectangle(uv+vec2(0.01,0.),-0.32,-0.2,-0.003+y*0.1,0.003-y*0.1,0.005);\n    WlineMask += Rectangle(uv/0.6+(vec2(-0.002,-0.11)),-0.32,-0.22,-0.003+y*0.1,0.003-y*0.1,0.005);\n    back = mix(back,Wline,WlineMask);\n    \n    return back;\n}\n\nvec4 Mount(vec2 uv,vec4 bounds,vec4 hCol,float shadowCurve){\n    float x = uv.x; \n\tuv = within(uv,bounds);\n    float d = length(uv);\n    float hillMask = S(0.5,0.47,d);\n    uv.x += pow(uv.y,shadowCurve)-0.2;\n    uv.y += sin(uv.x*10.*uv.x)*0.08;\n    \n    float shadeMask = S(0.0,0.1,uv.x);\n    float snowMask = S(0.4,0.42,uv.y);\n    \n    vec4 snowCol = vec4(1.);\n    vec4 hillCol = hCol;\n    hillCol = mix(hCol,snowCol,snowMask);\n    vec4 shadeCol = hillCol*0.85; \n    \n    \n    vec4 col = mix(hillCol,shadeCol,shadeMask);\n    \n    col.a = hillMask;\n    return col*hillMask;\n}\n\nvec4 Hill(vec2 uv,vec4 bounds,vec4 hCol,float shadowCurve){\n\tuv = within(uv,bounds);\n    float d = length(uv);\n    float hillMask = S(0.5,0.48,d);\n    uv.x += pow(uv.y,shadowCurve);\n    float shadeMask = S(0.0,0.1,uv.x);\n    \n    vec4 hillCol = hCol;\n    vec4 shadeCol = hillCol*0.85; \n    \n    vec4 col = mix(hillCol,shadeCol,shadeMask);\n    col.a = hillMask;\n    return col*hillMask;\n}\n\nvec4 Hills(vec2 uv){\n    uv.x = abs(uv.x);\n    uv.x -= 0.08;\n    vec4 col = vec4(0.);\n    \n    vec4 capMount = Mount(uv,vec4(0.13+uv.y*0.03,-0.01,0.4-uv.y*0.3,0.7),vec4(0.447059,0.464706,0.164706,1.),2.);\n    capMount += Mount(uv,vec4(0.37+uv.y*0.03,-0.01,0.8-uv.y*0.3,0.7),vec4(0.447059,0.764706,0.464706,1.),2.)*(1. - capMount.a);\n    vec4 smallHill = Hill(uv,vec4(0.3,-0.07,0.7,0.2),vec4(0.3,0.6,0.1,1.),3.);\n    vec4 medHill = Hill(uv,vec4(0.4,-0.17,0.8,0.5),vec4(0.2,0.7,0.1,1.),3.);\n    smallHill += Hill(uv,vec4(-0.6,-0.07,-1.0,0.2),vec4(0.3,0.6,0.1,1.),3.);\n    smallHill += Hill(uv,vec4(-0.9,-0.01,-1.3,0.6),vec4(0.2,0.63,0.4,1.),3.)*(1. - smallHill.a); \n    smallHill += Hill(uv,vec4(0.7,-0.01,1.1,0.6),vec4(0.2,0.63,0.4,1.),3.)*(1. - smallHill.a);    \n    medHill += Hill(uv,vec4(-0.5,-0.17,-1.1,0.5),vec4(0.2,0.7,0.1,1.),3.);\n    \n    col = mix(col,capMount*capMount.a,capMount.a);\n    col = mix(col,medHill,medHill.a);\n    col = mix(col,smallHill,smallHill.a);\n    \n    \n    return col;\n}\n\nvec4 Scene(vec2 uv){\n    //uv += vec2(sin(iTime),cos(iTime))*0.2;\n    vec4 col = vec4(0.);\n    vec4 grass = Grass(uv,-0.035);\n    vec4 sky = Sky(uv);\n    vec4 road = Road(uv);\n    vec4 rayLight = Rays(uv);\n    vec4 hills = Hills(uv);\n    \n    col.rgb = mix(col.rgb,grass.rgb,grass.a);\n    col.rgb = mix(col.rgb,sky.rgb,sky.a*(1.-grass.a));\n    col.rgb = mix(col.rgb,road.rgb,road.a*grass.a);\n    col.rgb = mix(col.rgb,rayLight.rgb,rayLight.a);\n    col.rgb = mix(col.rgb,hills.rgb,hills.a*(1.-grass.a));\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    fragColor = Scene(uv);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3BDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 96, 96, 140], [142, 142, 177, 177, 339], [341, 341, 394, 394, 495], [497, 497, 565, 565, 650], [652, 652, 671, 671, 1264], [1266, 1266, 1284, 1284, 1476], [1478, 1478, 1511, 1511, 1639], [1641, 1641, 1660, 1660, 2434], [2436, 2436, 2496, 2496, 3011], [3013, 3013, 3072, 3072, 3400], [3402, 3402, 3422, 3422, 4403], [4405, 4405, 4425, 4470, 4935], [4937, 4937, 4994, 5044, 5171]], "test": "valid"}
{"id": "Md3BRB", "name": "tricks 1", "author": "MonterMan", "description": "A collection of tricks, includes: fake sphere & plane AO, analytical sphere occlusion, vignetting, 3d fbm-based texturing, shadowing, fresnel effect, and GGX lobe specular lighting.", "tags": ["raymarch", "texturing"], "likes": 8, "viewed": 260, "published": "Public", "date": "1525678488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(in float entropy)\n{\n    return fract(sin(entropy*821.91)*951.51);\n}\n\nfloat hash3(in vec3 entropy)\n{\n    return hash(3.7*entropy.x + 721.5*entropy.y + 3.91*entropy.z + 0.5);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ipos = floor(p);\n    vec3 fpos = fract(p);\n    \n    float a = hash3(ipos + vec3(0, 0, 0));\n    float b = hash3(ipos + vec3(1, 0, 0));\n    float c = hash3(ipos + vec3(0, 1, 0));\n    float d = hash3(ipos + vec3(1, 1, 0));\n    \n    float e = hash3(ipos + vec3(0, 0, 1));\n    float f = hash3(ipos + vec3(1, 0, 1));\n    float g = hash3(ipos + vec3(0, 1, 1));\n    float h = hash3(ipos + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(0., 1., fpos);\n    \n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y),\n               t.z);\n}\n\nfloat fbm(in vec3 p)\n{\n    float res = 0.;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp*noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat map(in vec3 p, out int id)\n{\n    float sphere = length(p - vec3(0, 1, 0)) - 1.;\n    float ground = p.y;\n    float d = min(sphere, ground);\n    \n    if (d == ground)\n    {\n        id = 0;\n    }\n    if (d == sphere)\n    {\n        id = 1;\n    }\n    \n    return d;\n}\n\nvec3 map_n(in vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    int garbage;\n    return normalize(vec3(map(p + e.yxx, garbage), map(p + e.xyx, garbage), map(p + e.xxy, garbage)) - map(p, garbage));\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float res = 1.;\n    float k = 4.;\n    \n    float t = 0.1;\n    float t_max = 50.;\n    for(int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        int garbage;\n        float d = map(p + t*l, garbage);\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, d*k/t);\n        t += d;\n    }\n    \n    return res;\n}\n\n//NOTE: GGX lobe for specular lighting, took straight from here: http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\nfloat chiGGX(float v)\n{\n    return v > 0. ? 1. : 0.;\n}\nfloat GGX_Distribution(vec3 n, vec3 h, float alpha)\n{\n    float NoH = dot(n,h);\n    float alpha2 = alpha * alpha;\n    float NoH2 = NoH * NoH;\n    float den = NoH2 * alpha2 + (1. - NoH2);\n    return (chiGGX(NoH) * alpha2) / ( 3.1415926 * den * den );\n}\n\nvec4 render(in vec2 uv)\n{\n    float time = 0.1*iTime;\n    \n    vec3 at = vec3(0, 1, 0);\n    vec3 ro = vec3(4.*sin(time), 2, -4.*cos(time));\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(cam_x * uv.x + cam_y * uv.y + 2. * cam_z);\n    \n    int id = -1;\n    float t_max = 50.;\n    float t = 0.001;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n        \n        int curr_id;\n        float d = map(ro + t*rd, curr_id);\n        if (d < 0.001)\n        {\n            id = curr_id;\n            break;\n        }\n        t += d;\n    }\n    \n    vec3 sun_color = vec3(1.5);\n    vec3 background = vec3(1.4, 1.6, 1.8);\n    vec3 p = ro + t*rd;\n    vec3 col = background;\n    if (id != -1)\n    {\n        vec3 n = map_n(p);\n        vec3 l = -normalize(vec3(0.5, -0.9, 0.5));\n        \n        vec3 shad = vec3(0);\n        \n        float ao = 1.;\n        if (id == 0)\n        {       \n#if 1       \n           //NOTE: iq's analytical sphere occlusion\n            vec3 d = vec3(0, 1, 0) - p;\n            float l = length(d);\n            ao  = 1.0- max(0.0,dot(n,d))/(l*l*l);\n            \n#else       \n            //NOTE: fake occlusion\n            float t = length(p);\n            ao = smoothstep(0.0, 1.5, t);\n#endif\n        }\n        else if (id == 1)\n        {\n            ao = 0.5 * (dot(n, vec3(0,1,0)) + 1.);\n        }\n        \n     \tfloat roughness;\n        if (id == 0)\n        {\n            roughness = 0.3;\n        }\n        else if (id == 1)\n        {\n            roughness = 0.9;\n        }\n        \n        //ambient\n        shad += 0.3 * ao * background;\n        \n        //sun reflection\n        {\n            vec3 v = normalize(ro - p);\n            vec3 h = normalize(l + v);\n            float R0 = 1. - roughness;\n            float fresnel = R0 + (1. - R0) * pow(1. - dot(v, n), 5.);\n            float diff = (1. - fresnel) * max(0., dot(n, l));\n            float spec = fresnel * GGX_Distribution(n, h, roughness);\n            shad += 0.7 * shadow(p, l) * (diff + spec) * sun_color;\n        }\n        \n        float t = 1.0;\n        if (id == 0)\n        {\n            vec3 _p = p;\n            _p.x = fbm(p);\n            _p.z = fbm(p);\n            t = fbm(_p * vec3(6, 1.0, 0.3));\n        }\n        else if (id == 1)\n        {\n            t = fbm(p * vec3(2.9, 0.2, 3.1));\n        }\n        \n        vec3 color;\n        if (id == 0)\n        {\n            color = mix(vec3(0.05), vec3(0.6, 0.5, 0.35), t);\n        }\n        else if (id == 1)\n        {\n            color = mix(vec3(0.05), vec3(3.0, 2.5, 1.65), t);\n        }\n        \n        col = shad * color;\n        col = mix(col, background, length(p) / t_max);\n    }\n    \n    //poor man's tonemap\n    float k = 1.0;\n    return vec4(1.0 - exp(-col * k), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    //vignette\n    vec2 _uv = uv * (1. - uv);\n    float vig = pow(_uv.x*_uv.y*15., 0.15);\n    \n    //render\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    fragColor = vig * sqrt(render(uv)); //poor man's gamma correct\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3BRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 78], [80, 80, 110, 110, 185], [187, 187, 211, 211, 803], [805, 805, 827, 827, 1027], [1029, 1029, 1063, 1063, 1297], [1299, 1299, 1322, 1322, 1491], [1493, 1493, 1529, 1529, 1888], [1890, 2035, 2058, 2058, 2089], [2090, 2090, 2143, 2143, 2341], [2343, 2343, 2368, 2368, 5183], [5185, 5185, 5242, 5292, 5577]], "test": "valid"}
{"id": "Md3BW2", "name": "Hashcraft", "author": "James_Harnett", "description": "Watch the Intricate Patterns Emerge over Time.", "tags": ["fractal", "abstract", "art", "onetweet", "wallpaper"], "likes": 8, "viewed": 147, "published": "Public", "date": "1526731528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LICENSE: http://unlicense.org/\nvoid mainImage(out vec4 O,vec2 U){\nuvec2 p = uvec2(U + 9e3) + uint(iFrame);\np ^= p << (p.x + p.y >> 11);\nuint n = (p.x & p.y) - p.x;\nn ^= n << 21;\nO += sqrt(float(n ^ n << (n >> 27)) / 4e9);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3BW2.jpg", "access": "shaders20k", "license": "unlicense", "functions": [[0, 34, 68, 68, 225]], "test": "valid"}
{"id": "Md3Bzs", "name": "Sootie", "author": "gilesruscoe", "description": "sootie", "tags": ["soot"], "likes": 5, "viewed": 88, "published": "Public", "date": "1526331321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uvs\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    uv = uv * 2.0 - 1.0;\n    uv += vec2(sin(iTime), cos(iTime)) * sin(iTime) * 0.25;\n    uv.y *= ar;\n    \n    //basic shape\n    float lenUV = length(uv);\n    float body = smoothstep(lenUV, lenUV + 0.35, 0.5);\n\n    float rot = atan(uv.y, uv.x);\n\n    //anim\n    rot += sin(rot * 12.0 + iTime * 3.0 - lenUV * 50.0) * 0.1;\n    float sinrot = sin(rot * 8.0) * 0.5 + 0.5;\n    \n    //arms\n    float arms = sinrot * (1.0 - lenUV * 4.5) * 5.0;\n\t\n    //eyes\n    float eyeshapesL = length(uv * vec2(2.0, 1.0) + vec2(0.1, 0.0));\n    float eyeshapesR = length(uv * vec2(2.25, 1.2) - vec2(0.1, -0.02));\n    float pupilshapesL = length(uv * vec2(1.0, 1.0) + vec2(0.05, 0.055));\n    float pupilshapesR = length(uv * vec2(1.2, 1.0) - vec2(0.05, -0.055));\n    float eyes = smoothstep(eyeshapesL, eyeshapesL + 0.008, 0.1);\n    eyes += smoothstep(eyeshapesR, eyeshapesR + 0.008, 0.1);\n    eyes -= smoothstep(pupilshapesL, pupilshapesL + 0.005, 0.035);\n    eyes -= smoothstep(pupilshapesR, pupilshapesR + 0.005, 0.035);\n    \n    //blinky blink\n    eyes *= step(sin(iTime * 3.0 + cos(iTime * 2.0) * 2.0), 0.95);\n\n    //comp\n    float comp = arms + body;\n\tcomp *= 3.0;\n    comp = 1.0-clamp(comp, 0.0, 1.0);\n    comp += eyes;\n    fragColor = vec4(comp);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 69, 1387]], "test": "valid"}
{"id": "Md3fWB", "name": "Boiling geometry", "author": "Moumou38", "description": "hexagon party in raymarching with some point lights, trying to get a better understanding of raymarching. Not most optimised I guess. ", "tags": ["raymarching", "hexagon", "geometry"], "likes": 5, "viewed": 249, "published": "Public", "date": "1526819857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 30;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.0001;\n\nstruct light\n{\n\tvec3 Position;\n\tvec3 Color;\n\tfloat Intensity;\n} PointLight;\n\n\nfloat rand_1_05(in vec2 uv)\n{\n    float noise = (fract(sin(dot(uv ,vec2(12.9898,78.233)*2.0)) * 43758.5453));\n    return noise;\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n\t\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nfloat map(vec3 originPos)\n{\n    vec3 q = originPos + vec3(-2.5,-1.3,0.4);\n    float d = 1.0; //sdHexPrism(q,vec2(0.2,0.5));\n    for(int j=0; j< 12; ++j)\n    {\n        for(int i = 0; i < 7; ++i)\n        {\n            //float rand = rand_1_05(vec2(float(i)/iTime*cos(iTime),float(j)/sin(iTime)));\n            vec3 q = q + vec3(float(j)*0.45,float(i)*0.45,(0.05*cos(float(i)*iTime/1.5)*sin(float(j)*iTime)));\n            d = opU(d, sdHexPrism(q,vec2(0.2,0.2)));\n        }\n    }\n    \n    \n    return d;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    //p += vec3(0.0,0.0,sin(iTime));\n    vec3 q = mod(p,c)-0.5*c;\n    return map(q);\n}\n\n\nfloat trace(vec3 o, vec3 r)\n{\n float t= 0.0;\n    for(int i=0; i< MAX_MARCHING_STEPS; ++i) // for number of iteration\n    {\n    \tvec3 p = o + r*t; // until we find intersection\n        //p += vec3(0.0,1.0,0.0);\n        \n        vec3 q = ((rotateX(-90.0)) * vec4(p, 1.0)).xyz;\n        \n        float d =  map(p); //opRep(q, vec3(5.4,1,0));;\n\n        t += d * 0.5; // advancing on ray\n    }\n    return t;\n        \n}\n\nfloat applyFog( float b ) \n{\n    return pow(1.0 / (1.0 + b), 1.0);;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 pointLight( in vec3 p, in vec3 n, in vec3 v, in vec3 diffuseColor, in vec3 specularColor, in float specularPower, light Light)\n{\n\tvec3 l = normalize(Light.Position - p);\n\tfloat ndotl = max(dot(n, l), 0.0);\n\tvec3 h = normalize(l+v);\n\tfloat ndoth = max(dot(n, h), 0.0);\n\tfloat d = distance(Light.Position, p);\n\tfloat att = 1.f / (d*d);\n\treturn att * Light.Color * Light.Intensity * (diffuseColor * ndotl + specularColor * pow(ndoth, specularPower));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0; // change coordinates\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-2.0);\n    vec3 rd = normalize(vec3(uv,1.0)); // normalized so it does not poke geometry close to camera\n\n\n    float t = trace(ro, rd); // distance\n    \n    if (t > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n \n\tvec3 intersection = ro + rd * t;    \n    \n    // scene \n    //vec3 col = vec3(0.5,0.5,1.0); // background\n    \n    //col += vec3(applyFog(t)); // geometry\n    \n   \n    PointLight.Position = vec3(sin(iTime), cos(iTime), ro.z); \n    PointLight.Color = vec3(1.0,0.5,0.8); \n    PointLight.Intensity = 2.0;\n      \n    light point = PointLight;\n    \n    point.Position = vec3(cos(iTime*2.0), sin(iTime/3.14), ro.z); \n    point.Color = vec3(0.0,0.5,0.8); \n    point.Intensity = 2.0;\n    \n    vec3 color = pointLight( intersection, estimateNormal(intersection),-rd, vec3(abs(sin(iTime)),abs(cos(iTime)),abs(cos(iTime))), vec3(1.0,1.0,1.0), 0.0, PointLight)\n        + pointLight( intersection, estimateNormal(intersection),-rd, vec3(abs(sin(iTime)),abs(cos(iTime)),abs(cos(iTime))), vec3(0.0,1.0,1.0), 5.0, point) ;\n    \n\tfragColor = vec4(color , 1.0) ; /* applying the fog last */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3fWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 230, 230, 330], [333, 333, 369, 369, 455], [457, 457, 490, 490, 515], [517, 517, 544, 544, 727], [729, 729, 756, 756, 939], [941, 941, 968, 968, 1441], [1443, 1443, 1474, 1511, 1561], [1564, 1564, 1593, 1593, 1976], [1978, 1978, 2006, 2006, 2047], [2050, 2050, 2079, 2079, 2359], [2362, 2362, 2495, 2495, 2816], [2818, 2818, 2875, 2925, 4245]], "test": "valid"}
{"id": "Md3fzS", "name": "6 - Orbital", "author": "Makio64", "description": "Orbital - number 6 done for @36daysoftype instagram challenge :)\nI try using orbital formula to move the object in cute way. \nAlso experimenting with the depth to make a \"smooth aura\" and more specular stuffs while reducing the marching step.", "tags": ["cute", "number", "bubble", "specular", "orbit", "6", "orbital"], "likes": 10, "viewed": 662, "published": "Public API", "date": "1525665735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By David Ronai / @Makio64\n// Orbital - number 6 done for @36daysoftype instagram challenge :)\n// I try using orbital formula to move the object in cute way. \n// Also experimenting with the depth to make a \"smooth aura\" \n// and more \"specular stuffs\" while reducing the marching step.\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 23\n#define RAYMARCHING_JUMP 1.\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\nfloat snoise(in vec2 v);\nvec3 orbit(float phi, float theta, float radius){\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\n//http://mercury.sexy/hg_sdf/\n#define saturate(x) clamp(x, 0., 1.)\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec3 color = vec3(1.7,1.1,1.);\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    float time = iTime * 3. ;\n    vec3 q = pos + orbit(pos.x/10.+time, (pos.y*2.+time)/1., 1.);\n    float d = fCapsule(q,vec3(10.,30.,-8.),vec3(-10.,10.,-5.),6.);\n    q = pos + vec3(0.,10.,0.) + orbit(pos.x/10.+time, (pos.y+time)/1., 2.);\n    pR(q.yz,1.2);\n    d = fOpUnionRound(fTorus(q, 8.,20.),d,5.);\n    return d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n{\n\tfloat t = 15.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\nvec3 bw( in vec3 col ) { return vec3(0.299*col.r + 0.587*col.g + 0.114*col.b); }\nvec3 postEffects( in vec3 col, in vec2 uv )\n{    \n    // gamma correction\n\t//col = pow( clamp(col,0.0,1.0), vec3(0.6) );\n\t//vignetting\n\tcol *= 0.5+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n    //noise\n    col -= snoise((uv*3.+iTime)*1000.)*.1;\n    //col = mix(bw(col), col, sound*3.);\n    col*=(1.6,.9,.9);\n\treturn col;\n}\n\nvec3 addLight(in vec3 lpos, inout vec3 col, in vec3 pos, in vec3 nor, in vec3 rd, in float thi){\n\tvec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .5 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\t//col = vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) / latt;\n\tcol += vec3(.3,.3,.1) * (trans/latt)*thi;\n    return col;\n   \n}\n\n//------------------------------------------------------------------ RENDER\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n    \n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n    // lighitng        \n    vec3 lig = vec3(-0.6, 0.7, -0.5);\n    vec3 ref = reflect( rd, nor );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float specular = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),8.0);\n\n    float sound = texture( iChannel0, vec2( 0.01, .7 ) ).x;\n    sound *= sound;\n\n\tvec3 bg = vec3(sin(uv.x*1.1),sin(uv.y*2.),.9+sound*.8);\t\n    vec3 col = bg;\n    if(t<150.){\n        col /= 3.;\n    \tcol += max(0.,dot(nor,lig))*color;\n        col += specular*.2*sound; \n        col += fre*.2;\n    }\n    col = max(vec3(.05),col);\n\tcol += depth*vec3(1.,1.,1.)*.7+sound*.2;\n    col = mix( col, bg, 1.0-exp( -0.000001*t*t*t ));\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI/2.-.4,PI/2.,radius);\n\tvec3 ta  = vec3(0.);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\tcolor = postEffects( color, fragCoord.xy / iResolution.xy );\n\tfragColor = vec4(color,1.0);\n}\n\n#define X .211324865405187\n#define Y .36602540378443\nvec3 permute(in vec3 x) { return mod( x*x*34.+x, 289.); }\nfloat snoise(in vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i,\n       j = step(x0.yx, x0),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n", "image_inputs": [{"id": "Mts3DX", "previewfilepath": "https://soundcloud.com/steffenyoshiki/why-cant-i-turn-off-the-radio", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/steffenyoshiki/why-cant-i-turn-off-the-radio", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3fzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 519, 568, 568, 686], [688, 843, 887, 887, 990], [991, 1063, 1112, 1112, 1149], [1150, 1150, 1182, 1182, 1224], [1225, 1225, 1285, 1285, 1356], [1357, 1357, 1405, 1405, 1490], [1524, 1597, 1623, 1623, 1943], [1945, 2026, 2086, 2086, 2323], [2325, 2325, 2350, 2350, 2669], [2671, 2752, 2776, 2776, 2832], [2833, 2833, 2878, 2967, 3166], [3168, 3168, 3264, 3264, 3548], [3550, 3627, 3678, 3678, 4451], [4453, 4453, 4505, 4505, 4679], [4682, 4756, 4813, 4813, 5254], [5309, 5309, 5334, 5334, 5366], [5367, 5367, 5392, 5392, 6027]], "test": "error"}
{"id": "MdcBzB", "name": "Cubic Spline Interpolation", "author": "paniq", "description": "Interpolating four points using Bernstein polynomial of third degree.", "tags": ["spline", "cubic", "interpolation", "polynomial", "bernstein"], "likes": 12, "viewed": 747, "published": "Public API", "date": "1525709110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\nfloat p[4];\n\nfloat cubic_spline(float x) {\n\tfloat m[2];    \n    // compute control points\n    m[0] = p[1] + (p[2] - p[0]) / 6.0;\n    m[1] = p[2] - (p[3] - p[1]) / 6.0;\n    \n    float rx = (1.0 - x);\n    float rxx = rx*rx;\n    float xx = x*x;\n    \n    float t0 = rxx*rx;\n    float t1 = 3.0*x*rxx;\n    float t2 = 3.0*xx*rx;\n    float t3 = xx*x;\n    \n    return t0 * p[1] + t1 * m[0] + t2 * m[1] + t3 * p[2];\n}\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nvoid paint() {\n    float t = iTime;\n    \n    p[0] = cos(t*0.79)*1.5;\n    p[1] = sin(t*0.9)*0.8;\n    p[2] = cos(t*0.49)*0.8;\n    p[3] = cos(t*0.3333)*1.5;\n    \n    float d0 = (p[2] - p[0]) / 2.0;\n    float d1 = (p[3] - p[1]) / 2.0;\n    \n    float m[2];\n    m[0] = p[1] + d0 / 3.0;\n    m[1] = p[2] - d1 / 3.0;\n    \n    translate(-0.5, 0.0);\n    \n    set_source_rgb(vec3(1.0));\n    clear();\n    \n    set_line_width_px(1.3);\n    \n    set_source_rgba(1.0,0.0,0.0,1.0);\n    move_to(-1.0,p[1]-d0);\n\tline_to(1.0,p[1]+d0);\n    stroke();\n    move_to(0.0,p[2]-d1);\n\tline_to(2.0,p[2]+d1);\n    stroke();\n\n    set_source_rgba(0.0,0.0,0.0,1.0);\n    graph1D(cubic_spline);\n\tstroke();\n    \n    move_to(-3.0,0.0);\n    line_to(3.0,0.0);\n    move_to(-1.0,-1.0);\n\tline_to(-1.0,1.0);\n    move_to(0.0,-1.0);\n\tline_to(0.0,1.0);\n    move_to(1.0,-1.0);\n\tline_to(1.0,1.0);\n    move_to(2.0,-1.0);\n\tline_to(2.0,1.0);\n    stroke();\n    \n    circle(-1.0, p[0], 0.02);\n    circle(0.0, p[1], 0.02);\n    circle(1.0, p[2], 0.02);\n    circle(2.0, p[3], 0.02);\n\tfill();\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 119, 119, 484], [6230, 6295, 6309, 6309, 7329], [7483, 7543, 7570, 7570, 7596], [7598, 7658, 7679, 7679, 7786], [7788, 7788, 7825, 7825, 7911], [7913, 7913, 7959, 7959, 7992], [7994, 8132, 8160, 8160, 8620], [8648, 8648, 8667, 8667, 8700], [8702, 8702, 8720, 8720, 8753], [8755, 8755, 8779, 8779, 8883], [8885, 8885, 8902, 8902, 8923], [8925, 8925, 8952, 8974, 9257], [9259, 9259, 9287, 9287, 9521], [9523, 9523, 9547, 9547, 9633], [9635, 9635, 9662, 9662, 9875], [9877, 9877, 9903, 9903, 10131], [10133, 10133, 10155, 10155, 10281], [10283, 10283, 10303, 10303, 10363], [10365, 10365, 10397, 10397, 10424], [10426, 10426, 10447, 10447, 10469], [10471, 10471, 10495, 10495, 10555], [10557, 10557, 10591, 10591, 10615], [10617, 10617, 10631, 10631, 10695], [10697, 10697, 10723, 10723, 10761], [10763, 10763, 10789, 10789, 10810], [10812, 10812, 10835, 10835, 10930], [10932, 10932, 10956, 10956, 11025], [11027, 11027, 11052, 11052, 11099], [11101, 11101, 11118, 11118, 11231], [11233, 11233, 11256, 11256, 11385], [11387, 11387, 11415, 11415, 11543], [11545, 11545, 11569, 11569, 11709], [11711, 11711, 11749, 11749, 11883], [11885, 11885, 11922, 11922, 11957], [11959, 11959, 11986, 11986, 12036], [12038, 12038, 12068, 12068, 12124], [12126, 12126, 12155, 12155, 12336], [12338, 12338, 12360, 12360, 12519], [12521, 12521, 12534, 12534, 12573], [12575, 12575, 12605, 12605, 12634], [12636, 12636, 12669, 12669, 12726], [12728, 12728, 12754, 12754, 12804], [12806, 12806, 12827, 12827, 12892], [12894, 12894, 12918, 12918, 13001], [13003, 13003, 13018, 13018, 13059], [13061, 13061, 13077, 13077, 13115], [13117, 13117, 13135, 13135, 13192], [13194, 13194, 13224, 13224, 13594], [13596, 13596, 13654, 13654, 13692], [13694, 13694, 13723, 13723, 13759], [13761, 13761, 13809, 13809, 13840], [13842, 13842, 13876, 13876, 13935], [13937, 13937, 14014, 14014, 14179], [14181, 14181, 14258, 14258, 14338], [14340, 14340, 14416, 14416, 14532], [14534, 14534, 14610, 14610, 14688], [14690, 14690, 14728, 14728, 14762], [14764, 14764, 14786, 14786, 14832], [14834, 14834, 14861, 14861, 14905], [14907, 14907, 14956, 14956, 15217], [15219, 15219, 15292, 15292, 15346], [15348, 15348, 15380, 15380, 15416], [15418, 15418, 15474, 15474, 15530], [15532, 15532, 15562, 15562, 15655], [15656, 15656, 15696, 15696, 15719], [15721, 15767, 15806, 15806, 16954], [16956, 16956, 16986, 16986, 17088], [17090, 17090, 17142, 17142, 17182], [17184, 17184, 17206, 17206, 17257], [17259, 17259, 17291, 17291, 17313], [17315, 17330, 17352, 17352, 17644], [17646, 17646, 17678, 17678, 17700], [17702, 17702, 17721, 17721, 17753], [17802, 17865, 17907, 17907, 17973], [17975, 18045, 18096, 18096, 18448], [18450, 18484, 18530, 18530, 19042], [19044, 19113, 19159, 19159, 19665], [19667, 19667, 19700, 19700, 19916], [19918, 19918, 19977, 19977, 20022], [20024, 20024, 20067, 20067, 20128], [20130, 20130, 20172, 20172, 20209], [20211, 20271, 20328, 20328, 20527]], "test": "error"}
{"id": "MdcBzf", "name": "Time travel", "author": "Flopine", "description": "Shader made in 25 minutes during Outline 2018", "tags": ["raymarching", "modeling", "25mins"], "likes": 14, "viewed": 234, "published": "Public", "date": "1526140039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine, for Outline 2018 shader showdown\n// Thanks to wsmind, leon, lsdlive, XT95, lamogui for teaching me :) <3\n\n#define time iTime\n#define PI 3.141592\n#define ITER 65.\n\n\nfloat  mid  = 0.;\n\nfloat tiktak(float period)\n{\n    float tik = floor(time)+pow(fract(time),3.);\n    tik *= 3.*period;\n    return tik;\n}\n\nmat2 rot (float a)\n{\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b) , 0.5 * (u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat od (vec3 p, float d)\n{\n\treturn dot(p,normalize(sign(p)))-d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n\treturn length(max(abs(p)-c,0.));\n}\n\nfloat cylY(vec3 p, float r, float h)\n{\n\treturn max(length(p.xz)-r, abs(p.y)-h);\n}\n\nfloat cylZ(vec3 p, float r, float h)\n{\n\treturn max(length(p.xy)-r, abs(p.z)-h);\n}\n\nfloat prim1 (vec3 p, float h)\n{\n    p.xz *= rot(p.y);\n    p.xz = moda(p.xz, 2.*PI/5.);\n    p.x -= .6;\n    return cylY(p,0.07,h);\n}\n\nfloat prim2 (vec3 p, float h)\n{\n\treturn min(cylY(vec3(p.x,p.y+h,p.z),1.,0.2), cylY(vec3(p.x,p.y-h,p.z),1.,0.2));\n}\n\nfloat sablier (vec3 p)\n{\n    float h = 1.8;\n    float s1 = stmin(prim1(p,h), prim2(p,h),0.3,5.);\n    p.xz *= rot(time);\n    p.xy *= rot(time);\n    return min(s1,od(p,0.3));\n}\n\nfloat ring (vec3 p)\n{\n    p *= 1.2;\n    float s1 = max(-cylZ(p,0.6,1.), cylZ(p,1.,0.3));\n    p.xy = moda(p.xy, 2.*PI/8.);\n    p.x -= 1.2;\n    return stmin(box(p,vec3(0.4,0.2,0.2)), s1,0.3,5.);\n}\n\nfloat SDF (vec3 p)\n{\n    float per = 6.;\n    float d = 0.;\n\n    p.z = mod(p.z-per/2.,per)-per/2.;\n\n    vec3 pp = p;\n    p.xy *=rot(tiktak(0.5));\n    float r1 = ring (p);\n\n    p = pp;\n\n    p.xy *=rot(-tiktak(0.5));\n    p.xy = moda(p.xy,2.*PI/5.);\n    p.x -= 5.;\n    float s = sablier(p);\n\n    if (d<r1)\n    {\n        mid = 1.;\n        d = r1;\n    }\n\n    if (d>s)\n    {\n        mid = 2.;\n        d = s;\n    }\n\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n  \tvec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.001,0.001,time*3.); vec3 p = ro;\n    vec3 dir = normalize(vec3(uv,1.));\n    float shad = 0.;\n\n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p+=d*dir*0.35;\n    }\n\n    float t = length(ro-p);\n\n    vec3 col = vec3(0.);\n\n    if (mid == 1.) col = vec3(1.-shad)/vec3(0.3,0.8,0.)*0.8;\n    if (mid == 2.) col = mix(vec3(shad), vec3(0.1,0.5,0.7), 1.-abs(p.y)+2.);\n\n\tcol = mix(col,length(uv)* vec3(0.,0.,0.1),1.-exp(-0.001*t*t));\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 203, 231, 231, 320], [322, 322, 342, 342, 388], [390, 390, 421, 421, 545], [547, 547, 596, 596, 703], [705, 705, 733, 733, 772], [774, 774, 802, 802, 838], [840, 840, 878, 878, 921], [923, 923, 961, 961, 1004], [1006, 1006, 1037, 1037, 1136], [1138, 1138, 1169, 1169, 1252], [1254, 1254, 1278, 1278, 1428], [1430, 1430, 1451, 1451, 1624], [1626, 1626, 1646, 1646, 2046], [2048, 2048, 2104, 2104, 2780]], "test": "valid"}
{"id": "MdcfDj", "name": "Simplest Fastest 2D Hash", "author": "James_Harnett", "description": "Simple and Fast 2D Hash!", "tags": ["noise", "hash", "rand", "rng"], "likes": 15, "viewed": 1021, "published": "Public", "date": "1526729143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LICENSE: http://unlicense.org/\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n\n\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n//https://www.shadertoy.com/view/4dVBzz\n//much improved version, still comparable in speed to fract(sin()),\n//but with much better bit quality for making vec3 and vec4's\nfloat hash_Tong(uvec2 q)\n{\n\tq *= uvec2(M1, M2);\n    uint n = q.x ^ q.y;\n    n = n * (n ^ (n >> 15));\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n///////////////////Below are some other hash functions I found to compare with///////////////////\n\nfloat hash_FractSin(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);   \n}\n\n//https://www.shadertoy.com/view/MsV3z3\nfloat hash_2DWeyl(ivec2 c)\n{\n  int x = 0x3504f333*c.x*c.x + c.y;\n  int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n  return float(x*y)*(2.0/8589934592.0)+0.5;\n}\n\n//https://www.shadertoy.com/view/4tXyWN\nfloat hash_IQ3( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash_WithoutSine(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fp = vec2(fragCoord)+float(iFrame);\n    uvec2 up = uvec2(fragCoord)+uint(iFrame);\n    ivec2 ip = ivec2(fragCoord)+int(iFrame);\n    float c = hash(up);\n    \n    \n    //each loop below runs at 15 frames per second on my machine (760GTX)\n    \n    //for(uint  i=0U; i<500000U; i++)c = hash(up+i);\n    \n    //for(float i=0.0;i<350000.0;i++)c = hash_FractSin(fp+i);\n\n    //for(uint  i=0U; i<250000U; i++)c = hash_Tong(up+i);\n    \n    //for(int   i=0;  i<150000;  i++)c = hash_2DWeyl(ip+i);\n\n    //for(uint  i=0U; i<125000U; i++)c = hash_IQ3(up+i);\n\n    //for(float i=0.0;i<100000.0;i++)c = hash_WithoutSine(fp+i);\n    \n    \n    \n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcfDj.jpg", "access": "shaders20k", "license": "unlicense", "functions": [[0, 121, 144, 144, 260], [262, 432, 458, 458, 582], [584, 683, 712, 712, 781], [783, 823, 851, 851, 974], [976, 1016, 1043, 1043, 1199], [1201, 1241, 1273, 1273, 1390], [1392, 1392, 1449, 1449, 2118]], "test": "valid"}
{"id": "MdcfWH", "name": "warping gyroid, cheese-lookalike", "author": "MacSlow", "description": "Having seen FabriceNeyret2's gyroid (https://www.shadertoy.com/view/MdcfWH), I had to try that shape in my own raymarching-environment in order to understand how the shape works. Amazed by the weird and compact formulas producing the coolest geometries.", "tags": ["3d", "raymarching", "realtime", "material", "surface", "gyroid"], "likes": 11, "viewed": 735, "published": "Public API", "date": "1526418838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"warping gyroid\" - ripoff of FabriceNeyret2's gyroid:\n//                    https://www.shadertoy.com/view/MdcfWH\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool VISUALIZE_DEPTH = false;\nconst int MAX_STEPS = 128;\nconst float LARGE_STEP = .5;   // these should be 1.6 and 1.0 usually, but deforming\nconst float SMALL_STEP = .125;  // and bending some objects require smaller steps :/\nconst float EPSILON = .001;\n\nfloat hash (float f)\n{\n\treturn fract (sin (f) * 45734.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\nmat3 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 ( c, .0, -s),\n                     vec3 (.0, 1,  .0),\n                     vec3 ( s, .0,  c));\n\n    return mat;\n}\n\nmat3 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat3 mat = mat3 (vec3 (  c,  -s, 0.0),\n                     vec3 (  s,   c, 0.0),\n                     vec3 (0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat fbm (vec3 p)\n{\n\tmat3 m1 = mat3 (rotZ (23.4));\n\tmat3 m2 = mat3 (rotZ (45.5));\n\tmat3 m3 = mat3 (rotZ (77.8));\n\n    float result = .0;\n    result = 0.5 * noise3d (p);\n    p *= m1 * 2.02;\n    result += 0.25 * noise3d (p);\n    p *= m2 * 2.03;\n    result += 0.125 * noise3d (p);\n    p *= m3 * 2.04;\n    result += 0.0625 * noise3d (p);\n    result /= 0.9375;\n\n    return result;\n}\n\nfloat sphere (vec3 p, float size)\n{\n\treturn length (p) - size;\n}\n\nfloat plane (vec3 p)\n{\n    return p.y + .25;\n}\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad * p.y);\n    float s = sin (rad * p.y);\n    mat2  m = mat2 (c, -s, s, c);\n    p = vec3 (m * p.xy, p.z);\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 2. + (.5 + .5 * cos (iTime));\n    result =  sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n    return result;\n}\n\nvec2 map (vec3 p)\n{\n    float dt = .0;\n    float dp = .0;\n\tvec3 w = vec3 (.0);\n\tvec2 d1 = vec2 (.0);\n\tmat3 m = rotY (20. * iTime) * rotZ (-20. * iTime);\n\n    // floor\n    vec2 d2 = vec2 (plane (p), 2.);\n\n    // yellow warping gyroid\n    w = -m * (p + vec3 (.0, -1.5, .0));\n    opBend (w, 7. * cos (iTime));\n    d1.y = 3.;\n    float thickness = .075;\n    float cubeSize = 6.;\n    float surfaceSide = dot (sin (w), cos (w.yzx));\n    d1.x = abs (surfaceSide) - thickness;\n    vec3 a = abs (w);\n    d1.x = max (d1.x, max(a.x, max (a.y, a.z)) - cubeSize);\n\n    // only the nearest survives :)\n    if (d2.x < d1.x) {\n        d1 = d2;\n    }\n\n\treturn d1;\n}\n\nvec3 normal (vec3 p, float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (map (p + e.xyy).x,\n                            map (p + e.yxy).x,\n                            map (p + e.yyx).x) - map (p).x);\n}\n\nvec3 march (vec3 ro, vec3 rd)\n{\n    float pixelSize = 1. / iResolution.x;\n    bool forceHit = true;\n    float infinity = 10000000.0;\n    float t_min = .0000001;\n    float t_max = 1000.0;\n    float t = t_min;\n    vec3 candidate = vec3 (t_min, .0, .0);\n    vec3 candidate_error = vec3 (infinity, .0, .0);\n    float w = LARGE_STEP;\n    float lastd = .0;\n    float stepSize = .0;\n    float sign = map (ro).x < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n\t{\n        float signedd = sign * map (ro + rd * t).x;\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = SMALL_STEP;\n        } else {\n            stepSize = signedd * w;\n        }\n\n\t\tlastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error.x) {\n            candidate_error.x = error;\n            candidate.x = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n        \tbreak;\n\t\t}\n\n        candidate_error.y = map (ro + rd * t).y;\n        candidate.y = candidate_error.y;\n\n        candidate_error.z = float (i);\n        candidate.z = candidate_error.z;\n\n        t += stepSize;\n \n\t}\n\n    if ((t > t_max || candidate_error.x > pixelSize) && !forceHit) {\n        return vec3 (infinity, .0, .0);\n    }\n\n\treturn candidate;\n}\n\n// uses improved shadow-version by Sebastian Aaltonen as\n// demonstrated by iq here https://www.shadertoy.com/view/lsKcDD\nfloat shadow (in vec3 ro, in vec3 rd)\n{\n    float result = 1.;\n    float t = .1;\n    float ph = 1e10;\n    for (int i = 0; i < 64; i++) {\n        float h = map (ro + t * rd).x;\n        if (h < .00001) return .0;\n        float y = h*h/(2.*ph);\n        float d = sqrt (h*h - y*y);\n        result = min (result, 10.*d/max (.0, t - y));\n        ph = h;\n        t += h*.5;\n    }\n\n    return result;\n}\n\nvec3 floorMaterial (vec3 pos)\n{\n    vec3 col = vec3 (.6, .5, .3);\n    float f = fbm (pos * vec3 (6., .0, .5));\n    col = mix (col, vec3 (.3, .2, .1), f);\n    f = smoothstep (.6, 1., fbm (48. * pos));\n    col = mix (col, vec3 (.2, .2, .15), f);\n\n    return col;\n}\n\nvec3 thingMaterial (vec3 pos)\n{\n\treturn vec3 (.9, .5, .0);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspect = vec2 (iResolution.x/ iResolution.y, 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = vec2 (-1. + 2. * uv) * aspect;\n\n    vec3 ro = 9. * vec3 (cos (.2 * iTime), 1.25, sin (.2 * iTime));\n    vec3 ww = normalize (vec3 (.0, 1., .0) - ro);\n    vec3 uu = normalize (cross (vec3 (.0, 1., .0), ww));\n    vec3 vv = normalize (cross (ww, uu));\n    vec3 rd = normalize (p.x * uu + p.y * vv + 1.5 * ww);\n\n    // \"look\" into the world\n    vec3 t = march (ro, rd);\n    float fog = 1. / (1. + t.x*t.x*.001);\n\n    // base infinity-color (when nothing was \"seen\")\n    vec3 col = vec3 (.8);\n\n    // otherwise do all the lighting- and material-calculations\n    if (t.y > .5) {\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = normal (pos, t.x*EPSILON);\n        vec3 lig = normalize (vec3 (1., .8, .6));\n        vec3 blig = normalize (vec3 (-lig.x, lig.y, -lig.z));\n        vec3 ref = normalize (reflect (rd, nor));\n\n        float con = 1.;\n        float amb = .5 + .5 * nor.y;\n        float diff = max (dot (nor, lig), .0);\n        float bac = max (.2 + .8 * dot (nor, blig), .0);\n        float sha = shadow (pos, lig);\n        float spe = pow (clamp (dot (ref, lig), .0, 1.), 8.);\n        float rim = pow (1. + dot (nor, rd), 2.5);\n\n        col  = con  * vec3 (.1, .15, .2);\n        col += amb  * vec3 (.1, .15, .2);\n        col += diff * vec3 (1., .97, .85) * sha;\n        col += spe * vec3 (.9, .9, .9);\n        col += bac;\n\n        // either display ray-marching depth or materials\n        if (VISUALIZE_DEPTH) {\n\t        col *= vec3 (1. - t.z / float (MAX_STEPS));\n        } else {\n            if (t.y == 2.) {\n                col *= floorMaterial (pos);\n            } else if (t.y == 3.) {\n                col *= thingMaterial (pos);\n            }\n        }\n\n        col += .6 * rim * amb;\n        col += .6 * spe * sha * amb;\n\n        // fog, tint, tone-mapping, color-correction\n        col *= fog;\n        col *= vec3 (.95, .9, .85);\n        col = col / (.75 + col);\n        col = .2 * col + .8 * sqrt (col);\n    }\n\n    // put slight vignette over image\n    col *= .2 + .8 * pow (16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .2);\n\n    // after all this work, put the final color to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcfWH.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1091, 1259, 1281, 1281, 1321], [1323, 1323, 1347, 1347, 2021], [2023, 2023, 2051, 2051, 2275], [2277, 2277, 2305, 2305, 2538], [2540, 2540, 2560, 2560, 2918], [2920, 2920, 2955, 2955, 2984], [2986, 2986, 3008, 3008, 3032], [3034, 3034, 3074, 3074, 3248], [3250, 3250, 3275, 3275, 3444], [3446, 3446, 3465, 3465, 4094], [4096, 4096, 4133, 4133, 4323], [4325, 4325, 4356, 4356, 5665], [5667, 5789, 5828, 5828, 6183], [6185, 6185, 6216, 6216, 6447], [6449, 6449, 6480, 6480, 6509], [6511, 6511, 6567, 6567, 8817]], "test": "valid"}
{"id": "MdcfWj", "name": "Accelerated raymarching concept", "author": "rory618", "description": "Typically we only sample the sdf at points along the ray, but nearby points may provide more information. If the circle/sphere of empty space intersects the ray, you may march forward. Is the extra computation worth it? Is there a better way to get grad?", "tags": ["2d", "raymarching", "visualization"], "likes": 2, "viewed": 132, "published": "Public", "date": "1526775820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){\n    \n    z -= a; b -= a;                        // go to A referential\n    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate\n    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P \n\n    \n    fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-length( z - b),0.,1.));\n}\n\nvoid circle(inout vec4 fragColor, vec2 z, vec2 a, float r, vec4 c,  float w){\n    \n    fragColor =mix(fragColor,vec4(c.xyz,1) ,c.w* clamp(w-abs(length(z-a)-r),0.,1.));\n}\n\nfloat map(vec2 z){\n    //Edges of the screen and center circle\n    return min(abs(length(z-iResolution.xy/2.)-100.),min(min(z.x,z.y),min(iResolution.x-z.x,iResolution.y-z.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int it = 17;\n    \n    fragColor = vec4(1);\n    float l = 0.;\n    vec2 z = iMouse.zw;\n    vec2 d = normalize(iMouse.xy-iMouse.zw);\n    if(iMouse.z<=0.){\n        z = (.5+.5*sin(iTime*vec2(.031,.042)))*iResolution.xy;\n        d = normalize(sin(iTime*vec2(.064,.077)));\n    }\n    //Do normal raymarching in green\n    for(int i = 0; i < it; i++){\n        float d0 = map(z+l*d);\n     \tcircle(fragColor,fragCoord,z+l*d,d0,vec4(0,1,0,1),1.);\n        l += d0;\n            \n        lineSegment(fragColor,fragCoord,z,z+d*l,vec4(0,1,0,1),1.);\n    }\n     l = 0.;\n    //Accelerated raymarching in red\n    for(int i = 0; i < it; i++){\n        float d0 = map(z+l*d);\n        \n        //Estimate gradient of sdf numerically\n        float d1 = map(z+l*d+vec2(1e-2,0));\n        float d2 = map(z+l*d+vec2(0,1e-2));\n        \n        vec2 grad = normalize(vec2(d1-d0,d2-d0));\n        float x = -d0/dot(grad,d);\n        \n     \tfloat y = x/2./dot(grad,d);\n        float h = sqrt(y*y-x*x/4.);\n        \n        //To select a good additional point to sample the sdf at, assume we are nearby a flat surface and use the gradient to compute\n        //exactly where the ray would intersect the approximate surface. Then sample far enough away from that surface that you can\n        //expect the circle to also intersect the current location, so as to not have any gaps where small objects could get skipped over.\n        \n        //For rays moving away from a nearby surface I'll have to come up with a different way of choosing a point.\n        //Probably something along the lines of keeping track of a running estimate of how far away from the ray we shoud sample\n        //in order to still be able to march forward with the resulting information.\n        vec2 c = z+(l+x)*d-y*grad;\n        float p = map(c);\n        if(p>h){\n            float x0 = sqrt(p*p-h*h);\n            float a = x/2.-x0;\n            float b = x/2.+x0;\n            if(a<=d0 && x > 0. && d0<b){\n                l += b;\n                circle(fragColor,fragCoord,c,p,vec4(1,0,0,.4),2.);\n            } else {\n                circle(fragColor,fragCoord,z+l*d,d0,vec4(1,0,0,.4),2.);\n                l += d0;\n            }\n        } else {\n            circle(fragColor,fragCoord,z+l*d,d0,vec4(1,0,0,.4),2.);\n            l += d0;\n        }\n     \t\n            \n        lineSegment(fragColor,fragCoord,z,z+d*l,vec4(1,0,0,.4),2.);\n    }\n    circle(fragColor,fragCoord,iResolution.xy/2.,100.,vec4(1,0,1,.9),2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcfWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 81, 81, 415], [417, 417, 494, 494, 586], [588, 588, 606, 650, 766], [768, 768, 825, 825, 3318]], "test": "valid"}
{"id": "Mdcfzl", "name": "Wooden Parts", "author": "tholzer", "description": "Kali-inspired twisted sculpture parts.\n[url=https://www.shadertoy.com/view/lldSRM]Original[/url] coded by dila!\nPress mouse to view rounded distance function.\n", "tags": ["3d", "raymarching", "texture", "rotate", "kali"], "likes": 8, "viewed": 188, "published": "Public", "date": "1526320248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//----------------------------------------------------------\n// Wooden_Parts.glsl\n// \n// Kali-inspired twisted sculpture parts.\n// Press mouse ti view rounded distance function.\n//\n// original: https://www.shadertoy.com/view/lldSRM by dila\n//\n//   v1.0  2018-05-14  initial release\n//   v1.1  2018-06-21  sdSphere added  \n//\n// tags: 3d, raymarching, texture, rotate, kali\n//----------------------------------------------------------\n\n#define pi 3.14159\n\n// return 2d rotation matrix for counter clockwise rotation\nmat2 rotate2d (float angle)    \n{ \n  float ca = cos(angle),  sa = sin(angle);    \n  return mat2(ca, sa, -sa, ca);\n}\n\n//----------------------------------------------------------\n// signed box: bs.xyz = box size\nfloat sdBox( vec3 pos, vec3 bs )\n{\n    vec3 d = abs(pos) - bs;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// signed sphere distance: pos = position  \nfloat sdSphere (vec3 pos, float radius)  \n{\n    return length(pos) - radius; \n}\n//----------------------------------------------------------\n\nvec3 mpos = vec3(0.0); // map position\nfloat mid = 0.0;\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    \n//  q.y += sin(q.z * 0.125) * 3.0;\n    \n//  q.x -= (sin(q.z * 0.25) * 0.5 + 0.5) * 3.0;\n    \n    q.xy *= rotate2d(iTime*0.3);\n    \n    float u = 5.125;\n    q.z = (fract(q.z / u) - 0.5) * u;\n    \n    vec3 s = vec3(1.0, 0.125, 0.25);\n    \n    const int n = 4;\n    for (int i = 0; i < n; ++i) {\n        q.y = abs(q.y) - 0.5;\n        q.xy *= rotate2d(pi * 0.125);\n        q = abs(q) - 0.125;\n        q.xy *= rotate2d(p.z * 0.5);\n    }\n    \n    mpos = p;\n    mid = 0.0;\n    float d = 28.0 - p.x;\n    \n    float k = sdBox(q, s);\n    if (iMouse.z > 0.)\n      k = sdSphere(q, s.y+s.z);\n\n    if (k < d) {\n    \td = k;\n        mpos = q * 10.0;\n        mid = 1.0;\n    }\n    \n    return d;\n}\n\n// return normalized normal vector\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    float d = map(p);\n    return normalize(vec3(d - map(p-o.xyy),\n                          d - map(p-o.yxy),\n                          d - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 40; ++i) \n    {   float d = map(o + r * t);\n\t\tif (d < 2.)\n             t += d * 0.6;\n\t\telse t += d * 0.9;\n    }\n    return t;\n}\n\nvec3 texture3d(sampler2D channel, vec3 p)\n{\n    vec3 ta = texture(channel, p.xy).xyz;\n    vec3 tb = texture(channel, p.xz).xyz;\n    vec3 tc = texture(channel, p.zy).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(-5.0, 0.0, iTime * 1.0);\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    r.xy *= rotate2d(sin(iTime * 0.25) * 0.2);\n    r.xz *= rotate2d(pi * 0.5);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n    float ao = map(w + sn * 1.2);\n    \n    vec3 lcol1 = vec3(0.4, 0.3, 0.25) * 2.0;\n    vec3 lcol2 = vec3(0.5, 1.0, 1.0);\n    \n    vec3 tex = vec3(0.0);\n    if (mid == 0.0) {\n    \ttex = texture(iChannel0, mpos.yz * 0.03).xyz;\n        tex *= tex;\n    } else {\n        tex = texture3d(iChannel1, mpos * 0.05);\n        tex *= vec3(1.0, 0.5, 0.25);\n    }\n\n    vec3 lpos = o += vec3(-1.0, 8.0, -2.0);\n    vec3 ldel = w - lpos;\n    float ldist = length(ldel);\n    ldel /= ldist;\n    float lt = trace(lpos + sn * 0.5, ldel);\n    float lm = max(dot(ldel, -sn), 0.0);\n    lm /= (1.0 + ldist * ldist * 0.001);\n    if (lt < ldist) {\n        lm *= 0.25;\n    }\n    \n    if (mid == 1.0) {\n        vec3 ref = reflect(ldel, sn);\n    \tfloat spec = max(dot(r, -ref), 0.0);\n    \tspec = pow(spec, 4.0);\n        lcol1 *= 0.5 + spec;\n    \tlcol2 *= 0.5 + spec;\n    }\n    \n    vec3 lit = vec3(lm) * lcol2 + lcol1 * (sn.y * 0.5 + 0.5);\n    \n    float edge = 1.0 - 1.0 / (1.0 + fd * 100.0);\n    \n    vec3 fc = mix(lit * tex, lcol1, edge) * ao;\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "4d2SRV", "previewfilepath": "https://soundcloud.com/vynehall/movements-chapter-iii", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vynehall/movements-chapter-iii", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mdcfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 516, 549, 549, 631], [633, 727, 761, 761, 859], [861, 905, 948, 948, 984], [1070, 1104, 1123, 1123, 1823], [1825, 1860, 1881, 1881, 2071], [2073, 2073, 2102, 2102, 2270], [2272, 2272, 2315, 2315, 2491], [2493, 2493, 2550, 2550, 3994]], "test": "error"}
{"id": "MdcfzS", "name": "Zoomed variant Logistic map", "author": "akhgary", "description": "variable population initialization helps to distinguish more fixed points.\n\npoints are colored based on if its odd or even iteration. try mod 4  as well.", "tags": ["map", "chaos", "logistic"], "likes": 2, "viewed": 131, "published": "Public", "date": "1525669181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hue(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat draw(float dist){\n    return 1.-smoothstep(-1./iResolution.y,1./iResolution.y, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy+vec2(3,0); \n    vec3 col = vec3(0);\n\n    // population initial value is calculated using \n    // triangle wave that alternates between 0 and 1\n    float lambda = uv.x, pop = abs(mod(iTime/5.+.5,2.)-1.); \n    \n    for(int i=0;i<300;i++){\n        pop *= lambda*(1.-pop);\n        \n        if(i>150)\n            col += draw(abs(uv.y-pop)-1e-4)\n            \t  *hue(mod(float(i),2.)/2.); //also try mod(float(i),4.)/4.\n          \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdcfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 66], [68, 68, 91, 91, 161], [163, 163, 220, 220, 727]], "test": "valid"}
{"id": "MddBDX", "name": "second shader", "author": "wuyue", "description": "second shader", "tags": ["second", "beginer"], "likes": 0, "viewed": 346, "published": "Public API", "date": "1527070762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "valid"}
{"id": "MddfD7", "name": "Cannon-Thurston for fig 8 knot", "author": "henryseg", "description": "Joint work with Dave Bachman. An approximation to the Cannon-Thurston map from the boundary circle of the universal cover of the fiber of the figure eight knot complement to the boundary of 3D hyperbolic space.", "tags": ["fractal", "hyperbolic"], "likes": 19, "viewed": 379, "published": "Public", "date": "1525553807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Joint work with Dave Bachman. \n// An approximation to the Cannon-Thurston map from the boundary circle of the \n// universal cover of the fiber of the figure eight knot complement to the \n// boundary of 3D hyperbolic space.\n\n// This is a view of a horizontal slice through the upper half space model \n// of three-dimensional hyperbolic space. The height varies with time from \n// 0.001 to 0.201. The pattern is made as follows: Each pixel is inside of \n// a tetrahedron of the lift of the triangulation of the figure eight knot\n// complement to H^3. We move it by elements of the fundamental group until\n// it is inside of the fundamental domain, which consists of two tetrahedra\n// with vertices (infinity, 0, 1, e^(i pi/6)), and (infinity, 0, 1, e^(-i pi/6)).\n// As we go, we track how many times we cross through the fiber. If the answer is\n// zero we colour the pixel grey (0.5,0.5,0.5). If the number of times we\n// cross through is positive then the pixel gets more white, and if it\n// is negative then the pixel gets more black. \n\n// The result is that as we decrease the height of the horizontal slice down\n// towards zero, the points coloured (0.5,0.5,0.5) form a better and better\n// approximation to the image of the Cannon-Thurston map, a sphere-filling curve.\n\n// Works interestingly with 3d \"Chromadepth\" glasses\n\nvec4 c2q(in vec2 a){\n    return vec4(a, 0.0, 0.0);\n}\nvec4 qonj(in vec4 q){\n    return vec4(q.x, -q.yzw);\n}\nvec4 qinv(in vec4 q){\n \treturn qonj(q) / dot(q,q);\n}\nvec4 qmul(in vec4 p, in vec4 q){\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\nvec4 qdiv(in vec4 p, in vec4 q){\n    return qmul(p, qinv(q));\n}\nvec4 qmob(in vec2[4] M, in vec4 z){ // see Ahlfors 1981 Mob tsfms p14\n    vec4 a = c2q(M[0]);\n    vec4 b = c2q(M[1]);\n    vec4 c = c2q(M[2]);\n    vec4 d = c2q(M[3]);\n    return qdiv( qmul(a,z)+b, qmul(c,z)+d ); // if z.w = 0 then result.w = 0\n}\n\nconst float sqrt3 = sqrt(3.0);\nconst vec2 w = vec2(0.5, 0.5*sqrt3);\nconst vec2 winv = vec2(0.5, -0.5*sqrt3);\nconst vec2 c0 = vec2(0.0,0.0);\nconst vec2 c1 = vec2(1.0,0.0);\nconst vec2 ci = vec2(0.0,1.0);\n\nbool needt1(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 1\n\treturn q.x*(-0.5*sqrt3) + q.y*0.5 > 0.0;}\nbool needt1inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 1\n    vec4 center = c2q((c1 + winv)/3.0);\n    vec4 qmc = q - center;\n    return qmc.x*qmc.x + qmc.y*qmc.y + qmc.z*qmc.z < 1.0/3.0;}\nbool needt2(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 2\n\treturn q.x*(-0.5*sqrt3) + q.y*(-0.5) > 0.0;}\nbool needt2inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 2\n\treturn (q.x-1.0)*(0.5*sqrt3) + q.y*(0.5) > 0.0;}\nbool needt3(in vec4 q){ // q is wrong side of face of fund domain corresponding to transformation 3\n    return (q.x-1.0)*(0.5*sqrt3) + q.y*(-0.5) > 0.0; }\nbool needt3inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 3\n    vec4 center = c2q((c1 + w)/3.0);\n\tvec4 qmc = q - center;\n    return dot(qmc.xyz, qmc.xyz) < 1.0/3.0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t1[4];\n\tt1[0] = c1;\n\tt1[1] = -w;\n\tt1[2] = c1;\n\tt1[3] = winv;  // is this really the only way to assign values to the array??\n    vec2 t1inv[4];\n    t1inv[0] = winv;\n    t1inv[1] = w;\n    t1inv[2] = -c1;\n    t1inv[3] = c1;\n    vec2 t2[4];\n    t2[0] = c1;\n    t2[1] = w;\n    t2[2] = c0;\n    t2[3] = c1;\n    vec2 t2inv[4];\n    t2inv[0] = c1;\n    t2inv[1] = -w;\n    t2inv[2] = -c0;\n    t2inv[3] = c1;\n    vec2 t3[4];\n    t3[0] = -winv;\n    t3[1] = -w;\n    t3[2] = w;\n    t3[3] = -w - c1;\n    vec2 t3inv[4];\n    t3inv[0] = -w - c1;\n    t3inv[1] = w;\n    t3inv[2] = -w;\n    t3inv[3] = -winv; //all these should have det 1 now\n    \n    vec2 p = vec2(0.1,0.001) + 1.5*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec4 q = vec4(p, 0.001+0.1*(0.75 + cos(iTime) + 0.25*cos(2.0*iTime)), 0.0);\n\t//vec4 q = vec4(p, 0.0001, 0.0);\n    \n    int crossing_count = 0;\n    bool inside_fund_dom = false;\n    for(int i=0;i<512;i++){\n        if (needt1(q)) q = qmob(t1, q);\n        else if (needt1inv(q)) q = qmob(t1inv, q);\n        else if (needt2(q)) { q = qmob(t2, q);\n                             crossing_count -= 1;}\n        else if (needt2inv(q)) { q = qmob(t2inv, q);\n                             crossing_count += 1;}\n        else if (needt3(q)) { q = qmob(t3, q);\n                             crossing_count -= 1;}        \n        else if (needt3inv(q)) { q = qmob(t3inv, q);\n                             crossing_count += 1;}\n        else{\n            inside_fund_dom = true;\n            break;\n        }\n    }\n    vec3 col;\n    if (inside_fund_dom){\n        //float c = 0.5 + float(crossing_count)/10.0;\n        float d = float(crossing_count)/15.0;\n        if (d > 0.0){\n            col = vec3(d,0.5*(1.0-d),0.5*(1.0-d));\n        }\n        else{\n            col = vec3(0.0,0.5*(1.0+d),0.5*(1.0+d)); \n        }\n        \n    }\n    else{\n        col = vec3(0.0,0.0,0.5);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1276, 1330, 1350, 1350, 1382], [1383, 1383, 1404, 1404, 1436], [1437, 1437, 1458, 1458, 1489], [1490, 1490, 1522, 1522, 1745], [1746, 1746, 1778, 1778, 1809], [1810, 1810, 1845, 1879, 2054], [2259, 2259, 2282, 2359, 2402], [2403, 2403, 2429, 2510, 2640], [2641, 2641, 2664, 2741, 2787], [2788, 2788, 2814, 2895, 2945], [2946, 2946, 2969, 3045, 3100], [3101, 3101, 3127, 3208, 3314], [3316, 3316, 3373, 3373, 5292]], "test": "error"}
{"id": "MddfDH", "name": "SickBow's Lightspeed Jump", "author": "sickbow", "description": "starfield lightspeed jump", "tags": ["stars"], "likes": 2, "viewed": 194, "published": "Public", "date": "1525144237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265358979\n\nfloat rand(float seed){\n\treturn fract(sin(seed * 13123.1317) * 64532.6438)+.01;   \n}\n\nvec3 star(vec3 col, vec3 starCol, vec2 uv, float size, vec2 center){\n    \n    float perp = length( cross(vec3(uv,0), vec3(center,0)) )/length(center);\n    float streakLength = 15. * pow(fract(iTime/10.),10.);\n    float streakWidth = 4.* pow(fract(iTime/10.),20.);\n    \n    if (length(uv-center) <= size){\n    \tcol += smoothstep(size, 0.0, length(uv-center))*starCol;\n    }\n    \n    if (perp < streakWidth && length(uv - center) < streakLength){\n    \tcol += smoothstep(size, 0.0, perp)*starCol; \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n\t\n    for(float i = 0.; i < 70.; i+=.1){\n    \t\n        vec2 center = 100. * ( 1.-fract(iTime/10.) ) * rand(i) * vec2( i/70.*cos(i), i/70.*sin(i) );\n        \n        float shrink = length(center);\n        \n    \tcol = star(col, vec3(.5), uv, .01*shrink, center );\n       \n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 52, 52, 113], [115, 115, 183, 183, 638], [640, 640, 697, 733, 1166]], "test": "valid"}
{"id": "MddfRl", "name": "Voxel Bridge 3", "author": "shau", "description": "A tunnel made of cubes", "tags": ["3d", "tunnel"], "likes": 47, "viewed": 1337, "published": "Public API", "date": "1526504995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define PI 3.141592\n#define T iTime\n#define FAR 50.0\n\n//Dave Hoskins\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Shane\nvec3 path(float t) {\n    float a = sin(t * PI / 24.0 + 1.7);\n    float b = cos(t * PI / 24.0);\n    return vec3(a * 2.0, b * a, t);    \n}   \n\n//wireframe edges\nfloat tex(vec3 rp) {\n    float bs = 0.95;\n    if (abs(rp.x) < bs && abs(rp.y) < bs) return 0.0;\n    return 1.0;   \n}        \n\n// Cube mapping routine from Fizzer\nfloat fizz(vec3 rp) {\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f);\n}\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//sphere and box functions from IQ\n//http://www.iquilezles.org/www/index.htm\nvec2 boxIntersection(vec3 ro, vec3 rd, vec3 b, inout vec3 on, float r1, float r2) {\n    \n    float la = 0.0;\n    \n    ro.zy *= rot(r1);\n    rd.zy *= rot(r1);\n    ro.xz *= rot(r2);\n    rd.xz *= rot(r2);\n\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * b;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    on = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    \n    la = fizz(ro + rd * tN);\n    \n    on.zy *= rot(-r1); \n    on.zy *= rot(-r1); \n    on.xz *= rot(-r2); \n    on.xz *= rot(-r2); \n    \n    return (tN > tF || tF < 0.0) ? vec2(0.0) : vec2(tN, la);\n}\n\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\n//modified logic from IQ\n//https://www.shadertoy.com/view/4dfGzs\nstruct Scene {\n    float t;\n    vec3 n;\n    float l;\n};\nScene voxelMarch(vec3 ro, vec3 rd) {\n \n    float t = 0.0;\n    vec3 n = vec3(0.0), mm = n, p = floor(ro), ri = 1.0 / rd, rs = sign(rd);\n    float l = 0.0;\n    \n    vec3 d = (p - ro + 0.5 + rs * 0.5) * ri;\n\n    for (int i = 0; i < 128; i++) {\n        \n        if (length(p.xy - path(p.z).xy) > 3.0) {\n        \n            float r = hash13(p);\n        \tfloat r1 = r + T + p.z;\n        \tfloat r2 = r1 * 2.0 + p.y;\n\n            vec2 bi = boxIntersection(ro - (p + vec3(0.5)), \n                                       rd, \n                                       vec3(clamp(r * 0.5, 0.1, 0.3)), \n                                       n,\n                                       r1,\n                                       r2);\n            \n            if (bi.x > 0.0) {\n                t = bi.x;\n                l = bi.y;\n                break;\n            }\n        }\n        \n        mm = step(d.xyz, d.yxy) * step(d.xyz, d.zzx);\n        d += mm * rs * ri;\n        p += mm * rs;\n    }\n    \n    return Scene(t, n, l);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd, inout vec3 lp) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 6.0);\n    ro = lookAt + vec3(0.0, 0.0, -1.0);\n    lp = lookAt + vec3(0.0, 0.0, 16.0 + sin(T * 0.2) * 6.0);\n\n    lookAt = path(lookAt.z);\n    ro = path(ro.z);\n\tlp = path(lp.z);\n      \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    rd.xy *= rot(sin(-ro.x  * 0.5) * 0.4);//isdive\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float mint = FAR;\n    vec3 pc = vec3(0.0), ro, rd, lp;\n    setupCamera(fragCoord, ro, rd, lp);\n    \n    Scene scene = voxelMarch(ro, rd);\n    \n    if (scene.t > 0.0) {\n        \n        mint = scene.t;\n        vec3 rp = ro + rd * scene.t;\n        \n        //camera light\n        vec3 ld = normalize(vec3(4.0, 5.0, -4.0));\n        float atten = 1.0 / (1.0 + scene.t * scene.t * 0.05);\n        float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\n        vec3 ac = vec3(1.0) * max(dot(ld, scene.n), 0.05) * 0.2;\n        ac += vec3(0.1, 0.0, 0.9) * max(0.0, scene.n.y) * 0.1;\n        ac += vec3(1.0) * spec * atten;\n        \n        //glowball light\n        ld = normalize(lp - rp);\n        float lt = length(lp - rp);\n        atten = 1.0 / (1.0 + lt * lt * 0.03);\n        spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\n        //shadow\n        Scene shadowScene = voxelMarch(rp - rd * 0.01, ld);\n        float sh = shadowScene.t > 0.0 && shadowScene.t < lt ? 0.0 : 1.0;\n        vec3 gc = vec3(1.0, 0.5, 0.0) * max(dot(ld, scene.n), 0.05) * atten * sh;\n        atten = 1.0 / (1.0 + lt * lt * 0.08);\n        gc += vec3(1.0, 0.8, 0.0) * max(dot(ld, scene.n), 0.05) * atten * sh;\n        gc += vec3(1.0, 1.0, 0.3) * spec * atten * sh;\n        \n        pc = ac + gc;\n        \n        float la = mod(rp.z + T * 8.0, 30.0);\n        pc += vec3(1.0, 0.5, 0.0) * scene.l * step(la, 5.0) / (1.0 + mint * 0.001);\n    }\n    \n    pc = mix(pc, vec3(0.4, 0.2, 0.0), mint / FAR);\n    \n    vec2 si = sphIntersect(ro, rd, vec4(lp, 1.0));\n    if (si.x > 0.0 && si.x < mint) {\n        float w = sphDensity(ro, rd, vec4(lp, 1.0), FAR);\n        if (w > 0.0) {\n        \tpc += vec3(1.0, 0.2, 0.0) * w * w;    \n        \tpc += vec3(1.0, 0.5, 0.0) * w * w * w;    \n        \tpc += vec3(1.0, 1.0, 0.0) * w * w * w * w * w;    \n        }\n    }\n    \n    fragColor = vec4(pc, 1.0);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[224, 239, 262, 262, 364], [366, 374, 394, 394, 510], [515, 533, 553, 553, 649], [659, 695, 716, 716, 879], [881, 881, 900, 900, 946], [948, 1025, 1108, 1108, 1695], [1697, 1697, 1744, 1744, 1992], [1994, 1994, 2055, 2055, 2571], [2573, 2694, 2730, 2730, 3704], [3706, 3706, 3785, 3785, 4367], [4369, 4369, 4424, 4424, 6309]], "test": "valid"}
{"id": "MddfzN", "name": "Computer Graphics: Clock", "author": "ftr177", "description": "Clock", "tags": ["clock"], "likes": 3, "viewed": 108, "published": "Public", "date": "1525193687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Creates a line segment:\n// p - coordinate system\n// a - position of segment\n// b - angle of segment\n// w - width of segment\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float w) \n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return smoothstep(0.0, w, length(pa - ba*h));\n}\n\n// Creates the line segment and\n// movement for the second hand\nfloat secondHand(vec2 uv)\n{\n    float secondHand;\n    float second = mod(iDate.w, 60.0);\n    float angle = -second * 2.0 * 3.14159 / 60.0 + + (3.14159/2.0);\t// Converts from time to radians\n    secondHand = 1.0 - lineSegment(uv, vec2(0.0, 0.0), 0.31 * vec2(cos(angle), sin(angle)), .005);\n    return secondHand;\n}\n\n// Creates the line segment and\n// movement for the minute hand\nfloat minuteHand(vec2 uv)\n{\n    float minuteHand;\n    float minute = mod(iDate.w/60.0, 60.0);\t// Converts time in seconds to minutes\n    float angle = -minute * 2.0 * 3.14159 / 60.0 + (3.14159/2.0);\n    minuteHand = 1.0 - lineSegment(uv, vec2(0.0, 0.0), .25 * vec2(cos(angle), sin(angle)), .005);\n    return minuteHand;\n}\n\n// Creates the line segment and\n// movement for the hour hand\nfloat hourHand(vec2 uv)\n{\n    float hourHand;\n    float hour = mod(iDate.w/3600.0, 24.0);\n    float angle = -hour * 2.0 * 3.14159 / 12.0 + (3.14159/2.0);\n    hourHand = 1.0 - lineSegment(uv, vec2(0.0, 0.0), .19 * vec2(cos(angle), sin(angle)), .005);\n    return hourHand;\n}\n\n// Creates a circle:\n// uv - coordinate system\n// p - position\n// r - radius of circle\n// blur - blur\nfloat circle(vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Recenter coordinate system so that\n    // the center of the screen is (0., 0.)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Drawing of the clock outline\n    vec3 col;\n    col = vec3(0.0);\n    float disc = circle(uv, vec2(0.0, 0.0), 0.35, 0.01);\n    disc -= circle(uv, vec2(0.0, 0.0), 0.34, 0.01);\n    col = vec3(1.0, 1.0, 1.0)*disc;\n    \n    // Drawing of the hands\n    col += vec3(0.0, secondHand(uv), secondHand(uv));\n    col += vec3(0.0, minuteHand(uv), 0.0);\n    col += vec3(hourHand(uv), 0.0, hourHand(uv));\n    \n    // Variation in screen color\n    //col -= vec3(cos(iTime*.5)*.25, cos(iTime*.75)*.25, sin(iTime*.75));\n\tcol -= 0.5*cos(.75*iTime+uv.xyx+vec3(2.0,2.0,2.0));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MddfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 180, 180, 321], [323, 387, 414, 414, 700], [702, 766, 793, 793, 1087], [1089, 1151, 1176, 1176, 1423], [1425, 1527, 1579, 1579, 1663], [1665, 1665, 1722, 1808, 2531]], "test": "valid"}
{"id": "MdGBzz", "name": "Wanderlust", "author": "Julius", "description": "Raytracing example", "tags": ["raytracing"], "likes": 1, "viewed": 335, "published": "Public API", "date": "1527431020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct ray { vec3 origin; vec3 direction; };\n  \nray cameraRay(vec2 uv, vec3 camera) {    \n    vec2 pos = uv - vec2(.5, .5);\n    \n\treturn ray(camera, vec3(pos.x, pos.y, 1));\n}\n\nvec3 intersectPlane(float planeHeight, ray r) {\n\tfloat height = planeHeight - r.origin.y;\n    \n    return r.origin + r.direction / r.direction.y * height;\n}\n\nfloat rand(vec3 v){\n    return fract(sin(dot(v ,vec3(12.9898,78.233,.0235))) * 43758.5453);\n}\n\nvec3 stars(vec3 direction) {\n\tif(rand(direction) > .0001)\n        return vec3(0,0,0);\n    else\n        return vec3(1,1,1);\n}\n\nvec3 checkered(vec2 location) {\n\tif ((mod(location.x, 2.) > 1.) != (mod(location.y, 2.) > 1.))\n        return vec3(0,0,0);\n    else\n        return vec3(1,1,1);\n}\n\nvec3 foggy(vec3 color, float d, float view) {\n    float viewFactor = max(0., view / d);\n    \n\treturn color * viewFactor + vec3(.5, .5, .5) * (1. - viewFactor);\n}\n\nvec3 traceColor(ray r) {\n    float d;\n    vec3 color;\n    \n    if(r.direction.y >= 0.) {\n    \tcolor = stars(r.direction);\n        d = 50.;   \n    } else {\n        vec3 intersect = intersectPlane(0., r);\n        d = length(r.origin - intersect);\n        color = checkered(intersect.xz);\n    }\n    \n    return foggy(color, d, r.origin.z * .1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    ray r = cameraRay(uv, vec3(0,1,iTime * iTime));\n    \n    vec3 col = traceColor(r);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGBzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 85, 85, 174], [176, 176, 223, 223, 332], [334, 334, 353, 353, 427], [429, 429, 457, 457, 553], [555, 555, 586, 586, 716], [718, 718, 763, 763, 879], [881, 881, 905, 905, 1224], [1226, 1226, 1283, 1333, 1494]], "test": "valid"}
{"id": "MdGfzW", "name": "A graph with some cool functions", "author": "JohnShadow", "description": "A colorful grid with some functions.\ncould use a better graphing function though...", "tags": ["grid", "color", "graph", "functions", "graphing"], "likes": 1, "viewed": 129, "published": "Public", "date": "1527753131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define epsilon 0.15\n#define epsilon2 0.25\n#define lineThickness 0.1\n#define pi 3.14159265359\nfloat scale = 1.0;\n#define rangeBounds(x,b,e) (x < (b+e) && x > (b-e) ? 1.0 : 0.0)\nvec3 grid(vec2 uv, vec3 colOpt1, vec3 colOpt2, vec3 colShadow)\n{\n    vec2 uvFract = fract(uv * scale);\n    \n    return    min(uvFract.x, uvFract.y) < epsilon ?  colOpt2\n\t\t\t: min(uvFract.x, uvFract.y) < epsilon2 ? colShadow\n            :\t\t\t\t\t\t\t\t\t\t colOpt1;\t\n}\nfloat c(float x, float r)\n{\n    float c = (sin(1.0-x*r)*cos(x*1.0-r));\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    \n    uv += vec2(sin(((iTime+2.0)/2.0) + 1.0),cos((iTime+2.0)/2.0));\n    \n    uv -= vec2(1.0,1.0);\n    \n    scale = 2.0*(sin(iTime)+5.0);\n    \n    vec3 col;\n    vec3 colOpt1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tvec3 colOpt2 = vec3(0.15,0.15,0.15);\n    vec3 colOpt3 = vec3(0.1,0.1,0.1);\n    col = grid(uv,colOpt1,colOpt2,colOpt3);\n    \n    float r1 = 0.5*pi;\n    float r2 = 0.25*pi;\n   \n\tfloat f1 = c(c(uv.x * scale,r1-pi),r2+pi);\n\tfloat f2 = c(c(uv.x * scale,pi-r1),pi-r2);\n\tfloat f3 = c(c(uv.x * scale,r1+pi),r2-pi);\n    float f4 = (f1+f2+f3)/3.0;\n    \n    uv += 2.0;\n   \tfloat m1 = c(c((uv.x + iTime) * scale,r1-pi),r2+pi);\n\tfloat m2 = c(c((uv.x + iTime) * scale,pi-r1),pi-r2);\n\tfloat m3 = c(c((uv.x + iTime) * scale,r1+pi),r2-pi);\n    float m4 = (f1+f2+f3)/3.0;\n    \n    col = mix(col, vec3(1.0), rangeBounds(uv.y * scale, m4, lineThickness));\n    uv -= 2.0;\n    col = mix(col, vec3(1.0), rangeBounds(uv.y * scale, f4, lineThickness));\n    col = mix(col, vec3(1.0), rangeBounds(uv.y * scale, 1./uv.x, lineThickness));\n    col = mix(col, vec3(1.0), rangeBounds(uv.y * scale, 10.*uv.x, lineThickness));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdGfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 241, 241, 435], [436, 436, 463, 463, 522], [523, 523, 580, 630, 1906]], "test": "valid"}
{"id": "MdKfRh", "name": "BlackWhite by SR", "author": "Shaderay", "description": "sdfdsf", "tags": ["sdfsdf"], "likes": 1, "viewed": 168, "published": "Public API", "date": "1527644993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat noise(in vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\t\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n\n#define OCTAVES 6 //adds detail\n        float turbulence (in vec2 st) {\n            // Initial values\n            float value = 0.30;\n            float amplitude = .47;\n            // Loop of octaves\n            for (int i = 0; i < OCTAVES; i++) {\n                value += amplitude * noise(st); // st* something adds detail\n                st *= 1.8; //changes shape\n                amplitude *= .46; //adds detail\n            }\n            return value;\n        }\n\n float pattern( in vec2 st, out vec2 q, out vec2 r, out vec2 s)\n          {\n              q.x = turbulence( st + vec2(3.0,1.0) );\n              q.y = turbulence( st + vec2(2.4,1.3) );\n\n              r.x = turbulence( st + 1.0*q +iTime*0.05 + vec2(1.7,9.2) );\n              r.y = turbulence( st + 1.0*q -iTime*0.005 + vec2(8.3,2.8) );\n\t\t\t\t\n              s.x = turbulence( st + 1.0*r + vec2(1.3,7.2) );\n              s.y = turbulence( st + 1.0*r + vec2(5.3,1.8) );  \n              \n              return turbulence( st + 1.5*s);}\n\n\n\n\n            \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n\tst.x *= iResolution.x/iResolution.y;\n    \n  \n    vec3 color = vec3(0.0);\n       \tvec2 q = vec2(0.);\n          \tvec2 r = vec2(0.);\n            vec2 s = vec2(0.);\n            color += pattern(st,q,r,s);\n\n    color *= 1.7; //makes lighter and darker\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 65, 65, 112], [113, 113, 134, 134, 181], [182, 182, 204, 204, 239], [241, 241, 309, 309, 352], [355, 355, 379, 432, 2130], [2173, 2173, 2204, 2234, 2598], [2601, 2601, 2675, 2675, 3126], [3145, 3145, 3202, 3252, 3576]], "test": "valid"}
{"id": "MdtBR8", "name": "Reflections of Reflections", "author": "felipunkerito", "description": "Mouse moves the camera.", "tags": ["raymarching", "reflection", "sdf", "reflections"], "likes": 4, "viewed": 656, "published": "Public API", "date": "1525302740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS      500\n#define FAR       50.0\n#define EPS       1e-3\n#define REFLECTIONS 10\n#define PI acos( -1.0 )\n#define TPI   PI * 2.0\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n// Uncomment for funky ass sphere\n//#define FUNKY\n// Comment for different scene\n#define SCENE\n// Comment for only XZ repetition\n#define REP\n#define WAV texture( iChannel0, vec2( 0.0, 0.45 ) ).x\n\n// Hash by Dave Hoskins\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash( float a )\n{\n\n\treturn fract( sin( a * 45932.92 ) * 234823.9 );\n\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = TPI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}  \n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n                );\n\n}\n\nvec3 twiY( vec3 p, float f )\n{\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.y == 0.0 ) mou.y = 0.4;\n    \n    float a = mou.y * p.y * f;\n    \n    p.xz = cos( a ) * p.xz + sin( a ) * vec2( -p.z, p.x );\n    \n    return p;\n\n}\n\nvec3 twiX( vec3 p, float f )\n{\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.x == 0.0 ) mou.x = 0.5;\n    \n    float a = mou.x * p.x * f;\n    \n    p.yz = cos( a ) * p.yz + sin( a ) * vec2( -p.z, p.y );\n    \n    return p;\n\n}\n\nfloat sph( vec3 p ) \n{\n    \n    return length( p ) - 1.3;\n\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    \n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\n}\n\nfloat sph( vec3 p, float r )\n{\n\n    return length( p ) - r;\n\n}\n\nfloat pla( vec3 p, float d )\n{\n\n    return p.y + d;\n\n}\n\nvec3 modd( vec3 p, float siz )\n{\n    \n    float hal = siz * 0.5;\n    \n    if( iMouse.z < 0.0 || iMouse.x == 0.0  )\n    {\n    \n        p = mod( p, siz ) - hal;\n        \n    }\n    \n    else\n    {\n    \n        p = mod( p + hal, siz ) - hal;\n    \n    }\n    \n    return p;\n\n}\n\nvec2 map( vec3 p, out vec3 id )   \n{\n\n    #ifdef SCENE\n    \n    float rO = 1.0 + 0.15 * cos( 10.0 * p.x + iTime ) * cos( 10.0 * p.y + iTime ) * cos( 10.0 * p.z + iTime );\n    \n    float tileSize = 6.5;\n    \n    if( iMouse.z < 0.0 || iMouse.x == 0.0  )\n    {\n    \n        id = vec3( int( p.x / tileSize ), int( p.y / tileSize ), int( p.z / tileSize ) );\n        \n    }\n    \n    else\n    {\n    \n        id = vec3( int( p.x / ( tileSize + tileSize * 0.5 ) ), int( p.y / ( tileSize + tileSize * 0.5 ) ), int( p.z / ( tileSize + tileSize * 0.5 ) ) );\n    \n    }\n    \n    \n    //id = vec3( int( p.x / tileSize ), int( p.y / tileSize ), int( p.z / tileSize ) );\n    \n    vec3 pO = p;\n    \n    #ifdef REP\n    \n    pO = modd( p, tileSize );\n    \n    #else\n    \n    pO.xz = mod( pO.xz, tileSize ) - tileSize * 0.5;\n    \n    #endif\n    \n    #ifdef FUNKY\n    \n    vec2 sdSph = vec2( sph( pO, rO ), 0.0 );\n    \n    #else\n    \n    vec2 sdSph = vec2( sph( pO, 1.0 + WAV + hash13( id * WAV ) ), 0.0 );\n    \n    #endif\n    \n    vec2 sdPla = vec2( pla( p, 0.9 ), 1.0 );\n    \n    if( sdSph.x < sdPla.x ) sdPla = sdSph; \n    \n    #ifdef REP\n    \n    return sdSph;\n    \n    #else\n    \n    return sdPla;\n    \n    #endif\n    \n    #else\n    \n    vec2 pla = vec2( pla( p, 2.0 ), 1.0 );\n    vec2 cubO = vec2( sdBox( p - vec3( 0.0, 0.0, -1.5 ), vec3( 3.0, 3.2, 0.2 ) ), 0.0 );\n    vec2 cubT = vec2( sdBox( p - vec3( 3.0, 0.0, 0.0 ), vec3( 0.2, 3.2, 3.2 ) ), 0.0 );\n    vec2 cubTh = vec2( sdBox( p - vec3( -3.0, 0.0, 0.0 ), vec3( 0.2, 3.2, 3.2 ) ), 0.0 );\n    p = twiX( p, 2.0 );\n    p = twiY( p, 2.0 );\n    vec2 cub = vec2( sdBox( p, vec3( 1.0 ) ), 0.0 );\n    vec2 sds = vec2( sph( p ), 0.0 );\n    vec2 fin = max( -sds, cub );\n    \n    if( pla.x < fin.x ) fin = pla;    \n    if( fin.x < cubO.x ) cubO = fin;\n\tif( cubO.x < cubT.x ) cubT = cubO;\n    if( cubT.x < cubTh.x ) cubTh = cubT;\n    \n    vec2 one =  min( cubO, fin );\n    vec2 two = min( one, cubT );\n    \n    return cubTh;\n    \n    #endif\n\n}\n\nvec3 norm( vec3 p )\n{\n\n\tvec2 e = vec2( EPS, 0.0 ); vec3 id = vec3( 0 );\n    return normalize(  vec3( map( p + e.xyy, id ).x - map( p - e.xyy, id ).x, \n                             map( p + e.yxy, id ).x - map( p - e.yxy, id ).x,\n                             map( p + e.yyx, id ).x - map( p - e.yyx, id ).x\n                            ) \n                     );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0; vec3 id = vec3( 0 );\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        #ifdef SCENE\n        \n        d = 0.5 * map( ro + rd * t, id ).x;\n        \n        #else \n        \n        d = 0.5 * map( ro + rd * t, id ).x;\n        \n        #endif\n        \n        if( d < EPS || t > FAR ) break;\n        t += d;\n    \n    }\n    \n    return t;\n\n}\n\nvec3 sha( vec3 ro, vec3 rd )\n{\n      \n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    vec3 lig = vec3( 0 );\n    vec3 id = vec3( 0 );\n    vec2 ma = map( p, id );\n    \n    #ifdef SCENE\n    \n    if( iMouse.z > 0.0 )\n    {\n        \n        lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    \n    }\n    \n    else\n    {\n    \n        lig = normalize( vec3( 0.0, iTime, 0.0 ) );\n        lig.zy *= rot( iTime * 0.1 );\n        lig.xz *= rot( iTime * 0.1 );\n    \n    }\n    \n    #else\n    \n    lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    \n    #endif\n        \n    vec3 ref = reflect( rd, n );\n   \n    float dif = max( 0.0, dot( n, lig ) );\n    float amb = 0.5 + 0.5 * n.y;\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 32.0 );\n    float rim = pow(1.0+dot(n,rd),3.0);\n    \n    vec3 col = vec3( 0.0 );\n    \n    col += 0.5 * amb + 0.4 * dif + 1.0 * spe + 0.1 * rim;\n    \n    #ifdef SCENE\n    \n    //col += 0.5 * hash( id.x + id.y + id.z );\n    \n    float fre = texture( iChannel0, vec2( 0.0, 0.1 ) ).x * 0.05;\n    \n    col -= 0.5 * hash( id );\n    \n    #else\n    \n    if( map( p, id ).y == 0.0 ) col *= n;\n    \n    #endif    \n    \n    #ifdef REP\n    \n    #else\n    \n    if( map( p, id ).y == 1.0 ) col = vec3( 0.5 );\n    \n    #endif\n        \n    return col;\n\n}\n\nfloat rar( vec3 ro, vec3 rd, out float d )\n{\n\n    vec3 col = vec3( 0.0 ), id = vec3( 0 );\n    float t = 0.0;\n    for( int i = 0; i < 64; ++i )\n    {\n    \n    \td = 0.5 * map( ro + rd * t, id ).x;\n        if( d < EPS || t > FAR ) break;\n        t += d;\n        \n    }\n\n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    vec3 rd = normalize( vec3( uv, -1.0 ) );\n        \n    #ifdef SCENE\n    \n    if( iMouse.z > 0.0 )\n    {\n        \n        ro = vec3( 0.0, 0.0, 2 );\n        ro.zy *= rot( mou.y * TPI );\n        rd.zy *= rot( mou.y * TPI );\n        ro.xz *= rot( mou.x * TPI );\n        rd.xz *= rot( mou.x * TPI );\n    \n    }\n    \n    else\n    {\n    \n        ro = vec3( 0.0, iTime, 0.0 );\n        ro.zy *= rot( iTime * 0.01 );\n        rd.zy *= rot( iTime * 0.02 );\n        ro.xz *= rot( iTime * 0.01 );\n        rd.xz *= rot( iTime * 0.05 );\n    \n    }\n    \n    #else\n    \n    ro = vec3( 0.0, 0.0, 3.4 );\n    ro.zy *= rot( mou.y * TPI );\n    rd.zy *= rot( mou.y * TPI );\n    ro.xz *= rot( mou.x * TPI );\n    rd.xz *= rot( mou.x * TPI );\n    \n    #endif\n    \n    float d = 0.0, t = ray( ro, rd, d );\n    \n    vec3 p = ro + rd * t;\n    \n    vec3 n = norm( p );\n    \n    // Time varying pixel color\n    vec3 col = d < EPS ? sha( ro, rd ) : vec3( 0.0 ); vec3 id = vec3( 0 );\n    \n    #ifdef REP\n    \n    if( map( p, id ).y == 0.0 )\n        \n    for( int i = 0; i < REFLECTIONS; ++i )\n    {\n\n        rd = normalize( reflect( rd, n ) );\n        float dO = 0.0;\n        float tO = rar( ro, rd, dO );\n        p += rd * tO;\n        ro = p + rd * tO;\n\n        if( d < EPS ) col += 0.025 * sha( ro, rd );\n        \n    }\n    \n    #else\n    \n   // ro = vec3( 0, 2, 2 );\n        \n    for( int i = 0; i < REFLECTIONS; ++i )\n    {\n\n        rd = normalize( reflect( rd, n ) );\n        float dO = 0.0;\n        float tO = rar( ro, rd, dO );\n        p += rd * tO;\n        ro = p + rd * tO;\n\n        if( d < EPS ) col += 0.025 * sha( ro, rd );\n        \n    }\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4s2XWV", "previewfilepath": "https://soundcloud.com/engin-ee/crystal-castles-crimewave", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/engin-ee/crystal-castles-crimewave", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 429, 449, 449, 559], [561, 561, 584, 584, 692], [694, 694, 717, 717, 770], [772, 885, 935, 935, 1324], [1328, 1328, 1349, 1349, 1447], [1449, 1449, 1479, 1479, 1686], [1688, 1688, 1718, 1718, 1925], [1927, 1927, 1949, 1949, 1987], [1989, 1989, 2020, 2020, 2117], [2119, 2119, 2149, 2149, 2181], [2183, 2183, 2213, 2213, 2237], [2239, 2239, 2271, 2271, 2509], [2511, 2511, 2547, 2547, 4482], [4484, 4484, 4505, 4505, 4847], [4849, 4849, 4893, 4893, 5255], [5257, 5257, 5287, 5287, 6566], [6568, 6568, 6612, 6612, 6851], [6853, 6853, 6910, 6910, 8762]], "test": "error"}
{"id": "MdtfD2", "name": "fork of quinn's angelss", "author": "Crackhausen", "description": "fork of qunns angels", "tags": ["angels"], "likes": 1, "viewed": 472, "published": "Public API", "date": "1526885473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+12.0;\n    vec2 o = floor( 0.5 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+2.0)/23., 1.0 )*50.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n    for( int i=0; i<16; i++ )\n    {\n        p = roma*abs(p);\n        p.y-= 1.0;\n    }\n    float d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2(d,h );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 140.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<200; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 2.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*0.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.8,0.9,1.0)*(0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = intersect(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = 0.5 + 0.5*mix( sin( vec3(1.2,1.1,1.0)*tmat.y*3.0 ),\n                                  sin( vec3(1.2,1.1,1.0)*tmat.y*6.0 ),\n                                  1.0-abs(nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = 0.8 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        // lights\n        vec3 brdf = vec3(0.0);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        vec3 sun = vec3(1.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 32.0 );\n        col += sun;\n        dis = 140.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 22.1 * hash1(fc);\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t,1.0,10.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(1.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    col += 0.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(0.7645) );\n    // contrast/brightness\n    col = 1.3*col+0.1;\n    // tint\n    col *= vec3( 1.0, 1.04, 1.0);\n\n     return col-.04;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.15);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    // camera\n    float an = 2.5 + 0.12*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize(sin(iTime-6.)+ ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.2*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 3.0, 2.03/iMouse.x, 14.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, fragCoord );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 62], [64, 64, 87, 87, 137], [139, 139, 162, 162, 256], [258, 299, 338, 338, 720], [769, 769, 789, 806, 1383], [1385, 1385, 1427, 1427, 1770], [1772, 1772, 1804, 1804, 2019], [2021, 2021, 2086, 2086, 2340], [2342, 2342, 2384, 2384, 2732], [2778, 2778, 2829, 2843, 5087], [5089, 5089, 5146, 5146, 5972], [5974, 5974, 6068, 6068, 6235]], "test": "valid"}
{"id": "MdtfDl", "name": "isovalues 4", "author": "FabriceNeyret2", "description": "reference: [url]https://www.the-scientist.com/May2018/Abstract-3d.jpg[/url]\nadapting [url]https://shadertoy.com/view/ldfcRS[/url] + 3D + pseudo depth of field", "tags": ["noise", "dof", "depthoffield", "contour"], "likes": 43, "viewed": 837, "published": "Public API", "date": "1527279714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/ldfcRS\n\n// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    vec2 u = U/iResolution.y;\n    U = 6.*u - iTime;\n    O -= O; \n  // O += noise(vec3(U*4.,0)); return;\n    for (float z=0.; z<=1.; z+=.1, U.y -= .2) { // consider 1 isovalue per altitude\n        float n = ( 1.8*noise(vec3(U.x-U.y*.1,U.y/.6,.0*iTime)) -.8 -.2) / .6,\n              v = smoothstep(1.5+12.*abs(u.y-.5),0., abs(n-z)/fwidth(n));\n                 // /12./abs(u.y-.5);\n\t // O += v * vec4(.5,1,1,1);\n\t    O += v * (.5+.5*cos(6.3*n + vec4(0,23,21,0) ));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 183, 207, 207, 770], [867, 867, 936, 936, 1406]], "test": "valid"}
{"id": "MdtfDN", "name": "Humanoid Silhouettes 3D", "author": "TekF", "description": "Applying my 2D human silhouettes to billboards to put them in 3D space.\n", "tags": ["2d", "sdf", "billboard", "human", "figure", "people"], "likes": 15, "viewed": 968, "published": "Public API", "date": "1525336268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cheap 2D humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nfloat RoundMax( float a, float b, float r )\n{\n    a += r; b += r;\n    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);\n    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r )\n{\n    return -RoundMax(-a,-b,r);\n}\n\n// Humanoid, feet placed at <0,0>, with height of ~1.8 units on y\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    //torso += .2*(1.-cos((uv.y-1.)*3.));\n    //torso = RoundMax( torso, abs(uv.y-1.1)-.4, .2*(uv.y-.7)/.8 );\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.2*Rand(2));\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    return max( f, -uv.y );\n}\n\n\n// return: distance to intersection, sdf value (negative = solid)\nvec2 StandIn( in vec3 footPos, in float seed, in vec3 rayStart, in vec3 rayDir )\n{\n    footPos -= rayStart; // do everything relative to rayStart\n    \n    // construct a vertical plane through footPos, facing the camera\n    vec3 n = normalize( vec3(1,0,1)*footPos );\n    float d = dot(n,footPos);\n    \n    float intersectionDistance = d/dot(n,rayDir);\n    \n    vec3 pos = rayDir*intersectionDistance;\n    pos -= footPos;\n    vec2 uv = vec2( dot(pos,normalize(cross(vec3(0,1,0),rayDir))), pos.y );\n    float sdfValue = Humanoid( uv, seed );\n    \n    return vec2( intersectionDistance, sdfValue );\n}\n\n\nstruct Camera {\n    vec3 pos;\n    vec3 target;\n    float zoom;\n};\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tCamera cam;\n    cam.pos = vec3(sin(iTime/4.)*4.,3.+1.*sin(iTime*1.618/5.),-6.+2.*cos(iTime*.618/2.));\n    cam.target = vec3(1,1,6.);//-4.*cos(iTime/4.));\n    cam.zoom = 1.7;\n    \n    vec3 ray = vec3( ( fragCoord-iResolution.xy*.5 ) / iResolution.y, cam.zoom );\n    \n    vec3 k = normalize( cam.target - cam.pos );\n    vec3 i = normalize( cross( vec3(0,1,0), k ) );\n    vec3 j = cross(k,i);\n    \n    ray = ray.x*i + ray.y*j + ray.z*k;\n\n    vec3 standIns[] = vec3[](\n        vec3(7,1,11),\n        vec3(6.5,1,10.8),\n        vec3(8,1,10),\n        vec3(-1.7,1,5),\n        vec3(-1.2,1,4.5),\n        vec3(-2,1,4),\n        vec3(-2.5,.5,3),\n        vec3(2,1,3),\n        vec3(1,1,2),\n        vec3(0,1,2),\n        vec3(4,0,3),\n        vec3(4,0,1.5),\n        vec3(3,0,2),\n        vec3(3,0,1),\n        vec3(1,0,.5),\n        vec3(0)\n    );\n    \n    fragColour = vec4(1);\n    for ( int i=0; i < standIns.length(); i++ )\n    {\n    \tvec2 hit = StandIn( standIns[i], float(i), cam.pos, ray );\n\t    float aa = hit.x*2./(iResolution.x*cam.zoom); // soften the edges proportional to pixel size\n        // this blend assumes we've depth-sorted the things, because I'm being lazy\n        fragColour = mix( fragColour, vec4(1.-exp2(-hit.x/12.)), smoothstep(aa,-aa,hit.y) );// .5-.5*(hit.y/(abs(hit.y)+.002)) );\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtfDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[0, 263, 308, 308, 421], [423, 423, 468, 468, 501], [503, 569, 615, 615, 1706], [1709, 1775, 1857, 1857, 2372], [2442, 2442, 2500, 2500, 3796]], "test": "error"}
{"id": "MdtfRf", "name": "Simple noise practice", "author": "wzrd", "description": "Practice shader to learn more about procedural noise.", "tags": ["practicenewbie"], "likes": 2, "viewed": 276, "published": "Public", "date": "1526246662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p){\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = fract(uv * 10.);\n    vec2 id = floor(uv * 10.);\n    \n    lv = lv * lv * (3. -2. * lv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv += iTime * .1;\n    \n    vec3 col = vec3(SmoothNoise(uv));\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtfRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 77], [79, 79, 106, 106, 446], [448, 448, 505, 555, 732]], "test": "valid"}
{"id": "MdyfzD", "name": "Atmospheric Maze", "author": "NuSan", "description": "Raymarching scene of an infinite maze on a strange planet. The maze is not certified to be traversable...", "tags": ["3d", "raymarch", "maze"], "likes": 16, "viewed": 276, "published": "Public", "date": "1527779211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define KALEIDO 0\n#define MAXSTEPS 200\n#define SHADOWSTEPS 20\n\n#define v2Resolution iResolution\n#define out_color fragColor\n#define time iTime\n\n#define pi 3.141592\n\nfloat rnd(float a) {\n  return fract(sin(a*1328.478+3212.6534)*9863.1243986);\n}\n\nfloat rnd(vec2 a) {\n  return fract(dot(sin(a*vec2(1328.478,4351.3254)+a.yx*vec2(421.675,435.128)+vec2(3212.6534,9673.432)),vec2(9863.1243986,8765.34214)));\n}\n\nfloat plane(vec3 p, vec3 n, float v) {\n    return dot(p,n)-v;\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n  return length(max(abs(p)-s,0.0f))-.005;\n}\n\nfloat smin(float a,float b,float h) {\n  float k=clamp(0.5+0.5*(a-b)/h,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nfloat smax(float a,float b,float h) {\n  float k=1.0-clamp(0.5+0.5*(a-b)/h,0.0,1.0);\n  return mix(a,b,k)+k*(1.0-k)*h;\n}\n\nvec3 rep(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nvec3 repid(vec3 p, vec3 s) {\n  return floor(p/s+0.5);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a*pi);\n  float sa=sin(a*pi);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat block(vec3 p, float s, float s2, vec2 rr) {\n  vec3 b0 = rep(p, vec3(s,1.0,s));\n\n  vec2 id=repid(p, vec3(s,1.0,s)).xz;\n  float a=rnd(id+rr);\n  float b=rnd(id.yx+rr.yx);\n\n  b0.xz*=rot(floor(a*4.0)*0.5);\n  vec3 b0b=b0;\n  //b0b.xz*=rot(floor(b*3.0+1.0)*0.5);\n  b0b.xz*=rot(b>0.5?1.0:b>0.25?0.5:1.5); // more straight lines than turns\n\n  float ms2=(p.y>0.25)?s2:(b>0.65?s2*2.0:s2); // may produce cross lines\n  vec3 bsize=vec3(ms2,s2,0)+vec3(0.02);\n  vec3 boff=vec3(ms2,0,0);\n\n  float b1=box(b0-boff,bsize);\n  float b2=box(b0b-boff,bsize);\n\n  float final=min(b1,b2);\n  return final;\n}\n\nfloat map(vec3 p) {\n  \n  float d=plane(p,vec3(0,1,0),-0.15);\n\n  float s=(p.y>0.25)?1.6:0.4;\n  float s2=(p.y>0.25)?0.2:0.05;\n  float s3=0.02;\n  vec2 off=vec2(0,0.2);\n\n  float b0 = block(p, s,s2, vec2(0));\n  float b1 = block(p+off.yxx, s,s2, vec2(7845.356,134.623));\n  float b2 = block(p+off.xxy, s,s2, vec2(964.2365,123.658));\n  float b3 = block(p+off.yxy, s,s2, vec2(2761.986,347.642));\n\n  d=min(d,b0);\n  d=min(d,b1);\n  d=min(d,b2);\n  d=min(d,b3);\n\n  d=smin(d, plane(p,vec3(0,1,0),-0.05), 0.02);\n  //d=max(d,-plane(p,vec3(0,-1,0),-1.0));\n\n  return d;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0,0.001);\n  return normalize(map(p)-vec3(map(p+off.yxx),map(p+off.xyx),map(p+off.xxy)));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n  vec3 p=ro;\n  for(int i=0; i<MAXSTEPS; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      break;\n    }\n    p+=d*rd*0.5;\n  }\n\n  return p;\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n  float md=1.0;\n  int steps=SHADOWSTEPS;\n  float s=0.2/float(steps);\n  float t=0.01;\n  for(int i=0; i<steps; ++i) {\n    float d=map(ro+rd*t);\n    md=min(md,4.0*d/t);\n    if(d<0.0001) {\n      //md=0.0;\n      break;\n    } \n    t+=s;\n  }\n\n  return md;\n}\n\nfloat ambient(vec3 p, vec3 n) {\n    \n    float scale = 0.02;\n    float d = scale;\n    vec3 pos = p - n * d;\n\n    float fac = 1.0;\n\n    for( int i=0; i<5; ++i) {\n    \n        float str = 5.5/float(1+i);\n        fac *= 1.0-clamp((d-map(pos))*str,0.0,1.0);\n        pos -= n * scale;\n        d += scale;\n    \n    }\n\n    return fac;\n}\n\nvec2 mir(vec2 uv, float a) {\n  mat2 ra=rot(a);\n  uv*=ra;\n  uv.x=abs(uv.x);\n  uv*=ra;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / v2Resolution.x, fragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n #if KALEIDO\n  float mt=time*0.2;\n  uv=mir(uv,mt);\n  uv=mir(uv,-mt*0.3);\n  uv=mir(uv,mt*.5);\n  uv=mir(uv,-mt*.1);\n  float ma=time*0.5;\n  uv+=abs(vec2(cos(ma),sin(ma)))*0.5;\n #endif\n\n\n  float ct=time*0.2;\n  vec3 parc=vec3(0,0,ct);\n  vec3 cam=vec3(cos(ct),0.2,sin(ct))*1.0+parc;\n  vec3 ta=vec3(0,-0.3 + sin(ct*1.2)*0.4 + 0.3,0)+parc;\n  vec3 cz=normalize(ta-cam);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cx,cz));\n\n  vec3 ro=cam;\n  vec3 rd=normalize(uv.x*cx+uv.y*cy+cz);\n\n  vec3 p=march(ro,rd);\n\n  float depth=length(p-ro);\n  vec3 n=norm(p);\n\n  vec3 col=vec3(0);\n  \n  vec3 ldir=normalize(vec3(0.2,-0.7,0.4));\n\n  float shadd=shadow(p,-ldir);\n\n  float shad=clamp(shadd,0.0,1.0);\n\n  float lum=max(0.0, dot(n,ldir));\n  col += lum*shad*vec3(1.0,0.8,0.5);\n\n  float ao=ambient(p, n);\n\n  col += ao*0.6*vec3(0.4,0.5,0.7);\n  \n  //col *= min(vec3(1.0)/(depth*depth),vec3(1.0));\n  //col=vec3(shad);\n\n  //col=vec3(ao);\n\n  col += exp(-vec3(1.9,1.5,1.2)/depth);\n\n  out_color = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdyfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 185, 185, 243], [245, 245, 264, 264, 402], [404, 404, 442, 442, 467], [469, 469, 497, 497, 521], [523, 523, 550, 550, 594], [596, 596, 633, 633, 710], [712, 712, 749, 749, 830], [832, 832, 858, 858, 893], [895, 895, 923, 923, 950], [952, 952, 971, 971, 1046], [1048, 1048, 1097, 1097, 1633], [1635, 1635, 1654, 1654, 2187], [2189, 2189, 2208, 2208, 2315], [2317, 2317, 2347, 2347, 2487], [2489, 2489, 2521, 2521, 2772], [2774, 2774, 2805, 2805, 3103], [3105, 3105, 3133, 3133, 3204], [3206, 3206, 3263, 3263, 4409]], "test": "valid"}
{"id": "Ms3fWB", "name": "Palladio's Detector", "author": "dr2", "description": "Classical design for a CERN particle detector using repeated hollowed-out mandelboxes (mouseable)", "tags": ["fractal", "mandelbox"], "likes": 13, "viewed": 784, "published": "Public API", "date": "1526545453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Palladio's Detector\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nvec3 HsvToRgb (vec3 c);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos[2], ltAx;\nfloat tCur, dstFar;\nconst float pi = 3.14159;\nconst float itMax = 12.;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 p4;\n  float d;\n  p = mod (p + 3., 6.) - 3.;\n  p4 = vec4 (p, 1.);\n  for (float j = 0.; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    p4 = 2.8 * p4 / clamp (dot (p4.xyz, p4.xyz), 0.25, 1.) + vec4 (p, 1.);\n  }\n  d = max (max (length (p4.xyz) / p4.w, - PrBoxDf (p, vec3 (0.33))),\n     - Minv3 (vec3 (PrRoundBox2Df (p.xy, vec2 (0.05), 0.03),\n     PrRoundBox2Df (p.yz, vec2 (0.05), 0.03), PrRoundBox2Df (p.zx, vec2 (0.05), 0.03))));\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0005;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 120; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (ObjDf (ro + s * rd) > eps) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (3. * h, 0.02, 0.1);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = 1.; j < 4.; j ++) {\n    d = 0.02 * j;\n    ao += max (0., d - ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - 5. * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec3 p3, col;\n  float pp, ppMin, cn, s;\n  p = mod (p + 3., 6.) - 3.;\n  p3 = p;\n  cn = 0.;\n  ppMin = 1.;\n  for (float j = 0.; j < itMax; j ++) {\n    p3 = 2. * clamp (p3, -1., 1.) - p3;\n    pp = dot (p3, p3);\n    if (pp < ppMin) {\n      cn = j;\n      ppMin = pp;\n    }\n    p3 = 2.8 * p3 / clamp (pp, 0.25, 1.) + p;\n  }\n  s = mod (cn, 2.);\n  col = HsvToRgb (vec3 (mod (0.6 + 1.5 * cn / itMax, 1.), mix (0.6, 0., s), 1.));\n  return vec4 (col, 0.05 + 0.4 * s);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnn, ltDir, rds;\n  float dstObj, atten, dfSum, spSum, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vnn = VaryNf (256. * ro, vn, 0.2);\n    dfSum = 0.;\n    spSum = 0.;\n    for (int k = 0; k < 2; k ++) {\n      ltDir = ltPos[k] - ro;\n      atten = 1. / (1. + 0.1 * dot (ltDir, ltDir));\n      ltDir = normalize (ltDir);\n      atten *= smoothstep (0.3, 0.5, dot (ltAx, - ltDir));\n      dfSum += atten * max (dot (vnn, ltDir), 0.);\n      spSum += atten * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n    }\n    ltDir = normalize (0.5 * (ltPos[0] + ltPos[1]) - ro);\n    sh = ObjSShadow (ro, ltDir, max (dstObj - 0.2, 0.));\n    col4 = ObjCol (ro);\n    col = (0.1 + 0.4 * sh * dfSum) * col4.rgb + col4.a * sh * spSum * vec3 (1., 1., 0.9);\n    col *= ObjAO (ro, vn);\n    col += vec3 (0., 0.2, 0.) * max (dot (- rd, vn), 0.) *\n       (1. - smoothstep (0., 0.05, abs (dstObj - mod (0.5 * tCur, 3.))));\n    col *= mix (1., smoothstep (0., 1., Maxv3 (col)), 0.3);\n  } else {\n    if (rd.y < 0.) {\n      rd.y = - rd.y;\n      rd.xz = vec2 (- rd.z, rd.x);\n    }\n    rds = floor (2000. * rd);\n    rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n    for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n    col = vec3 (0.02, 0.02, 0.05) + 0.5 * vec3 (1., 1., 0.7) * min (1., 0.5e-3 *\n       pow (min (6., length (rds)), 5.));\n  }\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  p = vec3 (6. * floor (t / 18.));\n  t = mod (t, 18.);\n  if (t < 6.) p += vec3 (0., 0., t);\n  else if (t < 12.) p += vec3 (t - 6., 0., 6.);\n  else p += vec3 (6., t - 12., 6.);\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, cs;\n  float el, az, spd, t, tm, ts;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 0.2;\n  ro = TrackPath (spd * tCur);\n  vd = normalize (TrackPath (spd * tCur + 0.7) - TrackPath (spd * tCur - 0.7));\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  }\n  t = spd * tCur / 18.;\n  tm = mod (3. * t, 1.);\n  ts = 2. * step (1., mod (t, 2.)) - 1.;\n  if (max (abs (vd.x), abs (vd.z)) > 0.5) {\n    az += 0.5 * pi * SmoothBump (0.3, 0.7, 0.15, tm) * ts;\n    if (abs (vd.z) > 0.5) vd.yz = Rot2D (vd.yz, el);\n    else if (abs (vd.x) > 0.5) vd.yx = Rot2D (vd.yx, el);\n  }\n  if (abs (vd.y) < 1. - 1e-5) {\n    vd.xz = Rot2D (vd.xz, az);\n    vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n       vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  } else {\n    az += 2. * pi * smoothstep (0.3, 0.7, tm) * ts;\n    cs = sin (az + vec2 (0.5 * pi, 0.));\n    vuMat = mat3 (vec3 (cs.x, 0., - cs.y), vec3 (cs.y, 0., cs.x), vec3 (0., vd.y, 0.));\n  }\n  ltPos[0] = ro + vuMat * vec3 (-0.3, 0.2, -0.05);\n  ltPos[1] = ro + vuMat * vec3 (0.3, 0.2, -0.05);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 80.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 2.));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = pow (clamp (col, 0., 1.), vec3 (0.9));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3fWB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 561, 583, 583, 1060], [1062, 1062, 1095, 1095, 1535], [1537, 1537, 1558, 1558, 1758], [1760, 1760, 1809, 1809, 2067], [2069, 2069, 2101, 2101, 2284], [2286, 2286, 2308, 2308, 2768], [2770, 2770, 2805, 2805, 4251], [4253, 4253, 4279, 4279, 4479], [4481, 4481, 4537, 4537, 6311], [6313, 6313, 6345, 6345, 6445], [6447, 6447, 6494, 6494, 6541], [6543, 6543, 6567, 6567, 6684], [6686, 6686, 6743, 6743, 6826], [6828, 6828, 6850, 6850, 6888], [6890, 6890, 6912, 6912, 6950], [6952, 6952, 6982, 6982, 7095], [7129, 7129, 7153, 7153, 7283], [7285, 7285, 7309, 7309, 7529], [7531, 7531, 7556, 7556, 7742], [7744, 7744, 7769, 7769, 7994], [7996, 7996, 8025, 8025, 8237], [8239, 8239, 8278, 8278, 8458]], "test": "error"}
{"id": "Ms3fWf", "name": "Air streams", "author": "WAHa_06x36", "description": "A quick bit of therapeutic shader coding. Use the mouse to look around, if you want.", "tags": ["tunnel", "air", "flying"], "likes": 7, "viewed": 440, "published": "Public API", "date": "1526992751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getSkyColor(vec3 e) {\n\tfloat skyY = max(e.y, 0.0);\n\tfloat cloudY = max(-e.y, 0.0);\n\treturn vec3(\n\t\tpow(1.0 - skyY, 2.0),\n\t\t1.0 - skyY,\n\t\t0.6 + (1.0 - skyY) * 0.4\n\t) * mix(vec3(1.0), vec3(0.8, 0.8, 0.85), cloudY);\n}\n\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x), cos(ang.x));\n\tvec2 a2 = vec2(sin(ang.y), cos(ang.y));\n\tvec2 a3 = vec2(sin(ang.z), cos(ang.z));\n\treturn mat3(\n\t\tvec3(a1.y * a3.y + a1.x * a2.x * a3.x, a1.y * a2.x * a3.x + a3.y * a1.x, -a2.y * a3.x),\n\t\tvec3(-a2.y * a1.x, a1.y * a2.y, a2.x),\n\t\tvec3(a3.y * a1.x * a2.x + a1.y * a3.x, a1.x * a3.x - a1.y * a3.y * a2.x, a2.y * a3.y)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse == vec2(0.0)) mouse = vec2(0.5);\n\tvec3 ang = vec3( 0.0, -(mouse.y - 0.5) * 3.14159265 * 1.0, mouse.x * 3.1415926535 * 2.0);\n\tvec3 pos = vec3(0.0,0.0,0.0);\n\tvec3 dir = normalize(vec3(p.xy, -2.0 + length(p) * 0.15)) * fromEuler(ang);\n\t\n\tvec3 sky = getSkyColor(dir);\n\n\tvec3 color = sky;\n\tfor(int i = 1; i < 16; i++) {\n\t\tfloat r = float(i) * 1.0 + 0.33;\n\t\tfloat z = r * dir.z / length(dir.xy);\n\t\tfloat a = atan(dir.y, dir.x);\n\t\tfloat pattern = sin(a * (4.0 * float(i)) + sin((z + iTime * 20.0 + float(i)) * 0.5 / (float(i) + 2.0)) * 3.0);\n\t\tcolor *= (1.0 + pow((pattern + 1.0) * 0.5, 4.0) * 0.1 / (length(vec2(abs(z), r)) + 5.0));\n\t}\n\t\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms3fWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 219], [221, 221, 247, 247, 609], [611, 611, 668, 668, 1494]], "test": "valid"}
{"id": "MscBDN", "name": "Not Sure", "author": "chandlercr", "description": "Nothing much to say", "tags": ["pixels"], "likes": 0, "viewed": 83, "published": "Public", "date": "1525199085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* Exercise 4\n * Tutorial Courtesy of Jamie Wong\n *\n * Exercise\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *  and the geometric primitives. Remember you can use vector subtraction for translation,\n *  and component-wise vector multiplication for scaling.\n */\n \nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n \n/**\n * Rotation matrix around the X axis.\n */\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 path( float t )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 10. + 4.0*sin(0.05*t), p.y );   \n}\n\nfloat hash( vec2 p )\n{\n    float h = dot(p,vec2(127.1,311.7));\n    \n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nmat3 rotateX(float theta) {\n   float c = cos(theta);\n   float s = sin(theta);\n   return mat3(\n       vec3(1, 0, 0),\n       vec3(0, c, -s),\n       vec3(0, s, c)\n   );\n}\n \n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n   float c = cos(theta);\n   float s = sin(theta);\n   return mat3(\n       vec3(c, 0, s),\n       vec3(0, 1, 0),\n       vec3(-s, 0, c)\n   );\n}\n \n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n   float c = cos(theta);\n   float s = sin(theta);\n   return mat3(\n       vec3(c, -s, 0),\n       vec3(s, c, 0),\n       vec3(0, 0, 1)\n   );\n}\n \n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n   return max(distA, distB);\n}\n \n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n   return min(distA, distB);\n}\n \n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n   return max(distA, -distB);\n}\n \n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n   vec3 d = abs(p) - (size / 2.0);\n   \n   // Assuming p is inside the cube, how far is it from the surface?\n   // Result will be negative or zero.\n   float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n   \n   // Assuming p is outside the cube, how far is it from the surface?\n   // Result will be positive or zero.\n   float outsideDistance = length(max(d, 0.0));\n   \n   return insideDistance + outsideDistance;\n}\n \n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n   return length(p) - r;\n}\n\n// I need to make this a heart somehow\n// https://www.shadertoy.com/new\n// https://www.shadertoy.com/view/XsVGzK\nfloat heartSDF(vec3 p, float r) {\n   \n\n    mat4 m = mat4( 1.0 );\n    m[ 3 ] = vec4( 1.0, 1., 2. * ( sin( 1.0 * iTime ) * 0.5 + 0.5 ) , 1.0 );\n    vec3 c = vec3( 10, 10,10 );\n\tp = mod( p, c ) - 0.5 * c;\n    p = ( m * vec4( p, .5 ) ).xyz;\n    \n    //float oval = length( p + vec3( 0, 7. * r / 3., 0 ) ) - 4. * r / 3. - p.y / 2.8;\n    //float sphereLeft = length( p + vec3( r, r/3., 0 ) ) - r;\n    //float sphereRight = length( p + vec3( -r , r/3., 0 ) ) - r;\n    \n    //return smin( min( sphereLeft, sphereRight ), oval, 1.8 ); \n    \n   return length(p) - r;\n}\n\n/*\nfloat heart( vec3 pos, vec3 origin, float r ) \n{\n    mat4 m = mat4( 1.0 );\n    m[ 3 ] = vec4( 1.0, 1., 2. * hash( origin.zy ) * ( sin( 25.0 * iTime ) * 0.5 + 0.5 ) , 1.0 );\n    vec3 c = vec3( 15, 20, 20 );\n\tpos = mod( pos, c ) - 0.5 * c;\n    pos = ( m * vec4( pos, 1. ) ).xyz;\n    \n    float oval = length( pos - origin + vec3( 0, 7. * r / 3., 0 ) ) - 4. * r / 3. - pos.y / 2.8;\n    float sphereLeft = length( pos - origin + vec3( r, r/3., 0 ) ) - r;\n    float sphereRight = length( pos - origin + vec3( -r , r/3., 0 ) ) - r;\n    \n    return smin( min( sphereLeft, sphereRight ), oval, 1.8 ); \n}\n*/\n\n \n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n   // How far inside or outside the cylinder the point is, radially\n   float inOutRadius = length(p.xy) - r;\n   \n   // How far inside or outside the cylinder is, axially aligned with the cylinder\n   float inOutHeight = abs(p.z) - h/2.0;\n   \n   // Assuming p is inside the cylinder, how far is it from the surface?\n   // Result will be negative or zero.\n   float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n \n   // Assuming p is outside the cylinder, how far is it from the surface?\n   // Result will be positive or zero.\n   float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n   \n   return insideDistance + outsideDistance;\n}\n \n/**\n * Signed distance function describing the scene.\n *\n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {   \n   // Slowly spin the whole scene\n   samplePoint = rotateY(iTime / 2.0) * samplePoint;\n   \n    //Smaller Radius hole with staggered opening\n   //float cylinderRadius = ((1.0 - 0.2) * (cos(sin(1.7 * iTime))) / 2.0) - 0.25;\n   float cylinderRadius = ((1.0 - 0.1) * abs((sin(0.7 * iTime))) / 2.0);\n   float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n   float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n   float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n   \n   float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n   \n   float sphere = sphereSDF(samplePoint, 1.2);\n   \n   float ballOffset = 0.9 + sin(1.7 * iTime);\n   float ballRadius = (1.0 - 0.4) * (1.0 + sin(1.7 * iTime))/3.0;\n   float balls = heartSDF(samplePoint - vec3(ballOffset, 0.0, 0.0), ballRadius);\n   balls = unionSDF(balls, heartSDF(samplePoint + vec3(ballOffset, 0.0, 0.0), ballRadius));\n   balls = unionSDF(balls, heartSDF(samplePoint - vec3(0.0, ballOffset, 0.0), ballRadius));\n   balls = unionSDF(balls, heartSDF(samplePoint + vec3(0.0, ballOffset, 0.0), ballRadius));\n   balls = unionSDF(balls, heartSDF(samplePoint - vec3(0.0, 0.0, ballOffset), ballRadius));\n   balls = unionSDF(balls, heartSDF(samplePoint + vec3(0.0, 0.0, ballOffset), ballRadius));\n   \n   \n   \n   float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                        unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n   \n   return unionSDF(balls, csgNut);\n}\n \n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n *\n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n   float depth = start;\n   for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n       float dist = sceneSDF(eye + depth * marchingDirection);\n       if (dist < EPSILON) {\n                                   return depth;\n       }\n       depth += dist;\n       if (depth >= end) {\n           return end;\n       }\n   }\n   return end;\n}\n           \n \n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n *\n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n   vec2 xy = fragCoord - size / 2.0;\n   float z = size.y / tan(radians(fieldOfView) / 2.0);\n   return normalize(vec3(xy, -z));\n}\n \n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n   return normalize(vec3(\n       sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n       sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n       sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n   ));\n}\n \n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                         vec3 lightPos, vec3 lightIntensity) {\n   vec3 N = estimateNormal(p);\n   vec3 L = normalize(lightPos - p);\n   vec3 V = normalize(eye - p);\n   vec3 R = normalize(reflect(-L, N));\n   \n   float dotLN = dot(L, N);\n   float dotRV = dot(R, V);\n   \n   if (dotLN < 0.0) {\n       // Light not visible from this point on the surface\n       return vec3(0.0, 0.0, 0.0);\n   }\n   \n   if (dotRV < 0.0) {\n       // Light reflection in opposite direction as viewer, apply only diffuse\n       // component\n       return lightIntensity * (k_d * dotLN);\n   }\n   return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n \n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n   const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n   vec3 color = ambientLight * k_a /2.0;\n   \n   vec3 light1Pos = vec3(4.0 * sin(iTime),\n                         2.0,\n                         4.0 * cos(iTime));\n   vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n   \n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                 light1Pos,\n                                 light1Intensity);\n   \n   vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                         2.0 * cos(0.37 * iTime),\n                         2.0);\n   vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n   \n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                 light2Pos,\n                                 light2Intensity);   \n   return color;\n}\n \n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n   // Based on gluLookAt man page\n   vec3 f = normalize(center - eye);\n   vec3 s = normalize(cross(f, up));\n   vec3 u = cross(s, f);\n   return mat3(s, u, -f);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n           vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   vec3 eye = vec3(10.0, 5.0 * sin(0.2 * iTime), 7.0);\n   \n   mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n   \n   vec3 worldDir = viewToWorld * viewDir;\n   \n   float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n   \n   if (dist > MAX_DIST - EPSILON) {\n       // Didn't hit anything\n       fragColor = vec4(1.0*sin(iTime)/2.0, 10.0, 100.0, 10.0);\n       //fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n                       return;\n   }\n   \n   // The closest point on the surface to the eyepoint along the view ray\n   vec3 p = eye + dist * worldDir;\n   \n   // Use the surface normal as the ambient color of the material\n   vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n   vec3 K_d = K_a;\n   vec3 K_s = vec3(20.0, 1.0, 30.0);\n   float shininess = 5000.0;\n   \n   vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n   \n    //figure out how to get the texture on there\n    //https://orig00.deviantart.net/9efb/f/2011/172/2/2/companion_cube_face_by_bulbablaaah-d3jl8wz.png\n   //fragColor = vec4(color*1.5, 10.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 518, 559, 559, 652], [654, 654, 676, 676, 859], [861, 861, 883, 883, 981], [983, 983, 1010, 1010, 1150], [1153, 1199, 1226, 1226, 1366], [1369, 1415, 1442, 1442, 1582], [1585, 1676, 1722, 1722, 1753], [1756, 1840, 1882, 1882, 1913], [1916, 2005, 2052, 2052, 2084], [2087, 2195, 2228, 2228, 2647], [2650, 2737, 2771, 2771, 2798], [2800, 2913, 2946, 2946, 3471], [4078, 4195, 4240, 4308, 4902], [4905, 5144, 5178, 5215, 6691], [6694, 7114, 7205, 7205, 7532], [7547, 7800, 7865, 7865, 7994], [7997, 8086, 8115, 8115, 8419], [8422, 8913, 9052, 9052, 9622], [9625, 9994, 10079, 10079, 10862], [10865, 11192, 11241, 11275, 11402], [11405, 11405, 11462, 11462, 12612]], "test": "valid"}
{"id": "MscBRs", "name": "Outline #1: Voxel tunnel", "author": "lsdlive", "description": "This was my shader for the shader showdown at Outline demoparty 2018 for the first round.\nShader showdown is a live-coding competition where two participants are facing each other during 25 minutes.\n\nI was a little bit nervous, but it turned out well :-)", "tags": ["tunnel", "voxel", "livecoding", "demoparty"], "likes": 119, "viewed": 6081, "published": "Public", "date": "1526327169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\n// This was my shader for the shader showdown at Outline demoparty 2018 in Nederland.\n// Shader showdown is a live-coding competition where two participants are\n// facing each other during 25 minutes.\n// (Round 1)\n\n// I don't have access to the code I typed at the event, so it might be\n// slightly different.\n\n// Original algorithm on shadertoy from fb39ca4: https://www.shadertoy.com/view/4dX3zl\n// I used the implementation from shane: https://www.shadertoy.com/view/MdVSDh\n\n// Thanks to shadertoy community & shader showdown paris.\n\n// This is under CC-BY-NC-SA (shadertoy default licence)\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(2.*a, a*b);\n}\n\nfloat g = 0.;\nfloat de(vec3 p) {\n\tp.xy -= path(p.z);\n\n\tfloat d = -length(p.xy) + 4.;// tunnel (inverted cylinder)\n\n\tp.xy += vec2(cos(p.z + iTime)*sin(iTime), cos(p.z + iTime));\n\tp.z -= 6. + iTime * 6.;\n\td = min(d, dot(p, normalize(sign(p))) - 1.); // octahedron (LJ's formula)\n\t// I added this in the last 1-2 minutes, but I'm not sure if I like it actually!\n\n\t// Trick inspired by balkhan's shadertoys.\n\t// Usually, in raymarch shaders it gives a glow effect,\n\t// here, it gives a colors patchwork & transparent voxels effects.\n\tg += .015 / (.01 + d * d);\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat dt = iTime * 6.;\n\tvec3 ro = vec3(0, 0, -5. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 right = cross(fwd, vec3(0, 1, 0));\n\tvec3 up = cross(right, fwd);\n\tvec3 rd = normalize(fwd + uv.x*right + uv.y*up);\n\n\trd.xy *= r2d(sin(-ro.x / 3.14)*.3);\n\n\t// Raycast in 3d to get voxels.\n\t// Algorithm fully explained here in 2D (just look at dde algo):\n\t// http://lodev.org/cgtutor/raycasting.html\n\t// Basically, tracing a ray in a 3d grid space, and looking for \n\t// each voxel (think pixel with a third dimension) traversed by the ray.\n\tvec3 p = floor(ro) + .5;\n\tvec3 mask;\n\tvec3 drd = 1. / abs(rd);\n\trd = sign(rd);\n\tvec3 side = drd * (rd * (p - ro) + .5);\n\n\tfloat t = 0., ri = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\n\t\t/*\n\t\t// sphere tracing algorithm (for comparison)\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\tif(d<.001) break;\n\t\tt += d;\n\t\t*/\n\n\t\tif (de(p) < 0.) break;// distance field\n\t\t\t\t\t\t\t  // we test if we are inside the surface\n\n\t\tmask = step(side, side.yzx) * step(side, side.zxy);\n\t\t// minimum value between x,y,z, output 0 or 1\n\n\t\tside += drd * mask;\n\t\tp += rd * mask;\n\t}\n\tt = length(p - ro);\n\n\tvec3 c = vec3(1) * length(mask * vec3(1., .5, .75));\n\tc = mix(vec3(.2, .2, .7), vec3(.2, .1, .2), c);\n\tc += g * .4;\n\tc.r += sin(iTime)*.2 + sin(p.z*.5 - iTime * 6.);// red rings\n\tc = mix(c, vec3(.2, .1, .2), 1. - exp(-.001*t*t));// fog\n\n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscBRs.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[550, 609, 628, 628, 688], [690, 690, 710, 710, 780], [796, 796, 814, 814, 1351], [1353, 1353, 1408, 1408, 2949]], "test": "valid"}
{"id": "MscBzs", "name": "Outline #2: Scenes in a cube", "author": "lsdlive", "description": "This was my shader for the shader showdown at Outline demoparty 2018 for the final.\nShader showdown is a live-coding competition where two participants are facing each other during 25 minutes.\n\nI'm now qualified for the shader showdown revision 2019 :-)", "tags": ["raymarch", "cube", "livecoding", "demoparty"], "likes": 14, "viewed": 391, "published": "Public", "date": "1526341450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// @lsdlive\n\n// This was my second shader for the shader showdown at Outline demoparty 2018 in Nederland.\n// Shader showdown is a live-coding competition where two participants are\n// facing each other during 25 minutes.\n\n// I don't have access to the code I typed at the event,\n// so the code is NOT exactly the same. See below to get more information.\n\n// The idea was a simple cube on which I texture mapped other sphere-traced scenes.\n// There is only two scenes, but as I was updating the scenes at the same time\n// & changing the rotation during the 25 minutes, it gives the illusion\n// there was more than 2 scenes.\n// I kept everything black & white, because I didn't have time to add colours.\n// I wish I would have worked harder on this & deliver a more polished version,\n// but it was prepared the same day before the event, and I wanted to do this for the event.\n\n// Thanks to the organizers of the Outline demoparty!\n// Thanks to the shadertoy community & greets to the shader showdown paris gang!\n\n// This is under CC-BY-NC-SA (shadertoy default licence).\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat re(float p, float d) {\n\treturn mod(p - d * .5, d) - d * .5;\n}\n\n// mercury's hglib\nvoid amod(inout vec2 p, float m) {\n\tfloat a = re(atan(p.x, p.y), m);\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\n// mercury's hglib\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x)p = p.yx;\n}\n\n// signed cross\n// http://iquilezles.org/www/articles/menger/menger.htm\nfloat sc(vec3 p, float d) {\n\tp = abs(p);\n\tp = max(p, p.yzx);\n\treturn min(p.x, min(p.y, p.z)) - d;\n}\n\n// signed box\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(vec3 p, vec3 b) {\n\tb = abs(p) - b;\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\n}\n\nvoid transf(inout vec3 p) {\n\tfloat t = iTime * 7.;\n\tfloat s = t * .1 + sin(t)*.1;\n\tp.xz *= r2d(.77 + s * 2.5);\n\tp.xy *= r2d(.77 + s * 2.5);\n}\n\n// Main scene\n// The rotating cube\nfloat de(vec3 p) {\n\ttransf(p);\n\treturn box(p, vec3(1));\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0005, 0);\n\treturn normalize(vec3(\n\t\tde(p + e.xyy) - de(p - e.xyy),\n\t\tde(p + e.yxy) - de(p - e.yxy),\n\t\tde(p + e.yyx) - de(p - e.yyx)\n\t));\n}\n\n// First sphere-traced scene mapped on the cube.\n// This is not what it was on stage, it was improvisation,\n// so, it's impossible to me to remember the parameters.\n// This was a signed cross with amod/mo layers.\nfloat de2(vec3 p) {\n\t//p.xz*=r2d(iTime);\n\tp.xy*=r2d(iTime);\n\tp.z = re(p.z, 2.);\n\n\t//mo(p.xy, vec2(1, 2));\n\tamod(p.xy, .785);\n\tmo(p.xy, vec2(2.5, 1));\n\tp.x = abs(p.x) - 2.;\n\tp.xy *= r2d(3.14*.25);\n\n\treturn sc(p, .2);\n}\n\n// At some point during the live-coding session,\n// the 2nd scene was something like this:\n/*\nfloat de3(vec3 p){\np.xz*=r2d(iTime);\namod(p.xy,.785);\nmo(p.xz, vec2(.4, .2));\nreturn dot(p,normalize(sign(p)))-1.;\n}\n\nvec3 tex3(vec2 uv){\nvec3 ro=vec3(0,0,-4);\nvec3 rd=normalize(vec3(uv,1));\n\nfloat t=0.,i=0.;\nvec3 p;\nfor(;i<1.;i+=.01){\np=ro+rd*t;\nfloat d=de3(p);\nif(d<.001)break;\nt+=d;\n}\n\nvec3 c=vec3(i)*(1.-length(pow(uv, vec2(3.) )));\nreturn c;\n}\n*/\n\n\n\n// Second sphere-traced scene mapped on the cube.\n// This is not what it was on stage, it was kind of an improvisation,\n// I tried to do something similar to one of my previous shader:\n// https://www.shadertoy.com/view/4ddfDr\n// but I struggled hard on stage with the stress & time limit,\n// so I did a less intersting stuff at the event.\nfloat g3 = 0.;\nfloat de3(vec3 p) {\n\n\tp.xy *= r2d(iTime*.3);\n\n\tfloat pl = p.y + .2;\n\n\tp.z = re(p.z, 2.);\n\n\tvec3 q = p;\n\tq.xz *= r2d(3.14*.25);\n\tq.y = abs(q.y) - .3;\n\tfloat sc1 = sc(q, .2);;\n\n\tp.x = abs(p.x) - 1.;\n\tp.xy *= r2d(3.14*.25);\n\n\tfloat d = max(-sc1, min(pl, sc(p, .25)));\n\tg3 += .01 / (.015 + d * d);\n\treturn d;\n}\n\n// One face is barely visible due to my cube rotation function\n// So I decide to just put a very fast coded moving texture\n// It also helped me to focus only on two scene in parallel.\nvec3 tex1(vec2 uv) {\n\tvec2 uv2 = uv;\n\tuv *= sin(iTime);\n\tuv *= r2d(iTime);\n\tvec3 c = texture(iChannel0, uv).rrr;\n\n\t// small trick to avoid seeing texture from other faces on edges.\n\tc *= (1. - length(pow(uv2, vec2(3))));\n\n\treturn c;\n}\n\n// Sphere tracer of the first mapped scene.\n// It was faster & more flexible to duplicate code in this livecoding context,\n// sorry if it triggers your developer's sense :p\nvec3 tex2(vec2 uv) {\n\tvec3 ro = vec3(0, 0, -4. + iTime * 4.);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\tfloat t = 0., ri;\n\tvec3 p;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de2(p);\n\t\tif (d < .001) break;\n\t\tt += d;\n\t}\n\n\tvec3 c = vec3(ri);\n\n\t// small trick to avoid seeing texture from other faces on edges.\n\tc *= (1. - length(pow(uv, vec2(3))));\n\n\treturn c;\n}\n\n// Sphere tracer of the second mapped scene.\nvec3 tex3(vec2 uv) {\n\tvec3 ro = vec3(0, 0, -4. + iTime * 1.);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\tfloat t = 0., ri;\n\tvec3 p;\n\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de3(p);\n\t\t// if(d<.001) break;\n\t\td = max(abs(d), .002);\n\t\tt += d * .3;\n\t}\n\n\tvec3 c = vec3(ri*.1);//mix(vec3(.2, .3, .7), vec3(.1, .1, .4), i);\n\tc += g3 * .008;\n\n\t// small trick to avoid seeing texture from other faces on edges.\n\tc *= (1. - length(pow(uv, vec2(3))));\n\n\treturn c;\n}\n\n// boxmap from iq https://www.shadertoy.com/view/MtsGWH\nvec3 boxmap(vec3 p, vec3 n) {\n\tn = pow(abs(n), vec3(32));\n\tvec3 tx = tex1(p.yz);\n\tvec3 ty = tex2(p.zx);\n\tvec3 tz = tex3(p.xy);\n\treturn (tx*n.x + ty * n.y + tz * n.z) / (n.x + n.y + n.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 ro = vec3(0, 0, -4);\n\tvec3 rd = normalize(vec3(uv, 1));\n\n\tfloat t = 0., ri;\n\tvec3 p;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd * t;\n\t\tfloat d = de(p);\n\t\tif (d < .001) break;\n\t\tt += d;\n\t}\n\n\tvec3 n = normal(p);\n\ttransf(p);\n\ttransf(n);\n\tvec3 c = boxmap(p, n);\n\tfragColor = vec4(c, 1);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscBzs.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[1012, 1072, 1091, 1091, 1151], [1153, 1153, 1181, 1181, 1220], [1222, 1241, 1275, 1275, 1348], [1350, 1369, 1400, 1400, 1473], [1475, 1547, 1574, 1574, 1646], [1648, 1732, 1759, 1759, 1841], [1843, 1843, 1870, 1870, 1984], [1986, 2021, 2039, 2039, 2078], [2080, 2080, 2101, 2101, 2256], [2258, 2471, 2490, 2511, 2688], [3139, 3493, 3512, 3512, 3799], [3801, 3985, 4005, 4005, 4219], [4221, 4394, 4414, 4414, 4786], [4788, 4833, 4853, 4853, 5321], [5323, 5379, 5408, 5408, 5567], [5569, 5569, 5624, 5624, 6021]], "test": "error"}
{"id": "MscfRS", "name": "teppich", "author": "lennyjpg", "description": "asdfadsf", "tags": ["asdfadf"], "likes": 2, "viewed": 350, "published": "Public API", "date": "1525656093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 3737.37+sin(iTime*0.137)*337.37;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 center = vec2(1);\n    float d = distance(uv,iMouse.xy*0.01);\n    float a = 0.1;\n    float b = 0.1;\n    t *= sin(fragCoord.y*a)*b;\n    t *= cos(fragCoord.x*a)*b;\n    float r = floor(mod(d - t, .5 )*3.0);\n    fragColor = vec4( r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 383]], "test": "valid"}
{"id": "MscfWS", "name": "Portal Cube", "author": "Bundas", "description": "Check out the other sides of the cube maybe there are more things there ;)\nIf you feel lost, try it with the USE_WORLD_BACKGOUND setting.\nSome places seem empty but are they really?", "tags": ["cube", "portal"], "likes": 4, "viewed": 139, "published": "Public", "date": "1526510783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DRAW_LIGHT_SPHERE\n//#define USE_WORLD_BACKGOUND\n//#define AUTO_CAMERA\n\n//#define DRAW_MOUSE_INPUT\n\n\n#define D_PI 6.2831853\n#define PI_2 1.5707963\n#define PI   3.1415927\n#define EPS  0.001\n\n// camera\nfloat camera_r = 8.0;\nvec3 eye = vec3(-5,0,0);\nvec3 center = vec3(0,0,0);\nvec3 up = vec3(0,1,0);\n\n// light\nvec3 light_pos = vec3(0,5,0);\nfloat specular_power = 16.0;\n\n// ray and object\nvec3 rayOrig = vec3(0);\nvec3 rayDir = vec3(1,0,0);\nfloat t = -1.0;\nvec3 norm = vec3(0);\nvec3 objColor = vec3(0.5);\n\nfloat time = 0.0;\nvec3[] bg = vec3[](\n\tvec3(0,0.5,1),\n    vec3(0.5,0.75,0),\n    vec3(0.25,0,0.75),\n    vec3(0.5,0.25,0.5),\n    vec3(1,0.75,0.25),\n    vec3(1,0,0.5),\n    vec3(0.5,0,0.75)\n);\n\n// functions\nvoid getRay(in vec3 eye, in vec3 center, in vec3 up, in vec2 normFragCoords, out vec3 rayDirection);\nvoid RubiksCube(in vec3 centerPos, in float sideLength);\nvoid drawPortalCube(inout int portalSide);\nvoid world1();\nvoid world2();\nvoid world3();\nvoid world4();\nvoid world5();\nvoid world6();\nvoid sphere(in vec3 center, in float r, in vec3 col);\nvoid octahedron(in vec3 center, in float r, in vec3 col);\nvoid frame(in vec3 corner, in vec3 dir1, in vec3 dir2, inout vec2 par, in bool oneWay, in float frameSize, out bool inside, in vec3 col);\nvoid outerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, out int lookThrough, in vec3 col);\nvoid innerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, in vec3 col);\nvoid parallelogram(in vec3 corner, in vec3 dir1, in vec3 dir2, inout vec2 par, in vec3 col);\nvoid triangle(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 col);\nvec3 shade(in vec3 pos, in vec3 normal, in bool shadowed);\nvec3 polarToDesc(in float r, in float phi, in float theta);\nvoid animatedParalelogram(in vec3 corner, in vec3 dir1, in vec3 dir2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime/2.0;\n    #ifdef DRAW_MOUSE_INPUT\n        if(distance(iMouse.xy,fragCoord) < 5.0) { fragColor = vec4(1,0,0,1); return;}\n        if(distance(iMouse.zw,fragCoord) < 5.0) { fragColor = vec4(0,1,0,1); return;}\n    #endif\n\n    // set camera position\n    float phi = 0.0;\n    float theta = PI_2;\n    vec2 mOffset = vec2(0);\n    if(iMouse.z > 0.0){\n        mOffset = (iMouse.xy - iMouse.zw) / iResolution.xy;\n        mOffset.y = clamp(mOffset.y, -0.499, 0.499);\n    }\n    theta += mOffset.y * PI;\n    #ifdef AUTO_CAMERA\n    \tphi -= time * PI * 0.25;\n    #else\n        phi += mOffset.x * D_PI;\n    #endif\n    eye = polarToDesc(camera_r, phi, theta);\n    \n    // set point light\n    light_pos = vec3(5.0*cos(time/7.0*D_PI), 1.0+1.2*sin(time/3.0*D_PI), 5.0*sin(time/7.0*D_PI));\n    \n    // get normalized fragment coordinates\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    \n    // draw the scene\n    getRay(eye, center, up, uv, rayDir);\n    rayOrig = eye;\n    t = -1.0;\n    #ifdef DRAW_LIGHT_SPHERE\n        sphere(light_pos, 0.1, vec3(10.0));\n    #endif\n    int portal = -1;\n    drawPortalCube(portal);\n    float pos_t = t;\n    vec3 pos_pos = rayOrig + t * rayDir;\n    vec3 pos_norm = norm;\n    vec3 pos_objColor = objColor;\n    \n    // shadow\n    bool inShadow = false;\n    if(pos_t >= 0.0){\n        rayDir = pos_pos - light_pos;\n        float lightRay_t = length(rayDir);\n        rayDir = normalize(rayDir);\n        rayOrig = light_pos;\n        t = -1.0;\n    \tdrawPortalCube(portal);\n        inShadow = (t > 0.0) && (t + EPS < lightRay_t);\n\n        objColor = pos_objColor;\n    }\n    \n    #ifdef USE_WORLD_BACKGOUND\n\t\tvec3 background = bg[portal];\n    #else\n\t\tvec3 background = bg[0];\n    #endif\n    \n    vec3 col = pos_t < 0.0 ? background : shade(pos_pos, pos_norm, inShadow);\n    \n    fragColor = vec4(col, 1.0); \n}\n\nvoid getRay(in vec3 eye, in vec3 center, in vec3 up, in vec2 normFragCoords, out vec3 rayDirection)\n{\n    vec3 w = normalize(eye-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n   \tvec2 mres = normalize(iResolution.xy);\n    \n    float alpha = normFragCoords.x*mres.x;\n    float beta = normFragCoords.y*mres.y;\n    \n    rayDirection = normalize(alpha*u + beta*v - w);\n}\n\nvoid drawPortalCube(inout int portalSide)\n{\n    // in portalSide == -1 -> draw phase\n    // in portalSide == 0 -> shadowing phase (no portal)\n    // in portalSide > 0 -> shadowing phase (we are in a portal)\n    \n    int side = 0;\n    \n    outerCubeFrame(vec3(0), 5.0, 0.1, side, vec3(0.8));\n    innerCubeFrame(vec3(0), 5.0, 0.1, vec3(0.8));\n    \n    int world = (portalSide == -1 ? side : portalSide);\n    switch(world){\n    \tcase 1: world1(); break;\n        case 2: world2(); break;\n        case 3: world3(); break;\n        case 4: world4(); break;\n        case 5: world5(); break;\n        case 6: world6(); break;\n    }\n    \n\tportalSide = (portalSide == -1) ? side : portalSide;\n}\n\nvoid world1()\n{\n    RubiksCube(vec3(0), 1.0);\n    //RubiksCube(vec3(5.0,0,0), 1.0);\n    //RubiksCube(vec3(0,5.0,0), 1.0);\n    //RubiksCube(vec3(0,-5.0,0), 1.0);\n    //RubiksCube(vec3(0,0,5.0), 1.0);\n    //RubiksCube(vec3(0,0,-5.0), 1.0);\n}\n\nvoid world2()\n{\n    sphere(vec3(-2.5+2.0*cos(time/6.0*D_PI), 2.5+2.0*sin(time/6.0*D_PI), 0.0), 1.0, vec3(0.75,0.75,0));\n}\n\nvoid world3()\n{\n    sphere(vec3(0,2.0*sin(time),0), 1.0, vec3(0.5,1,0.25));\n}\n\nvoid world4()\n{\n    if(iMouse.z > 0.0 && (abs(iMouse.xy-iMouse.zw)/iResolution.xy).x > 0.5)\n    \tRubiksCube(vec3(0,0,0), 3.0);\n    else\n\t\toctahedron(vec3(0), 2.0, vec3(1,0.3,0));\n    \n}\n\nvoid world5()\n{\n    sphere(4.0*vec3(cos(time/12.0*D_PI), 0.0, -sin(time/12.0*D_PI)), 1.0, vec3(0,1,0));\n}\n\nvoid world6()\n{\n    if(iMouse.z > 0.0 && (abs(iMouse.xy-iMouse.zw)/iResolution.xy).x > 0.5){\n        //octahedron(vec3(0,4.0,0), 3.0, vec3(0.5,1,0.25));\n        //octahedron(vec3(0,-4.0,0), 3.0, vec3(0.5,1,0.25));\n        //octahedron(vec3(4.0,0,0), 3.0, vec3(0.5,1,0.25));\n        //octahedron(vec3(-4.0,0,0), 3.0, vec3(0.5,1,0.25));\n        octahedron(vec3(0,0,-4.0), 3.0, vec3(0.5,1,0.25));\n    }else{\n        animatedParalelogram(vec3(-2.0,-2.0,0),vec3(4,0,0),vec3(0,4,0));\n    }\n    \n}\n\nvoid RubiksCube(in vec3 centerPos, in float sideLength)\n{\n    vec2 par = vec2(-1.0);\n    vec3 minCorner = centerPos - sideLength/2.0;\n    vec3 maxCorner = centerPos + sideLength/2.0;\n    vec3 x = vec3(sideLength,0,0);\n    vec3 y = vec3(0,sideLength,0);\n    vec3 z = vec3(0,0,sideLength);\n\n    // back\n    parallelogram(minCorner, z, y, par, vec3(1,0,0));\n    // bottom\n    parallelogram(minCorner, x, z, par, vec3(1,1,0));\n    // right\n    parallelogram(minCorner, y, x, par, vec3(0,1,0));\n\t// front\n    parallelogram(maxCorner, -y, -z, par, vec3(1,0.5,0));\n\t// top\n    parallelogram(maxCorner, -z, -x, par, vec3(0.9));\n    // left\n    parallelogram(maxCorner, -x, -y, par, vec3(0,0,1));\n    \n    float eps = 0.01;\n    if(abs(par.x)<eps||abs(par.x-1.0/3.0)<eps||abs(par.x-2.0/3.0)<eps||abs(par.x-1.0)<eps||\n       abs(par.y)<eps||abs(par.y-1.0/3.0)<eps||abs(par.y-2.0/3.0)<eps||abs(par.y-1.0)<eps)\n        objColor = vec3(0);\n}\n\nvoid sphere(in vec3 center, in float r, in vec3 col)\n{\n\tfloat B = 2.0*dot(rayDir, rayOrig - center);\n\tfloat C = dot( rayOrig - center, rayOrig - center) - r*r;\n\n\tfloat discr = B*B - 4.0*C;\n\tif (discr < 0.0) return;\n\n\tfloat tt = 0.5*(-B - sqrt(discr));\n\n    if(tt > 0.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(rayOrig + tt*rayDir - center);\n\t\tobjColor = col;\n    }\n}\n\nvoid octahedron(in vec3 c, in float r, in vec3 col)\n{\n    vec3 x = vec3(r, 0, 0);\n    vec3 y = vec3(0, r, 0);\n    vec3 z = vec3(0, 0, r);\n    triangle(c+z, c+x, c+y, col);\n    triangle(c+x, c-z, c+y, col);\n    triangle(c-z, c-x, c+y, col);\n    triangle(c-x, c+z, c+y, col);\n    triangle(c+x, c+z, c-y, col);\n    triangle(c-z, c+x, c-y, col);\n    triangle(c-x, c-z, c-y, col);\n    triangle(c+z, c-x, c-y, col);\n}\n\nvoid frame(in vec3 corner, in vec3 dir1, in vec3 dir2, in float frameSize, out bool inside, in vec3 col)\n{\n    inside = false;\n    vec2 locPar = vec2(0,0);\n    float old_t = t;\n    vec3 old_norm = norm;\n\tvec3 old_col = objColor;\n    parallelogram(corner, dir1, dir2, locPar, col);\n\n\tif(locPar.x > frameSize && locPar.y > frameSize && locPar.x < 1.0 - frameSize && locPar.y < 1.0 - frameSize){\n\t\tt = old_t;\n\t\tnorm = old_norm;\n\t\tobjColor = old_col;\n\t\tinside = true;\n\t}\n}\n\nvoid outerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, out int lookThrough, in vec3 col)\n{\n    lookThrough = 0;\n    vec3 minCorner = centerPos - sideLength/2.0;\n    vec3 maxCorner = centerPos + sideLength/2.0;\n    vec3 x = vec3(sideLength,0,0);\n    vec3 y = vec3(0,sideLength,0);\n    vec3 z = vec3(0,0,sideLength);\n    bool intersect = false;\n    bool inside = false;\n    // back\n    frame(minCorner, z, y, frameSize, inside, col);\n\tlookThrough = inside ? 1 : lookThrough;\n    // bottom\n    frame(minCorner, x, z, frameSize, inside, col);\n\tlookThrough = inside ? 2 : lookThrough;\n    // right\n    frame(minCorner, y, x, frameSize, inside, col);\n\tlookThrough = inside ? 3 : lookThrough;\n    // front\n    frame(maxCorner, -y, -z, frameSize, inside, col);\n\tlookThrough = inside ? 4 : lookThrough;\n    // top\n    frame(maxCorner, -z, -x, frameSize, inside, col);\n\tlookThrough = inside ? 5 : lookThrough;\n    // left\n    frame(maxCorner, -x, -y, frameSize, inside, col);\n\tlookThrough = inside ? 6 : lookThrough;\n}\n\nvoid innerCubeFrame(in vec3 centerPos, in float sideLength, in float frameSize, in vec3 col)\n{\n    vec3 minCorner = centerPos - sideLength/2.0;\n    vec3 maxCorner = centerPos + sideLength/2.0;\n    vec3 x = vec3(sideLength,0,0);\n    vec3 y = vec3(0,sideLength,0);\n    vec3 z = vec3(0,0,sideLength);\n    float absFrame = frameSize*sideLength;\n    vec3 xx = vec3(absFrame,0,0);\n    vec3 yy = vec3(0,absFrame,0);\n    vec3 zz = vec3(0,0,absFrame);\n    bool inside = false;\n    // back\n    frame(minCorner+xx, y, z, frameSize, inside, col);\n    // bottom\n    frame(minCorner+yy, z, x, frameSize, inside, col);\n    // right\n    frame(minCorner+zz, x, y, frameSize, inside, col);\n    // front\n    frame(maxCorner-xx, -z, -y, frameSize, inside, col);\n    // top\n    frame(maxCorner-yy, -x, -z, frameSize, inside, col);\n    // left\n    frame(maxCorner-zz, -y, -x, frameSize, inside, col);\n}\n\nvoid parallelogram(in vec3 corner, in vec3 dir1, in vec3 dir2, inout vec2 par, in vec3 col)\n{\n    vec3 faceNormal = cross(dir1, dir2);\n    if(dot(rayDir, faceNormal) >= 0.0) return;\n    \n    mat3 A = mat3(dir1, dir2, -rayDir);\n    vec3 b = rayOrig - corner;\n    \n    vec3 a_b_t = inverse(A)*b;\n    float aa = a_b_t.x;\n    float bb = a_b_t.y;\n    float tt = a_b_t.z;\n    \n    if(aa >= 0.0 && aa <= 1.0 && bb >= 0.0 && bb <= 1.0 && tt >= 0.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(faceNormal);\n\t\tobjColor = col;\n\t\tpar = vec2(aa, bb);\n    }\n}\n\nvoid triangle(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 col)\n{\n    vec3 dir1 = p2 - p1;\n    vec3 dir2 = p3 - p1;\n    vec3 faceNormal = cross(dir1, dir2);\n    if(dot(rayDir, faceNormal) >= 0.0) return;\n    \n    mat3 A = mat3(dir1, dir2, -rayDir);\n    vec3 b = rayOrig - p1;\n    \n    vec3 a_b_t = inverse(A)*b;\n    float aa = a_b_t.x;\n    float bb = a_b_t.y;\n    float tt = a_b_t.z;\n    \n    if(aa >= 0.0 && bb >= 0.0 && tt >= 0.0 && aa + bb <= 1.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(faceNormal);\n\t\tobjColor = col;\n    }\n}\n\nvec3 shade(in vec3 pos, in vec3 normal, in bool shadowed)\n{\n\tvec3 ambient = 0.2*objColor;\n    if(shadowed) return clamp(ambient, 0.0, 1.0);\n    \n\tvec3 toLight = normalize(light_pos - pos);\n\tfloat di = clamp(dot(toLight, normal), 0.0, 1.0);\n\tvec3 diffuse = di*objColor;\n\t\n\tvec3 specular = vec3(0);\n\tif (di > 0.0)\n\t{\n\t\tvec3 e = normalize(eye - pos);\n\t\tvec3 r = reflect(-toLight, normal);\n\t\tfloat si = pow(clamp(dot(e, r), 0.0, 1.0), specular_power);\n\t\tspecular = si*vec3(0.9);\n\t}\n\n\treturn clamp(ambient + diffuse + specular, 0.0, 1.0);   \n}\n\nvec3 polarToDesc(in float r, in float phi, in float theta)\n{\n    return r*vec3(cos(phi)*sin(theta), cos(theta), sin(phi)*sin(theta));\n}\n\nfloat metaBall(in vec2 c, in float r, in vec2 p){\n    float d = distance(c, p) / r;\n    return (d >= 1.0) ? 0.0 : clamp(2.0*d*d*d - 3.0*d*d + 1.0, 0.0, 1.0);\n}\n\nfloat metaBalls(in vec2 p){\n    vec2 c1 = vec2(0.5); \n    float r1 = 0.2;\n    vec2 c2 = 0.5+0.3*vec2(cos(iTime),sin(iTime));\n    float r2 = 0.2;\n    vec2 c3 = 0.5+0.3*vec2(cos(2.0*iTime),sin(4.0*iTime));\n    float r3 = 0.1;\n    vec2 c4 = 0.5+0.2*vec2(cos(iTime),-sin(iTime));\n    float r4 = 0.1;\n    \n    float f = \n        metaBall(c1, r1, p)+\n        metaBall(c2, r2, p)+\n        metaBall(c3, r3, p)+\n        metaBall(c4, r4, p);\n    f = clamp(f, 0.0, 1.0);\n    return f;\n}\n\nvoid animatedParalelogram(in vec3 corner, in vec3 dir1, in vec3 dir2)\n{\n    vec3 faceNormal = cross(dir1, dir2);\n    if(dot(rayDir, faceNormal) >= 0.0) return;\n    \n    mat3 A = mat3(dir1, dir2, -rayDir);\n    vec3 b = rayOrig - corner;\n    \n    vec3 a_b_t = inverse(A)*b;\n    float aa = a_b_t.x;\n    float bb = a_b_t.y;\n    float tt = a_b_t.z;\n    \n    if(aa >= 0.0 && aa <= 1.0 && bb >= 0.0 && bb <= 1.0 && tt >= 0.0 && (t < 0.0 || tt < t)){\n    \tt = tt;\n        norm = normalize(faceNormal);\n\t\tobjColor = vec3((metaBalls(vec2(aa,bb)) < 0.25) ? 0.0 : 1.0, 0 ,0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MscfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[698, 1809, 1866, 1866, 3700], [3702, 3702, 3803, 3803, 4100], [4102, 4102, 4145, 4308, 4784], [4786, 4786, 4801, 4801, 5025], [5027, 5027, 5042, 5042, 5148], [5150, 5150, 5165, 5165, 5227], [5229, 5229, 5244, 5244, 5414], [5416, 5416, 5431, 5431, 5521], [5523, 5523, 5538, 5538, 6013], [6015, 6015, 6072, 6072, 6942], [6944, 6944, 6998, 6998, 7332], [7334, 7334, 7387, 7387, 7745], [7747, 7747, 7853, 7853, 8215], [8217, 8217, 8332, 8332, 9250], [9252, 9252, 9346, 9346, 10132], [10134, 10134, 10227, 10227, 10697], [10699, 10699, 10763, 10763, 11249], [11251, 11251, 11310, 11310, 11789], [11791, 11791, 11851, 11851, 11926], [11928, 11928, 11977, 11977, 12087], [12089, 12089, 12116, 12116, 12564], [12566, 12566, 12637, 12637, 13137]], "test": "error"}
{"id": "MsdBD4", "name": "Extreme Desert", "author": "dr2", "description": "Desert flyover with changing lighting (look around with mouse)", "tags": ["terrain", "lighting", "sand", "desert"], "likes": 8, "viewed": 662, "published": "Public API", "date": "1525249445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Extreme Desert\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Desert flyover with changing lighting (look around with mouse)\n\n  Based on earlier 'Terrain Explorer' with terrain option derived from 'Sirenian Dawn'\n  by nimitz; sand ripples use waveform from 'Rock Garden'.\n\n  Motivation from Shane's 'Desert Sand'\n*/\n\n#define FAST_SUN  1    // (0/1) fast lighting changes\n#define AA        0    // (0/1) optional antialiasing\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2s (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat tCur, dstFar, gFac, hFac, fWav, aWav, smFac, stepFac;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec3 v;\n  vec2 q, t;\n  float wAmp, wp, tp, f;\n  q = gFac * p;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * fWav;\n  wAmp = 1.;\n  t = vec2 (0.);\n  wp = aWav;\n  tp = 5.;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    v = Noisev3v2 (q);\n    t += pow (abs (v.yz), vec2 (tp)) - v.yz;\n    tp -= 1.;\n    f += wAmp * v.x / (1. + dot (t, t));\n    wAmp *= - wp;\n    wp *= smFac;\n    q *= qRot;\n  }\n  return hFac * (1. + 6. * f / (1. + smoothstep (-0.5, 1.5, f)));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0. || s > dstFar) break;\n    sLo = s;\n    s += stepFac * (max (0.3, 0.6 * h) + 0.008 * s);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2s (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2s (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.5, 0.5, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.xz += tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (0.9), clamp (1.6 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec2 e = vec2 (1., 0.);\n  return (sd.z > 0.) ? 0.1 * pow (abs (sd.z), 4.) *\n     (2. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n     e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n     e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n     e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy))) : vec3 (0.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dstGrnd, f, spec, sh, dFac;\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro, dstGrnd);\n    f = 0.2 + 0.6 * smoothstep (0.7, 1.1, 2. * Fbm2s (16. * ro.xz));\n    col = mix (mix (vec3 (0.75, 0.5, 0.1), vec3 (0.65, 0.4, 0.1), f),\n       mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.4), f), smoothstep (1., 3., ro.y));\n    col = mix (vec3 (0.7, 0.6, 0.4), col, smoothstep (0.2, 0.5, vn.y));\n    spec = mix (0.05, 0.1, smoothstep (2., 3., ro.y));\n    dFac = 1. - smoothstep (0.3, 0.4, dstGrnd / dstFar);\n    if (dFac > 0. && vn.y > 0.85) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.85, 0.9, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 6. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    if (dFac > 0.) vn = VaryNf (8. * ro, vn, dFac);\n    sh = 0.3 + 0.7 * smoothstep (0.3, 0.7, Fbm2 (0.1 * ro.xz + 1.3 * tCur));\n    col *= 0.2 + sh * (0.1 * vn.y + 0.7 * max (0., dot (vn, sunDir)) +\n       0.1 * max (0., dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy))) +\n       spec * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    col *= 0.8 + 0.2 * dFac;\n    col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 g, w;\n  float f, c, s;\n  v = normalize (v);\n  g = cross (v, vec3 (0., 1., 0.));\n  if (g.y != 0.) {\n    g.y = 0.;\n    w = normalize (cross (g, v));\n  } else w = vec3 (0., 1., 0.);\n  f = v.z * a.x - v.x * a.z;\n  f = - clamp (2. * f, -0.2 * pi, 0.2 * pi);\n  c = cos (f);\n  s = sin (f);\n  w = normalize (cross (w, v));\n  return mat3 (w, cross (v, w), v) * mat3 (c, s, 0., - s, c, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv, uvv, ori, ca, sa;\n  float el, az, sunEl, sunAz, dt, tCur, flyVel, mvTot, h, hSum, nhSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 3600.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  }\n  gFac = 0.07;\n  hFac = 1.5;\n  fWav = 1.9;\n  aWav = 0.45;\n  smFac = 0.65;\n  flyVel = 3.;\n  dstFar = 120.;\n  stepFac = 0.35;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  mvTot = flyVel * tCur;\n  ro = TrackPath (mvTot);\n  dt = 1.;\n  fpF = TrackPath (mvTot + dt);\n  fpB = TrackPath (mvTot - dt);\n  flMat = EvalOri ((fpF - fpB) / (2. * dt), (fpF - 2. * ro + fpB) / (dt * dt));\n  hSum = 0.;\n  nhSum = 0.;\n  for (float fk = -1.; fk <= 5.; fk ++) {\n    hSum += GrndHt (TrackPath (mvTot + 0.5 * fk).xz);\n    ++ nhSum;\n  }\n  ro.y = 6. * hFac + hSum / nhSum;\n#if FAST_SUN\n  sunAz = 0.03 * 2. * pi * tCur;\n#else\n  sunAz = 0.01 * 2. * pi * tCur;\n#endif\n  sunEl = pi * (0.2 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunAz) * cos (sunEl), sin (sunEl), sin (sunAz) * cos (sunEl));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.), 0.5 * pi * (a + 0.5));\n    rd = normalize (vec3 (uvv, 2.5));\n    rd = vuMat * rd;\n    rd = flMat * rd;\n    col += (1. / naa) * (ShowScene (ro, rd) + GlareCol (rd, sunDir * vuMat, uvv));\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2s (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.75);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdBD4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[122, 786, 809, 809, 1272], [1274, 1274, 1308, 1308, 1843], [1845, 1845, 1876, 1876, 2031], [2033, 2033, 2058, 2058, 2439], [2441, 2441, 2485, 2485, 2679], [2681, 2681, 2703, 2703, 2795], [2797, 2797, 2829, 2829, 3114], [3116, 3116, 3159, 3159, 3546], [3548, 3548, 3583, 3583, 4919], [4921, 4921, 4952, 4952, 5354], [5356, 5356, 5382, 5382, 5495], [5497, 5497, 5553, 5553, 7463], [7465, 7465, 7522, 7522, 7605], [7607, 7607, 7637, 7637, 7750], [7784, 7784, 7808, 7808, 7938], [7940, 7940, 7964, 7964, 8027], [8029, 8029, 8054, 8054, 8240], [8242, 8242, 8267, 8267, 8611], [8613, 8613, 8634, 8634, 8789], [8791, 8791, 8813, 8813, 8966], [8968, 8968, 8997, 8997, 9209], [9211, 9211, 9250, 9250, 9430]], "test": "error"}
{"id": "MsdBDl", "name": "Weird torus", "author": "MacSlow", "description": "An experiment with the cell-index obtained from domain-repetition... applied to material-index and morph/animation-phase.", "tags": ["3d", "raymarching", "reflection", "phong", "torus", "shadow", "materials", "spheretracing", "blinn", "fresnel"], "likes": 10, "viewed": 519, "published": "Public API", "date": "1527278045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// weird torus - experiment with cell-index from domain-repetition\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 48;\nconst float EPSILON = .001;\nconst float STEP_BIAS = .75;\n\nfloat saturate (in float v) { return clamp (v, .0, 1.); }\n\nmat2 r2d (in float a) {\n\tfloat c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat sdTerrain (in vec3 p, in float height)\n{\n    float h = .5*texture (iChannel0, .1*p.xz).r;\n    h += .25*texture (iChannel0, .2*p.xz).r;\n    h += .125*texture (iChannel0, .4*p.xz).r;\n    h += .0625*texture (iChannel0, .8*p.xz).r;\n    h /= (.5 + .25 + .125 + .0625);\n    h += height;\n    return p.y - .0625*h*.25;\n}\n\nfloat sdTorus (in vec3 p, in vec2 t)\n{\n    vec2 q = vec2 (length (p.xz) - t.x, p.y);\n    return length (q) - t.y;\n}\n\nfloat sdBoxSphere (in vec3 p, in float size, in float phase)\n{\n\tfloat box = sdBox (p, vec3 (size), size*.1);\n    float factor = mix (.0, 1.85, phase);\n\tfloat sphere = sdSphere (p, size*factor);\n\treturn max (box, sphere);\n}\n\nvec3 opRepeat (inout vec3 p, in float size)\n{\n\tfloat hsize = .5*size;\n\tvec3 cell = floor ((p + hsize)/vec3(size));\n\tp = mod (p + hsize, vec3 (size)) - hsize;\n\treturn cell;\n}\n\nstruct HitResult {\n\tfloat dist;\n\tint id;\n};\n\nHitResult sceneOld (in vec3 p) {\n    vec3 boxSphereCenter = p + vec3 (.0, -1., .0);\n    vec3 torusCutterCenter = boxSphereCenter;\n\n    boxSphereCenter.xy *= r2d (20.*iTime);\n    boxSphereCenter.yz *= r2d (-35.*iTime);\n    boxSphereCenter.zx *= r2d (50.*iTime);\n\n    float repeatSizePhase = .4;// + .1*(.5 + .5*sin (iTime));\n    vec3 cell = opRepeat (boxSphereCenter, repeatSizePhase);\n    float boxSpherePhase = .5 + .5*cos (.75*(cell.x + cell.y + cell.z) + iTime);\n\tfloat boxSphere = sdBoxSphere (boxSphereCenter, .15, boxSpherePhase);\n\n\ttorusCutterCenter.xy *= r2d (-30.*iTime);\n    torusCutterCenter.yz *= r2d (40.*iTime);\n    torusCutterCenter.zx *= r2d (20.*iTime);\n\n\tfloat torusCutter = sdTorus (torusCutterCenter, vec2 (1.25, .6));\n\tboxSphere = max (torusCutter, boxSphere);\n\tint id = int (floor (mod (cell.x+cell.y+cell.z, 4.)));\n\n    float ground = sdTerrain (p, -100.0);\n\n\tHitResult result = HitResult (.0, -1);\n\tresult.dist = min (ground, boxSphere);\n\tresult.id = result.dist == ground ? 1 : ( result.dist == boxSphere ? id : -1);\n\n    return result;\n}\n\nHitResult scene (in vec3 p) {\n    vec3 boxSphereCenter = p + vec3 (.0, -1., .0);\n    vec3 torusCutterCenter = boxSphereCenter;\n\n\ttorusCutterCenter.xy *= r2d (-30.*iTime);\n    torusCutterCenter.yz *= r2d (40.*iTime);\n    torusCutterCenter.zx *= r2d (20.*iTime);\n    float torusCutter = sdTorus (torusCutterCenter, vec2 (1.25, .6));\n\n    float repeatSizePhase = .4;\n    vec3 cell = opRepeat (boxSphereCenter, repeatSizePhase);\n    float boxSphere = sdBox (boxSphereCenter, vec3(.15), .0);\n    float d = distance (torusCutter, boxSphere);\n    float boxSpherePhase = torusCutter < boxSphere ? sqrt (d) : .0;\n    boxSpherePhase *= .5 + .5*cos (.75*(cell.x + cell.y + cell.z) + 2.*iTime);\n    \n\tboxSphere = sdBoxSphere (boxSphereCenter, .15, boxSpherePhase);\n\n\tboxSphere = max (torusCutter, boxSphere);\n\tint id = int (floor (mod (cell.x+cell.y+cell.z, 4.)));\n\n    float ground = sdTerrain (p, -100.0);\n\n\tHitResult result = HitResult (.0, -1);\n\tresult.dist = min (ground, boxSphere);\n\tresult.id = result.dist == ground ? 1 : ( result.dist == boxSphere ? id : -1);\n\n    return result;\n}\n\nHitResult raymarch (in vec3 ro, in vec3 rd) {\n    float d = .0;\n\tfloat t = .0;\n\tHitResult result;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        result = scene (ro + t*rd);\n        d = result.dist;\n        if (abs (d) < EPSILON * (1. + .125*d)) break;\n        t += d*STEP_BIAS;\n    }\n\n\tresult.dist = t;\n    return result;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n    float d = scene (p).dist;\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy).dist,\n                            scene (p + e.yxy).dist,\n                            scene (p + e.yyx).dist) - d);\n}\n\n// uses improved shadow-version by Sebastian Aaltonen as\n// demonstrated by iq here https://www.shadertoy.com/view/lsKcDD\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos) {\n    vec3 rd = normalize (lPos - p);\n    float result = 1.;\n    float t = .1;\n    float ph = 1e10;\n    for (int i = 0; i < 64; i++) {\n        float h = scene (p + .01*n + t * rd).dist;\n        if (h < .00001) return .0;\n        float y = h*h/(2.*ph);\n        float d = sqrt (h*h - y*y);\n        result = min (result, 10.*d/max (.0, t - y));\n        ph = h;\n        t += h*.5;\n    }\n\n    return result;\n}\n\nvec3 diffSpecTerm (in vec3 ro,\n                   in vec3 rd,\n                   in float d,\n                   in vec3 lPos,\n                   in vec3 diffColor,\n                   in float attenuationDamping,\n                   in vec3 specColor,\n\t\t\t\t   in float shininess) {\n    vec3  p = ro + d*rd;\n    vec3  n = normal (p, d*EPSILON);\n    vec3  lDir = normalize (lPos - p);\n    float lDist = distance (lPos, p);\n    float diff = max (dot (lDir, n), .0);\n    float sha = shadow (p, n, lPos);\n    float attenuation = attenuationDamping / (lDist*lDist);\n    vec3  diffTerm = sha*attenuation*diff*diffColor;\n    vec3  h = normalize (lDir - rd);\n    float spec = pow (max (dot (n, h), .0), shininess);\n    vec3  specTerm = (sha > .1) ? attenuation*spec*specColor : vec3 (.0);\n\n    return diffTerm + specTerm;\n}\n\nstruct Material {\n\tvec3 color;\n\tfloat shininess;\n};\n\nMaterial[4] materials = Material[4] (Material (vec3 (1., .5, .2), 10.),\n\t\t\t\t\t\t\t         Material (vec3 (.5, 1., .2), 50.),\n\t\t\t\t\t\t\t         Material (vec3 (.2, .5, 1.), 150.),\n\t\t\t\t\t\t\t         Material (vec3 (.3, .8, .4), 30.));\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in int matId) {\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 amb = vec3 (.2);\n\tvec3 color = matId == 1 ? mix (vec3 (.9),\n\t\t\t\t\t\t\t\t   vec3 (1., .1, .1),\n\t\t\t\t\t\t\t\t   smoothstep (.475, .5, cos(p.x)*cos (p.z))) :\n\t\t\t\t\t\t\t  materials[matId].color;\n\t\n\tfloat mask = mix (1., .0, smoothstep (.3, .5, (.5+.5*sin (60.*p.x))*(.5+.5*sin(60.*p.y))));\n\tfloat shininess = matId == 0 ? mix (20., 60., mask) : materials[matId].shininess;\n    vec3 term1 = diffSpecTerm (ro, rd, d,\n                              vec3 (2.*cos (2.*iTime), 3., -1. + 2.*sin (1.5*iTime)),\n                              color, 8., vec3 (1.), shininess);\n\n    vec3 term2 = diffSpecTerm (ro, rd, d,\n                              vec3 (1. + 2.*cos (2.*iTime), 3., -1. + 2.*sin (2.*iTime)),\n                              color, 10., vec3 (1.), shininess);\n\n    return amb + term1 + term2;\n\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n\tuv = uv * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3 (.0 + 3.*cos (.5*iTime), 3., .5 + 3.*sin (.5*iTime));\n    vec3 aim = vec3 (.0, .75, .0);\n    float zoom = 1.125;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    HitResult result = raymarch (ro, rd);\n    float d = result.dist;\n    float fog = 1. / (1. + d*.05);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (ro, rd, d, result.id);\n\n    vec3 refl = normalize (reflect (rd, n));\n    result = raymarch (p + .01*n, refl);\n    float refd = result.dist;\n    vec3 refp = p + refd*refl;\n\tvec3 refn = normal (refp, refd*EPSILON);\n    vec3 refcol = shade (p, refl, refd, result.id);\n\n    vec3 refl2 = normalize (reflect (refl, refn));\n    result = raymarch (refp + .01*refn, refl2);\n    float refd2 = result.dist;;\n    vec3 refp2 = refp + refd2*refl2;\n    vec3 refcol2 = shade (refp, refl2, refd2, result.id);\n\n\tfloat fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.25);\n    col += fakeFresnel*.85*refcol;\n    col += fakeFresnel*.85*refcol2;\n\n    col *= fog;\n    col = mix (col, vec3 (.65, .75, .85), pow (1. - 1. / d, 30.));\n    col *= vec3 (.9, .8, .7);\n    col = col / (1. + col);\n    col = .3 * col + .7 * sqrt (col);\n    col *= .3 + .7 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .2);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdBDl.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1030, 1059, 1059, 1087], [1089, 1089, 1112, 1112, 1208], [1210, 1210, 1250, 1250, 1279], [1281, 1281, 1332, 1332, 1432], [1434, 1434, 1480, 1480, 1752], [1754, 1754, 1792, 1792, 1869], [1871, 1871, 1933, 1933, 2093], [2095, 2095, 2140, 2140, 2268], [2315, 2315, 2347, 2347, 3378], [3380, 3380, 3409, 3409, 4458], [4460, 4460, 4505, 4505, 4785], [4787, 4787, 4830, 4830, 5057], [5059, 5181, 5232, 5232, 5635], [5637, 5637, 5915, 5915, 6448], [6731, 6731, 6794, 6794, 7646], [7648, 7648, 7714, 7714, 8043], [8045, 8045, 8102, 8102, 9514]], "test": "error"}
{"id": "MsdfWl", "name": "MacSlow's 2nd 3D-truchet attempt", "author": "MacSlow", "description": "My first 3D-truchet try grew over time... mostly in the area of shading. Geometry-wise I'm a bit lazy at the moment. This now has a nice creepy feel to it :) It's still miles away from truchet-structures à la Shane, but at least I'm seeing some progess.", "tags": ["3d", "raymarching", "reflection", "phong", "shadow", "spheretracing", "truchet", "blinn", "fresnel"], "likes": 9, "viewed": 556, "published": "Public API", "date": "1527269490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// my second sphere-traced 3D-truchet structure \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\n#define SHANES_VARIATION 1 // 0: false, 1: true\n#define MAX_ITER 128\n#define STEP_SIZE .95\n#define EPSILON .001\n\nconst vec4 red     = vec4 (1.0, 0.0, 0.0, 1.0);\nconst vec4 green   = vec4 (0.0, 1.0, 0.0, 1.0);\nconst vec4 blue    = vec4 (0.0, 0.0, 1.0, 1.0);\n\nmat3 rotX (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (1., .0, .0), vec3 (.0, c, s), vec3 (.0, -s, c));}\nmat3 rotY (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (c, .0, s), vec3 (.0, 1., .0), vec3 (-s, .0, c));}\nmat3 rotZ (in float a) {float c = cos(a); float s = sin (a); return mat3 (vec3 (c, s, .0), vec3 (-s, c, .0), vec3 (.0, .0, 1.));}\nmat2 rot2d (in float a) { float c = cos (a); float s = sin (a); return mat2 (vec2 (c, s), vec2 (-s, c)); }\n\nvec4 gradient (float v) {\n    float steps = 2.;\n    float step = 1. / steps;\n    vec4 col = green;\n\n    if (v >= .0 && v < step) {\n        col = mix (green, blue, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (blue, red, (v - step) * steps);\n    }\n    \n    return col;\n}\n\n// basic sdf toolbox\nvec3 opRepeat (in vec3 p, in vec3 size) {return mod (p, 2. * size) - size;}\n\n#if SHANES_VARIATION\nfloat distPol(vec2 p, float r) { const float rf = .025; return length(max(abs(p) - r + rf, 0.)) - rf; }\nfloat distTor(vec2 p, float r) { return length(p) - r; }\nfloat sdTorus (in vec3 p, in vec2 t){ vec2 q = vec2 (distTor(p.xz, t.x), p.y); return distPol(q, t.y); }\n#else\nfloat sdTorus (in vec3 p, in vec2 t) { vec2 q = vec2 (length (p.xz) - t.x, p.y); return length (q) - t.y; }\n#endif\n\n// one single truchet-cell with the three tori\n// t.x -> torus radius\n// t.y -> torus \"thickness\"\n// t.z -> the offset by which the torus should be moved from the center\nfloat sdTruchet (in vec3 p, in vec3 t)\n{\n    float offset = t.z;\n    vec3 p1 = vec3 (p - vec3 (offset, offset, .0)) * rotX (radians (90.));\n    vec3 p2 = vec3 (p - vec3 (.0, -offset, offset)) * rotZ (radians (90.));\n    vec3 p3 = vec3 (p - vec3 (-offset, .0, -offset)) * rotY (radians (90.));\n    \n    float t1 = sdTorus (p1, t.xy);\n    float t2 = sdTorus (p2, t.xy);\n    float t3 = sdTorus (p3, t.xy);\n\n    return min (t1, min (t2, t3));\n}\n\nfloat scene (in vec3 p)\n{\n    vec2 mouse = iMouse.xy;\n    if (iMouse.xy == vec2(.0)) mouse.xy = vec2 (212., 192.);\n    mat3 rot = rotX (radians (180. + mouse.y / iResolution.y * 360.)) * rotY (radians (-180. + mouse.x / iResolution.x * 360.));\n\tp *= rot;\n\n    // \"move the camera\" (actually, we're moving space)\n    p.x -= iTime * .3;\n\n    vec3 cellParam = vec3 (.5, .07 + .04 * (.5 + .5 * cos (3.*iTime)), .5);\n\n    // these random functionsand the used values are still major WTF's for me\n    float selector = fract(sin(dot(floor(p) + 13.37, vec3(7., 157., 113.)))*43758.5453);\n\n    // I _hate_ myself for having to peek into one of Shane's truchet-examples for getting a\n    // clue about the cell-rotation and not coming up with coordinate-swiveling... it's so\n    // simple and obvious... argl!\n    if (selector > .75) {\n        p = p;\n    } else if (selector > .5) {\n    \tp = p.yzx;\n    } else if (selector > .25) {\n\t    p = p.zxy;\n    }\n\n    float d = sdTruchet (opRepeat (p, vec3 (.5)), cellParam);\n\n\treturn d;\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd, out int iter)\n{\n    float t = .0;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        iter = i;\n        vec3 p = ro + t * rd;\n        float d = scene (p);\n        if (abs (d) < EPSILON * (1. + .125*d)) break;\n        t += d * STEP_SIZE;\n    }\n\n    return t;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec3 e = vec3(.0001, .0, .0);\n    float d = scene (p);\n    vec3 n = vec3 (scene (p + e.xyy) - d, scene (p + e.yxy) - d, scene (p + e.yyx) - d);\n    return normalize(n);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n    float distanceToLight = distance (p, lPos);\n    int ignored = 0;\n    float distanceToObject = raymarch (p + .01*n, normalize (lPos - p), ignored);\n    bool isShadowed = distanceToObject < distanceToLight;\n    return isShadowed ? .1 : 1.;\n}\n\n// blinn-phong shading... as much as I can remember it\nvec3 shade (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n\n    vec3 ambColor = vec3 (.1, .05, .05);\n    vec3 diffColor = vec3 (1.9, 1.4, 1.2);\n    vec3 specColor = vec3 (.95, .85, .85);\n    float shininess = 120.;\n\n    vec3 lightPos = ro + vec3 (cos (iTime) * .5, .5, sin (iTime) * .5);\n    vec3 lightDir = lightPos - p;\n    vec3 lightNDir = normalize (lightDir);\n    vec3 nor = normal (p);\n    vec3 h = normalize (lightDir - rd);\n\n    float diffuse = max (dot (lightNDir, nor), .0);\n    float specular = pow (max (dot (h, nor), .0), shininess);\n\n    float sha = shadow (p, nor, lightPos);\n    float distanceToLight = distance (p, lightPos);\n    float attenuation = 1. / (distanceToLight*distanceToLight);\n\n    vec3 specTerm = ((sha > .1) ? attenuation * specular * specColor : vec3 (.0));\n    return ambColor + sha * attenuation * diffuse * diffColor + specTerm;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalizing and aspect-correction\n\tvec2 uvRaw = fragCoord.xy / iResolution.xy;\n\tvec2 uv = uvRaw;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // create origin and view-ray\n    vec3 ro = vec3 (.0, .0, -.75);\n    vec3 rd = normalize (vec3 (uv, 1.) - ro);\n\n    // \"shake the camera\" around a bit\n    rd.xy *= rot2d (cos (iTime) * .075);\n    rd.xz *= rot2d (sin (iTime) * .15);\n\n    // do the ray-march...\n    int iter = 0;\n    float d = raymarch (ro, rd, iter);\n    float depth = float (iter) / float (MAX_ITER);\n    vec3 cc = gradient (depth).rgb;\n    float fog = 1. / (1. + d * d * .1);\n    vec3 c = shade (ro, rd, d);\n\n    // secondary/1st reflection-ray\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 refl = normalize (reflect (rd, n));\n    float refd = raymarch (p + .01*n, refl, iter);\n    vec3 refp = p + refd*refl;\n    vec3 refcol = shade (p, refl, refd);\n\n    // restricting (fresnel) reflections to grazing view-angles\n\tfloat fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.25);\n    vec3 lPos = ro + vec3 (cos (iTime) * .5, .5, sin (iTime) * .5);\n    float lDist = distance (lPos, p);\n    float attenuation = 1. / (lDist*lDist);\n    c += fakeFresnel*attenuation*.125*refcol;\n\n    // fog, tonemapping, \"gamma-correction\", tint, vignette\n    c *= fog;\n\tc = c / (1. + c);\n    c = .2 * c + .8 * sqrt (c);\n    c *= vec3 (.9, .8, .7);\n    c *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    if (iMouse.x / iResolution.x < .5) {\n\t\tfragColor = vec4(c, 1.);\n    } else {\n\t\tfragColor = vec4(cc, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsdfWl.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1211, 1235, 1235, 1340], [1341, 1341, 1365, 1365, 1470], [1471, 1471, 1495, 1495, 1600], [1601, 1601, 1626, 1626, 1707], [1709, 1709, 1734, 1734, 2009], [2011, 2032, 2073, 2073, 2107], [2518, 2688, 2728, 2728, 3128], [3130, 3130, 3155, 3155, 4150], [4152, 4152, 4207, 4207, 4453], [4455, 4455, 4480, 4480, 4655], [4657, 4657, 4708, 4708, 4952], [4954, 5009, 5058, 5058, 5892], [5894, 5894, 5950, 5991, 7538]], "test": "valid"}
{"id": "MsGfRz", "name": "High Quality Hash and Visualizer", "author": "James_Harnett", "description": "First a 32 bit hash value is generated.\nLeft Side shows that hash value converted to a float\nRight Side shows each bit of that hash value individually.\nthe first 6 or so bits have obvious patterns, but only the top 23 bits are needed when convert to float", "tags": ["noise", "hash", "prng", "rng"], "likes": 6, "viewed": 149, "published": "Public", "date": "1527421494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LICENSE: http://unlicense.org/\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11  is also first 32bits of M1*M1\n\nuint hash(uvec2 q)\n{\n\tq ^= uvec2(M1, M2);\n    uint n = q.x * q.y;\n    n ^= n >> 15;\n    n *= (q.x + q.y);\n    return n;\n}\n\nfloat hashFloat( uvec2 q )\n{\n    return float(hash(q)) * (1.0/float(0xffffffffU));\n}\n\nfloat hashBit( uvec2 q,int bit)\n{\n    return float((hash(q)&(1U<<bit))!=0U); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(fragCoord)+uint(2*iFrame);\n\tint center = int(fragCoord.x) - (int(iResolution.x)>>1);\n\tfloat c = 0.0;\n    \n   \tif(center < 0)c = hashFloat(p);\n    if(center > 0)c = hashBit(p,iFrame>>5);\n    \n    fragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGfRz.jpg", "access": "shaders20k", "license": "unlicense", "functions": [[0, 151, 171, 171, 272], [274, 274, 302, 302, 358], [360, 360, 393, 393, 439], [442, 442, 499, 499, 745]], "test": "valid"}
{"id": "MsGfzD", "name": "Kaleido blobs", "author": "NuSan", "description": "Raymarching test scene, trying to make organic parts, and making it hypnotic by mirroring uvs a bunch.", "tags": ["3d", "raymarch"], "likes": 1, "viewed": 213, "published": "Public", "date": "1527776591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define KALEIDO 1\n#define MAXSTEPS 200\n\n#define v2Resolution iResolution\n#define out_color fragColor\n#define time iTime\n\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec3 p, vec2 s) {\n  return max(length(p.xz)-s.x,abs(p.y)-s.y);\n}\n\nvec3 rep(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nvec3 repid(vec3 p, vec3 s) {\n  return floor(p/s+0.5);\n}\n\nmat2 rot(float a) {\n  float co=cos(a);\n  float so=sin(a);\n  return mat2(co,so,-so,co);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp(0.5+0.5*(a-b)/h,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nfloat smax(float a, float b, float h) {\n  float k=clamp(0.5+0.5*(b-a)/h,0.0,1.0);\n  return mix(a,b,k)+k*(1.0-k)*h;\n}\n\nfloat map(vec3 p) {\n\n\n  vec3 m0 = p;\n  //m0.xy=abs(m0.xy);\n\n  float tt = time * 0.2;\n  float tt2 = time * 0.5;\n\n  vec3 r0 = m0;\n  r0.xz *= rot(tt);\n  r0.yz *= rot(tt*2.3975);\n  vec3 r1 = rep(r0, vec3(2.0));\n  vec3 def = repid(r0, vec3(2.0));\n  \n  float d = sph(r1, 0.1);\n\n  for(int i=0;i<7;++i) {\n    vec3 r2 = r1;\n    r2.xy *= rot(tt2*0.221 + float(i)*1.986 + dot(def,def));\n    r2.yz *= rot(tt2*1.674 + float(i)*5.34);\n    d=smin(d,cyl(r2+vec3(0.0), vec2(0.02,0.8)), 0.2);\n  }\n\n  for(int i=0;i<7;++i) {\n    vec3 r2 = r1;\n    r2.xy *= rot(tt2*0.8742 + float(i)*2.1243);\n    r2.yz *= rot(tt2*1.9865 + float(i)*6.974 + dot(def,def));\n    d=smax(d,-cyl(r2+vec3(0.0), vec2(0.02,0.8)),0.1);\n  }\n\n  float ex=smax(sph(r1,0.3),-sph(r1,1.1),0.2);\n\n  d=smin(d,ex,0.8);\n  d=smax(d, sph(r1,0.8),0.2);\n\n  return d;\n\n}\n\nvec3 norm(vec3 p) {\n\n  float base = map(p);\n  vec2 off = vec2(0.0,0.001);\n  return normalize(vec3(base-map(p+off.yxx),base-map(p+off.xyx),base-map(p+off.xxy)));\n\n}\n\nvec2 mirror(vec2 uv, float a) {\n  mat2 rr = rot(a);\n  vec2 m=uv*rr;\n  m.x=abs(m.x);\n  return m*rr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(2.0*fragCoord.x / v2Resolution.x-1.0, 1.0-2.0*fragCoord.y / v2Resolution.y);\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  vec2 off = vec2(cos(time),sin(time)) * 0.3;\n  //uv=abs(uv)-abs(off);\n\n  float tt=time*0.5;\n#if KALEIDO\n  uv = mirror(uv, tt*0.1);\n  uv = mirror(uv, -tt*0.3 + 0.124);\n  uv = mirror(uv, tt*2.3);\n\n  uv -= abs(off);\n#endif\n\n  vec3 col = vec3(0.0);\n  \n  vec3 ro = vec3(0,0,-1);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  \n  vec3 p = ro;\n\n  float e = 0.0;\n\n  for(int i=0;i<MAXSTEPS;++i) {\n\n    float d = map(p);\n    if(d<0.0001) {\n\n      break;\n    }\n    e += (1.0-clamp(length(p-ro)/10.0,0.0,1.0))*0.00001/(d);\n    p += d*rd;\n  }\n\n  vec3 n = norm(p);\n  float lum = clamp(dot(n,normalize(vec3(0.7))),0.0,1.0);\n\n  float depth = length(p-ro);\n\n  col = vec3(1.0/depth);\n  col *= lum;\n  col += 0.3*vec3(0.0,1.0,1.0)*max(0.0,n.y);\n  col += (pow(depth,0.3))*vec3(0.2,0.0,0.5)*0.2;\n\n  col += e * vec3(1.0,0.6,0.0);\n\n  out_color = vec4(col,0);\n\n  //out_color = vec4(fract(uv*5.0),0,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 150, 150, 174], [176, 176, 203, 203, 250], [252, 252, 278, 278, 313], [315, 315, 343, 343, 370], [372, 372, 391, 391, 460], [462, 462, 501, 501, 578], [580, 580, 619, 619, 696], [698, 698, 717, 717, 1503], [1505, 1505, 1524, 1524, 1668], [1670, 1670, 1701, 1701, 1770], [1772, 1772, 1829, 1829, 2847]], "test": "valid"}
{"id": "MsKfRR", "name": "Ocean-SnowMountain", "author": "senzheng", "description": "SnowMoutainTest", "tags": ["terrain", "ocean", "snow", "mountain"], "likes": 4, "viewed": 214, "published": "Public", "date": "1527514293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_RAYMARCHING_COUNT 96\n#define PRECISION 0.00003\n#define FAR 100.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time iTime\n\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.x += iTime*1.1;\n    p.z += sin(p.x*.5);\n    return triNoise3d(p*2.2/(d+20.),0.2)*(1.-smoothstep(0.,1.8,p.y));\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .1;\n    for(int i=0; i<30; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n\t\tfloat grd =  clamp((rz - fogmap(pos+.8-float(i)*0.1,d))*3., 0.1, 1. );\n        vec3 col2 = (vec3(1.)*.5 + .5*vec3(1.)*(1.7-grd))*0.55;\n        col = mix(col,col2,clamp(rz*smoothstep(d-0.4,d+2.+d*.75,mt),0.,1.) );\n        d *= 1.5+0.3;\n        if (d>mt)break;\n    }\n    return col;\n}\n\n//------------------------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nmat3 setCamera(vec3 ro, vec3 lookAt) {\n\tvec3 cw = normalize(lookAt-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sminP(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\nvec2 map(vec3 p, float concernWater) {\n    float d = 0.0;\n    vec2 q = p.xz*0.02;\n    float h = 0.;\n    float s = 1.0;\n    /*for (int i = 0 ; i < 10 ; i++) {\n        h += s*noise(vec3(q, 1.));\n        q = m2 * q * 2.01;\n        s *= 0.49;\n    }\n    h *= 23.;\n\t*/\n    for (int i = 0 ; i < 9 ; i++) {\n        h += s*noise(vec3(q, 1.));\n        q = m2 * q * 3.01;\n        s *= 0.334;\n    }\n    h *= 25.;\n    \n    if (concernWater == 1.0) {\n        q = m2*p.xz*0.2;\n        float o = 0.;\n        float t = iTime * 0.3;\n        s = 0.3;\n        for (int i = 0 ; i < 5 ; i++) {\n            o += s*noise(vec3(q + t, 1.));\n            q = m2 * q * 1.98;\n            s *= 0.51;\n            t *= 1.5;\n        }\n        o += 4.;\n\n        float d = p.y - max(h, o);\n    \treturn vec2(d, smoothstep(0., abs(noise(p*2.))*1.+0.03, h-o));\n    \t//return vec2(d, step(0.0, h-o));\n    \n    } else {\n    \n        float d = p.y - h;\n        return vec2(d, 1.0);\n    }\n    \n    \n}\n\n\nvec2 rayMarching(vec3 ro, vec3 rd, float concernWater) {\n\t\n\tfloat t = 0.01, told = 0., mid, dn;\n    vec2 res = map(rd*t + ro, concernWater);\n    float d = res.x;\n    float m = res.y;\n    float sgn = sign(d);\n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n    \tif (sign(d) != sgn || d < PRECISION || t > FAR) break;\n        \n        told = t;\n        t += max(d/2.0, t*0.02);\n        res = map(rd*t + ro, concernWater);\n        d = res.x;\n        m = res.y;\n    }\n    \n    if (sign(d) != sgn) {\n        res = map(rd*told + ro, 1.0);\n    \tdn = sign(res.x);\n        vec2 iv = vec2(told, t);\n        \n        for (int j = 0 ; j < 8 ; j++) {\n        \tmid = dot(iv, vec2(.5));\n            res = map(rd*mid + ro, concernWater);\n            d = res.x;\n        \tm = res.y;\n            if (abs(d) < PRECISION) break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y),step(0.0, d*dn));\n        }\n        t = mid;\n    }\n    \n    return vec2(min(t, FAR), res.y);\n    \n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 calcuNormal(in vec3 p, float concernWater)\n{  \n    vec2 e = vec2(-1., 1.)*0.03;   \n\treturn normalize(e.yxx*map(p + e.yxx, concernWater).x + e.xxy*map(p + e.xxy, concernWater).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx, concernWater).x + e.yyy*map(p + e.yyy, concernWater).x );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float concernWater)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t , concernWater).x;\n        res = min( res, 0.4*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<PRECISION || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos , 1.0).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 cloud(in vec3 bgCol, in vec3 ro, in vec3 rd, float spd) {\n    float t = iTime*spd;\n    vec2 sc = ro.xz + rd.xz*(120000.)/rd.y;\n    vec2 p = sc * 0.000007;\n    float f = 0.;\n    float s = 1.;\n    float sum = 0.;\n    for (int i = 0 ; i < 6 ; i++) {\n    \tp += t;\n        t *= 1.5;\n        f += s*abs(noise(vec3(p, 0.)));\n        p = m2 * p * 2.01;\n        sum += s;\n        s *= 0.6;\n    }\n    vec3 col = mix(bgCol, vec3(1.), smoothstep(0.0, 1.0, pow(f/sum, 0.5)) * pow(max(rd.y, 0.), 0.5));\n    //col = vec3(f/sum);\n    return col;\n}\n\nvec3 sun(vec3 lightPos, in vec3 ro, in vec3 rd) {\n\tfloat sunStength = clamp(dot(rd, normalize(lightPos)), 0., 1.);\n    vec3 col = 0.2*vec3(1.0, 0.5, 0.4) * pow(sunStength, 256.0);\n    col += 1.8*vec3(1.0, 0.5, 0.4) * pow(sunStength, 512.0);\n    //col += 0.4*vec3(1.0, 0.7, 0.4) * pow(sunStength, 1024.0);\n    return col;\n}\n/*\nvec3 bgCol1 = vec3(1.0);\nvec3 bgCol2 = vec3(0.9137, 0.9176, 0.898);\nvec3 bgCol3 = vec3(0.9137, 0.9176, 0.898);\n*/\n//vec3 mountainCol = vec3(0.6, 0.49, 0.313)*0.5;\nvec3 bgCol1 = vec3(0.98, 0.95, 0.93);\nvec3 bgCol2 = vec3(0.125, 0.550, 0.60);\nvec3 bgCol3 = vec3(0.0, 0.40, 0.41);\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n\t\n    vec3 skyCol = mix(bgCol2, bgCol3, smoothstep(0., 0.3, rd.y));\n    skyCol = mix(bgCol1, skyCol, smoothstep(-0.3, 0.12, rd.y));\n    skyCol = cloud(skyCol, ro, rd, .3);\n    \n    skyCol += sun(vec3(-0.7, 0.3, 1.0), ro, rd);\n    \n    return skyCol;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec2 res = rayMarching(ro, rd, 1.0);\n    float t = res.x;\n    float m = res.y;\n    vec3 col = vec3(0.);\n    vec3 shdCol = vec3(0.1294, 0.1882, 0.207);\n    \n    vec3 bgCol = sky(ro, rd);\n    \n    if (t < FAR) {\n        vec3 sp = ro + rd*t;\n    \tvec3 nor = calcuNormal(sp, 1.0); \n        \n        vec3 lp =vec3(10.0*sin(time/1.), 7.0, 10.0*cos(time/1.)+time*3.-4.);\n        vec3 ld = normalize(lp - sp);\n        ld = vec3(-1.0, 0.8, -1.0);\n        lp = normalize(ld + sp);   \n\n        //float shd = softShadow(sp, ld, 0.5, FAR, 3.);\n        float shd = calcSoftshadow( sp, ld, 0.5, FAR, 1.0);\n\n        float occ = calcAO( sp, nor );\n\n        vec3 hal = normalize( ld - rd );\n        float amb = clamp( 0.3+ 0.7*nor.y, 0.0, 1.0 );\n        float dif = max( dot( ld, nor ), 0.0); // Diffuse term.\n        //dif += 0.5*max( dot( ld*vec3(-1., 1., -1.), nor ), 0.0); // Diffuse term.\n        float speWater = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 128.0)*dif ; // Specular term.\n        float speMoun = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 32.0)*dif ; // Specular term.\n        float bac = clamp( dot( nor, normalize(vec3(-lp.x,0.0,-lp.z))), 0.0, 1.0 )*clamp( 1.0-sp.y,0.0,1.0);\n        float fre = clamp(1.0 + dot(rd, nor), 0.0, 1.0); // Fresnel reflection term.\n\n        \n        if(res.y == 0.0) {\n            float fre = clamp(dot(-rd, nor), 0.0, 0.2);\n            fre = smoothstep(0., 0.6, pow(fre, 1.6));\n            fre = fre * 0.7;\n            vec3 reflectCol = sky(sp, reflect(rd, nor));\n            \n        \tcol = mix(reflectCol, vec3(0.2, 0.3, 0.4), fre);\n            \n        \t//col = vec3(lin);\n            \n            vec3 nrd = refract(rd, nor, 1./1.333);\n            vec2 nres = rayMarching(sp, nrd, 0.0);\n            float nt = nres.x;\n            float nm = nres.y;\n            vec3 nsp = sp + nrd*nt;\n            vec3 nnor = calcuNormal(nsp, 0.0);\n            \n        \tfloat nshd = calcSoftshadow( sp, ld, 0.5, FAR, 0.0 );\n            \n            vec3 nhal = normalize( lp - nrd );\n            float namb = clamp( 0.3+ 0.7*nnor.y, 0.0, 1.0 );\n            float ndif = max( dot( ld, nnor ), 0.0); // Diffuse term.\n            float nspeMoun = pow( clamp( dot( nnor, nhal ), 0.0, 1.0 ), 32.0)*ndif ; // Specular term.\n            vec3 ncol = tex3D( iChannel0,sp/10., nnor );\n            \n            vec3 nlin = vec3(1.) * ndif * nshd;\n            nlin += 0.5*namb*bgCol2;\n            nlin += 0.1*nspeMoun*vec3(1.0,1.0,1.0);\n\n            ncol *= nlin;\n            \n            col = mix(ncol, col, smoothstep(0.0, 1., (1.-fre*0.7 )*smoothstep(0.0, 1.7, 0.5+nt)));\n            \n            col += speWater*vec3(1.0,1.0,1.0)*occ;\n            col *= smoothstep(0.0, 0.4, shd);\n            //col = ncol;\n        } else {\n\t\t\tvec3 mountainCol = tex3D( iChannel0, sp/10., nor );\n            col = mountainCol;\n            col = mix(col, vec3(0.9), smoothstep(0.45, 0.6, dot(nor, normalize(vec3(-0.3, 1.0, 0.0))\t)));\n            col = mix(col, mountainCol, 1.-smoothstep(0., 1., m\t));\n\n            vec3 lin = vec3(1.) * dif * shd;\n            lin += 0.5*amb*bgCol2*occ;\n            //lin += 0.3*bac*vec3(0.4)*occ;\n            lin += 0.1*speMoun*vec3(1.0,1.0,1.0)*occ;\n\n            col *= lin;\n\n\n            //col = vec3(shd);\n            //col = vec3(smoothstep(0.4, 0.52, nor.y));\n            //col = vec3(speMoun);\n\n        }\n        \n\n    } else {\n        col = bgCol;\n    }\n    float e = clamp(dot(rd, normalize(vec3(-0.7, 0.3, 1.0))), 0.0, 1.0);\n    vec3 fogCol = mix(bgCol, vec3(1.0, 1.0, 0.9)*1.2, pow(e, 32.));\n    col = mix(col, fogCol, smoothstep(5., FAR, t));\n    \n    col = mix(col, fog(col, ro, rd, t*1.2), 1.);\n    //col = pow(col, vec3(0.9));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 ro = vec3(0., 12., time*4.);\n    vec3 lookAt = vec3(sin(mouse.x*3.1415926*2.), ro.y, ro.z+cos(mouse.x*3.1415926*2.));\n    mat3 viewMat = setCamera(ro, lookAt);\n    vec3 rd = viewMat * normalize(vec3(p, 1.5));\n    \n    vec3 col = render( ro, rd );\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 246, 246, 415], [416, 416, 439, 439, 475], [476, 476, 502, 502, 1327], [1329, 1329, 1355, 1355, 2190], [2191, 2191, 2213, 2213, 2238], [2239, 2239, 2260, 2260, 2340], [2341, 2341, 2384, 2384, 2684], [2686, 2686, 2723, 2723, 2841], [2843, 2843, 2903, 2903, 3306], [3378, 3532, 3582, 3582, 3737], [3739, 3739, 3777, 3777, 3951], [3953, 3953, 3993, 3993, 4089], [4091, 4091, 4129, 4129, 5048], [5051, 5051, 5107, 5107, 6025], [6027, 6066, 6115, 6115, 6340], [6342, 6342, 6439, 6439, 6717], [6719, 6719, 6761, 6761, 7065], [7067, 7067, 7129, 7129, 7603], [7605, 7605, 7654, 7654, 7927], [7928, 8210, 8244, 8244, 8496], [8499, 8499, 8530, 8530, 12221], [12223, 12223, 12280, 12330, 12716]], "test": "error"}
{"id": "MstfDl", "name": "isovalues 4b", "author": "FabriceNeyret2", "description": "adapting [url]https://shadertoy.com/view/ldfcRS[/url] + 3D + pseudo depth of field", "tags": ["noise", "dof", "depthoffield", "contour"], "likes": 6, "viewed": 440, "published": "Public API", "date": "1527281177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"isovalues 4\" by FabriceNeyret2. https://shadertoy.com/view/MdtfDl\n// 2018-05-25 20:28:14\n\n// variant of https://shadertoy.com/view/ldfcRS\n\n// --- noise from procedural pseudo-Perlin (better but not so nice derivatives) ---------\n                    // ( adapted from IQ )\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    vec2 u = U/iResolution.y;\n    U = 6.*u;// - iTime;\n    O -= O; \n    for (float z=0.; z<=1.; z+=.05, U.y -= .1) { // consider 1 isovalue per altitude\n        float n = ( noise(vec3(U.x-U.y*.1,U.y/.6,.5*iTime))-.2) / .6,\n              v = smoothstep(0.,1.5+20.*abs(u.y-.5), (n-z)/fwidth(n));\n\t    O = mix(O, vec4(n), v);\n\t // O = mix(O, z*vec4(.5,1,1,1), v);\n\t // O = mix(O, z*(.5+.5*cos(6.3*z + vec4(0,23,21,0) )), v);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 285, 309, 309, 872], [971, 971, 1040, 1040, 1470]], "test": "valid"}
{"id": "MstfR2", "name": "Circle packing loop free", "author": "akhgary", "description": "move mouse to change radii.\n\nInstead of using loops to calculate center of each circle, the plane is translated to center of each circle.\n\ncircle packing for second layer would be nightmare, but ill work on that.", "tags": ["circle", "plot", "draw", "circlepacking", "loopfree"], "likes": 2, "viewed": 120, "published": "Public", "date": "1526024882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hue taken from https://www.shadertoy.com/view/4tlBWB\n\n#define tau 6.28318\n//#define pi 3.14159\n\nvec3 hue( in vec3 c )\n{\n\treturn c.z*(1.-c.y*smoothstep(2.,1.,abs(mod(c.x*6.+vec3(0,4,2),6.) -3.)));\n}\n\nfloat circle(vec2 xy, vec2 c, float r, bool fill){\n    float dist = length(xy-c)-r;\n    return 1.-smoothstep(0.,3./iResolution.y,fill?dist:abs(dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\tvec3 col = vec3(0);\n    \n    if(iMouse.xy == vec2(0)) mouse = vec2(.25); // preview icon\n        \n    float ep = 1e-2; \t\t\t\t\t// epsilon (fix edge cases)\n    vec2 C = vec2(0); \t\t\t\t\t// center\n    float R = mouse.x+ep;\t\t\t\t// central circle radius\n\tfloat r = mouse.y+ep;\t\t\t\t// surrounding circle radius\n\n\tfloat t = 2.*asin(r/(R+r)); \t\t// theta for each surrounding circle\n\tfloat ph = iTime/10.;               // time phase\n    \n    float div = abs(tau/t)+ep;\n\tint n = int(div); \t\t\t\t\t// number of surrounding circles\n    float pad = fract(div)*t/float(n);\t// circles padding                                       \n    \n    float rt = -t/2.-pad/2.+ph;\t\t\t// plane rotation\n    mat2 rm = mat2(cos(rt),-sin(rt),sin(rt),cos(rt));\n    vec2 zw = rm*(xy-C);\t\t\t\t// rotated plane\n    \n    float i = floor((atan(zw.y,zw.x))/(t+pad));                 // translate plane for surrounding circles\n    vec2 c = vec2(cos(i*(t+pad)+ph),sin(i*(t+pad)+ph))*(r+R)+C; // center of surrounding circles\n    \n    col+=circle(xy, C, R, false);\t\t// draw central circle\n    vec3 hsl = vec3(i/float(n),.75,1.); // color for each surrounding circle\n    col+=circle(xy,c,r,true)*hue(hsl);  // draw surrounding circles\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstfR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 99, 122, 122, 200], [202, 202, 252, 252, 354], [356, 356, 413, 413, 1734]], "test": "valid"}
{"id": "MstfRj", "name": "Rosaic", "author": "hu9o", "description": ".", "tags": ["mosaic", "rose", "rosace", "mandala"], "likes": 7, "viewed": 266, "published": "Public", "date": "1525985492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int rayCount = 12;\n    vec3 color1 = vec3(1.,.9,0.);\n    vec3 color2 = vec3(0.,0.4,.3);\n    \n    // center\n    vec2 c = (fragCoord - vec2(iResolution) * .5) / iResolution.y;\n    \n    // cartesian to polar\n\tfloat angle = atan(c.y, c.x);\n    float dist = length(c);\n    \n    // normalize angle\n    angle /= (2.*PI);\n    \n    // fraction angle\n    float mask = 1.;\n    \n    // radial gradient\n    float distRound = (1. - ceil(dist*10.*.5+.25)*.1);\n    float time2 = (fract(dist*10.*.5+.25) > 0.5 ? -iTime : iTime) * distRound; // cw/ccw alternatively\n    float ngfract = fract(angle * round(10. / (distRound * distRound)) + time2 * .6);\n    ngfract = abs(ngfract*2. - 1.);\n    ngfract *= fract(dist*10.) > .5 ? -1. : 1.;\n    mask -= ceil(dist*10. + .5 + ngfract*.5)*.1;\n    \n    //mask *= .8 + .2 * fract(dist*10.*.5+.25);\n    \n    // output\n    fragColor = vec4(mix(vec3(.7, .0, .9)*.3,mix(color2, color1, mask),distRound),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 1036]], "test": "valid"}
{"id": "MstfWf", "name": "Flying paint strokes", "author": "CoyHot", "description": "My first experiment with Raymarching / Sphere Tracing. Just to learn this new concept to me :\n\nTrying to combine distorsions on a simple sphere (i add some comments to explain what I do).\nNot optimized and maybe dirty, need a few seconds to \"stabilize\".", "tags": ["raymarching"], "likes": 13, "viewed": 467, "published": "Public", "date": "1527092197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -------------------------------------------------------\n// ---------------  Flying paint strokes -----------------\n// Francois 'CoyHot' Grassard, May 2018\n// My first real attempt with Raymarching / Sphere Tracing\n// -------------------------------------------------------\n\n\n\nfloat map(vec3 p)\n{\n  // Define some temporal and/or spatial references \n  float a =sin(iTime);\n  float b = p.z/6.0;\n  float c = 0.75+(sin((iTime*p.z)*3.)/12.);\n  float d = iTime/5.;\n\n  // --> Reminder : The next steps have to be read from bottom to top <--\n\n  // Rotate the whole scene\n  p.xy *= mat2(cos(d), sin(d), -sin(d), cos(d));\n\n\n  // Add turbulences on each axes, based on Z value\n  p.x += cos(b)*7.;\n  p.y += sin(b)*7.;\n  p.z += sin(b)*7.;\n\n\n  // Twist the whole scene alond Z axis\n  p.xy *= mat2(cos(b), sin(b), -sin(b), cos(b));\n\n\n  // Scatter strokes in space to avoid all strokes to be aligned\n  p = vec3(p.x+cos((p.z)),p.y+sin((p.z)),p.z);\n  p = vec3(p.x+cos(p.y),p.y+cos(p.x),p.z);\n\n\n  // Multiply Strokes\n  p = mod(p,16.0)-8.0;\n\n\n  // Rotate strokes globaly, base on global time. On Z AXIS !!!!\n  p.xy *= mat2(cos(cos(a)), sin(cos(a)), -sin(cos(a)), cos(cos(a)));\n\n\n  // Rotate each stroke, based on there own Z Value and global time\n  p.xz *= mat2(cos(c*3.), sin(c*3.), -sin(c*3.), cos(c));\n\n\n  // Add another sin/cos Noise on the surface, also based on Z value, to add some smaller details on the surface (to mimic the tail of the stroke)\n  p.z += (sin(p.x*25.+iTime)/40.);\n  p.z += (cos(p.y*25.+iTime)/40.);\n\n\n  // Rotate the whole shape, based on time\n  p.xy *= mat2(cos(a), sin(a), -sin(a), cos(a));\n\n\n  // Add sin/cos Noise on the surface, based on Z value\n  p.z += (sin(p.x*15.+iTime)/5.);\n  p.z += (cos(p.y*15.+iTime)/5.);\n\n\n  // Return the distance, including a final turbulence based on sin(time) and Z\n  return length(p) - sin((iTime+p.z)*2.0)-.25;\n}\n\n\n\nfloat trace (vec3 o, vec3 d)\n{\n  float t=0.; // Used as a near clipping value (check it with a value of 20.)\n  for(int i = 0; i< 128; i++)\n  {\n    vec3 p = o+d*t;\n    float d = map(p);\n    t += d*0.075;\n  }\n  return t;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    \n\t// 2D Displacement based on texture (produced Tweaked UV) : First Texture\n\tvec4 tex1 = texture(iChannel0, vec2(uv.x,uv.y+iTime/15.));\n\tuv.x += tex1.r/5.5*uv.x;\n\tuv.y += tex1.r/5.5*uv.y;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\t// Camera and ray direction\n\tvec3 pc = vec3(0.+sin(iTime)*1.0,0.+cos(iTime)*1.0,iTime*50.);\n\tvec3 ray = normalize(vec3(uv*1.5,1.));\n\n\tvec3 pixel = vec3(trace(pc,ray));\n\n\t// Add some Color, based on Tweaked UV\n\tpixel.r += uv.x*25.;\n\tpixel.g += uv.y*25.;\n\tpixel.b += uv.x*-25.;\n\n\n\t// Multiply the color by the fog\n\tvec3 fog = 1.0/(1.0+pixel*pixel/10.0)-0.001;    \n    \n\t// Output to screen\n\tfragColor = vec4(pixel*fog,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 279, 298, 351, 1857], [1861, 1861, 1891, 1891, 2081], [2086, 2086, 2143, 2193, 3014]], "test": "error"}
{"id": "MstfWX", "name": "rect load", "author": "skaplun", "description": "Simple loading animation\nCreated with Markus Fisch's Shader Editor ", "tags": ["animation", "loading"], "likes": 9, "viewed": 243, "published": "Public", "date": "1527069334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n#define PI 3.14159265359\n#define QPI 0.78539816339\n\nfloat rect(in vec2 uv, in float r, in vec2 offset){\n    uv += offset;\n    float b = .01;\n    return smoothstep(uv.x - r - b, uv.x - r + b, uv.y) * smoothstep(uv.x + r + b, uv.x + r - b, uv.y)\n    \t \t\t\t   * smoothstep(-uv.x - r - b, -uv.x - r + b, uv.y) * smoothstep(-uv.x + r + b, -uv.x + r - b, uv.y);\n}\n\nvec2 calcPoint(in float ang){\n\tvec2 ppp = vec2(cos(ang), .5 * sin(ang * 2.));\n\treturn vec2(pow(ppp.x, 2.) * sign(ppp.x), ppp.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n\tfloat bg;\n\t{\n\t\tvec2 uv = abs(st);\n\t\tuv -= vec2(.5, 0.);\n\t\tfloat ang = -QPI;\n\t\tuv *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\t\tuv += vec2(.5, 0.);\n\t\tfloat r = distance(uv, vec2(.5, 0.));\n\t  \tfloat a = mod(atan(uv.y, uv.x - .5), PI/2.) - QPI;\n\t  \tvec2 p = vec2(r * cos(a), r * sin(a));\n\t\tbg = rect(p, .475, vec2(-.5, 0.));\n\t}\n\t\n\tfloat time = iTime * 4.;\n\tfloat modAng = mod(time, QPI);\n\tfloat ang = time - modAng;\n\tvec2 emptyPoints[2]; emptyPoints[0] = calcPoint(ang); emptyPoints[1] = calcPoint(ang - QPI);\n        \n    bg -= rect(st, .475, -emptyPoints[0]);\n\tbg = clamp(bg, 0., 1.);\n    bg -= rect(st, .475, -emptyPoints[1]);\n\tbg = clamp(bg, 0., 1.);\n    bg += rect(st, .475, -mix(emptyPoints[0], emptyPoints[1], modAng/QPI));\n\t\n\tfragColor = vec4(bg);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MstfWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 128, 128, 381], [383, 383, 412, 412, 513], [515, 515, 572, 572, 1400]], "test": "valid"}
{"id": "Mstfzj", "name": "Abstract_DNA", "author": "balkhan", "description": " ", "tags": ["raymarching", "dna"], "likes": 12, "viewed": 713, "published": "Public API", "date": "1526272053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t200.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    rotate(dir.xz, iMouse.x*.01);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    ret_col = vec3(.490, .482, .470);\n    col.xyz = ret_col*((1.-inter.x*.005)+inter.y*.005);\n    col += h*.005;\n\n    c_out =  vec4(col,1.0);\n}\n\nvoid mainVR( out vec4 c_out, in vec2 f, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = fragRayDir;\n    vec3\tpos = fragRayOri;\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    ret_col = vec3(.490, .482, .470);\n    col.xyz = ret_col*((1.-inter.x*.005)+inter.y*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tvar;\n    float\tmind = 1e5;\n\n    p.z-=iTime*2.;\n\n    p.y-= -4.;\n    p.z -= -3.;\n    p.x -= 5.;\n    p.y -= -9.;\n    rotate(p.xz, 1.5);\n    vec3 sp = p;\n    vec3 op = p;\n    \n    p = op;\n    \n    float dd = .030625;\n\top.zy = fract(op.zy*dd)-.5;\n    op.zy /=dd;\n\n    rotate(op.yz, -iTime*.25 + op.x*.15);\n    float num = .5;\n    vec3 rp = op;\n    op.x = fract(op.x*num)-.5;\n    op.x /= num;\n    p = op;\n    \n    p = p.xyz-vec3(.0, -0., 0.);\n    p.z = abs(p.z)-10.;\n    float mada = max(max(abs(p.x)-.9, abs(p.y)-.8), abs(p.z)-.62 );\n    float light_wave = length(p.zy-vec2(-4.0,-8.))-1.*sin(rp.x*.25+iTime);\n    light_wave = abs(light_wave)+.05;\n    float light_wave2 = mylength( (fract((sp-vec3(.0+iTime*4.,.0,0.) ).xyz*.03125)-.5)/.03125 )-16.;\n    mada = min(mada, light_wave);\n    light_wave2 = abs(light_wave2)+.05;\n\n    h += vec3(.1, .4, .1)*vec3(1.)*.25/max(.001, .051 + 1.*light_wave*light_wave );\n    h += vec3(.51, .4, .1)*vec3(1.)*.25/max(.001, .051 + 1.*light_wave2*light_wave2 );\n    mind = min(mind, mada);\n    \n    p = op;\n    float ten0 = mylength(p.xy)-.2;\n    p = op;\n    p.z = fract(p.z*3.)-.5;\n    p.z /= 3.;\n\n    rotate(p.xy, (op.z*1.)*1.+iTime*1. );\n\n    float ming = mylength(vec3(abs(p.y)-.5, p.xz))-.105;\n\n    float caps = 1e5;\n    rotate(p.xz, p.y*5.+iTime*-4.);\n    p.xz = modA(p.xz, 2.);\n    p.x -= .06125;\n    \n    caps = max(length(p.xz)-.01, -p.y-0.9*.5);\n    caps = max(caps, p.y-.9*.5);\n    caps = min(caps, max(max(length(vec2(p.z, (fract(p.y*16.)-.5)/16. ) )-.01, p.x-.01), -p.x-.05) );\n    caps = max(caps, +p.y-.5);\n    caps = max(caps, -p.y-.5);\n    ming = min(ming, caps);\n    ming = max(ming, op.z-10.);\n    ming = max(ming, -op.z-10.);\n    ten0 = ming;\n    ten0 = min(ten0, mada);\n    p = op;\n    p.yx = modA(p.yx, 5.);\n    p.y -= 3.;\n    p.x = max(abs(fract(p.z)-.5 ), max(abs(p.x), abs(p.y)))-.5125;\n    float ten1 = 1e5+length(p.xy)-.02;\n    float ten2 = min(ten0, ten1);\n\n    mind = min(mind, ten2);\n\n    h -= (vec3(.05,.05,-0.505))*vec3(1.)*.0125/max(.01, .01+mind*mind);\n\n    return (mind)*.75;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max(abs(p.x), abs(p.y));\n\n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max(max(abs(p.x), abs(p.y)), abs(p.z));\n\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mstfzj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[616, 687, 720, 720, 851], [853, 876, 919, 919, 1319], [1321, 1321, 1403, 1403, 1761], [1763, 1763, 1784, 1784, 3834], [3836, 3836, 3868, 3868, 4279], [4281, 4295, 4319, 4319, 4386], [4388, 4388, 4412, 4412, 4494], [4496, 4496, 4536, 4536, 4611], [4613, 4613, 4641, 4641, 4749], [4751, 4751, 4773, 4773, 4979], [4981, 4981, 5031, 5031, 5294]], "test": "error"}
{"id": "MsVcDd", "name": "Robot on a trampoline", "author": "joelamartina", "description": "robot on a trampoline", "tags": ["robot"], "likes": 2, "viewed": 79, "published": "Public", "date": "1525203073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nconst int MAX_MARCHING_STEPS = 255;\n\nconst float MIN_DIST = 0.0;\n\nconst float MAX_DIST = 100.0;\n\nconst float EPSILON = 0.0001;\n\n\n\n/**\n\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n\n */\n\nfloat intersectSDF(float distA, float distB) {\n\n   return max(distA, distB);\n\n}\n\n\n\n/**\n\n * Constructive solid geometry union operation on SDF-calculated distances.\n\n */\n\nfloat unionSDF(float distA, float distB) {\n\n   return min(distA, distB);\n\n}\n\n\n\n/**\n\n * Constructive solid geometry difference operation on SDF-calculated distances.\n\n */\n\nfloat differenceSDF(float distA, float distB) {\n\n   return max(distA, -distB);\n\n}\n\n\n\n/**\n\n * Signed distance function for a cube centered at the origin\n\n * with width = height = length = 2.0\n\n */\n\nfloat cubeSDF(vec3 p) {\n\n   // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n\n   // So if all components of d are negative, then p is inside the unit cube\n\n   vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n\n\n\n   // Assuming p is inside the cube, how far is it from the surface?\n\n   // Result will be negative or zero.\n\n   float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n\n\n   // Assuming p is outside the cube, how far is it from the surface?\n\n   // Result will be positive or zero.\n\n   float outsideDistance = length(max(d, 0.0));\n\n\n\n   return insideDistance + outsideDistance;\n\n}\n\n\n\n/**\n\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n\n */\n\nfloat sphereSDF(vec3 p) {\n\n   return length(p) - 1.0;\n\n}\n\n\n\n/**\n\n * Signed distance function describing the scene.\n\n *\n\n * Absolute value of the return value indicates the distance to the surface.\n\n * Sign indicates whether the point is inside or outside the surface,\n\n * negative indicating inside.\n\n */\n\nfloat sceneSDF(vec3 samplePoint) {\n\n   //float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n\n   //float cubeDist = cubeSDF(samplePoint + vec3(0.0, sin(iTime), 0.0));\n    \n       //float sphereDist = sphereSDF((samplePoint + vec3(0.0, sin(iTime), 0.0))/0.1) * 0.1;\n\n   float body = cubeSDF((samplePoint + vec3(0.0,sin(iTime),0.0))/0.6)*0.6;\n    float head = cubeSDF((samplePoint + vec3(0.0,sin(iTime)-1.0,0))/0.3)*0.3;\n    \n    float eye1 = sphereSDF((samplePoint+vec3(0.2, sin(iTime)-1.2,-0.3))/0.1)*0.1;\n    float eye2 = sphereSDF((samplePoint+vec3(-0.2, sin(iTime)-1.2,-0.3))/0.1)*0.1;\n    float eyes = unionSDF(eye1, eye2);\n    float mouth = sphereSDF((samplePoint+vec3(0.0, sin(iTime)-0.9,-0.3))/0.13)*0.13;\n    float moutheyes = unionSDF(eyes, mouth);\n    \n    float face = differenceSDF(head, moutheyes);                      \n    float bodyhead = unionSDF(body,face);\n    \n    float shoulder1 = cubeSDF((samplePoint + vec3(1.0,sin(iTime),0))/0.2)*0.2;\n    float wrist1 = cubeSDF((samplePoint + vec3(1.4,sin(iTime),0))/0.2)*0.2;\n    float shoulder2 = cubeSDF((samplePoint + vec3(-1.0,sin(iTime),0))/0.2)*0.2;\n    float wrist2 = cubeSDF((samplePoint + vec3(-1.4,sin(iTime),0))/0.2)*0.2;\n    float hand1 = cubeSDF((samplePoint + vec3(1.4,sin(iTime),-0.4))/0.2)*0.2;\n    float hand2 = cubeSDF((samplePoint + vec3(-1.4,sin(iTime),-0.4))/0.2)*0.2;\n    \n    float upperarm1 = unionSDF(shoulder1, wrist1);\n    float upperarm2 = unionSDF(shoulder2, wrist2);\n    float arm1 = unionSDF(upperarm1, hand1);\n    float arm2 = unionSDF(upperarm2, hand2);\n    \n    float arms = unionSDF(arm1, arm2);\n    float torso = unionSDF(arms, bodyhead);\n    \n  \tfloat thigh1 = cubeSDF((samplePoint + vec3(-0.4,sin(iTime)+0.8,0))/0.2)*0.2;\n    float ankle1 = cubeSDF((samplePoint + vec3(-0.4,sin(iTime)+1.2,0))/0.2)*0.2;\n    float thigh2 = cubeSDF((samplePoint + vec3(0.4,sin(iTime)+0.8,0))/0.2)*0.2;\n    float ankle2 = cubeSDF((samplePoint + vec3(0.4,sin(iTime)+1.2,0))/0.2)*0.2;\n    float foot1 = cubeSDF((samplePoint + vec3(-0.4,sin(iTime)+1.2,-0.4))/0.2)*0.2;\n    float foot2 = cubeSDF((samplePoint + vec3(0.4,sin(iTime)+1.2,-0.4))/0.2)*0.2;\n    \n    float upperleg1 = unionSDF(thigh1, ankle1);\n    float upperleg2 = unionSDF(thigh2, ankle2);\n    float leg1 = unionSDF(upperleg1, foot1);\n    float leg2 = unionSDF(upperleg2, foot2);\n    \n    float legs = unionSDF(leg1, leg2);\n    float robot = unionSDF(torso, legs);\n    \n    float ball = sphereSDF((samplePoint+vec3(0.0, sin(iTime)+2.0,-0.3))/0.7)*0.7;\n    float ground = cubeSDF((samplePoint+vec3(0.0,4.0,-0.3))/2.0)*2.0;\n    float base = intersectSDF(ball, ground);\n    \n    float difference = differenceSDF(ground, robot);\n    \n    float scene = unionSDF(robot, ground);\n    \n    float fullscene = unionSDF(difference,scene);\n\n\n   //return intersectSDF(cubeDist, sphereDist);\n    //return differenceSDF(cubeDist, sphereDist);\n     //return differenceSDF(cubeDist, sphereDist);\n    //return unionSDF(cubeDist2, differenceSDF(cubeDist, sphereDist));\n    \n    //return fullscene;\n    return fullscene;\n  \n\n}\n\n\n\n/**\n\n * Return the shortest distance from the eyepoint to the scene surface along\n\n * the marching direction. If no part of the surface is found between start and end,\n\n * return end.\n\n *\n\n * eye: the eye point, acting as the origin of the ray\n\n * marchingDirection: the normalized direction to march in\n\n * start: the starting distance away from the eye\n\n * end: the max distance away from the ey to march before giving up\n\n */\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n\n   float depth = start;\n\n   for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\n       float dist = sceneSDF(eye + depth * marchingDirection);\n\n       if (dist < EPSILON) {\n\n         return depth;\n\n       }\n\n       depth += dist;\n\n       if (depth >= end) {\n\n           return end;\n\n       }\n\n   }\n\n   return end;\n\n}\n\n\n\n\n\n/**\n\n * Return the normalized direction to march in from the eye point for a single pixel.\n\n *\n\n * fieldOfView: vertical field of view in degrees\n\n * size: resolution of the output image\n\n * fragCoord: the x,y coordinate of the pixel in the output image\n\n */\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n\n   vec2 xy = fragCoord - size / 2.0;\n\n   float z = size.y / tan(radians(fieldOfView) / 2.0);\n\n   return normalize(vec3(xy, -z));\n\n}\n\n\n\n/**\n\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n\n */\n\nvec3 estimateNormal(vec3 p) {\n\n   return normalize(vec3(\n\n       sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n\n       sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n\n       sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n\n   ));\n\n}\n\n\n\n/**\n\n * Lighting contribution of a single point light source via Phong illumination.\n\n *\n\n * The vec3 returned is the RGB color of the light's contribution.\n\n *\n\n * k_a: Ambient color\n\n * k_d: Diffuse color\n\n * k_s: Specular color\n\n * alpha: Shininess coefficient\n\n * p: position of point being lit\n\n * eye: the position of the camera\n\n * lightPos: the position of the light\n\n * lightIntensity: color/intensity of the light\n\n *\n\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n\n */\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n\n                         vec3 lightPos, vec3 lightIntensity) {\n\n   vec3 N = estimateNormal(p);\n\n   vec3 L = normalize(lightPos - p);\n\n   vec3 V = normalize(eye - p);\n\n   vec3 R = normalize(reflect(-L, N));\n\n\n\n   float dotLN = dot(L, N);\n\n   float dotRV = dot(R, V);\n\n\n\n   if (dotLN < 0.0) {\n\n       // Light not visible from this point on the surface\n\n       return vec3(0.0, 0.0, 0.0);\n\n   }\n\n\n\n   if (dotRV < 0.0) {\n\n       // Light reflection in opposite direction as viewer, apply only diffuse\n\n       // component\n\n       return lightIntensity * (k_d * dotLN);\n\n   }\n\n   return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n\n}\n\n\n\n/**\n\n * Lighting via Phong illumination.\n\n *\n\n * The vec3 returned is the RGB color of that point after lighting is applied.\n\n * k_a: Ambient color\n\n * k_d: Diffuse color\n\n * k_s: Specular color\n\n * alpha: Shininess coefficient\n\n * p: position of point being lit\n\n * eye: the position of the camera\n\n *\n\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n\n */\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n\n   const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n\n   vec3 color = ambientLight * k_a;\n\n\n\n   vec3 light1Pos = vec3(4.0 * sin(iTime),\n\n                         2.0,\n\n                         4.0 * cos(iTime));\n\n   vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\n\n\n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n\n                                 light1Pos,\n\n                                 light1Intensity);\n\n\n\n   vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n\n                         2.0 * cos(0.37 * iTime),\n\n                         2.0);\n\n   vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n\n\n\n   color += phongContribForLight(k_d, k_s, alpha, p, eye,\n\n                                 light2Pos,\n\n                                 light2Intensity);   \n\n   return color;\n\n}\n\n\n\n/**\n\n * Return a transform matrix that will transform a ray from view space\n\n * to world coordinates, given the eye point, the camera target, and an up vector.\n\n *\n\n * This assumes that the center of the camera is aligned with the negative z axis in\n\n * view space when calculating the ray marching direction. See rayDirection.\n\n */\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\n   // Based on gluLookAt man page\n\n   vec3 f = normalize(center - eye);\n\n   vec3 s = normalize(cross(f, up));\n\n   vec3 u = cross(s, f);\n\n   return mat4(\n\n       vec4(s, 0.0),\n\n       vec4(u, 0.0),\n\n       vec4(-f, 0.0),\n\n       vec4(0.0, 0.0, 0.0, 1)\n\n   );\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n   vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n   vec3 eye = vec3(8.0, 5.0, 7.0);\n\n\n\n   mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n\n\n   vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n\n\n   float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n\n\n   if (dist > MAX_DIST - EPSILON) {\n\n       // Didn't hit anything\n\n       fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n      return;\n\n   }\n\n\n\n   // The closest point on the surface to the eyepoint along the view ray\n\n   vec3 p = eye + dist * worldDir;\n\n\n\n   vec3 K_a = vec3(0.2, 0.2, 0.2);\n\n   vec3 K_d = vec3(0.7, 0.2, 0.2);\n\n   vec3 K_s = vec3(1.0, 1.0, 1.0);\n\n   float shininess = 10.0;\n\n\n\n   vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n\n\n   fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 227, 273, 273, 306], [310, 397, 439, 439, 472], [476, 568, 615, 615, 649], [653, 765, 788, 939, 1368], [1372, 1464, 1489, 1489, 1520], [1524, 1770, 1804, 2037, 4816], [4820, 5250, 5341, 5341, 5655], [5661, 5921, 5986, 5986, 6119], [6123, 6215, 6244, 6244, 6554], [6558, 7065, 7205, 7205, 7786], [7790, 8172, 8257, 8257, 9045], [9049, 9383, 9432, 9467, 9694], [9698, 9698, 9756, 9756, 10584]], "test": "valid"}
{"id": "MsyyRc", "name": "Twisty", "author": "felipunkerito", "description": "Mouse does stuff", "tags": ["3d", "sdf", "antialiasing"], "likes": 4, "viewed": 401, "published": "Public API", "date": "1525712086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS      0.002\n#define STEPS     1028\n#define FAR      100.0\n#define PI 3.141592653\n#define REFLECTIONS  3\n// AA from https://www.shadertoy.com/view/XlyGzh\n#define SS\n// When SS is defined uncomment the next line to get reflections\n//#define REFLECT\n\nconst float f = 1.5;\nconst int samples = 2;\n\nvec3 modP( vec3 p )\n{\n\n    float rep = 10.0;\n    float a = atan( p.y, p.x );\n    float r = length( p.xy );\n    a = mod( a, 2.0 * PI / rep ) - PI / rep;\n    p.xy = r * vec2( cos( a ), sin( a ) );\n    p.x -= 1.8;\n    p.z = mod( p.z, 1.0 ) - 0.5;\n    \n    return p;\n\n}\n\nvec3 twiY( vec3 p, float f )\n{\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.y == 0.0 ) mou = vec2( 0, sin( iTime * 0.2 ) );\n    \n    float a = mou.y * p.y * f;\n    \n    p.xz = cos( a ) * p.xz + sin( a ) * vec2( -p.z, p.x );\n    \n    return p;\n\n}\n\nvec3 twiX( vec3 p, float f )\n{\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    if( mou.x == 0.0 ) mou = vec2( 0.3, 0 );\n    \n    float a = mou.x * p.x * f;\n    \n    p.yz = cos( a ) * p.yz + sin( a ) * vec2( -p.z, p.y );\n    \n    return p;\n\n}\n\nfloat sph( vec3 p ) \n{\n    \n    return length( p ) - 1.3;\n\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    \n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\n}\n\nfloat pla( vec3 p )\n{\n\n    return p.y + 2.0;\n\n}\n\nvec2 map( vec3 p )\n{\n\n    vec2 pla = vec2( pla( p ), 1.0 );\n    p = twiX( p, 2.0 );\n    p = twiY( p, 2.0 );\n    vec2 cub = vec2( sdBox( p, vec3( 1.0 ) ), 0.0 );\n    vec2 sds = vec2( sph( p ), 0.0 );\n    vec2 fin = max( -sds, cub );\n    \n    if( pla.x < fin.x ) fin = pla;\n\n    return fin;\n    \n}\n\nvec3 nor( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0.0 );\n    return normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                            map( p + e.yxy ).x - map( p - e.yxy ).x,\n                            map( p + e.yyx ).x - map( p - e.yyx ).x\n                           )\n                     );\n    \n}\n\nfloat ray( in vec3 ro, in vec3 rd, out float d )\n{\n\n    float t = 0.0;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = 0.5 * map( ro + rd * t ).x;\n        if( d < EPS || t > FAR ) break;\n        t += d;\n    \n    }\n    \n    return t;\n        \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )  \n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t ).x;\n        res = min( res, 8.0 * h / t );\n        \n        t += h;\n    \n    }\n    \n    return res;\n\n}\n\nvec3 sha( vec3 ro, vec3 rd )\n{\n\n    vec3 col = vec3( 0.0 );\n    vec3 lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n    \n    float d = EPS;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = nor( p );\n    vec3 ref = reflect( rd, n );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float bac = max( 0.0, 0.5 + 0.2 * dot( n, blig ) );\n    float sha = softShadows( p, lig );\n    float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n    float speO = pow( clamp( dot( ref, blig ), 0.0, 1.0 ), 16.0 );\n    \n    col += amb * vec3( 0.1, 0.15, 0.2 );\n    col += dif * vec3( 1.0, 0.97, 0.85 ) * sha;\n    col += 1.0 * spe;\n    col += 1.0 * speO;\n    if( map( p ).y == 1.0 ) col *= vec3( 2.0 );\n    if( map( p ).y == 0.0 ) col *= n;\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = 3.0 * vec3( sin( 0.0 ), 0.0, cos( 0.0) );\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    // Camera matrix\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww  ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    \n    float d = EPS;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = nor( p );\n    \n    vec3 col = vec3( 0 );\n    \n    #ifdef SS\n    for (int x = - samples / 2; x < samples / 2; x++) {\n        for (int y = - samples / 2; y < samples / 2; y++) {\n\t\t\tvec3 rd = normalize(\n                (float(x) / iResolution.y + uv.x)*uu +\n                (float(y) / iResolution.y + uv.y)*vv +\n                f*ww );\n            t = ray(ro, rd, d);\n            col += d < EPS ? sha( ro, rd ) : mix( vec3( 1.0 ), vec3( 0.4, 0.2, 0.1 ), uv.y );\n        }\n    }\n    \n    col = col / float(samples * samples);\n    col *= vec3( samples * samples );\n    \n    #ifdef REFLECT\n    \n    if( map( p ).y == 0.0 )\n        \n    for( int i = 0; i < REFLECTIONS; i++ )\n    {\n\n        p = p + ro * 0.05;\n        p += EPS * rd;\n        ro = p + rd * 0.02;\n        rd = reflect( rd, n );\n\n        col += d < EPS ? sha( ro, rd ) : vec3( 0.0 );\n        \n    }\n    \n    #else\n    \n    #endif\n\n\tfragColor = vec4( col / float(samples * samples), 1.0 );\n\n    #else\n    \n    col = d < EPS ? sha( ro, rd ) : mix( vec3( 1.0 ), vec3( 0.4, 0.2, 0.1 ), uv.y );\n    \n    if( map( p ).y == 0.0 )\n        \n    for( int i = 0; i < REFLECTIONS; i++ )\n    {\n\n        p = p + ro * 0.05;\n        p += EPS * rd;\n        ro = p + rd * 0.02;\n        rd = reflect( rd, n );\n\n        col += d < EPS ? sha( ro, rd ) * 0.1 : vec3( 0.0 );\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 304, 325, 325, 569], [571, 571, 601, 601, 832], [834, 834, 864, 864, 1080], [1082, 1082, 1104, 1104, 1142], [1144, 1144, 1175, 1175, 1272], [1274, 1274, 1295, 1295, 1321], [1323, 1323, 1343, 1343, 1618], [1620, 1620, 1640, 1640, 1938], [1940, 1940, 1990, 1990, 2195], [2197, 2197, 2244, 2244, 2455], [2457, 2457, 2487, 2487, 3310], [3312, 3312, 3369, 3419, 5363]], "test": "valid"}
{"id": "MtXfWS", "name": "koosh", "author": "dahart", "description": "A spikey koosh ball made by raymarching through spherical coordinates", "tags": ["raymarch", "ball", "spherical", "spike", "koosh"], "likes": 4, "viewed": 123, "published": "Public", "date": "1525558956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A Koosh ball\n// Most of this code from one of IQ's ray marching samples\n// The main test/modification here is to use a mod function\n// in spherical coordinates so that each ray march step\n// only has to test against one spike.\n// For fun I added a warp to make the spikes droop\n// downward, to test mixing mixing operations \n// in world space and sphere space.\n\n#define AA 2\n\n//------------------------------------------------------------------\n\nfloat N(float t) {\n\treturn fract(sin(t*10234.324)*123423.23512);\n}\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//------------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// remove r from n, i.e., project n onto plane with normal r\nvec3 remove(vec3 n, vec3 r) {\n    return n - r * dot(n, r) / dot(r, r);\n}\n\n// A generalized cylinder primitive\nfloat sdFatLine(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n    vec3 d = b - a;\n    float t = dot(p - a, d) / dot(d, d);\n    t = min(1.0, max(0.0, t));\n    vec3 cp = a + t * d;\n    float cr = ra + t * (rb - ra);\n    return length(p - cp) - cr;\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 cartesian2Sphere(vec3 sp) {\n    float r = length(sp);\n    float dec = acos(sp.y / r);\n    float heading = atan(sp.z, sp.x);\n    //vec2 pp = vec2(0.5, 0.5) + vec2(cos(heading), sin(heading)) * dec;\n    //return vec3(pp, r);\n    return vec3(heading, dec, r);\n}\n\n// octahedral map\nconst float pi = 3.1415927;\nvec3 uv2sphere(vec2 uv) {\n    uv = 2. * uv - 1.;\n    float d = 1. - (abs(uv.x) + abs(uv.y));\n    float r = 1. - abs(d);\n    // Compute  phi in  first  quadrant (branchless , except  for  the\n    // div -by-zero  test), using  sign(u) to map  the  result  to the\n    // correct  quadrant  below\n    float phi = (r == 0.) ? 0. : (pi / 4.) * ((abs(uv.y) - abs(uv.x)) / r + 1.);\n    float omrr = 1. - r * r;\n    float f = r * sqrt(1. + omrr);\n    float x = f * sign(uv.x) * cos(phi);\n    float y = f * sign(uv.y) * sin(phi);\n    float z = sign(d) * omrr;\n    return vec3(x,y,z);\n}\n\n//------------------------------------------------------------------\n\n\n// signed distance function returns (approximate) signed euclidian distance to nearest object from pos\n// overestimates express as holey objects\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1.0f, 0.0f);\n        \n\tres = opU( res, vec2( sdSphere(    pos-vec3( 0.0, 0.0, 0.0), 2.0 ), 46.9 ) );\n    \n    vec2 rep = vec2(0.15, 0.15);\n    vec3 d = vec3(0.0, 0.0, 1.0);\n    vec3 p = vec3(0.0*rep, 0.0);\n    vec3 p0 = (p);\n    vec3 p1 = (p+d);\n    float r = 0.01;\n    \n    vec3 pp = pos + 0.5 * smoothstep(2.0, 4.0, length(pos.xz)) * vec3(0.0, 1.0, 0.0);\n    \n    pp = cartesian2Sphere(pp);\n\n    vec2 offset = vec2(N2(floor(pp.xz)), N2(floor(pp.xz + vec2(5.0, 15.0))));\n    pp += vec3(rep * offset * 0.5, 0.0);\n    pp.z -= 2.01; // push hair base out to surface of sphere\n\n    pp = opRep(pp, vec3(rep, 0.0));\n\n    res = opU( res, vec2( sdFatLine(pp, p0, p1, r, 0.0) ) );\n\n    return res;\n}\n\n// castRay returns a vec2 pair: ray time to intersection, material id\nvec3 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0; // front plane\n    float tmax = 12.0; // back plane\n   \n    float t = tmin;\n    float m = -1.0; // material\n    \n    const int MAX_STEPS = 256; // may need higher threshold, due to heavily non-linear, non-uniform warpa\n    const float step = 1.f; // may need partial step (< 1.f), due to non-linear, non-uniform warps\n    \n    int i;\n    for( i=0; i<MAX_STEPS; i++ ) \n    {\n\t    float precis = 0.00005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += step * res.x; \n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, i );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// sample a tet at the intersection point to calculate a normal\n// TODO: we may be able to remove one eval of map() here by passing in the last one from the ray cast\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec3 res = castRay(ro,rd);\n    //return vec3(res.z / 256.);// visualize # iters\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 ) {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.1 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = 1.0;//calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.2, 0.7, -0.3) );\n        vec3  lig2 = normalize( vec3(0.2, 0.7, 0.3) );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float dif2 = clamp( dot( nor, lig2 ), 0.0, 1.0 );\n\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= 0.8 + 0.2 * softshadow( pos, lig, 0.02, 2.5 );\n        dom *= 0.8 + 0.2 * softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.00*dif*vec3(1.00,0.80,0.55);\n        lin += 3.00*dif2*vec3(1.00,0.80,0.55);\n\n\t\tlin += 1.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        //lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        //lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = iTime;\n    const float camDist = 4.0;\n    \n    vec3 tot = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.0+camDist*cos(0.1*time + 6.0*mo.x), \n                       0.0 + 3.0*mo.y, 0.0 + camDist*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.0, -0.0, 0.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = 2.0 * col / (col + 1.0);\n        //col = pow( col, vec3(0.4545) );\n\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[379, 449, 467, 467, 515], [516, 516, 535, 571, 743], [744, 744, 762, 818, 961], [963, 1033, 1068, 1068, 1094], [1096, 1157, 1186, 1186, 1230], [1232, 1268, 1329, 1329, 1515], [1517, 1587, 1617, 1617, 1650], [1652, 1652, 1682, 1682, 1711], [1713, 1713, 1745, 1745, 1976], [1978, 2024, 2049, 2049, 2600], [2673, 2818, 2843, 2843, 3555], [3557, 3627, 3667, 3667, 4276], [4279, 4279, 4353, 4353, 4613], [4615, 4781, 4813, 4813, 5021], [5023, 5023, 5065, 5065, 5364], [5366, 5366, 5405, 5405, 7207], [7209, 7209, 7261, 7261, 7438], [7440, 7440, 7497, 7497, 8453]], "test": "valid"}
{"id": "Xd3BRl", "name": "some worms", "author": "MonterMan", "description": "a lot of worms!", "tags": ["raymarch", "helix"], "likes": 0, "viewed": 68, "published": "Public", "date": "1526340236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(in float entropy)\n{\n    return 2. * fract(sin(entropy*281.51)*921.51) - 1.;\n}\n\nfloat noise(in float t)\n{\n    float ipos = floor(t);\n    float fpos = fract(t);\n    return mix(hash(ipos), hash(ipos + 1.), smoothstep(0., 1., fpos));\n}\n\nfloat sd_worm(in vec3 p)\n{\n    float unique = hash(21821.5*floor(0.5 * (p.x - 1.)) + 8125.1*floor(0.5 * (p.z - 1.)));\n    p.xz -= vec2(0.5, 0);\n    p.xz = mod(p.xz - 1.0, 2.0) - 1.;\n    \n\tfloat t = 7. * p.y + 1.5*iTime;\n    float xr = 0.1 + 0.3*noise(3.*iTime + 0.8*p.y + 2194.15*unique);\n    float zr = 0.1 + 0.3*noise(1.*iTime - 0.5*p.y + 21899851.*unique);\n    \n    float atten = min(1., p.y);\n    p.x += atten * xr * cos(t);\n    p.z += atten * zr * sin(t);\n    \n    return 0.5*(length(p.xz) - 0.1);   \n}\n\nfloat map(in vec3 p, out int id)\n{\n    float ground = p.y;\n    float worm = sd_worm(p);\n    \n    float d = min(ground, worm);\n    if (d == ground)\n    {\n        id = 0;\n    }\n    if (d == worm)\n    {\n        id = 1;\n    }\n    return d;\n}\n\nvec3 map_n(in vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    int garbage;\n    return normalize(vec3(map(p + e.yxx, garbage), map(p + e.xyx, garbage), map(p + e.xxy, garbage)) - map(p, garbage));\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float res = 1.;\n    float k = 32.;\n    \n    float t = 0.01;\n    float t_max = 50.;\n    for(int i = 0; i < 512; ++i)\n    {\n        if (t > t_max) break;\n        int garbage;\n        float d = map(p + t*l, garbage);\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, d*k/t);\n        t += d;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    vec3 ro = vec3(0, 1.9, -2.5);\n    vec3 at = vec3(0, 1, 0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0,1,0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(cam_x * uv.x + cam_y * uv.y + cam_z * 2.);\n    \n    int id = -1;\n    float t = 0.001;\n    float t_max = 30.;\n    for (int i = 0; i < 256; ++i)\n    {\n        if (t > t_max) break;\n     \t\n        int curr_id;\n        float d = map(ro + t*rd, curr_id);\n        if (d < 0.001)\n        {\n            id = curr_id;\n            break;\n        }\n        t += d;\n    }\n    \n    // Time varying pixel color\n    vec3 sun_color = vec3(1);\n    vec3 background = vec3(0.7, 0.8, 0.9);\n    vec3 col = background;\n    if (id != -1)\n    {\n        vec3 p = ro + t*rd;\n        vec3 n = map_n(p);\n        vec3 l = -normalize(vec3(0.5, -0.5, -0.1));\n        \n        float ao = 1.;\n        if (id == 0)\n        {\n            //ao = smoothstep(0., .12, length(p));\n        }\n        else if (id == 1)\n        {\n            ao = 0.5 + 0.5 * dot(n, vec3(0,1,0));\n        }\n        \n        vec3 shad = vec3(0.);\n        shad += 0.2 * ao * background;\n        shad += 0.8 * shadow(p, l) * max(0., dot(n, l)) * sun_color;\n        \n        vec3 mat;\n        if (id == 0)\n        {\n            mat = vec3(0.4, 0.5, 0.3);\n        }\n        else if (id == 1)\n        {\n            mat = vec3(0.7, 0.4, 0.2);\n        }\n        \n        col = shad * mat;\n        \n        col = mix(col, background, pow(min(1., t / t_max), 2.));\n    }\n\n    // Output to screen\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3BRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 88], [90, 90, 115, 115, 242], [244, 244, 270, 270, 751], [753, 753, 787, 787, 990], [992, 992, 1015, 1015, 1184], [1186, 1186, 1222, 1222, 1582], [1584, 1584, 1641, 1691, 3356]], "test": "valid"}
{"id": "Xd3BWM", "name": "Hypno-spinner", "author": "Mordi", "description": "Fast spinning insanity.", "tags": ["fast", "hypnotic", "spin"], "likes": 1, "viewed": 100, "published": "Public", "date": "1525283537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv -= 0.5;\n    uv *= 2.0;\n    \n    float d = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float PI_TWO = 6.283185;\n    \n    float timeMultiplier = iTime * iTime / 30.0;\n    \n    float c1 = sin(d * 20.0  + angle * 5.0 + timeMultiplier * 4.0);\n    float c2 = sin(d * 100.0 + angle * 2.0 + timeMultiplier * 8.0 + (0.33 * PI_TWO));\n    float c3 = sin(d * 40.0  + angle * 3.0 + timeMultiplier * 12.0 + (0.66 * PI_TWO));\n    \n    vec3 color1 = vec3(c1);\n    color1.r *= mix(0.2, 0.8, d);\n    color1.g *= mix(0.9, 0.6, d);\n    color1.b *= mix(0.5, 0.2, d);\n    \n    vec3 color2 = vec3(c2);\n    color2.r *= mix(0.3, 0.8, d);\n    color2.g *= mix(0.4, 0.3, d);\n    color2.b *= mix(0.4, 0.2, d);\n    \n    vec3 color3 = vec3(c3);\n    color3.r *= mix(0.7, 0.2, d);\n    color3.g *= mix(0.1, 0.7, d);\n    color3.b *= mix(0.2, 0.6, d);\n    \n\n    fragColor = vec4(color1 + color2 + color3, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3BWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 992]], "test": "valid"}
{"id": "Xd3fWX", "name": "vinvol-mandel", "author": "vinvol", "description": "Mandel", "tags": ["mandelbrot"], "likes": 0, "viewed": 60, "published": "Public", "date": "1526913629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat cubixFunc (float a, float b, int MAX) {\n\n\n      float ca = a;\n      float cb = b;\n\n      int n = 0;\n\n      while (n < MAX) {\n        float aa = float(a * a - b * b);\n        float bb = float(2.0 * a * b);\n        a = aa + ca;\n        b = bb + cb;\n        if (a * a + b * b > 16.0) {\n          break;\n        }\n        n++;\n      }\n\treturn float(n)/ float(MAX);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float mult = 1.0 + (iTime / 10.0);\n    vec2 uv = vec2(fragCoord.x/iResolution.y , fragCoord.y/iResolution.y );\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    float x = -0.5 + (uv.x + 1.5)/ mult;\n    float y = (uv.y - mult + 0.5) / mult;\n    \n    float alpha = cubixFunc(x,y, 3);\n    float beta = cubixFunc(x, y, 50);\n    float gamma = cubixFunc(x, y, 20);\n    \n    // Output to screen\n    fragColor = vec4(1.0-alpha, 1.0-beta, 1.0-gamma,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd3fWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 47, 47, 370], [373, 373, 430, 480, 983]], "test": "valid"}
{"id": "XdcBRj", "name": "scales effect", "author": "FabriceNeyret2", "description": "rigid scales under non-rigid displacement let appearing deep color at stretched places while crushed places only show surface color.\n\nloop-less algorithm ( the 0..3 doesn't count ;-) )", "tags": ["2d", "pattern", "perception", "loopless"], "likes": 10, "viewed": 810, "published": "Public API", "date": "1525878073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// scale size   + wave characteristics\n//float r = .65, Ax = .15, Lx = 1., Ay = 1., Ly = .5, Lt = 1.;\n//float r = .9,  Ax = .15, Lx = 1., Ay = 0., Ly = .5, Lt = 1.;\n  float r = .9,  Ax = .15, Lx = 1., Ay = 2., Ly = .5, Lt = 4.;\n\nvec2 disp(vec2 U) {\n    U.x += Ax*sin(Lx*U.x +Lt*iTime +Ay*sin(Ly*U.y));\n    return U;\n}\nvec2 invdisp(vec2 V) {\n    float x = V.x;\n    for (int i=0; i<3; i++)              // converges ultra-fast for small Ax\n        x = V.x - Ax*sin(Lx*x+ Lt*iTime +Ay*sin(Ly*V.y));\n    return vec2(x,V.y);\n}\n      \nvoid mainImage( out vec4 O, vec2 U ) {\n    float p = 10./iResolution.y;         // scales = relative size\n  //float p = 1./30.;                    // scales = absolute size\n    U *= p;\n    O -= O;\n    \n    for (int k=0; k<4; k++) {                                  // 4 covering scales\n        vec2  D = ( vec2(k%2,k/2)+.75*vec2(0,k%2 )) * .5,\n              V = disp(U),\n             U0 = invdisp( floor(V-D)+D+.5 ),                  // cell center \n           // F = fract(V)*2.-1.;                              // distorted scales\n              F = 2.*(U-U0);                                   // rigid scales\n        //O += cos(6.28*vec4(10,5,1,0)*length(F)); return;     // debug\n        float m = smoothstep(0.,-3.*p,length(F)-r),            // scale mask\n              z = m*(.5+.5*(F.x+F.y)/1.4/r);                   // scale z\n        if (z>O.a) O = vec4(  mix(vec3(.3,0,0),vec3(1),clamp(-1.5+3.*z,0.,1.)) // color gradient\n                            * smoothstep(0.,-3.*p,length(F)-(r-.1)), // dark border\n                              z);\n    }   \n    O = sqrt(O);                                               // gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 229, 248, 248, 317], [318, 318, 340, 340, 521], [529, 529, 567, 567, 1672]], "test": "valid"}
{"id": "XdcBW4", "name": "Desert Sand+Dune Stripes", "author": "tholzer", "description": "Try of using more realistic sand waves...\nOriginal 'Desert Sand' function 'sandL()' replaced with 'Dune Stripes' (refs see code).\nAdded: use your mouse to look around.\nMissing a sandstorm like at 'Skin peeler'.\n\n", "tags": ["3d", "noise", "raymarcher", "stripes", "sand", "desert", "dune"], "likes": 17, "viewed": 1172, "published": "Public API", "date": "1526026806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\tDesertSand + DuneStripes        2018-05-11\n\t------------------------\n\n    Original   'Desert Sand'  https://www.shadertoy.com/view/ld3BzM\n    Now using  'Dune Stripes' https://www.shadertoy.com/view/MsG3Wm\n    Sound from 'Skin peeler'  https://www.shadertoy.com/view/XtfSWX\n\n    Tags: 3d, desert, dune, sand, stripes, raymarcher, noise\n*/\n\n#define SPEED 0.05\n#define DUNE_SIZE 3.6\n\n/*\n\tDesert Sand\n\t-----------\n\n\tSand, and more sand -- Monotony, at it's finest. :) I've visited and flown over many sandy \n\tregions in my time, and I can say unequivocably that this particular scene doesn't remotely  \n\tresemble the real thing. :D \n\n\tHaving said that, there's something that I really like about minimal artificial dune scenes.  \n\tThey're somewhat of a visual programmer cliche -- I think that's partly due to the fact that \n\tthey have a decent \"aesthetic appeal to algorithmic complexity\" ratio.\n\t\n\tFor the sand dunes, rather than deal with dune physics, I used a pretty standard smoothstep \n\tnoise layer formula. I wouldn't say that dune physics is particularly difficult, but I'd \n\trather leave that to people like Dr2. :) Besides, with this example, I wanted to save some\n\tcycles and focus on the sand texture generation.\n\n\tThere are so many different ways to create wavy sand patterns. Some are expensive -- using\n\tthings like gradient erosion -- and some are cheap. Not suprisingly, the expensive methods \n\ttend to look better. I bump mapped the sand layer to give myself a few extra cycles to play \n\twith, but I still had to keep things relatively simple.\n\n\tThe pattern you see is a mixture of a simple trick I've seen around and some of my own\n\tadjustments. Without going into detail, the idea is to create a layer of repeat rounded \n\tgradient lines, and another rotated at slight angle, then perturb them slightly and mix \n\ttogether using an underlying noise layer. It's simple, but reasonably effective. Anyway, \n\tI've explained in more detail below.\n\t\n\n\tRelated examples:\n\n\tIt won Breakpoint way back in 2009. Ten people on Pouet gave it the thumbs down.\n    I hope they put their work up on Shadertoy, because it must be insanely good. :D\n      Elevated  -  IQ  -  https://www.shadertoy.com/view/MdX3Rr\n \n\tOne of my favorite simple coloring jobs.\n      Skin Peeler  -  Dave Hoskins  -  https://www.shadertoy.com/view/XtfSWX\n\n    Based on one of my all time favorites:\n      Xyptonjtroz  -  Nimitz  -  https://www.shadertoy.com/view/4ts3z2\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 100.\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// 1x1 and 3x1 hash functions.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( vec3 p  ){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s)\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s)\n{\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\n//mat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n/*\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n*/\n\n// Fabrice's consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n/*\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec2 to vec2.\nvec2 hash22(vec2 p){\n\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 19.19);\n    p = fract((p3.xx + p3.yz)*p3.zy)*2. - 1.;\n    return p;\n    \n    \n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    //mat2  m = r2(mod(iTime, 6.2831853)); \n\t//p.xy = m * p.xy;//rotate gradient vector\n  \t//return p;\n}\n*/\n\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) \n{\n  // Faster, but probaly doesn't disperse things as nicely as other methods.\n  float n = sin(dot(p, vec2(113, 1)));\n  p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n  return p;\n}\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f)\n{\n   // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm (Fractional Brownian Motion ?)\nfloat fBm(in vec2 p)\n{\n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) \n{\n\tvec2 i = floor(p); p -= i; \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2( fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453) )*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n}\n\n\n// Repeat gradient lines. How you produce these depends on the effect you're after. I've used a smoothed\n// triangle gradient mixed with a custom smoothed gradient to effect a little sharpness. It was produced\n// by trial and error. If you're not sure what it does, just call it individually, and you'll see.\nfloat grad(float x, float offs)\n{\n    // Repeat triangle wave. The tau factor and \".25\" factor aren't necessary, but I wanted its frequency\n    // to overlap a sine function.\n    x = abs(fract(x/6.283 + offs - .25) - .5)*2.;\n    \n    float x2 = clamp(x*x*(-1. + 2.*x), 0., 1.); // Customed smoothed, peaky triangle wave.\n    //x *= x*x*(x*(x*6. - 15.) + 10.); // Extra smooth.\n    x = smoothstep(0., 1., x); // Basic smoothing - Equivalent to: x*x*(3. - 2.*x).\n    return mix(x, x2, .15);\n    \n/*    \n    // Repeat sine gradient.\n    float s = sin(x + 6.283*offs + 0.);\n    return s*.5 + .5;\n    // Sine mixed with an absolute sine wave.\n    //float sa = sin((x +  6.283*offs)/2.);\n    //return mix(s*.5 + .5, 1. - abs(sa), .5);\n    \n*/\n}\n\n\n// replacement of 'sandL'\n//---------------------------------------------------------\n// from Desert stripes   https://www.shadertoy.com/view/MsG3Wm\n//---------------------------------------------------------\nvec2 coord;\n\nvec2 hash( vec2 p )                       // rand in [-1,1]\n{\n  p = vec2(dot(p,vec2(127.1,311.7)),\n           dot(p,vec2(269.5,183.3)));\n  return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n//---------------------------------------------------------\n// 2d noise functions from https://www.shadertoy.com/view/XslGRr\nfloat noise( in int i, in int j )\n{\n  vec2 n = vec2(i,j); \n  vec2 p = floor(n);\n  vec2 f = fract(n);\n  f = f*f*(3.0-2.0*f);\n  vec2 uv = (p+vec2(37.0,17.0)) + f;\n  vec2 rg = hash( uv/256.0 ).yx;\n  return 0.5*mix( rg.x, rg.y, 0.5 );\n}\n\n//---------------------------------------------------------\n#define NUM 100     // number or gabor blobs\n#define SIZE 0.25   // size of gabor blobs\n                       // freq tuned by mouse.x\n\nfloat DuneStripes (vec2 uv, float d, float freq, float time)\n{\n  float hv = -0.5;\n  for (int i = 0; i < NUM; i++) \n  {\n    vec2 pos = vec2(noise(i,0), noise(i,1));\n    vec2 dir = (1.+d)*vec2(noise(i,2),noise(i,3)) - d;\n    hv += SIZE * sin(dot(uv-pos, freq*dir) * 6. + time);\n  }\n  return hv;\n}\n//---------------------------------------------------------\n#define GB_NUM 100     // number or gabor blobs\n#define GB_SIZE 0.01   // size of gabor blobs\n\nfloat DuneStripes (vec2 p, float d, float freq)\n{\n  float hv = -0.5;\n  float time = iTime;\n  p.x *= 0.5;\n  for (int i = 0; i < GB_NUM; i++) \n  {\n    vec2 pos = vec2(noise(i,0), noise(i,1));\n    vec2 dir = (0.5+d)*vec2(noise(i,2),noise(i,3)) - d;\n    hv += GB_SIZE + 0.05 * sin(dot(p, freq*dir) * 6. + time);\n  }\n  return hv;\n}\n\n// replacement with DuneStripes\nfloat sandL(vec2 p)\n{\n  return DuneStripes(p, 6., 2.);\n}\n//---------------------------------------------------------\n// One sand function layer... which is comprised of two mixed, rotated layers of repeat gradients lines.\nfloat xsandL(vec2 p){\n    \n    // Layer one. \n    vec2 q = rot2(3.14159/18.)*p; // Rotate the layer, but not too much.\n    q.y += (gradN2D(q*18.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad1 = grad(q.y*80., 0.); // Repeat gradient lines.\n   \n    q = rot2(-3.14159/20.)*p; // Rotate the layer back the other way, but not too much.\n    q.y += (gradN2D(q*12.) - .5)*.05; // Perturb the lines to make them look wavy.\n    float grad2 = grad(q.y*80., .5); // Repeat gradient lines.\n      \n    \n    // Mix the two layers above with an underlying 2D function. The function you choose is up to you,\n    // but it's customary to use noise functions. However, in this case, I used a transcendental \n    // combination, because I like the way it looked better.\n    // \n    // I feel that rotating the underlying mixing layers adds a little variety. Although, it's not\n    // completely necessary.\n    q = rot2(3.14159/4.)*p;\n    //float c = mix(grad1, grad2, smoothstep(.1, .9, n2D(q*vec2(8))));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, n2D(q*vec2(6)));//smoothstep(.2, .8, n2D(q*8.))\n    //float c = mix(grad1, grad2, dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5);//smoothstep(.2, .8, n2D(q*8.))\n    \n    // The mixes above will work, but I wanted the use a suble screen blend of grad1 and grad2.\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5;\n    float a1 = 1. - a2;\n    \n    grad1 *= a1;\n    grad2 *= a2;\n    \n    // Screen blend.\n    float c = 1. - (1. - grad1)*(1. - grad2);\n    \n    // Smooth max\\min\n    //float c = smax(grad1, grad2, .5);\n\n    return c;\n}\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\nfloat sand(vec2 p)\n{\n    // Rotating by 45 degrees. I thought it looked a little better this way. Not sure why.\n    // I've also zoomed in by a factor of 4.\n    p = vec2(p.y - p.x, p.x + p.y)*.7071/4.;\n    \n    // Sand layer 1.\n    float c1 = sandL(p);\n    \n    // Second layer.\n    // Rotate, then increase the frequency -- The latter is optional.\n    vec2 q = rot2(3.14159/12.)*p;\n    float c2 = sandL(q*1.25);\n    \n    // Mix the two layers with some underlying gradient noise.\n //   c1 = mix(c1, c2, smoothstep(.1, .9, gradN2D(p*vec2(4))));\n    \n/*   \n\t// Optional screen blending of the layers. I preferred the mix method above.\n    float a2 = gradN2D(p*vec2(4));\n    float a1 = 1. - a2;\n    \n    // Screen blend.\n    c1 = 1. - (1. - c1*a1)*(1. - c2*a2);\n*/    \n    \n    // Extra grit. Not really necessary.\n    //c1 = .7 + fBm(p*128.)*.3;\n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took me far too long before it hit me. :)\n    return c1/(1. + gT*gT*.015);\n}\n\n/////////\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z)\n{ \n    return vec2(4.*sin(z * .1), 0);\n}\n\n// The standard way to produce \"cheap\" dunes is to apply a triangle function to individual\n// noise layers varying in amplitude and frequency. However, I needed something more subtle\n// and rounder, so I've only applied a triangle function to the middle layer.\n// \n// Here's an example using a more standard routine that's worth taking a look at:\n//\n// desert - wachel\n// https://www.shadertoy.com/view/ltcGDl\nfloat surfFunc( in vec3 p)\n{\n    p /= 2.5;\n    \n    // Large base ampltude with lower frequency.\n    float layer1 = n2D(p.xz*.2)*2. - .5; // Linear-like discontinuity - Gives an edge look.\n    layer1 = smoothstep(0., 1.05, layer1); // Smoothing the sharp edge.\n\n    // Medium amplitude with medium frequency. \n    float layer2 = n2D(p.xz*.275);\n    layer2 = 1. - abs(layer2 - .5)*2.; // Triangle function, to give the dune edge look.\n    layer2 = smoothstep(.2, 1., layer2*layer2); // Smoothing the sharp edge.\n    \n    // Smaller, higher frequency layer.\n\tfloat layer3 = n2D(p.xz*.5*3.);\n\n     // Combining layers fBm style. Ie; Amplitudes inversely proportional to frequency.\n    float res = layer1*.7 + layer2*.25 + layer3*.05;\n    //float res = 1. - (1. - layer1*.7)*(1. - layer2*.25)*(1. - layer3*.05); // Screen \n    //float res = layer1*.75 + layer2*.25;\n\n    return res;\n    \n}\n\n\n// A similar -- trimmed down and smoothed out -- version of function above, for camera path usage.\nfloat camSurfFunc( in vec3 p)\n{\n    p /= 2.5;\n    \n    // Large base ampltude with lower frequency.\n    float layer1 = n2D(p.xz*.2)*2. - .5; // Linear-like discontinuity - Gives an edge look.\n    layer1 = smoothstep(0., 1.05, layer1); // Smoothing the sharp edge.\n\n    // Medium amplitude with medium frequency. \n    float layer2 = n2D(p.xz*.275);\n    layer2 = 1. - abs(layer2 - .5)*2.; // Triangle function, to give the dune edge look.\n    layer2 = smoothstep(.2, 1., layer2*layer2); // Smoothing the sharp edge.\n\n     // Combining layers fBm style. Ie; Amplitudes inversely proportional to frequency.\n    float res = (layer1*.7 + layer2*.25)/.95;\n    //float res = 1. - (1. - layer1*.75)*(1. - layer2*.25); // Screen \n\n    return res;\n}\n\n\n\n// The desert scene. Adding a heightmap to an XZ plane. Not a complicated distance function. :)\nfloat map(vec3 p){\n    \n\t// Height map to perturb the flat plane. On a side note, I'll usually keep the\n    // surface function within a zero to one range, which means I can use it later\n    // for a bit of shading, etc. Of course, I could cut things down a bit, but at\n    // the expense of confusion elsewhere... if that makes any sense. :)\n    float sf = surfFunc(p);\n\n    // Add the height map to the plane.\n    return p.y + (.5-sf)*DUNE_SIZE; \n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \n    for(int i=0; i<96; i++){\n    \n        h = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += h; \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n \n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(0.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, fract(p.zx)).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// 3D noise fBm.\nfloat fBm(in vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    // Obtaining some terrain samples in order to produce a gradient\n    // with which to distort the sand. Basically, it'll make it look\n    // like the underlying terrain it effecting the sand. The downside\n    // is the three extra taps per bump tap... Ouch. :) Actually, it's\n    // not that bad, but I might attempt to come up with a better way.\n    float n = surfFunc(p);\n    vec3 px = p + vec3(.001, 0, 0);\n    float nx = surfFunc(px);\n    vec3 pz = p + vec3(0, 0, .001);\n    float nz = surfFunc(pz);\n    \n    // The wavy sand, that have been perturbed by the underlying terrain.\n    return sand(p.xz + vec2(n - nx, n - nz)/.001*1.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 0.001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n         \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        h = clamp(h, .1, .5); // max(h, .02);//\n        dist += h;\n\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (shade<0.001 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 5.;\n\t//const float falloff = .9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + .0)*.5/nbIte*maxDist;        \n        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n\n// Standard sky routine. Gradient with sun and overhead cloud plane. I debated over whether to put more \n// effort in, but the dust is there and I'm saving cycles. I put sun flares in, but I wasn't feeling it,\n// so took them out again. I might tweak them later, and see if I can make them work with the scene.\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    // Sky color gradients.\n    vec3 col = vec3(.8, .7, .5), col2 = vec3(.4, .6, .9);\n    \n    //return mix(col, col2, pow(max(rd.y*.5 + .9, 0.), 5.));  // Probably a little too simplistic. :)\n     \n    // Mix the gradients using the Y value of the unit direction ray. \n    vec3 sky = mix(col, col2, pow(max(rd.y + .15, 0.), .5));\n    sky *= vec3(.7, 1, 1.3)*vec3(1.2, 1, .9); // Adding some extra vibrancy.\n     \n    float sun = clamp(dot(ld, rd), 0.0, 1.0);\n    sky += vec3(1, .7, .4)*vec3(pow(sun, 16.))*.2; // Sun flare, of sorts.\n    sun = pow(sun, 32.); // Not sure how well GPUs handle really high powers, so I'm doing it in two steps.\n    sky += vec3(1, .9, .6)*vec3(pow(sun, 32.))*.35; // Sun.\n    \n     // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.15;\n    rd = normalize(rd);\n   \n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) sky =  mix(sky, vec3(2), smoothstep(.45, 1., fBm(1.5*uv/SC))*\n                        smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    \n    // Return the sky color.\n    return sky;\n}\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n/////\n// Code block to produce some layers of smokey haze. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n// Four layers of cheap cell tile noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    \n    //ro -= vec3(0, 0, iTime*3.);\n    \n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        // If we reach the surface, don't accumulate any more values.\n        if (t0>t) break; \n        \n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = 1./(1. + sDi*.25);\n\t    \n        // Noise layer.\n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = noise3D(ro2)*.65 + noise3D(ro2*3.)*.25 + noise3D(ro2*9.)*.1; //cellTile\n        //float c = trigNoise3D(ro2);\n        //float c = triNoise3d(ro2/8., 0.);\n        float n = c;//max(.65-abs(c - .5)*2., 0.);//smoothstep(0., 1., abs(c - .5)*2.);\n        mist += n*sAtt;\n        \n        // Advance the starting point towards the hit point. You can \n        // do this with constant jumps (FAR/8., etc), but I'm using\n        // a variable jump here, because it gave me the aesthetic \n        // results I was after.\n        t0 += clamp(c*.25, .1, 1.);\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist/48., 0.);\n    \n    // A different variation (float n = (c. + 0.);)\n    //return smoothstep(.05, 1., mist/32.);\n\n}\n\n//-------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Screen coordinates.\n\tvec2 u =  (fragCoord - iResolution.xy*.5) / iResolution.y;\n\tvec2 mp = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n\t// Camera Setup.     \n\tvec3 ro = vec3(0, 1.2, iTime*SPEED);   // Camera position, doubling as the ray origin.\n    vec3 lookAt = ro + vec3(0, -.15, .5);  // \"Look At\" position.\n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n    lookAt.x += mp.x;\n    \n    // Raising the camera up and down with the terrain function and tilting it up or down\n    // according to the slope. It's subtle, but it adds to the immersiveness of that mind \n    // blowing, endless-sand experience. :D\n    float sfH = camSurfFunc(ro); \n    float sfH2 = camSurfFunc(lookAt); \n    float slope = (sfH2 - sfH)/length(lookAt - ro); // Used a few lines below.\n    //slope = smoothstep(-.15, 1.15, (slope*.5 + .5)) - .5; // Smoothing the slope... Needs work.\n     \n    // Raising the camera with the terrain.\n    ro.y += sfH2; \n    lookAt.y += sfH2 + mp.y;\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/2.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/96.)*rd.xy;\n    \n    // Subtle up and down tilt, or camera pitch, if you prefer.\n    rd.yz = rot2(-slope/3.)*rd.yz;\n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.25, FAR*.25, FAR) + vec3(0, 0, ro.z);\n \n\t// Raymarching.\n    float t = trace(ro, rd);\n    \n    gT = t;\n    \n    // Sky. Only retrieving a single color this time.\n    //vec3 sky = getSky(rd);\n    \n    vec3 col = vec3(0.9, 0.5, 0.0);   // sand color\n    \n    // Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    // the mist, so that's why it's declared in an untidy postion outside the block below...\n    // It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y;//surfFunc(sp);// - path(sp.z).y; // Path height line, of sorts.\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR)\n    {\n        vec3 sn = normal(sp, 1.); // Surface normal. //*(1. + t*.125)\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld /= lDist; // Normalize the light direct vector.\n        \n        lDist /= FAR; // Scaling down the distance to something workable for calculations.\n        float atten = 1./(1. + lDist*lDist*.025);\n        \n        // Texture scale factor.        \n        const float tSize = 1./8.;\n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .07);///(1. + t*t/FAR/FAR*.25)\n        \n        // Texture bump mapping.\n        float bf = .01;//(pathHeight + 5. < 0.)?  .05: .025;\n        //sn = doBumpMap(iChannel0, sp*tSize, sn, bf/(1. + t/FAR));\n        \n        // Soft shadows and occlusion.\n        float sh = softShadow(sp + sn*.002, lp, 6., t); \n        float ao = calcAO(sp, sn); // Ambient occlusion.\n        \n        // Add AO to the shadow. No science, but adding AO to things sometimes gives a bounced light look.\n        sh = min(sh + ao*.25, 1.); \n        \n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        // in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.35;// + fre*fre2*.2;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        //col = clamp(mix(vec3(1.152, 0.4275,.153), vec3(.225, 0.05985, 0.0153), -sn.y*.5 + pathHeight*.5 + 1.75), vec3(.9, 0.534375, 0.239), vec3(.9, .855, .765));\n        \n        // Give the soil a bit of a sandstone texture.\n        //col = smoothstep(-.5, 1., tex3D(iChannel0, sp*tSize, sn)*2.)*(col + vec3(.225, .21375, .19125));\n        //col = tex3D(iChannel0, sp*tSize, sn)*2.;\n        col = mix(col, vec3(0.8, 0.6, 0.2), fBm(sp.xz*16.));\n        col = mix(col*1.4, col*.6, fBm(sp.xz*32. - .5));///(1. + t*t*.001)\n        \n        //vec3 tx = tex3D(iChannel0, sp*tSize, sn); tx *= tx;\n        //col = mix(col, tx*2., .3);\n        \n        float bSurf = bumpSurf3D(sp);\n        col *= bSurf*.75 + .5;\n        //col *= surfFunc(sp)*.75 + .5;\n        \n        col = mix(col*.7 + hash(floor(sp*96.))*.3, col, min(t*t/FAR, 1.));\n        \n        col *= vec3(1.2, 1, .9);\n        \n        // Making the ground reflect just a little more to give the appearance of fine dust or sand...\n        // It's a work in progress. :)\n        //col += smoothstep(0., 1., -pathHeight - 5.5)*fre*.25;\n \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky(ro, rd, ld)*fre*fre2*.5; \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = col*(dif + amb + vec3(1, .97, .92)*fre2*spe*2.)*atten;\n        \n        col *= sh*ao;// + amb*pow(col, vec3(2.));\n\n        //col = vec3(ao);\n    }\n    \n    // Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro, rd, lp, t)*(1. - smoothstep(0., 1., pathHeight*.05));//(-rd.y + 1.);\n    vec3 gLD = normalize(lp - vec3(0, 0, ro.z));\n    vec3 sky = getSky(ro, rd, gLD);//*mix(1., .75, dust);\n    //col = mix(col, sky, min(t*t*1.5/FAR/FAR, 1.)); // Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .95, t/FAR)); // Linear fade. Much dustier. I kind of like it.\n    \n    // Mild dusty haze... Not really sure how it fits into the physical situation, but I thought it'd\n    // add an extra level of depth... or something. At this point I'm reminded of the \"dog in a tie \n    // sitting at the computer\" meme with the caption, \"I have no idea what I'm doing.\" :D\n    vec3 mistCol = vec3(1, .95, .9); // Probably, more realistic, but less interesting.\n    //col += (mix(col, mistCol, .66)*.66 + col*mistCol*1.)*dust;\n    \n    // Simulating sun scatter over the sky and terrain: IQ uses it in his Elevated example.\n    col += vec3(1., .6, .2)*pow( max(dot(rd, gLD), 0.), 16.)*.5;\n    \n    // Applying the mild dusty haze.\n    col = col*.75 + (col + .25*vec3(1.2, 1, .9))*mistCol*dust*1.5;\n    //col *= 1.05;\n    \n    // Really artificial. Kind of cool, but probably a little too much.    \n    //col *= vec3(1.2, 1, .9);\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord / iResolution.xy;\n    col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    // Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}\n", "image_inputs": [{"id": "XdjSzK", "previewfilepath": "https://soundcloud.com/vynehall/movements-chapter-iii", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vynehall/movements-chapter-iii", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2640, 2699, 2721, 2721, 2789], [2792, 2823, 2845, 2845, 2880], [2881, 2881, 2903, 2903, 2972], [2975, 3008, 3048, 3048, 3139], [3141, 3190, 3229, 3229, 3319], [4065, 4108, 4126, 4126, 4194], [4818, 4850, 4872, 4949, 5048], [5050, 5348, 5374, 5460, 6914], [6916, 6969, 6991, 6991, 7060], [7063, 7332, 7352, 7352, 7601], [7604, 7913, 7946, 8087, 8651], [8654, 8876, 8937, 8937, 9065], [9066, 9191, 9226, 9226, 9423], [9596, 9622, 9684, 9684, 9916], [9917, 10072, 10121, 10121, 10398], [10400, 10432, 10453, 10453, 10488], [10489, 10654, 10675, 10699, 12276], [12278, 12644, 12664, 12800, 13809], [13811, 13924, 13947, 13947, 13986], [13988, 14398, 14426, 14426, 15283], [15286, 15385, 15416, 15416, 16123], [16127, 16223, 16241, 16565, 16673], [16677, 16698, 16734, 16734, 17170], [17653, 17753, 17787, 17787, 17942], [19327, 19470, 19491, 19491, 19837], [19840, 19857, 19878, 19878, 19945], [19948, 19975, 20004, 20360, 20653], [20655, 20705, 20762, 20762, 21144], [21146, 21447, 21500, 21578, 22925], [22929, 23081, 23117, 23117, 23425], [23429, 23740, 23779, 23813, 25150], [25153, 25229, 25254, 25347, 26299], [26596, 26647, 26668, 26668, 26734], [26736, 27024, 27086, 27086, 28343], [28345, 28397, 28454, 28478, 36917]], "test": "error"}
{"id": "XdcBzS", "name": "Ray Tracing 2D", "author": "alijaya", "description": "Ray Tracing in 2D", "tags": ["raytrace"], "likes": 7, "viewed": 555, "published": "Public API", "date": "1525568958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define u_resolution iResolution\n#define u_mouse iMouse.xy\n#define u_time iTime\n\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 1000.;\nconst float EPS = .1;\n\nconst float TAU = 2. * acos(-1.);\n\nvec2 camera_pos = vec2(-100., -100.);\nvec2 camera_target = vec2(20., 20.);\nfloat camera_fov = TAU / 5.;\nconst int camera_ray = 10;\nfloat camera_gamma = 4.;\n\nmat3 world;\nvec2 mouse_gl;\n\nvec2 ori;\nvec2 dir;\n\nfloat h_fov;\nvec2 fov1;\nvec2 fov2;\n\nvec2 dir_left;\nvec2 plane1;\nvec2 plane2;\n\nfloat sdf_u(float a, float b) {\n    return min(a, b);\n}\n\nfloat sdf_i(float a, float b) {\n    return max(a, b);\n}\n\nfloat sdf_s(float a, float b) {\n    return max(a, -b);\n}\n\nfloat sdf_circle(vec2 coord, float r) {\n    return length(coord) - r;\n}\n\nfloat sdf_rect(vec2 coord, vec2 s) {\n    vec2 d = abs(coord) - s/2.;\n    return sdf_i(d.x, d.y);\n}\n\nfloat sdf_grid(vec2 coord, vec2 s, float w) {\n    vec2 f = mod(coord, s);\n    return -sdf_rect(f - s/2., s - w);\n}\n\nfloat sdf_line(vec2 coord, vec2 a, vec2 b, float w) {\n    vec2 v = b - a;\n    vec2 nv = normalize(v);\n    float proj = dot(nv, coord - a);\n    proj = min(length(v), max(0., proj));\n    vec2 p = proj * nv + a;\n    return distance(coord, p) - w/2.;\n}\n\nfloat sdf_ray(vec2 coord, vec2 ori, vec2 dir, float w) {\n    vec2 nv = normalize(dir);\n    float proj = dot(nv, coord - ori);\n    proj = max(0., proj);\n    vec2 p = proj * nv + ori;\n    return distance(coord, p) - w/2.;\n}\n\nmat3 inv_t(vec2 t) {\n    t = -t;\n    return mat3(\n        1., 0., 0.,\n        0., 1., 0.,\n        t.x, t.y, 1.\n    );\n}\n\nmat3 inv_r(float r) {\n    r = -r;\n    return mat3(\n        cos(r), sin(r), 0.,\n        -sin(r), cos(r), 0.,\n        0., 0., 1.\n    );\n}\n\nmat3 inv_s(vec2 s) {\n    s = 1./s;\n    return mat3(\n        s.x, 0., 0.,\n        0., s.y, 0.,\n        0., 0., 1.\n    );\n}\n\nmat3 inv_mat(vec2 t, float r, vec2 s) {\n    return inv_s(s) * inv_r(r) * inv_t(t);\n}\n\nvec2 mult(mat3 mat, vec2 pos) {\n    return vec2(mat * vec3(pos, 1.));\n}\n\nvec2 ray2ray(vec2 ori1, vec2 dir1, vec2 ori2, vec2 dir2) {\n    vec2 d = ori2 - ori1;\n    float det = dir2.x * dir1.y - dir2.y * dir1.x;\n    float u = (d.y * dir2.x - d.x * dir2.y) / det;\n\tfloat v = (d.y * dir1.x - d.x * dir1.y) / det;\n    return vec2(u, v);\n}\n\nfloat scene(vec2 coord) {\n    // float obj = sdf_rect(coord, vec2(100., 50.));\n    float obj = sdf_grid(coord, vec2(20.), 2.);\n    vec2 circle = mult(inv_mat(vec2(50., 100. + sin(u_time) * 100.), 0., vec2(1.)), coord);\n    obj = sdf_circle(circle, 20.);\n    vec2 rect = mult(inv_mat(vec2(-50., 100.), u_time, vec2(1.)), coord);\n    obj = sdf_u(obj, sdf_rect(rect, vec2(20., 50.)));\n    return obj;\n}\n\nvec4 debug(float scene) {\n    return vec4(fract(scene/20.));\n}\n\nfloat toSolid(float scene) {\n    return smoothstep(-1., 1., -scene);\n}\n\nvec4 solid(float scene) {\n    return vec4(toSolid(scene));\n}\n\nvoid update(vec2 res, vec2 mouse) {\n    world = inv_mat(res/2., 0., vec2(1.));\n    mouse_gl = mult(world, mouse);\n    \n    camera_target = mouse_gl;\n    ori = camera_pos;\n    dir = normalize(camera_target - camera_pos);\n    \n    h_fov = camera_fov / 2.;\n    fov1 = mult(inv_mat(vec2(0.), h_fov, vec2(1.)), dir);\n    fov2 = mult(inv_mat(vec2(0.), -h_fov, vec2(1.)), dir);\n    \n    dir_left = vec2(-dir.y, dir.x);\n    plane1 = dir_left * ray2ray(camera_target, dir_left, ori, fov1).x + camera_target;\n    plane2 = dir_left * ray2ray(camera_target, dir_left, ori, fov2).x + camera_target;\n}\n\nvoid left(vec2 res, vec2 mouse, in vec2 coord, out vec4 color) {\n    vec2 st = coord / res;\n    \n    coord = mult(world, coord);\n    \n    // scene\n    float s = scene(coord);\n    \n    // background\n    vec3 c = vec3(.1, .1, .1);\n    \n    // draw scene\n    c = mix(c, vec3(1.), toSolid(s));\n    \n    // draw grid\n    float grid = toSolid(sdf_grid(coord, vec2(20.), 1.));\n    c = mix(c, vec3(0.182,0.345,0.332), grid);\n    \n    // draw center\n    float center = toSolid(sdf_circle(coord, 5.));\n    c = mix(c, vec3(0.585,0.263,0.274), center);\n    \n    // draw camera\n    vec2 camera_c = mult(inv_mat(camera_pos, 0., vec2(1.)), coord);\n    float camera = toSolid(sdf_circle(camera_c, 5.));\n    c = mix(c, vec3(0.449,0.810,0.555), camera);\n    \n    // draw camera target\n    vec2 target_c = mult(inv_mat(camera_target, 0., vec2(1.)), coord);\n    float target = toSolid(sdf_circle(target_c, 5.));\n    c = mix(c, vec3(0.736,0.810,0.362), target);\n    \n    // draw fov\n    float fov = toSolid(sdf_u(sdf_ray(coord, ori, fov1, 5.), sdf_ray(coord, ori, fov2, 5.)));\n    c = mix(c, vec3(0.510,0.116,0.150), fov);\n    \n    // draw plane\n    float plane = toSolid(sdf_line(coord, plane1, plane2, 2.));\n    c = mix(c, vec3(0.650,0.460,0.479), plane);\n    \n    // additional ray\n    for (int j=-camera_ray; j<=camera_ray; j++) {\n        vec2 p = mix(camera_target, plane1, float(j) / float(camera_ray));\n        vec2 dir = normalize(p - ori);\n        float d = 0.;\n        bool found = false;\n        \n        // ray marching\n        for (int i=0; i<MAX_ITER; i++) {\n            vec2 p = ori + d * dir;\n            float r = scene(p);\n            \n            // draw bubble\n            if (j == 0) {\n                vec2 bubble_c = mult(inv_mat(p, 0., vec2(1.)), coord);\n                float bubble = toSolid(sdf_s(sdf_circle(bubble_c, r), sdf_circle(bubble_c, r-1.)));\n                c = mix(c, vec3(0.425,0.462,0.555), bubble);\n            }\n            \n            d += r;\n            if (r < EPS) {\n                found = true;\n                break;\n            }\n            if (d > MAX_DIST) {\n                break;\n            }\n      \t}\n        \n        // draw ray\n        float ray = toSolid(sdf_ray(coord, ori, dir, 1.));\n        c = mix(c, vec3(0.960,0.895,0.363), ray);\n        \n        // draw contact\n        if (found) {\n            vec2 p = ori + d * dir;\n            // draw line\n            float line = toSolid(sdf_line(coord, ori, p, 2.));\n            c = mix(c, vec3(0.940,0.380,0.086), line);\n\n            // draw point\n            vec2 contact_c = mult(inv_mat(p, 0., vec2(1.)), coord);\n            float contact = toSolid(sdf_circle(contact_c, 5.));\n            c = mix(c, vec3(0.940,0.095,0.005), contact);\n        }\n    }\n    \n    color = vec4(c, 1.);\n}\n\nvoid right(vec2 res, vec2 mouse, in vec2 coord, out vec4 color) {\n    vec2 st = coord / res;\n    \n    mat3 i = inv_mat(res/2., 0., vec2(1.));\n    coord = mult(i,coord);\n    float s = scene(coord);\n    color = debug(s);\n}\n\n\nvoid top(vec2 res, vec2 mouse, in vec2 coord, out vec4 color) {\n    vec2 st = coord / res;\n    \n    float brightness = length(camera_target - camera_pos);\n    vec2 p = mix(camera_target, plane1, st.x * 2. - 1.);\n    vec2 dir = normalize(p - ori);\n    float d = 0.;\n    bool found = false;\n\n    // ray marching\n    for (int i=0; i<MAX_ITER; i++) {\n        vec2 p = ori + d * dir;\n        float r = scene(p);\n        d += r;\n        if (r < EPS) {\n            found = true;\n            break;\n        }\n        if (d > MAX_DIST) {\n            break;\n        }\n    }\n    \n    if (found) {\n        color = vec4(pow(brightness/d, camera_gamma));\n        //color = vec4(1. - exp(-d * brightness / 100000.));\n    } else {\n        color = vec4(0.);\n    }\n    \n    //color = vec4(st, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 halfres = vec2(u_resolution.x/2., u_resolution.y * .9);\n    \n    update(halfres, u_mouse);\n    if (fragCoord.y > halfres.y) {\n        vec2 offset = vec2(0., -halfres.y);\n        top(vec2(u_resolution.x, u_resolution.y * .1), u_mouse + offset, fragCoord.xy + offset, fragColor);\n    } else {\n        if (fragCoord.x < halfres.x) {\n            left(halfres, u_mouse, fragCoord.xy, fragColor);\n        } else {\n            vec2 offset = vec2(-halfres.x, 0.);\n            right(halfres, u_mouse + offset, fragCoord.xy + offset, fragColor);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 510, 510, 534], [536, 536, 567, 567, 591], [593, 593, 624, 624, 649], [651, 651, 690, 690, 722], [724, 724, 760, 760, 822], [824, 824, 869, 869, 938], [940, 940, 993, 993, 1188], [1190, 1190, 1246, 1246, 1411], [1413, 1413, 1433, 1433, 1532], [1534, 1534, 1555, 1555, 1669], [1671, 1671, 1691, 1691, 1792], [1794, 1794, 1833, 1833, 1878], [1880, 1880, 1911, 1911, 1951], [1953, 1953, 2011, 2011, 2212], [2214, 2214, 2239, 2292, 2613], [2615, 2615, 2640, 2640, 2677], [2679, 2679, 2707, 2707, 2749], [2751, 2751, 2776, 2776, 2811], [2813, 2813, 2848, 2848, 3400], [3402, 3402, 3466, 3466, 6174], [6176, 6176, 6241, 6241, 6396], [6399, 6399, 6462, 6462, 7184], [7186, 7186, 7243, 7243, 7806]], "test": "error"}
{"id": "XdcBzX", "name": "Circle packing spirals", "author": "akhgary", "description": "playing around...", "tags": ["spiral", "circle", "plot", "draw", "circlepacking", "loopfree"], "likes": 4, "viewed": 136, "published": "Public", "date": "1526059710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Circle packing\n// https://en.wikipedia.org/wiki/Circle_packing\n\n// Hue taken from https://www.shadertoy.com/view/4tlBWB\n\n#define tau 6.28318\n#define pi 3.14159\n#define ep 1e-2  // epsilon (fix edge cases)\n\nvec3 hue( in vec3 c )\n{\n\treturn c.z*(1.-c.y*smoothstep(2.,1.,abs(mod(c.x*6.+vec3(0,4,2),6.) -3.)));\n}\n\nfloat circle(vec2 xy, vec2 c, float r, bool fill){\n    float dist = length(xy-c)-r;\n    return 1.-smoothstep(-2./iResolution.y,3./iResolution.y,fill?dist:abs(dist));\n}\n\nvec3 circles(vec2 xy, vec2 C, float R, float r, float ph){\n    float spacing = abs(mod(iTime/7.,2.)-1.);\t// some extra spacing between circles\n\tfloat t = 2.*asin(r/(R+r))+spacing; \t\t// theta for each surrounding circle\n    \n    float div = abs(tau/t)+ep;\n\tint n = int(div); \t\t\t\t\t// number of surrounding circles\n    float pad = fract(div)*t/float(n);\t// circles padding                                       \n    \n    float rt = -t/2.-pad/2.+ph;\t\t\t// plane rotation\n    mat2 rm = mat2(cos(rt),-sin(rt),sin(rt),cos(rt));\n    vec2 zw = rm*(xy-C);\t\t\t\t// rotated plane\n    \n    float i = floor((atan(zw.y,zw.x))/(t+pad));                 // i-th circle\n    vec2 c = vec2(cos(i*(t+pad)+ph),sin(i*(t+pad)+ph))*(r+R)+C; // center of surrounding circles\n\t\n    vec3 hsl = vec3(i/float(n),1.,.75); // color for each surrounding circle\n    return circle(xy,c,r,true)*hue(hsl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n        \n    vec2 C = vec2(0); // center\n    float R = .055;\t// central circle radius\n\tfloat r = .055;\t// surrounding circle radius\n\n    col+=circle(xy, C, R, false);// draw central circle\n    \n    float n = 20.; // number of layers\n    float i = floor((min(r*2.*(n-1.)+ep,length(xy-C)-R))/(r*2.)); // i-th layer\n    \n    if(i>=0.)\n        col+=circles(xy, C, R+r*i*2., r,i);  // draw surrounding circles\n    \n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 209, 232, 232, 310], [312, 312, 362, 362, 479], [481, 481, 539, 539, 1348], [1350, 1350, 1407, 1407, 1936]], "test": "valid"}
{"id": "XdcfDl", "name": "///105///----", "author": "MrHenryBemis", "description": "///////", "tags": ["logos"], "likes": 18, "viewed": 632, "published": "Public API", "date": "1527129275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tAbstract Glassy Field\n\t---------------------\n\n\tAn abstract, blobby-looking field - rendered in the style of hot, glowing glass. It was \n\tproduced using cheap low-budget psuedoscience. :)\n\n\tThe surface was constructed with a spherized sinusoidal function, of sorts. I like it, because \n\tit's very cheap to produce, mildly reminiscent of noise and allows a camera to pass through it \n\twithout having to resort to trickery.\n\n\tThe fluid filled glass look is fake, but at least interesting to look at. Basically, it was\n\tproduced by indexing the reflected and refracted surface rays into a 3D tri-planar texture\n\tlookup. By the way, I've tried the real thing on this particular surface - with multiple ray \n\tbounces and so forth - and to say it's slower is an understatement. :)\n\n\tBy the way, if anyone is aware of some cheap and simple improvements, corrections, etc, feel\n\tfree to let me know.\n\n*/\n#define iTime (iTime*1.62)\n#define FAR 4250. // Far plane, or maximum distance.\n\n//float objID = 0.; // Object ID\n\nfloat accum; // Used to create the glow, by accumulating values in the raymarching function.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(105222.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.zy).xyz;\n    vec3 ty = texture(t, p.xz).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// Camera path.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.2311);\n    float b = cos(t * 0.1314);\n    return vec3(a*4. -b*0.5, b*.7 + a*2.5, t);\n    \n}\n\n\n// A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n// combination. I came up with it when I was bored one day. :) Lousy to hone in\n// on, but it has the benefit of being able to guide a camera through it.\nfloat map(vec3 p){\n \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n    \n     \n\tp = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.\n    \n    \n    float n = length(p); // Spherize. The result is some mutated, spherical blob-like shapes.\n\n    // It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    // is there to get a little extra distance... Obtained by trial and error.\n    return (n - 1.025)*1.33;\n    \n}\n\n/*\n// Alternative, even more abstract, field.\nfloat map(vec3 p){\n    \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n   \n\tp = cos(p*.1575 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.\n    \n    // Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3.+cos(p.yzx*3.)); // Finer bumps. Subtle.\n    \n    return (n - p.x*p.y*p.z*.35 - .9)*1.33; // Combine, and we're done.\n    \n}\n*/\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(vec3 p){\n\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n        // Simple distance-based accumulation to produce some glow.\n        if(abs(h)<.35) accum += (.35-abs(h))/24.;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.01, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Simple environment mapping.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tpl(iChannel1, rd*4., n);\n    return smoothstep(0., 1., col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 4.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .25);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 2.) + vec3(0, 1, 0); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.125)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    //float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position.\n        vec3 p = o + r*t;\n\t\t\n        // Normal.\n        vec3 n = nr(p);\n        \n        // Sometimes, it's handy to keep a copy of the normal. In this case, I'd prefer the\n        // bumps on the surface to not have as much influence on the reflrection and \n        // refraction vectors, so I tone down the bumped normal with this. See the reflection\n        // and refraction lines.\n        vec3 svn = n;\n        \n        // Texture bump the normal.\n        float sz = 1./3.; \n        n = db(iChannel0, p*sz, n, .1/(1. + t*.25/FAR));\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n        float at = 1./(1. + d*.05 + d*d*.0125); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.), 64.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), .0, 1.); // Fresnel reflection term.\n \n         \n        \n        // Texturing - or coloring - the surface. The \"color\"' of glass is provide by the surrounds...\n        // of it's contents, so just make it dark.\n        vec3 tx = vec3(.05); // tpl(iChannel0, p*sz, n);\n         \n\n\t\t// Very simple coloring.\n        col = tx*(di*.1 + ao*.25) + vec3(.8, .1, .2)*sp*2. + vec3(.5, .2, .8)*pow(fr, 8.)*1.25;\n \n        // Very cheap, and totally fake, reflection and refraction. Obtain the reflection and\n        // refraction vectors at the surface, then pass them to the environment mapping function.\n        // Note that glass and fluid have different refractive indices, so I've fudged them into \n        // one figure.\n        vec3 refl = envMap(normalize(reflect(r, svn*.5 + n*.5)), svn*.5 + n*.5);\n        vec3 refr = envMap(normalize(refract(r, svn*.5 + n*.5, 1./1.35)), svn*.5 + n*.5);\n        \n        /*\n\t\t// You can also index into a 3D texture, but I prefer the above.\n        vec3 refl = texture(iChannel2, normalize(reflect(r, svn*.5 + n*.5))).xyz;\n        vec3 refr = texture(iChannel2, normalize(refract(r, svn*.5 + n*.5, 1./1.31))).xyz;\n        refl *= refl*.5;\n        refr *= refr*.5;\n        */\n        \n        // More fake physics that looks like real physics. :) Mixing the reflection and refraction \n        // colors according to a Fresnel variation.\n        vec3 refCol = mix(refr, refl, pow(fr, 5.)); //(refr + refl)*.5; // Adding them, if preferred.\n        \n        // Obviously, the reflected\\refracted colors will involve lit values from their respective\n        // hit points, but this is fake, so we're just combining it with a portion of the surface \n        // diffuse value.\n        col += refCol*((di*di*.25+1.75) + ao*.125)*.85; // Add the reflected color. You could combine it in other ways too.\n        \n        // Based on IQ's suggestion: Using the diffuse setting to vary the color slightly in the\n        // hope that it adds a little more depth. It also gives the impression that Beer's Law is \n        // taking effect, even though it clearly isn't. I might try to vary with curvature - or some other\n        // depth guage - later to see if it makes a difference.\n        col = mix(col.xzy, col, di*.185 + .515); \n        \n        // Glow.\n        // Taking the accumulated color (see the raymarching function), tweaking it to look a little\n        // hotter, then combining it with the object color.\n        vec3 accCol = vec3(0, 1.3, 4.91)*accum;\n        vec3 gc = pow(min(vec3(1.5, 1, 1)*accum, 1.), vec3(10, 9.5, 45.))*.5 + accCol*.05;\n        col += col*gc*12.;\n \n\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    \n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fog = vec3(.125, .04, .05)*(r.y*.5 + .5);    \n    col = mix(col, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    \n    // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col = mix(vec3(0), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.5 + .5);\n\n \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1109, 1261, 1282, 1282, 1353], [1356, 1514, 1560, 1560, 2068], [2071, 2087, 2109, 2305, 2426], [2429, 2664, 2682, 2682, 3156], [3627, 3779, 3812, 3812, 4054], [4057, 4157, 4173, 4173, 4359], [4363, 4384, 4420, 4420, 4994], [4997, 5009, 5085, 5085, 5669], [5672, 5754, 5809, 5809, 6308], [6310, 6453, 6471, 6471, 6817], [6821, 6852, 6881, 6881, 6965], [6968, 6968, 7024, 7058, 12651]], "test": "error"}
{"id": "XdcfRs", "name": "RAVEArrow", "author": "skandix", "description": "RaVEBOW", "tags": ["rainbowarrow"], "likes": 2, "viewed": 117, "published": "Public", "date": "1526296737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec2 rotate (vec2 v, float a ){\n\tfloat s = sin(a); \n    float c = cos(a); \n    mat2 m = mat2(c, -s, s,c);\n    return m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 q = uv - vec2(.5, .5);\n\n\n    // Time varying pixel color\n    \n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    \n    if (mod(iTime, 2.0) >= 1.0) {\n        uv = uv *2.-1.7;\n    \tuv.xy /= .1;\n    } else {\n        uv = uv *2.-1.7;\n    \tuv.xy /= -.1;\n    }\n    \n    // *= .2;\n    \n\t//vec3 col = dot(atan(uv.y/uv.x), sin(iTime)*5.)-sin(iTime+uv.y+abs(uv.x)+PI-vec3(0,2,4))*TWO_PI;\n    \n\tvec3 col = .2+ sin(0.1 + tan(iTime)*cos(iTime+uv.y-abs(uv.x)+vec3(0,2,4))-vec3(q, .5));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 87, 87, 181], [183, 183, 240, 290, 862]], "test": "valid"}
{"id": "Xdcfzj", "name": "Grid index based rotations", "author": "ivanlesko", "description": "Learning how to manipulate angles based on XY indices.  \n\nLoosely based on this image: https://www.designspiration.net/save/1718294031417/", "tags": ["grid", "beginner", "rotation"], "likes": 4, "viewed": 140, "published": "Public", "date": "1525845272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate2D(vec2 uv, float angle) {\n    uv -= 0.5;\n    uv =  mat2(cos(angle),-sin(angle),\n               sin(angle),cos(angle)) * uv;\n    uv += 0.5;\n    return uv;\n}\n\nfloat getSquare(vec2 p, vec2 size, vec2 uv) {\n    float m = max(iResolution.x, iResolution.y);\n    p = p * iResolution.xy/m;\n    vec2 bl = 1.0-smoothstep(-16.0/m, 16.0/m, abs(2.0*(p-uv))-size );\n    return bl.x * bl.y;\n}\n\nvec2 grid(vec2 uv, float num) {\n    uv *= num;\n    vec2 index = floor(uv);\n    \n    // Hides rows along the edges\n    if (index.x <= 0. ||\n        index.x > num-1. ||\n        index.y <= 0. ||\n        index.y > num - 2.) {\n        return vec2(0.);\n    }\n    \n    float rad = (1.5708 /num) * (index.x - index.y) * sin(iTime * 2.) * 3.;\n    uv = fract(uv);\n    uv = rotate2D(uv, rad);\n    \n    return uv;\n}\n\nfloat ring(vec2 pos, float r, vec2 uv) {\n    uv -= .5;\n    float l = length(uv);\n    \n    float color = smoothstep(r - 0.05, r, l) - smoothstep(r, r - 0.1, l);\n    \n    float t = r - 0.15;\n    color *= smoothstep(t - 0.05, t, l) - smoothstep(t, t - 0.05, l);\n    \n    color -= getSquare(vec2(-0.010,0.40), vec2(0.140,0.5), uv);\n    \n    return 1. - color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.y;\n    st.x -= 0.3;\n    \n    vec3 color = vec3(.97);\n    \n    vec2 grid = grid(st, 8.);\n    \n    float ring = ring(vec2(0.5), .53, grid);\n    color = mix(color, vec3(0.), ring);\n    \n    // color = vec3(grid.x ,grid.y, 0.);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xdcfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 167], [169, 169, 214, 214, 389], [391, 391, 422, 422, 794], [796, 796, 836, 836, 1153], [1155, 1155, 1212, 1212, 1515]], "test": "valid"}
{"id": "XddBWs", "name": "Hyperspace Travel", "author": "noxbuds", "description": "My attempt at making the cool sci-fi hyperspace effects in space movies.", "tags": ["raymarch"], "likes": 9, "viewed": 502, "published": "Public", "date": "1527259653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14\n#define TA 6.28\n#define PH 1.57\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//             HYPERSPACE EFFECT               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculates the hyperspace tunnel at uv\nvec3 tunnel(vec2 uv)\n{\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Calculate polar co-ordinates\n    float r = 0.5 / length(uv) + iTime;\n    float mr = mod(r + 1000.0, 700.0);\n    if (mr < 400.0)\n        mr += 400.0;\n    float theta = atan(uv.x, uv.y);\n    \n    // Calculate the colour\n    // Convert the new polar co-ordinates to cartesian\n    vec2 ptc = vec2(mr * cos(theta / TA), mr * sin(theta / TA));\n    \n    // Then create some noise\n    float snv = fbm(ptc * 2.0);\n    if (snv > 0.8)\n        col = vec3(1.0);\n    \n    // Then make the tunnel. Use two noise values,\n    // which are mirrors of each other. Use a small\n    // value added to theta to prevent artifacts.\n    float fbm1 = fbm(vec2( r, mod(theta + 0.001, PI) ));\n    float fbm2 = fbm(vec2( r, PI - mod(theta - 0.001, PI) ));\n    \n    // Change fbm1 and fbm2 to make more contrast\n    fbm1 = pow(fbm1, 2.0);\n    fbm2 = pow(fbm2, 2.0);\n    \n    // More mirrored noise for colouring\n    float fbm3 = fbm(vec2( r, mod(theta + 0.001, PI) ) * 2.0);\n    float fbm4 = fbm(vec2( r, PI - mod(theta - 0.001, PI) ) * 2.0);\n    \n    // Colours for the tunnel\n    vec3 tc1 = vec3(0.0, 1.0, 0.5);\n    vec3 tc2 = vec3(0.0, 0.5, 1.0);\n    \n    // Set the noise value based on the angle\n    if (theta > 0.0)\n    \tcol = mix(col, mix(tc1, tc2, fbm4), fbm2);\n    else\n        col = mix(col, mix(tc1, tc2, fbm3), fbm1);\n    \n    // Return colour\n    return col;\n}\n\n// Calculates the pixel at uv\nvec3 calcPixel(vec2 uv)\n{\n    // Correct the UV co-ordinates\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Draw the tunnel\n    col = tunnel(uv);\n    \n    // Return colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Do some supersampling\n    for (float x = -1.0; x < 2.0; x += 0.5)\n    {\n        for (float y = -1.0; y < 2.0; y += 0.5)\n        {\n            // Calculate pixel here\n            vec3 pixel = calcPixel((fragCoord + vec2(x, y)) / iResolution.xy);\n            \n            // Add it, and make a bloom effect\n            col += pixel;\n        }\n    }\n    \n    // Average it out\n    col /= 16.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 568, 590, 590, 653], [655, 673, 695, 715, 1228], [1230, 1246, 1265, 1265, 1518], [1771, 1813, 1835, 1855, 3236], [3238, 3268, 3293, 3328, 3541], [3543, 3793, 3850, 3870, 4361]], "test": "valid"}
{"id": "XddBzf", "name": "Sphere01", "author": "Benstyle", "description": "My first ray marching experience !!!!", "tags": ["spheretestfirstone"], "likes": 0, "viewed": 98, "published": "Public", "date": "1526231812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat sphere(vec3 o,vec3 v,vec3 p, vec3 l, float lint, float r)\n{\n\tfloat d = length(o-p) - r;\n    vec3 t = v;\n\n\tfor (int i = 0; i <= 64; i++)\n    {\n        t += d*v;\n        d = (length( o + t - p) - r); // ray marching algorithm we look for the nearest point on the sphere\n        \n        \n            }\n    if(d < 0.1) {\n        float intensity = 0.;\n        vec3 LtoPoint = o + t - l;\n        vec3 normale = o + t - p;\n        normale = normale/(length(normale)); // creating two vectors for lighting\n                           \n        vec3 StoPoint = normale + vec3(texture(iChannel0,normale.xy*.3).x/10.,texture(iChannel0,normale.xy*.3).y/10.,0); // adding bump map ( iChannel 0)\n        float l1 = length(LtoPoint);\n        float l2 = length(StoPoint);\n        \n            \n        intensity = (lint*dot(LtoPoint,-StoPoint)/(l1*l1*l2)); // calculating light intensity\n        intensity = (intensity + abs(intensity))/2.;\n        intensity += .1;\n        \n      \n            \n            \n\treturn intensity;\n        }\n    else{\n        return .7;\n            }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5 ;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    // creating the camera, the screen the sphere and the light\n    \n    vec3 o = vec3(0.,0.,-2.);\n    vec3 v = vec3(uv.x,uv.y, 0) - o;\n    v = v/length(v);\n    \n    float t = iTime;\n    \n    vec3 p = vec3(0. + cos(.5*t)*5., 0., 20. + sin(.5*t)*10.);\n    vec3 l = vec3(40.*(iMouse.x/iResolution.x - .5),40.*(iMouse.y/iResolution.y - .5),2.);\n    \n    float intensity = sphere(o,v, p, l,10., 5.);\n\n    // Output to screen\n    \n    vec4 sphereCol = vec4(intensity*.5,intensity*.5,intensity,1.0);\n    \n    fragColor = sphereCol;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 67, 67, 1072], [1075, 1075, 1132, 1182, 1804]], "test": "error"}
{"id": "XddfDs", "name": "Circle Hipnosis", "author": "lowww", "description": "Another glsl exercise.\nNot really sure what I'm trying to do here, just playing around", "tags": ["circles"], "likes": 4, "viewed": 143, "published": "Public API", "date": "1527263116", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FREQUENCY 20.0\n#define SPEED 2.0\n#define OFFSET 0.5\n\nfloat drawCircle(vec2 uv, vec2 offset) {\n    float ratio = iResolution.x / iResolution.y;\n\tfloat d = length(uv - vec2(0.5 * ratio, 0.5) - offset);\n    float c = cos(d * FREQUENCY - iTime * SPEED);\n\tc *= 500.0;\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.y;\n\t\n    float c = 0.0;\n    \n    // \"original\" circle\n    c += drawCircle(uv, vec2(0.0));\n    \n    // horizontal displacement\n    float h = cos(iTime);\n\tc += mix(c, drawCircle(uv, vec2(-OFFSET, 0.0)), h);\n    c += mix(c, drawCircle(uv, vec2(OFFSET, 0.0)), h);\n\t\n    // vertical displacement\n    float v = sin(iTime);\n    c += mix(c, drawCircle(uv, vec2(0.0, -OFFSET)), v);\n    c += mix(c, drawCircle(uv, vec2(0.0, OFFSET)), v);\n    \n    // antialias as suggested by @FabriceNeyret2\n    c = c / fwidth(c);\n\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddfDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 101, 101, 283], [285, 285, 340, 340, 906]], "test": "valid"}
{"id": "XddfW7", "name": "Quartic Intersection", "author": "wyatt", "description": "Testing different people's quartic roots algorithms in the context of a couple simple quartic shapes + some quadric ones too\n\nhad big dreams for this one, but it looks like shiny unstable poo\n\nShane wins for best quartic solver!", "tags": ["torus", "sphere", "intersection", "quartic", "parabola"], "likes": 8, "viewed": 642, "published": "Public API", "date": "1527032402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHANE 1\n#define MATTZ 2\n#define WYATT 0\n#define METHOD SHANE\nmat3 M;\nmat3 rot (vec3 u) {\n\t\tvec3 s = sin(u), c = cos(u);\n\t\tmat3 x = mat3(1,0,0, \t\t0,c.x,s.x, \t\t0,-s.x,c.x);\n\t\tmat3 y = mat3(c.y,0,s.y, \t0,1,0, \t\t\t-s.y,0,c.y);\n\t\tmat3 z = mat3(s.z,c.z,0,\t-c.z,s.z,0,\t\t0,0,1);\n\t\treturn x*y*z;}\n\n#if METHOD == WYATT\n\t//https://www.shadertoy.com/view/4dlcDN\n\tfloat cbrt (float a) {\n        return sign(a)*exp(log(abs(a))/3.);\n    }\n    vec2 cbrt (vec2 a) {\n        return vec2(cbrt(a.x),cbrt(a.y));\n    }\n    vec2 cbrti (vec2 v) {\n        float a = length(v);\n        a = exp(log(a)/3.);\n        float theta = atan(v.y/v.x)/3.;\n        return a*vec2(cos(theta), sin(theta));\n    }\n    float cubic (float b, float c, float d) {\n        float p = -b/3.;\n        float q = p*p*p + b*c/6. - 0.5*d;\n        float r = c/3.;\n        float s = r-p*p;\n        float u = q*q + s*s*s;\n        if (u < 0.) {\n            vec2 t = vec2(0., sqrt(-u));\n            vec2 Q = vec2(q, 0.);\n            return (cbrti(Q + t) + cbrti(Q - t)).x + p; \n        } else {\n            float t = sqrt(u);\n            return cbrt(q + t) + cbrt(q - t) + p; \n        }\n    }\n\tbvec4 solve_quartic (in vec4 coe, out vec4 roots) {\n        //https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n        float b = coe.x;float c = coe.y; float d = coe.z; float e = coe.w;\n        float p = c - 3.*b*b/8.;\n        float q = 0.125*b*b*b - 0.5*b*c + d;\n        float r = (-3.*b*b*b*b + 256.*e - 64.*b*d + 16.*b*b*c)/256.;\n        float m = cubic(p, 0.25*p*p - r, -0.125*q*q);\n        if (m<=0.) return bvec4(false);\n        float A = -0.25*b;\n        float B = 0.5*sqrt(2.*m);\n        float C = -2.*p - 2.*m;\n        float D = -sqrt(2.)*q/sqrt(m);\n        float x = 10.;\n        roots = vec4(\n            A + B + 0.5*sqrt(C + D),\n            A + B - 0.5*sqrt(C + D),\n            A - B + 0.5*sqrt(C - D),\n            A - B - 0.5*sqrt(C - D)\n        );\n        return bvec4(vec2(C+D>=0.),vec2(C-D>=0.));\n    }\n#elif METHOD == MATTZ\n\t//https://www.shadertoy.com/view/4dVcR1\n\tbvec4 solve_quartic(in vec4 coeffs,out vec4 roots) {\n        //Mattz version of quartic solver\n\t\t//https://www.shadertoy.com/view/XdKyRR\n        \n    float p = coeffs[0];\n    float q = coeffs[1]; \n    float r = coeffs[2];\n    float s = coeffs[3];\n    float i = -q;\n    float j = p*r - 4.*s;\n    float k = 4.*q*s - r*r - p*p*s;\n    float a = (3.*j - i*i) / 3.;\n    float b = (2.*i*i*i - 9.*i*j + 27.*k) / 27.;\n    float delta1 = b*b / 4.;\n    float delta2 = a*a*a / 27.;\n    float delta = delta1 + delta2;\n    \n    float z1;\n    \n    if (delta >= 0.) {\n        vec2 AB = -0.5*b + vec2(1,-1) * sqrt(max(delta, 0.));\n        AB = sign(AB) * pow(abs(AB), vec2(1.0/3.0));\n        z1 = AB.x + AB.y;\n    } else {\n        float phi = acos( -sign(b) * sqrt(delta1/-delta2) );\n        z1 = 2. * sqrt(-a/3.) * cos( phi / 3.);\n    }\n    \n    // shift back from normal form to root of resolvent cubic\n    z1 -= i/3.;\n    \n    ////////////////////////////////////////////////////////////\n\t// now form quartic roots from resolvent cubic root\n\n    float R2 = p*p/4. - q + z1; \n        \n    bool R_ok = (R2 >= 0.);\n\n    float R = sqrt(max(R2, 0.));\n    \n    float foo, bar;\n    \n    if (R == 0.) { \n        float z124s = z1*z1 - 4.*s;\n        R_ok = R_ok && (z124s >= 0.);\n        foo = 3.*p*p / 4. - 2.*q;\n        bar = 2.*sqrt(max(z124s, 0.));\n    } else {\n        foo = 3.*p*p / 4. - R2 - 2.*q;\n        bar = (4.*p*q - 8.*r - p*p*p) / (4.*R);\n    }\n    \n    bool D_ok = R_ok && (foo + bar >= 0.);\n    bool E_ok = R_ok && (foo - bar >= 0.);\n    \n    float D = sqrt(max(foo + bar, 0.));\n    float E = sqrt(max(foo - bar, 0.));\n    \n    roots = vec4(-p/4.) + 0.5 * vec4(R+D, R-D, -(R-E), -(R+E));\n    return bvec4(D_ok, D_ok, E_ok, E_ok);\n\n}\n#elif METHOD == SHANE\n\t//https://www.shadertoy.com/view/XsGyDh\n\tint solve_quadric(vec2 coeffs, inout vec2 roots){\n        float p = coeffs.y / 2.;\n        float D = p*p - coeffs.x;\n        if (D <= 0.) return 0;\n        else {\n            roots = vec2(-1, 1)*sqrt(D) - p;\n            return 2;\n        }\n    }\n    int solve_cubic(vec3 coeffs, inout vec3 r){\n        float a = coeffs[2];\n        float b = coeffs[1];\n        float c = coeffs[0];\n        float p = b - a*a/3.;\n        float q = a * (2.*a*a - 9.*b)/27. + c;\n        float p3 = p*p*p;\n        float d = q*q + 4.*p3/27.;\n        float offset = -a/3.;\n        if(d >= 0.0) { \n            vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n            uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n            r[0] = offset + uv.x + uv.y;\t\n            float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n            float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n            r[0] -= f/f1;\n            return 1;\n        }\n        float u = sqrt(-p/3.);\n        float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n        float m = cos(v), n = sin(v)*1.732050808;\n        float f,f1;\n        r[0] = offset + u * (m + m);\n        f = ((r[0] + a)*r[0] + b)*r[0] + c;\n        f1 = (3.*r[0] + 2. * a)*r[0] + b;\n        r[0] -= f / f1;\n        r[1] = offset - u * (n + m);\n        f = ((r[1] + a)*r[1] + b) * r[1] + c;\n        f1=(3.*r[1] + 2. * a)*r[1] + b;\n        r[1] -= f / f1;\n        r[2] = offset + u * (n - m);\n        f = ((r[2] + a)*r[2] + b)*r[2] + c;\n        f1 = (3.*r[2] + 2. * a)*r[2] + b;\n        r[2] -= f / f1;\n        return 3;\n    }\n    bvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n        bvec4 broots;\n        float a = coeffs[0];\n        float b = coeffs[1];\n        float c = coeffs[2];\n        float d = coeffs[3];\n        float sq_a = a * a;\n        float p = - 3./8. * sq_a + b;\n        float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n        float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n        int num;\n        vec3 cubic_coeffs;\n        cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n        cubic_coeffs[1] = - r;\n        cubic_coeffs[2] = - 1.0/2. * p;\n        solve_cubic(cubic_coeffs, s.xyz);\n        float z = s[0];\n        float u = z * z - r;\n        float v = 2. * z - p;\n        if(u > 0.) u = sqrt(abs(u));\n        else return bvec4(false);\n        if(v > 0.) v = sqrt(abs(v));\n        else return bvec4(false);\n        vec2 quad_coeffs;\n        quad_coeffs[0] = z - u;\n        quad_coeffs[1] = q < 0. ? -v : v;\n        num = solve_quadric(quad_coeffs, s.xy);\n        if (num == 0) broots.xy = bvec2(false);\n        if (num == 2) broots.xy = bvec2(true);\n        quad_coeffs[0] = z + u;\n        quad_coeffs[1] = q < 0. ? v : -v;\n        vec2 tmp = vec2(1e8);\n        int old_num = num;\n        num = solve_quadric(quad_coeffs, s.zw);\n        if (num == 0) broots.zw = bvec2(false);\n        if (num == 2) broots.zw = bvec2(true);\n        s -= a/4.;\n        return broots;\n    }\n#endif\n\nfloat absmin(float a, float b) {\n\tif (b>0.) return min(a,b);\n    return a;\n}\nfloat intersect (vec4 coes) {\n    vec4 roots;\n    bvec4 br = solve_quartic(coes, roots);\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}\nfloat intersect (vec2 coes) {\n\tfloat i=1e4;\n    float det = coes.x*coes.x-4.*coes.y;\n    if (det < 0.) return i;\n    det =sqrt(det);\n    i = absmin(i,0.5*(-coes.x+det));\n    i = absmin(i,0.5*(-coes.x-det));\n    return i;\n}\nvec4 torus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r) {\n\tfloat dn = dot(d,n);\n    float wn = dot(p-c,n);\n    vec3 s = p-c-wn*n;\n    vec3 q = d - dn*n;\n    float qq = dot(q,q);\n    float sq = dot(s,q);\n    float ss = dot(s,s);\n    float A = (dn*dn+qq)*0.5/r.x;\n    float B = (wn*dn+sq)/r.x;\n    float C = (r.x*r.x-r.y*r.y+wn*wn+ss)*0.5/r.x;\n    return vec4(2.*A*B,B*B+2.*A*C-qq,2.*C*B-2.*sq,C*C-ss)/(A*A);\n    \n}\nvec4 cube (vec3 p, vec3 d, vec3 c, mat3 n, float r) {\n\tvec3 a = vec3(dot(p-c,n[0]),dot(p-c,n[1]),dot(p-c,n[2]));\n    vec3 b = vec3(dot(d,n[0]),dot(d,n[1]),dot(d,n[2]));\n    return vec4(\n        4.*dot(a*b,b*b),\n        6.*dot(a*a,b*b),\n        4.*dot(a*a,a*b),\n           dot(a*a,a*a)-r*r*r*r\n    )/dot(b*b,b*b);\n}\nvec2 ellipse (vec3 p, vec3 d, vec3 a, vec3 b, float r) {\n\ta = p-a;b = p-b;\n    float \n        rr = r*r,\n        ad = dot(a,d),\n        bd = dot(b,d),\n        aa = dot(a,a),\n        bb = dot(b,b);\n    return vec2(\n    \tad*aa-ad*bb+bd*bb-bd*aa-rr*(ad+bd),\n        -aa*bb+0.25*(aa*aa+bb*bb+rr*rr)+0.5*(aa*bb-rr*(aa+bb))\n    )/(ad*ad+bd*bd-rr-2.*ad*bd);\n}\nvec2 sphere (vec3 p, vec3 d, vec3 c, float r) {\n\tc = p-c;\n    return vec2(2.*dot(c,d),dot(c,c)-r*r);\n}\nvec2 parabola (vec3 p, vec3 d, vec3 a, vec3 b) {\n\tvec3 n = normalize(b-a);\n    a = p-a;\n    b = p-b;\n    float\n        dn = dot(d,n),\n        an = dot(a,n),\n        bd = dot(b,d),\n        bb = dot(b,b);\n   \treturn vec2(\n    \t2.*(an*dn-bd),\n        an*an-bb\n    )/(dn*dn-1.);\n}\nfloat scene (vec3 p, vec3 d) {\n    float i = 1e3;\n    i = min(i,intersect(torus (p,d,vec3(0),vec3(0,0,1),vec2(0.15,0.02))));\n    i = min(i,intersect(ellipse(p,d,vec3(-.1,-.08,0.04),vec3(0.1,-.08,-.04),.23)));\n    i = min(i,intersect(cube (p,d,vec3(0),mat3(1,0,0,0,1,0,0,0,1),0.5)));\n    i = min(i,intersect(cube (p,d,vec3(.1),mat3(1,0,0,0,1,0,0,0,1),0.08)));\n  \ti = min(i,intersect(sphere(p,d,vec3(0,.1,0),0.03)));\n    i = min(i,intersect(parabola(p,d,vec3(-0.02,0,0),vec3(0))));\n    return i;\n    \n}\nvec3 nor (vec3 p, vec3 d, float i) {\n\tfloat e = 1e-4;\n    vec3 t = normalize(cross(d,vec3(1,0,0)));\n    vec3 a = p+e*t+d*scene(p+e*t,d);\n    t = normalize(cross(d,t));\n    vec3 b = p+e*t+d*scene(p+e*t,d);\n    p = p+d*i;\n\treturn normalize(cross(b-p,a-p));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy*2.-1.)*iResolution.xy/iResolution.yy;\n\tM = rot(0.3*iTime*vec3(0,vec2(1)+0.3*(iMouse.xy/iResolution.xy*2.-1.)));\n    vec3 p = M*vec3(0.01*uv,-.3);\n    vec3 d = M*normalize(vec3(uv,2));\n    float i;\n    vec3 n;\n    vec3 col = vec3(0);\n    for (int o = 0; o < 5; o++) {\n    \ti = scene(p,d);\n        n = nor(p,d,i);\n        p += i*d;\n       \td = reflect(d,n);\n        p += 0.001*d;\n        col += (0.3+0.7*n)/float(2*o/3+2);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 96, 96, 294], [6734, 6734, 6766, 6766, 6810], [6811, 6811, 6840, 6840, 7079], [7080, 7080, 7109, 7109, 7302], [7303, 7303, 7356, 7356, 7712], [7713, 7713, 7766, 7766, 8027], [8028, 8028, 8084, 8084, 8379], [8380, 8380, 8427, 8427, 8482], [8483, 8483, 8531, 8531, 8759], [8760, 8760, 8790, 8790, 9260], [9261, 9261, 9297, 9297, 9517], [9518, 9518, 9575, 9575, 10075]], "test": "valid"}
{"id": "XddfWB", "name": "wrecking Lipschitz again...", "author": "MacSlow", "description": "... but the result is cleaner and almost artefact-free :) ShaderToy is not good for my social life ;)", "tags": ["3d", "raymarching", "noise", "reflection", "deform"], "likes": 6, "viewed": 460, "published": "Public API", "date": "1526771611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"wrecking Lipschitz again\" - cleaner domain-distortions with less artefacts \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .001;\n\nfloat udBox (in vec3 p, in vec3 size, in float r)\n{\n    return length (max (abs (p) - (size -r), .0)) - r;\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat sdSphere (in vec3 p, in float r)\n{\n    return length (p) - r;\n}\n\nvec3 opRepeat3 (in vec3 p, float d)\n{\n    return mod (p + d*.5, d) - d*.5;\n}\n\nfloat opUnion (in float a, in float b)\n{\n\treturn min (a, b);\n}\n\nfloat opIntersect (in float a, in float b)\n{\n\treturn max (a, b);\n}\n\nfloat opSubtract (in float a, in float b)\n{\n\treturn max (-a, b);\n}\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float cy = cos (rad * p.y);\n    float sy = sin (rad * p.y);\n    mat2  my = mat2 (cy, -sy, sy, cy);\n    float cx = cos (rad * p.x);\n    float sx = sin (rad * p.x);\n    mat2  mx = mat2 (cx, -sx, sx, cx);\n    p = mix (vec3 (mx* p.zx, p.y), vec3 (my * p.xy, p.z), .15*cos (p.x));\n\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 6. + 4.*cos (2.*iTime);\n\tresult = .375 * sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n\n    return result;\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat scene (in vec3 p)\n{\n    vec2 offset = .75 * vec2 (cos (6.28+iTime), sin (6.28+iTime));\n\n    vec3 w = (p + vec3 (-offset.x, -.125+offset.y, .0));\n    opBend (w, 45. * cos (.25*iTime));\n    w.zx *= r2d (50.*iTime);\n    w.xy *= r2d (-75.*iTime);\n    float dt = sdSphere (w, .65);\n    float dp = displace (w);\n    float thing = dt + dp; \n    \n    p.xz *= r2d (-12.*iTime);\n    p.yx *= r2d (8.*iTime);\n    vec3 p1 = p + vec3 (.355);\n    p1 = opRepeat3 (p1, .325);\n    float boxes = udBox (p1, vec3 (.15), .03);\n    float cutBox = sdBox (p, vec3 (2.7), .05);\n    float wallBox = sdBox (p, vec3 (2.8), .05);\n\n    return opUnion (thing, opUnion (-wallBox, opSubtract (cutBox, boxes)));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd)\n{\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 96; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs(t) < EPSILON*(1. + .125*t)) break;\n        d += t*.5;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - scene (p));\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n    vec3 ambient = vec3 (.025);\n    vec3 diffuseColor = vec3 (.2, .1, .1);\n    vec3 specularColor = vec3 (.95);\n    float shininess = 70.;\n    float diffuseStrength = .95;\n    float t = 3.*iTime;\n\n    vec3 n = normal (p, d*EPSILON);\n    vec3 lPos = 1.5 * vec3 (cos (t), 1., sin (t));\n    float lDist = distance (lPos, p);\n    vec3 lDir = normalize (lPos - p);\n    vec3 hDir = normalize (ro + lDir);\n    float diffuse = max (dot (n, lDir), .0)*(1. / lDist)*diffuseStrength;\n    float specular = pow (max (dot (hDir, n), .0), shininess);\n\n\tvec3 diffuseColor2 = vec3 (.1, .2, .1);\n    vec3 specularColor2 = vec3 (.95);\n    vec3 lPos2 = -1.5 * vec3 (.0, sin(t), .75*cos(t));\n    float lDist2 = distance (lPos2, p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    vec3 hDir2 = normalize (ro + lDir2);\n    float diffuse2 = max (dot (n, lDir2), .0)*(1. / lDist2)*diffuseStrength;\n    float specular2 = pow (max (dot (hDir2, n), .0), shininess);\n\n\tvec3 diffuseColor3 = vec3 (.1, .1, .2);\n    vec3 specularColor3 = vec3 (.95);\n    vec3 lPos3 = 1.5 * vec3 (sin (t), .5*cos(t), -1.);\n    float lDist3 = distance (lPos3, p);\n    vec3 lDir3 = normalize (lPos3 - p);\n    vec3 hDir3 = normalize (ro + lDir3);\n    float diffuse3 = max (dot (n, lDir3), .0)*(1. / lDist3)*diffuseStrength;\n    float specular3 = pow (max (dot (hDir3, n), .0), shininess);\n\n    vec3 col = ambient +\n\t\t\t   diffuse * diffuseColor + specular * specularColor +\n\t\t\t   diffuse2 * diffuseColor2 + specular2 * specularColor2 +\n\t\t\t   diffuse3 * diffuseColor3 + specular3 * specularColor3;\n    return col;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n    \n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // set up \"camera\", view origin (ro) and view direction (rd)\n    float angle = radians (300. + 55. * iTime);\n    float dist = 2.6;\n    vec3 ro = vec3 (dist * cos (angle), cos (iTime), dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // primary-/view-ray\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.035);\n    vec3 p = ro + d * rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (ro, rd, d);\n    col = mix (col, vec3 (.95, .85, .7), pow (1. - 1. / d, 10.));\n\n    // secondary-/reflection-ray\n    vec3 rd2 = normalize (reflect (rd, n));\n    float d2 = raymarch (p + n*.001, rd2);\n    vec3 p2 = p + d2 * rd2;\n    vec3 n2 = normal (p2, EPSILON);\n    vec3 col2 = shade (p, rd2, d2);\n    col += (.1 + .05*(.5 + .5 * cos (5.*iTime))) * col2;\n\n    // ternary-/reflection-ray\n    vec3 rd3 = normalize (reflect (rd2, n2));\n    float d3 = raymarch (p2 + n2*.001, rd3);\n    vec3 p3 = p2 + d3 * rd3;\n    vec3 n3 = normal (p3, EPSILON);\n    vec3 col3 = shade (p, rd3, d3);\n    col += (.05 + .025*(.5 + .5 * cos (5.*iTime))) * col3;\n\n    // fog, tone-mapping, tint, vingette, raster-lines, gamma-correction\n    col *= fog;\n    col = col / (1. + col);\n    col *= vec3 (.85, .9, .95);\n    col *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n    col *= mix (1., .75, .5 + .5*cos (900.*uvRaw.y));\n    col = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XddfWB.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 989, 1040, 1040, 1097], [1099, 1099, 1150, 1150, 1250], [1252, 1252, 1292, 1292, 1321], [1323, 1323, 1360, 1360, 1399], [1401, 1401, 1441, 1441, 1463], [1465, 1465, 1509, 1509, 1531], [1533, 1533, 1576, 1576, 1599], [1601, 1601, 1641, 1641, 1970], [1972, 1972, 1997, 1997, 2164], [2166, 2166, 2194, 2194, 2309], [2311, 2311, 2336, 2336, 2996], [2998, 2998, 3039, 3039, 3256], [3258, 3258, 3301, 3301, 3491], [3493, 3493, 3542, 3542, 5125], [5127, 5127, 5193, 5193, 5526], [5528, 5528, 5585, 5585, 7200]], "test": "valid"}
{"id": "Xddfzs", "name": "Cow plasma - Issues CMAP", "author": "Lovax", "description": ".", "tags": ["plasma"], "likes": 1, "viewed": 75, "published": "Public", "date": "1527430818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EXP 2.71828182846\n\n\n\n#define BAD_3\n\n#ifdef BAD_1\nfloat w1 = 0.5;\nfloat w2 = 1.5;\nfloat w3 = 20.0;\nfloat threshold = 0.99;\n#endif\n#ifdef BAD_2\nfloat w1 = 1.0;\nfloat w2 = 5.0;\nfloat w3 = 50.0;\nfloat threshold = 0.95;\n#endif\n#ifdef BAD_3\nfloat w1 = 3.0;\nfloat w2 = 3.0;\nfloat w3 = 20.0;\nfloat threshold = 0.80;\n#endif\n\nfloat horizontal(in vec2 xy, float t)\t{\n    float v = cos(w1*xy.x + t);\n\treturn v;\n}\n    \nfloat diagonal(in vec2 xy, float t)\t{\n    float v = cos(w2*(xy.x*cos(t) + 5.0*xy.y*sin(t)) + t);\n    return v;\n}\nfloat radial(in vec2 xy, float t)\t{\n    float x = 0.3*xy.x - 0.5 + cos(t);\n    float y = 0.3*xy.y - 0.5 + sin(t*0.5);\n    float v = sin(w3*sqrt(x*x+y*y+1.0)+t);\n    return v;\n}\n\nfloat map(float a,float b,float c,float d,float x) {\n    return ((x-a)*(d-c)/(b-a))+c;\n}\n\nfloat log_map(float a,float b,float c,float d,float x) {\n    float x1 = map(a,b,1.0,EXP,x);\n    return log(x1)*(d-c)+c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t{\n    float t = iTime;\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    float v = horizontal(xy,t);\n    v += diagonal(xy,t);\n    v += radial(xy,t);\n    v /= 3.0;\n    float r = step(map(-1.0,1.0,   0.75,1.0,sin(PI*v)), threshold);\n    fragColor = vec4(1,1,1,1)-vec4(r,r,r,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xddfzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 388, 388, 433], [439, 439, 476, 476, 551], [552, 552, 587, 587, 728], [730, 730, 782, 782, 818], [820, 820, 876, 876, 941], [943, 943, 1000, 1000, 1274]], "test": "valid"}
{"id": "XdtBR2", "name": "Dancing Sinus", "author": "FraKtus", "description": "Three sinusoids dance on the spectrum of music. Inspired by https://github.com/overtone/shadertone/blob/master/examples/disco.glsl", "tags": ["microphone"], "likes": 13, "viewed": 1770, "published": "Public API", "date": "1525948745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Marco Hinic\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// Original https://github.com/overtone/shadertone/blob/master/examples/disco.glsl\n//\n\nfloat hz(float hz)\n{\n    float u = hz/11000.0;\n    return texture(iChannel0,vec2(u,0.25)).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // 3 dancing magenta, cyan & yellow sine waves\n    float v1 = 0.02 + 0.4*hz(100.0);\n    float v2 = 0.02 + 0.4*hz(500.0);\n    float v3 = 0.02 + 0.4*hz(2000.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float v1x = uv.x - 0.5 + sin(5.0*iTime + 1.5*uv.y)*v1;\n    float v2x = uv.x - 0.2 + sin(3.0*iTime + 0.8*uv.y)*v2;\n    float v3x = uv.x - 0.3 + sin(7.0*iTime + 3.2*uv.y)*v3;\n    col += vec3(1.0,0.0,1.0) * abs(0.066/v1x) * v1;\n    col += vec3(1.0,1.0,0.0) * abs(0.066/v2x) * v2;\n    col += vec3(0.0,1.0,1.0) * abs(0.066/v3x) * v3;\n\n    // with a lighted disco floor pattern\n    float uvy2 = 0.4*iTime-uv.y;\n    float a1 = max(0.0,0.25*hz(200.0)) *\n        max(0.0,min(1.0,sin(50.0*uv.x)*sin(50.0*uvy2)));\n    col += vec3(1.0,1.0,1.0) * a1;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtBR2.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1166, 1186, 1186, 1260], [1262, 1262, 1319, 1319, 2140]], "test": "error"}
{"id": "XdtfDs", "name": "pseudo-realistic base scene", "author": "MacSlow", "description": "Two light-sources, hard shadows, reflections, (fake) fresnel, blinn-phong, basic material-system... and polka-dots :) For a non-PBR scene it looks solid I guess. This is basically now my goto-scene for starting new tests.", "tags": ["3d", "raymarching", "reflection", "phong", "shadow", "lighting", "spheretracing", "blinn", "fresnel"], "likes": 4, "viewed": 483, "published": "Public API", "date": "1527269087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// pseudo-realistic base scene \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 48;\nconst float EPSILON = .001;\nconst float STEP_BIAS = .95;\n\nmat2 r2d (in float a) {\n\tfloat c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat sdTerrain (in vec3 p, in float height)\n{\n    float h = .5*texture (iChannel0, .1*p.xz).r;\n    h += .25*texture (iChannel0, .2*p.xz).r;\n    h += .125*texture (iChannel0, .4*p.xz).r;\n    h += .0625*texture (iChannel0, .8*p.xz).r;\n    h /= (.5 + .25 + .125 + .0625);\n    h += height;\n    return p.y - .0625*h*.25;\n}\n\nfloat sdTorus (in vec3 p, in vec2 t)\n{\n    vec2 q = vec2 (length (p.xz) - t.x, p.y);\n    return length (q) - t.y;\n}\n\nstruct HitResult {\n\tfloat dist;\n\tint id;\n};\n\nHitResult scene (in vec3 p) {\n    vec3 boxCenter = p + vec3 (1.5, -1., .0);\n    boxCenter.xz *= r2d (12.*iTime);\n    boxCenter.zy *= r2d (-16.*iTime);\n    boxCenter.xy *= r2d (8.*iTime);\n    boxCenter.xy += .02*sin (10.*p.y + 5.*iTime);\n    boxCenter.yz += .02*cos (20.*p.y + 4.*iTime);\n    boxCenter.zy += .02*sin (15.*p.y + 6.*iTime);\n    float box = sdBox (boxCenter, vec3(.75), .1);\n\n    float ground = sdTerrain (p, -1.);\n    vec3 torusCenter = p + vec3 (-1.5, -1., .0);\n    torusCenter.xy *= r2d (80.*(.5+.5*cos(iTime))*torusCenter.z);\n    float torus = sdTorus (torusCenter, vec2 (.75, .3));\n\n\tHitResult result = HitResult (.0, -1);\n\tresult.dist = min (torus, min (ground, box));\n\tresult.id = result.dist == torus ? 0 : (result.dist == ground ? 1 : (result.dist == box ? 2 : -1));\n\n    return result;\n}\n\nHitResult raymarch (in vec3 ro, in vec3 rd) {\n    float d = .0;\n\tfloat t = .0;\n\tHitResult result;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        result = scene (ro + t*rd);\n        d = result.dist;\n        if (abs (d) < EPSILON * (1. + .125*d)) break;\n        t += d*STEP_BIAS;\n    }\n\n\tresult.dist = t;\n    return result;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n    float d = scene (p).dist;\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy).dist,\n                            scene (p + e.yxy).dist,\n                            scene (p + e.yyx).dist) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos) {\n    float lDist = distance (p, lPos);\n    vec3 lDir = normalize (lPos - p);\n    float dist = raymarch (p + .01*n, lDir).dist;\n    return dist < lDist ? .1 : 1.;\n}\n\nvec3 diffSpecTerm (in vec3 ro,\n                   in vec3 rd,\n                   in float d,\n                   in vec3 lPos,\n                   in vec3 diffColor,\n                   in float attenuationDamping,\n                   in vec3 specColor,\n\t\t\t\t   in float shininess) {\n    vec3  p = ro + d*rd;\n    vec3  n = normal (p, d*EPSILON);\n    vec3  lDir = normalize (lPos - p);\n    float lDist = distance (lPos, p);\n    float diff = max (dot (lDir, n), .0);\n    float sha = shadow (p, n, lPos);\n    float attenuation = attenuationDamping / (lDist*lDist);\n    vec3  diffTerm = sha*attenuation*diff*diffColor;\n    vec3  h = normalize (lDir - rd);\n    float spec = pow (max (dot (n, h), .0), shininess);\n    vec3  specTerm = (sha > .1) ? attenuation*spec*specColor : vec3 (.0);\n\n    return diffTerm + specTerm;\n}\n\nstruct Material {\n\tvec3 color;\n\tfloat shininess;\n};\n\nMaterial[3] materials = Material[3] (Material (vec3 (1., .5, .2), 10.),\n\t\t\t\t\t\t\t         Material (vec3 (.5, 1., .2), 50.),\n\t\t\t\t\t\t\t         Material (vec3 (.2, .5, 1.), 150.));\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in int matId) {\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 amb = vec3 (.15);\n\tvec3 color = matId == 1 ? mix (vec3 (.9),\n                                   vec3 (1., .1, .1),\n                                   smoothstep (.475, .5, cos(2.*p.x)*cos (2.*p.z))) :\n                              materials[matId].color;\n\tfloat mask = mix (1., .0, smoothstep (.3, .5, (.5+.5*sin (60.*p.x))*(.5+.5*sin(60.*p.y))));\n\tfloat shininess = matId == 0 ? mix (20., 60., mask) : materials[matId].shininess;\n    vec3 term1 = diffSpecTerm (ro, rd, d,\n                              vec3 (2.*cos (2.*iTime), 3., -1. + 2.*sin (1.5*iTime)),\n                              color, 5., vec3 (1.), shininess);\n\n    vec3 term2 = diffSpecTerm (ro, rd, d,\n                              vec3 (1. + 2.*cos (2.*iTime), 3., -1. + 2.*sin (2.*iTime)),\n                              color, 4., vec3 (1.), shininess);\n\n    return amb + term1 + term2;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinate-normalization, aspect-correction\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n\tuv = uv * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // \"camerea\"/view setup\n    float dist = -2.75;\n    vec3 ro = vec3 (.0 + 3.*cos (iTime), 3., .5 + 3.*sin (iTime));\n    vec3 aim = vec3 (.0);\n    float zoom = 1.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // primary/view-ray\n    HitResult result = raymarch (ro, rd);\n    float d = result.dist;\n    float fog = 1. / (1. + d*.025);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (ro, rd, d, result.id);\n\n    // secondary/1st reflection-ray\n    vec3 refl = normalize (reflect (rd, n));\n    result = raymarch (p + .01*n, refl);\n    float refd = result.dist;\n    vec3 refp = p + refd*refl;\n    vec3 refn = normal (refp, refd*EPSILON);\n    vec3 refcol = shade (p, refl, refd, result.id);\n\n    // ternary/2st reflection-ray\n    vec3 refl2 = normalize (reflect (refl, refn));\n    result = raymarch (refp + .01*refn, refl2);\n    float refd2 = result.dist;;\n    vec3 refp2 = refp + refd2*refl2;\n    vec3 refcol2 = shade (refp, refl2, refd2, result.id);\n\n    // restricting reflections to grazing view-angles\n\tfloat fakeFresnel = pow (1. - max (dot (n, -rd), .0), 1.25);\n  \tcol += fakeFresnel*.85*refcol;\n   \tcol += fakeFresnel*.85*refcol2;\n\n    // fog, \"horizon\", tint, tone-mapping, gamma-correction, vignette\n    col *= fog;\n    col = mix (col, vec3 (.65, .75, .85), pow (1. - 1. / d, 30.));\n    col *= vec3 (.9, .8, .7);\n    col = col / (1. + col);\n    col = .3 * col + .7 * sqrt (col);\n    col *= .3 + .7 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .2);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtfDs.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 995, 1018, 1018, 1114], [1116, 1116, 1167, 1167, 1267], [1269, 1269, 1315, 1315, 1587], [1589, 1589, 1627, 1627, 1704], [1751, 1751, 1780, 1780, 2560], [2562, 2562, 2607, 2607, 2887], [2889, 2889, 2932, 2932, 3159], [3161, 3161, 3212, 3212, 3375], [3377, 3377, 3655, 3655, 4188], [4420, 4420, 4483, 4483, 5407], [5409, 5409, 5475, 5475, 5804], [5806, 5806, 5863, 5914, 7581]], "test": "error"}
{"id": "XdtfRB", "name": "Playstation Waves", "author": "sangwhan", "description": "Fork of waves remix to look like the PS4 boot screen.", "tags": ["waves"], "likes": 10, "viewed": 744, "published": "Public API", "date": "1525757343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 C = vec3(0.25, 0.0, 0.2);\nfloat GWM = 2.05;\nfloat TM = 0.25;\n\nfloat getAmp(float frequency) {\n    return texture(iChannel0, vec2(frequency / 512.0, 0)).x;\n}\n\nfloat getWeight(float f) {\n    return (getAmp(f - 2.0) + getAmp(f - 1.0) + \\\n            getAmp(f + 2.0) + getAmp(f + 1.0) + \\\n            getAmp(f)) / 5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 backdrop = mix(C, C, C);\n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.0 * uvTrue - 1.0;\n    \n\tfloat li;\n    float gw;\n    float ts;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n\t\tuv.y += (0.2 * sin(uv.x + i / 7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(pow(i, 2.0) * 20.0) * (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        li = 0.4 + pow(1.6 * abs(mod(uvTrue.x + i / 1.1 + iTime,2.0) - 1.0), 2.0);\n\t\tgw = abs(li / (150.0 * Y));\n        \n        ts = gw * (GWM + sin(iTime * TM));\n\t\tcolor += vec3(ts, ts, ts);\n\t}\t\n\n\tfragColor = vec4(color + backdrop, 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 98, 98, 161], [163, 163, 189, 189, 321], [323, 323, 380, 380, 1013]], "test": "error"}
{"id": "XdtfRS", "name": "asdfad", "author": "lennyjpg", "description": "asdfasdf", "tags": ["asdfasdf"], "likes": 1, "viewed": 335, "published": "Public API", "date": "1527016441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv.x-=0.3;\n    vec2 center = vec2(0.5);\n       \n    float d = 0.1;\n    d += tan(fragCoord.x+fragCoord.y+iTime)*0.01;\n    d += sin(7.0*uv.x-uv.y*7.0+iTime)*0.1;\n    uv.x += sin(uv.y)*d;\n    uv.y += cos(uv.x)*d;\n    \n    float e = distance(center,uv);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \t\n    float g = e > 0.3 ? 0.0 : 1.0;\n    float f = uv.y*0.5;\n    float k = smoothstep(0.2,0.2+f,e);\n    \n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 594]], "test": "valid"}
{"id": "XdtfW4", "name": "egavga.bgi test", "author": "klk", "description": "Nostalgic egavga.bgi test/demo :)\nI tried to do one-connected Bresenham-like primitives routines for line, circle and ellipse.", "tags": ["oldstylevga"], "likes": 8, "viewed": 3221, "published": "Public API", "date": "1525185645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Alex Kluchikov\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nbool circle(float2 p, float r)\n{\n    p=abs(p);\n    if((p.x>r+.5)||(p.y>r+.5))\n        return false;\n    if(p.x<p.y)\n        p.xy=p.yx;\n    if(abs(p.x-sqrt(r*r-p.y*p.y))<0.5)\n       return true;\n    return false;\n}\n\nbool ellipse(float2 p, float2 r)\n{\n    p=abs(p);\n    r=abs(r)+0.01;\n    if((p.x>r.x+.5)||(p.y>r.y+.5))\n        return false;\n    float m=max(r.x,r.y);\n    r/=m;\n    p.x/=r.x;\n    p.y/=r.y;\n    if(p.x/r.x>p.y/r.y)\n    {\n        p.xy=p.yx;\n        r.xy=r.yx;\n    }\n\n    if(r.x>=r.y)\n    {\n        if(abs(p.y-sqrt(m*m-p.x*p.x))<0.5/r.y)\n            return true;\n    }\n    else\n    {\n        if(abs(p.y-sqrt(m*m-p.x*p.x))<0.5)\n            return true;\n    }\n    return false;\n\n    if(abs(sqrt(p.x*p.x+p.y*p.y))<m)\n       return true;\n    return false;\n\n}\n\nbool fillellipse(float2 p, float2 r)\n{\n    p=abs(p);\n    r=abs(r)+0.01;\n    float m=max(r.x,r.y);\n    r/=m;\n    p.x/=r.x;\n    p.y/=r.y;\n\n    if(abs(sqrt(p.x*p.x+p.y*p.y))<m)\n       return true;\n    return false;\n}\n\nbool line(float2 p, float2 p0, float2 p1)\n{\n\tfloat2 dp=p1-p0;\n    p-=p0;\n    float2 n=p/dp;\n    if(abs(dp.x)<abs(dp.y))\n    {\n        if((n.y<0.0)||(n.y>1.0))\n            return false;\n        float l=p.x-p.y*dp.x/dp.y;\n        if(abs(l)<0.5)\n            return true;\n    }\n    else\n    {\n        if((n.x<0.0)||(n.x>1.0))\n            return false;\n        float l=p.y-p.x*dp.y/dp.x;\n        if(abs(l)<0.5)\n            return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0,0,0,1);\n    float2 uv=fragCoord;\n\t\n\tif(false)\n    {\n\t    if(line(trunc(uv/2.0),float2(100,100),iMouse.xy/2.0))\n    \t    fragColor.g=1.0;\n\t    if(fillellipse(trunc(uv/2.0)-float2(100,100),iMouse.xy/2.0-float2(100,100)))\n    \t    fragColor.r=1.0;\n    \treturn;\n    }\n        \n\n    if(mod(float(iFrame),240.0)<1.0)\n    {\n        return;\n    }\n    \n   \tfloat3 col=float3(\n        fract(sqrt(iTime)*float3(117.22,151.56,510.285))\n    );\n\n    col=trunc(col*6.0)/5.0;\n    int n=int(mod(float(iFrame/240), 4.0));\n    if(n==1)\n    {\n        float2 c0=iResolution.xy*(\n            float2(fract(sqrt(iTime)*float2(354.5671,510.8234))));\n        float2 rp=trunc(uv/2.0)-trunc(c0/2.0);\n        if(!circle(rp,60.0*fract(sqrt(iTime)*358.116)))\n            discard;\n    }\n    else if(n==0)\n    {\n        float2 c0=iResolution.xy*(\n            float2(fract(sqrt(iTime)*float2(354.5671,510.8234))));\n        float2 c1=iResolution.xy*(\n            float2(fract(sqrt(iTime+5.0)*float2(354.5671,510.8234))));\n        if(!line(trunc(uv/2.0), trunc(c0/2.0), trunc(c1/2.0)))\n            discard;\n    }\n    else if(n==2)\n    {\n        float2 c0=iResolution.xy*(\n            float2(fract(sqrt(iTime)*float2(354.5671,510.8234))));\n        float2 c1=float2(80)*(\n            float2(fract(sqrt(iTime+5.0)*float2(354.5671,510.8234))));\n        if(!ellipse(trunc(c0/2.0)-trunc(uv/2.0), trunc(c1/2.0)))\n            discard;\n    }\n    else if(n==3)\n    {\n        float2 c0=iResolution.xy*(\n            float2(fract(sqrt(iTime)*float2(354.5671,510.8234))));\n        float2 c1=float2(80)*(\n            float2(fract(sqrt(iTime+5.0)*float2(354.5671,510.8234))));\n        if(!fillellipse(trunc(c0/2.0)-trunc(uv/2.0), trunc(c1/2.0)))\n            discard;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdtfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 91, 123, 123, 304], [306, 306, 340, 340, 856], [858, 858, 896, 896, 1071], [1073, 1073, 1116, 1116, 1529], [1531, 1531, 1588, 1588, 3363]], "test": "valid"}
{"id": "XdVfRz", "name": "Ride the Wave", "author": "lejeunerenard", "description": "Playing with Cosine distortion & perlin noise modulated vertical bars.", "tags": ["psychedelic", "abstract", "pattern"], "likes": 29, "viewed": 1064, "published": "Public", "date": "1527482756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n#define TWO_PI 6.2831853072\n\n#define edge 0.001\n#define totalT 8.0\n#define cosT TWO_PI * mod(iTime, totalT) / totalT\n\nfloat cnoise2 (in vec2);\n\nfloat linez (in vec2 uv) {\n  vec2 q = uv;\n\n  q += 0.1000 * cos( 7.0 * q.yx + 2.0 * cosT);\n  q += 0.0500 * cos(13.0 * q.yx + 3.0 * cosT);\n\n  const float baseHeight = 0.5;\n  const float size = 0.06;\n  const float halfsize = 0.5 * size;\n\n  float c = floor((q.x + halfsize) / size);\n  q.x = mod(q.x + halfsize, size) - halfsize;\n  q.y -= 0.3 * cnoise2(vec2(c, sin(cosT + c)));\n  q.y -= 0.2 * sin(3.0 * cosT + 0.1 * c);\n\n  const float border = 0.2 * size;\n  float v = smoothstep(halfsize - border, halfsize - border - edge, abs(q.x));\n  v *= smoothstep(baseHeight + edge, baseHeight, abs(q.y));\n  return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize to [-1, -1] -> [1, 1]\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n  \tcolor.r = linez(uv);\n  \tcolor.g = linez(uv + 0.0125);\n  \tcolor.b = linez(uv + 0.0250);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise2(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVfRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 194, 194, 771], [774, 774, 831, 870, 1115], [1117, 1562, 1583, 1583, 1632], [1634, 1634, 1656, 1656, 1693], [1695, 1695, 1723, 1723, 1775], [1777, 1777, 1796, 1796, 1836], [1838, 1862, 1885, 1885, 2919]], "test": "error"}
{"id": "XdyBRz", "name": "#51521_1_0", "author": "purple_marine", "description": "Name: \"Rising Sun\" Description: – Common shader of \"rising sun from Japan\", perhaps this shader can be made as somehow simpler", "tags": ["japan", "nice", "novice", "eazy"], "likes": 5, "viewed": 109, "published": "Public", "date": "1527355381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    vec2 st = vec2(atan(uv.y,uv.x), length(uv)); // Initialize polar coordinates\n    \n    uv = vec2(st.y , st.x-iTime); // Use polar coordinates on a cartesian coordinates\n    \n    \n    float y = uv.y*10.; // Rise the y coordinates by 10 times\n    float e = cos(y)*10.;\n    \n    \n    float c = e;\n    \n    vec3 mask = vec3(.0, 1., 1.); // Initialize mask to recolor\n    \n    vec3 col = vec3(c)*mask;\n    \n    col = col / fwidth(col); // Antialiasing. Thanks @FabriceNeyret2\n   \n    \n    fragColor = vec4(1.-col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 645]], "test": "valid"}
{"id": "XdyBzh", "name": "Spline Toroid Tunnel", "author": "TekF", "description": "Inspired by Beeple's VJ loops.", "tags": ["raymarching", "music"], "likes": 10, "viewed": 612, "published": "Public API", "date": "1527768950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 spline[] = vec3[](\n     vec3(0,-.2,2)\n    ,vec3(1.4,0,1.4)\n    ,vec3(2,0,0)\n    ,vec3(1.1,0,-1.2)\n    ,vec3(0,-.2,-2)\n    ,vec3(-1.4,0,-1.4)\n    ,vec3(-2,.2,0)\n    ,vec3(-2.6,.5,1.4)\n    ,vec3(-4,.8,2)\n    ,vec3(-5.4,.5,2.6)\n    ,vec3(-6,.2,4)\n    ,vec3(-5.4,0,5.4)\n    ,vec3(-4,-.2,6)\n    ,vec3(-2.6,-.5,5.4)\n    ,vec3(-2,-.8,4)\n    ,vec3(-1.4,-.5,2.6)\n    );\n\n\n\nvec3 CatmullRom( float t )\n{\n    int n = spline.length();\n\n    int i = int(floor(t));\n    t -= float(i);\n    \n    vec3 p0 = spline[(i-1+1000*n)%n]; // % is stupid on negative numbers, so add 1000*n because nothing matters and the world is a dumpster fire. Also I'm lazy.\n    vec3 p1 = spline[(i+0+1000*n)%n];\n    vec3 p2 = spline[(i+1+1000*n)%n];\n    vec3 p3 = spline[(i+2+1000*n)%n];\n    \n    const float t0 = -1.;\n    const float t1 = 0.;\n    const float t2 = 1.;\n    const float t3 = 2.;\n    \n    vec3 A0 = mix( p0, p1, (t-t0)/(t1-t0) ); // todo: simplify this maths\n    vec3 A1 = mix( p1, p2, (t-t1)/(t2-t1) ); // hopefully the compiler's smart enough to do it\n    vec3 A2 = mix( p2, p3, (t-t2)/(t3-t2) );\n    vec3 B0 = mix( A0, A1, (t-t0)/(t2-t0) );\n    vec3 B1 = mix( A1, A2, (t-t1)/(t3-t1) );\n\n    return mix( B0, B1, (t-t1)/(t2-t1) );\n}\n\nfloat Torus( vec3 pos, vec3 centre, vec3 axis, float majorRadius, float minorRadius )\n{\n    pos -= centre;\n    float pd = dot(pos,axis);\n    float pd2 = pd*pd;\n    float r = sqrt(dot(pos,pos)-pd2)-majorRadius;\n    return sqrt(r*r+pd2)-minorRadius;\n}\n\t\n#define SplinePosDir(T) CatmullRom(T),normalize(CatmullRom(T+.1)-CatmullRom(T-.1))\n\nfloat SDF( vec3 pos )\n{\n    float f = 1e30;\n    \n    int n = spline.length();\n    \n    float beat = 1.-fract(iChannelTime[0]*114./60.);\n    beat = pow(beat,2.)*sin(beat*6.283*4.);\n    \n    // in theory calling CatmullRom() with a constant *SHOULD* compile to a static result\n    // but the compiler seems to get confused if I do it in a loop (i.e. it didn't unroll the loop)\n    // unrolling the loop by hand fixed the problem, and means I can set individual radii\n    float s = float(n)/24.;\n    f = min(f,Torus(pos,SplinePosDir(0.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(1.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(2.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(3.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(4.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(5.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(6.*s),.7,.5+.1*beat));\n    f = min(f,Torus(pos,SplinePosDir(7.*s),.9,.1));\n    f = min(f,Torus(pos,SplinePosDir(8.*s),.8,.1));\n    f = min(f,Torus(pos,SplinePosDir(9.*s),.7,.1));\n    f = min(f,Torus(pos,SplinePosDir(10.*s),.6,.1));\n    f = min(f,Torus(pos,SplinePosDir(11.*s),1.,.3));\n    f = min(f,Torus(pos,SplinePosDir(12.*s),.8,.3));\n    f = min(f,Torus(pos,SplinePosDir(13.*s),1.,.1));\n    f = min(f,Torus(pos,SplinePosDir(14.*s),.8,.3));\n    f = min(f,Torus(pos,SplinePosDir(15.*s),1.,.1));\n    f = min(f,Torus(pos,SplinePosDir(16.*s),1.+.025*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(17.*s),1.+.05*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(18.*s),1.+.1*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(19.*s),1.+.2*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(20.*s),1.+.1*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(21.*s),1.+.05*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(22.*s),1.+.025*beat,.3));\n    f = min(f,Torus(pos,SplinePosDir(23.*s),1.+.0*beat,.3));\n    \n    return f;\n}\n\n\nfloat Trace( vec3 start, vec3 dir, float minT, float maxT, float pixelScale )\n{\n    float epsilon = pixelScale*1.;\n    \n    float t = minT;\n    \n    float dist;\n    for ( int i=0; i < 500; i++ ) // this can be really big as long as epsilon is high enough\n    {\n        dist = SDF( start + t*dir );\n        if ( dist < epsilon*t || t > maxT ) return t;\n        t += dist;\n    }\n    \n    if ( dist < 0.1 && t < maxT )\n    {\n        t += dist;\n        float dist2 = SDF( start + t*dir );\n        \n        // try to guess where the surface might be, by extrapolating as if SDF is planar here\n        t += max(0.,dist2*dist/(dist-dist2)); //(dist-dist2)/dist = change in df / distance stepped, so divide DF by this to find distance we should step\n        \n        return t;\n    }\n    \n    return maxT; // todo: maybe return best-guess t when we run out of iterations?\n}\n\n\nvec3 GetNormal( vec3 pos, float sampleSpacing )\n{\n    vec2 d = vec2(-1,1)*sampleSpacing;\n    \n    return normalize(\n        SDF( pos + d.xxx )*d.xxx +\n        SDF( pos + d.yyx )*d.yyx +\n        SDF( pos + d.yxy )*d.yxy +\n        SDF( pos + d.xyy )*d.xyy\n        );\n}\n\n\nvec4 Shade( vec3 pos, vec3 ray, vec3 n )\n{\n    vec4 col = vec4(1,0,0,0);\n\n    //col.rgb = fract(pos);\n\n    vec3 diffuse = vec3(.1)*(n.y*.5+.5);\n\n    vec3 l = normalize( vec3( 2,3,1 ) );\n    diffuse += vec3(1) * max(dot(n,l),0.);\n\n    col.rgb *= diffuse;\n    \n    // reflectivity\n    col.a = pow( 1.+dot(ray,n), 5. );\n    col.a = mix( .01, 1., col.a );\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    const float targetT = 1.;\n    float time = iTime/1.;\n    \n    vec3 camPos = CatmullRom( time );\n    \n    vec3 camK = CatmullRom( time+targetT ) - camPos;\n    \n    if ( iMouse.z > 0. )\n    {\n\t    float a = -.5*6.283*(iMouse.x/iResolution.x-.5);\n        camK.xz = camK.xz*cos(a) + sin(a)*vec2(-1,1)*camK.zx;\n        camK.y += 2.*(iMouse.y/iResolution.y-.5);\n\t}\n    camK = normalize(camK);\n    \n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.y,1.);\n    float pixelScale = ray.z / iResolution.y;\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    float far = 1e10;\n    float t = Trace( camPos, ray, 0., far, pixelScale );\n\n    fragColour.rgb = vec3(.7);\n    if ( t < far )\n    {\n        vec3 pos = camPos + ray*t;\n        \n\t    vec3 n = GetNormal( pos, .001 );\n\n        fragColour.rgba = Shade( pos, ray, n );\n        \n        // reflection\n        vec3 rayr = reflect(ray,n);\n        float tr = Trace( pos, rayr, .01, 128., pixelScale );\n\n        vec3 ref = vec3(.7);\n        if ( tr < 128. )\n        {\n            vec3 posr = pos + rayr*t;\n            ref = Shade( posr, rayr, GetNormal( posr, .001 ) ).rgb;\n        }\n        \n        fragColour.rgb = mix( fragColour.rgb, ref, fragColour.a );\n    }\n\n        \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 397, 397, 1213], [1215, 1215, 1302, 1302, 1464], [1551, 1551, 1574, 1574, 3404], [3407, 3407, 3486, 3486, 4271], [4274, 4274, 4323, 4323, 4540], [4543, 4543, 4585, 4585, 4917], [4920, 4920, 4978, 4978, 6411]], "test": "error"}
{"id": "XdyfR1", "name": "Undah Da Sea", "author": "jgkling", "description": "waow", "tags": ["raymarching", "terrain", "water", "ocean", "godrays", "underwater"], "likes": 7, "viewed": 463, "published": "Public", "date": "1527556761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Various parameters\n#define GOD_RAY_LENGTH 1.1 // higher number = shorter rays\n#define GOD_RAY_FREQUENCY 28.0\n\n// Raymarching\n#define MAX_ITERS 220.0\n#define T_MAX 60.0\n\n#define NUM_OCTAVES 2 // for noise\n\nfloat GodRays(  in vec2 ndc, in vec2 uv) {\n    vec2 godRayOrigin = ndc + vec2(-1.15, -1.25);\n    float rayInputFunc = atan(godRayOrigin.y, godRayOrigin.x) * 0.63661977236; // that's 2/pi\n    float light = (sin(rayInputFunc * GOD_RAY_FREQUENCY + iTime * -2.25) * 0.5 + 0.5);\n    light = 0.5 * (light + (sin(rayInputFunc * 13.0 + iTime) * 0.5 + 0.5));\n    //light *= (sin(rayUVFunc * 8.0 + -iTime * 0.25) * 0.5 + 0.5);\n    light *= pow(clamp(dot(normalize(-godRayOrigin), normalize(ndc - godRayOrigin)), 0.0, 1.0), 2.5);\n    light *= pow(uv.y, GOD_RAY_LENGTH);\n    light = pow(light, 1.75);\n    return light;\n}\n\n// 2D Noise from IQ\nfloat Noise2D( in vec2 x ) {\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat ComputeFBM( in vec2 pos ) {\n    float amplitude = 1.0;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < NUM_OCTAVES; ++i) {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 3.0;\n        pos *= 0.7;\n    }\n    return sum / maxAmp;\n}\n\nfloat SceneMap( in vec3 pos ) {\n    return pos.y - 3.0 * ComputeFBM(pos.xz * 0.2);\n}\n\nvec3 ComputeNormal( in vec3 pos ) {\n    vec2 epsilon = vec2(0.0, 0.001);\n    float mapVal = SceneMap(pos);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - mapVal,\n                            epsilon.y,\n                            SceneMap(pos + epsilon.xxy) - mapVal));\n}\n\n// From: http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nvec3 RaymarchScene( in vec3 origin, in vec3 dir ) {\n    float distance, t, dt;\n    float hitSomething, numIters = 0.0;\n    float lastPosY, lastHeight;\n    vec3 pos;\n    \n    for(t = 0.01; t < T_MAX && numIters < MAX_ITERS; t += dt) {\n        pos = origin + t * dir;\n        distance = SceneMap(pos);\n        \n        if(distance < (0.0001 * t)) {\n            hitSomething = 1.0;\n            break;\n        }\n        \n        numIters += 1.0;\n        dt = 0.05 * t;\n        lastPosY = pos.y;\n        lastHeight = distance + lastPosY;\n    }\n    return vec3(t - dt + dt * (lastHeight - lastPosY) / (pos.y - lastPosY - (distance + pos.y) + lastHeight), hitSomething, numIters);\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin ) {\n    // Compute local camera vectors\n    vec3 refPoint = vec3(origin.x, 10.0, origin.z + 1.0);\n    vec3 camLook = normalize(refPoint - origin);\n    vec3 camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = origin + camLook + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // God rays\n    float godRay = GodRays(ndc, uv);\n    \n    vec3 waterColor = mix(vec3(0.2, 1.5, 0.7), vec3(0.2, 0.4, 0.9) * 0.5, pow(clamp(0.25 * (ndc.x * ndc.x * 0.2 - ndc.y + 1.5), 0.0, 1.0), 0.15));\n    vec3 lightColor = mix(vec3(0.5, 1.0, 0.8), vec3(0.55, 0.55, 0.95) * 0.95, 1.0 - uv.y);\n    vec3 finalColor = waterColor;\n    \n    // Raymarching\n    vec3 rayOrigin = vec3(0.0, 10.0, -1.0);\n    rayOrigin += vec3(-iTime, 0.0, 0.0);\n    vec3 rayDirection = CastRay(ndc, rayOrigin);\n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    if(result.y > 0.0) {\n        vec3 isectPos = rayOrigin + result.x * rayDirection;\n        vec3 normal = ComputeNormal(isectPos);\n        finalColor = vec3(0.5, 0.5, 0.25) * 2.75 * dot(normal, normalize(vec3(1.0, 1.0, 1.0)));\n    }/* else {\n        finalColor = vec4(finalColor, 1.0);\n    }*/ // stuff if we miss\n    \n    // To add:\n    // bubbles? probably screen space aligned\n    // coral/algae/plants\n    // caustics on ground: https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch02.html\n    // better sand texture\n    // try tonemapping again? http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    \n    // Simple distance fog\n    float fogAmount = 1.0 - exp(-result.x * 0.05);\n    finalColor = mix(finalColor, waterColor * 0.8, fogAmount);\n    \n    finalColor = mix(finalColor, lightColor, (godRay + 0.05)/1.05);\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 208, 250, 250, 816], [818, 838, 866, 866, 1310], [1312, 1312, 1345, 1345, 1609], [1611, 1611, 1642, 1642, 1695], [1697, 1697, 1732, 1732, 1978], [1980, 2064, 2115, 2115, 2739], [2741, 2741, 2785, 2821, 3169], [3171, 3171, 3228, 3228, 4764]], "test": "error"}
{"id": "Xs3BWs", "name": "flower formulation", "author": "sergiobase", "description": "flower made using cosine ...", "tags": ["flower"], "likes": 0, "viewed": 61, "published": "Public", "date": "1527134939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tvec2 st = uv-vec2(0.5);\n    st.x*= iResolution.x/iResolution.y;\n    float r = 0.2+0.1*cos(atan(st.y,st.x)*7.);\n    float circle = smoothstep(r,r-0.05,length(st));\n   \n    r = 0.05;\n    st.y+= -0.3;\n    col*=clamp((smoothstep(r,r-0.05,abs(st.x+sin(st.y*3.+7.13)*0.5)))*step(0.5,1.-uv.y)+circle,0.0,1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3BWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 608]], "test": "valid"}
{"id": "Xs3Bzs", "name": " Lens Flare alpha resolume", "author": "captainflo22", "description": "https://www.shadertoy.com/view/Xlc3D2", "tags": ["update"], "likes": 26, "viewed": 1335, "published": "Public API", "date": "1526300772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(vec2 p)\n{\n    float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n return f;   \n}\n\nfloat rnd(float w)\n{\n    float f = fract(sin(w)*1000.);\n return f;   \n}\n\nfloat regShape(vec2 p, int N)\n{\n float f;\n    \n    \nfloat a=atan(p.x,p.y)+.2;\nfloat b=6.28319/float(N);\nf=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n    \n    \n    return f;\n}\nvec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 mouse)\n{\n \t \n    \n    //l is used for making rings.I get the length and pass it through a sinwave\n    //but I also use a pow function. pow function + sin function , from 0 and up, = a pulse, at least\n    //if you return the max of that and 0.0.\n    \n    float l = length(p + mouse*(dist*4.))+size/2.;\n    \n    //l2 is used in the rings as well...somehow...\n    float l2 = length(p + mouse*(dist*4.))+size/3.;\n    \n    ///these are circles, big, rings, and  tiny respectively\n    float c = max(00.01-pow(length(p + mouse*dist), size*1.4), 0.0)*50.;\n    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;\n    float c2 =  max(0.04/pow(length(p-mouse*dist/2. + 0.09)*1., 1.), 0.0)/20.;\n    float s = max(00.01-pow(regShape(p*5. + mouse*dist*5. + 0.9, 6) , 1.), 0.0)*5.;\n    \n   \tcolor = 0.5+0.5*sin(color);\n    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;\n \tvec3 f = c*color ;\n    f += c1*color;\n    \n    f += c2*color;  \n    f +=  s*color;\n    return f-0.01;\n}\n\nfloat sun(vec2 p, vec2 mouse)\n{\n float f;\n    \n    vec2 sunp = p+mouse;\n    float sun = 1.0-length(sunp)*8.;\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    //uv=uv*2.-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 mm = iMouse.xy/iResolution.xy - 0.5;\n    mm.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 circColor = vec3(0.9, 0.2, 0.1);\n    vec3 circColor2 = vec3(0.3, 0.1, 0.5);\n    \n    //now to make the sky not black\n    vec3 color = mix(vec3(0.0, 0.0, 0.00)/1.0, vec3(0.0, 0.0, 0.0), uv.y)*3.-0.52*sin(iTime/0.4)*0.1+0.2;\n    \n    //this calls the function which adds three circle types every time through the loop based on parameters I\n    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more\n    for(float i=0.;i<10.;i++){\n        color += circle(uv, pow(rnd(i*2000.)*1.0, 2.)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, mm);\n    }\n    //get angle and length of the sun (uv - mouse)\n        float a = atan(uv.y-mm.y, uv.x-mm.x);\n    \tfloat l = max(1.0-length(uv-mm)-0.84, 0.0);\n    \n    float bright = 0.1;//+0.1/1/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    //add the sun with the frill things\n    color += max(0.1/pow(length(uv-mm)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    color += max(0.1/pow(length(uv-mm)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    color += (max(bright/pow(length(uv-mm)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n        color*= exp(1.0-length(uv-mm))/5.;\n\tfragColor = vec4(color,0.5);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3Bzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 102], [104, 104, 124, 124, 175], [177, 177, 208, 208, 365], [366, 366, 460, 696, 1428], [1430, 1430, 1461, 1461, 1554], [1556, 1556, 1612, 1612, 3475]], "test": "valid"}
{"id": "Xs3fDj", "name": "VR HMD dead/stuck pixel fixer", "author": "BeRo", "description": "VR HMD display panel dead/stuck pixel fixer, the mode change at each minute ... and do NOT look at it, while it is running! Tested with Firefox. It doesn't work with Edge due to missing working GLES 300 mode here at Shadertoy inside Edge  ", "tags": ["vr", "deadpixel", "stuckpixel"], "likes": 1, "viewed": 667, "published": "Public API", "date": "1526681289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#version 300 es\nvec4 hash44(uvec4 p){\n  \n  uvec4 v = p; \n    \n#if 1\n  // Pre-inter-mixing of all components with all components with a single ChaCha20 cipher round primitive iteration\n  v.x += v.y; v.w ^= v.x; v.w = (v.w << 16u) | (v.w >> 16u);\n  v.z += v.w; v.y ^= v.z; v.y = (v.y << 12u) | (v.y >> 20u); \n  v.x += v.y; v.w ^= v.x; v.w = (v.w << 8u) | (v.w >> 24u);\n  v.z += v.w; v.y ^= v.z; v.y = (v.y << 7u) | (v.y >> 25u); \n#endif\n    \n#if 1\n  // Full avalanche integer (re-)hashing with as far as possible equal bit distribution probability\n  // => http://burtleburtle.net/bob/hash/integer.html  \n  v -= (v << 6u);\n  v ^= (v >> 17u);\n  v -= (v << 9u);\n  v ^= (v << 4u);\n  v -= (v << 3u);\n  v ^= (v << 10u);\n  v ^= (v >> 15u);\n#endif\n    \n#if 1\n  // Post-inter-mixing of all components with all components with a single ChaCha20 cipher round primitive iteration\n  v.x += v.y; v.w ^= v.x; v.w = (v.w << 16u) | (v.w >> 16u);\n  v.z += v.w; v.y ^= v.z; v.y = (v.y << 12u) | (v.y >> 20u); \n  v.x += v.y; v.w ^= v.x; v.w = (v.w << 8u) | (v.w >> 24u);\n  v.z += v.w; v.y ^= v.z; v.y = (v.y << 7u) | (v.y >> 25u); \n#endif\n    \n  return vec4(intBitsToFloat(ivec4(uvec4(((v >> 9u) & uvec4(0x007fffffu)) | uvec4(0x3f800000u))))) - vec4(1.0);\n    \n}      \n\nvec4 doPixel(in vec2 fragCoord){    \n    vec4 c = vec4(0.0);\n    const int HzRate = 30;\n    int f = int(float(iTime * float(HzRate))); \n    vec4 u = hash44(uvec4(uint(f), uint(fragCoord.x), uint(fragCoord.y), 0));\n    int p = (int(iTime) / 60) & 3;    \n    int i = (p == 0) ?\n              ((int(u.x * 8.0) ^ int(u.y * 8.0) ^ int(u.z * 8.0) ^ int(u.w * 8.0)) & 7) :\n              (p == 1) ?\n                ((int(f) % 3) + 2) :\n                (p == 2) ?\n                  (int(f) & 7) :\n                  (int(f) & 1);\n    if(i == 0){        \n      c = vec4(1.0);\n    }else if(i == 1){\n      c = vec4(0.0);\n    }else if(i == 2){\n      c = vec4(1.0, 0.0, 0.0, 1.0);\n    }else if(i == 3){\n      c = vec4(0.0, 1.0, 0.0, 1.0);\n    }else if(i == 4){\n      c = vec4(0.0, 0.0, 1.0, 1.0);\n    }else if(i == 5){\n      c = vec4(1.0, 0.0, 1.0, 1.0);\n    }else if(i == 6){\n      c = vec4(1.0, 1.0, 0.0, 1.0);\n    }else if(i == 7){\n      c = vec4(0.0, 1.0, 1.0, 1.0);\n    }\n    return c; \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = doPixel(fragCoord);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir){\n    fragColor = doPixel(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3fDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 39, 39, 1242], [1250, 1250, 1282, 1282, 2228], [2230, 2230, 2284, 2284, 2322], [2324, 2324, 2415, 2415, 2453]], "test": "valid"}
{"id": "XscBDM", "name": "Gabor Function", "author": "chronos", "description": "Simple adaption of the Gabor filter basis function as presented in the wikipedia article.", "tags": ["filter", "function", "gabor", "signal"], "likes": 1, "viewed": 169, "published": "Public", "date": "1525296197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n// From Wikipedia:\n// https://en.wikipedia.org/wiki/Gabor_filter#Example_implementations\nimport numpy as np\ndef gabor_fn(sigma, theta, Lambda, psi, gamma):\n    sigma_x = sigma\n    sigma_y = float(sigma) / gamma\n\n    # Bounding box\n    nstds = 3 # Number of standard deviation sigma\n    xmax = max(abs(nstds * sigma_x * np.cos(theta)), abs(nstds * sigma_y * np.sin(theta)))\n    xmax = np.ceil(max(1, xmax))\n    ymax = max(abs(nstds * sigma_x * np.sin(theta)), abs(nstds * sigma_y * np.cos(theta)))\n    ymax = np.ceil(max(1, ymax))\n    xmin = -xmax\n    ymin = -ymax\n    (y, x) = np.meshgrid(np.arange(ymin, ymax + 1), np.arange(xmin, xmax + 1))\n\n    # Rotation \n    x_theta = x * np.cos(theta) + y * np.sin(theta)\n    y_theta = -x * np.sin(theta) + y * np.cos(theta)\n\n    gb = np.exp(-.5 * (x_theta ** 2 / sigma_x ** 2 + y_theta ** 2 / sigma_y ** 2)) * np.cos(2 * np.pi / Lambda * x_theta + psi)\n    return gb\n**/\n\n// Directly adapted, unoptimized version\n#define PI 3.14159\nfloat gabor_fn(vec2 uv, float sigma, float theta, float Lambda, float psi, float gamma)\n{\n    float sigma_x = sigma;\n    float sigma_y = sigma / gamma;\n   \n    // \"Bounding Box\"\n    float nstds = 3., xmax, ymax, xmin, ymin;\n    xmax = max(\tabs(nstds * sigma_x * cos(theta)),\n        \t\tabs(nstds * sigma_y * sin(theta)));\n    xmax = ceil(max(1., xmax));\n    ymax = max(\tabs(nstds * sigma_x * sin(theta)),\n        \t\tabs(nstds * sigma_y * cos(theta)));\n    ymax = ceil(max(1., ymax));\n    xmin = -xmax;\n    ymin = -ymax;\n    \n    float x = (xmax - xmin) * uv.x + xmin;\n    float y = (ymax - ymin) * uv.y + ymin;\n    \n    // Rotation\n    float x_theta = x * cos(theta) + y * sin(theta);\n    float y_theta = -x * sin(theta) + y * cos(theta);\n    \n    float gb = \n         exp( -.5 * \n             (pow(x_theta / sigma_x, 2.) + \n              pow(y_theta / sigma_y, 2.))\n        \t) *\n            cos(2. * PI / Lambda * x_theta + psi);\n    \n    return gb;\n}\n\n// Somewhat compactified Gabor function\nfloat gabor_fn2(vec2 uv, float sigma, float theta, float Lambda, float psi, float gamma)\n{\n    vec2 sigma_xy = vec2(sigma, sigma / gamma);\n   \n    vec2 trig = vec2(cos(theta), sin(theta));\n    \n    const float nstds = 5.; // \"Bounding Box\"\n    vec4 bounds = abs(nstds * sigma_xy.xxyy * trig.xyyx);\n    vec2 max_bounds = ceil(max(vec2(1),max(bounds.xy, bounds.zw)));\n    \n    vec2 xy = 2. * max_bounds * uv - max_bounds;\n    vec2 xy_theta = mat2(trig.x, -trig.y, trig.y, trig.x) * xy; // Rotate by theta\n    \n    return\n         exp( -.5 * dot(pow(xy_theta / sigma_xy, vec2(2)), vec2(1))) *  // 2D Gaussian\n            cos(2. * PI / Lambda * xy_theta.x + psi);\t\t\t\t\t// Cosine \n}\n\n// From: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.28.6586&rep=rep1&type=pdf\n// Omega = color spiral rotation frequency\n// Phi   = color spiral rotation phase\n// Assumes 0 <= t <= 1\nvec3 pseudocolor(float t, float omega, float phi)\n{\n    const float root3 = sqrt(3.);\n\tmat3 rot = mat3(1. + root3, 1. - root3, -2., // Rotate to spiral around grayscale axis\n                    1. - root3, 1. + root3, -2.,\n                    2         , 2         ,  2);\n    float r = sqrt(1.5) * t * (1.-t); // spiral radius\n    vec3 spiral = vec3(r * sin(omega * t + phi),\n                       r * cos(omega * t + phi),\n                       root3 * t);\n\treturn rot * spiral / (2. * root3);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center and fix aspect ratio\n    vec2 uv = (fragCoord - .5 * vec2(iResolution.x - iResolution.y, 0.)) /iResolution.y;\n\n    // Gabor function parameters\n    float             // Attempt at interpreting values from formulas :)\n        sigma   = 1., // Standard Deviation\n        theta   = 1., // Rotation\n        Lambda  = .5, // Oscilation inverse frequency\n        psi     = 1., // Oscilation phase\n        gamma   = 1.; // Standard deviation // falloff \"aspect ratio\"\n    \n    // Animate parameters\n    theta *= iTime / 4.;\n    sigma *= 4. * abs(iMouse.x/iResolution.x - .5);\n    Lambda *= mix(2., .1, iMouse.y/iResolution.y);\n    psi   *= 5. * iTime;\n    gamma *= mix(.5, 2., iMouse.x/iResolution.x);\n    \n    // Gabor function\n    float gb = gabor_fn2(uv, sigma, theta, Lambda, psi, gamma);\n\n    // Color parameters\n    float omega = 5.5; // Pseudocolor hue frequency\n    float phi = 2.1;   // Pseudocolor hue phase\n    const float scale = exp(0.);\n    vec3 col = pseudocolor(.5*(gb / scale + 1.), omega, phi);\n    \n    // Show only unit square area\n    col *=  step(0., uv.y) * step(0., 1.-uv.y) * step(0., uv.x) * step(0., 1.-uv.x);\n    \n    fragColor = vec4(col,1.0); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[917, 977, 1066, 1066, 1927], [1929, 1969, 2059, 2059, 2645], [2647, 2844, 2895, 2895, 3344], [3346, 3346, 3403, 3438, 4605]], "test": "valid"}
{"id": "XscBRS", "name": "Default RGB color visualization", "author": "ivanlesko", "description": "Simple shader that displays what the hell is going on with that default project.  For the noobs (like myself).", "tags": ["beginner"], "likes": 1, "viewed": 64, "published": "Public", "date": "1525554050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 color = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    color = mix(color, vec3(1., 0., 0.), plot(uv, color.r));\n    color = mix(color, vec3(0., 1., 0.), plot(uv, color.g));\n    color = mix(color, vec3(0., 0., 1.), plot(uv, color.b));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 81, 81, 172], [174, 174, 231, 281, 660]], "test": "valid"}
{"id": "XscBWs", "name": "My first 'LOVE' shader", "author": "indere", "description": "a default background color and a function of  cardioid", "tags": ["2d"], "likes": 1, "viewed": 981, "published": "Public API", "date": "1527137829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat HeartFunction(float x, float y){\n\treturn 5.0 * x * x - 6.0 * abs(x) * y + 5.0 * y * y;\n}\n\nbool TestFunction(float x, float y){\n\tbool judge = false;\n    if(x > 0.0f && y > 0.0f)\n        judge = true;\n    return judge;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 CenterOfScreen = iResolution.xy / 2.0;\n    float scale = abs(20.0 * sin(iTime));\n    if(scale == 0.0f)\n        scale = 0.0001f;\n    vec2 position = (fragCoord.xy - CenterOfScreen) / scale;\n    vec2 vector = (fragCoord.xy - CenterOfScreen) / min(iResolution.x, iResolution.y);\n    \n    vec3 bcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n   // if(TestFunction(position.x, position.y))\n      //  bcol = vec3(1.0,0.0,0.0);\n    \n    if(HeartFunction(position.x, position.y) <= 128.0f)\n        bcol = vec3(1.0, 0.0,0.0)*(1.0 - length(vector));\n    \n   \tfragColor = vec4(bcol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 95], [97, 97, 133, 133, 225], [227, 227, 284, 334, 967]], "test": "valid"}
{"id": "XscBzl", "name": "sync circles", "author": "Plento", "description": "Just messing around. Learning coordinates and such. I love watching the circles sync up. ", "tags": ["circle", "learning"], "likes": 6, "viewed": 157, "published": "Public", "date": "1526280076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   float mx = fragCoord.x / iMouse.x;\n   float my = fragCoord.y / iMouse.y;\n    \n    vec2 uv = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tuv = 2.0 * uv.xy / iResolution.y;\n    \n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(0.5, 0.5, 1.0);\n\tvec3 color2 = vec3(1.00, 0.0, 0.0);\n\tvec3 color3 = vec3(0.0, 0.0, 1.0);\n\n\tvec3 pixel = backgroundColor;\n    \n    if( mod(uv.x, 0.1) < 2.0 / iResolution.y ) pixel = color1;\n    if( mod(uv.y, 0.1) < 2.0 / iResolution.y ) pixel = color1;\n  \n    vec2 center;\n    vec2 d;\n    \n    float speed = 4.0;\n    \n    for(float i = 0.0;i < 1.0;i += 0.05)\n    {\n        center = vec2(sin(iTime * i * speed) * 0.5, \n                      cos(iTime * i * speed) * 0.5 );\n        d = uv - center;\n        \n\t\tif( length(d) < 0.09) \n        {\n\t\t    pixel = vec3(6.0 / i * .05 , 0.0, 0.0);\n            \n\t\t}\n    }\n    \n   \n\tfragColor = vec4(pixel, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 61, 61, 955]], "test": "valid"}
{"id": "XscfW2", "name": "wrecking Lipschitz", "author": "MacSlow", "description": "Messing around on the weekend... very heavy still, but I like the demoscene-ish look. It started with wanting to play around with 4th order Chmutov Banchoff implicit surfaces... and this came out at the end. Some artefacts remain.", "tags": ["3d", "raymarching", "warping", "distortion", "shadows", "reflections"], "likes": 5, "viewed": 556, "published": "Public API", "date": "1526770120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"wrecking Lipschitz\" - going overboard with domain-distortions \n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 96;\nconst float EPSILON = .0001;\nconst float STEP_SIZE = .4;\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float cy = cos (rad * p.y);\n    float sy = sin (rad * p.y);\n    mat2  my = mat2 (cy, -sy, sy, cy);\n    float cx = cos (rad * p.x);\n    float sx = sin (rad * p.x);\n    mat2  mx = mat2 (cx, -sx, sx, cx);\n    p = mix (vec3 (mx* p.zx, p.y), vec3 (my * p.xy, p.z), .15*cos (p.x));\n\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 6. + 4.*cos (2.*iTime);\n\tresult = .375 * sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n\n    return result;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float radius)\n{\n\treturn length (p) - radius;\n}\n\nfloat sdPlane (in vec3 p, in float height)\n{\n\treturn length (p.y - height);\n}\n\nfloat udBox (in vec3 p, in vec3 size, in float radius)\n{\n\treturn length (max (abs (p) - size, .0)) - radius;\n}\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n\tfloat s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat scene (in vec3 p)\n{\n    float ground = sdPlane (p, -2.);\n\n    vec2 offset = .5 * vec2 (cos (6.28+iTime), sin (6.28+iTime));\n    vec3 p2 = (p + vec3 (-offset.x, offset.y, -1.25));\n    opBend (p2, 45. * cos (.25*iTime));\n    p2.zx *= r2d (50.*iTime);\n    p2.xy *= r2d (-75.*iTime);\n    float dt = sdSphere (p2, .5);\n    float dp = displace (p2);\n    float ball2 = dt + dp;\n\n    p.xz *= r2d (20.*iTime);\n    p.zy *= r2d (-30.*iTime);\n    float x = p.x*.125;\n    float y = p.y*.125;\n    float z = p.z*.125;\n    float fourthOrderChmutovBanchoffSurface = 3. + 8.*(x*x*x*x + y*y*y*y + z*z*z*z) - 8.*(x*x + y*y + z*z);\n    fourthOrderChmutovBanchoffSurface *= .75;\n    ground = opCombine (ground, ball2, 2.5);\n    fourthOrderChmutovBanchoffSurface = opCombine (fourthOrderChmutovBanchoffSurface, ground, .5);\n\n    return fourthOrderChmutovBanchoffSurface;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    float d = scene (p);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd)\n{\n    float d = .0;\n    float t = .0;\n    for (int iter = 0; iter < MAX_ITER; ++iter) {\n        t = scene (ro + d * rd);\n        if (abs(t) < EPSILON*(1. + .125*t)) break;\n        d += t*STEP_SIZE;\n    }\n\n    return d;\n}\n\nfloat shadow (in vec3 p, in vec3 lpos)\n{\n    float distanceToLight = distance (lpos, p);\n    vec3 n = normal (p, distanceToLight*EPSILON);\n    vec3 ldir = normalize (lpos - p);\n    float distanceToObject = raymarch (p + .01 * n, ldir);\n    bool isShadowed = distanceToObject < distanceToLight;\n\n\treturn isShadowed ? .5 : 1.;\n}\n\nvec3 shade (in vec3 p, in vec3 n)\n{\n    vec3 lightPosition1 = vec3 (1.);\n    lightPosition1.xz *= r2d (60.*iTime);\n    vec3 l1 = normalize (lightPosition1 - p);\n    float d1 = distance (p, lightPosition1);\n    float lightIntensity1 = 5.;\n\n \tvec3 lightPosition2 = vec3 (1., 1.*cos (2.*iTime), 1.);\n    lightPosition2.xz *= r2d (20.*iTime);\n    vec3 l2 = normalize (lightPosition2 - p);\n    float d2 = distance (p, lightPosition2);\n    float lightIntensity2 = 3.;\n\n    vec3 diffuseColor1 = vec3 (.9, .8, .7);\n    vec3 diffuseColor2 = vec3 (.7, .8, .9);\n\n    vec3 finalColor1 = max (dot (n, l1), .0) * diffuseColor1 * lightIntensity1 / (d1*d1);\n    vec3 finalColor2 = max (dot (n, l2), .0) * diffuseColor2 * lightIntensity2 / (d2*d2);\n\n    return shadow (p, lightPosition1) * finalColor1 +\n           shadow (p, lightPosition2) * finalColor2;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalize and aspect-correct\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // create viewray\n    vec3 ro = vec3 (.0, .0, -2.);\n    vec3 rd = normalize (vec3 (uv, .0) - ro);\n\n    // primary/view ray\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.01);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, d*EPSILON);\n    vec3 col = shade (p, n);\n\n\t// secondary/reflection ray\n    vec3 refr = normalize (reflect (rd, n));\n    float refd = raymarch (p + .001*n, refr);\n    vec3 refp = p + refd * refr;\n    vec3 refn = normal (refp, EPSILON);\n    vec3 refc = shade (refp, refn);\n    col += .05*refc;\n\n    // fog, tint, tone-map, gamma-correct\n    col *= fog;\n    col *= vec3 (.95, .8, .75);\n    col = col / (1. + col);\n    col = sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscfW2.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 1030, 1070, 1070, 1399], [1401, 1401, 1426, 1426, 1593], [1595, 1595, 1651, 1651, 1755], [1757, 1757, 1802, 1802, 1833], [1835, 1835, 1879, 1879, 1912], [1914, 1914, 1970, 1970, 2024], [2026, 2026, 2054, 2054, 2169], [2171, 2171, 2196, 2196, 3026], [3028, 3028, 3071, 3071, 3278], [3280, 3280, 3321, 3321, 3540], [3542, 3542, 3582, 3582, 3868], [3870, 3870, 3905, 3905, 4711], [4713, 4713, 4769, 4805, 5626]], "test": "valid"}
{"id": "XscfzB", "name": "zebrazebra", "author": "lennyjpg", "description": "sdgsfd", "tags": ["sdfg"], "likes": 20, "viewed": 4937, "published": "Public API", "date": "1525640322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float t = iTime*.004;\n    vec2 center = vec2(iMouse/1000.0);\n    float g = 3.1;\n    center.x+=sin(uv.y*g+t+iTime);\n    center.y+=cos(uv.x*g+t);\n    float d = distance(uv,center);\n\tfloat k = -sin(d*6.283*10. - t);\n\tfloat e = smoothstep(0., fwidth(k)*1.5, k);\n\tfragColor = vec4(sqrt(max(e, 0.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 397]], "test": "valid"}
{"id": "XscfzX", "name": "SickBow's Spiral", "author": "sickbow", "description": "spiral", "tags": ["spiral"], "likes": 6, "viewed": 156, "published": "Public", "date": "1526252354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592653589\n\nvec3 drawSpiral(vec2 uv, vec3 col, float thickness){\n\t   \n    //float lim = 12.*pi;\n    float growth = sqrt(2.);\n    float theta = ( pi*log(length(uv)) )/(2.*log(growth) ); //angle of spiral for length of UV vector with spiral being r(theta)\n    vec2 spiral = pow(growth,2./pi * theta)*vec2(cos(theta),sin(theta));\n    \n    if( abs(dot(normalize(uv),normalize(spiral))-1.) < 1.195 && abs(length(uv)-length(spiral)) < thickness  ){\n     col = vec3(1.)*smoothstep(/*(sin(iTime)+1.1)/2.*/1.,0., abs(dot(normalize(uv),normalize(spiral))-1.) );  \n    }\n    \n    col*=vec3((sin(iTime)+1.)/3.+.5,(cos(iTime)+1.)/3.+.5,(cos(iTime)+1.)/3.+.5);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord-iResolution.xy*.5)/iResolution.y;\n\tuv/= fract(iTime) +.325;//fract(iTime)/.5+.675;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n\n    //col = shape(uv, col, vec2(0.45, 0.25), 1., vec3(1.),  .0125);\n    col = drawSpiral(uv, col, .45);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XscfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 79, 110, 684], [686, 686, 743, 793, 1128]], "test": "valid"}
{"id": "XsdBDf", "name": "Basic 3D-to-1D Hash", "author": "TEttinger", "description": "It's yet another hashing function, this one based on the x,y position of a fragment and the time, producing a float used as a brightness value. Behavior here may depend on hardware precision.", "tags": ["hash"], "likes": 2, "viewed": 537, "published": "Public API", "date": "1527035389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 license, do what thou wilt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 uv = mod((vec3((fragCoord.xy / iResolution.xy), iTime) * 11035.15245)\n                  // these are based off a number I had good results with as an increment with\n                  // 64-bit integer CPU hashing, 0x369DEA0F31A53F85, and its powers modulo 64 bits\n                  + vec3(393555.9000370003845, -55865.4634555294951, 782941.5577042901757),\n                  96.9875);\n    float h = fract(dot(uv + uv.yzx + uv.zxy, fract(uv * uv)));\n// to generate grayscale:\n    fragColor = vec4(h, h, h, 1.0);\n// to generate color:\n//    float r = h;\n//    float g = fract(h * 78294.15577042901757);\n//    float b = fract(h * 258.654634555294951);\n//    fragColor = vec4(r, g, b, 1.0);\n}\n\n// below has occasional pure-black frames when any component of uv is 0.0 .\n//    float h = fract(dot((uv * uv.yzx * uv.zxy), fract(uv * uv)));\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdBDf.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 35, 92, 92, 786]], "test": "valid"}
{"id": "XsdBRj", "name": "Spiral of Spirals", "author": "KilledByAPixel", "description": "Experiment with something like a Vogel spiral. Can produce some cool spiral patterns and mess with your vision after a while. Really interesting to watch how it continues to develop over time.\n\nmouse.x = skip ahead\nmouse.y = zoom", "tags": ["spiral", "sunflower", "vogel"], "likes": 22, "viewed": 7349, "published": "Public API", "date": "1526176529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Spiral of Spirals - Copyright 2018 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float pi = 3.14159265359;\n\nvec3 hsv2rgb(vec3 c)\n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\nvec3 GetSpiralColor(float a, float i, float t)\n{\n    \n    // fixed size\n    //t *= 1.0 - 0.9*mousePos.w;\n    //a *= 1.0 + mousePos.w*(floor(i)+p);\n    \n    a += 2.0*pi*floor(i);\n   \n    // apply color\n    float h = a;\n    h *= 1.003*t;\n    //h *= 0.1*(floor(i)+p);\n    h = 0.5*(sin(h) + 1.0);\n    h = pow(h, 3.0);\n    h += 1.222*t + 0.4;\n    \n    float s = a;\n    s *= 1.01*t;\n    s = 0.5*(sin(s) + 1.0);\n    s = pow(s, 2.0);\n    \n    float v = a;\n    v *= t;\n    v = sin(v);\n    v = 0.5*(v + 1.0);\n    v = pow(v, 3.0);\n    //v *= pow(sin(fract(i)*pi), 0.4);\n    \n    return vec3(h, s, v);\n}       \n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv -= iResolution.xy / 2.0;\n    uv /= iResolution.x;\n   \n    vec4 mousePos = (iMouse.xyzw / iResolution.xyxy);\n \tuv *= 40.0;\n    if (mousePos.y > 0.0)\n    \tuv *= 4.0 * mousePos.y;\n    \n    float a = atan(uv.y, uv.x);\n    float d = length(uv);\n    \n    // apply slight pow so center is smaller\n    d = pow(10.0*d, 0.7);\n    \n    // make spiral\n    float i = d;\n    i -= a/(2.0*pi) + 0.5;\n    \n    // change over time\n    float t = .05*(iTime + 400.0*mousePos.x);\n    \n    vec3 c1 = hsv2rgb(GetSpiralColor(a, i, t));\n    vec3 c2 = hsv2rgb(GetSpiralColor(a, i+1.0, t));\n    \n    float p = fract(i);\n    vec3 c3 = mix(c1, c2, p);\n    \n\tfragColor = vec4(c3, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdBRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 337, 359, 359, 499], [501, 501, 549, 647, 1092], [1109, 1109, 1166, 1166, 1856]], "test": "valid"}
{"id": "XsdBW2", "name": "Koch Snowflake 3D", "author": "BenDrews", "description": "An attempt to raymarch a 3D extension of the Koch snowflake fractal.", "tags": ["fractal", "kochsnowflake"], "likes": 4, "viewed": 160, "published": "Public", "date": "1526861156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Ben Drews\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// 3D extenstion of Koch snowflake to tetrahedra.\n//\n// Raymarching skeleton taken from iq's shader \"Apollonian\"\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nfloat longTime = 20.0;\nvec3 far = vec3(10.0);\nfloat maxIters = 5.0;\nint iters = 0;\nfloat height = 1.0;\n\nvec3 orb;\nvec3 orb2;\nvec3 lastPt(vec3 p1, vec3 p2, vec3 p3, float scale) {\n    float l = length(p2 - p1);\n    vec3 n = normalize(cross(p2-p1,p3-p1));\n    return (0.6666666667 * ((p1 + p2)/2.0f - p3)) + p3 + (n*l*0.81649658092*scale);\n}\n\nfloat rayTriangle(vec3 P, vec3 w, inout vec3 n, vec3 v1, vec3 v2, vec3 v3){\n    //Edge vectors\n    vec3 e1 = v2-v1;\n    vec3 e2 = v3-v1;\n    \n    n = normalize(cross(e1, e2));\n    \n    vec3 q = cross(w, e2);\n    float a = dot(e1, q);\n    \n    vec3 s = (P - v1) / a;\n    vec3 r = cross(s, e1);\n    \n    float b0 = dot(s, q);\n    float b1 = dot(r, w);\n    float b2 = 1.0 - b0 - b1;\n    if ((b0 >= 0.0) && (b1 >= 0.0) && (b2 >= 0.0)) return dot(e2, r);\n    return longTime;\n    \n}\n\nfloat rayTetra(vec3 P, vec3 w, inout vec3 n, vec3 v1, vec3 v2, vec3 v3, vec3 v4){\n\tfloat t = rayTriangle(P, w, n, v1, v2, v3);\n    vec3 n1;\n    float t1 = rayTriangle(P, w, n1, v1, v3, v4);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v2, v4, v3);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v1, v4, v2);\n    if(t1 < t) { t = t1; n = n1; }\n    return t;\n}\n\nvoid chooseTetra(vec3 P, vec3 w, inout vec3 p1, inout vec3 p2, inout vec3 p3, inout vec3 p4, vec3 p5, vec3 p6, vec3 p7, vec3 p8, inout float t, inout vec3 n, vec3 col, inout float next) {\n\tvec3 n1;\n    float t2 = rayTetra(P, w, n1, p5, p6, p7, p8);\n    if( t2 < t) {\n        t = t2;\n        n = n1;\n        p1 = p5;\n        p2 = p6;\n        p3 = p7;\n        p4 = p8;\n        orb = col;\n    }\n    if( t2 < next && t2 > 0.0) {\n    \tnext = t2;\n    }\n}\n\nvec3 o1 = vec3(0.0, 0.0, 0.0);\nvec3 o2 = vec3(1.0, 0.0, 0.0);\nvec3 o3 = vec3(0.5, 0.86602540378, 0.0);\nvec3 o4 = vec3(0.5, 0.28867513459, 0.81649658092);\n\n    \nfloat map( vec3 P, vec3 w, float s, inout vec3 n, inout int level)\n{\n    orb = vec3(0.0);\n    orb2 = vec3(0.0);\n    vec3 p1 = far;\n    vec3 p2 = far;\n    vec3 p3 = far;\n    vec3 p4 = far;\n    \n    float t = longTime;\n    float next = t;\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o1, 2.0*o2, 2.0*o3, 2.0*lastPt(o3, o2, o1, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,1.0), next);\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o2, 2.0*o4, 2.0*o3, 2.0*lastPt(o3, o4, o2, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o3, 2.0*o4, 2.0*o1, 2.0*lastPt(o1, o4, o3, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o2, 2.0*o1, 2.0*o4, 2.0*lastPt(o2, o4, o1, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,0.0,1.0), next);\n\torb2 += orb;    \n                \n    vec3 v1 = p1;\n    vec3 v2 = p2;\n    vec3 v3 = p3;\n    vec3 v4 = (p1 + p2)/2.0;\n    vec3 v5 = (p2 + p3)/2.0;\n    vec3 v6 = (p1 + p3)/2.0;\n    vec3 v7 = lastPt(v4, v6, v5, 1.0);\n  \t\n    if(t > 0.0) {\n    \tlevel = -1;\n        return t;\n    }\n    for(int i=0; i <iters; i++) {\n        t = next;\n        chooseTetra(P, w, p1, p2, p3, p4, v4, v6, v1, lastPt(v1, v6, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v5, v3, v6, lastPt(v6, v3, v5, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,1.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v2, v5, v4, lastPt(v4, v5, v2, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v4, v7, v6, lastPt(v6, v7, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v5, v6, v7, lastPt(v7, v6, v5, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v4, v5, v7, lastPt(v7, v5, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,0.0), next);\n        orb2 += orb;\n        v1 = p1;\n        v2 = p2;\n        v3 = p3;\n        v4 = (p1 + p2)/2.0;\n        v5 = (p2 + p3)/2.0;\n        v6 = (p1 + p3)/2.0;\n        v7 = lastPt(v4, v6, v5, 1.0);\n        if(t > 0.0) {\n        \tlevel = i;    \n            return t;\n        }\n    }\n    t = next - 0.01;\n    \n    //For anim\n    v7 = lastPt(v4, v6, v5, height);\n    orb2 -= orb;\n    orb2 += orb*height;\n    vec3 n1;\n    float t1 = rayTriangle(P, w, n1, v1, v6, v4);\n    if(t1 < t) {t = t1; n = n1;}\n    t1 = rayTriangle(P, w, n1, v6, v3, v5);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v5, v2, v4);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v4, v6, v7);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v7, v6, v5);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v7, v5, v4);\n    if(t1 < t) { t = t1; n = n1; }\n    level = iters;\n\treturn t;\n}\n\n\n//Ray marching\nfloat trace( in vec3 ro, in vec3 rd, float s, inout vec3 n)\n{\n    int count = max(8, 2*iters);\n\tfloat maxd = longTime;\n    float t = 0.01;\n    int level = 0;\n    for( int i=0; i<count; i++)\n    {\n\t    float precis = 0.001 * t;\n\t    float h = map( ro+rd*t, rd, s, n, level);\n        if((h < precis && level == iters) || t>maxd ) break;\n        t += max(h, 0.01);\n    }\n\n    if( t>maxd) t=-1.0;\n    return t;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float t = trace( ro, rd, anim, n);\n    if( t>0.0 )\n    {\n        vec3 tra = orb2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = n;\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(1.0,1.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.0,0.0), clamp(tra.x,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,1.0,0.0), clamp(tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,0.0,1.0), clamp(tra.z,0.0,1.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = maxIters * (1.0 + cos(0.2*iTime));\n    iters = int(anim);\n    height = fract(anim);\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        // camera\n        vec2 mo = iMouse.xy/iResolution.xy;\n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA); \n\tfragColor = vec4( tot, 1.0 );\t\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdBW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[229, 433, 486, 486, 647], [649, 649, 724, 743, 1126], [1128, 1128, 1209, 1209, 1526], [1528, 1528, 1715, 1715, 1976], [2138, 2138, 2206, 2206, 4982], [4985, 5000, 5061, 5061, 5408], [5410, 5410, 5464, 5478, 6503], [6505, 6505, 6557, 6557, 6734], [6736, 6736, 6793, 6793, 7608]], "test": "valid"}
{"id": "XsdfDH", "name": "Flower_0", "author": "balkhan", "description": "deforming a grid of spheres with a distance field", "tags": ["raymarching"], "likes": 17, "viewed": 561, "published": "Public API", "date": "1526153440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// bgd color\nvec3\th; \t\t\t// volumetric light\nvec3\trc;         // light color\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t40.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    h*=0.;\n    rc = vec3(\n        abs(sin(iTime*.25+0.00) )\n   \t\t,\n        abs(sin(iTime*.25+1.04) )\n        ,\n        abs(sin(iTime*.30+2.08) )\n    );\n    vec2\tinter = (march(pos, dir));\n    ret_col = vec3(.90, .82, .70);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tscene(vec3 p)\n{  \n    float\tmind = 1e5;\n    float\ttoris = 1e5;\n    p.z += -37.;\n    rotate(p.xz, 1.57-.035*iTime );\n    rotate(p.yz, 1.57-.05*iTime );\n    vec2 q;\n\n    q = vec2( length(p.xz)-5., p.y );\n    rotate(q, iTime*3.0*.125+1.*cos(2.0*atan(p.x, p.z)+15.*atan(q.x, q.y)-iTime*1.*.0)*3.14/12. );\n\n    q.y = max(abs(q.x), abs(q.y) )-3.;\n    q.x = max(abs(q.x), abs(q.y) )-3.;\n\n    toris = mylength(q)-.125;\n    \n    mind = mylength(p.xyz)-10.;\n    p.xyz = fract(p.xyz*2.)-.5;\n    mind = max(mind, (length(p.xyz)+.0+toris*.5-.5+.0*.1250025*(1./max(toris*toris + .25, .05)) ) );\n    mind = abs(mind)+.005;\n\n    h += (1.5-rc)*1./max(.01, toris*toris+ 2.25);\n    h += vec3(.5, .1, .1)*1./max(.01, toris*toris*10.+.25);\n    h += vec3(.92, .27,.1)*1./max(.01, mind*mind*40. + .2505101);\n    \n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max(abs(p.x), abs(p.y));\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max(max(abs(p.x), abs(p.y)), abs(p.z));\n\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsdfDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[451, 649, 692, 692, 1181], [1183, 1254, 1287, 1287, 1418], [1420, 1443, 1464, 1464, 2259], [2261, 2261, 2293, 2293, 2704], [2706, 2720, 2744, 2744, 2815], [2817, 2817, 2841, 2841, 2923], [2925, 2925, 2965, 2965, 3040], [3042, 3042, 3070, 3070, 3178], [3180, 3180, 3202, 3202, 3408], [3410, 3410, 3460, 3460, 3723]], "test": "error"}
{"id": "Xsdfz2", "name": "Lines, Cube, Triangle", "author": "kekwizard", "description": "This is just some hacky way to draw 2D-Primitives like lines and circles.\n", "tags": ["2d", "triangle", "cube", "line", "lines", "circle", "primitives", "drawing"], "likes": 3, "viewed": 359, "published": "Public API", "date": "1525972006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is just some hacky way to draw 2D-Primitives like lines and circles.\n\n*/\n\nfloat TWO_PI = 6.28318531;\nvec3 lineColor = vec3(1.0, 1.0, 1.0);\nvec3 background = vec3(0.23, 0.23, 0.23);\n\n// Helper for drawing a line\nfloat lineDistance(vec2 start, vec2 end, vec2 p) {\n  float l2 = pow(distance(start, end), 2.0);\n  if (l2 == 0.0) return distance(p, start);\n  float t = max(0., min(1., dot(p - start, end - start) / l2));\n  vec2 projection = start + t * (end - start);\n  return distance(p, projection);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// Helper for Circle\nfloat circleDistance(vec2 center, vec2 p, float radius) {\n    vec2 n = center + radius * normalize(p - center);\n\treturn distance(p, n);\n}\n\nfloat shade(float x, float t) {\n    return pow(1. - (x / t), 1.25);    \n}\n\n\n// Draws a circle ;)\nfloat circle(vec2 center, vec2 p, float radius, float thickness) {\n    float d = circleDistance(center, p, radius);\n    if(d < thickness) {\n       return shade(d, thickness);    \n    } else {\n\t\treturn 0.0;\n    }\n}\n\n// Draw a line from start to end\nfloat line(vec2 start, vec2 end, vec2 p, float thickness) {\n    float d = lineDistance(start, end, p);\n    if(d < thickness) {\n       return shade(d, thickness);    \n    } else {\n\t\treturn 0.0;\n    }\n}\n\nfloat cube(vec3 pos, vec2 uv, float size, float thickness) {\n        \n    const int nverts = 8;\n\tvec3 verts[nverts] = vec3[]( \n      \t\t\t\t\t\t\tvec3( -0.5, -0.5, -0.5 ),\n                                vec3( 0.5, -0.5, -0.5 ),\n                                vec3( -0.5, -0.5, 0.5 ),\n                                vec3( 0.5, -0.5, 0.5 ),\n            \t\t\t\t\tvec3( -0.5, 0.5, -0.5 ),\n                                vec3( 0.5, 0.5, -0.5 ),\n                                vec3( -0.5, 0.5, 0.5 ),\n                                vec3( 0.5, 0.5, 0.5 )\n                              );\n   \n    for(int i = 0; i < nverts; i++) {\n        mat4 a = rotationMatrix(vec3(1.0, 0.0, 0.0), iTime);\n        mat4 b = rotationMatrix(vec3(0.0, 1.0, 1.0), iTime * 1.2);\n    \tverts[i] = (a * b * vec4((verts[i] * size) + pos, 1.0)).xyz;\n    }\n        \n        \n\tfloat m = 0.;\n    \n\tm = max(m, line(verts[0].xy, verts[1].xy, uv, thickness));\n\tm = max(m, line(verts[0].xy, verts[2].xy, uv, thickness));\n\tm = max(m, line(verts[2].xy, verts[3].xy, uv, thickness));\n\tm = max(m, line(verts[3].xy, verts[1].xy, uv, thickness));\n    \n\tm = max(m, line(verts[4].xy, verts[5].xy, uv, thickness));\n\tm = max(m, line(verts[4].xy, verts[6].xy, uv, thickness));\n\tm = max(m, line(verts[6].xy, verts[7].xy, uv, thickness));\n\tm = max(m, line(verts[7].xy, verts[5].xy, uv, thickness));\n    \n\tm = max(m, line(verts[4].xy, verts[0].xy, uv, thickness));\n\tm = max(m, line(verts[5].xy, verts[1].xy, uv, thickness));\n\tm = max(m, line(verts[7].xy, verts[3].xy, uv, thickness));\n\tm = max(m, line(verts[6].xy, verts[2].xy, uv, thickness));\n\n    \n    return m;\n}\n\nfloat triangle(vec3 pos, vec2 uv, float radius, float thickness) {\n\t\n    float m = 0.;\n    const int dotN = 3;\n    const float dotNF = float(dotN);\n    vec2 dots[dotN];\n    float a = sin(iTime* 0.08) * 3.1 + 0.5;\n    for(int i = 0; i < dotN; i++) {\n    \tdots[i] = vec2( cos((float(i) + a) * (TWO_PI / dotNF)) * radius, sin((float(i) + a) * (TWO_PI / dotNF)) * radius);\n    }\n    \n    for(int i = 0; i < dotN; i++) {\n        int k = (i + 1) % dotN;\n        m = max(m, line(dots[i], dots[k], uv, thickness));\n    }\n    \n    \n    return m;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / (iResolution.y);\n    \n    float r = 0.35;\n    vec3 col = background;\n    float m = 0.;\n    \n    float gThickness = 0.0075;\n    \n    // Draw a circle\n    m = max(m, circle(vec2(0.0, 0.0), uv, r, gThickness));\n    \n    // Draw a cube\n    m = max(m, cube(vec3(0.0), uv, 0.1, gThickness));\n    \n    // Draw a triangle\n\tm = max(m, triangle(vec3(0.0), uv, r, gThickness));\n    \n    \n\n    \n    float k = pow(1. - m, 0.275);\n    col = mix(background, lineColor, m);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsdfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 220, 270, 270, 506], [508, 508, 553, 553, 1181], [1184, 1205, 1262, 1262, 1342], [1344, 1344, 1375, 1375, 1417], [1420, 1441, 1507, 1507, 1654], [1656, 1689, 1748, 1748, 1889], [1891, 1891, 1951, 1951, 3499], [3501, 3501, 3567, 3567, 4044], [4047, 4047, 4102, 4102, 4649]], "test": "error"}
{"id": "XsGBzW", "name": "2D Symbol Lightsweep Highlighter", "author": "Sleicreider", "description": "Shader for highlighting 2D symbols in a simple game.\nGive a nice detailed touch to the game as an simple effect.\n\nShader avoids lightsweep texture which could've been used to simulate the highlight\n\nIn action:\nhttps://puu.sh/ABhfJ/9f56d9289f.gif", "tags": ["2d", "game", "symbol", "lightsweep", "highlighter"], "likes": 13, "viewed": 383, "published": "Public", "date": "1527695765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = fragCoord.xy / iResolution.xy;\n   \t\n\tfloat col = sin(r.y + r.x*3. -iTime*9.) * 0.9;\n    col *= col * col * 0.6;\n   \t\n    col = clamp(col, 0., 1.);\n    \n    vec4 tex = texture(iChannel0, r);\n    \n    fragColor = tex + vec4(col);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGBzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 297]], "test": "error"}
{"id": "XsGfzh", "name": "dotdotdotdotdot", "author": "lennyjpg", "description": "dotdotdotdotdot", "tags": ["asdfasd"], "likes": 2, "viewed": 384, "published": "Public API", "date": "1527556499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv-=0.5;\n    uv*=1.2;\n    float e = 0.2;\n    float angle = sin(uv.x+uv.y)*17.0;\n    vec2 p = vec2(0.5);\n    p.x+=sin(angle)*e;\n    p.y+=cos(angle)*e;\n    float d = distance(p,mod(iTime*0.5+uv*7.0,1.0)) * 2.0;\n\tfloat big = smoothstep(d*0.9,d,0.5);\n    float dd = distance(p,mod(iTime*-0.8+uv*5.0,1.0)) * 2.0;\n\tfloat small = smoothstep(dd*0.9,dd,0.1);\n    fragColor = vec4(big+small);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGfzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 485]], "test": "valid"}
{"id": "XsKfzz", "name": "DAT205 project GPU terrain v0.3", "author": "IT_Viking", "description": "This is an updated version of https://www.shadertoy.com/view/MsKcRd\n\nAdded snow and grass\nAdded texture on water. ", "tags": ["raymarching", "terraingeneration"], "likes": 0, "viewed": 193, "published": "Public", "date": "1527495588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TODO create a per pixel colour selection function that creates realistic looking cliffsides.\n//TODO try to increase FPS\n//TODO lightsource and shadows?\n//TODO Fog? \n//TODO Add snow line\n//TODO Green when normal is flat.\n\n//TODO add the broken functions for binarysearch again for presentation.\n\nconst int MAX_MARCHING_STEPS = 255; //255\nconst float MIN_DIST = 0.0; //0.0\nconst float MAX_DIST = 100.0; //100\nconst float EPSILON = 0.001; //0.0001\nconst int OCTAVES = 6; //9 is realistic, 3 works for a cartoony landscape\nconst float SCALE_STEP = 0.22; //0.23;\nconst int WATER_WORLD = 1; //True for water, false for land\nconst int BINARY_SEARCH = 0; //Enables binary search algorithm for the raymarcher\n\n// Simple 2d noise algorithm contributed by Trisomie21 (Thanks!)\nfloat snoise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\n// This is my first attempt att creating terrain\nfloat densityFunc(vec3 point, int oct){\n    float dens = point.y + 1.5; //Why do I need to add a float here? \n  \tfloat freq = 0.5;\n    float amp = 2.0;\n    for (int i=0;i<oct; i++){\n   \t\tdens += snoise(point.xz*freq)*amp;\n        //dens += sin(point.x)+sin(point.z)+amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    \n    //dens += snoise(point.xz*1.01);\n    //dens += snoise(point.xz*1.98)*0.5;\n    //dens += snoise(point.xz*4.03)*0.25;\n    \n    \n    return dens; \n\n}\n\n\nvec2 map(vec3 p){\n    \n    if (p.y < -1.0 && WATER_WORLD == 1) return vec2(-1.0, 0);\n    if (p.y < -1.0) return vec2(densityFunc(p, 1)*0.005, 3.0); //This should use a density function tailored for it. \n    float height = densityFunc(p, OCTAVES);\n    \n      //Create a hard floor\n      //if (height >= 1.05) return p.y + 1.05; //THis is bugged. Ask for help. \n    // Do this in the raymarcher instead. \n    \n   \n    \n    return vec2(height, 1);\n}\n\n\n//Raymatching with binary search\nvec2 traceBin(vec3 eye, vec3 viewRayDirection, float start, float end){\n\tfloat depth = start;\n    float scaleStep = SCALE_STEP;\n    \n    for (int i=0; i < MAX_MARCHING_STEPS; i++){\n        vec2 dist = map(eye + depth * viewRayDirection);\n        if (dist.x<EPSILON){//We're inside the geometry\n            float oldDepth = depth; \n            for (int j=0; j<8; j++){\n                if (abs(dist.x)<EPSILON){\n                    return vec2(depth, dist.y); //Correct spot\n                }\n                else if (dist.x>EPSILON){ //depth is too high, continue marching\n                    oldDepth = depth; \n                    depth += dist.x * scaleStep; //Move along the ray\n        \t\t\tif (depth >= end) return vec2(end, -1); //We've gone too far 7\n                }\n                else { //if (dist.x<-EPSILON) //Our step is too long; \n                    scaleStep *= 0.5; //Half the step length and continue; \n                    depth = oldDepth + dist.x * scaleStep; \n                    \n                }\n                dist = map(eye + depth * viewRayDirection);\n                \n            }\n        \treturn vec2(depth, dist.y); \n        }\n        depth += dist.x * scaleStep; //Move along the ray\n        if (depth >= end) return vec2(end, -1); //We've gone too far\n    }\n    if (depth < end) return vec2(depth, -2);\n    return vec2(end, -1);\n}\n\n//Raymarching\nvec2 trace(vec3 eye, vec3 viewRayDirection, float start, float end){\n    if (BINARY_SEARCH == 1) return traceBin(eye, viewRayDirection, start, end);\n\tfloat depth = start;\n    \n    for (int i=0; i < MAX_MARCHING_STEPS; i++){\n        vec2 dist = map(eye + depth * viewRayDirection);\n        if (abs(dist.x)<EPSILON){//We're inside the geometry\n        \treturn vec2(depth, dist.y); \n        }\n        depth += dist.x * SCALE_STEP; //Move along the ray\n        if (depth >= end) return vec2(end, -1); //We've gone too far\n    }\n    if (depth < end) return vec2(depth, -2);\n    return vec2(end, -1);\n}\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n\treturn normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal (vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n \n}\n\nvec3 renderSky (vec3 p, vec3 cameraPos){\n    \n    vec3 sky = vec3(0.5, 0.75, 1.0);\n    \n    if (p.y < 0.01) return sky;\n\t\n    /*oat v = (300.0-cameraPos.y)/p.y;\n\tp.xz *= v;\n    p.xz += cameraPos.xz;\n\tp.xz *= .005;\n    float rand = snoise(p.xz); \n    rand += snoise(p.xz*0.5)*2.0; \n    \n\t*/\n\t\n    float v = (0200.0-cameraPos.y)/p.y;\n\tp.xz *= v;\n\tp.xz += cameraPos.xz;\n\tp.xz *= .005;\n    \n    float rand = snoise(p.xz); \n    rand += snoise(p.xz * 0.5) *2.0;\n\trand = smoothstep(0.0, 0.5, rand);\n    \n    \n    //sky = mix(sky, vec3(.95, .95, .92), clamp(rand*p.y-.1, 0.0, 1.0));\n   \n\treturn vec3(0.5+rand, 0.75+rand/2.0, 1.0);\n}\n\nvec3 renderCliffs(vec3 p){\n    vec3 norm = estimateNormal(p);\n    vec3 colour = vec3(0.0);\n    \n    float r = mix( 0.5, 0.9, norm.x ); //This only works due to the angle we are looking from.\n    if (norm.y>0.45 && p.y>0.5) { //Adds terrain effects\n        colour = vec3(0.8+r*0.5, 0.8+r, 1.0);//Add snow\n    }else if (norm.y>0.6) { \n        colour = vec3(0.5, 0.4+r*0.5, 0.3+r*0.1); //add grass\n\n    } else {\t\n\t\tcolour = vec3(0.85*r, 0.75*r, 0.75*r);\n    }\n    /*\n    if (norm.y==1.0) colour = vec3(0.0, 0.8, 1.0);\n    else if (norm.y>0.9) colour = vec3(1.0, 1.0, 1.0);\n    else if (norm.y>0.7) colour = vec3(0.9, 0.9, 1.0);\n    else if (norm.y>0.5) colour = vec3(0.3, 0.3, 0.3);\n    else if (norm.y>0.3) colour = vec3(0.4, 0.4, 0.4);\n    else if (norm.y>0.1) colour = vec3(0.5, 0.5, 0.5);\n    else colour = vec3(0.6, 0.6, 0.6);\n    */\n    return colour; \n}\n\nvec3 renderGrass(vec3 p){\n    vec3 norm = estimateNormal(p);\n    float r = mix( 0.5, 0.9, norm.x );\n    return vec3(0.5, 0.3+r*0.4, 0.2+r*0.1);\n}\n\nvec3 renderWater(vec3 p, vec3 cameraPos){\n     vec3 water = vec3(0.0, 0.3, 0.4);\n    \n    if (p.y > 0.01) return water;\n\t\t\n    float v = (0200.0-cameraPos.y)/p.y;\n\tp.xz *= v;\n\tp.xz += cameraPos.xz;\n\tp.xz *= .005;\n    \n    float rand = snoise(p.xz); \n    rand += snoise(p.xz * 0.5) *2.0;\n    rand += snoise(p.xz * 0.25) *4.0;\n\t//rand = smoothstep(0.0, 0.3, rand);\n    \n    \n    //return mix(water, vec3(.92, .92, .95), clamp(rand*p.y-.1, 0.0, 1.0));\n   \n\treturn vec3(0.1-rand*0.015, 0.35-rand*0.015, 0.55-rand*0.005);\n\t//return vec3(0.0, 0.3, 0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    \n    \n    //This is the trace to render\n    vec3 dir = rayDirection (45.0, iResolution.xy, fragCoord); //45 FoV before experimenting\n    \n    /*\n    //Let's try to trace down\n    vec3 dirDown =  rayDirection (45.0, iResolution.xy, vec2(1.0, 0.5));\n    vec2 distDown = trace(vec3(0.0, 0.1, -iTime*2.0), dir, MIN_DIST, MAX_DIST);\n    vec3 eye = vec3(0.0, 1.0-distDown.x* 0.5, -iTime*2.0);\n    */\n    \n    vec3 eye = vec3(0.0, 1.5, -iTime*2.0);\n    //vec3 eye = vec3(0.0, 1.0, 15.0);\n    vec2 dist = trace(eye, dir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    //Render sky\n    if (dist.x > MAX_DIST - EPSILON) { \n        //Didn't hit anything\n        fragColor = vec4(renderSky(eye + dist.x * dir, eye), 0.0);\n        return;\n    }\n    // The closest point on the surface to the eyepoint along the view ray\n    if (dist.y == 1.0) fragColor = vec4(renderCliffs(eye + dist.x * dir), 0.0); //Cliffs\n    else if (WATER_WORLD == 1) fragColor = vec4(renderWater(eye + dist.x * dir, eye), 0.0); //water\n    else  fragColor = vec4(renderGrass(eye + dist.x * dir), 0.0); //grass \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 768, 792, 792, 1026], [1029, 1078, 1117, 1117, 1556], [1559, 1559, 1576, 1576, 2005], [2008, 2041, 2112, 2112, 3404], [3406, 3420, 3488, 3488, 4016], [4020, 4020, 4084, 4084, 4211], [4213, 4213, 4242, 4242, 4535], [4537, 4537, 4577, 4577, 5161], [5163, 5163, 5189, 5189, 6020], [6022, 6022, 6047, 6047, 6167], [6169, 6169, 6210, 6210, 6718], [6720, 6720, 6776, 6824, 7855]], "test": "valid"}
{"id": "XsKyWt", "name": "The T-1000 as embryo ;)", "author": "MacSlow", "description": "A sort of hommage to provod's Revision 2018 shader-competition entry. Doing \"illegal\" things (bending and distoring) to the distance-fields of the two circling spheres. Thanks to hints from Shane there are almost no more artefacts :)", "tags": ["3d", "raymarching", "reflections", "realtime", "material"], "likes": 7, "viewed": 592, "published": "Public API", "date": "1526352430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"The T-1000 as embryo ;)\" - hommage to provod's Revision 2018 shader-entry\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .0001;\n\nfloat udBox (in vec3 p, in vec3 size, in float r)\n{\n    return length (max (abs (p) - (size -r), .0)) - r;\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n  vec3 d = abs(p) - size;\n  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat sdSphere (in vec3 p, in float r)\n{\n    return length (p) - r;\n}\n\nvec3 opRepeat3 (in vec3 p, float d)\n{\n    return mod (p + d*.5, d) - d*.5;\n}\n\nfloat opUnion (in float a, in float b)\n{\n\treturn min (a, b);\n}\n\nfloat opIntersect (in float a, in float b)\n{\n\treturn max (a, b);\n}\n\nfloat opSubtract (in float a, in float b)\n{\n\treturn max (-a, b);\n}\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad * p.y);\n    float s = sin (rad * p.y);\n    mat2  m = mat2 (c, -s, s, c);\n    p = vec3 (m * p.xy, p.z);\n\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 5. + 4. * (.5 + .5 * cos (iTime));\n\tresult = .125 * sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n\n    return result;\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat scene (in vec3 p)\n{\n    vec2 offset = 1. * vec2 (cos (iTime), sin (iTime));\n    vec2 offset2 = -1. * vec2 (cos (6.28+iTime), sin (6.28+iTime));\n    float warp = .2 + .05 * (.5 + .5 * cos (25.*p.y + 8.*iTime));\n    float sphere = sdSphere (p + vec3 (-offset.x, .0+offset.y, .0), .2 + warp);\n\n    vec3 w = (p + vec3 (-offset2.x, -.125+offset2.y, .0));\n    opBend (w, 42.5 * cos (3.*iTime));\n    float dt = sdSphere (w, .65);\n    float dp = displace (w);\n    float thing = dt + dp;\n    thing = min (thing, sphere);\n \n    \n    p.xz *= r2d (-12.*iTime);\n    p.yx *= r2d (8.*iTime);\n    vec3 p1 = p + vec3 (.355);\n    p1 = opRepeat3 (p1, .325);\n    float boxes = udBox (p1, vec3 (.15), .03);\n    float cutBox = sdBox (p, vec3 (2.7), .05);\n    float wallBox = sdBox (p, vec3 (2.8), .05);\n\n    return opUnion (thing, opUnion (-wallBox, opSubtract (cutBox, boxes)));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd)\n{\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs(t) < EPSILON*(1. + .125*t)) break;\n        d += t * .75;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - scene (p));\n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n    vec3 ambient = vec3 (.05);\n    vec3 diffuseColor = vec3 (.9, .3, .3);\n    vec3 specularColor = vec3 (.9, .8, .7);\n    float shininess = 40.;\n    float diffuseStrength = .25;\n    float t = 3.*iTime;\n\n    vec3 n = normal (p, d*d*EPSILON);\n    vec3 lPos = 1.5 * vec3 (cos (t), 1., sin (t));\n    float lDist = distance (lPos, p);\n    vec3 lDir = normalize (lPos - p);\n    vec3 hDir = normalize (ro + lDir);\n    float diffuse = max (dot (n, lDir), .0)*(1. / lDist)*diffuseStrength;\n    float specular = pow (max (dot (hDir, n), .0), shininess);\n\n\tvec3 diffuseColor2 = vec3 (.3, .9, .3);\n    vec3 specularColor2 = vec3 (.7, .8, .9);\n    vec3 lPos2 = -1.5 * vec3 (.0, sin(t), .75*cos(t));\n    float lDist2 = distance (lPos2, p);\n    vec3 lDir2 = normalize (lPos2 - p);\n    vec3 hDir2 = normalize (ro + lDir2);\n    float diffuse2 = max (dot (n, lDir2), .0)*(1. / lDist2)*diffuseStrength;\n    float specular2 = pow (max (dot (hDir2, n), .0), shininess);\n\n\tvec3 diffuseColor3 = vec3 (.3, .3, .9);\n    vec3 specularColor3 = vec3 (.8, .9, .7);\n    vec3 lPos3 = 1.5 * vec3 (sin (t), .5*cos(t), -1.);\n    float lDist3 = distance (lPos3, p);\n    vec3 lDir3 = normalize (lPos3 - p);\n    vec3 hDir3 = normalize (ro + lDir3);\n    float diffuse3 = max (dot (n, lDir3), .0)*(1. / lDist3)*diffuseStrength;\n    float specular3 = pow (max (dot (hDir3, n), .0), shininess);\n\n    vec3 col = ambient +\n\t\t\t   diffuse * diffuseColor + specular * specularColor +\n\t\t\t   diffuse2 * diffuseColor2 + specular2 * specularColor2 +\n\t\t\t   diffuse3 * diffuseColor3 + specular3 * specularColor3;\n    return col;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n    \n    return normalize (camCenter + uv.x * camRight + uv.y * camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // set up \"camera\", view origin (ro) and view direction (rd)\n    float angle = radians (300. + 55. * iTime);\n    float dist = 2.65;\n    vec3 ro = vec3 (dist * cos (angle), cos (iTime), dist * sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // primary-/view-ray\n    float d = raymarch (ro, rd);\n    float fog = 1. / (1. + d*d*.03);\n    vec3 p = ro + d * rd;\n    vec3 n = normal (p, d*.0002);\n    vec3 col = shade (ro, rd, d);\n    col = mix (col, vec3 (.95, .85, .7), pow (1. - 1. / d, 10.));\n\n    // secondary-/1st reflection-ray\n    vec3 rd2 = normalize (reflect (rd, n));\n    float d2 = raymarch (p + n*.001, rd2);\n    vec3 p2 = p + d2 * rd2;\n    vec3 n2 = normal (p2, .0002);\n    vec3 col2 = shade (p, rd2, d2);\n    col += (.05 + .05*(.5 + .5 * cos (5.*iTime))) * col2;\n\n    // ternary-/2nd reflection-ray\n    vec3 rd3 = normalize (reflect (rd2, n2));\n    float d3 = raymarch (p2 + n2*.001, rd3);\n    vec3 p3 = p2 + d3 * rd3;\n    vec3 n3 = normal (p3, .0002);\n    vec3 col3 = shade (p2, rd3, d3);\n    col += (.025 + .025*(.5 + .5 * cos (5.*iTime))) * col3;\n\n    // fog, tint, tone-mapping, gamma-correction, vingette\n    col *= fog;\n    col *= vec3 (.85, .9, .95);\n    col = col / (.85 + col);\n    col = .1 * col + .9 * sqrt (col);\n    col *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4d2XzK", "previewfilepath": "https://soundcloud.com/professorkliq/crystals-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/professorkliq/crystals-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKyWt.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[0, 988, 1039, 1039, 1096], [1098, 1098, 1149, 1149, 1249], [1251, 1251, 1291, 1291, 1320], [1322, 1322, 1359, 1359, 1398], [1400, 1400, 1440, 1440, 1462], [1464, 1464, 1508, 1508, 1530], [1532, 1532, 1575, 1575, 1598], [1600, 1600, 1640, 1640, 1815], [1817, 1817, 1842, 1842, 2020], [2022, 2022, 2050, 2050, 2165], [2167, 2167, 2192, 2192, 3032], [3034, 3034, 3075, 3075, 3295], [3297, 3297, 3340, 3340, 3530], [3532, 3532, 3581, 3581, 5186], [5188, 5188, 5254, 5254, 5587], [5589, 5589, 5646, 5646, 7201]], "test": "valid"}
{"id": "XstBDN", "name": "Formula of Everything!", "author": "akhgary", "description": "this is a formula in which you can plot anything with it. this formula can plot any combination of points on a XY plane given the right scales and Y offset.\n\ncheck out the provided links.", "tags": ["number", "digit", "plot", "character", "formula", "print", "char"], "likes": 1, "viewed": 115, "published": "Public", "date": "1525195330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Loop free digit printer\n// ====================================\n// Tupper's self-referential formula\n// https://en.wikipedia.org/wiki/Tupper%27s_self-referential_formula\n// ====================================\n// great video by numberphile!\n// https://www.youtube.com/watch?v=_s5RFgd59ao\n// ====================================\n\nconst vec2 scale = vec2(3,5);\nfloat[] k_arr = float[](32319.,2033.,30391.,32437.,31900.,\n                        24253.,24255.,32272.,32447.,32445.);\n\nvoid mainImage(out vec4 col,in vec2 coord)\n{\n    vec2 uv = (2.*coord.xy-iResolution.xy)/iResolution.y;\n    vec2 c = vec2(0), o = vec2(1)/2., mi=c-o, ma=c+o; float s = scale.y;\n    if(uv.x<mi.x||uv.y<mi.y||uv.x>ma.x||uv.y>ma.y) return;\n    vec2 xy = (uv-mi)/(ma-mi)*scale; // map    \n    xy.y+=k_arr[int(mod(iTime,10.))]*s;\n    if(.5<floor(mod(floor(xy.y/s)*pow(2.,-s*floor(xy.x)-mod(floor(xy.y),s)),2.))) // magic formula\n    \tcol = vec4(.5+.5*cos(iTime+uv.xyx+vec3(0,2,4)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 483, 527, 527, 962]], "test": "error"}
{"id": "XstBDX", "name": "dasf", "author": "lennyjpg", "description": "asdfasd", "tags": ["asdfasd"], "likes": 1, "viewed": 370, "published": "Public API", "date": "1527026249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.x;\n    vec2 s = vec2(.0),c = vec2(.0);\n    vec4 final = vec4(1.0,1.0,1.0,1.0);\n    float t = iTime * 0.1;\n    float d = 0.0,r = 0.0;\n    vec4 c0 = texture(iChannel0,uv);   \n    vec4 c1 = texture(iChannel1,uv);\n    vec4 c2 = texture(iChannel2,uv);\n    vec4 c3 = texture(iChannel3,uv);\n    for(float j=0.0; j<4.0; j+=1.0) {   \n     float pixel = 0.0;\n\t     for(float i=0.0; i<50.0; i+=1.0) {\n           s = vec2( sin(i*1.9+t), cos(j*2.5+t));\n           c.x = cos(i * 12.9 + s.x)*1.0 ;\n           c.y = sin(i * 13.44 + s.y)*1.0;\n           r = fract(sin((i*0.6))*5.0) * 0.4;\n           d = length(uv-0.5 - c);\n           pixel += smoothstep(d*0.5,d,r*r);\n         }\n        vec4 e = c0;   \n        if(j<3.0) e = c1;\n        if(j<2.0) e = c2;\n        if(j<1.0) e =c3;\n        if(pixel>0.3) final  = e;\n    }\n    fragColor = final;\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 921]], "test": "error"}
{"id": "XstBWN", "name": "Test Blob intersection", "author": "paulbaron", "description": "Test blob intersection", "tags": ["blobraymarch"], "likes": 1, "viewed": 88, "published": "Public", "date": "1525260568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float \tinfinity = 10000.0f;\n\nconst float \tsolidSurfThreshold = 0.5f;\nconst float \trayMarchDist = 0.05f;\n\n// Ray hit surface\nstruct  SRayHit\n{\n    float \tm_Distance;\n    vec3    m_Position;\n    vec3    m_Normal;\n};\n\n// Blob\nstruct \tSBlob\n{\n    vec3 \tm_Position;\n    float \tm_Radius;\n    float \tm_Intensity;\n};\n\n// Camera representation\nstruct  SCamera\n{\n    vec3    m_Position;\n    vec3    m_Side;\n    vec3    m_Forward;\n    vec3    m_Up;\n};\n\n// build look at\nSCamera buildLookAt(vec3 position, vec3 toLookAt, vec3 up)\n{\n    SCamera cam;\n        \n    cam.m_Position = position;\n    cam.m_Forward = normalize(toLookAt - position);\n    cam.m_Side = normalize(cross(up, cam.m_Forward));\n    cam.m_Up = cross(cam.m_Forward, cam.m_Side);\n    return cam;\n}\n\n// Projects a uv coordinate between -1 and 1 in world space\n// nearDist: near plane distance\n// aspectRatio: screenResolution.x / screenResolution.y\n// verticalOpening: vertical world size of the screen is 2 * verticalOpening, use it as FOV\nvec3    uvToWorldSpace(SCamera cam, vec2 uv, float nearDist, float aspectRatio, float verticalOpening)\n{\n    // Now we convert this in world space\n    vec3 nearPlaneCenter = cam.m_Position + (cam.m_Forward * nearDist);\n    vec3 worldSpaceUv = nearPlaneCenter +\n                        (uv.x * cam.m_Side * aspectRatio * verticalOpening) +\n                        (uv.y * cam.m_Up * verticalOpening);\n    return worldSpaceUv;\n}\n\nSRayHit \trayMarchBlobs(SBlob blob1, SBlob blob2, vec3 rayOrigin, vec3 rayDirection, float farDist)\n{\n    SRayHit\thit;\n    vec3 \tcurrentPos = rayOrigin;\n    float \tcurrentDist = 3.0f;\n\n    while (currentDist < farDist)\n    {\n        currentPos += rayDirection * rayMarchDist;\n        currentDist += rayMarchDist;\n        \n        float \tsumInfluence = 0.0f;\n        \n        vec3 \tcurToBlob1 = blob1.m_Position - currentPos;\n        float \tblobInfluence1 = blob1.m_Intensity / dot(curToBlob1, curToBlob1);\n\n\t\tsumInfluence += blobInfluence1;\n        \n    \tvec3 \tcurToBlob2 = blob2.m_Position - currentPos;\n        float \tblobInfluence2 = blob2.m_Intensity / dot(curToBlob2, curToBlob2);\n\n\t\tsumInfluence += blobInfluence2;\n\n        if (sumInfluence > solidSurfThreshold)\n        {\n            hit.m_Distance = currentDist;\n            hit.m_Position = currentPos;\n            return hit;\n        }\n\t}\n    hit.m_Distance = infinity;\n\thit.m_Position = vec3(infinity);\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float camSpeed = 2.0f;\n    const float camDistance = 0.0f;\n    \n    float \t\tcamPosX = cos(iTime * camSpeed) * camDistance;\n    float \t\tcamPosY = sin(iTime * camSpeed) * camDistance;\n    \n    vec3 \t\tcamPos = vec3(camPosX, 10.0f, camPosY);\n    SCamera \tcamera = buildLookAt(camPos, vec3(0.0f), vec3(0.0, 0.0, 1.0));\n    \n    SBlob \t\tblob1;\n    SBlob \t\tblob2;\n\n    blob1.m_Position = vec3(0, 0, 0);\n    blob1.m_Radius = 1.0f;\n    blob1.m_Intensity = 1.0f;\n\n    float \t\tblobDist = cos(iTime * 3.0f) * 0.5f + 0.8f ;\n    \n    blobDist *= 5.0f;\n    \n    float \t\tblobPosX = cos(iTime * 2.0f) * blobDist;\n    float \t\tblobPosY = sin(iTime * 2.0f) * blobDist;\n\n    blob2.m_Position = vec3(blobPosX, 0, blobPosY);\n    blob2.m_Radius = 2.0f;\n    blob2.m_Intensity = 1.0f;\n    \n\t// Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0f - 1.0f;\n\n    float \taspectRatio = iResolution.x / iResolution.y;\n    float \tfov = 0.1f;\n    float \tnearDist = 0.2f;\n    \n    vec3 \trayOrigin = uvToWorldSpace(camera, uv, nearDist, aspectRatio, fov);\n\tvec3 \trayDirection = rayOrigin - camPos;\n                                       \n\tSRayHit hit = rayMarchBlobs(blob1, blob2, rayOrigin, rayDirection, 50.0f);\n\n    vec3 \txPos = dFdx(hit.m_Position);\n    vec3 \tyPos = dFdy(hit.m_Position);\n\n    fragColor = vec4(0.0f, 0.0f, 0.3f, 1.0f);\n\n    if (hit.m_Distance != infinity)\n    {\n\t    fragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 466, 526, 526, 756], [758, 999, 1103, 1145, 1425], [1427, 1427, 1527, 1527, 2407], [2409, 2409, 2466, 2466, 3915]], "test": "valid"}
{"id": "XstBzf", "name": "Circle packing 2-Layers loopless", "author": "akhgary", "description": "Layer 2 is an approximation by a modulated sin wave.\n\nprobably there is an square root-ish algorithm for exact coordinates, but i could not figure that out.\n\nwho wants to go for layer 3? :)", "tags": ["circle", "ball", "plot", "draw", "rolling", "circlepacking", "loopfree"], "likes": 13, "viewed": 217, "published": "Public", "date": "1526217438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Loop free circle packing. \n\n// My play ground\n// https://www.desmos.com/calculator/pndtbj27ny\n//\n// thanks to user https://www.shadertoy.com/user/FabriceNeyret2\n// for his great help. i didnt know desmos is such a great tool!\n\n// Hue taken from https://www.shadertoy.com/view/4tlBWB\n\n#define tau 6.28318\n#define pi 3.14159\n\nconst vec2 C = vec2(0);\t// center\nconst float R = .2;\t\t// radius\n\nconst float t = asin(.5);\t// angle to tangent point between two circles in layer 1\nconst float tc = t*2.; \t\t// angle to center of circles in layer 1\n\nvec3 hue( in vec3 c ){\n\treturn c.z*(1.-c.y*smoothstep(2.,1.,abs(mod(c.x*6.+vec3(0,4,2),6.) -3.)));\n}\n\nfloat circle(vec2 xy, vec2 c, float r, bool fill){\n    float dist = length(xy-c)-r;\n    return 1.-smoothstep(-3./iResolution.y,2./iResolution.y,fill?dist:abs(dist));\n}\n\nmat2 rotate(float th){\n    return mat2(cos(th),-sin(th),sin(th),cos(th));\n}\n\nfloat layer0(vec2 xy){\n    return circle(xy, C, R, false);\n}\n\nvec3 layer1(vec2 xy, float ph){\n\tfloat n = tau/tc;\t\t\t\t\t\t// number of circles\n    vec2 zw = rotate(ph-t)*(xy-C); \t\t\t// plane rotation\n    float i = floor(atan(zw.y,zw.x)/tc);\t// angular coordinates to index\n    vec2 c = vec2(cos(i*tc+ph),sin(i*tc+ph))*2.*R+C; // center\n    vec3 hsl = vec3(i/n+.9,1.,.8);\t\t\t\t \t // coloring\n    return circle(xy,c,R,true)*hue(hsl);\n}\n\nvec3 layer2_half(vec2 xy, float k, float ph0, float ph){\n    float n = tau/t;\t\t\t\t\t// number of circles\n    vec2 zw = rotate(ph-t+k*t)*(xy-C);\t// plane rotation\n    float mad = 4.*R;\t\t\t\t\t// max distance\n    float mid = mad*cos(t); \t\t\t// min distance\n    float j = k+2.*floor((atan(zw.y,zw.x))/tc);\t\t        // angular coordinates to index\n    float r = mid+abs(cos(pi/2.*((ph-ph0)/t+j)))*(mad-mid); // approximated radius\n    vec2 c = vec2(cos(j*t+ph),sin(j*t+ph))*r+C; // center\n    vec3 hsl = vec3(j/n,1.,.5); \t\t\t\t// coloring\n    return circle(xy,c,R,true)*hue(hsl);\n}\n\nvec3 layer2(vec2 xy, float ph0, float ph){\n    return layer2_half(xy,0.,ph0,ph)+ // 6 even 0,2,4,6,8,10\n           layer2_half(xy,1.,ph0,ph); // 6 odd  1,3,5,7,9,11\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float ph1 = sin(iTime*2.)+iTime/2., ph2 = cos(iTime+pi/3.)-iTime/3.;\n    xy=rotate(iTime)*(xy-C)+C;\n\tvec3 col = layer0(xy)\n         \t + layer1(xy, ph1)\n        \t + layer2(xy, ph1, ph2);\n    \n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 543, 565, 565, 643], [645, 645, 695, 695, 812], [814, 814, 836, 836, 889], [891, 891, 913, 913, 951], [953, 953, 984, 984, 1317], [1319, 1319, 1375, 1375, 1888], [1890, 1890, 1932, 1932, 2056], [2058, 2058, 2115, 2115, 2413]], "test": "error"}
{"id": "XstfzB", "name": "Disco tunnel", "author": "WAHa_06x36", "description": "A fabulous tunnel. Good for staring at.", "tags": ["tunnel", "sensoryoverload"], "likes": 56, "viewed": 13938, "published": "Public API", "date": "1525772856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 position(float z) {\n\treturn vec2(\n\t\t0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n\t\t0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n\t) * 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat camZ = 25.0 * iTime;\n\tvec2 cam = position(camZ);\n\n\tfloat dt = 0.5;\n\tfloat camZ2 = 25.0 * (iTime + dt);\n \tvec2 cam2 = position(camZ2);\n\tvec2 dcamdt = (cam2 - cam) / dt;\n\t\n\tvec3 f = vec3(0.0);\n \tfor(int j = 1; j < 300; j++) {\n\t\tfloat i = float(j);\n\t\tfloat realZ = floor(camZ) + i;\n\t\tfloat screenZ = realZ - camZ;\n\t\tfloat r = 1.0 / screenZ;\n \t\tvec2 c = (position(realZ) - cam) * 10.0 / screenZ - dcamdt * 0.4;\n\t \tvec3 color = (vec3(sin(realZ * 0.07), sin(realZ * 0.1), sin(realZ * 0.08)) + vec3(1.0)) / 2.0;\n \t\tf += color * 0.06 / screenZ / (abs(length(p - c) - r) + 0.01);\n\t}\n\n\tfragColor = vec4(f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XstfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 243], [245, 245, 302, 302, 998]], "test": "valid"}
{"id": "XsVBRh", "name": "Loading test - 119 chars", "author": "fjavifabre", "description": ".", "tags": ["animation", "loading", "golf"], "likes": 1, "viewed": 76, "published": "Public", "date": "1527605059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ABizard's 119 chars\n\nvoid mainImage(out vec4 O, vec2 u) {  \n    vec2 R = iResolution.xy,\n         v = (u+u-R)/R.y;\n    cos(2.*(atan(v.y,v.x)+iTime))>0. && abs(length(v)-.4)<.1 ?\n      O ++ : O;}\n\n\n// ABizard's 152 chars (with antialiasing)\n/*\n#define S smoothstep(5./R.y,0.\n#define mainImage(O,u)\\\n    vec2 R = iResolution.xy,\\\n         v = (u+u-R)/R.y;\\\n    O += S,cos(2.*(atan(v.y,v.x)+iTime))/4.)\\\n        *S,abs(length(v)-.4)-.1)     \n*/\n\n// ABizard's 121 chars\n/*\n#define mainImage(O,u)\\\n    vec2 R = iResolution.xy,\\\n         v = (u+u-R)/R.y;\\\n    mod(atan(v.y,v.x)+iTime,3.14)<1.57 && abs(length(v)-.4)<.1 ?\\\n    O ++ : O\n*/\n             \n// ABizard's 157 chars (with antialiasing)\n/* \n#define mainImage(O,u)\\\n    vec2 R = iResolution.xy,\\\n         v = (u+u-R)/R.y;\\\n    O += smoothstep(20./R.y,0.,cos(2.*(atan(v.y,v.x)+iTime)))\\\n        *smoothstep(5./R.y,0.,abs(length(v)-.4)-.1)\n*/\n\n// fjavifabre's - 163 chars\n/*\n#define w(t) acos(dot(v/length(v), vec2(sin(t),cos(t)))) < .8\n#define mainImage(O,u)\\\n\tvec2 v = u/iResolution.xy - .5; \\\n\tabs(length(v) - .2) < .05 && \\\n\t(w(iTime) || w(iTime+3.14)) \\\n\t? O++ : O; \n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsVBRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 24, 60, 60, 197]], "test": "valid"}
{"id": "Xsyfz1", "name": "Rose curves", "author": "lnae", "description": "Playing with rose curves", "tags": ["2d", "rose"], "likes": 6, "viewed": 115, "published": "Public", "date": "1527552247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 4.0;\n    \n    float time = 0.5 * iTime;\n    float angle = atan(uv.y, uv.x) + 2.0 * sin(PI * time);\n    float radius = length(uv);\n    \n    float n = mod(floor(time + 3.0), 9.0);\n    float d = mod(floor(time / 9.0 + 5.0), 10.0) + 1.0;  \n    float k = n / d;\n    float offset = sin(2.6 * sin(1.9 * sin(PI * time)));\n\n    float res = 10000.0;    \n    for(float i = 0.0; i < d; i++){\n    \tangle += 2.0 * PI;\n        res = min(res, abs(radius - ( cos(k * angle) + offset)));\n        res = min(res, abs(-radius - (cos(k * (angle + PI)) + offset)));\n    }\n    \n    res = smoothstep(20.0 / iResolution.y, 0.0, res);\n    \n    fragColor = vec4(vec3(res),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xsyfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 808]], "test": "valid"}
