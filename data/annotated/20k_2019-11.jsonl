{"id": "3d3SDB", "name": "[inercia2019] Coudycol", "author": "PauloFalcao", "description": "A quick effect done in Inecia2019", "tags": ["inercia2019"], "likes": 13, "viewed": 317, "published": "Public API", "date": "1572748443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Coudycol\n//\n// by @paulofalcao\n//\n// A quick effect done in Inecia2019\n//\n// Original made on http://www.backtothepixel.com/apps/GLSLSandboxHack/index.html\n//\n\n#define Size 0.192\n#define ScreenL 4.686\n#define SphereOpacity 0.006\n#define Color vec3(1,0.38,0.38)\n#define R1 5.475\n#define G1 6.954\n#define B1 6.313\n#define time iTime\n#define resolution iResolution.xy\n\nfloat sincostex(vec3 p,float s){\n  p*=s;\n  return cos(p.x)*sin(p.y)*cos(p.z)*0.5+0.5;\n}\n\nvec4 of(vec3 p){\n  p*=(sin(time*2.0)*0.5+1.5);\n  float ct=cos(time);float st=sin(time);\n  p.xz*=mat2(ct,-st,st,ct);\n  ct=cos(time*0.5);st=sin(time*0.5);\n  p.xy*=mat2(ct,-st,st,ct);\n\n  vec3 op=p;\n  vec3 a1=p*(1.0+sin(op.yzx*4.0)*0.4);\n  vec3 a2=p*(1.0+sin(op*4.0)*0.4);\n  p=mix(a1,a2,sin(time*0.1)*0.5+0.5);\n\n  vec3 n=normalize(p);\n  p*=(0.5+sincostex(n,sin(floor(time))*10.0+10.0));\n  float a=length(p)<(sincostex(n,Size*10.0)+2.0)?SphereOpacity:0.0;\n\n  return vec4(vec3(sin(p*vec3(R1,G1,B1))*0.5+0.5)*Color,a);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n  vec2 uv=iResolution.xy;\n    \n  uv=(gl_FragCoord.xy-uv*.5)/uv.y;\n\n  vec3 ro=vec3(0,0,5);\n  vec3 r=normalize(vec3(uv,-1));\n\n  vec4 color;\n  float f=1.0;\n  for(int i=0;i<400;i++){\n    vec3 p=ro+f*r;\n    vec4 d=of(p);\n    color+=vec4(d.xyz*d.w,d.w);\n    if (f>8.0) break;\n    if (color.w>1.0) break;\n    f+=0.02;\n  }\n\n  fragColor=vec4(color.xyz*ScreenL,1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3SDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 372, 404, 404, 459], [461, 461, 477, 477, 976], [978, 978, 1034, 1034, 1394]], "test": "untested"}
{"id": "3d3XWl", "name": "Pixel Art Clouds", "author": "bogz", "description": "ive been leanring c++ and glsl shader for about a week and this is my first all memory shader from things ive learnt from many sites and online book!", "tags": ["procedural", "2d", "clouds", "pixel", "sky", "art"], "likes": 6, "viewed": 371, "published": "Public API", "date": "1573077959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nfloat rand(vec2 coords)\n{\n\treturn fract(sin(dot(coords, vec2(56.3456f,78.3456f)) * 5.0f) * 10000.0f);\n}\n\nfloat noise(vec2 coords)\n{\n\tvec2 i = floor(coords);\n\tvec2 f = fract(coords);\n\n\tfloat a = rand(i);\n\tfloat b = rand(i + vec2(1.0f, 0.0f));\n\tfloat c = rand(i + vec2(0.0f, 1.0f));\n\tfloat d = rand(i + vec2(1.0f, 1.0f));\n\n\tvec2 cubic = f * f * (3.0f - 2.0f * f);\n\n\treturn mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0f - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nfloat fbm(vec2 coords)\n{\n\tfloat value = 0.0f;\n\tfloat scale = 0.5f;\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tvalue += noise(coords) * scale;\n\t\tcoords *= 4.0f;\n\t\tscale *= 0.5f;\n\t}\n\n\treturn value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y * 2.0f;\n    \n    float Pixels = 1024.0;\n    float dx = 10.0 * (1.0 / Pixels);\n    float dy = 10.0 * (1.0 / Pixels);\n  \n    vec2 Coord = vec2(dx * floor(uv.x / dx),\n                          dy * floor(uv.y / dy));\n\tvec2 motion = vec2(fbm(Coord + iTime * 0.05f));\n  \n\n    float final = fbm(Coord + motion);\n    \n\tfragColor = vec4(mix(vec3(-0.2f), vec3(0.45, 0.4f, 0.6f) + vec3(0.6f), final), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3XWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 49, 49, 127], [129, 129, 155, 155, 485], [487, 487, 511, 511, 676], [679, 679, 736, 736, 1176]], "test": "untested"}
{"id": "3dcSDs", "name": "Codevember #6 - Music Vis", "author": "desertsky", "description": "Lightrun Vis!", "tags": ["fft", "audio", "audiovisual", "lightrun"], "likes": 3, "viewed": 71, "published": "Public", "date": "1573099639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave;\nfloat fft;\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\t\n\nfloat sphere(in vec3 pos) {\n\tvec3 cen = vec3(0.,0.2,0.);\n\treturn length(cen* fft*5.-pos) -.35*fft*3.5;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 cen = vec3(-0.4,1.-2.*fft,-.7);\n\tvec3 d = abs(p)+cen - b;\n\treturn length(max(d, vec3(.3))) + vmax(min(d, vec3(0.)));\n}\n\n\n\nfloat map(vec3 p) {\n    \np = mod(p+2.,4.) - 2.;\n//return length(p) -.35;\n    float s = sphere(p); \n\tfloat b = fBox(p, vec3(1.));\n    return min(s,b);\n}\n\nvec3 GetNormal(vec3 p) \n{\n\tvec2 e = vec2(.001,0);\n    float d = map(p);\n    vec3 n = d - vec3(\n    \tmap(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat CastRay(in vec3 ro, vec3 rd) {\n  \n    float t = 0.0;\n        \n    for (int i = 0; i < 120; i++) {\n    \n        vec3 pos = ro + rd * t;\n\n        float h = map(pos);\n        \n        if(h<.001) break;\n        t+=h;\n        if(t>20.0) break;\n    }\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord -iResolution.xy)/iResolution.y;\n    \n    //from https://www.shadertoy.com/view/Xds3Rr\n    int tx = int(p.x/3.);\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\t fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    vec3 ro = vec3(\n    0., \n    2.,\n    iTime*3.4);\n     vec3 ta = vec3(0.,0.,0.);\n\n    vec3 ww = normalize(ta - ro); //forward\n\n    vec3 uu = normalize (cross(ww,vec3(0,1,0))); // right?\n\n    vec3 vv = normalize(cross(uu,ww) ); // up?\n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\n    vec3 col = (vec3(0.65,0.75,0.9)-0.5*rd.y)/1.5;\n\t\n    \n\tfloat t = CastRay(ro,rd);\n    \n    \n    \n    \n    if(t<20.) {\n    \n        //base \n        col = vec3(.99*p.x+fft,.36,p.y+fft/8.);\n\n    \tvec3 pos = ro + t * rd;\n \n    \n        vec3 sun_dir = vec3(1,1,0);\n    \tvec3 nor = GetNormal(pos);\n        float sun_dif = clamp(dot(nor,sun_dir),0.,1.);\n        col += sun_dif;\n        //col+= vec3(.3+fft*2.,.3+fft*.5,.3+fft*2.);\n            \n    }\n    \n    //prettier without faux-gamma\n    //col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "lls3DX", "previewfilepath": "https://soundcloud.com/user-107012861/lightrun03", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-107012861/lightrun03", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 69], [71, 71, 91, 91, 126], [128, 128, 148, 148, 193], [197, 197, 224, 224, 301], [303, 303, 331, 331, 459], [463, 463, 482, 482, 614], [616, 616, 641, 641, 806], [808, 808, 844, 844, 1074], [1078, 1078, 1135, 1135, 2376]], "test": "untested"}
{"id": "3dcSWl", "name": "singularity ? deep dive.", "author": "Carandiru", "description": "original source : https://www.shadertoy.com/view/td3XW2 andremichelle\njust trying to find the singularity in my computer\n*best viewed full screen*", "tags": ["effect", "illusion", "temporal"], "likes": 3, "viewed": 127, "published": "Public", "date": "1573076021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// original source : https://www.shadertoy.com/view/td3XW2 andremichelle\n\n// just trying to find the singularity in my computer\n// *best viewed full screen*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*2.0;\n    \n    float a = atan(uv.y, uv.x);\n    float l = length(uv) * 0.5f;\n\n    float t = iTime*0.975;\n    float f = float(iFrame)*0.975f;\n    \n    float x = (t+25.0f)*sin(1.0f+f)*1.61803398875f*(l-0.333+sin(f*2.0f)*0.06125);\n    float c = (cos(x*2.0)/x)*max(0.0,(1.75-(x*0.001*(0.5*sin(iTime)*0.5))));\n    float d = 0.0;\n    \n    d += smoothstep(0.0f, sqrt(c), tan(a*1.0+t*0.5));\n    d += smoothstep(d, d*d, tan(a*2.0-t*1.2));\n    d += smoothstep(d*d, d*d*d, tan(a*3.0+t*1.5));\n    d += smoothstep(d*d*d, d*d*d*d, tan(a*2.0-t*1.7));\n    d += smoothstep(d*d*d*d, d*d*d*d*d, tan(a*1.0+t*3.8));\n    d += smoothstep(d*d*d*d*d, d*d*d*d*d*d, tan(a*2.0+t*4.7));\n    d += smoothstep(d*d*d*d*d*d, d*d*d*d*d*d*d, tan(a*0.5+t*6.8));\n    d += smoothstep(d*d*d*d*d*d*d, d*d*d*d*d*d*d*d, tan(a*0.25+t*9.8));\n    float amount = c/(1.0f + d*d*d);\n    amount = max(d, amount) + min(d, amount);\n    amount = min(c, d*d);\n    vec3 col = smoothstep(vec3(0), vec3(1), vec3(1.0,0.0,0.2)*(0.05+amount*d*0.03f));\n    vec3 bar = pow(col, vec3(9.4f));\n    bar = pow(abs(col - bar), vec3(4.0f));\n    col = bar + col * col;\n    fragColor = vec4(pow(col, vec3(1.0f/2.2f)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 158, 215, 215, 1426]], "test": "untested"}
{"id": "3dcXRN", "name": "Interference Pattern Reflections", "author": "Hotrhodium", "description": "Making fake wave reflections. The waves do not maintain independent velocity but are relative to the movement of the center point.", "tags": ["reflections", "wavepatterns"], "likes": 5, "viewed": 119, "published": "Public", "date": "1572579167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/vec2(iResolution.y);\n    int i = 0;\n    const int SquarCount = 5;\n    float freq = 50.0;\n    float yCal = 0.0;\n    float Fade = 1.48;\n    \n    yCal = iResolution.x/iResolution.y;\n    \n    vec2 CirCen0[9];\n    CirCen0[0] = vec2(0.9-(cos((iTime+5.0)*0.27)*0.9),0.5+(0.5*cos(iTime*.33)));\n    CirCen0[1] = vec2(1,-1) * CirCen0[0];\n    CirCen0[2] = CirCen0[1]+vec2(0,2);\n    CirCen0[3] = vec2(-1,1) * CirCen0[0];\n    CirCen0[4] = CirCen0[3]+vec2((yCal)*2.0,0);\n\n    vec2 CirCen1[9];\n    CirCen1[0] = vec2(0.9-(cos(iTime*0.59)*0.9),0.5+(0.5*cos((iTime+5.0)*.41)));\n    CirCen1[1] = vec2(1,-1) * CirCen1[0];\n    CirCen1[2] = CirCen1[1]+vec2(0,2);\n    CirCen1[3] = vec2(-1,1) * CirCen1[0];\n    CirCen1[4] = CirCen1[3]+vec2((yCal)*2.0,0);\n    \n    float MyDist = 0.0;\n    float Darkness = 0.0;\n    float Adj = float(SquarCount) * 2.0;\n    \n    for(int i=0;i<SquarCount;i++)\n    {\n        MyDist = distance(CirCen0[i],uv);\n        if (MyDist < Fade)\n        {    \n        \tDarkness += (cos((MyDist*freq)-iTime*10.0)/(Adj))*(Fade-MyDist);\n        }\n    }\n    for(int i=0;i<SquarCount;i++)\n    {\n        MyDist = distance(CirCen1[i],uv);\n        if (MyDist < Fade)\n        {    \n        \tDarkness += (cos((MyDist*freq)-iTime*10.0)/(Adj))*(Fade-MyDist);\n        }\n    \n    }\n\t\n\tDarkness = Darkness+0.5;\n    fragColor = vec4(vec3(Darkness),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcXRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1416]], "test": "untested"}
{"id": "3dcXWS", "name": "thundercloud", "author": "mahalis", "description": "a project for Nodevember. today's subject: “cloud”. you may need a relatively high-end GPU to get a decent frame rate.", "tags": ["volume", "raymarch", "cloud", "smoke", "lightning"], "likes": 51, "viewed": 1489, "published": "Public API", "date": "1572735999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// except where otherwise noted, this code is CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\n// ------\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\n// returns a pair of values for the distances along the ray at which there are sphere intersections, or 0 if none\nvec2 sphereIntersectionDistances(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius) {\n    vec3 toCenter = sphereOrigin - rayOrigin;\n    float toCenterAlongRay = dot(toCenter, rayDirection);\n    \n    float perpendicularDistanceSquared = dot(toCenter, toCenter) - toCenterAlongRay * toCenterAlongRay;\n    float radiusSquared = sphereRadius * sphereRadius;\n    \n    if (perpendicularDistanceSquared > radiusSquared) { // ray doesn’t touch the sphere\n        return vec2(0.);\n    }\n    \n    float insideSphereAlongRay = sqrt(radiusSquared - perpendicularDistanceSquared); // half the length of the portion of the ray inside the sphere\n    \n    float intersection1 = toCenterAlongRay - insideSphereAlongRay;\n    float intersection2 = toCenterAlongRay + insideSphereAlongRay;\n    if (intersection1 > intersection2) {\n        float t = intersection1;\n        intersection1 = intersection2;\n        intersection2 = t;\n    }\n    \n    if (intersection1 < 0.) { // first intersection is before the start of the ray\n        if (intersection2 < 0.) { // ditto second, though that… shouldn’t happen?\n            return vec2(0.);\n        } else {\n            intersection1 = intersection2;\n            intersection2 = 0.;\n        }\n    }\n    \n    return vec2(intersection1, intersection2);\n}\n\n// -----------------\n\n// 3d noise by iq, from https://www.shadertoy.com/view/Xsl3Dl\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n// hash functions by David Hoskins, from https://www.shadertoy.com/view/4djSRW\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\n\n// -----------------\n\nfloat octavedNoise(vec3 position) {\n    vec3 samplePosition = position * 2.;\n    float noiseAmount = noise(samplePosition + iTime * vec3(0.0,0.2,0.0));\n    samplePosition *= 1.99;\n    noiseAmount += noise(samplePosition + iTime * vec3(0.05,-0.37,0.02)) * 0.51;\n    noiseAmount /= 1.51;\n    return noiseAmount;\n}\n\nfloat density(vec3 position) {\n    float baseValue = 1.0 - pow(max(0.0, length(position)), 2.0);\n    float noiseAmount = octavedNoise(position);\n    \n    return max(0.,min(1.,baseValue - max(0.,noiseAmount * 1.5)));\n}\n\nvec4 innerLightPositionAndIntensity() {\n    float scaledTime = iTime * 6.1;\n    float hashInput = floor(scaledTime) * 0.1;\n    \n    if (hash11(hashInput) < 0.8) return vec4(0.); // mask out most of the flashes\n        \n    vec3 hash = hash31(hashInput);\n    float theta = hash.x * 6.283;\n    float z = hash.y * 2. - 1.;\n    float sinPhi = sin(acos(z));\n    vec3 position = vec3(sinPhi * cos(theta), sinPhi * sin(theta), z) * (0.6 + hash.z * 0.2);\n    \n    float intensity = sin(fract(scaledTime) * 3.142);\n    \n    return vec4(position, intensity);\n}\n\n\n// marching logic adapted from Ryan Brucks's article here: https://shaderbits.com/blog/creating-a-volumetric-ray-tracer\n\nvec4 march(vec3 origin, vec3 direction) {\n    \n    const int mainSteps = 30;\n    const int shadowSteps = 10;\n    const vec3 toLight = normalize(vec3(1.0,1.0,0.));\n    const float mainDensityScale = 4.;\n    \n    const float shadowingThreshold = 0.001;\n    const float shadowDensityScale = 3.;\n    \n    vec3 light = vec3(0.);\n    float transmittance = 1.;\n    \n    vec3 samplePosition = origin;\n   \n    const float mainStepLength = 2. / float(mainSteps); // why does lowering this below 2 change the appearance?\n    const float shadowStepLength = 1. / float(shadowSteps);\n    \n    const vec3 scaledShadowDensity = shadowDensityScale * shadowStepLength / vec3(0.8,0.7,1.0);\n    \n    const float shadowConstant = -log(shadowingThreshold) / scaledShadowDensity.z;\n    \n    const vec3 mainLightColor = vec3(0.6,0.8,1.);\n    const vec3 innerLightColor = vec3(0.7,0.4,1.) * 4.;\n    \n    vec3 mainStepAmount = direction * mainStepLength;\n    \n    vec3 shadowStepAmount = toLight * shadowStepLength;\n    \n    vec4 innerLight = innerLightPositionAndIntensity();\n    \n    for(int i = 0; i < mainSteps; i++) {\n        float localDensity = min(1.0, density(samplePosition) * mainDensityScale);\n        if (localDensity > 0.001) {\n            \n            // - main light (directional)\n            \n            vec3 shadowSamplePosition = samplePosition;\n            float shadowAccumulation = 0.;\n            for(int j = 0; j < shadowSteps; j++) {\n                shadowSamplePosition += shadowStepAmount;\n                \n                shadowAccumulation += min(1.0, density(shadowSamplePosition) * shadowDensityScale);\n                if (shadowAccumulation > shadowConstant || dot(shadowSamplePosition, shadowSamplePosition) > 1.) break;\n            }\n            \n            vec3 shadowTerm = exp(-shadowAccumulation * scaledShadowDensity);\n            float stepDensity = min(1.,localDensity * mainStepLength);\n            vec3 absorbedLight = shadowTerm * stepDensity;\n            \n            // accumulate directional light\n            light += absorbedLight * transmittance * mainLightColor;\n            \n            \n            // - inner light (point)\n            \n            shadowSamplePosition = samplePosition;\n            shadowAccumulation = 0.;\n            vec3 toInnerLight = innerLight.xyz - samplePosition;\n            vec3 innerLightShadowStepAmount = normalize(toInnerLight) * shadowStepLength;\n            \n            for(int j = 0; j < shadowSteps; j++) {\n                shadowSamplePosition += innerLightShadowStepAmount;\n                \n                shadowAccumulation += min(1.0, density(shadowSamplePosition) * shadowDensityScale);\n                \n                // bail out if we’ve accumulated enough or if we’ve gone outside the bounding sphere (squared length of the sample position > 1)\n                if (shadowAccumulation > shadowConstant || dot(shadowSamplePosition, shadowSamplePosition) > 1.) break;\n            }\n            \n            shadowTerm = exp(-shadowAccumulation * scaledShadowDensity);\n            stepDensity = min(1.,localDensity * mainStepLength);\n            absorbedLight = shadowTerm * stepDensity;\n            \n            // inverse-squared fade of the inner point light\n            float attenuation = min(1.0, 1.0 / (dot(toInnerLight, toInnerLight) * 2. + 0.0001)) * innerLight.w;\n            \n            // accumulate point light\n            light += absorbedLight * (transmittance * attenuation) * innerLightColor;\n            \n            // -\n            \n            transmittance *= (1. - stepDensity);\n\n            if (transmittance < 0.01) {\n                break;\n            }\n        }\n        \n        samplePosition += mainStepAmount;\n    }\n    \n    return vec4(vec3(light), transmittance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = rY(vec3(0.0, 0.1, 1.0) * 2.5, iTime * 0.2);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 2.0 * cameraForward);\n    \n    // closest and farthest intersections, if any, with the bounding sphere\n    vec2 rayDistances = sphereIntersectionDistances(cameraPosition, rayDirection, vec3(0.), 1.);\n    \n    vec3 backgroundColor = vec3(0.1) - length(uv) * 0.04; // vignette\n    \n    if (rayDistances.x != 0. && rayDistances.y != 0.) {\n        vec3 farIntersection = cameraPosition + rayDirection * rayDistances.y;\n        \n        vec4 value = march(farIntersection, -rayDirection);\n        fragColor = vec4(mix(value.rgb, backgroundColor, value.w), 1.0);\n        \n        // containing ball\n        /*\n        vec3 nearIntersection = cameraPosition + rayDirection * rayDistances.x;\n        fragColor += pow(1.0 - abs(dot(rayDirection, nearIntersection)), 8.) * 0.3;\n\t\t*/\n    } else {\n        fragColor = vec4(backgroundColor, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcXWS.jpg", "access": "shaders20k", "license": "cc-by-2.5", "functions": [[104, 115, 141, 141, 281], [283, 397, 505, 505, 1702], [1789, 2868, 2889, 2889, 3058], [3060, 3060, 3086, 3086, 3911], [3994, 4071, 4094, 4094, 4179], [4181, 4181, 4203, 4203, 4342], [4345, 4367, 4402, 4402, 4678], [4680, 4680, 4710, 4710, 4897], [4899, 4899, 4938, 4938, 5449], [5452, 5573, 5614, 5614, 9347], [9349, 9349, 9406, 9406, 10731]], "test": "untested"}
{"id": "3ddSDB", "name": "N O R M B A L L S", "author": "xdaimon", "description": "a", "tags": ["norm"], "likes": 4, "viewed": 233, "published": "Public API", "date": "1572802382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float nrm(vec2 x, float p) {\n    x = abs(x);\n    float s = pow(pow(x.x,p)+pow(x.y,p),1./p);\n    return s;\n}\nfloat norm_balls(vec2 x, float p) {\n    return 2.*abs(mod(nrm(x*1.618,p)+iTime/2.,1.)-.5) - 1.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv *= 1.333;\n    uv.x *= iResolution.x/iResolution.y;\n    float p = iMouse.x/iResolution.x * 3.25+.75;\n    if (iMouse.z<=0.)\n        p = 1.;\n    fragColor = vec4(.02/abs(norm_balls(uv,p*p)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 107], [108, 108, 143, 143, 205], [206, 206, 263, 263, 511]], "test": "untested"}
{"id": "3ddSDs", "name": "bonemandel", "author": "mrange", "description": "Based upon: https://www.shadertoy.com/view/XdlSD4\n\nI always liked mandelbox_ryu made by EvilRyu\nWas tinkering a bit with the code and came up with this which at least I liked.\n", "tags": ["bonemandelbox"], "likes": 20, "viewed": 528, "published": "Public API", "date": "1573152879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based upon: https://www.shadertoy.com/view/XdlSD4\n\n// I always liked mandelbox_ryu made by EvilRyu\n// Was tinkering a bit with the code and came up with this which at least I liked.\n\n// Uses very simple occlusion based lighting which made it look more like a structure\n// of bones than my other futile lighting attemps.\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst vec3  folding_limit = vec3(1.0);\nconst float scale         = -2.8;\nconst int   max_iter      = 120;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvec3 pmin(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid box_fold(float k, inout vec3 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*pmin(abs(z), folding_limit, vec3(k));\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    const float k = 0.05;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(k/dr, z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));        \n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nfloat df(vec3 p) { \n    float d1 = mb(p);\n    return d1; \n} \n\n\nfloat hash(vec2 p)  {\n  float h = dot(p,vec2(127.1,311.7));   \n  return fract(sin(h)*43758.5453123);\n}\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n    float res;\n    float r = hash(ro.xy + ro.xz + ro.yz);\n    float t = 10.0*mix(0.01, 0.02, r);\n    iter = max_iter;\n    \n    for(int i = 0; i < max_iter; ++i) {\n        vec3 p = ro + rd * t;\n        res = df(p);\n        if(res < 0.001 * t || res > 20.) {\n            iter = i;\n            break;\n        }\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n    vec3 n = normal(p);\n    float fake = float(iter)/float(max_iter);\n    float fakeAmb = exp(-fake*fake*9.0);\n    float amb = ambientOcclusion(p, n);\n\n    vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n    return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n    col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n    vec2 q=fragCoord.xy/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x/iResolution.y; \n    \n    float stime=sin(iTime*0.1); \n    float ctime=cos(iTime*0.1); \n\n    vec3 ta=vec3(0.0,0.0,0.0); \n    vec3 ro= 0.63*vec3(3.0*stime,2.0*ctime,5.0+1.0*stime);\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  // transform from view to world\n\n    vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n    vec3 col = bg;\n\n    vec3 p=ro; \n\n    int iter = 0;\n  \n    float t = intersect(ro, rd, iter);\n    \n    if(t > -0.5) {\n        p = ro + t * rd;\n        col = lighting(p, rd, iter); \n        col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n    } \n    \n\n    col=post(col, q);\n    fragColor=vec4(col.x,col.y,col.z,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 551, 599, 599, 869], [871, 871, 906, 906, 994], [996, 996, 1050, 1094, 1174], [1176, 1176, 1207, 1207, 1231], [1233, 1233, 1262, 1262, 1327], [1330, 1330, 1348, 1348, 1848], [1850, 1850, 1868, 1868, 1909], [1913, 1913, 1934, 1934, 2015], [2017, 2017, 2066, 2066, 2446], [2448, 2448, 2488, 2488, 2690], [2692, 2692, 2718, 2718, 2926], [2928, 2928, 2970, 2970, 3212], [3214, 3214, 3243, 3243, 3502], [3504, 3504, 3562, 3562, 4430]], "test": "untested"}
{"id": "3ddXWl", "name": "fractalskew", "author": "ArthurSango", "description": "derp", "tags": ["fractal"], "likes": 1, "viewed": 206, "published": "Public API", "date": "1573342488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.1547*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n#define t iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \t\n    \n  \n    vec3 col = vec3( 1.);\n    \n    uv = abs( uv * 2. - 1. );\n   uv = skew(uv);\n    vec2 iuv = uv;\n    \n   // uv = fract( 5.* abs(sin(iTime+1.) + 1.) * uv );\n     uv = fract( 5. * uv );\n     uv = skew(uv);\n    iuv *= mat2( sin(iTime), 0.,0., sin(iTime) );\n    \n     uv *= mat2( cos(t), sin(t), -sin(t), cos(t) );\n    \n    float d = distance( uv, iuv);\n    \n    float dt = dot( uv, iuv) * length(uv);\n\n    col.x = uv.y;\n    col.y = d;\n    \n\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 108], [125, 125, 182, 232, 769]], "test": "untested"}
{"id": "3dGSD3", "name": "Twitch: Get Your Flu Shot", "author": "blackle", "description": "A very biological shader. Coded live on my twitch stream, watch the recording and tune in fridays to watch live! https://www.twitch.tv/videos/515076146", "tags": ["noise", "molecule", "health", "biology", "twitchstream"], "likes": 16, "viewed": 458, "published": "Public API", "date": "1575085565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat rand(float k) {\n  int x = FK(k);int y = FK(cos(k));\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 rand3(float k) {\n  float t1 = rand(k);\n  float t2 = rand(k+t1);\n  float t3 = rand(t1+t2);\n  return vec3(t1,t2,t3);\n}\n\nvec3 spherecords(vec2 p) {\n  float phi = acos(p.x);\n  float lamb = p.y*acos(-1.);\n  return vec3(cos(phi), sin(phi)*cos(lamb), sin(phi)*sin(lamb));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat comp(vec3 p, vec3 off, vec3 rot) {\n  float scale = 0.6 + sqrt(sin(iTime*2.)*0.5+0.5)*0.1;\n  vec3 ax = spherecords(rot.xy);\n  p = erot(p, ax, rot.z*acos(-1.));\n  p+=off;\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - scale*0.3;\n}\n\nvec3 mapp(vec3 p) {\n  for (int i = 0; i < 8; i++) {\n    vec3 off = spherecords(rand3(2.4*cos(float(i))).xy);\n    vec3 rot = rand3(5.1*float(i));\n    vec3 ax = spherecords(rot.xy);\n    off = erot(off, ax, iTime*0.1);\n    float offscale = 1. + sin(iTime*0.5);\n    p+=off*offscale;\n    p -= min(dot(off,p),0.)*off*2.; \n    p-=off*offscale;\n  }\n  return p;\n}\n\nfloat jort = 0.;\nfloat scene(vec3 p) {\n  p = mapp(p);\n  \n  float dist = 100000.;\n  for (int i = 0; i < 5; i++) {\n    float d = comp(p, rand3(float(i)), rand3(cos(float(i))));\n    if (d < dist) jort = float(i);\n    dist = smin(d,dist,0.1);\n  }\n  return (dist + max(length(p)-1.5,0.)*0.25);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat sharp(float k) {\n  return smoothstep(0.0,1.,k);\n}\n\nfloat fakereflection(vec3 p, vec3 cam) {\n  vec3 n = norm(p);\n  vec3 inc = reflect(cam, n);\n  float s1 = scene(p);\n  float avg = 0.;\n  float cum = 0.;\n  \n  for (int i = 0; i < 3; i++) {\n    float stp = 0.045*(float(i)+1.);\n    vec3 stped = p+inc*stp;\n    vec3 n2 = norm(stped);\n    stped = mapp(stped);\n    float brt = min(length(stped),2.)/2.;\n    avg += mix(0., mix(dot(n2,normalize(mapp(p)))*0.5+0.5,1.,brt*0.8), brt*0.3+0.7);//((s2-s1)/stp)*0.5+0.5\n    cum += 1.;\n  }\n  return sharp(avg/cum*0.95);\n}\n\nvec3 RED = vec3(0.9,0.2,0.2);\nvec3 BLUE = vec3(0.2,0.6,0.9);\n\nbool cros(vec2 p) {\n  p *= asin(sin(iTime/60.*140.*4.))*0.15+1.15;\n  p = abs(p);\n  vec2 p2 = vec2(min(p.y,p.x),max(p.y,p.x));\n  float sc = 1.5;\n  if (p2.x < 0.05*sc && p2.y < 0.15*sc) return true;\n  return false;\n}\n\nvec3 backgroundcol(vec2 uv) {\n  uv*=4.;\n  vec2 sc = vec2(0.4,0.7)*2.;\n  vec2 id = floor(uv/sc);\n  float off = iTime;\n  if (mod(id.x,2.)==mod(floor(off*0.5),2.)) {\n    uv.y+=0.5*sc.y;\n  } else {\n    uv.y;\n  }\n  uv = (fract(uv/sc)-0.5)*sc;\n  \n  return cros(uv) ? RED : vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(0.5,uv));\n  vec3 init = vec3(-8.+sin(iTime*0.7),0.,0.)+cam*0.8;\n  float ro = iTime;\n  cam = erot(cam, vec3(0,1,0), sin(ro)/7.);\n  init = erot(init, vec3(0,1,0), sin(ro)/7.);\n  cam = erot(cam, vec3(0,0,1), ro/3.);\n  init = erot(init, vec3(0,0,1), ro/3.);\n  vec3 p = init;\n  bool hit = false;\n  float k = 1.;\n  for (int i = 0; i < 200; i++) {\n    float dist = scene(p);\n    if (i == 0) k = sign(dist);\n    dist *= k;\n    if (abs(dist) < 0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) {hit=false;break;}\n    p += dist*cam;\n  }\n  float j = jort;\n  vec3 col = vec3(1);\n  \n\n  if (j == 0.) {\n    col = RED;\n  }\n  if (j == 1.) {\n    col = BLUE;\n  }\n  //hit = false;\n\n  fragColor.xyz = hit ? col*vec3(fakereflection(p, cam)) : backgroundcol(uv);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGSD3.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 249, 270, 270, 350], [352, 352, 373, 373, 473], [475, 475, 501, 501, 623], [625, 625, 663, 663, 727], [729, 729, 770, 770, 854], [856, 856, 896, 896, 1098], [1100, 1100, 1119, 1119, 1454], [1473, 1473, 1494, 1494, 1746], [1748, 1748, 1767, 1767, 1878], [1880, 1880, 1902, 1902, 1935], [1937, 1937, 1977, 1977, 2439], [2503, 2503, 2522, 2522, 2717], [2719, 2719, 2748, 2748, 2996], [2998, 2998, 3055, 3055, 3980]], "test": "untested"}
{"id": "3dGSDy", "name": "Mandelbrot😁SynapseHypeImaginary", "author": "rmmcal", "description": "Adding more imagination to the imaginary.... 😏\n=> Imagining the nonexistent.... 🤨\n( I hope I have not created a new set of numbers (nonexistent numbers).... 🤔) 😁  ¯\\_(ツ)_/¯  🤐  \n\nfork: https://www.shadertoy.com/view/WdyXWy", "tags": ["mandelbrot"], "likes": 5, "viewed": 94, "published": "Public", "date": "1574835007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n////      ... Mandelbrot-Synapse-HypeImaginary ...       ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus  \n// Mandelbrot-Synapse-HypeImaginary\n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/11\n// - https://www.shadertoy.com/view/3dGSDy\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  Adding more imagination to the imaginary\n//\n//      ... @rmmcal 2019/11\n//\n//  \n//  fork from: https://www.shadertoy.com/view/WdyXWy\n//\n//  wiki: https://en.wikipedia.org/wiki/Mandelbrot_set\n//\n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n \n\nfloat mandelbrot(vec2 uv)\n{\n    vec2 c = uv;\n    vec2 z = uv;\n    float maxSteps = 150.0;\n    float steps = 0.0;\n    for (steps = 0.0; steps<=maxSteps; ++steps)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (length(z) > 2.0) break;\n    }\n    return steps / maxSteps;\n}\n\nfloat mandelbrotImg(vec2 uv)\n{\n    vec2 c = uv;\n    vec2 z = uv;\n    float maxSteps = 150.0;\n    float steps = 0.0;\n    for (steps = 0.0; steps<=maxSteps; ++steps)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (2.0*z.x*z.y > 1000.0) break;\n       // if (length(z) > 2.0) break;\n    }\n    return steps / maxSteps;\n}\n\nvec2 mandelbrotVec2(vec2 uv)\n{\n    vec2 c = uv;\n    vec2 z = uv;\n    float maxSteps = 150.0;\n    float steps = 0.0;\n    for (steps = 0.0; steps<=maxSteps; ++steps)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        //if (2.0*z.x*z.y > 1000.0) break;\n        if (length(z) > 2.0) break;\n    }\n    return z;\n}\nvec2 mandelbrotImgVec2(vec2 uv)\n{\n    vec2 c = uv;\n    vec2 z = uv;\n    float maxSteps = 150.0;\n    float steps = 0.0;\n    for (steps = 0.0; steps<=maxSteps; ++steps)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (2.0*z.x*z.y > 1000.0) break;\n        //if (length(z) > 2.0) break;\n    }\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.5/exp(iTime/50.0);\n    uv += vec2(-0.406, 0.293);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float mr = mandelbrot(uv);\n    float mi = mandelbrotImg(uv);\n    vec2 mvr = mandelbrotVec2(uv);\n    vec2 mvi = mandelbrotImgVec2(uv);\n    \n    float vr = sqrt(sqrt(sqrt(abs(mr))));      // imaginating the imaginary\n    vr = pow(abs(vr), fract(iTime*.5)*2.+.5);\n  \tvr = vr / (1.-vr);\n\n    float vi = sqrt(sqrt(sqrt(abs(mi))));      // imaginating the hyper-imaginary  ^_^\n    vi = pow(abs(vi), fract(iTime*.5)*2.+.5);\n    vi = vi / (1.-vi);\n\n    vec3 c = vec3(cos(vi),cos(vi),cos(vi)*cos(vr)); // join (vi , vr)\n  \n    float mc = 1.-step(1.0, mr); \t// exists solution?\n    c *= mc; \t\t\t\t\t\t// remove nonexistent\n    \n    // imagining the nonexistent\n    {\n        c += vec3(cos(length(mvi)*200.+iTime))*(1.-mc);\n        //c -= vec3(cos(length(mvr)*200.+iTime))*(1.-mc); //  real - imaginary == null\n        \n        c -= vec3( (cos(length(mvi)*30.+iTime*2.))   )*(1.-mc)*vec3(1.,0.,0); // color animation\n    }\n        \n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 805, 832, 832, 1098], [1100, 1100, 1130, 1130, 1439], [1441, 1441, 1471, 1471, 1765], [1766, 1766, 1799, 1799, 2093], [2095, 2095, 2152, 2202, 3344]], "test": "untested"}
{"id": "3dGSWw", "name": "Tux Penguin Walking", "author": "edubart", "description": "This is my first ray marching shader, made it to learn ray marching and SDFs in practice.\nAll the tricks was learned by looking IQ articles, his shaders and youtube videos. (https://www.iquilezles.org/)\n\nAA can be changed at the top.\n\n\n", "tags": ["3d", "raymarching", "sdf", "animation"], "likes": 11, "viewed": 180, "published": "Public", "date": "1574115887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 100.0\n#define MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define M_PI 3.1415926535897932384626433832795\n#define AA 1\n//#define AA 2\n\n#define MATERIAL_BODY 1\n#define MATERIAL_BELLY 2\n#define MATERIAL_SKIN_YELLOW 3\n#define MATERIAL_EYE 4\n#define MATERIAL_FLOOR 5\n\nstruct Hit {\n    float d;\n    int material;\n};\n\n// Distance to sphere at origin of radius `r`\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Distance to capsule of radius `r` formed by line segment from `a` to `b`\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0);\n    return length(ap - ab*t) - r;\n}\n\n// Distance to plane at origin of normal `n`\nfloat sd_plane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\n// Distance to torus at origin of radius `r`\nfloat sd_torus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\n// Distance to ellipsoid at origin of radius `r`\nfloat sd_ellipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Distance to round cone\nfloat sd_round_cone(vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n      \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n      \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n          \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// Unite two SDFs smoothing\nfloat op_smooth_union(float d1, float d2, float k ) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Rotate vector `p` along the x axis at angle `t` (in radians)\nvec3 rotate_x(vec3 p, float t) {\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 a = mat3(\n        1.0,  0.0,  0.0,\n        0.0, cost,-sint,\n        0.0, sint, cost);\n    return a * p;\n}\n\n// Rotate vector `p` along the z axis by angle `t` (in radians)\nvec3 rotate_z(vec3 p, float t) {\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 a = mat3(\n         cost,-sint, 0.0,\n         sint, cost, 0.0,\n          0.0,  0.0, 1.0);\n    return a * p;\n}\n\n#define check_hit(m) if(dist < mindist) { material = m; mindist = dist; }\n\nvoid get_penguin_sdf(vec3 p, inout float mindist, inout int material) {\n    // body\n    float dist = op_smooth_union(\n        sd_ellipsoid(p - vec3(0.0, 1.0, 0.0), vec3(2.0, 2.2, 1.8)),\n        sd_sphere(p - vec3(0.0, 3.0, 0.0), 1.6), 0.5);\n\n    // arms\n    const vec3 larm_pos = vec3(-2.0, 2.0, 0);\n    const vec3 rarm_pos = larm_pos*vec3(-1.0, 1.0, 1.0);\n    const vec3 arm_radius = vec3(0.9, 0.3, 0.8);\n    dist = op_smooth_union(dist,\n        sd_ellipsoid(rotate_z(p - larm_pos, 0.7 + sin(iTime*10.0)*0.2), arm_radius), 0.1);\n    dist = op_smooth_union(dist,\n        sd_ellipsoid(rotate_z(p - rarm_pos,-0.7 + sin(iTime*10.0)*0.2), arm_radius), 0.1);\n\n    // rings around eyes\n    const vec3 leye_pos = vec3(-0.5, 3.2, 1.0);\n    const vec3 reye_pos = leye_pos*vec3(-1.0, 1.0, 1.0);\n    const vec3 leye_size = vec3(0.8, 0.9, 0.7);\n    const vec3 reye_size = vec3(0.8, 0.7, 0.7);\n    dist = op_smooth_union(dist,\n        sd_torus(rotate_x(p - leye_pos, M_PI/2.0), vec2(leye_size.x, 0.2)), 0.1);\n    dist = op_smooth_union(dist,\n        sd_torus(rotate_x(p - reye_pos, M_PI/2.0), vec2(reye_size.x, 0.2)), 0.1);\n\n    check_hit(MATERIAL_BODY);\n\n    // belly\n    dist = sd_ellipsoid(p - vec3(0.0, 1.0, 0.4), vec3(2.0, 2.2, 1.8)*0.9);\n    check_hit(MATERIAL_BELLY);\n\n    \n    // foot\n    const vec3 lfoot_pos = vec3(-1.2, -0.5, 1.9);\n    const vec3 rfoot_pos = vec3(-lfoot_pos.x, lfoot_pos.y, lfoot_pos.z);\n    const vec3 foot_radius = vec3(1.0, 0.6, 1.0);\n    dist = min(\n        sd_ellipsoid(rotate_x(p - lfoot_pos, sin(iTime*10.0)*0.3), foot_radius),\n        sd_ellipsoid(rotate_x(p - rfoot_pos, sin(iTime*10.0+M_PI)*0.3), foot_radius));\n\n    // beak\n    dist = min(dist, sd_round_cone(rotate_x(p - vec3(0.0, 2.5, 2.0), 3.3*M_PI/2.0), 0.1, 0.4, 0.6));\n    check_hit(MATERIAL_SKIN_YELLOW);\n\n    // eyes\n    dist = min(\n        sd_ellipsoid(p - leye_pos, leye_size), \n        sd_ellipsoid(p - reye_pos, reye_size));\n    check_hit(MATERIAL_EYE);\n\n    // retina\n    vec3 lretina_pos = vec3(-0.4 + sin(iTime)*0.1, 3.3, 1.63);\n    vec3 rretina_pos = vec3(0.4 - sin(iTime)*0.1, 3.3, 1.63);\n    dist = min(sd_ellipsoid(p - lretina_pos, vec3(0.2, 0.3, 0.1)),\n               sd_ellipsoid(p - rretina_pos, vec3(0.2, 0.25, 0.1)));\n    check_hit(MATERIAL_BODY);\n}\n\n// Return the closest surface distance to point p\nHit get_sdf(vec3 p) {\n    float mindist = MAX_DIST;\n    int material = 0;\n\n    // penguin\n    get_penguin_sdf(rotate_z(p, sin(iTime*10.0)*0.1), mindist, material);\n\n    // floor\n    float dist = sd_plane(p - vec3(0.0, -1.0, 0.0), normalize(vec3(0.0, 1.0, 0.0)));\n    check_hit(MATERIAL_FLOOR);\n\n    return Hit(mindist, material);\n}\n\n// Get normal at point `p` using the tetrahedron technique for computing the gradient\nvec3 get_normal(vec3 p) {\n    const float eps = 0.0001;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize(e.xyy*get_sdf(p + e.xyy*eps).d + \n                     e.yyx*get_sdf(p + e.yyx*eps).d + \n                     e.yxy*get_sdf(p + e.yxy*eps).d + \n                     e.xxx*get_sdf(p + e.xxx*eps).d);\n}\n\n// March a ray from `rayfrom` along the `raydir` direction and return the closet surface distance\nHit ray_march(vec3 rayfrom, vec3 raydir) {\n    // begin at ray origin\n    float t = 0.0;\n    Hit hit;\n    // ray march loop\n    for(int i=0; i<MAX_STEPS; ++i) {\n        // compute next march point\n        vec3 p = rayfrom+t*raydir;\n        // get the distance to the closest surface\n        hit = get_sdf(p);\n        // increase the distance to the closest surface\n        t += hit.d;\n        // hit a surface\n        if(hit.d < SURF_DIST || t > MAX_DIST)\n            break;\n    }\n    // return the distance to `rayfrom`\n    hit.d = t;\n    return hit;\n}\n\n// Hard shadows\nfloat hard_shadow(vec3 rayfrom, vec3 raydir, float tmin, float tmax) {\n    float t = tmin;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayfrom + raydir*t;\n        float h = get_sdf(p).d;\n        if(h < SURF_DIST)\n            return 0.0;\n        t += h;\n        if(t > tmax)\n            break;\n    }\n    return 1.0;\n}\n\n// Get occlusion along `normal` from point of view `rayfrom`\nfloat get_occlusion(vec3 rayfrom, vec3 normal) {\n    const int AO_ITERATIONS = 5;\n    const float AO_START = 0.01;\n    const float AO_DELTA = 0.11;\n    const float AO_DECAY = 0.95;\n    const float AO_INTENSITY = 2.0;\n\n    float occ = 0.0;\n    float decay = 1.0;\n    for(int i=0; i<AO_ITERATIONS; ++i) {\n        float h = AO_START + float(i) * AO_DELTA;\n        float d = get_sdf(rayfrom + h*normal).d;\n        occ += (h-d) * decay;\n        decay *= AO_DECAY;\n    }\n    return clamp(1.0 - occ * AO_INTENSITY, 0.0, 1.0);\n}\n\n// Return diffuse albedo color for material\nvec3 get_material_diffuse(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.0, 0.0, 0.0);\n        case MATERIAL_BELLY:\n            return vec3(0.6, 0.6, 0.6);\n        case MATERIAL_FLOOR: {\n            float checker = clamp(sin(p.x)*sin(p.y)*sin(p.z+iTime*4.0), 0.0, 1.0);\n            return vec3(0.4, 0.4, 0.4) * checker + vec3(0.1, 0.2, 0.2);\n        }\n        case MATERIAL_SKIN_YELLOW:\n            return vec3(1.0, .3, .01);\n        case MATERIAL_EYE:\n            return vec3(1.0, 1.0, 1.0);\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n// Return specular color for material\nvec3 get_material_specular(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.6, 0.6, 0.6);\n        case MATERIAL_SKIN_YELLOW:\n            return vec3(1.0, .6, .1);\n        case MATERIAL_EYE:\n            return vec3(1.0, 10.0, 1.0);\n        default:\n            return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n// Compute the scene light at a point\nvec3 get_light(vec3 raydir, vec3 p, int material) {\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    vec3 normal = get_normal(p);\n    float occlusion = get_occlusion(p, normal);\n\n    // sun light\n    const float SUN_INTENSITY = 1.5;\n    const float SUN_SHINESS = 10.0;\n    const vec3 SUN_POS = vec3(-10.0, 20.0, 10.0);\n    const vec3 SUN_COLOR = vec3(1.0,0.77,0.6);\n\n    vec3 sun_vec = SUN_POS - p;\n    vec3 sun_dir = normalize(sun_vec);\n    float sun_diffuse = clamp(dot(normal, sun_dir), 0.0, 1.0);\n    float sun_shadow = hard_shadow(p, sun_dir, 0.01, length(sun_vec));\n    float sun_specular = pow(clamp(dot(reflect(sun_dir, normal), raydir), 0.0, 1.0), SUN_SHINESS);\n\n    diffuse += SUN_COLOR * (sun_diffuse * sun_shadow * SUN_INTENSITY);\n    specular += SUN_COLOR * sun_specular;\n\n    // sky light\n    const float SKY_INTENSITY = 0.3;\n    const float SKY_SHINESS = 10.0;\n    const float SKY_MINIMUM_ATTENUATION = 0.5;\n    const vec3 SKY_COLOR = vec3(0.5, 0.7, 1.0);\n\n    float sky_diffuse = SKY_MINIMUM_ATTENUATION + SKY_MINIMUM_ATTENUATION * normal.y;\n    float sky_specular = pow(clamp(dot(reflect(vec3(0.0,1.0,0.0), normal), raydir), 0.0, 1.0), SKY_SHINESS);\n    diffuse += SKY_COLOR * (SKY_INTENSITY * sky_diffuse * occlusion);\n    specular += SKY_COLOR * (sky_specular * occlusion);\n\n    // fake indirect light\n    const float INDIRECT_INTENSITY = 0.2;\n    const float INDIRECT_SHINESS = 10.0;\n    const vec3 INDIRECT_COLOR = SUN_COLOR;\n\n    vec3 ind_dir = normalize(sun_dir * vec3(-1.0,0.0,-1.0));\n    float ind_diffuse = clamp(dot(normal, ind_dir), 0.0, 1.0);\n    float ind_specular = pow(clamp(dot(reflect(ind_dir, normal), raydir), 0.0, 1.0), INDIRECT_SHINESS);\n    diffuse += INDIRECT_COLOR * (ind_diffuse * INDIRECT_INTENSITY);\n    specular += INDIRECT_COLOR * (ind_specular * INDIRECT_INTENSITY);\n\n    // env light\n    const vec3 ENV_COLOR = SKY_COLOR;\n    const float ENV_INTENSITY = 0.3;\n    diffuse += ENV_COLOR * ENV_INTENSITY;\n\n    // apply material\n    vec3 col = diffuse * get_material_diffuse(p, material) +\n               specular * get_material_specular(p, material);\n\n    // gamma correction\n    col = pow(col, vec3(0.4545));\n\n    return col;\n}\n\n// Return camera transform matrix looking from `lookfrom` towards `lookat`, with tilt rotation `tilt`,\n// vertical field of view `vfov` (in degrees), at coords `uv` (in the range [-1,1])\nvec3 get_ray(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n    // camera up vector\n    vec3 vup = vec3(sin(tilt), cos(tilt), 0.0);\n    // camera look direction\n    vec3 lookdir = normalize(lookat - lookfrom);\n    // unit vector in camera x axis\n    vec3 u = cross(lookdir, vup);\n    // unit vector in camera y axis\n    vec3 v = cross(u, lookdir);\n    // vector in camera z axis normalized by the fov\n    vec3 w = lookdir * (1.0 / tan(vfov*M_PI/360.0));\n    // camera transformation matrix\n    mat3 t = mat3(u, v, w);\n    // camera direction\n    return normalize(t * vec3(uv, 1.0));\n}\n\nvec3 render(vec2 uv) {\n    vec3 lookfrom = vec3(0, 10, 30);\n    vec3 lookat = vec3(0, 1, 0);\n    vec3 raydir = get_ray(lookfrom, lookat, 0.0, 20.0, uv);\n    Hit hit = ray_march(lookfrom, raydir);\n    vec3 p = lookfrom + raydir * hit.d;\n    vec3 col = get_light(raydir, p, hit.material);\n    return col;\n}\n\nvec3 render_aa(vec2 uv) {\n#if AA > 1\n    float w = 1.0/iResolution.y;\n    vec3 col = vec3(0.0);\n    for(int n=0; n<AA*AA; ++n) {\n        vec2 o = 2.0*(vec2(float(int(n / AA)),float(int(n % AA))) / float(AA) - 0.5);\n        col += render(uv + o*w);\n    }\n    col /= float(AA*AA);\n    return col;\n#else\n    return render(uv);\n#endif\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n    // uv coords in range from [-1,1] for y and [-aspect_ratio,aspect_ratio] for x\n    vec2 uv = 2.0 * ((fragcoord-0.5*iResolution.xy) / iResolution.y);\n    // render the entire scene\n    vec3 col = render_aa(uv);\n    // set the finished color\n    fragcolor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 369, 403, 403, 431], [433, 509, 560, 560, 696], [698, 743, 775, 775, 799], [801, 846, 878, 878, 953], [955, 1004, 1040, 1040, 1129], [1131, 1157, 1215, 1215, 1497], [1499, 1527, 1580, 1580, 1677], [1679, 1743, 1775, 1775, 1940], [1942, 2006, 2038, 2038, 2206], [2283, 2283, 2354, 2366, 4532], [4534, 4584, 4605, 4605, 4915], [4917, 5003, 5028, 5028, 5308], [5310, 5408, 5450, 5477, 5961], [5963, 5979, 6049, 6049, 6305], [6307, 6368, 6416, 6416, 6888], [6890, 6934, 6983, 6983, 7545], [7547, 7585, 7635, 7635, 7932], [7934, 7972, 8023, 8023, 10156], [10158, 10345, 10420, 10444, 10945], [10947, 10947, 10969, 10969, 11251], [11253, 11253, 11278, 11278, 11585], [11587, 11587, 11642, 11725, 11917]], "test": "untested"}
{"id": "3dGSzG", "name": "http://zzart.3d2k.com/", "author": "mosaic", "description": "Generated from above website\nHit the spanner there and scroll down to export shadertoy code\nI just added an iTime to animate", "tags": ["2d"], "likes": 1, "viewed": 71, "published": "Public", "date": "1574242665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI=3.141592653589793;\nvec3 CosinePalette( float t, vec3 a, vec3 b, vec3 c, vec3 d ) { return a + b*cos( PI*2.*(c*t+d)); }\nvec4 lengthA(vec4 a)      { return vec4(length(a)); }\nvec4 asinA(vec4 a)        { return asin(clamp(a,-1.,1.)); }\nvec4 acosA(vec4 a)        { return acos(clamp(a,-1.,1.)); }\nvec4 logA(vec4 a)         { return log(abs(a)); }\nvec4 log2A(vec4 a)        { return log2(abs(a)); }\nvec4 sqrtA(vec4 a)        { return sqrt(abs(a)); }\nvec4 inversesqrtA(vec4 a) { return inversesqrt(abs(a)); }\nvec4 pow2(vec4 a)         { return a*a; }\nvec4 pow3(vec4 a)         { return a*a*a; }\n\nvoid mainImage(out vec4 a, in vec2 p)\n{\na=p.xyxy/iResolution.xyxy;\na.xywz *= vec2(-7.785, -8.657).xyxy;\na.xywz += vec2(-2.607, -9.299).xyxy;\nvec4 b = a;\n\n// Generated Code - Line Count: 15\na.zxyw = (b).wzzz;\nb.wzyx += cos(a+iTime).yzwx;\na.ywxz += (vec4(-3.875, 1.722, 0.055, -0.108)).yywy;\na.wyzx /= (vec4(2.236, 0.091, -6.245, 4.132)).zwwz;\na.xzwy += (b).wyzw;\nb.ywzx /= cos(b).yywy;\na.xzwy /= (b).yxyw;\nb.yzwx = normalize(b).ywyx;\nb.zwxy = pow3(a).zyzw;\na.wyzx /= (a).xwzz;\nb.xzwy -= pow3(b).zyxw;\nb.wyzx /= logA(vec4(-3.510, -0.258, 1.908, 9.090)).wyzw;\nb.yzxw -= (b).zxxy;\na.yzxw = exp(b).xxyx;\nb.ywxz += asinA(b).yzyw;\n\n// Cosine palettes by iq\na.x = a.x * -0.001+0.138;\na.xyz = b.x * CosinePalette(a.x,\n vec3(0.322, 0.917, 0.897),\n vec3(0.641, 0.263, 0.654),\n vec3(0.759, 0.294, 0.739),\n vec3(0.683, 0.658, 0.115));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGSzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 98, 98, 134], [135, 135, 162, 162, 188], [189, 189, 216, 216, 248], [249, 249, 276, 276, 308], [309, 309, 336, 336, 358], [359, 359, 386, 386, 409], [410, 410, 437, 437, 460], [461, 461, 488, 488, 518], [519, 519, 546, 546, 560], [561, 561, 588, 588, 604], [606, 606, 645, 645, 1429]], "test": "untested"}
{"id": "3dGSzR", "name": "A trip to the void", "author": "wessles", "description": " ", "tags": ["raymarching", "psychadelic"], "likes": 3, "viewed": 612, "published": "Public API", "date": "1573179229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ##########################\n// ### A trip to the void ###\n// ##########################\n//\n// As the name implies, this is a trippy demo I made messing\n// with raymarching. This code could be way more optimized.\n//\n// IF you want to know how it works, just mess with the flags\n// below and read the program.\n//\n// ----\n// 1.\n//   This is a lattice of spheres we are moving through\n// 2.\n//   I apply a hue shift based on how far the ray march goes\n// 3.\n//   I ray march, but each iteration i rotate the ray direction slightly\n//   the extent of this rotation is a sine function over time\n// 4.\n//   I mess with the FOV with a tan(mod(x, 3.14/2.)) function that makes\n//   the zoomy looking effect.\n\n\n#define CAM_ROTATE\n#define RAY_ROTATE\n#define WHACK_FOV\n#define WHACK_COLOR\n\n#define ITER 100\n#define BASE_FOV 2.0\n\n// distance function\n// returns distance from point p to nearest sphere\n// in infinite lattice\nfloat dist(vec3 p) {\n    p = fract(p) * 2.0 - 1.0;\n    return length(p) - (0.8);\n}\n\n// ray marching algorithm, with a modification:\n// if the RAY_ROTATE flag is defined, we can\n// rotate the ray's direction after each iteration.\n// *this is the primary source of \"whack\" in this shader*\nfloat march(vec3 o, vec3 r) {\n    float t = 0.0;\n    vec3 p = o;\n    for(int i = 0; i < ITER; i++) {\n        #ifdef RAY_ROTATE\n        float the = 0.04*sin(iTime/2.);\n        r.xy *= mat2(cos(the),-sin(the),sin(the),cos(the));\n        #endif\n        p = o+r*t;\n        t += dist(p)*0.5;\n    }\n    return t;\n}\n\n// hue2rgb function I ripped off.\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // this technically isn't FOV, it's the initial distance\n    // the ray is pushed outwards into the z axis before being\n    // normalized and marched.\n    // 0 values of X mean 180 degrees, infinite means 0 degrees.\n    float x = 1.0;\n    #ifdef WHACK_FOV\n    x = 0.1*tan(mod(iTime/10., 3.14/2.));\n    #endif\n    \n    // raycast with optional camera rotation\n    vec3 ray;\n    ray = normalize(vec3(uv,BASE_FOV*x));\n    float the = iTime/2.;\n    #ifdef CAM_ROTATE\n    ray.xy *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    #endif\n    \n    vec3 origin = vec3(0,0,iTime);\n    \n    float t = march(origin, ray);\n    \n    float fog = 1.0 / (1.0 + t*t*0.1);\n    \n    vec3 col = vec3(fog);\n    \n    // psychedelics ensue\n    #ifdef WHACK_COLOR\n    col*=hue2rgb(t*2.);\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[819, 914, 934, 934, 996], [998, 1201, 1230, 1230, 1509], [1511, 1604, 1628, 1628, 1737], [1739, 1739, 1796, 1846, 2791]], "test": "untested"}
{"id": "3dGXD1", "name": "Wavy Crystal", "author": "ShnitzelKiller", "description": "Experimenting with hybrid raytracing/raymarching for perturbed surfaces. For each bounce, first raytrace, then do a bit of raymarching to find the exact depth and normal.", "tags": ["raytracing", "raymarching", "reflection", "refraction", "glossy"], "likes": 6, "viewed": 308, "published": "Public API", "date": "1573854089", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n\n#define SPHERESPACING 0.25\n#define SPHEREGRID 0.01\n\n#define RADIUS 1.\n\n#define ABSORPTION_RATE vec3(0.9, 0.8, 0.8)\n#define IOR 1.33\n#define LOW_SCATTER 0.001\n#define HIGH_SCATTER 0.03\n#define SAMPLES 25\n#define REFLECTIONS 3\n#define RAYMARCH_STEPS 15\n#define RAYMARCH_TOL 0.005\n\n#define TIME_T 6.\n#define TIME_H 6.\n#define TIME_L 6.\n\n\nfloat oscillate(float t_low, float t_high, float t_transition, float t_offset) {\n    float t_osc = 0.5*(t_high+t_low)+t_transition;\n    float h_l = 0.5*t_low/t_osc;\n    float h_h = (0.5*t_low+t_transition)/t_osc;\n    return smoothstep(0., 1., (clamp(abs(mod(iTime + t_offset, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n}\n\n/*vec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}*/\n\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 ni, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return vec2(-1.);\n    ni = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    no = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nfloat sphere(in vec3 ro, in vec3 rd, in float r, in bool entering, out vec3 n) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return -1.;\n    float tdiff = sqrt(disc);\n    float t = -pd + (entering ? -tdiff : tdiff);\n    n = normalize(ro + t * rd);\n    \n    return t;\n}\n\nfloat spheresdf(in vec3 ro, in float r) {\n    float mag = 0.02 * oscillate(TIME_L*.5, TIME_H*.5, TIME_T*0.5, -2.);\n    return length(ro) - r + mag*(sin(ro.y*20. + iTime*1.32)+1.);\n}\n\nvec3 spheregrad(in vec3 ro, in float r) {\n    vec2 diff = vec2(RAYMARCH_TOL, 0.);\n    float dx = spheresdf(ro + diff.xyy, r) - spheresdf(ro - diff.xyy, r);\n    float dy = spheresdf(ro + diff.yxy, r) - spheresdf(ro - diff.yxy, r);\n    float dz = spheresdf(ro + diff.yyx, r) - spheresdf(ro - diff.yyx, r);\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat hybridsphere(in vec3 ro, in vec3 rd, in float r, in bool entering, out vec3 n) {\n    float t = sphere(ro, rd, r, entering, n);\n    if (t > 0.) {\n        for (int i=0; i<RAYMARCH_STEPS; i++) {\n            float dist = spheresdf(ro + t*rd, r);\n            t += (entering ? dist : -dist);\n            if (dist < RAYMARCH_TOL) {\n                n = spheregrad(ro + t*rd, r);\n                return t;\n            }\n        }\n    }\n    return -1.;\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\nvec3 z_to_vec(in vec3 d, in vec3 z) {\n    vec3 u = normalize(cross(vec3(0., 0., 1.), d));\n    vec3 v = cross(d, u);\n    return u * z.x + v * z.y + d * z.z;\n}\n\n//raytrace the exterior surroundings\nvec4 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    vec3 col1;\n    if (t < 0.) {\n        t = 1000.;\n        col1 = bgcol(rd);\n    } else {\n        vec2 uv = ro.xy+t*rd.xy;\n        if (max(abs(uv.x), abs(uv.y)) > 8.) col1 = bgcol(rd);\n        else {\n            vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n            float aofac = smoothstep(0., 1.25, length(uv));\n            col1 = mix(vec3(0.2), vec3(0.8), min(checkers.x,checkers.y)) * (1.-0.5*(1.-aofac));\n        }\n    }\n    \n    vec3 ni;\n    float voffset = abs(0.8*sin(1.4*iTime));\n    float t2 = sphere(ro - vec3(0.6 + RADIUS, 0., -0.4 + voffset), rd, 0.6, true, ni);\n    vec3 spherero = t2 * rd + ro - vec3(0., 0., voffset);\n    vec3 spherech = smoothstep(vec3(SPHEREGRID*0.75), vec3(SPHEREGRID), abs(mod(spherero, vec3(SPHERESPACING))*2.-SPHERESPACING));\n    float tea = mix(t, t2, step(0., t2));\n    return vec4(mix(col1, mix(vec3(1., 0., 0.), mix(vec3(1.), vec3(0.5, 0.6, 0.8), spherero.z+1.), min(spherech.x, min(spherech.y, spherech.z))), step(0., t2)), tea);\n}\n\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nvec2 GetRandom2(){return vec2(GetRandom(), GetRandom());}\n\nvec3 randnorm(vec2 seed) {\n    vec2 utheta = GetRandom2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime*sin(iTime) + (fragCoord.x+iResolution.x*fragCoord.y)/(iResolution.y);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni;\n    float t = hybridsphere(eye, rd, RADIUS, true, ni);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    vec4 bgg = background(eye, rd);\n    \n    if (t > 0. && t < bgg.w) {\n        \n        float osc = oscillate(TIME_L, TIME_H, TIME_T, 0.);\n        float SCATTER_FACTOR = mix(LOW_SCATTER, HIGH_SCATTER, osc);\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec3 n = randnorm(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6));\n            // reflection\n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, ni), 5.);\n            vec3 rdr = mix(reflect(rd, ni), normalize(n + ni), SCATTER_FACTOR);\n            vec3 reflcol = background(ro, rdr).xyz;\n            \n            // refraction, absorption and internal reflection\n            vec3 rd_refr = mix(refract(rd, ni, 1./IOR), normalize(n-ni), SCATTER_FACTOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            vec3 ro_refr = ro;\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                \n                vec3 ni2, no2;\n                float tout = hybridsphere(ro_refr, rd_refr, RADIUS, false, no2);\n                ro_refr = ro_refr + tout * rd_refr;\n                vec3 randno2 = normalize(n + no2);\n                vec3 rd_refr_out = mix(refract(rd_refr, -no2, IOR), randno2, SCATTER_FACTOR);\n\n                float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rd_refr_out, no2), 5.);\n                           \n            \trd_refr = mix(reflect(rd_refr, -no2), randno2, SCATTER_FACTOR);\n                transmission *= pow(ABSORPTION_RATE, vec3(tout));\n            \tinsidecol += accum * (1.-fresnel2) * background(ro_refr, rd_refr_out).xyz * transmission;\n                accum *= fresnel2;\n            }    \n            \n            \n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(bgg.xyz, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 507, 507, 758], [760, 899, 970, 970, 1402], [1404, 1404, 1484, 1484, 1716], [1718, 1718, 1759, 1759, 1899], [1901, 1901, 1942, 1942, 2246], [2248, 2248, 2334, 2334, 2698], [2700, 2700, 2724, 2724, 2803], [2805, 2805, 2842, 2842, 2962], [2964, 3001, 3042, 3042, 4131], [4145, 4145, 4163, 4163, 4204], [4205, 4205, 4223, 4223, 4262], [4264, 4264, 4290, 4290, 4465], [4467, 4467, 4524, 4524, 7277]], "test": "untested"}
{"id": "3dGXRW", "name": "Pacman (Demosplash 2019)", "author": "blackle", "description": "made this in 25 minutes in front of an audience for Demosplash 2019's shader showdown.  The pulsating background is optimized for a 138 bpm song.\n\nhttps://www.youtube.com/watch?v=ik3T37fCydo", "tags": ["pacman", "shadershowdown", "demosplash", "liveshader", "livecode"], "likes": 7, "viewed": 428, "published": "Public API", "date": "1573481179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\nint x = FK(p.x);int y = FK(p.y);\nreturn float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat maze(vec2 p) {\nvec2 id = floor(p);\nfloat sgn = sign(hash(id));\np = fract(p)-0.5;\nreturn abs(abs(p.x+p.y*sgn)-0.5)/sqrt(2.);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\nreturn distance(p, mix(a, b, clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.)));\n}\n\nfloat scene(vec3 p) {\nvec2 crds = vec2(maze(p.xy), p.z);\nfloat walls = linedist(crds, vec2(0,0),vec2(0,1));\nreturn min(walls-0.05, p.z);\n}\n\nfloat light(vec3 p, vec3 l) {\nreturn pow(max(0., scene(p)-scene(p+l*0.01))/0.01,2.);\n}\n\nvoid pac(vec2 uv, inout vec3 col) {\nuv.y = abs(uv.y);\nif (length(uv) > 1.) return;\nif (atan(uv.x/uv.y) < -1. - sin(iTime*12.)*0.35-0.2) return;\ncol = vec3(1.,1.,0.);\n}\n\nvoid goast(vec2 uv, inout vec3 col, vec3 colgo) {\nvec2 head = vec2(0,0.2);\nif (length(uv-head+vec2(0.5,0)) < 0.1) {col = vec3(0); return;}\nif (length(uv-head-vec2(0.3,0)) < 0.1) {col = vec3(0); return;}\nif (length(uv-head+vec2(0.4,0)) < 0.2) {col = vec3(1); return;}\nif (length(uv-head-vec2(0.4,0)) < 0.2) {col = vec3(1); return;}\nif (abs(uv.x) > 0.8) return;\nif (uv.y < -1.) return;\nif (uv.y > .2 && length(uv - head) > 0.8) return;\nfloat tail = asin(sin((uv.x + floor(iTime)*3.)*20.))*0.05;\nif (uv.y+tail < -0.9) return;\ncol = colgo;\n}\n\nvec3 colgo4t(float t) {\nt = mod(t ,4.);\nif (t < 1.) return vec3(1.,0.,0.);\nif (t < 2.) return vec3(0.,1.,1.);\nif (t < 3.) return vec3(1.,0.5,0.);\nif (t < 4.) return vec3(0.7,0.,1.);\nreturn vec3(0.);\n}\n\nfloat bpm = 23.*6.;\n\nvoid dots(vec2 uv, float bt, inout vec3 col) {\nfloat old = uv.x;\nuv.x = fract(uv.x)-0.5;\nif (length(uv) > smoothstep(0.,1., bt+12.)*0.1) return;\nif (old+bt > 0.) return;\ncol = vec3(1.,1.,0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\nvec2 olduv = uv*10.;\n\nfloat beat =  fract(iTime/60.*bpm);\n\nuv = vec2(uv.x*sign(uv.y), -abs(uv.y));\nvec3 cam =normalize(vec3(0.5 + beat*0.03,uv));\nvec3 init = vec3(-4.+iTime,iTime/10.,2.);\nvec3 p = init;\nbool hit = false;\nfor (int i = 0; i< 100; i++) {\nfloat dist = scene(p);\nif (abs(dist) < 0.001) { hit = true; break; }\n\np += cam*dist;\n}\nfloat l = light(p, cam);\nvec3 col = hit ? vec3(0.2,0.4,1)*l: vec3(0);\nfragColor = vec4(col ,0);\n\nfloat bt = (fract((iTime+2.5)/5.)-0.5)*30.;\nfloat bk = floor((iTime+2.5)/5.);\nvec2 anim = olduv + vec2(bt,0.);\npac(anim, fragColor.xyz);\ndots(olduv, bt, fragColor.xyz);\ngoast(anim - vec2(3,0), fragColor.xyz, colgo4t(bk));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGXRW.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 249, 269, 269, 344], [346, 346, 366, 366, 477], [479, 479, 519, 519, 592], [594, 594, 615, 615, 732], [734, 734, 763, 763, 820], [822, 822, 857, 857, 989], [991, 991, 1040, 1040, 1528], [1530, 1530, 1553, 1553, 1730], [1753, 1753, 1799, 1799, 1946], [1949, 1949, 2006, 2006, 2803]], "test": "untested"}
{"id": "3dKSDR", "name": "Enchanted Family of Mushrooms", "author": "imanbell", "description": "-", "tags": ["forest", "mushroom", "glowing", "magical", "enchanted"], "likes": 6, "viewed": 138, "published": "Public", "date": "1573773268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define EPSILON 0.001\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Credit to the awesome iq for sdf-related functions\n\n/*** HELPER FUNCTIONS ***/\n\nfloat smoothUnion(in float iSDF1, in float iSDF2, in float iTransitionSize) {\n    \n \tfloat h = clamp(0.5 + 0.5*(iSDF2 - iSDF1)/iTransitionSize, 0.0, 1.0);\n    return mix(iSDF2, iSDF1, h) - iTransitionSize*h*(1.0 - h);   \n    \n}\n\nfloat roundedConeSDF(in vec3 iPoint, in float iSmallRadius, in float iBigRadius, in float iHeight) {\n    \n    vec2 q = vec2(length(iPoint.xz), iPoint.y);\n    \n    float b = (iBigRadius - iSmallRadius)/iHeight;\n    float a = sqrt(1.0 - b*b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.0) return length(q) - iBigRadius;\n    if (k > a*iHeight) return length(q - vec2(0.0, iHeight)) - iSmallRadius;\n\n    return dot(q, vec2(a, b)) - iBigRadius;\n    \n}\n\n/*** MUSHROOM FUNCTIONS ***/\n\nfloat stemSDF(in vec3 iPoint, vec2 iPosition, in float iRadius, in float iStemHeight) {\n\t\n    // The stem is a capped cylinder with a varying radius    \n    float d = length(iPoint.xz - iPosition) - iRadius*(1.0 + 0.05*cos(2.0*iPoint.y + iPoint.z));\n    d = max(d, -iStemHeight + abs(iPoint.y));\n    return d;\n    \n}\n\nfloat capSDF(in vec3 iPoint, vec2 iPosition, in float iRadius, in float iStemHeight, in float iTiltingAngle) {\n    \n    // We first apply the inverse of the slight tilting rotation we want to the point\n    \n    float c = cos(0.3*iTiltingAngle);\n    float s = sin(0.5*iTiltingAngle);\n    \n    mat3 tiltingMatrix = transpose(mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0)));   \n\n    vec3 tiltedPoint = tiltingMatrix*iPoint;\n    \n    // A cap is a smooth union between a rounded cone and a flattened half sphere\n    \n    float coneSdf = roundedConeSDF(tiltedPoint - vec3(iPosition.x, iStemHeight, iPosition.y), 0.2*iRadius, 0.4*iRadius, 2.0*iStemHeight);\n    \n    float sphereSdf = length(tiltedPoint - vec3(iPosition.x, 0.01*iStemHeight, iPosition.y)) - iRadius;\n\n    float d = smoothUnion(coneSdf, sphereSdf, 2.0);\n    \n    // We apply a small displacement on the surface of the cap\n    \n    vec2 normalizedPoint = normalize(tiltedPoint.xz - iPosition);\n    float cosTheta = normalizedPoint.x;\n    float sinTheta = normalizedPoint.y;\n    float theta = acos(cosTheta)*sign(sinTheta);\n  \n    d -= max(0.0, 0.38*abs(cos(8.0*theta) - 0.5) - 0.5);\n    d = max(d, iStemHeight - tiltedPoint.y);\n    \n    return d;\n    \n}\n\nfloat mushroomSDF(in vec3 iPoint, vec2 iPosition, in float iStemRadius, in float iStemHeight, in float iCapRadius, in float iTiltingAngle) {\n    \n    float d = min(stemSDF(iPoint, iPosition, iStemRadius, iStemHeight),\n\t\t\t\tcapSDF(iPoint, iPosition, iCapRadius, iStemHeight, iTiltingAngle));\n    return d;\n    \n}\n            \nfloat allMushroomsSDF(in vec3 iPoint) {\n    \n    float d = mushroomSDF(iPoint, vec2(-0.5, -3.0), 0.6, 2.0, 4.0, 0.1);\n    d = min(d, mushroomSDF(iPoint, vec2(-8.0, 3.0), 1.1, 1.8, 4.0, -0.2));   \n    d = min(d, mushroomSDF(iPoint, vec2(4.0, 1.0), 1.0, 1.6, 3.0, 0.3));\n    d = min(d, mushroomSDF(iPoint, vec2(-7.5, -7.0), 0.5, 1.0, 2.0, 0.1));\n\td = min(d, mushroomSDF(iPoint, vec2(-2.5, -9.0), 0.25, 1.0, 0.8, -0.15));\n    return d;\n    \n}\n\nfloat rayMarchMushrooms(in vec3 iOrigin, in vec3 iRay) {\n    \n \tfloat t = 0.0;\n    vec3 p = iOrigin;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = iOrigin + t*iRay;\n     \tfloat sdist = allMushroomsSDF(p);\n        t += sdist;\n        if (abs(sdist) < EPSILON) {\n            break;\n        }\n    }\n    return t;\n    \n}\n\nvec3 computeMushroomDiffuseColor(in vec3 iPoint) {\n    \n    vec3 softPink = vec3(0.9, 0.6, 0.9);\n    vec3 softBlue = vec3(0.5, 1.0, 1.0);    \n    vec3 color = mix(softPink, softBlue, iPoint.y/0.9);\n    color *= 2.4*texture(iChannel0, (iPoint.xz - 10.0)*0.1).xyz;\n    return color;\n    \n}\n\n/*** FLYING ORB FUNCTIONS ***/\n\nvec3 orbPosition0;\nvec3 orbPosition1;\nvec3 orbPosition2;\nvec3 orbPosition3;\n\nfloat orbSDF(in vec3 iPoint, in vec3 iPosition, in float iRadius) {\n    \n    // An orb is a simple sphere    \n\treturn length(iPoint - iPosition) - iRadius;   \n    \n}\n\nfloat allOrbsSDF(in vec3 iPoint) {\n    \n    float d = orbSDF(iPoint, orbPosition0, 0.15);\n    d = min(d, orbSDF(iPoint, orbPosition1, 0.1));\n    d = min(d, orbSDF(iPoint, orbPosition2, 0.05));\n    d = min(d, orbSDF(iPoint, orbPosition3, 0.1));\n    return d;\n    \n}\n\n/*** GROUND FUNCTIONS ***/\n\nfloat groundSDF(in vec3 iPoint) {\n    \n    // Using a texture as a height map to roughen up the ground    \n    float height = texture(iChannel1, (iPoint.xz + vec2(10.0))*0.2).x;\n    return iPoint.y + 1.1 + 0.1*height;\n    \n}\n\nvec3 computeGroundDiffuseColor(in vec3 iPoint) {\n    \n    return texture(iChannel0, (iPoint.xz + vec2(10.0))*0.05).xyz;\n \n}\n\n/*** COMPUTE NORMALS ***/\n\nfloat sceneSDF(in vec3 iPoint) {\n    \n    float d = min(allMushroomsSDF(iPoint), allOrbsSDF(iPoint));\n    d = min(d, groundSDF(iPoint));\n    return d;\n    \n}\n\nvec3 computeNormal(in vec3 iPoint) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(iPoint.x + EPSILON, iPoint.y, iPoint.z)) - sceneSDF(vec3(iPoint.x - EPSILON, iPoint.y, iPoint.z)),\n        sceneSDF(vec3(iPoint.x, iPoint.y + EPSILON, iPoint.z)) - sceneSDF(vec3(iPoint.x, iPoint.y - EPSILON, iPoint.z)),\n        sceneSDF(vec3(iPoint.x, iPoint.y, iPoint.z  + EPSILON)) - sceneSDF(vec3(iPoint.x, iPoint.y, iPoint.z - EPSILON))\n    ));\n    \n}\n\n/*** RAY MARCHING ***/\n\nfloat rayMarch(in vec3 iOrigin, in vec3 iRay, inout int ioObjectHit) {\n    \n \tfloat t = 0.0;\n    vec3 p = iOrigin;\n\t\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = iOrigin + t*iRay;\n     \tfloat m = allMushroomsSDF(p);\n     \tfloat o = allOrbsSDF(p);\n     \tfloat g = groundSDF(p);\n\t\t\n\t\tfloat depth = min(min(o, m), g);\n\t\t// We hit an orb\n\t\tif (o < m && o < g) {\n\t\t\tdepth = o;\n\t\t\tioObjectHit = 2;\n\t\t} \n\t\t// We hit a mushroom\n\t\tif (m < o && m < g) {\n\t\t\tdepth = m;\n\t\t\tioObjectHit = 1;\n\t\t}\n\t\t// We hit the ground\n\t\tif (g < o && g < m) {\n\t\t\tdepth = g;\n\t\t\tioObjectHit = 0;\n\t\t}\t\t\n        t += depth; \n        if (abs(depth) < EPSILON) {\n            break;\n        }\n    }\n\t\n    return t;\n    \n}\n\n/*** LIGHTING AND SHADOWS ***/\n\n// The scene's 2 static lights\n\nvec3 lightPosition0 = vec3(15.0, 25.0, -15.0);\nvec3 lightColor0 = vec3(0.4, 0.7, 1.0);\n\nvec3 lightPosition1 = vec3(-15.0, 15.0, 15.0);\nvec3 lightColor1 = vec3(0.8, 0.0, 0.8);\n\n// Computes the shadow created by a particular light\nvec3 computeShadow(in vec3 iPoint, in vec3 iLightPosition) {\n    \n    vec3 ray = normalize(iLightPosition - iPoint);\n    float d = rayMarchMushrooms(iPoint, ray);\n    return vec3(1.0 - 1.0/(1.0 + 0.03*d*d));\n    \n}\n\n// Only mushrooms cast shadows\n// Only static lights create shadows\n// Only the ground receives shadows\nvec3 computeAllShadows(in vec3 iPoint) {\n    \n    vec3 shadow = computeShadow(iPoint, lightPosition0);\n    shadow *= computeShadow(iPoint, lightPosition1);\n    return shadow;\n    \n}\n                                \n// Basic Phong-type lighting\n// Compute the lighting of a particular light\nvec3 computeLighting(in vec3 iLightPosition, in vec3 iLightColor, in vec3 iDiffuseColor, in vec3 iPoint, in vec3 iNormal, in vec3 iOrigin, in bool iAttenuated) {\n\t\n    vec3 pointToLight = iLightPosition - iPoint;\n    float distanceToLight = length(pointToLight);\n    vec3 pointToLight_n = normalize(pointToLight);\n    vec3 reflected = reflect(-pointToLight_n, iNormal);\n    vec3 pointToOrigin_n = normalize(iOrigin - iPoint);\n    float lambertian = max(dot(pointToLight_n, iNormal), 0.0);        \n        \n\tfloat specular = 0.0;\n  \n\tif(lambertian > 0.0) {\n    \tfloat angle = max(dot(reflected, pointToOrigin_n), 0.0);\n    \tspecular = pow(angle, 16.0);\n\t}\n  \t\n    // We soften the lighting if it's too harsh\n    if (iAttenuated) \n\t\treturn 20.0*iLightColor*vec3(lambertian*iDiffuseColor + specular*vec3(1.0, 1.0, 1.0))/(1.0 + distanceToLight*distanceToLight);          \n\telse\n  \t\treturn iLightColor*vec3(lambertian*iDiffuseColor + specular*vec3(0.0, 1.0, 1.0));          \n\n}\n\n// Computes the lighting of the scene using all the light sources: 4 orbs and 2 static lights\nvec3 computeAllLighting(in vec3 iPoint, in vec3 iNormal, in vec3 iOrigin, in vec3 iDiffuseColor) {\n\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    \n    vec3 col = computeLighting(orbPosition0, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(orbPosition1, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(orbPosition2, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(orbPosition3, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)\n        + computeLighting(lightPosition0, lightColor0, iDiffuseColor, iPoint, iNormal, iOrigin, false)\n        + computeLighting(lightPosition1, lightColor1, iDiffuseColor, iPoint, iNormal, iOrigin, false);\n\n    return col;\n    \n}\n\n/*** VIEWPOINT ***/\n\n// Computing the matrix needed to transform the ray in world space\nmat4 viewToWorldMatrix(in vec3 iEyePosition, in vec3 iTarget, in vec3 iUpDirection) {\n\t\n    vec3 f = -normalize(iTarget - iEyePosition);\n\tvec3 s = normalize(cross(f, iUpDirection));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 2.0*uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Defining the origin and ray of the raymarching algorithm\n    vec3 target = vec3(-3.0, -3.0, 8.0);\n    vec3 origin = vec3(5.0, 25.0, -40.0);    \n    mat4 rayMatrix = viewToWorldMatrix(origin, target, vec3(0.0, 1.0, 0.0));    \n    vec3 ray = vec3(rayMatrix*vec4(normalize(vec3(uv, 5.0)), 0.0));\n\n    // Defining orb parameters\n    orbPosition0 = vec3(4.0*cos(iTime) - 2.5, -0.5, 6.0*sin(iTime));\n    orbPosition1 = vec3(5.5*cos(iTime + 2.0) - 2.5, 8.0, 6.0*sin(iTime + 2.5));\n    orbPosition2 = vec3(5.0*cos(iTime + 5.0) - 2.5, 7.0, 6.0*sin(iTime + 5.0));\n    orbPosition3 = vec3(13.0*cos(iTime + 3.0) - 2.5, 2.5, 9.0*sin(iTime + 3.0));\n    \n    // Color of the point hit by the ray\n    vec3 diffuseColor;\n    \n\t// This represents the object hit\n\t// 0: ground\n\t// 1: mushroom\n\t// 2: orb\n\tint objectHit = -1;\n    \n    // Depth of the closest point hit by the ray\n\tfloat depth = rayMarch(origin, ray, objectHit);\n\t\n\tvec3 point = origin + depth*ray;    \n    vec3 normal = computeNormal(point);\n\t\n    // Determining the color\n\tswitch (objectHit) {\n\t\tcase 0:\n\t\t\tdiffuseColor = computeGroundDiffuseColor(point);\n\t\t\tdiffuseColor *= computeAllShadows(point);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdiffuseColor = computeMushroomDiffuseColor(point);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tdefault:\n\t\t\tdiffuseColor = vec3(1.0, 1.0, 0.0);\n\t\t\tbreak;\n\t}\n\t\n    // Shading\n    vec3 finalColor = computeAllLighting(point, normal, origin, diffuseColor);\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 202, 279, 279, 429], [431, 431, 531, 531, 884], [886, 916, 1003, 1068, 1232], [1234, 1234, 1344, 1435, 2459], [2461, 2461, 2601, 2601, 2771], [2785, 2785, 2824, 2824, 3224], [3226, 3226, 3282, 3282, 3550], [3552, 3552, 3602, 3602, 3839], [3841, 3950, 4017, 4059, 4115], [4117, 4117, 4151, 4151, 4381], [4383, 4411, 4444, 4517, 4635], [4637, 4637, 4685, 4685, 4760], [4762, 4789, 4821, 4821, 4946], [4948, 4948, 4984, 4984, 5394], [5396, 5420, 5490, 5490, 6112], [6354, 6407, 6467, 6467, 6621], [6623, 6727, 6767, 6767, 6908], [6942, 7017, 7178, 7178, 7989], [7991, 8085, 8183, 8183, 8844], [8867, 8934, 9019, 9019, 9239], [9241, 9241, 9298, 9298, 10888]], "test": "untested"}
{"id": "3dKSRD", "name": "formation", "author": "mahalis", "description": "a project for Nodevember day 12, “Paper”.", "tags": ["raymarch", "paper", "origami", "nodevember"], "likes": 4, "viewed": 289, "published": "Public API", "date": "1573575380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nvec3 opRepeatLimited(vec3 p, vec3 spacing, vec3 limit) {\n    return p - spacing * clamp(round(p / spacing), -limit, limit);\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n// -----------------\n\nfloat planeDistance(vec3 position) {\n    vec3 wingP = position.xzy * vec3(2.0,1.5,2.0);\n    wingP.x = abs(wingP.x);\n    wingP.z -= 0.3 * wingP.x; // tilt by skewing the space\n    \n    float wingDistance = sdTriPrism(wingP, vec2(1.0,0.02));\n    \n    vec3 bodyP = position.yzx * vec3(4.0,1.5,1.0);\n    \n    float bodyDistance = max(sdTriPrism(bodyP, vec2(1.0, 0.01)), dot(position, vec3(0.0,1.0,0.0)));\n    \n    return min(wingDistance, bodyDistance);\n}\n\nfloat d(vec3 position) {\n    vec3 warpedPosition = position + sin(position.x * 2.0 + iTime * 2.3) * 0.1;\n    return planeDistance(rZ(opRepeat(warpedPosition, vec3(2.0)), cos(iTime * 1.2) * 0.15));\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize((vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x);\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance * 0.4, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(0.3, 0.9, 0.9));\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    const float diffuse = 0.8;\n    vec3 ambience = mix(vec3(0.2,0.25,0.3), vec3(0.2,0.4,0.6), dot(normal, vec3(0., 1., 0.)) * -0.5 + 0.5);\n    const float specular = 0.6;\n    vec3 color = vec3((ndotL * diffuse + pow(ndotH, 2.) * specular) + ambience);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, -0.05, 0.0);\n    vec3 cameraPosition = vec3(0.75,0.6,1.5);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    cameraPosition += iTime * vec3(0.0,-0.2,-1.0);\n    \n    vec4 marchResult = march(cameraPosition, rayDirection, 0.001);\n    vec3 backgroundColor = mix(vec3(0.4,0.75,1.0), vec3(0.2,0.5,0.9), (uv.y + 0.5));\n    if (marchResult.w > 0.0) {\n        fragColor = vec4(backgroundColor, 1.0); // “sky” color\n    } else {\n        vec3 position = marchResult.xyz;\n        float fogDistance = max(0., length(position - cameraPosition) - 4.);\n        vec3 litColor = lightSurface(position, gradient(position, marchResult.w), -rayDirection);\n        \n        fragColor = vec4(mix(litColor, backgroundColor, 1.0 - exp(-fogDistance * 0.1)), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 11, 57, 57, 166], [168, 168, 199, 199, 288], [290, 290, 323, 323, 351], [353, 353, 390, 390, 436], [438, 438, 494, 494, 563], [565, 565, 598, 598, 625], [627, 627, 660, 660, 686], [688, 688, 721, 721, 747], [749, 749, 775, 775, 914], [916, 916, 942, 942, 1082], [1084, 1084, 1110, 1110, 1249], [1251, 1251, 1287, 1287, 1370], [1372, 1394, 1430, 1430, 1845], [1847, 1847, 1871, 1871, 2045], [2047, 2047, 2079, 2079, 2215], [2217, 2217, 2266, 2266, 2708], [2710, 2710, 2769, 2769, 3259], [3261, 3261, 3318, 3318, 4447]], "test": "untested"}
{"id": "3dKXRy", "name": "Mister Softəə", "author": "desertsky", "description": "the platonic ice cream reactor", "tags": ["raymarching", "experiment", "noob"], "likes": 2, "viewed": 197, "published": "Public API", "date": "1574314768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 1\nvec2 r(vec2 ax, float a){return mat2(cos(a),-sin(a),sin(a),cos(a))*ax;}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p.xz =  r(p.xz,(-p.y*9.*sin(iTime)));\n  p.xz =  r(p.xz,sin(iTime)*6.);\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat checkers(vec2 p)\n{\n    vec2 w = fwidth(p) + .001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5/sin(iTime*0.1))-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\t//p.yz = r(p.yz, .45+iTime);\n  \tvec2 q = vec2(length(p.xz)-t.x,p.y);  \n    return length(q)-t.y;\n}\n\nfloat gimbal(vec3 pos)\n{\n    vec3 t1p = pos, t2p = pos, t3p = pos; \n    t1p.xy = r(t1p.xy,.45+sin(iTime*3.)*t1p.x*1.3+iTime);\n    t2p.yz = r(t2p.yz,.45-cos(iTime*3.)*t2p.y*1.5-iTime);\n    t3p.xy = r(t3p.xy,.45+cos(iTime*3.)*t3p.z*1.7-iTime);\n    t3p.xy = r(t3p.xy,.45+sin(iTime*3.)*t3p.x*1.7+iTime);\n    float torus1 = sdTorus(t1p,vec2(.27,.0125));\n    float torus2 = sdTorus(t2p,vec2(.25,.0125));\n    float torus3 = sdTorus(t3p,vec2(.2,.0125));    \n    float gimbal = min(torus1, min(torus2, torus3));\n    return gimbal;\n}\n\n\nvec2 map(vec3 pos) \n{\n    vec3 inf = mod(pos+1.5,3.)-1.5;\n    float plane = 1.4+pos.y+sin((pos.x)/2.333+iTime+cos((pos.z)/2.333+iTime));\n\t//float plane = 3.+pos.y;\n    float oct = sdOctahedron(pos,.12);\n    \n    float g = gimbal(pos);\n    float scene = oct;\n    float MAT = 0.;\n    scene = min(scene,plane);\n\tscene = min(scene,g);\n //   \tscene = min(scene,k);\n    if(scene == oct) MAT = 1.; \n    else if(scene == plane) MAT = 0.;\n    else if(scene == g) MAT = 2.;\n    return vec2(scene, MAT);\n}\n\n\nvec2 RM(vec3 ro, vec3 rd) \n{\tfloat MAT = 0.;\n    float dO = 0.0;\n    for(int i = 0; i < 128; i++) \n    {\n    \tvec2 t = map(ro + rd* dO);\n        if (abs(t.x) < .001) break;        \n        dO+=t.x;\n        MAT = t.y;\n        if(dO > 20.) break;\n    }    \n    return vec2(dO,MAT);\n}\n\nvec3 n(vec3 pos)\n{\n    vec2 d = map(pos);\n    vec2 e = vec2(.001,.0);\n    vec3 pn = d.x - vec3(\n        map(pos-e.xyy).x,\n        map(pos-e.yxy).x,\n        map(pos-e.yyx).x\n        );\n    return normalize(pn);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 l(vec3 pos)\n{\n    vec3 nor = n(pos);\n\tvec3 total = vec3(0.);\n    vec3 sundir = normalize(vec3(3.,15.,0.));\n    float AO = calcAO(pos,nor);\n    total+= clamp(pow(dot(nor,sundir),.2),.0,1.)*vec3(.9,.7,.5) *AO; //sun\n\ttotal+= clamp(dot(nor,vec3(.0,1.,0.)),.0,1.)*vec3(.3,.5,.7)*.15*AO; //sky\n\ttotal+= clamp(dot(nor,-sundir),.0,1.)*vec3(.9,.7,.5)*.01*AO;//bounce\n    total*= calcSoftshadow( pos, sundir, 0.02, 2.5 );\n    return(total);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec3 ro = vec3(sin(iTime/2.),.3+sin(iTime/2.)*cos(iTime/2.)*.75,cos(iTime/2.));\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 ww=normalize(ta-ro),uu=normalize(cross(ww,vec3(0.,1.,0.))), vv=normalize(cross(uu,ww));       \n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n        \n    vec2 r = RM(ro,rd);\n    vec3 p = ro + rd * r.x;\n\n    vec3 col = vec3(0);\n\t//objects\n    if(r.x<20.)\n    {\n        \n        // octa\n        if(r.y == 1.) \n        {\n\t        //lighting\n        \tcol+=vec3(l(p));\n            \n            //reflection\n            ro = p+n(p)*.06;\n            rd = normalize(reflect(rd, n(p)));\n\t\t\tvec2 rf = RM(ro,rd);\n            vec3 prf = ro+rd*rf.x;\n            col+=l(prf)*5.*vec3(p.y,p.x,cos(iTime)*p.x*p.y);\n            \n        }\n        //gimbal\n        else if(r.y == 2.) \n        {\n\t        //lighting\n        \tcol+=vec3(l(p));\n\n            //coloring\n            col+=vec3(p.y,p.x,cos(iTime)*p.x*p.y);        \n          //plane\n        } else if (r.y == 0.) {\n            float le = smoothstep(.0,5.,p.x-.5);\n            col+=(checkers(p.xz*3.));            \n            }\n    }\n    //bg\n    else \n    {\n        float l = smoothstep(.0,5.,p.y+3.5);\n        col = mix(vec3(.5,.5,1.),vec3(.3,.5,.9),l);\n       \t//fog\ncol = mix( col, vec3(0.9), 1.0-exp( -0.001*p*p ) );\n    }\n    \n    col = pow(col,vec3(.4545));\n        //tot += col;\n      //  tot /= float(AA*AA);\n    //}\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 38, 38, 84], [86, 86, 124, 124, 250], [252, 252, 276, 276, 436], [439, 439, 472, 502, 572], [574, 574, 598, 598, 1097], [1100, 1100, 1121, 1121, 1594], [1597, 1597, 1625, 1625, 1878], [1880, 1880, 1898, 1898, 2091], [2092, 2092, 2134, 2134, 2447], [2448, 2510, 2588, 2611, 2995], [2997, 2997, 3015, 3015, 3435], [3437, 3437, 3494, 3494, 4989]], "test": "untested"}
{"id": "3dKXWK", "name": "Animated 2D Grid", "author": "foez", "description": "wanted to draw a 3d grid, had no idea how to do it so tried doing it in 2d", "tags": ["2d", "grid"], "likes": 2, "viewed": 240, "published": "Public", "date": "1575013030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float a = iResolution.x/iResolution.y;\n   \n\n    vec3 col = vec3(0);\n    float time = iTime;\n\t\n    float pw = 2./iResolution.y;\n    // comment the next two lines to get the grid without animation\n  \tuv.y += sin((uv.x/a)*3.14*5.+10.*sin(time*2.))*0.1;\n    uv *= rot(time*0.1);\n    \n    vec2 gv = (fract(uv*2.)-0.5)/2.;\n\n    col += smoothstep(0., 2.*pw, abs(abs(gv.y)-0.25));\n    col *= smoothstep(0., 2.*pw, abs(abs(gv.x)-0.25));\n    if(uv.x > 0. && uv.y > 0.) {\n        col *= vec3(0.95, 0.5, 0.5); \n    }\n    \n    if(uv.x < 0. && uv.y < 0.) {\n        col *= vec3(234, 255, 208)/256.0;\n    }\n    \n    if(uv.x > 0. && uv.y < 0.) {\n        col *= vec3(149, 225, 211)/256.0;\n    }\n    \n    if(uv.x < 0. && uv.y > 0.) {\n        col *= vec3(252, 227, 138)/256.0;\n    }\n     \n    \n    col = pow(col, vec3(1./2.2) );\n   \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 154, 204, 1112]], "test": "untested"}
{"id": "3dKXWR", "name": "[TWITCH] Keke Tribute", "author": "Flopine", "description": "A tribute to the AWESOME french artist keke flipnote : https://twitter.com/Kekeflipnote\nMade during a live twitch here : https://www.twitch.tv/flopine", "tags": ["raymarching", "dithering", "keke", "baguette", "pigeon"], "likes": 9, "viewed": 187, "published": "Public", "date": "1573771259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define PI 3.141592\n#define time iTime\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// iq website https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat ellipse( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat vcaps( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length(p) - r;\n}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\n#define anim(t, sp, st) (fract(t*sp)*st*(1.-(fract(t*sp))))\n\nfloat head (vec3 p)\n{\n    float y = anim(time, 4.,3.);\n    float v =  vcaps(p-vec3(0.,y*0.2,0.), 0.4, 0.2);\n\n    return v;\n}\n\nfloat eyes (vec3 p)\n{\n    float y = anim(time, 4.,3.);\n    p.y -= 0.6;\n    p.z += 0.1;\n    p.x = abs(p.x)-0.15;\n\n    return length(p+vec3(0.,y*0.2,0.))-0.05;\n}\n\nfloat mouth (vec3 p)\n{\n    float y = anim(time, 4.,3.);\n    p.y -= 0.5;\n    p.z += 0.18;\n    return od (p+vec3(0.,y*0.2,0.), 0.05);\n}\n\nfloat body (vec3 p)\n{\n    p.y -=.5;\n    float y = anim(time,4.,3.);\n\n    float sy = 0.6+y;\n    float sxz = 1./sy;\n    return ellipse(p+vec3(0.,y*0.5,0.), vec3(0.5*sxz,0.5*sy,0.5*sxz));\n}\n\nfloat feets (vec3 p)\n{\n    p.y += 1.4;\n    p.x = abs(p.x)+0.2;\n    p.x -= anim(p.y,1., anim(time, 4., 18.))*0.2+.3;\n    return vcaps(p, 1.,0.05);\n}\n\nfloat baguette (vec3 p)\n{\n\n    float per = 0.6;\n    p.x = abs(p.x);\n    p.x -= 2.;\n    p.xz *= rot(time*5.);\n    vec3 pp = p;\n    p.z += 0.2;\n    p.y = mod(p.y, per)-per*0.5;\n    float c = length(p.yz)-(0.15-abs(p.x)*0.1);\n\n    p = pp;\n    p.y += 1.1;\n    return max(-c,vcaps(p,2.2, .2));\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    float f = feets(p);\n    float b = body(p+vec3(0.,.45,0.));\n    float h = head(p);\n    float e = eyes(p);\n    float m = mouth(p);\n    float ba = baguette(p);\n\n    float d = min(min(e,m),min(f,min(h, b)));\n    d = min(d, ba);\n\n    if (d == f || d == m) mat_id = 1;\n    if (d == b || d == h) mat_id = 2;\n    if (d == e) mat_id = 3;\n    if (d == ba) mat_id = 4;\n\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat lighting (vec3 n, vec3 l)\n{\n    return max(0.,dot(n, l));\n}\n\nfloat background (vec2 uv)\n{\n    float per = .9;\n\n    vec2 id = floor(uv/per);\n    uv = mod(uv,per)-per*0.5;\n    uv.x = abs(uv.x)-0.05;\n    uv *= rot(-PI/4.);\n\n    return step(length(uv*vec2(1.,0.5)),clamp(sin(length(id*2.)-time),0.05,0.15));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.,0.,-4.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = normalize(vec3(1.,2.,-3.)),\n        col = mix(vec3(0.97),vec3(.95,0.,0.),background(uv*8.));\n\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<ITER;i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n\n        p += d*rd*0.5;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = floor(lighting(n, l)*3.)/3.;\n        if (mat_id == 1) col = mix(vec3(0.5,0.3,0.),vec3(0.8,0.8,0.),light);\n        if (mat_id == 2) col = mix(vec3(0.2,0.2,0.3),vec3(0.5,0.5,0.6),light);\n        if (mat_id == 3) col = vec3(0.); \n        if (mat_id == 4) col = mix(vec3(0.5,0.2,0.1),vec3(0.8,0.8,0.5),light);\n        col  *= vec3(1.-shad);\n    }\n\n    float dit = texture(iChannel0, fragCoord.xy/8.).r;\n\n    float detail = 4.;\n    col += dit/detail;\n    col = floor(col*detail)/detail;\n\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 369, 389, 389, 432], [434, 520, 553, 553, 642], [644, 644, 685, 685, 746], [748, 748, 776, 776, 813], [876, 876, 897, 897, 1000], [1002, 1002, 1023, 1023, 1161], [1163, 1163, 1185, 1185, 1296], [1298, 1298, 1319, 1319, 1484], [1486, 1486, 1508, 1508, 1633], [1635, 1635, 1660, 1660, 1925], [1939, 1939, 1959, 1959, 2338], [2340, 2340, 2363, 2363, 2477], [2479, 2479, 2512, 2512, 2544], [2546, 2546, 2574, 2574, 2790], [2792, 2792, 2849, 2849, 4024]], "test": "untested"}
{"id": "3dtXDB", "name": "Horizontal scroller", "author": "oktomus", "description": "With the help of https://casual-effects.com/research/McGuire2019ProcGen/McGuire2019ProcGen.pdf", "tags": ["glsl"], "likes": 3, "viewed": 92, "published": "Public", "date": "1572981338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\n// Map functions.\n//\n// From https://github.com/msfeldstein/glsl-map.\n//\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat safeMap(float value, float inMin, float inMax, float outMin, float outMax)\n{\n    if (value > inMax)\n        return outMax;\n    else if (value < inMin)\n        return outMin;\n    else\n        return map(value, inMin, inMax, outMin, outMax);\n}\n\n\n//\n// Random functions\n//\n\nuint hash(uint x) \n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat random(uint hashed_value) \n{\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n    \n    hashed_value &= mantissaMask;\n    hashed_value |= one;\n\n    float  r2 = uintBitsToFloat(hashed_value);\n    return r2 - 1.0;\n}\n\n\nfloat random(float f) \n{    \n    return random(hash(floatBitsToUint(f)));\n}\n\nfloat random(vec2 v)\n{\n    uint hashed =\n        hash(\n            floatBitsToUint(v.x) \n            ^ hash(floatBitsToUint(v.y)));\n    return random(hashed);\n}\n\nfloat random(vec3 v)\n{\n    uint hashed =\n        hash(\n            floatBitsToUint(v.x) \n            ^ hash(floatBitsToUint(v.y))\n            ^ hash(floatBitsToUint(v.z)));\n    return random(hashed);\n}\n\n//\n// Utility functions.\n//\n\nfloat noise(float x) \n{\n    float \ti = floor(x), \n        \tf = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);    \n    return 2.0 * mix(random(i), random(i + 1.0), u) - 1.0;\n}\n\n//\n// Advanced functions.\n//\n\nvoid getSkyColor(vec2 uv, inout vec3 color)\n{\n    float h = max(0.0, 1.4 - uv.y - pow(abs(uv.x - 0.5), 3.0));\n    color.r = pow(h, 3.0);\n    color.g = pow(h, 7.0);\n    color.b = 0.2 + pow(max(0.0, h - 0.1), 10.0);    \n}\n\nfloat terrain(float x)\n{   \n    x += 0.1;\n    float y = 0.0;\n    float k;\n    for (int octave = 0; octave < 7; ++octave)\n    {\n        k = pow(2.0, float(octave));\n        y += noise(x * k) / k;\n    }\n\treturn y * 0.6 + 0.8;\n}\n\nfloat water(float x)\n{   \n    x += 0.5;\n    float y = 0.0;\n    float k;\n    for (int octave = 0; octave < 10; ++octave)\n    {\n        k = pow(2.0, float(octave));\n        y += noise(x * k) / k;\n    }\n\treturn y * 0.05 + 0.4;\n}\n\nfloat tree(float x, float h)\n{\n  \n    float k;\n    float y = noise(x * 81.5);\n    \n    return safeMap(h, 0.45, 0.55, 0.0, 1.0) * max(0.0, y * 0.2);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float shift = 0.09 * iTime + 0.2;\n    float x = uv.x + shift;\n\n    vec3 col;\n    \n    float h = max(water(x), terrain(x));\n    h += tree(x, h);\n    \n    if (uv.y < h)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n    \tgetSkyColor(uv, col);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 78, 156, 156, 231], [233, 233, 305, 305, 380], [382, 382, 454, 454, 529], [531, 531, 603, 603, 678], [680, 680, 762, 762, 927], [930, 957, 977, 977, 1108], [1110, 1110, 1144, 1144, 1365], [1368, 1368, 1392, 1392, 1443], [1445, 1445, 1467, 1467, 1605], [1607, 1607, 1629, 1629, 1808], [1810, 1839, 1862, 1862, 2015], [2017, 2047, 2092, 2092, 2266], [2268, 2268, 2292, 2292, 2493], [2495, 2495, 2517, 2517, 2720], [2722, 2722, 2752, 2752, 2877], [2879, 2879, 2936, 2986, 3345]], "test": "untested"}
{"id": "3dVSRm", "name": "4.8^2 Truchet Weave", "author": "fizzer", "description": "A 'weaved' version of my 4.8^2 semi-regular Truchet tiling ([url=https://www.shadertoy.com/view/MlyBRG]this one[/url]).", "tags": ["truchet", "tiling", "weaving", "weave", "octagon"], "likes": 12, "viewed": 203, "published": "Public", "date": "1573733871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a 'weaved' version of my 4.8^2 semi-regular truchet tiling, which\n// you can see here: https://www.shadertoy.com/view/MlyBRG\n\nconst float pi = 3.141592653589;\nconst float r = .02;\nconst float r2 = .005;\nconst float slope = .1;\nconst vec2 dir = vec2(.1, slope);\nconst float r3 = (r + r2 * 0.15) / (dir.x / length(dir));\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\nfloat arcDistance(vec2 p, vec2 a, vec2 b)\n{\n    if(abs(a.x * b.y - a.y * b.x) < 1e-5)\n        return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return abs(distance(p, o) - r);\n}\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    float d = arcDistance(p, a, b);\n    return smoothstep(0.03, 0.03 - w * 2., d - .04);\n}\n\n// Based on https://www.shadertoy.com/view/llGSzw\nuint hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n\nvoid sdRope(vec2 p, out float mask_d, out float outline_d)\n{    \n    float pd = dot(p, vec2(dir.y, -dir.x)) / ((r + r2 * 0.15) * 2. * length(dir));\n    \n    p.y += 2. * r3 * floor(pd) + r3;\n    \n    vec2 q = dir * clamp(dot(p, dir) / dot(dir, dir), -.5, +.5);\n    \n    float d = distance(p, q) - r;\n    \n    mask_d = d - r2;\n    outline_d = min(max(-d, abs(p.x) - r * 3.), abs(d) - r2);\n}\n\nvec4 arcDistanceRope(vec2 p, vec2 a, vec2 b)\n{\n    float mask_d;\n    float outline_d;\n    float mask2;\n\n    float sr = r3 * 2.;\n\n    if(abs(a.x * b.y - a.y * b.x) < 1e-5)\n    {\n    \tfloat ld = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        \n        vec2 n = normalize(b - a);\n\n        float da = dot(a, n);\n        float db = dot(b, n);\n        float d = dot(p, n);\n        \n        vec2 q = vec2(dot(p, -vec2(n.y,-n.x)), mix(round(da / sr) * sr, round(db / sr) * sr, (d - da) / (db - da)));\n\n        sdRope(q + vec2(0., r3), mask_d, outline_d);\n\n        mask2 = ld-.05;\n    }\n    else\n    {    \n        vec2 o;\n        float r;\n        solveCircle(a, b, o, r);\n        \n        vec2 nm = normalize((a + b) / 2. - o);\n        \n        vec2 na = normalize(a - o);\n        vec2 nb = normalize(b - o);\n        vec2 np = normalize(p - o);\n\n        float tha = asin(na.x * nm.y - na.y * nm.x) * r;\n        float thb = asin(nb.x * nm.y - nb.y * nm.x) * r;\n        float th = asin(np.x * nm.y - np.y * nm.x) * r;\n\n        vec2 q = vec2(length(p - o) - r, mix(round(tha / sr) * sr, round(thb / sr) * sr, (th - tha) / (thb - tha)));\n\n        sdRope(q + vec2(0., r3), mask_d, outline_d);\n\n        mask2 = abs(distance(p, o) - r)-.05;\n    }\n\n    vec3 col = vec3(mix(vec3(.02), vec3(.8), smoothstep(0.0, w, outline_d)));\n    \n    return vec4(col, 1. - smoothstep(0.0, w, mask2 - 0.05));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 6. + iMouse.xy / iResolution.xy * 10.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    float el = tan(2. * pi / 16.);\n    float hyp = sqrt(1. - el * el);\n    float d = cos(2. * pi / 16.) * hyp;\n\n    vec2 ip = floor(p - .5) * 2.;\n    vec2 fpa = abs(fract(p) - .5);\n    vec2 fp = fract(p - .5) - .5;\n\n    vec4 a = vec4(vec3(.8), 0.);\n    float b = hash(ip);\n    float c = 0.;\n\n    uint num_inds = 0U;\n    float th = 0., thoffset = 0.;\n    float r = 1.;\n\n    if(fpa.x + fpa.y < (1. - sqrt(2.) / 2.))\n    {\n        // Square.\n        ip = floor(p) * 2. +1.;\n        b = hash(ip);\n        fp = fract(p) - .5;\n        if(b > .5)\n            fp = fp.yx * vec2(1, -1);\n\n        num_inds = 4U;\n        th = pi * 2. / 4.;\n        r = .5 * d;\n        thoffset = th / 2.;\n\n        c = max(c, smoothstep((1. - sqrt(2.) / 2.) - w * sqrt(2.) * 2., (1. - sqrt(2.) / 2.), max(abs(fp.x + fp.y), abs(fp.y - fp.x))));\n    }\n    else\n    {\n        // Octagon.\n        th = floor(mod(b,.25)/.25*8.) * pi * 2. / 8.;\n        fp *= mat2(cos(th), sin(th), -sin(th), cos(th));\n\n        th = pi * 2. / 8.;\n\n        num_inds = 8U;\n\n        float d = max(abs(fp.x + fp.y) / sqrt(2.), abs(fp.y - fp.x) / sqrt(2.));\n        c = max(c, smoothstep(.5 - w * 2., .5, max(d, max(abs(fp.x), abs(fp.y)))));\n    }\n\n    \n    // Shuffle the indices by using the Fisher-Yates algorithm\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    uint inds[8];\n    \n\tinds[0] = 0U;\n    \n    uint seed = uint(ip.x + ip.y * 8192.)*319U;\n    for(uint j = 1U; j < num_inds; ++j)\n    {\n        seed = hash1(seed);\n        uint k = seed % j;\n        uint temp = inds[k];\n        inds[k] = j;\n        inds[j] = temp;\n    }\n\n    // Draw the arcs.\n    \n    for(uint j = 0U; j < num_inds; j += 2U)\n    {\n        uint ia = inds[j];\n        uint ib = inds[j + 1U];\n        vec2 pa = vec2(cos(th * float(ia) - thoffset), sin(th * float(ia) - thoffset)) * r / 2.;\n        vec2 pb = vec2(cos(th * float(ib) - thoffset), sin(th * float(ib) - thoffset)) * r / 2.;\n        vec4 d = arcDistanceRope(fp, pa, pb);\n        a = mix(a, d, d.a);\n    }\n    \n    \n    // Shade.\n    vec3 col = mix(vec3(1), vec3(.3), c);\n\n    float l = 1. - (min(fract(iTime / 6.) * 2., 2. - 2. * fract(iTime / 6.)) - .5) * 16.;\n\n    fragColor.rgb = mix(a.rgb, a.rgb * col, (1. - a.a) * smoothstep(0., 1., l));\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 376, 396, 396, 453], [455, 729, 787, 787, 873], [875, 875, 918, 918, 1145], [1147, 1207, 1240, 1240, 1331], [1333, 1383, 1406, 1449, 1540], [1543, 1543, 1603, 1603, 1931], [1933, 1933, 1979, 1979, 3347], [3349, 3349, 3404, 3404, 5935]], "test": "untested"}
{"id": "3dVSRV", "name": "headache_001", "author": "Windless", "description": "First shader.", "tags": ["headache001"], "likes": 5, "viewed": 71, "published": "Public", "date": "1574447688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      \n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n    \n  float a = iTime / 15.0 + cos(iTime/3.0 + cos(iTime)/4.0)/7.0 + cos(length(uv) * 5.0 - iTime/3.0)/10.0;\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  \n\n  \n  uv = m * uv;\n\n  \n  float c1 =  cos(uv.x * 40.0 * (6.0 + cos(iTime/3.0 + 1.0)) / (2.0 + sin(uv.y*4.0+ iTime)/4.0) + iTime);\n  float c2 =  cos((uv.y * 40.0 * (6.0 + cos(iTime/3.0)) + 20.0 * sin(uv.x/3.0 + iTime/4.0) * 3.0) / (2.0 + sin(uv.x*2.0+ iTime)/4.0) + iTime);\n  \n  fragColor.x = c1;\n  fragColor.z = (1.0 - c1 + c2) / 2.0;\n  fragColor.y = c2;\n      \n  fragColor = round(fragColor * 4.0) / 4.0;\n\n\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 710]], "test": "untested"}
{"id": "3dVSWR", "name": "Donuts from outer space", "author": "Jarazz", "description": "recreation of ashurbanipalscabin's art", "tags": ["2ddistortion"], "likes": 4, "viewed": 128, "published": "Public", "date": "1573777321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NOISINESS   .445\n#define HUEOFFSET   .53\n#define DONUTWIDTH .3\n//imported functions: \n//https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\t//2D simplex\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}  \n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//helper functions:\nvec2 cartesian2polar(vec2 cartesian){\n\treturn vec2(atan(cartesian.x,cartesian.y),length(cartesian.xy));\n}\n\nvec2 polar2cartesian(vec2 polar){\n\treturn polar.y*vec2(cos(polar.x),sin(polar.x));\n}\n\n vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n }\n\nfloat sdTorus2D(float distToMid,float radius,  float thickness){\t//returns the distance to a torus, with the distance to the torus center, its radius and thiccness as inputs\nreturn abs(distToMid- radius)-thickness;\n}\n\nfloat donutFade(float distToMid,float radius,  float thickness){\t//returns in the domain [0,1] from the inner edge 0 to the outer edge 1 of the torus  \nreturn clamp( (distToMid-radius)/thickness+.5,0.,1.);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     uv*=3.; \t\t\t\t\t//zoom\n    \n    uv += noise(uv+(iTime+sin(iTime*.1)*10.+vec2(cos(iTime*.144),sin(iTime*.2)*14.))*.2)*NOISINESS;\t//map distortion+ movement\n  // uv/= 1.+  (iTime/2.)*2.;\n    vec2 uvPol = cartesian2polar(uv);\n    //vec3 col = 0.5 +.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0.  );\n    \n    float colorAccumulation =  .5;\n    float result = sin(uv.y);\n \t\n     \n    float torus = donutFade(uvPol.y, fract(iTime/3. )*5. ,DONUTWIDTH);   //pulsating donut\n    float contribution =  min(smoothstep(torus ,1.,.95),smoothstep(torus , .0 ,.05) );\t//determine how much this area is affected by torus1\n    colorAccumulation += contribution ; \n    col +=  hsv2rgb(vec3(torus *1.3 +HUEOFFSET,1.,1.)) *contribution ;\n\n    \n     torus = donutFade(uvPol.y, .5,DONUTWIDTH); \n     contribution =  min(smoothstep(torus ,1.,.95),smoothstep(torus , .0 ,.05) );\t//determine how much this area is affected by torus1\n    colorAccumulation += contribution ; \n    col +=  hsv2rgb(vec3(torus *1.3 +HUEOFFSET,1.,1.)) *contribution ;\n\n    torus = donutFade(uvPol.y, 1.1, DONUTWIDTH); \n    contribution =  min(smoothstep(torus ,1.,.95),smoothstep(torus , .0 ,.05) );\t//determine how much this area is affected by torus1\n    colorAccumulation += contribution ; \n    col +=  hsv2rgb(vec3(torus *1.3 +HUEOFFSET,1.,1.)) *contribution ;\n\n    torus = donutFade(uvPol.y, 1.5, DONUTWIDTH); \n    contribution =  min(smoothstep(torus ,1.,.95),smoothstep(torus , .0 ,.05) );\t//determine how much this area is affected by torus1\n    colorAccumulation += contribution ; \n    col +=  hsv2rgb(vec3(torus *1.3 +HUEOFFSET,1.,1.)) *contribution ;\n\n    \n     //col /= colorAccumulation;\t\t//for making the background white, use this line and initialize col as .5\n     //col = vec3(contribution1,contribution1,contribution1) ;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 134, 191, 191, 306], [308, 308, 347, 347, 826], [829, 953, 976, 976, 1061], [1063, 1083, 1120, 1120, 1188], [1190, 1190, 1223, 1223, 1274], [1277, 1277, 1299, 1299, 1468], [1470, 1470, 1494, 1494, 1940], [1942, 1942, 2006, 2115, 2158], [2160, 2160, 2224, 2311, 2367], [2372, 2372, 2429, 2429, 4323]], "test": "untested"}
{"id": "3dVSzD", "name": "Circle pettern", "author": "MadcoreTom", "description": "circle patterns", "tags": ["pattern"], "likes": 0, "viewed": 82, "published": "Public", "date": "1573549015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    uv *= vec2(9.0, 5.0);\n    \n    float limit = (sin(iTime + uv.x*uv.y)*0.25+0.75) * 0.3;\n    vec2 sub = vec2(mod(uv.x,1.0), mod(uv.y,1.0));\n    \n    vec2 c = sub * 2.0 - 1.0;\n    float dsq = c.x*c.x + c.y*c.y;\n    \n    vec3 col = vec3(0.2,0.6,1.0) * (dsq <limit*limit && dsq > limit*limit*0.3 ? sin(uv.x + uv.y*1.5)*0.25+0.75 : 0.2);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 552]], "test": "untested"}
{"id": "3dVSzm", "name": "Sphere UV mapping", "author": "darkeclipz", "description": "Mapping a texture onto a sphere.\n\nhttps://en.wikipedia.org/wiki/UV_mapping", "tags": ["texture", "uv", "sphere", "mapping"], "likes": 8, "viewed": 1092, "published": "Public", "date": "1573673009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2.\n#define R iResolution.xy\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\nvec2 map( in vec3 pos, float time )  \n{\n    float id = 0.;\n    float sphere = sdSphere(pos, 0.5);\n    float plane = pos.y + 0.5;\n    \n    if(plane < sphere) {\n    \tid = 1.;    \n    }\n    \n    float d = min(sphere, plane);\n    \n    return vec2(d, id);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.00;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec2 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.01;\n    int i=0;\n    for( i=0; i<100; i++ )\n    {\n        float precis = 0.001 * t;\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x<precis )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec2(t, m);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/4.;\n\n    vec3 col = vec3(0);\n    vec3 res = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0,0,0);\n        vec3 ro = vec3(0, 1.0 + (-sin(time) * .5 + .5), -1);\n        ro.xz *= rot(time);\n        \n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n \n        vec3 col = vec3(0.0);\n\n        vec2 tm = castRay(ro, rd, time); \n\n        if( tm.x < 20. )\n        {\n            float t = tm.x;\n            float id = tm.y;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            vec3 mate = vec3(0.6); \n            \n            if(id < 0.5) { // sphere\n                \n            \tmate = vec3(.8); \n                \n                //calculate uv coordinates for the sphere:\n                // https://en.wikipedia.org/wiki/UV_mapping\n                \n                // posn is the normalized vector from P to the sphere center\n                // which in this example is at (0, 0, 0).\n                vec3 posn = normalize(pos);\n                float u = 0.5 + atan(posn.z, posn.x) / (2.*3.1415);\n                float v = 0.5 - asin(posn.y) / 3.1415;\n                \n                // trick from Fabrice to avoid the discontinuity at Greenwich.\n                vec2 uv = vec2(u,v),\n                     df = fwidth(uv);\n               \tif(df.x > 0.5) df.x = 0.;\n                \n                mate = textureLod(iChannel0, uv, log2(max(df.x, df.y)*1024.)).xyz;\n                \n                // reuse mate \n                nor += 0.05*length(mate);\n                 \n            }\n            else if(id < 1.5) { // floor\n                \n            \tmate = vec3(0.);   \n                float s = 12.;\n                float w = 0.05;\n                \n                if(fract(pos.x*s) < w) {\n                \tmate = vec3(.3);    \n                }\n                \n                if(fract(pos.z*s) < w) {\n                \tmate = vec3(.3);    \n                }\n            }\n\n            vec3  light1 = vec3( 0, 1, 1 );\n            vec3  light2 = vec3( 1, 3, 1 );\n\n            float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n            float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n            float amb = (0.7+0.3*nor.y);\n            float shadow = clamp(castShadow(pos + nor*.1, light1 - pos, time), 0., 1.);\n\n            vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*shadow;\n            brdf += 1.0*vec3(1.00,1.00,1.00)*key*shadow;\n            brdf += 1.0*vec3(0.40,0.40,0.40)*bac;\n\n            col = mate * brdf * exp(-0.6*t);\n        }\n\n        res += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow( res/(AA*AA), vec3(0.4545) );\n    \n    O = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 59, 59, 119], [121, 121, 154, 154, 183], [185, 185, 224, 224, 437], [439, 439, 481, 481, 716], [718, 718, 771, 771, 1072], [1075, 1075, 1124, 1124, 1486], [1488, 1488, 1529, 1529, 4465]], "test": "untested"}
{"id": "3dVSzR", "name": "InterferenceFringes", "author": "CoolerZ", "description": "Constructive and destructive interference.", "tags": ["physics"], "likes": 5, "viewed": 234, "published": "Public", "date": "1573238826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SOURCES 6.\n#define RADIUS .1\n#define FREQUENCY 10.\n#define TIME_SCALE 4.\n#define PI 3.14159265\n#define ANGLE_PER_SOURCE (2. * PI / NUM_SOURCES)\n\nfloat circle(vec2 uv)\n{\n    float d = length(uv);\n    return smoothstep(1., 0.9, d);\n}\n\nfloat wave_source(vec2 uv, float offset)\n{\n    float d = length(uv);\n    float amplitude = cos(FREQUENCY * d - iTime * TIME_SCALE);// + offset);\n    return amplitude;\n}\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5)/(iResolution.xy - 1.);\n    uv *= 2.;\n    uv -= 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n\n    vec3 col = vec3(0.);\n    float mask = 0.;\n\n    for(float i = 0.; i < NUM_SOURCES; ++i)\n    {\n        float angle = i * ANGLE_PER_SOURCE;\n        vec2 pos = vec2(cos(angle), sin(angle));\n        // float scale = 1. / RADIUS;\n        // vec2 circle_uv = scale * (uv - pos);\n        vec2 circle_uv = uv - pos;\n\t    mask += wave_source(circle_uv, i * iTime);\n//\t    col = mix(col, vec3(sin(angle), cos(angle), 1.), mask);\n    }\n    //col = mix(col, vec3(0., 0., 1.), mask);\n    vec3 wave_col = hsb2rgb(vec3(mask, 1., mask));\n    col = mix(col, wave_col, mask);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 180, 180, 243], [245, 245, 287, 287, 413], [415, 415, 442, 442, 675], [677, 677, 734, 734, 1454]], "test": "untested"}
{"id": "3dVXR3", "name": "unknown", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 22, "viewed": 278, "published": "Public", "date": "1574609070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hue(t) (cos((vec3(0,2,-2)/3.0+t)*TAU)*0.5+0.5)\n#define hsv(h,s,v) mix(vec3(1),hue(h),s)*v\n#define hash(n) fract(sin(n)*5555.0)\n\nvec3 rot3D(vec3 p,vec3 a,float t) \n{\n\ta=normalize(a);\n\tvec3 v=cross(a,p),u=cross(v,a);\n\treturn u*cos(t)+v*sin(t)+a*dot(p, a);   \n}\n\nvec2 billboardUv(vec3 ro,vec3 rd, vec3 a)\n{\n    a-=ro;\n    vec3 g= cross(a, rd);\n    vec3 up=normalize(cross(a,cross(a,vec3(0,1,0))));\n    return vec2(dot(g,up),dot(g,cross(normalize(a),up)));\n}\n\nvec3 randVec(float n)\n{\n\tvec3 v=vec3(1,0,0);\n    v.xy*=rot(asin(hash(n)*2.-1.));\n    v.xz*=rot(hash(n+215.3)*TAU);\n\treturn v;\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<4; i++)\n    {\n        p += randVec(n+=365.)*sin((t*=1.3)+sin(t*0.6)*0.5);\n    }\n    return p*20.;\n}\n\nfloat map(vec3 p)\n{   \n    vec3 id=floor(p/6.0);\n    p=mod(p,6.0)-3.0;\n    if(hash(dot((id+236.0)*236.,id.xzy+123.0))>0.4)return 2.0;\n    float c=hash(dot((id+1236.0)*236.,id.xzy+123.0));\n    p=rot3D(p,randVec(dot(id*236.,id.xzy+123.0)),iTime*2.0+hash(dot((id+236.0)*236.,id.xzy+123.0))*3.0);\n    p = abs(p)-vec3(0.5);\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n\tp.z = max(0.0,p.z);\n\treturn length(p);\n}\n\nvec3 tetraCoord(int i)\n{\n    i=i&3;\n    return vec3(9>>i&1, i>>1&1, i&1)*2.0-1.0;\n}\n\nfloat castLine(vec3 ro, vec3 rd, vec3 a, in vec3 b)\n{\n    vec3 ab =normalize(b-a),ao = a-ro;\n    float d0 = dot(rd, ab), d1 = dot(rd, ao), d2 = dot(ab, ao);\n    float len = (d0*d1-d2)/(1.0-d0*d0);\n    len= clamp(len,0.0,length(b-a));\n    vec3 p = a+ab*len;\n    return length(cross(p-ro, rd));\n}\n\nint S[26]=int[](7325,53709,35217,53705,36241,3217,39317,7196,49601,39176,11282,35088,6202,14392,39321,3229,47513,11421,37285,16577,39192,2578,14872,8738,16418,33667);\nfloat de16Seg(vec2 p,int n)\n{\n\tfloat e=2.;\n\tmat2 m=mat2(0,-1,1,0);\n    for(int i=0;i<16;i++){\n\t\tint j=i&3;\n\t\tif(j==0)m*=mat2(0,1,-1,0);\n\t\tif((n>>i&1)==1){\n\t\t\tvec2 a=m*vec2(26>>j&1,19>>j&1)*vec2(0.6,1);\n\t\t\tvec2 b=m*vec2(13>>j&1,9>>j&1)*vec2(0.6,1);\n            a.x+=0.2*a.y;\n            b.x+=0.2*b.y;\n            vec2 c=p-a,d=b-a;\n\t\t\te=min(e,length(c-d* clamp(dot(c,d)/dot(d,d), 0.1, 0.9)));\n\t\t}\n\t}\n\treturn e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\tfloat t=-iTime*0.3;\n    float seed=123.0;\n    vec3 ro=randCurve(t+0.3,seed);\n\tvec3 ta=randCurve(t+0.1,seed);\n    vec3 w=normalize(ta-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n\tvec3 v=cross(w,u);\n    vec3 rd=normalize(u*p.x+v*p.y+w*2.);\n    vec3 col = vec3(0);\n    #define ZERO min(0.0,iTime)\n    #define SIZE 20.0\n    for(float i=ZERO; i<SIZE*2.0;i+=0.15)\n    {\n        vec3 p=ta+w*(i-SIZE);\n        vec2 uv=billboardUv(ro,rd,p);\n\t\tp+=u*uv.x+v*uv.y; \n        float de=map(p);\n        float z=length(p-ro);\n        col+=hsv(iTime*0.3,0.3,0.6)*exp(-z*z*0.0007)*exp2(-de*20.0);\n    }\n    #define tf(p) rot3D(p,randVec(456.123),iTime)\n    vec3 coord= randCurve(t,seed);\n    float fog=exp(-pow(length(coord-ro),2.0)*0.001);\n    for(int j=0;j<6;j++)\n    {\n        float de= castLine(ro,rd,coord+tf(tetraCoord(j&3)),coord+tf(tetraCoord((j&3)+(j>>2&1)+1)));\n        col+=mix(vec3(1,0.3,0.1),vec3(0),smoothstep(0.01,0.1,de))*fog;\n    }\n    vec2 uv=billboardUv(ro,rd,coord);\n    col+=mix(vec3(1),vec3(0),smoothstep(0.0,0.1,abs(length(uv)-2.5)));\n\n    float r=2.2;\n    vec2 q=vec2(atan(uv.x,uv.y)*r, length(uv)-r);\n    float s = TAU*r/12.0;\n    q.x=mod(q.x,s)-0.5*s;\n    q.x-=clamp(q.x,-0.4,0.4);\n    col+=mix(vec3(1)*step(0.0,sin(iTime*10.0)),vec3(0),smoothstep(0.0,0.1,length(q)));\n    \n    q=uv;\n    q=abs(q);\n    if(q.x<q.y) q=q.yx;\n    q.x-=clamp(q.x,2.0,3.0);\n    col+=mix(vec3(1),vec3(0),smoothstep(0.0,0.1,length(q)));\n\n    q=uv;\n    q-=vec2(1.8);\n    q-=clamp(q.y,0.0,1.0);\n    col+=mix(vec3(1),vec3(0),smoothstep(0.0,0.1,length(q)));\n\n    q=uv;\n    q-=vec2(2.8);\n    q.x-=clamp(q.x,0.0,5.0);\n    col+=mix(vec3(1),vec3(0),smoothstep(0.0,0.1,length(q)));\n\n\t#define A(a) idx=S[a];de=min(de,de16Seg(q,idx));q.x-=2.0;\n    int idx;\n    float de=10.0;\n    q=uv;\n    q*=3.0;\n    q-=vec2(10);\n    A(20)A(13)A(10)A(13)A(14)A(22)A(13)\n    col+=mix(vec3(1),vec3(0),smoothstep(0.0,0.2,de));\n\n    col=min(vec3(1),col);\n    fragColor=vec4(col,1);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 266, 266, 360], [362, 362, 405, 405, 556], [558, 558, 581, 581, 685], [687, 687, 720, 720, 862], [864, 864, 883, 883, 1288], [1290, 1290, 1314, 1314, 1373], [1375, 1375, 1428, 1428, 1669], [1838, 1838, 1867, 1867, 2248], [2250, 2250, 2307, 2307, 4308]], "test": "untested"}
{"id": "3dySDc", "name": "Study Ray Marching", "author": "familyshadertoy000", "description": "学习1", "tags": ["studyraymarching"], "likes": 1, "viewed": 696, "published": "Public API", "date": "1575119326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 屏幕左下角UV(0,0) 右上角UV(1,1) \n// 三维坐标：左手坐标系,X轴指向屏幕右侧，Y轴指向屏幕上面，Z轴垂直于屏幕向里\n\n// 最大步数\n// 最大距离\n// 最小步进的距离\n#define Max_Steps 100\n#define Max_Dist 100.\n#define Surf_Dist 0.01\n\n// \nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0,1,6,1);// 球的位置(s.xyz)和半径（s.w）\n    float sphereDist = length(p-s.xyz)-s.w;// P点到球面的距离\n    float planeDist  = p.y;// P点到平面的距离\n    \n    float d = min(sphereDist,planeDist);\n    return d;\n}\n\n// \nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d0 = 0.;\n    for(int i = 0; i < Max_Steps; i++)\n    {\n        vec3 p = ro + rd*d0;\n        float ds = GetDist(p);\n        d0+=ds;\n        if(d0>Max_Dist || ds < Surf_Dist) \n            break;           \n    }\n                     \n    return d0;     \n}\n\n// 顶点的法线\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\n// 计算灯光，点光源\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.0;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    \n    float d = RayMarch(p + n*Surf_Dist*2.0,l);\n    if(d<length(lightPos-p))dif*=0.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    // Camera：ro 位置， rd 方向\n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    \n    \n    //d/=6.0;\n    col = vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dySDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 284, 307, 307, 559], [561, 565, 599, 599, 862], [864, 883, 907, 907, 1092], [1094, 1122, 1146, 1146, 1446], [1448, 1448, 1505, 1505, 1907]], "test": "untested"}
{"id": "3dySDK", "name": "Journey Through the Cosmos", "author": "Soleam", "description": "An eternal quest", "tags": ["cosmos"], "likes": 13, "viewed": 266, "published": "Public", "date": "1575045512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define timeScale 1.\n\nfloat N11(float n)\n{\n    vec2 v1 = vec2(fract(n*129.3484),fract(n*10.2347+1.4948));\n    vec2 v2 = vec2(49.256,n);\n    return fract(dot(v1,v2));\n}\n\nvec2 N12(float n)\n{\n    vec2 v1 = vec2(fract(n*33.24102+1.2847),fract(n*4.70234556-2.5856));\n    vec2 v2 = vec2(39.3823+n,n*3.1938+1.4028);\n    return vec2(fract(dot(v1,v2)),N11(dot(v1,v2)));\n}\n\nvec2 N22(vec2 p)\n{\n    return vec2(N11(4.238+p.y+p.x*0.6274),N11(3.4148*p.y-8.29*p.x+1.39558));\n}\n\nfloat perlin(vec2 p,float scale, float seed)\n{\n    vec2 pS = p*scale;\n    \n    float X1 = floor(p.x*scale);\n    float X2 = X1+1.;\n    float Y1 = floor(p.y*scale);\n    float Y2 = Y1+1.;\n    \n    vec2 v11 = vec2(X1,Y1);\n    \n    vec2 gpUnfaded = pS - v11;\n    float xCub = pow(gpUnfaded.x,3.);\n    float yCub = pow(gpUnfaded.y,3.);\n    vec2 gp = vec2((6.*gpUnfaded.x*gpUnfaded.x-15.*gpUnfaded.x+10.)*xCub,\n              (6.*gpUnfaded.y*gpUnfaded.y-15.*gpUnfaded.y+10.)*yCub);\n    \n    vec2 v12 = vec2(X1,Y2);\n    vec2 v21 = vec2(X2,Y1);\n    vec2 v22 = vec2(X2,Y2);\n    \n\tvec2 d11 = gp-v11;\n    vec2 d12 = gp-v12;\n    vec2 d21 = gp-v21;\n    vec2 d22 = gp-v22;\n    \n    float fact = 1.394+seed;\n    vec2 g11 = (N22(v11*fact)-.5)*2.;\n    vec2 g12 = (N22(v12*fact)-.5)*2.;\n    vec2 g21 = (N22(v21*fact)-.5)*2.;\n    vec2 g22 = (N22(v22*fact)-.5)*2.;\n    \n    vec2 contribY1 = mix(g11,g21,gp.x);\n    vec2 contribY2 = mix(g12,g22,gp.x);\n    \n    vec2 contrib = mix(contribY1,contribY2,gp.y);\n\n\tfloat value= dot(d11,contrib)+dot(d12,contrib)-dot(d21,contrib)-dot(d22,contrib);\n    \n    return mix(0.,1.,value);\n}\n\nvec3 starColor(vec2 p, float id, float radius)\n{\n    //center of the star\n    vec2 center = N12(id)-.5;\n    //random color\n    vec3 color = vec3(N11(id),N11(id*7.2819),N11(id/2.));\n    vec2 vec = center-p;\n    float dist = (length(vec));\n   \tfloat angle = abs(sqrt(abs(vec.x*vec.y)))*5.;\n    float star = smoothstep(radius*.3,radius*.25,dist);\n    float halo = smoothstep(radius*1.2,.0,dist)*(.7+abs(sin(iTime*(20.+center.x*40.)))*.3);\n    float scint = smoothstep(1.,.0,angle)*halo*(.7+abs(sin(iTime*(10.+center.x*20.)))*.3);\n    return star*vec3(sqrt(color))+(scint+halo)*color;\n}\n\nvec3 layerColor(vec2 uv, float layerIndex,float scale)\n{\n    uv = uv*scale;\n    //random seed for this layer\n    float seed = 2.309387+layerIndex*1.283374;\n    //subdivision into squares\n    vec2 gv = (fract(uv*10.)*2.)-1.;\n    //id of the square\n    float id= seed*1.4983*floor(uv.y*10.)+5.39283*floor(uv.x*10.);\n    //random radius for the star\n    float radius = mix(.1,.5,N11(id*3.82918));\n   \t//is the start in this square visible?\n    float visible = smoothstep(.95,.96,N11(id*19.10982));\n    //value of the star to draw\n    vec3 starColor = starColor(gv,id,radius);\n    \n    \n    return starColor*visible;\n}\n\nvec3 nebula(vec2 uv,float scale, float seed)\n{\n    uv = uv*scale;\n    vec3 color = 0.5 + 0.5*cos(iTime*.4*timeScale-length(uv)+vec3(0,2,4));\n    \n \t//value of the nebula\n    float valPerlin = perlin(uv,scale,seed)+.6*perlin(uv,5.*scale,seed)+.3*perlin(uv,7.*scale,seed);\n    vec3 colNebul = smoothstep(-1.,1.,valPerlin)*color*.12*(.2+.2*length(uv));  \n    \n    return colNebul;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy*2.)-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 col = vec3(0.);\n    \n    \n    float time = iTime*timeScale;\n    // Number of layers\n    float nbLayers = 20.;\n    float step = .5;\n    float width = nbLayers * step;\n    \n    for(float i = 1. ; i < nbLayers; i++)\n    {\n        float posI = mod(width-(time+i),width+0.5);\n        float scale =posI;\n        float visible = clamp(2.-abs(posI - 2.), 0.,1.);\n        vec3 nebulVal = nebula(uv,scale,i)*.7;\n        col += visible*(layerColor(uv,i,scale)+nebulVal);\n    }\n                                                                   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dySDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 42, 42, 167], [169, 169, 188, 188, 362], [364, 364, 382, 382, 461], [463, 463, 509, 509, 1565], [1567, 1567, 1615, 1640, 2149], [2151, 2151, 2207, 2207, 2765], [2767, 2767, 2813, 2813, 3146], [3148, 3148, 3205, 3255, 3946]], "test": "untested"}
{"id": "3dySDm", "name": "Aquafire", "author": "cmarangu", "description": "repeating fire made with repeating fractal noise (made from repeating gradient noise made from repeating white noise)\nhttps://twitter.com/c010011012/status/1200632543961174016", "tags": ["fire"], "likes": 5, "viewed": 479, "published": "Public API", "date": "1574142408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// infinite blu fire\n// need to add text\n\n\n// useful white noise lattice points\n// same for the same values of ix and iy\n\n// yea i basically spammed random stuff\nfloat wnoise (float ix, float iy) {\n    // ix %= 10;\n    // iy %= 5;\n    // return ((600+ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n    \n    ix = mod(ix, 10.);\n    iy = mod(iy, 5.);\n    return mod((600.+ix*iy*12453.+136.*pow(ix+15., mod(iy, 16.) )+\n                sin(iy*1600.)*1376.+ix*656.+iy*75.), 1000.)/1000.;\n    \n}\n\nfloat gnoise (float px, float py) {\n    float mx = fract(px);\n    float my = fract(py);\n    px = floor(px);\n    py = floor(py);\n    // mx = 3.*my*my-2.*mx*mx*mx;\n    return mix(\n        mix(wnoise(px, py), wnoise(px+1., py), mx),\n        mix(wnoise(px, py+1.), wnoise(px+1., py+1.), mx),\n        my\n    );\n}\n\nfloat fnoise (float px, float py) {\n    float s = 0.;\n    float a = .5;\n    float f = 1.;\n    for (int i=0; i<4; ++i) {\n        s += a*gnoise(px*f, py*f);\n        a *= .5;\n        f *= 2.;\n    }\n    return s;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float arg = mod(float(iFrame), 50.)/50.;\n    float px, py, fi=0., r=0., g=0., b=0.;\n    px = (uv.x-.5)*iResolution.x/iResolution.y+.5;\n    py = 1.-uv.y;\n    fi = .1/((fnoise(px*9., py*9.+arg*5.)*( \n        .03+0.*length(vec2(px-.5, py/2.-.5))*.15+\n        0.1/(pow(py, 1.1)+0.1)\n    )))-0.5;\n    // fi = fnoise(px*7, py*7);\n    if (fi <= 0.) {\n        r = 0.;\n        g = 0.;\n        b = 100./255.;\n    }\n    else if (0. < fi && fi < .7) {\n        r = 0.;\n        g = fi/.7;\n        b = 100./255.+155./255.*fi/.7;\n    }\n    else if (true) {\n        r = 1.;\n        g = 1.;\n        b = 1.;\n    }\n    fragColor = vec4(r, g, b, 1.);\n}\n\n\n\n\n\n\n\n\n/*\n// Old code for \"lit texture\"\n// \"Sneaky 2D texture generated using 3D lighting methods\"\nvec3 sund () {\n    return normalize(\n        vec3(\n            cos(iTime),\n            sin(iTime),\n            -1.\n         )\n    );\n}\n\nfloat rand (float x, float y) {\n    x = mod(x, 20.)+3.;\n    y = mod(y, 20.)+3.;\n    // return mod(x*x*256.+y*x*y*30.+256., 1200.)/1200.;\n    return mod(245.+x*y+x*200.+floor(y)*20.*x*x, 1200.)/1200.;\n}\n\nfloat ease (float t) {\n    return 3.*t*t-2.*t*t*t;\n}\n\nfloat lerp (float a, float b, float t) {\n    return a+(b-a)*ease(t);\n}\n\nfloat gnoise (vec2 px) {\n    float mx = mod(px.x+1e3, 1.);\n    float my = mod(px.y+1e3, 1.);\n    px.x = floor(px.x);\n    px.y = floor(px.y);\n    float tr = rand(px.x+1., px.y);\n    float tl = rand(px.x, px.y);\n    float bl = rand(px.x, px.y+1.);\n    float br = rand(px.x+1., px.y+1.);\n    return lerp(\n        lerp(tl, tr, mx),\n        lerp(bl, br, mx),\n        my\n    );\n}\n\nfloat fnoise (vec2 px) {\n    //return (\n    //    gnoise(px/4.)*1.+\n    //    gnoise(px/6.)*1.+\n    //    gnoise(px/10.)*2.+\n    //    gnoise(px/20.)*2.\n    //)/6.;\n    // learned this here\n    // https://thebookofshaders.com/13/\n    float sum = 0.;\n    float amp = .5;\n    float freq = .07;\n    for (int i=0; i<4; ++i) {\n        sum += gnoise(px*freq)*amp;\n        amp *= .5;\n        freq *= 2.;\n    }\n    return sum;\n}\n\nfloat SDF (vec2 px) {\n    // return sqrt(px.x*px.x+px.y*px.y);\n    return lerp(fnoise(vec2(px.x*.4, px.y*.5)*60.*4.*3.), fnoise(px*60.*2.), .5+.5*sin(iTime) );\n}\n\nvec3 dSDF (vec2 px) {\n    // so btw 2D so change in z does not affect shape...\n    float inf = 1e-3;\n    float SDFp = SDF(px);\n    return normalize(\n        vec3(\n            SDF(vec2(px.x+inf, px.y))-SDFp,\n            SDF(vec2(px.x, px.y+inf))-SDFp,\n            inf\n        )\n    );\n}\n\nvec3 TEX (vec2 px, vec3 d) {\n    float SDFp = SDF(px);\n    vec3 dSDFp = dSDF(px);\n    vec3 TEXp = vec3(0., 0., 0.);\n    // TEXp += mod(floor(px.x*7.)+floor(px.y*7.), 2.)*.5;\n    // diffuse\n    TEXp += .8*(dot(dSDFp, sund())*.5+.5);\n    TEXp += .2*clamp(dot(dSDFp, sund()), 0., 1.);\n    TEXp = vec3(0., 1., .9)*TEXp;\n    // speculsr\n    TEXp += .5*pow(clamp(-dot(reflect(d, dSDFp), sund()), 0., 1.), 12.);\n    TEXp = clamp(TEXp, 0., 1.);\n    \n    return TEXp;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    vec3 retina = TEX(screen, normalize(vec3(screen.x, screen.y, .25)) );\n    // retina = vec3(fnoise(screen*60.*4.));\n    fragColor = vec4(retina, 1.);\n}\n*/\n\n\n\n\n\n\n\n/*\n// Old code: Original code to generate this shader on\n// https://www.khanacademy.org/computer-programming/new/pjs\n// infinite blu fire\n// need to add text\n// useful white noise lattice points\n// same for the same values of ix and iy\nvar wnoise = function(ix, iy) {\n    // ix %= 10;\n    iy %= 5;\n    return ((600+ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n};\nvar gnoise = function(px, py) {\n    var mx = px%1;\n    var my = py%1;\n    px = floor(px);\n    py = floor(py);\n    // mx = 3*my*my-2*mx*mx*mx;\n    return lerp(\n        lerp(wnoise(px, py), wnoise(px+1, py), mx),\n        lerp(wnoise(px, py+1), wnoise(px+1, py+1), mx),\n        my\n    );\n};\nvar fnoise = function(px, py) {\n    var s = 0;\n    var a = 0.5;\n    var f = 1;\n    for (var i=0; i<4; ++i) {\n        s += a*gnoise(px*f, py*f);\n        a *= 0.5;\n        f *= 2;\n    }\n    return s;\n    // return noise(px, py);\n};\nvar imgs = [];\nvar FRAMES = 50;\nvar C = 0;\nvar index = 0;\nvar draw = function() {\n    if (C < FRAMES) {\n        var arg = (C%FRAMES)/FRAMES;\n        if (!this.loadPixels) {\n            return;\n        }\n        this.loadPixels();\n        var pix = this.imageData.data;\n        var px, py, fi=0, r=0, g=0, b=0;\n        for (var jndex=0; jndex<1000; ++jndex) {\n            px = (index%width)/width;\n            py = floor(index/width)/height;\n            fi = 0.1/((fnoise(px*9, py*9+arg*5)*( \n                dist(px, py/2, 0.5, 1/2)*0.15+\n                0.1/(pow(py, 1.1)+0.1)\n            )))-0.5;\n            // fi = fnoise(px*7, py*7);\n            if (fi <= 0) {\n                r = 0;\n                g = 0;\n                b = 100;\n            }\n            else if (0 < fi && fi < 0.7) {\n                r = 0;\n                g = 255*fi/0.7;\n                b = 100+100*fi/0.7;\n            }\n            else if (fi) {\n                r = 255;\n                g = 255;\n                b = 255;\n            }\n            pix[index*4] = r;\n            pix[index*4+1] = g;\n            pix[index*4+2] = b;\n            ++index;\n            if (index >= width*height) {\n                break;\n            }\n        }\n        this.updatePixels();\n        if (index >= width*height) {\n            index = 0;\n            imgs[C] = get(0, 0, width, height);\n            C++;\n\t    println(floor(C/FRAMES*100)+\"%\");\n        }\n    }\n    else {\n        image(imgs[C%FRAMES], 0, 0);\n        C++;\n    }\n};\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dySDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 162, 197, 328, 519], [521, 521, 556, 556, 828], [830, 830, 865, 865, 1040], [1042, 1042, 1098, 1153, 1834]], "test": "untested"}
{"id": "3dySDR", "name": "Knob Rubber", "author": "andremichelle", "description": "Rubber type knob", "tags": ["knob"], "likes": 1, "viewed": 112, "published": "Public API", "date": "1573986341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvec4 over( in vec4 a, in vec4 b ) {\n    return mix(a, b, 1.-a.w);\n}\n\nfloat nCap(vec2 uv, float angle, float r, float r1, float n) {\n\tfloat r2 = 1./r1;\n    float a = atan(uv.y, uv.x)+angle;\n    float b = a/PI*n/2.+PI*r2*2.0;\n    float f = fract(b);\n    float l = length(uv);\n    float d = sin(f*PI*r2) * step(f, r1);\n    return (1.-d*0.05)*r-l;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/-iResolution.y*2.0;\n    \n    float av = sin(iTime)*PI*5./6.; // angle value\n    \n    mat2 m = mat2(cos(av), sin(av), -sin(av), cos(av));\n    \n    float a = atan(uv.y, uv.x);\n    float l = length(uv);\n\tfloat g = -1. + smoothstep(.5, -.5, uv.y) * 2.;\n\n    vec4 col = vec4(vec3(.04), 1.); // background\n    vec2 la = vec2(.0, -.24)*m;\n    vec2 lb = vec2(.0, -.41)*m;\n    \n    float d = .0;\n    float e = .0;\n    for(float q = 0. ; q < 11. ; q += 1.) {\n        float aq = -PI*1./3.+q*PI*1./6.;\n        vec2 v = vec2(.66, .0) * rot(aq);\n        d += smoothstep(.01, .0, distance(uv, v)-.002);\n        e += smoothstep(.02, .0, distance(uv, v)-.008);\n    }\n    col = over(vec4(vec3(e*e), d*d), col); // divs\n    \n    col = over(vec4(vec3(.20+g*.08-(l-.48)), smoothstep(.02, .0, l-.48)), col); // bottom\n    col = over(vec4(vec3(.16), smoothstep(.002, .0, l-.40)), col); // bottom to cap\n    col = over(vec4(vec3(.36 - smoothstep(.2, .8, l)*0.4), smoothstep(.02, .0, l-.38)), col); // cap\n    col = over(vec4(vec3(.50), max(0., (1.-pow(abs(uv.x), .25)))*smoothstep(.02, 0., abs(l-.37))), col); // cap bevel\n\n    col = over(vec4(vec3(1.), smoothstep(.01, .0, line(uv, vec2(.0, -.2)*m, vec2(.0, -.35)*m)-.01))*.8, col);\n    \n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dySDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 55, 55, 87], [89, 89, 151, 151, 365], [367, 367, 414, 414, 533], [535, 535, 554, 554, 630], [632, 632, 689, 689, 1974]], "test": "untested"}
{"id": "3dySWG", "name": "Infinite Color", "author": "maxsond", "description": "\"I wonder what will happen if I... ohh....\"", "tags": ["2d"], "likes": 1, "viewed": 68, "published": "Public", "date": "1574798654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from Chapter 6 of https://thebookofshaders.com\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3((angle/0.000628318530718+iTime/7.5),radius,1.0));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dySWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 133, 159, 159, 392], [394, 394, 451, 451, 902]], "test": "untested"}
{"id": "3dyXR1", "name": "Los Colores - Clasico  ", "author": "anemolo", "description": "Inspired by \"Los colores\"'s album. :)", "tags": ["linesexclusioninclusion"], "likes": 3, "viewed": 77, "published": "Public", "date": "1573340080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n      i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n\n}\n\nfloat getLine(float val, float count){\n \n    \n    val *= count;\n    \n\tfloat lines = fract(val);\n    lines = smoothstep(0.8,1.,lines);\n    \n    \n    \n    return lines;\n    \n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat getNoise(vec2 uv, float time){\n    float noise = snoise(vec3(uv , time));\n    noise = step(0., noise);\n    return noise;\n}\n#define PI 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float rotationTime = iTime * 0.1;\n    float noiseTime = iTime * 0.5;\n    \n    vec2 uv2 = uv;\n    uv2 -= 0.5;\n    \n    uv2 = rotate2d( rotationTime) * uv2;\n    float lines1 = getLine(uv2.x,40.);\n    uv2 = rotate2d(PI / 3. + rotationTime) * uv2;\n    float lines2 = getLine(uv2.x,100.);\n    uv2 = rotate2d(PI / 3.+ rotationTime) * uv2;\n    float lines3 = getLine(uv2.x,40.);\n    \n    \n    \n    float noise1 = getNoise(uv *2., noiseTime);\n    \n    float noise2 = getNoise(uv *2., 10. +noiseTime); \n    \n    float noise3 = getNoise(uv *2., 20. +noiseTime); \n    \n    float only1 = max(0., noise1 - noise2 - noise3);\n    float only2 = max(0., noise2 - noise1 - noise3);\n    float only3 = max(0., noise3 - noise2 - noise1);\n    \n    float share1and2 = noise1 * noise2 * (1.-noise3);\n    float share1and3 = noise1 * noise3 * (1.-noise2);\n    float share2and3 = noise2 * noise3 * (1.-noise1);\n    \n    float allShare = noise1 * noise2 * noise3;\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(lines1+ lines2 + lines3);\n     col = vec3(\n         only1 * lines1 + \n         only2 * lines2 + \n         only3 * lines3 + \n         share1and2 * (lines1 + lines2) +\n         share1and3 * (lines1 + lines3) +\n         share2and3 * (lines2 + lines3) +\n         allShare * 1.\n     \n     );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 71], [73, 73, 94, 94, 143], [145, 145, 167, 167, 204], [206, 206, 233, 233, 285], [287, 287, 309, 309, 2411], [2413, 2413, 2451, 2451, 2586], [2587, 2587, 2615, 2615, 2701], [2702, 2702, 2738, 2738, 2830], [2856, 2856, 2913, 2963, 4351]], "test": "untested"}
{"id": "3dyXRm", "name": "discomBLOBulated", "author": "thisisthais", "description": "still dk", "tags": ["noise", "tbos"], "likes": 3, "viewed": 46, "published": "Public", "date": "1573680535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 random2D(vec2 st){\n  st=vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)));\n  return-1.+2.*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st){\n  vec2 i=floor(st);\n  vec2 f=fract(st);\n  // mixing function\n  vec2 u=f*f*(3.-2.*f);\n  \n  return mix(mix(dot(random2D(i+vec2(0.,0.)),f-vec2(0.,0.)),\n  dot(random2D(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n  mix(dot(random2D(i+vec2(0.,1.)),f-vec2(0.,1.)),\n  dot(random2D(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n}\n\nfloat circle(in vec2 _st,in float _radius){\n  vec2 l=_st-vec2(.5);\n  return 1.-smoothstep(_radius-(_radius*.01),\n  _radius+(_radius*.01),\n  dot(l,l)*4.);\n}\n\nfloat shape(vec2 st,float radius){\n  st=st-vec2(.5);\n  float r=length(st)*2.;\n  float a=atan(st.y,st.x);\n  float m=abs(mod(2.*iTime,2.*PI)-PI)/a*2.2;\n  float f=radius;\n  \n  // stripeys, where they coming from, idk\n  m*=noise(st+iTime*.1)*10.;\n  st-=.9;\n  m*=noise(st+iTime*.1)*5.;\n  st.y+=.4;\n  m*=noise(st+iTime*.1)*7.;\n  st=1.-st;\n  m*=noise(st+iTime*.1)*5.;\n  st+=.9;\n  m*=noise(st+iTime*.1)*10.;\n  \n  f+=sin(a*100.)*noise(st+iTime*.2)*.1;\n  f+=(sin(a*100.)*.1*pow(m,2.));\n  return smoothstep(f,f+.007,r);\n}\n\nfloat shapeBorder(vec2 st,float radius,float width){\n  return shape(st,radius)-shape(st,radius-width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st=fragCoord.xy/iResolution.y;\n  vec3 color=vec3(0.);\n  color=vec3(shape(st,.5));\n  color+=circle(st,.005*(sin(iTime)+1.1));\n  \n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 58, 58, 169], [171, 256, 277, 277, 585], [587, 587, 630, 630, 742], [744, 744, 778, 778, 1254], [1256, 1256, 1308, 1308, 1360], [1362, 1362, 1418, 1418, 1583]], "test": "untested"}
{"id": "3dyXRz", "name": "Topologica VR", "author": "ajb", "description": "VR port of https://www.shadertoy.com/view/4djXzz by otaviogood.", "tags": ["vr"], "likes": 11, "viewed": 558, "published": "Public API", "date": "1573200195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// various noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise2dT(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).y;\t// use constant here instead?\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat Density(vec3 p)\n{\n    //float ws = 0.06125*0.125;\n    //vec3 warp = vec3(noise(p*ws), noise(p*ws + 111.11), noise(p*ws + 7111.11));\n    float final = noise(p*0.06125);// + sin(iTime)*0.5-1.95 + warp.x*4.0;\n    float other = noise(p*0.06125 + 1234.567);\n    other -= 0.5;\n    final -= 0.5;\n    final = 0.1/(abs(final*final*other));\n    final += 0.5;\n    return final*0.0001;\n}\n\nvec4 render(vec3 camPos, vec3 relVec) \n{\n\t// --------------------------------------------------------------------------------\n\tfloat t = 0.0;\n\tfloat inc = 0.02;\n\tfloat maxDepth = 70.0;\n\tvec3 pos = vec3(0,0,0);\n    float density = 0.0;\n\t// ray marching time\n    for (int i = 0; i < 37; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n        pos = camPos + relVec * t;\n        float temp = Density(pos);\n        //temp *= saturate(t-1.0);\n\n        inc = 1.9 + temp*0.05;\t// add temp because this makes it look extra crazy!\n        density += temp * inc;\n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(0.01,0.1,1.0)* density*0.2;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\treturn vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;\n\tfloat my=-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n    fragColor = render(camPos, relVec);\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfragColor = render(fragRayOri + vec3(0,0,-0.5*iTime), fragRayDir);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyXRz.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[562, 589, 612, 612, 689], [690, 690, 713, 713, 805], [806, 806, 847, 847, 890], [928, 928, 952, 952, 1225], [1226, 1226, 1251, 1251, 1473], [1474, 1474, 1496, 1496, 2055], [2079, 2079, 2102, 2102, 2132], [2133, 2133, 2156, 2156, 2186], [2187, 2187, 2212, 2212, 2242], [2244, 2244, 2267, 2381, 2625], [2627, 2627, 2667, 2752, 3595], [3597, 3597, 3654, 3739, 4528], [4532, 4532, 4626, 4626, 4696]], "test": "untested"}
{"id": "3s3SWl", "name": "square dancing circles", "author": "thisisthais", "description": "sample exercise from chapter 9 of the book of shaders", "tags": ["circles", "pattern", "tilling", "tbos"], "likes": 2, "viewed": 88, "published": "Public", "date": "1573075703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 st,float radius){\n  return smoothstep(20./iResolution.y , 0., length(st-.5) - radius*.5);\n}\n\nvec2 moveAndTile(vec2 st,float _zoom){\n  st*=_zoom;\n  \n  // slow down time\n  float time=iTime/2.;\n  \n  // naming some variables for ease of reading\n  float stepCounter=step(.5,fract(time));\n  float colTracker=step(1.,mod(st.y,2.));\n  float rowTracker=step(1.,mod(st.x,2.));\n  \n  // when stepCounter is 1 (which is half the time), we move side to side\n  // alternating rows move alternating directions\n  st.x-=2.*fract(time)*(1.-colTracker)*stepCounter;\n  st.x+=2.*fract(time)*colTracker*stepCounter;\n  \n  // otherwise when stepCounter is 0, we move up and down\n  // still alternating directions\n  st.y+=2.*fract(time)*rowTracker*(1.-stepCounter);\n  st.y-=2.*fract(time)*(1.-rowTracker)*(1.-stepCounter);\n  \n  return fract(st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 myRes = iResolution.yy/0.5;\n  vec2 st=fragCoord.xy/myRes.xy;\n  vec3 color=vec3(0.);\n  st=moveAndTile(st,20.);\n  \n  color=vec3(circle(st,.5));\n  \n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3SWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 109], [111, 111, 149, 149, 839], [841, 841, 897, 897, 1079]], "test": "untested"}
{"id": "3scSDS", "name": "ShaderTober - Catch", "author": "Flopine", "description": "A small doodle with inktober's theme \"Catch\"", "tags": ["raymarching", "noise", "inktober"], "likes": 6, "viewed": 187, "published": "Public", "date": "1572718514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(vec2(42.1, 48.4),x))*1245.5);}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat cyl(vec2 p, float r)\n{return length(p)-r;}\n\n// iq's formula http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat g1 = 0.;\nfloat gem (vec3 p)\n{\n    p.y += sin(iTime)*2.-1.5;\n    p.yz *= rot(iTime);\n    p.xy *= rot(iTime);\n    float d = dot(p,normalize(sign(p)))-.8;\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat prim1(vec3 p)\n{return sdCapsule(p, vec3(0.,-3.,0.), vec3(0.,3.,0.), 1.4+p.y*0.3);}\n\nfloat cocoon(vec3 p)\n{\n     p.z += texture(iChannel0, p.yx*0.04*sin(length(p.xy)-iTime)).r*length(p)*0.5;\n    p.xy *= rot(p.z*0.3);\n    vec3 pp = p;\n    p.x += sin(p.y*0.5);\n    p.y += 1.;\n    float cap = prim1(p);\n    \n    p.xz *= rot(iTime);\n    p.xz *= rot(p.y*0.5);\n    p.xz = moda(p.xz, 2.*PI/3.);\n   \tp.x -= (2.-abs(p.y-1.)*0.1);\n    float branch1 = cyl(p.xz, 0.4);\n    \n    p = pp;\n\n    p.xy *= rot(PI/3.);\n    p.xz *= rot(iTime*0.2);\n    p.xz *= rot(p.y*0.4);\n    p.xz = moda(p.xz, 2.*PI/2.);\n   \tp.x -= (1.+abs(p.y)*0.1);\n    float branch2 = cyl(p.xz, 0.3+abs(p.y)*0.03);\n    \n    p = pp;\n\n    p.xy *= rot(-PI/3.);\n    p.xz *= rot(iTime*0.2);\n    p.xz *= rot(p.y*0.4);\n    p.xz = moda(p.xz, 2.*PI/2.);\n   \tp.x -= (1.+abs(p.y)*0.1);\n    float branch3 = cyl(p.xz, 0.1+abs(p.y)*0.03);\n    \n    return smin(branch3,smin(branch2,smin(cap,branch1,.5), .5),.5);\n}\n\nfloat SDF (vec3 p)\n{\n\treturn min(gem(p),cocoon(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-8.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            // phantom mode from lsdlive \n\t\t\t// https://www.shadertoy.com/view/XsGfDD\n            d = max(abs(d),0.2);\n        }\n        d *= 0.2+dither*0.2;\n        p += d*rd;\n        \n    }\n    \n    if (hit)\n    {col = vec3(1.-shad);}\n\n    col += g1*vec3(clamp(length(uv),0.,1.),0.1,0.6)*0.3;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 351, 374, 374, 425], [427, 427, 458, 458, 576], [578, 578, 598, 598, 641], [643, 643, 684, 684, 777], [779, 779, 807, 807, 827], [829, 912, 964, 964, 1091], [1108, 1108, 1128, 1128, 1291], [1293, 1293, 1314, 1314, 1381], [1383, 1383, 1405, 1405, 2248], [2250, 2250, 2270, 2270, 2303], [2305, 2305, 2362, 2362, 3111]], "test": "untested"}
{"id": "3sdXzs", "name": "ShaderTober - Ride", "author": "Flopine", "description": "A small doodle with inktober's theme \"Ride\"", "tags": ["raymarching", "rainbow"], "likes": 11, "viewed": 266, "published": "Public", "date": "1572654393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define PI 3.141592\n#define tt (iTime*6.)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,16.1)))*1245.4);}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep*0.5) id = abs(id);\n    return id;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat g1 = 0.;\nfloat box (vec3 p, vec3 c)\n{\n    float d = length(max(abs(p)-c,0.));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g2;\nfloat cyl (vec2 p, float r)\n{\n    float d = length(p)-r;\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvec2 path(float t) \n{\n\tfloat a = sin(t*.2+1.5), b = sin(t*.2);\n\treturn vec2(a, a*b);\n}\n\nfloat cid;\nfloat SDF (vec3 p)\n{\n    p.xy -= path(p.z)*3.;\n    p.xy *= rot(p.z*0.15);\n    \n    vec3 pp = p;\n    \n    p += sin(p.yzx - cos(p.zxy));\n    p += sin(p.yzx/1.5 + cos(p.zxy)/2.)*.5;\n    float t = -length(p.xy)+6.;\n    \n    p = pp;\n    moda(p.xy, 6.);\n    p.x -= 3.;\n    float b = box(p,vec3(.2,0.2,1e10));\n    \n    p = pp;\n    p.xy *= rot(PI/6.);\n    cid = moda(p.xy, 6.);\n    p.y += sin(p.z)*0.5;\n    p.x -= 2.;\n   \tfloat c = cyl(p.xy, 0.3);\n    return min(min(c,t),b);\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.,0.,-5.+tt),\n        ta = vec3(0.,0.,tt);\n    \n    ro.xy += path(ro.z)*3.;\n\tta.xy += path(ta.z)*3.;\n       \n    vec3 rd = getcam(ro,ta, uv),\n    \tp = ro,\n    \tcol = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n         d *= 0.6+dither*0.1;\n        p += d*rd;\n    }\n    \n    float t = length(ro-p);\n\tcol = vec3(shad)*0.5;\n\n   \n    col += g2 * 0.09* palette(cid, \n                        vec3(0.5),\n                        vec3(0.5),\n                        vec3(0.1+cid), \n                        vec3(0.,0.3,0.45)); \n    col -= g1*0.25;\n    \n    fragColor = vec4(pow(clamp(col,0.,1.),vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 372, 395, 395, 445], [447, 447, 485, 485, 714], [716, 716, 736, 736, 779], [796, 796, 824, 824, 905], [917, 917, 946, 946, 1014], [1016, 1016, 1037, 1037, 1102], [1115, 1115, 1135, 1135, 1584], [1586, 1586, 1628, 1628, 1790], [1792, 1792, 1848, 1848, 1879], [1881, 1881, 1938, 1938, 2809]], "test": "untested"}
{"id": "3sfSDS", "name": "Discarded", "author": "Zoz", "description": "Inro idea that never went any way.", "tags": ["reflections"], "likes": 3, "viewed": 74, "published": "Public", "date": "1572749632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n#define FAR_PLANE 10.\n#define MAX_SAMPLES 60\n\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\n\n\n/* Noise functions */\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n    //return hash(x.x);\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//https://www.shadertoy.com/view/Ms2SD1\nfloat noise( vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix( rand( i + vec2(0.0,0.0) ), \n                     rand( i + vec2(1.0,0.0) ), u.x),\n                mix( rand( i + vec2(0.0,1.0) ), \n                     rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 v) {\n\tfloat sum = 0.;\n    for (int i = 0; i < 8; i++) {\n        float e = pow(2., float(i));\n        sum += noise(v * vec2(e)) / e;\n    }\n    return sum;\n}\n\nfloat marble(vec2 v) {\n    float c = 0.;\n    for (int i = 0; i < 3; i++) {\n     \tc = fbm(v + c * 2.) + fbm(v)* 1.7;   \n    }\n    return c;\n}\n\n\n/* Boolean operatorns */\nvec2 opUnion(vec2 d1, vec2 d2) {\n    float k = 8.;\n    float res = exp2( -k*d1.x ) + exp2( -k*d2.x );\n    float d =-log2( res )/k;\n    return vec2(d, abs(d - d1.x) < abs(d - d2.x) ? d1.y : d2.y);\n    \n \treturn d1.x < d2.x ? d1 : d2;   \n}\n\nvec2 opIntersect(vec2 d1, vec2 d2) {\n \treturn d1.x > d2.x ? d1 : d2;   \n}\n\nvec2 opComp(vec2 d1, vec2 d2) {\n    return d1.x > -d2.x ? d1 : d2;\n}\n\n/* Distance functions */\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p) {\n \treturn length(p) - 1.;   \n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat tunnel(vec3 p) {\n    p = Rotate(vec3(0, p.y*1., 0)) * p;\n    p.y = mod(p.y, 1.) - .5;\n \tfloat d1 = sdBox(p, vec3(.5));\n    float d2 = sdBox(p, vec3(.4, .4, 1.));\n    float d3 = sdBox(p, vec3(.4, 1., .4));\n    float d4 = sdBox(p, vec3(1., .4, .4));\n   \n    float d = max(d1, -d2);\n    d = max(d, -d3);\n    d = max(d, -d4);\n    \n    return d;\n}\n\n\n/* Sphere tracing */\nvec2 map(vec3 p) {\n    //p = Rotate(vec3(-0.5, -.5, -PI/2.)) * p;\n    vec2 d = vec2(100.);\n    \n    float y = p.y;\n    for (float i = 1.; i <= 5.; i += 1.) {      \n        vec2 off = vec2(noise(vec2(iTime + y + float(i)*50.)), 0.);\n        float dd = .5 * abs(noise(vec2(iTime + y))) + .3;\n        vec3 pd = vec3(p.x + dd * sin(i + off.x), 0., p.z + dd * cos(i + off.x));\n \n     \td = opUnion(d, vec2(sdBox(Rotate(vec3(0., y + off.x, 0.)) * pd, vec3(.1)), float(i)));  \n    }\n    d = opUnion(d, vec2(tunnel(p/2.)*2., 10.));\n    d = opUnion(d, vec2(p.x +2., 11.));\n    d = opUnion(d, vec2(-p.x + 2., 11.));\n    \n    return d;\n}\n\nvec2 strace(vec3 o, vec3 r) {\n    vec2 d = vec2(0.);\n    for (int i = 0; i < MAX_SAMPLES; i++) {\n     \tvec3 p = o + d.x * r;\n        vec2 res = map(p) * 1.;\n        d.x += res.x;\n        d.y = res.y;\n    }\n    \n    return d;\n}\n\n/* Shading helpers */\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nfloat FOG_AMOUNT = 0.2;\nvoid applyFog( inout vec3  rgb, in float dist )\n{\n    //FOG_AMOUNT += pow(.8 * noise(vec2(iTime * 10.)), 10.);\n    float fogAmount = 1.0 - exp( -dist*FOG_AMOUNT );\n    vec3  fogColor  = vec3(.05, .05, .1);\n    fogColor = vec3(0);\n    rgb = mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 color(vec3 o, vec3 r, vec3 n, vec2 d) {\n    vec3 p = o + r * d.x;\n\n    vec3 col;\n    col = vec3(1.);\n    vec2 q = floor(p.yz);\n   \t//if (d.y == 11.) col = vec3(mod(q.x+q.y,2.));\n    if (d.y < 6.) col = vec3(1., .95, 0.95);\n    float ao = 1.;\n    for (float i = 0.; i < 6.; i++) {\n   \t\tao -= 0.3 * abs(length(n * i /16.) - map(p + n * i / 16.).x);\n    }\n    col *= ao;\n    \n    applyFog(col, d.x);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0., iTime*0., -5.5);\n    vec3 r = normalize(vec3(uv, 2.)); \n    \n   \t\n\n    vec2 d = strace(o, r);\n    vec3 p = o + r * d.x;\n    vec3 n = normal(p);  \n    vec3 col = color(o, r, n, d);\n    \n    \n    \n    r = reflect(r, n);\n    o = p + r;\n    d = strace(o, r);\n    n = normal(o + r * d.x);\n    col = mix(col, color(o, r, n, d), .05);\n   \t\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 92, 92, 377], [381, 403, 424, 424, 465], [467, 467, 488, 512, 856], [858, 858, 878, 878, 950], [952, 992, 1015, 1015, 1315], [1317, 1317, 1336, 1336, 1487], [1489, 1489, 1511, 1511, 1629], [1632, 1657, 1689, 1689, 1894], [1896, 1896, 1932, 1932, 1969], [1971, 1971, 2002, 2002, 2039], [2041, 2066, 2097, 2097, 2247], [2249, 2249, 2273, 2273, 2303], [2305, 2305, 2341, 2341, 2375], [2377, 2377, 2419, 2419, 2518], [2520, 2520, 2553, 2579, 2610], [2612, 2612, 2634, 2634, 2960], [2963, 2984, 3002, 3049, 3609], [3611, 3611, 3640, 3640, 3837], [3839, 3861, 3882, 3882, 4106], [4132, 4132, 4181, 4242, 4406], [4409, 4409, 4453, 4453, 4833], [4835, 4835, 4892, 4942, 5466]], "test": "untested"}
{"id": "3sGSDD", "name": "Right Hemisphere 4kb", "author": "Manwe", "description": "4k intro: https://www.pouet.net/prod.php?which=83559\nAntialiasing is disabled for faster render. You can edit the code to enable it.\nEnvelopes eat 2/3 GPU time.", "tags": ["4k", "art"], "likes": 2, "viewed": 109, "published": "Public", "date": "1574067624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Right Hemisphere 4 kb intro\n// by SandS & Jetlag\n// https://www.pouet.net/prod.php?which=83559\n\n// watch in fulscreen to enable vsync mode\n\n\nprecision highp float;\n\n#define maxZ 26.\n\n#define fps 60.\n\n#define LastFrame 9180\n#define totalEnvelopes 13 // number of envelopes used\n\n\nint ef[]=int[219] // envelope data: key frames offsets\n(\n    0,239,1,28,32,180,7662,858,480, // fade\n    0,180,540,1,719,1,359,5400,480,614,886, // shift11\n    0,480,1,119,1140,2,126,2,2210,2,30,2,1646,1,59,900,18,12,10,12,8,420,300,2,32,20,66,1560, // zoomshift\n    0,960,1,239,1,2879,1,31,1,169,1,39,1,1437,1,1439,1,1979, // steps\n    0,5760,1,779,178,4,358,120,2,298,1,1037,642, // greyscale\n    0,6240,2,42,196,240,14,6,202,258,1980, // greyscale2\n    0,720,1,239,1,239,1,239,60,3302,1,477,1,479,1,3419, // timeshift\n    0,480,1,239,1,239,1,239,1,3601,1,477,1,479,1,3419, // shiftX\n    0,480,1,239,1,239,1,239,1,3601,1,477,1,3899, // shiftY\n    0,480,1,239,1,59,180,1,239,1,239,1,599,2762,1,477,1,479,1,1439,1,1499,480, // zoomXY\n    0,1740,128,2,172,2,6,8,42,180,1800,2,32,2,54,632,1,597,2,14,104,1980,2,118,1560, // red\n    0,1680,1,11,30,18,1,2543,36,2,4858, // skip\n    0,1488,372,18,1242,2,24,2,30,24,878,2,32,2,72,72,2,20,2,36,2,4,26,4828 // distort\n);\n\nfloat ev[]=float[219] // envelope data: nodes values\n(\n    0.,.3,.6,.47,.53,1.,1.,0.,0., // fade\n    300.,300.,228.9,263.,243.,134.,86.77,165.23,160.,148.53867,133., // shift11\n    2.8,2.8,2.7,2.8,2.8,2.6,2.5,2.8,2.8,3.,3.,2.8,2.8,7.298,7.246,3.,5.79,5.545,5.67,5.57,5.595,4.,4.,3.6,3.95,3.9,4.,4., // zoomshift\n    3.,3.,4.,4.,3.,3.,2.,2.,3.,3.,2.,2.,3.,3.,1.,1.,2.,2., // steps\n    0.,0.,1.,1.,.9,1.,1.,.86,.5,.3,0.,0.,.7, // greyscale\n    0.,0.,.85,.43,.23,.21,.4,1.,1.,.5,.5, // greyscale2\n    86.,86.,164.,164.,-211.,-221.,164.,164.,6.,6.,156.,150.,122.,118.,6.,6., // timeshift\n    -.5,-.5,-.062,-.062,-.37,-.37,-.98,-.98,-.5,-.5,.2,0.,-.45,-.45,-.5,-.5, // shiftX\n    -.5,-.5,-.8,-.8,-.5,-.5,.28,.28,-.5,-.5,-.4,-.4,-.5,-.5, // shiftY\n    1.4,1.4,1.04,1.04,1.2,1.2,1.12,.48,.5,.86,.85,1.2,1.2,2.38,.7,.7,1.3,1.15,1.4,1.4,1.65,2.2,1.94, // zoomXY\n    0.,0.,1.,0.,0.,.4,.4,.2,0.,0.,.7,.26,.6,.34,.75,1.,0.,0.,.25,.23,0.,0.,.6,0.,0., // red\n    15.,15.,14.,14.,0.,0.,15.,15.,0.,15.,15., // skip\n    0.,0.,.4,0.,0.,.35,.1,.2,.05,0.,0.,.25,.1,.2,0.,0.,.3,.1,.3,1.,.9,.2,0.,0. // distort\n),\n\tparameter[totalEnvelopes], // array with current envelopes values\n    zoom, time;\n\n\nvec3 rotate(vec3 p, vec3 a)\n{\n    vec3 s = sin(a), c = cos(a);\n    return p * mat3(\n         c.y,     s.z*s.y,            -s.y*c.z,\n        -s.x*s.y, c.x*c.z+s.x*s.z*c.y, s.z*c.x-s.x*c.z*c.y,\n         c.x*s.y, s.x*c.z-c.x*s.z*c.y, s.z*s.x+c.x*c.z*c.y\n    );\n}\n\n\nfloat squareSingle(vec3 o, vec3 c) // input: ray position, square center\n{\n    vec3 p, r; // moved vector, rotation\n    vec3 s = vec3(.5,.5,.001); // square size\n\n    r = c;\n    c.z = ( c.z + zoom ) * 4.;\n    p = o - c; // move square to 0,0,0\n    p = rotate(p, time/29. * r); // rotate over axis x,y,z // rotate over axis x,y,z\n    r = max(p - s, -p - s); // differences\n\n    return max(max(r.x,r.y),r.z); // cube distance function\n}\n\n\nvoid mainImage(out vec4 outcolor, vec2 fragCoord)\n{\n\n    time = mod(iTime,163.6);\n\tfor (int i=0, j=1, f; i<totalEnvelopes; i++) // fill parameter[] with current envelopes values\n    {\n\t\tfor (f=0; j<220; j++)\n        {\n            f += ef[j]; // sum offsets\n            if(f >= int(time*fps)) break;\n        }\n\t\tparameter[i] = mix(ev[j-1], ev[j], (time*fps - float(f-ef[j])) / float(ef[j]) );\n        for (; j<220; j++) if(ef[j]==0) break;\n    }\n    time += parameter[6]; // add timeshift\n\n    zoom = parameter[2] + smoothstep(120.,180.,time)*.6 - smoothstep(240.,300.,time); // parameter[2] ~ zoomshift\n\n\n    float l, d, d2, e = .0001, aax, aay = 0.17; // ray length, current distance, epsilon, anti-aliasing    \n    \n    // objects coordinates\n    vec3 massive[] = vec3[15]\n    (\n\t    vec3(.044677,.928527,.337524),\n\t    vec3(.520019,.026367,.486328),\n\t    vec3(.026125,.984497,.337249),\n\t    vec3(.635498,.42041, .41748),\n\t    vec3(.558349,.929687,.849609),\n\t    vec3(.840576,.539917,.436889),\n\t    vec3(.096557,.049438,.537475),\n\t    vec3(.439819,.906127,.853759),\n\t    vec3(.291748,.75415, .479736),\n\t    vec3(.572753,.774047,.402343),\n\t    vec3(.565551,.614624,.542602),\n\t    vec3(.279052,.261779,.16455) - parameter[1]/vec3(70.,110.,-180.), // parameter[1] ~ shift11\n\t    vec3(.62207, .145751,.537809),\n\t    vec3(.846801,.8208,  .397094),\n\t    vec3(.905029,.469421,.400512)\n    ),\n\n    xyz, color = vec3(0.), c, grey, // 3d-coordinates, final color, aa-color\n    p, r, found1, found2, s = vec3(.5,.5,.001), // moved vector, center, rotation, found square, square size\n    norm = vec3(0.), ex = vec3(e,0.,0.), ey = vec3(0.,e,0.), ez = vec3(0.,0.,e);    \n    \n    vec2 coordVar, uv;\n    \n//aay = 0.17; // antialiasing\n//for (int by=0; by<3; by++)\n//{\n//\taax = 0.17;\n//\tfor (int bx=0; bx<3; bx++)\n//{\n//\tcoordVar = (fragCoord + vec2(aax,aay)) / iResolution.xy;\n    coordVar = fragCoord / iResolution.xy; // comment this string if you enable antialiasing\n    uv = (coordVar + vec2(parameter[7],parameter[8])) / vec2(1., 16./9.) *parameter[9]; // paremeter[7] ~ shiftX\n\n\n\tl = 1.;\t// raymarching\n    xyz = normalize(vec3(uv, 1.)); // view direction\n\n\n    for (int i=0; i<5; i++) // trace to bounding sphere for the faster computation\n    {\n        if (i>=int(parameter[3])) break; // parameter[3] ~ steps\n\t\td = 26.; // distance\n\t    for (int j=0; j<15; j++) if(j!=int(parameter[11])) // parameter[11] ~ skip\n\t    {\n\t        c = massive[j]*4.-vec3(2.);\n\t        c.z = ( c.z + zoom ) * 4.;\n\t        d = min( d, length(xyz*l - c)-0.71 ); // sphere distance function\n\t    }\n        l += d;\n        if (l>maxZ) break;\n    }\n\n    \n    if (l<maxZ)\n    {\n       if (mod(uv.y,.08)<.04) l-=parameter[12]; // parameter[12] ~ distort\n        xyz *= l; // actual point\n        \n\t    d = 26.;\n\t    for (int j=0; j<15; j++)\n\t    {\n\t        c = massive[j]*4.-vec3(2.);\n\t        found1 = c;\n\t        r = c;\n\t        c.z = ( c.z + zoom ) * 4.;\n\t        p = xyz - c; // move square to 0,0,0\n\t        p = rotate(p, time/29. * r); // rotate over axis x,y,z\n\t        r = max(p - s, -p - s); // differences\n\t        d2 = max(max(r.x,r.y),r.z); // cube distance function\n\t        if (d2 < d)\n\t        {\n\t            d = d2;\n\t            found2 = found1;\n\t        }\n\t    }\n        norm = normalize(vec3(\n        squareSingle(xyz+ex,found2)-squareSingle(xyz-ex,found2),\n        squareSingle(xyz+ey,found2)-squareSingle(xyz-ey,found2),\n        squareSingle(xyz+ez,found2)-squareSingle(xyz-ez,found2)));\n\t}\n\n    \n    c = vec3(norm.xy,1.-l/20.);\n    c+= vec3(0.,c.x,c.y/2.); // colour correction\n    color += clamp(c, 0., 1.); // accumulate aa-color\n\n//    aax += .33; // end of antialiasing loop \n//}\n//    aay += .33;\n//}  \n//    color /= 9.; // normalize aa-color\n\n\n    color = (1.-parameter[4])*color + vec3(color.x+color.z*parameter[5]) * parameter[4]; // parameter[4] ~ greyscale\n\tcolor.xz+=parameter[10]*vec2(abs(norm.y),color.z/4.); // parameter[10] ~ red\n    \n    outcolor = vec4(color * parameter[0], 1.); // parameter[0] ~ fade\n}", "image_inputs": [{"id": "Xtj3zR", "previewfilepath": "https://soundcloud.com/keensky/right-hemisphere", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/keensky/right-hemisphere", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 2423, 2452, 2452, 2682], [2685, 2685, 2759, 2759, 3119], [3122, 3122, 3173, 3173, 7133]], "test": "untested"}
{"id": "3sGSR3", "name": "Shader Showdown COOKIE-19 Final", "author": "evvvvil", "description": "Winning shader made at COOKIE party 2019 Shader Showdown. \nLive coded on stage in 25 minutes. Designed on twitch in 2 hours.\nOn stage I fucked up the materials so the colours were screwed, but I got away with it.", "tags": ["time", "demoscene", "tree", "glow", "goo", "organic", "laser", "monster", "limit", "live", "battle", "lazer", "shadershowdown", "guts"], "likes": 24, "viewed": 1198, "published": "Public API", "date": "1574523582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Winning shader made at COOKIE Party 2019 Shader Showdown\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// \"My mother-in-law has come round to our house at Christmas 7 years running. This year we're having a change. We're going to let her in.\" Les Dawson\n\nvec2 z,e=vec2(.00035,-.00035);float t,tt,d01,g; vec3 np,pp,bp,po,no,ld,al;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 ball( vec3 p,float d,float mm,float mul, float bro )\n{\n  p.z=mod(p.z+tt*10.,30.)-15.;\n  bp=p*.28; p*=bro; d01=d*.5+.5;\n  vec2 h,t=vec2 (length(p)-5.,3);\n  t.x=max(t.x,-bo(p,vec3(2.8*mul)));\n  t.x=min(t.x,length(p)-2.*mul);\n  t.x=abs(t.x)-.3; \n  pp=p;pp.xy*=r2(sin(p.z*.2)+tt*(2.-d01)*d)*(mul*.5+.5);\n  t.x=max(t.x,bo(abs(abs(pp)-vec3(0,0,2))-vec3(0,0,1),vec3(10,3,.6)));\n  np=p; np.xy*=r2(mix(tt,1.59+sin(tt*.5)*1.0,d01)*d);\n  t.x=max(t.x,np.x);     \n  h=vec2 (length(p)-5.,mm);\n  h.x=max(h.x,-bo(p,vec3(2.8*mul)));\n  h.x=min(h.x,length(p)-2.*mul);\n  h.x=abs(abs(h.x)-.1)-.05;\n  h.x=max(h.x,bo(abs(abs(pp)-vec3(0,0,2))-vec3(0,0,1),vec3(10,4,.7))); \n  h.x=max(h.x,np.x-1.); \n  t=mix(t,h,step(h.x,t.x));\n  t.x/=bro*1.5;\n  return t;  \n}\nvec2 mp( vec3 p )\n{  \n  vec2 h,t=ball(p,-1.,6.,1.,1.);\n  h=ball(p,1.,5.,1.,.28);  \n  t=mix(t,h,step(h.x,t.x));  \n  h=ball(p,-1.,6.,-1.,.19);  \n  t=mix(t,h,step(h.x,t.x));\n  h=vec2(length(p.xy)-.5,3);\n  t=mix(t,h,step(h.x,t.x));\n  h=vec2(length(cos(bp*.8+sin(p.x*.2)+sin(p.z*.2))),6);\n  g+=0.1/(0.1+h.x*h.x*4000.);\n  t=mix(t,h,step(h.x,t.x));\n  pp=bp;pp.xy*=r2(-tt+sin(pp.z));\n  h=vec2(0.3*bo(pp,vec3(30,0.001,0.001)),6);\n  g+=0.1/(0.1+h.x*h.x*40.);\n  t=mix(t,h,step(h.x,t.x));\n  return t;  \n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2 (.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>120.) t.y=0.;\n  return t;  \n}\n// rough shadertoy approximation of the bonzomatic noise texture by yx https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.83);\n  vec3 ro=vec3(cos(tt*.5)*3.,16.+sin(tt)*3.,-10.),\n  cw=normalize(vec3(0,sin(tt*.5)*10.,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n  ld=normalize(vec3(.4,.7,-.2));\n  vec2 v=vec2(abs(atan(rd.z,rd.y)),rd.x+tt*.1);\n  co=fo=vec3(.2,.3,.4)+texNoise(v*.1).r*.5;\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+\n    e.yyx*mp(po+e.yyx).x+\n    e.yxy*mp(po+e.yxy).x+\n    e.xxx*mp(po+e.xxx).x);    \n    al=mix(vec3(.25,.5,0),vec3(.0,.2,.3),min((length(bp)-2.5),1.));\n    if(z.y<5.) al=vec3(0);\n    if(z.y>5.) al=vec3(1);\n    float dif=2.*max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),10.);    \n    co=mix(sp+al*(a(.2)*a(.4)+.2)*(dif+s(.4)+s(1.)),fo,min(fr,0.2));\n    co=mix(fo,co,exp(-.00001*t*t*t));\n  } \n  fragColor = vec4(pow(co+vec3(0.1,0.2,0.3)*g*.6,vec3(.45)),1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 538, 562, 562, 603], [604, 604, 621, 621, 664], [665, 665, 724, 724, 1403], [1404, 1404, 1423, 1423, 1896], [1897, 1897, 1926, 1926, 2094], [2095, 2204, 2227, 2227, 2431], [2521, 2521, 2578, 2578, 3616]], "test": "untested"}
{"id": "3sGSRh", "name": "Simple ray marching 101", "author": "mgjunior", "description": "Simple ray marching 101", "tags": ["raymarching"], "likes": 0, "viewed": 25, "published": "Public", "date": "1573308702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float perStep=0.4;\nconst float PI = 3.14;\nconst float epsilon = 0.001;  \n\nstruct Ray\n{\n    vec3 from; // position\n    vec3 dir; // vector\n};\n\nRay[4] createRayDiff(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    vec2[4] multisampleDiff;\n    float x = 0.5;\n    float y =0.5;\n    // offset from p\n    multisampleDiff[0]=vec2(x,y)/iResolution.y;   \n    multisampleDiff[1]=vec2(-y,x)/iResolution.y; \n    multisampleDiff[2]=vec2(-x,-y)/iResolution.y;\n    multisampleDiff[3]=vec2(y,-x)/iResolution.y;\n\n    Ray[4] rays;\n    for(int i=0;i<4;++i){\n        rays[i].from =p+( multisampleDiff[i].x*xAxis + multisampleDiff[i].y*yAxis );\n        rays[i].dir =normalize(rays[i].from-eye);\n    }\n\n    return rays;\n}\n\n// from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdVerticalCapsule( vec3 p, float h, float r,float offset )\n{\n    p.y -= clamp( p.y, offset, h+offset );\n    return length( p ) - r;\n}\n\nfloat bottle(vec3 pos){\n\tfloat H =2.,R =1.,Offset=0.;\n\tfloat h=1.,r=0.25,offset =3.;\n    \n    //return sdVerticalCapsule(pos,h,r,offset);\n    return min(sdVerticalCapsule(pos,H,R,Offset),sdVerticalCapsule(pos,h,r,offset));\n}\n\n// gradient is normal\nvec3 getNormal(vec3 pos){\n    float delta =0.01;\n    vec3 temp=vec3(bottle(pos+vec3(delta,0.,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,delta,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,0.,delta))-bottle(pos)\n                  );\n\treturn normalize(temp);\n}\n\nvec3 shading(Ray ray,vec3 eye){\n    vec3 shadingColor = vec3(0.0,0.0,0.0);\n    \n    // 物件 3軸 and 位移obj_offset\n    vec3 obj_offset=vec3(0.,1.,0.);\n    vec3 zAxis =vec3(0.,0.,1.);\n    float para_obj_rot=iTime;\n    vec3 yAxis = vec3(-sin(para_obj_rot),cos(para_obj_rot),0.);\n    vec3 xAxis =vec3(cos(para_obj_rot),sin(para_obj_rot),0.);\n    \n    \n\t// 座標變換\n\t// http://gpnnotes.blogspot.com/2018/10/worldpointvector.html\n    \n    // to local space(變換到物件的local座標系)\n    vec3 temp=(ray.from-obj_offset);\n    Ray localRay;\n    localRay.from =vec3(dot(xAxis,temp),dot(yAxis,temp),dot(zAxis,temp));\n    localRay.dir=vec3(dot(xAxis,ray.dir),dot(yAxis,ray.dir),dot(zAxis,ray.dir));\n    \n    vec3 lightDir=normalize(vec3(1.,1.,1.));\n    vec3 localLightDir =vec3(dot(xAxis,lightDir),dot(yAxis,lightDir),dot(zAxis,lightDir));\n    \n    //front side of bottle\n    vec3 final_color=vec3(0.2,0.2,0.2);\n    for(int i=0;i<20;i++){ // 改小一點試看看會怎樣\n    \tfloat dist = bottle(localRay.from);\n        if(dist<0.01){\n            \n            //shading bottle color\n            vec3 n=getNormal(localRay.from);\n        \tfinal_color= vec3(0.0,1.0,0.75)*max(0.,dot(n,localLightDir)) // 燈光1\n                +vec3(1.0,1.0,0.0)*max(0.,dot(n,-localLightDir)); // 燈光2\n            \n            break;\n        }\n        \n        localRay.from+=dist*localRay.dir;\n    }\n    \n    return final_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // weight (from -1 to 1)\n    vec2 weight = fragCoord/iResolution.xy;\n    weight= weight*2.0-1.0;\n\n    vec3 lookAt =vec3(0.0,1.0,0.0);\n    vec3 eye = vec3(0.0,1.0,5.0);\n    //vec3 eye = lookAt+ 5.0*vec3(cos(iTime),0.0,sin(iTime))+vec3(0.0,1.0,0.0);\n\n    // camera 3軸\n    vec3 zAsix = normalize(eye-lookAt);\n    vec3 yAxis = vec3(0.0,1.0,0.0);\n    vec3 xAxis = cross(yAxis,zAsix);\n    \n    //view frustum 近平面(z = -1) 這裡用右手座標\n    //這裡就是projection matrix對x,y做的事，反過來做\n    float fovDegree =90.0;\n    float halfFov = radians(0.5*fovDegree);\n    float tanH = tan(halfFov);\n    float tanW = tanH*iResolution.x/iResolution.y;\n\n    // generate point from the plane\n    vec3 pointOnPlane = eye -zAsix + xAxis*weight.x*tanW + yAxis*weight.y*tanH;\n    \n    // Antialiasing (多射幾條，取平均)\n    Ray[4] rays =createRayDiff(eye,xAxis,yAxis,pointOnPlane);\n    \n    vec3 color= vec3(0.0,0.0,0.0);\n    for(int i=0;i<1;++i) // 只射1條、不然手機跑起來超慢\n        color += shading(rays[i],eye);\n    //color *=0.25;\n\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 783, 849, 849, 922], [924, 924, 947, 947, 1148], [1150, 1172, 1197, 1197, 1453], [1455, 1455, 1486, 1486, 2878], [2880, 2880, 2937, 2966, 4041]], "test": "untested"}
{"id": "3sGSRV", "name": "primera cruz", "author": "jorge2017a1", "description": "primera cruz", "tags": ["primeracruz"], "likes": 1, "viewed": 34, "published": "Public", "date": "1574370705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n\n///-----------------------------------------\n\n///--------------------------------------------\n\n// For unions \n/*float unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}*/\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n\n\n//Coordinate positioning of each shape\nfloat GetDist(vec3 p) {\t\n\n \t\n    float planeDist = p.y+5.5;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,3.0,5.0),vec3(1.0,4.5,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,5.0,5.0),vec3(3.3,0.5,1.0));  //palo horizontal\n    float bx2a = sdBox (p-vec3(0.,5.0,5.5),vec3(3.0,0.4,1.8));  //palo horizontal\n    \n    \n    float bx3 = sdBox (p-vec3(0.,0.5,5.0),vec3(3.0,0.5,2.0));  //escalon1\n    float bx5 = sdBox (p-vec3(0.,-0.5,5.0),vec3(4.5,0.6,4.0)); //escalon2 \n    float bx4 = sdBox (p-vec3(0.,-4.5,5.0),vec3(5.5,3.5,4.5)); //escalon3\n    \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    //float  db1= dBar(p.xy-vec2(0.0,2),0.5);\n  \n    float dif1, dif2, dif3;\n    \n    \n    d=1000.0;\n    d=min(d,planeDist);\n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    //intersectSDF\n    //unionSDF\n    //differenceSDF\n    \n   \n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos1 = vec3(1, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(0, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\n\nfloat GetLightv3(vec3 p) {\n    vec3 lightPos1 = vec3(-1, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(2, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    \n    vec3 lightPos3 = vec3(-2.5, 5.5, 0.5);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos3.xy += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l3 = normalize(lightPos3-p);\n    vec3 n3 = GetNormal(p);\n    \n    float dif3 = clamp(dot(n3, l3), 0., 1.);\n    float d3 = RayMarch(p+n3*SURF_DIST*2., l3);\n    if(d3<length(lightPos3-p)) dif3 *= .1;\n    \n    \n    return (dif1+dif2+dif3)/3.0;\n}\n\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n    \n    vec3 lightPos1 = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    vec3 lightPos2 =lpos;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(0.0, cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n    //vec3 ro = vec3(0, 1.0, 0);\n    //vec3 ro = vec3(2.0+2.0*cos(iTime), 4.5, -4.0+2.0*cos(iTime));\n    vec3 ro = vec3(2.0+2.0*cos(iTime), 4.5, -12.0);\n    \n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = (ro + rd * d );  //+texture(iChannel0, uv).x;\n    \n    float dif = GetLight(p);\n    float dif3= GetLightv3(p);\n    \n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    dif=dif3+dif;\n    col = vec3(dif)+col2*dif;\n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSRV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[348, 365, 398, 398, 463], [468, 486, 522, 522, 591], [592, 607, 638, 638, 788], [789, 809, 845, 845, 932], [933, 949, 981, 1009, 1070], [1169, 1365, 1411, 1411, 1443], [1445, 1445, 1487, 1487, 1519], [1521, 1521, 1568, 1568, 1601], [1606, 1645, 1668, 1668, 2767], [2769, 2769, 2803, 2803, 3037], [3039, 3039, 3063, 3063, 3295], [3297, 3297, 3321, 3321, 3705], [3710, 3710, 3736, 3736, 4537], [4540, 4540, 4566, 4566, 5771], [5775, 5775, 5813, 5813, 6596], [6598, 6598, 6655, 6655, 7319]], "test": "untested"}
{"id": "3sGSWV", "name": "Improved film grain", "author": "noby", "description": "A lot of \"film grain\" shaders usually just default to some sort of white or value noise summation. This rarely looks like realistic grain present on most film reproductions. Here instead we perform a more convincing high-pass operation on value noise.", "tags": ["noise", "postprocessing", "film", "grain"], "likes": 16, "viewed": 741, "published": "Public", "date": "1574951410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licensed under the MIT license:\n// https://opensource.org/licenses/MIT.\n\n#define USE_COLOR_GRAIN\n\n// From Dave Hoskins: https://www.shadertoy.com/view/4djSRW.\nfloat hash(vec3 p3){\n    p3 = fract(p3 * 0.1031);\n    p3 += dot(p3,p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// From iq: https://www.shadertoy.com/view/4sfGzS.\nfloat noise(vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hash(i+vec3(0, 0, 0)), \n                       hash(i+vec3(1, 0, 0)),f.x),\n                   mix(hash(i+vec3(0, 1, 0)), \n                       hash(i+vec3(1, 1, 0)),f.x),f.y),\n               mix(mix(hash(i+vec3(0, 0, 1)), \n                       hash(i+vec3(1, 0, 1)),f.x),\n                   mix(hash(i+vec3(0, 1, 1)), \n                       hash(i+vec3(1, 1, 1)),f.x),f.y),f.z);\n}\n\n// Slightly high-passed continuous value-noise.\nfloat grain_source(vec3 x, float strength, float pitch){\n    float center = noise(x);\n\tfloat v1 = center - noise(vec3( 1, 0, 0)/pitch + x) + 0.5;\n\tfloat v2 = center - noise(vec3( 0, 1, 0)/pitch + x) + 0.5;\n\tfloat v3 = center - noise(vec3(-1, 0, 0)/pitch + x) + 0.5;\n\tfloat v4 = center - noise(vec3( 0,-1, 0)/pitch + x) + 0.5;\n    \n\tfloat total = (v1 + v2 + v3 + v4) / 4.0;\n\treturn mix(1.0, 0.5 + total, strength);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    vec2 x = fragCoord;\n    // Alternatively use iTime here instead and change the grain_rate\n    // parameter to correspond to frames-per-second.\n    float t = mix(0.0, float(iFrame), step(0.5, uv.x));\n    vec3 color = mix(texture(iChannel0, uv*2.0).rgb, vec3(0.5), step(0.5, uv.y));\n    vec3 grain = vec3(0);\n    \n    const float grain_strength = 1.0;\n    const float grain_rate = 1.0;\n    // Range: [0.5, 1.0].\n    const float grain_pitch = 1.0;\n    \n#ifdef USE_COLOR_GRAIN\n    float rg = grain_source(vec3(x, floor(grain_rate*(t))),     grain_strength, grain_pitch);\n    float gg = grain_source(vec3(x, floor(grain_rate*(t+9.0))), grain_strength, grain_pitch);\n    float bg = grain_source(vec3(x, floor(grain_rate*(t-9.0))), grain_strength, grain_pitch);\n    \n    // Consider using values outside the [0, 1] range as well\n    // to introduce interesting color shifts to the source.\n    const float color_level = 1.0;\n    vec3 color_grain = vec3(rg, gg, bg);\n    color_grain = mix(vec3(dot(color_grain, vec3(0.2126, 0.7152, 0.0722))), color_grain, color_level);\n    grain = color_grain;\n#else\n    const float neutral_grain_factor = sqrt(2.0);\n    grain = vec3(grain_source(vec3(x, floor(grain_rate*t)), grain_strength/neutral_grain_factor, grain_pitch));\n#endif\n    \n    // Control whether to add or multiply or lift the source with the grain.\n    // Multiply (0.0) should be more true to life, but adjust to taste.\n    const float grain_lift_ratio = 0.5;\n    color = max(mix(color*grain, color+(grain-1.0), grain_lift_ratio), 0.0);\n    \n    // After this you would normally perform tone mapping,\n    // apply the grain before that.\n    fragColor.rgb = color;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSWV.jpg", "access": "shaders20k", "license": "mit", "functions": [[101, 162, 182, 182, 287], [289, 340, 360, 360, 840], [842, 890, 946, 946, 1305], [1307, 1307, 1361, 1361, 3070]], "test": "untested"}
{"id": "3sGSWW", "name": "Symmetric Smooth Staircase", "author": "grinist", "description": "This is a fork of iq's [url=https://www.shadertoy.com/view/ttBXRG]Smooth Staircase[/url].\nWhen I saw it I had to try. All I did was substitute the gain function. Rationale in comments.", "tags": ["2d", "graph", "staircase"], "likes": 3, "viewed": 275, "published": "Public API", "date": "1573989373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Symmetric Smooth Staircse\n// This is a fork of iq's Smooth Staircase (https://www.shadertoy.com/view/ttBXRG). When I saw it I had to try.\n// All I did was substitute the gain function with one of my favorite interpolation functions.\n// As it is based on 1/x, it has the nice property of being symmetric wrt the diagonal y = x.\n// Ie. for y = 1/x, it also holds that x = 1/y; if point (4, 0.25) is on the curve, so is (0.25, 4).\n// For a smooth staircase it's perfect, it's as if the stair corners were pinched out at right angles from the straight diagonal.\n\n// See: https://www.shadertoy.com/view/Xd2yRd\n// Interpolates from 0 to 1 with slope of k at x=0 and x=1.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxEase2(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0); // clamp optional, if you know your k\n    x = 0.5 - x; // re-center at 0\n    float s = sign(x);\n    x = clamp(abs(x) * 2.0, 0.0, 1.0);\n    return 0.5 + 0.5 * s * x / (x * (k - 1.0) - k);\n}\n\n\n// License for the original Smooth Staircase: https://www.shadertoy.com/view/ttBXRG\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Staircase function y=f(x)\n//\n// k>1 : starts with vertical step\n// k<1 : starts with horizontal step\n// [Previous description didn't apply, as the steps are as much horizontal as they are vertical]\n//\n// The inverse function x=f^-1(x) is just the function itselft\n// with parameter 1/k instead of k.\nfloat staircase( in float x, in float k )\n{\n    float i = floor(x);\n    float f = fract(x);\n\n    return i + rxEase2(f, k);\n    \n    //float a = 0.5*pow(2.0*((f<0.5)?f:1.0-f), k);\n    //f = (f<0.5)?a:1.0-a;\n    \n    //return i+f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // coordinates    \n    float dx = 3.0/iResolution.y;\n    vec2  p = fragCoord.xy*dx;\n    \n    // animate staircase curve\n    float k = pow( 2.0, 8.0*sin(3.1415927*iTime));\n    \n    // background\n    vec3 col = vec3( 0.2 + 0.02*mod(floor(p.x)+floor(p.y),2.0) );\n\n    // draw curve y=f(x)\n    float y = staircase( p.x, k );\n    col = mix( col, vec3(0.2,0.9,0.7), 1.0-smoothstep(0.0, 2.0*dx, abs(p.y-y) ) );\n    \n    // draw curve x=f^-1(x)\n    float x = staircase( p.y, 1.0/k );\n    col = mix( col, vec3(0.2,0.9,0.7), 1.0-smoothstep(0.0, 2.0*dx, abs(p.x-x) ) );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[562, 738, 771, 771, 995], [2161, 2464, 2507, 2507, 2694], [2697, 2697, 2754, 2778, 3359]], "test": "untested"}
{"id": "3sGSzc", "name": "Tri Voronoi another coloring", "author": "aiekick", "description": "Triangular Voronoi another coloring", "tags": ["voronoi", "triangular", "anothercoloring"], "likes": 15, "viewed": 372, "published": "Public API", "date": "1574551907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via NoodlesPlate (https://github.com/aiekick/NoodlesPlate/releases)\n\nconst vec3 color0 = vec3(0.2,0.1,0.3);\nconst vec3 color1 = vec3(0.6,0.1,1.9);\nconst vec3 lightColor = vec3(0.7,1.6,0.6);\n\nvec3 shape(vec2 g)\n{\n\tfloat c = 9.0;\n    \t\n    float t = iTime;\n\tfloat t1 = t * 0.1;\n\t\n\tvec2 p = vec2(0), sp = p;\n\t\n    g *= 2.0;\n    \n    for(int x=-2;x<=2;x++)\n    for(int y=-2;y<=2;y++)\n    {\t\n        p = vec2(x,y);\n        p += .5 + .5*sin( t1 * 10. + 9. * fract(sin((floor(g)+p)*mat2(2,5,5,2)))) - fract(g);\n        p *= mat2(cos(t1), -sin(t1), sin(t1), cos(t1));\n        float d = max(abs(p.x)*.866 - p.y*.5, p.y);\n        if (d < c)\n        {\n            c = d;\n            sp = p;\n        }\n    }\n\n    return vec3(c,sp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\t\n\tfloat t = iTime * 0.5;\n\t\n    float k = 0.01;\n\tvec3 f = shape(uv);\n\tfloat fx = shape(uv + vec2(k,0.0)).x-f.x;\n\tfloat fy = shape(uv + vec2(0.0, k)).x-f.x;\n\t\n    vec3 n = normalize(vec3(fx, 0.1, fy) );\n\t\n\tvec3 col = mix( color0, color1, f.x );\n\n    float r = sin(t + f.y)*cos(t + f.z) * .5 + .5;\n\tcol = mix(col.xyz, mix(col.zxy, col.yzx, r), 1.-r);\n    \n\tcol += .4 * pow(max(dot( n, vec3(0,1,0)), 0.), 100.) * lightColor;\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSzc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 356, 376, 376, 886], [888, 888, 945, 945, 1466]], "test": "untested"}
{"id": "3sGSzw", "name": "Why pmod is heavier than ForLoop", "author": "ankd", "description": "(2019/11/14) atan() in pmod is heavier than a few for loops.\n-----\nI try to implement polar mod, I think polar mod is faster than for loop replication, but it's didn't happen while OBJ_NUM is small. \nWhat is the cause?", "tags": ["raymarching", "replication", "pmod", "forloop", "polarmod"], "likes": 1, "viewed": 83, "published": "Public", "date": "1573582323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TEST_ITR    ... testing count using for loop.\n// OBJ_NUM     ... as the name suggests.\n// ENABLE_PMOD ... when is defined it, use polar mod. \n//                 please comment out to compare.\n// ANIMATE     ... object animate.\n#define TEST_ITR 50\n#define OBJ_NUM 12\n//#define ENABLE_PMOD\n#define ANIMATE\n\nconst float PI = acos(-1.);\nconst float TWO_PI = 2.*PI;\n\nmat2 rotate(float a) { float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }\n// polar mod definition\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + PI / r;\n    float n = TWO_PI / r;\n    a = floor(a / n) * n;\n    return rotate(-a)*p;\n}\n\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\n#define repeat(p,c) mod(p,c)-0.5*c\nfloat object( in vec3 p ) {\n\tfloat res = 1e4;\n#ifdef ANIMATE\n    p.z -= mod(iTime, 1.);\n#endif\n    p.z = repeat(p.z, 1.);\n\n    for(int j=0;j<TEST_ITR;j++) {\n#ifdef ENABLE_PMOD\n\t    p.xy = pmod(p.xy, float(OBJ_NUM));\n\t    res = min(res, sphere(p-vec3(0., 1., 0.), 0.2));\n#else\n\t    for(int i=0;i<OBJ_NUM;i++) {\n\t        float fi = float(i);\n\t        float theta = fi * 2.*PI / float(OBJ_NUM);\n\t       \tvec3 o = vec3(cos(theta), sin(theta), 0.);\n\t        float r = 0.2;\n\t\t    res = min(res, sphere(p-o, r));\n\t    }\n#endif\n    }\n    return res;\n}\n\nfloat oMarch(in vec3 ro, in vec3 rd, in vec2 tmm) {\n\tfloat t = tmm.x;\n    for(int i=0;i<100;i++) {\n    \tfloat d = object(ro + rd*t);\n        if(d<1e-4) break;\n        t += d;\n    }\n    if(tmm.y<t) return -1.;\n    return t;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv) {\n\tvec2 cmm = vec2(0., 10.);\n    float t = oMarch(ro, rd, cmm);\n    vec3 col;\n    if(t<0.) {\n        col = vec3(0.);\n    } else {\n\t    col = vec3(exp(-.1*t));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = (fragCoord.xy*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(0., 0., 2.);\n    vec3 rd = normalize(vec3(p, -1.));\n    \n    vec3 col = render(ro, rd, uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 365, 387, 387, 438], [439, 463, 491, 491, 609], [611, 611, 648, 648, 672], [708, 708, 735, 735, 1251], [1253, 1253, 1304, 1304, 1477], [1480, 1480, 1529, 1529, 1710], [1712, 1712, 1769, 1769, 2065]], "test": "untested"}
{"id": "3sGXD1", "name": "Happy Planet", "author": "andremichelle", "description": "Naive Planet Factory", "tags": ["planet"], "likes": 6, "viewed": 405, "published": "Public API", "date": "1573853221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define s(a,b,c) smoothstep(a,b,c)\n\nfloat Hash(in vec2 p, in float scale) {\n\treturn fract(sin(dot(mod(p, scale), vec2(27.16898, 38.90563))) * 1.5473453);\n}\n\nfloat Noise(in vec2 p, in float scale ) {\n\tvec2 f;\n\tp *= scale;\n\tf = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(Hash(p, scale),\n\t\t\tHash(p + vec2(1.0, 0.0), scale), f.x),\n\t\t\tmix(Hash(p + vec2(0.0, 1.0), scale),\n\t\t\tHash(p + vec2(1.0, 1.0), scale), f.x), f.y);\n}\n\nfloat fbm(in vec2 p) {\n\tfloat f = 0.0;\n\tfloat scale = 10.;\n    p = mod(p, scale);\n\tfloat amp   = .6;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += Noise(p, scale) * amp;\n\t\tamp *= .5;\n\t\tscale *= 2.;\n\t}\n\treturn min(f, 1.0);\n}\n\nvec3 check(vec2 uv) {\n    const float s = 20.;\n    return vec3(.12+0.06*mod(floor(s*uv.x)+floor(s*uv.y),2.0));\n}\n\nvec4 over( in vec4 a, in vec4 b ) {\n    return mix(a, b, 1.-a.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*2.;\n    \n\tfloat len = length(uv);\n    float time = iTime + 33.;\n    \n    float size = .8;\n    vec2 sc = fract(uv*asin(len/size)/(len*PI*2.));\n    sc.x += time*.006;\n\n    vec4 c = vec4(.0);\n\n    float alpha = smoothstep(.0, .01, size-len);\n    float value = pow(fbm(sc), 0.75);\n\n    c = over(vec4(vec3(.00,.00,.20), s(.99, .80, value) * alpha), c);\n    c = over(vec4(vec3(.02,.14,.47), s(.80, .63, value) * alpha), c);\n\tc = over(vec4(vec3(.82,.68,.56), s(.63, .60, value) * alpha), c); // sand\n    c = over(vec4(vec3(.25,.41,.13), s(.61, .52, value) * alpha), c); // green coast\n    c = over(vec4(vec3(.35,.28,.20), s(.52, .50, value) * alpha), c);\n    c = over(vec4(vec3(.62,.48,.36), s(.50, .40, value) * alpha), c);\n    c = over(vec4(vec3(.38,.34,.26), s(.40, .30, value) * alpha), c);\n    c = over(vec4(vec3(.38,.31,.20), s(.21, .10, value) * alpha), c);\n    c = over(vec4(vec3(1.0,1.0,1.0), s(.20, .00, value) * alpha), c);\n\n    sc.x += time*.0014;\n    value = fbm(sc*3.);\n    c = over(vec4(vec3(0.), s(.21, .10, pow(value, 2.)) * alpha * 0.50), c);\n    c = over(vec4(vec3(1.), s(.20, .00, pow(value, 3.)) * alpha * 0.75), c);\n    c.rgb *= smoothstep(1., .7, len);\n    c = over(vec4(vec3(.0, .3, .6), s(.9, .00, pow(abs(size-len), .2))), c);\n    \n\tc = over(vec4(vec3(1.), pow(distance(uv, vec2( .98, .3)), -0.4+sin(time)*.04)*.040), c);\n\tc = over(vec4(vec3(1.), pow(distance(uv, vec2(-.9, -.6)), -1.2+sin(time)*.04)*.001), c);\n    \n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 94, 94, 174], [176, 176, 217, 217, 464], [466, 466, 488, 488, 682], [684, 684, 705, 705, 796], [798, 798, 833, 833, 865], [867, 867, 924, 924, 2434]], "test": "untested"}
{"id": "3sGXDc", "name": "Cuarto chico-color", "author": "jorge2017a1", "description": "Cuarto chico-color", "tags": ["cuartochicocolor"], "likes": 0, "viewed": 41, "published": "Public", "date": "1575121789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge flores ----jorge2017a1---fecha---30/nov/2019\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int cPlane = 6;\nconst int CLight = 7;\n\n\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n// For unions \n/*float unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}*/\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 9:\n        return vec3(85./255., 205./255., 252./255.); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n//-------------------------------------------------\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    //float planeDist = p.y;\n  \t//float sp = sdSphere (p-vec3(0.0), 1.0);\n    //float bx = sdBox (p-vec3(-2.,0.5,6.),vec3(0.65,0.5,0.5));\n    //float co = sdCone (p-vec3(0.,0.2,3.5),vec2(0.4,0.05));\n    //float tri = sdTriPrism (p-vec3(2,0.2,6),vec2(1.1,0.2));\n    //float tor = sdTorus(p-vec3(-3.,0.1,4.5),vec2(0.4,0.15));\n    //float d = min(sp , planeDist); \n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,0.5));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,0.5));\n    float bxAtras = sdBox (p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.3));\n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.3,0.8,0.4));\n    \n    \n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    \n    \n    \n    float  spLuz = sdSphere (p-vec3(0.0), 0.5);\n    vec2 res;\n    res = vec2(9999, 0);\n    \n    res = opU(res, vec2(planeDist, cPlane));\n    res = opU(res, vec2(bxInf, CInf));\n    res = opU(res, vec2(bxDer, CDer));\n    res = opU(res, vec2(bxIzq, CIzq));\n        \n        \n    \n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n\n    \n    res = opU(res, vec2(dif1, CAtras));\n    \n    \n       \n    dif2=differenceSDF(bxSup,bxSupVentana);     \n    res = opU(res, vec2(dif2, CSup));\n    res = opU(res, vec2(spLuz, CLight));\n  \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, 0);\n\n    vec3 rLuz=vec3(-0.5, 1.5, -5.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    float dif = GetLight(p);\n    float dif2 = GetLight(pluz);\n    \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    \n\n    \n    dif=(dif+dif2)/1.5;\n    \n    col = vec3(dif)*colobj;\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 363, 396, 396, 461], [462, 480, 516, 516, 585], [586, 601, 632, 632, 782], [783, 803, 839, 839, 926], [927, 943, 975, 1003, 1064], [1115, 1311, 1357, 1357, 1389], [1391, 1391, 1433, 1433, 1465], [1467, 1467, 1514, 1514, 1547], [1550, 1550, 1579, 1579, 1705], [1707, 1759, 1787, 1787, 2631], [2632, 2686, 2711, 3078, 4413], [4416, 4416, 4450, 4450, 4684], [4690, 4690, 4714, 4714, 4946], [4950, 4950, 4974, 4974, 5359], [5366, 5366, 5423, 5423, 6090]], "test": "untested"}
{"id": "3sGXRc", "name": "RaymarchCircleShadow2", "author": "KeeganPillow", "description": "Doing a weird thing seemed to smooth it out a bit. Not sure if this is a good step though.", "tags": ["raymarchmouseshadow"], "likes": 1, "viewed": 44, "published": "Public", "date": "1574545394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITS 256\n#define CIRCLE_RAD_MOD 50.0f\n\n//Finds the distance to a given circle\nfloat distToCirc(vec2 point, vec2 centerCirc, float radius)\n{\n    float dist = length(point - centerCirc);\n    \n    dist -= radius;\n    \n    if (dist < 0.0)\n    {\n        dist = 0.0;\n    }\n    \n   return dist;\n}\n\n\n//Raymarching:\nfloat rayMarching (vec2 camPos, vec2 pixPos, vec2 obj, float radius)\n{\n    //Logic\n    float dist = 0.0;\n    float totalDist = 0.0;\n    bool hit = false;\n    \n    //Massage inputs\n    vec2 dirToPix = normalize(pixPos - camPos);\n    float distToCam = length(pixPos - camPos);\n    \n    //Output\n    float depth = 0.0;\n    \n    //Constants\n    const float depthStepSize = 1.0;\n    \n    //Loop\n    for (int i = 0; i < MAXITS; ++i)\n    {\n    \n        //Find distance to nearest object from camera.\n        dist = distToCirc(obj, camPos, radius);\n\n        if (dist == 0.0) hit = true;\n        \n        //If dist > 0\n        if (!hit)\n        {\n            //Move in direction of raycast.\n            camPos += dirToPix * dist;\n            //Add to the total distance\n            totalDist += dist;\n            \n            if (dist < radius / 100.0)\n            {\n                depth += ((radius / radius) - (dist / radius));\n            }\n        }\n        //Has hit\n        else\n        {\n            if (dist > 0.0)\n            {\n               depth += (depthStepSize - dist);\n               break;\n            }\n            \n             //Move in direction of raycast.\n            camPos += dirToPix * depthStepSize;\n            //Add to the total distance\n            totalDist += depthStepSize;\n            //Add to the depth\n            depth += depthStepSize;\n        }\n\n\n        if (totalDist >= distToCam)\n        {\n            break;\n        }\n    } //Repeat until distance covered, or collided.\n    return depth;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Object\n  vec2 obj = vec2(iResolution.x / 2.0 + sin(iTime) * 20.0, iResolution.y / 2.0);\n      \n  //Main loop:\n\n  //Camera is the mouse position.\n  vec2 camPos = iMouse.xy;\n  float radius = min(0.0, sin(iTime) * 10.0) + CIRCLE_RAD_MOD;\n    \n    //Raymarch to pixel from cam position. \n  float depth = rayMarching(camPos, fragCoord, obj, radius);\n    \n  //Normalize depth\n  depth /= (radius * 2.0);\n  \n  //Check if no object was hit\n  if (depth == 0.0)\n      {\n          \n          fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n  else\n      {\n          fragColor = vec4(1.0 - depth, 0.0, 0.0, 1.0);\n      }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 88, 149, 149, 299], [302, 317, 387, 399, 1841], [1842, 1842, 1899, 1910, 2510]], "test": "untested"}
{"id": "3sGXRm", "name": "stripey bitey pacman", "author": "thisisthais", "description": "i'm anti anti-aliasing", "tags": ["noise", "tbos"], "likes": 3, "viewed": 36, "published": "Public", "date": "1573680521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 random2D(vec2 st){\n  st=vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)));\n  return-1.+2.*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st){\n  vec2 i=floor(st);\n  vec2 f=fract(st);\n  // mixing function\n  vec2 u=f*f*(3.-2.*f);\n  \n  return mix(mix(dot(random2D(i+vec2(0.,0.)),f-vec2(0.,0.)),\n  dot(random2D(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n  mix(dot(random2D(i+vec2(0.,1.)),f-vec2(0.,1.)),\n  dot(random2D(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n}\n\nfloat circle(in vec2 _st,in float _radius){\n  vec2 l=_st-vec2(.5);\n  return 1.-smoothstep(_radius-(_radius*.01),\n  _radius+(_radius*.01),\n  dot(l,l)*4.);\n}\n\nfloat shape(vec2 st,float radius){\n  st=st-vec2(.5);\n  float r=length(st)*2.;\n  float a=atan(st.y,st.x);\n  float m=abs(mod(2.*iTime,2.*PI)-PI)/a*2.2;\n  float f=radius;\n  m+=noise(st+iTime*.1)*.5;\n  \n  f+=sin(a*100.)*noise(st+iTime*.2)*.1;\n  f+=(sin(a*100.)*.1*pow(m,2.));\n  return 1.-smoothstep(f,f+.007,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st=fragCoord.xy/iResolution.y;\n  vec3 color=vec3(0.);\n  color=vec3(shape(st,.5));\n  \n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 58, 58, 169], [171, 256, 277, 277, 585], [587, 587, 630, 630, 742], [744, 744, 778, 778, 1053], [1055, 1055, 1111, 1111, 1233]], "test": "untested"}
{"id": "3sGXWV", "name": "cuarto chiquito", "author": "jorge2017a1", "description": "cuarto chiquito", "tags": ["cuartochiquito"], "likes": 0, "viewed": 50, "published": "Public", "date": "1574954650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 28-nov-2019\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n// For unions \n/*float unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}*/\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n///----------------------------------------------\n\n\n\n\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    //float planeDist = p.y;\n  \t//float sp = sdSphere (p-vec3(0.0), 1.0);\n    //float bx = sdBox (p-vec3(-2.,0.5,6.),vec3(0.65,0.5,0.5));\n    //float co = sdCone (p-vec3(0.,0.2,3.5),vec2(0.4,0.05));\n    //float tri = sdTriPrism (p-vec3(2,0.2,6),vec2(1.1,0.2));\n    //float tor = sdTorus(p-vec3(-3.,0.1,4.5),vec2(0.4,0.15));\n    //float d = min(sp , planeDist); \n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,0.5));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,0.5));\n    float bxAtras = sdBox (p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.3));\n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.3,0.8,0.4));\n    \n    \n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    \n    \n    \n    float  spLuz = sdSphere (p-vec3(0.0), 0.5);\n    \n    d = min(d,planeDist); \n    d = min(d,bxInf);\n    d = min(d,bxDer);\n    d = min(d,bxIzq);\n    //d = min(d,bxSup);\n    //d = min(d,bxAtras);\n    //d = min(d,bxAtrasVentana);\n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n    //d = min(d,bxAtrasPuerta);\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n    d=min(d,dif1);\n    \n    //d=min(d,bxSupVentana);\n    \n    dif2=differenceSDF(bxSup,bxSupVentana);\n    d=min(d, dif2);\n    \n  \n    \n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n\n    vec3 ro = vec3(0, 2.5, 0);\n\n    vec3 rLuz=vec3(0.5, 1.5, -5.5);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = (ro + rd * d ); \n    vec3 pluz=(rLuz + rd * d );\n    \n    float dif = GetLight(p);\n    float dif2 = GetLight(pluz);\n    \n\n    \n    dif=(dif+dif2)/1.5;\n    \n    col = vec3(dif);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 117, 150, 150, 215], [216, 234, 270, 270, 339], [340, 355, 386, 386, 536], [537, 557, 593, 593, 680], [681, 697, 729, 757, 818], [869, 1065, 1111, 1111, 1143], [1145, 1145, 1187, 1187, 1219], [1221, 1221, 1268, 1268, 1301], [1303, 1358, 1383, 1750, 2938], [2941, 2941, 2975, 2975, 3209], [3215, 3215, 3239, 3239, 3471], [3475, 3475, 3499, 3499, 3884], [3891, 3891, 3948, 3948, 4489]], "test": "untested"}
{"id": "3sGXWw", "name": "simple line-plane intersection", "author": "neur0sys", "description": "Simple line-plane intersection with basic lighting and texture", "tags": ["lineplaneintersection"], "likes": 3, "viewed": 131, "published": "Public", "date": "1574124634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n// https://en.wikipedia.org/wiki/Specular_reflection#Law_of_reflection\n// https://en.wikipedia.org/wiki/Lambertian_reflectance\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y = 1.0 - uv.y;\n    uv = uv * 2.0 - 1.0;\n \tuv *= iResolution.x / iResolution.y;\n    \n    // plane equation\n    // (p - p0) . n = 0\n    \n    // ray equation\n    // p = l0 + l * t\n    \n    // solve for parameter t\n    // t = ((p0 - l0) . n) / (l . n)\n    \n    vec3 n = vec3(0.0, 1.0, 0.0);\n    vec3 p0 = vec3(-1.0, -1.0, -1.0);\n\tvec3 l0 = vec3(0.0, 0.0, 1.0);\n    vec3 l = normalize(vec3(uv, -1.0));\n \n    float yOffset = sin(iTime) * 2.0 + 2.0;\n    float zOffset = cos(iTime) * 3.0 + 3.0;\n    float xOffset = cos(iTime) * 4.0 + 4.0;\n    \n    l0.y += yOffset;\n    l0.z += zOffset;\n    l0.x += xOffset;\n    \n    float denom = dot(n, l);\n    \n    if (denom > 1e-6) {\n    \tfloat t = dot((p0 - l0), n) / denom;\n        vec3 hit = l0 + l * t;\n        \n\t\tfloat t0 = iTime;\n\n        vec3 lightPos = vec3(0.0, 2.0, 5.0);\n        //lightPos.y += sin(t0) * 4.0 + 4.0;\n        lightPos.z += cos(t0) * 8.0 + 8.0;\n        lightPos.x += sin(t0) * 8.0 + 8.0;\n        \n\t\tvec3 lightDir = normalize(lightPos - hit);\n        \n        // ambient\n        float ambientStrength = 0.1;\n    \tvec3 ambient = ambientStrength * vec3(1.0);\n        \n        // diffuse\n        float diff = max(dot(n, lightDir), 0.0);\n\t\tvec3 diffuse = diff * vec3(1.0);\n        \n        // specular\n        vec3 viewDir = normalize(hit - l0);\n        vec3 reflectDir = reflect(lightDir, n); \n        \n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 128.0);\n         vec3 c = vec3(\n            sin(iTime) * 0.1 + cos(iTime) * 0.25 + 1.0,\n            sin(iTime) * 0.2 + cos(iTime) * 0.25 + 1.0,\n            cos(iTime) * 0.2 + cos(iTime) * 0.25 + 1.0\n        );\n        \n        c += -1.0 * texture(iChannel0, hit.xz / 7.0).xyz * vec3(0.2, 0.8, 0.8);\n\n        // checker board\n        float u = mod(hit.x, 2.0);\n        float v = mod(hit.z, 2.0);\n        \n        if ((u > 1.0 && v > 1.0) || (u < 1.0 && v < 1.0)) {\n            c -= 0.5;\n        }\n\n\n        fragColor = vec4(c * (ambient + diffuse + spec), 1.0);\n    } else {\n    \tfragColor = vec4(vec3(0.0), 1.0);\n    }\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 193, 250, 250, 2337]], "test": "untested"}
{"id": "3sGXzD", "name": "boney tunnel", "author": "mrange", "description": "Based orignally upon: https://www.shadertoy.com/view/XdlSD4\nI always liked mandelbox_ryu made by EvilRyu\n\nThis is a derivate of that shader that added camera path derived from: https://www.shadertoy.com/view/XdcfR8", "tags": ["raymarching", "tunnel", "mandelbox"], "likes": 21, "viewed": 453, "published": "Public API", "date": "1573509947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based orignally upon: https://www.shadertoy.com/view/XdlSD4\n\n// I always liked mandelbox_ryu made by EvilRyu\n// Was tinkering a bit with the code and came up with this which at least I liked.\n// https://www.shadertoy.com/view/3ddSDs\n\n// Uses very simple occlusion based lighting which made it look more like a structure\n// of bones than my other futile lighting attemps.\n\n// Continued tinkering and applied camera path and domain repetition\n\nconst float fixed_radius2 = 4.5;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 2.3;\nconst float scale         = -3.0;\nconst int   max_iter      = 120;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\nconst vec3  rep           = vec3(10.0);\n\n#define PATHA 0.4*vec2(0.11, 0.21)\n#define PATHB 0.7*vec2(13.0, 3.0)\n\n// Derived from https://www.shadertoy.com/view/XdcfR8\n//  Another shade I really like\n\nvec3 camPath(float z)  {\n  return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 camPathDeriv(float z)  {\n  return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 camPathDeriv2(float z)  {\n  return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), .0);\n}\n\nvec3 mod3(inout vec3 p, vec3 size) {\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\nvoid sphere_fold(float fr, inout vec3 z, inout float dz) {\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fr / min_radius2);\n    z *= temp;\n    dz *= temp;\n  } else if(r2 < fr) {\n    float temp = (fr / r2);\n    z *= temp;\n    dz *= temp;\n  }\n}\n\nvoid box_fold(float fl, inout vec3 z, inout float dz) {\n  z = clamp(z, -fl, fl) * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat mb(float fl, float fr, vec3 z) {\n  vec3 offset = z;\n  float dr = 1.0;\n  float fd = 0.0;\n  for(int n = 0; n < 5; ++n) {\n    box_fold(fl, z, dr);\n    sphere_fold(fr, z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;        \n    float r1 = sphere(z, 5.0);\n    float r2 = torus(z, vec2(8.0, 1));        \n    float r = n < 4 ? r2 : r1;        \n    float dd = r / abs(dr);\n    if (n < 3 || dd < fd) {\n      fd = dd;\n    }\n  }\n  return fd;\n}\n\nfloat df(vec3 p) { \n  float tm = p.z;\n  vec3 wrap = camPath(tm);\n  vec3 wrapDeriv = normalize(camPathDeriv(tm));\n  p.xy -= wrap.xy;\n  p -= wrapDeriv*dot(vec3(p.xy, 0), wrapDeriv)*0.5*vec3(1,1,-1);\n\n  p -= rep*vec3(0.5, 0.0, 0.0);\n  p.y *= (1.0 + 0.1*abs(p.y));\n  vec3 i = mod3(p, rep);\n  \n  float fl = folding_limit + 0.3*sin(0.025*iTime+1.0)- 0.3; \n  float fr = fixed_radius2 - 3.0*cos(0.025*sqrt(0.5)*iTime-1.0);\n\n  float d1 = mb(fl, fr, p);\n  \n  return d1; \n} \n\n\nfloat hash(vec2 p)  {\n  float h = dot(p,vec2(127.1,311.7));   \n  return fract(sin(h)*43758.5453123);\n}\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n  float res;\n  float r = hash(ro.xy + ro.xz + ro.yz);\n  float t = 10.0*mix(0.01, 0.02, r);\n  iter = max_iter;\n    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    res = df(p);\n    if(res < 0.001 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > 20.) t = -1.;\n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n  vec3 n = normal(p);\n  float fake = float(iter)/float(max_iter);\n  float fakeAmb = exp(-fake*fake*9.0);\n  float amb = ambientOcclusion(p, n);\n\n  vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n  return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 uv = -1.0 + 2.0*q; \n  uv.x*=iResolution.x/iResolution.y; \n    \n  float tm = 2.0*iTime;\n\n  vec3 up = vec3(0.0, 1.0, 0.0) + 2.0*camPathDeriv2(tm);\n    \n  vec3 ro = camPath(tm);\n  vec3 cf = normalize(camPathDeriv(tm));\n  vec3 cs = normalize(cross(cf, up)); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + (3.0 - 1.0*length(uv))*cf);  // transform from view to world\n\n  vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  \n  float t = intersect(ro, rd, iter);\n    \n  if(t > -0.5) {\n    p = ro + t * rd;\n    col = lighting(p, rd, iter);\n    col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n  } \n    \n\n  col=post(col, q);\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[776, 863, 887, 887, 927], [929, 929, 958, 958, 1006], [1008, 1008, 1038, 1038, 1092], [1094, 1094, 1130, 1130, 1225], [1227, 1227, 1285, 1285, 1490], [1492, 1492, 1547, 1547, 1584], [1586, 1586, 1617, 1617, 1641], [1643, 1643, 1672, 1672, 1737], [1739, 1739, 1777, 1777, 2197], [2199, 2199, 2217, 2217, 2661], [2665, 2665, 2686, 2686, 2767], [2769, 2769, 2818, 2818, 3150], [3152, 3152, 3192, 3192, 3394], [3396, 3396, 3422, 3422, 3630], [3632, 3632, 3674, 3674, 3904], [3906, 3906, 3935, 3935, 4184], [4186, 4186, 4244, 4244, 5036]], "test": "untested"}
{"id": "3sK3Rh", "name": "Ray tracing some spheres", "author": "janiorca", "description": "First ray tracing efforts with glsl. A couple of lights with shadows and spheres with fresnel reflections ", "tags": ["raytracing", "sphere", "fresnel", "whittedshadows"], "likes": 1, "viewed": 207, "published": "Public", "date": "1573676432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int num_spheres = 15;\n\nconst vec4 lights[2] = vec4[2] (\n    vec4( 28.0, 80.0, 28.0, 8742.0 ),\n    vec4( -28.0, 8.0, 8.0,  616.0 )\n);\n\nfloat w_intersect_sphere( float max_t, vec3 ray_dir, vec3 origin, \n    vec3 sphere, float sphere_radius2, int idx_in, \n    out vec3 pos, out vec3 norm, out int idx ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n        return max_t;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return max_t;\n        } \n        else {\n            float thc = sqrt(sphere_radius2-distToMidpoint2);\n            float t0 = tCA - thc;           // entry \n            if( t0 < max_t ) {\n                pos = origin + t0*ray_dir;\n                norm = normalize( pos-sphere);\n                idx = idx_in;\n                return t0;\n            } else {\n                return max_t;\n            }\n        }\n    }\n}\n\n// For shadows we only care if there was intersection\nbool intersects_sphere( vec3 ray_dir, vec3 origin, vec3 sphere, float sphere_radius2 ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n            return false;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return false;\n        } \n        else {\n            return true;\n        }\n    }\n}\n\nfloat ground_plane_intersect( vec3 ray_dir, vec3 origin, float ground, out vec3 pos, out vec3 norm ) {\n    if( ray_dir.y >= 0.0 ) {\n        return 99999999.0;\n    }\n    float t = ( ground-origin.y ) /  ray_dir.y; \n    norm = vec3( 0.0, 1.0f, 0.0f );\n    pos = origin + ray_dir*t;\n    return t;\n}\n\n// code from demo foxes blog\n// https://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\nfloat fresnel( float n, vec3 normal, vec3 incident )\n{\n        // Schlick aproximation\n        float r0 = (1.0-n) / (1.0+n);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n        return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2( 0.5, 0.5 );\n    vec3 spheres[num_spheres];\n    for( int idx=0; idx < num_spheres; idx++ ) \n    {\n        float fidx = float(idx);\n        float fidx2 = fidx*fidx;\n        vec3 spos = vec3( sin( fidx*0.12312 + iTime * 0.121312 + 0.423 + fidx2*0.1324), \n            sin( fidx*0.13312 + iTime * .372 + 0.4223+ fidx2*1.54 ),\n            sin( fidx*0.2912 + iTime * .255552 + 1.423+ fidx2*1.1324 )\n        );\n        spos *= 15.0f;\n        spheres[ idx ] = spos;\n    }\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    // [ -0.5, 05 ]    \n    vec2 screen_pos_2d = 2.0*(uv - center);\n    vec3 screen_pos_3d = vec3( screen_pos_2d, -29.0 );\n\n    float _angle = iTime/3.0;\n    mat3 rot_m = mat3( cos(_angle),0,  -sin( _angle ), \n                        0,          1,          0,\n                        sin(_angle), 0, cos(_angle) );\n\n    vec3 origin = rot_m*vec3( 0,0,-30.0) ;\n    vec3 ray_dir = normalize(rot_m*screen_pos_3d - origin);\n\n\n    float contribution = 1.0;\n    vec3 final_color = vec3( 0,0,0);\n    for( int bounce =3; bounce >0 ; bounce -- ) {\n        vec3 new_ray_dir;\n        vec3 norm;\n        vec3 pos;\n        vec3 diffuseCol;\n        float refractive_index;\n        float reflectance = 0.0;\n        int final_idx = -1;\n        float current_t = 99999999.0;\n\n        current_t = ground_plane_intersect( ray_dir, origin , -20.0, pos, norm );\n        if( current_t <= 99999999.0 ) {\n            diffuseCol = vec3( 0.05, 0.55, 0.05 );\n            if( ( ( int( pos.x/5.0) +int(pos.z/5.0) ) & 1 )== 1){\n                diffuseCol = vec3( 0.59, 0.6, 0.5 );\n            }   \n        } else {\n            diffuseCol = vec3( 1.0, 1.0, 0.0);\n\n        }\n\n        for( int idx=1; idx < num_spheres; idx++ ) {\n            vec3 vv = vec3( 0.0, 0.0, 0.0 )*float(idx);\n           current_t  =  w_intersect_sphere( current_t, ray_dir, origin, spheres[idx], 4.2*4.2, idx, \n               pos, norm, final_idx);\n        }\n        // workout out material properties\n        if( final_idx > 0 ) {\n            if( final_idx % 3 == 0 ) {\n                diffuseCol = vec3( 0.02, 0.02, 0.12 );\n                refractive_index = 1.77;\n            } else if( final_idx % 3 == 1 ) {\n                diffuseCol = vec3( 0.5, 0.1, 0.1 );\n                refractive_index = 1.2;\n            } else {\n                diffuseCol = vec3( 0.2, 0.5, 0.1 );\n                refractive_index = 1.5;\n            }\n            reflectance = fresnel( refractive_index, norm, ray_dir);\n            new_ray_dir = reflect( ray_dir, norm );\n        }\n\n\n        // light the point\n        vec3 point_color = vec3( 0, 0, 0 );\n        for( int lt=0; lt<2; lt++ ) \n        {\n            // Is the light shadowed\n            vec3 point_light = lights[ lt ].xyz - pos;\n            vec3 point_light_dir = normalize( point_light );\n            float current_t = 99999999.0;\n            bool in_shade = false;\n            for( int idx=1; idx < num_spheres; idx++ ) \n            {\n                if( intersects_sphere( point_light_dir, pos, spheres[idx], 4.2*4.2 ) ) \n                {\n                    in_shade = true;\n                    break;\n                }\n            }\n            if( !in_shade)\n            {\n                float dd = length( point_light );\n                float attenutation = lights[ lt ].w/( dd*dd);\n                vec3 reflectedLight = reflect( -point_light_dir, norm );\n                vec3 toCamera = -ray_dir;\n                float diffuse = attenutation*dot( point_light_dir, norm );\n\n                vec3 halfway = normalize( toCamera + point_light_dir );\n                float specular = attenutation*pow( dot( norm, halfway ), 121.0 );\n            \n                specular = clamp( specular, 0.0, 1.0 );\n\n                vec3 fragDiffuse = diffuseCol * diffuse;\n                point_color += vec3(specular,specular,specular) + fragDiffuse;\n            }\n        }\n        final_color += point_color * contribution * ( 1.0 - reflectance );\n        contribution = contribution * reflectance;\n        ray_dir = new_ray_dir;\n        origin = pos;\n    }\n    vec3 fragFinal = pow( final_color, vec3(1.0 / 2.2) );\n    fragColor = vec4(fragFinal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sK3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 307, 336, 1111], [1113, 1167, 1255, 1284, 1729], [1731, 1731, 1833, 1833, 2026], [2028, 2178, 2232, 2264, 2458], [2460, 2460, 2517, 2517, 6733]], "test": "untested"}
{"id": "3sKSRV", "name": "Starry night", "author": "FreddyDoll", "description": "Trying to imitate the night sky here", "tags": ["starsmilkywayheaven"], "likes": 4, "viewed": 279, "published": "Public", "date": "1574447708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n//Start with a temperature, in Kelvin, somewhere between 1000 and 40000.  (Other values may work,\n//but I can't make any promises about the quality of the algorithm's estimates above 40000 K.)\n//Note also that the temperature and color variables need to be declared as floating-point.\nvec3 ColFromTemp(float temp)\n{\n    temp /= 100.;\n    \n    vec3 col;\n\n    if(temp <= 66.)\n        col.r = 1.;\n    else\n    {\n        col.r = temp - 60.;\n        col.r = 329.698727446 * pow(col.r, -0.1332047592);\n        col.r/=255.;\n        col.r = clamp(col.r,0.,1.);\n    }\n    \n\n    if(temp <= 66.)\n    {\n        col.g = temp;\n        col.g = 99.4708025861 * log(col.g) - 161.1195681661;\n    }\n    else\n    {\n        col.g = temp - 60.;\n        col.g = 288.1221695283 * pow(col.g,-0.0755148492);\n    }\n    col.g/=255.;\n    col.g = clamp(col.g,0.,1.);\n   \n    \n    if(temp >= 66.)\n        col.b = 1.;\n    else\n    {\n\n        if(temp <= 19.)\n            col.b = 0.;\n        else\n        {\n            col.b = temp - 10.;\n            col.b = 138.5177312231 * log(col.b) - 305.0447927307;\n    \t\tcol.b/=255.;\n    \t\tcol.b = clamp(col.b,0.,1.);\n                \n         }\n     }\n    return col;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat starfield(vec2 uv, float density, float spacing)\n{\n    float base = (noise(uv*400.)+0.9)/2.;\n    return pow(base,15.*spacing)*200.*density;\n}\n\nfloat galaxyMask(vec2 uv)\n{\n    uv.x *=2.;\n    uv.y *=.8;\n    float base = (noise(uv*2.)+1.0)/2. + .3;\n    return pow(base,6.)*4.;\n}\n\nfloat tempMap(vec2 uv)\n{\n    float base = (noise(uv*200.)+1.0)/2.;\n    base = pow(base,6.)*10.;\n    return base*25000.+3000.;\n}\n\nvec3 doColor(vec2 uv)\n{\n    vec3 col = ColFromTemp(tempMap(uv))*vec3(starfield(uv*.8, galaxyMask(uv)*1.8,1.)); //stars\n    col += ColFromTemp(tempMap(uv*.2))*vec3(starfield(uv*.2, galaxyMask(uv*.2),1.3)); //galaxies\n\treturn col;\n}\n\n#define gauss_width 3    \nfloat gauss_fact[gauss_width]=float[](0.27901,0.44198,0.27901);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = vec4(ColFromTemp(uv.x*8000. + 1000.),1.0);\n    uv.x+=iTime*0.05;\n\tuv.y+=sin(iTime)*.01;\n    \n    vec2 baseAA = vec2(1./iResolution.x/1.5,1./iResolution.y/1.5);\n    vec3 col = vec3(0.);\n    for(int x=-gauss_width/2;x<=gauss_width/2;x++)\n    \tfor(int y=-gauss_width/2;y<=gauss_width/2;y++)\n            col += doColor(uv + vec2(baseAA.x*float(x),baseAA.y*float(y)))*gauss_fact[x+gauss_width/2]*gauss_fact[y+gauss_width/2];\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 362, 392, 392, 1253], [1255, 1255, 1277, 1277, 1416], [1418, 1503, 1525, 1525, 1929], [1932, 1932, 1988, 1988, 2079], [2081, 2081, 2108, 2108, 2213], [2215, 2215, 2239, 2239, 2342], [2344, 2344, 2367, 2367, 2574], [2667, 2667, 2724, 2774, 3314]], "test": "untested"}
{"id": "3sKSRw", "name": "Tunnel of Disco lights", "author": "bitless", "description": "Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration", "tags": ["2d", "tunnel", "atan", "disco"], "likes": 21, "viewed": 656, "published": "Public", "date": "1573652605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Tunnel of Disco lights\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n\n#define SCALE_X 16.\n#define SCALE_Y 5.\n#define TIME_SCALE 0.1\n#define BORDER 1.2\n\nfloat hash1( float n ) { return fract(sin(n)*437518.56453)+0.1; }\n\nfloat box(vec2 st) {\n    vec2 s = vec2(0.001); // border size\n    vec2 w = vec2(0.05); // border smoothness\n    vec2 uv = smoothstep(s,s+w,st);\n    uv *= smoothstep(s,s+w,vec2(1.0)-st);\n    return uv.x*uv.y*(1.-length(0.5-st)*0.75);\n}\n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nfloat fbm (in vec2 st) {\n\tfloat value = (sin(iTime*5.*hash1(st.x+hash1(st.y)))+4.0)*0.25;\n    return max(0.75,pow(value,3.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\t\n\tfloat a = atan(uv.x, uv.y);\n\tfloat r = length(uv);\n\t\n\tuv = vec2(a,r/dot(uv,uv));\n\n    vec3 color = vec3(0.);\n    float c = 1.;\n\n    float lt = mod(iTime*TIME_SCALE,1./SCALE_Y); //local time cycle\n    \n    \n    uv.x *= SCALE_X/3.1415926;\n    float i = floor(uv.x); // row\n    uv.x = fract(uv.x);\n\n    if (uv.y < BORDER-lt)\n    {\n        uv.y += iTime*TIME_SCALE;\n        uv.y *= SCALE_Y;\n        float j = floor(uv.y);\n\n        uv.y = fract(uv.y);\n        color = hsb2rgb(vec3((hash1(j+hash1(i))),0.7,fbm(vec2(i,j))))*box(uv);\n    }\n    else {\n        float fade = smoothstep (3.0,0.,sqrt(uv.y)); //fade to darkness\n        uv.y += lt - BORDER;\n        float j = floor ((BORDER-lt+iTime*TIME_SCALE)*SCALE_Y+floor(uv.y)); \n\t\tuv.y = fract(uv.y)*SCALE_Y + min(0., 1.-SCALE_Y+lt*(SCALE_Y/TIME_SCALE*SCALE_Y*hash1(i+hash1(j))+1.));\n    \tc *=  box (uv); //cell\n        c += smoothstep(3.0,1.0,sqrt(uv.y))*smoothstep(1.0,1.05,uv.y)*smoothstep(0.5,0.45,abs(uv.x-0.5))*0.25; //cell trail\n        c *= fade; //fade to darkness\n        color = mix (color,hsb2rgb(vec3((hash1(j+hash1(i))),0.7,fbm(vec2(i,j)))),c);\n\n    }\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 225, 249, 249, 290], [292, 292, 312, 312, 526], [528, 575, 601, 601, 759], [762, 762, 786, 786, 889], [892, 892, 949, 949, 2169]], "test": "untested"}
{"id": "3sKSRz", "name": "random line patterns", "author": "thisisthais", "description": "idk this looks different than in vscode, still cool", "tags": ["lines", "random", "tbos"], "likes": 3, "viewed": 132, "published": "Public", "date": "1573246686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(in float x){\n  return fract(sin(x)*1e4);\n}\n\nfloat randomLines(float x,float t){\n  return step(.5,random(floor(t)-fract(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st=fragCoord.xy/iResolution.xy;\n  st.x*=iResolution.x/iResolution.y;\n  vec3 color=vec3(0.,0.,0.);\n  \n  float stepCounter=floor(iTime/2.);\n  st*=vec2(1.,2.*min(stepCounter,100.));\n  float colTracker=step(1.,mod(st.y,2.));\n  \n  st.x+=colTracker*iTime/10000.;\n  st.x-=(1.-colTracker)*iTime/10000.;\n  \n  color=vec3(randomLines(st.x,iTime));\n  \n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 55], [57, 57, 92, 92, 139], [141, 141, 197, 197, 574]], "test": "untested"}
{"id": "3sKXRK", "name": "star field", "author": "mahalis", "description": "today’s Nodevember theme is “Star”. here is a star!", "tags": ["spiral", "star", "psychedelic", "nodevember"], "likes": 8, "viewed": 336, "published": "Public API", "date": "1574444887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// license: CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\nvec2 r(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nfloat oneArmDistance(vec2 p) {\n    float d = dot(p, vec2(0.0, 1.0));\n    d = max(d, -dot(vec2(abs(p.x), p.y), normalize(vec2(-1.0,0.3))) - 0.1);\n    return d;\n}\n\nvec3 palette(float v) {\n    return vec3(0.6,0.3,0.8) + vec3(0.2,0.5,0.2) * cos(6.28318 * (v + vec3(0.0, 0.665, 0.667)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n\n    uv.y = -uv.y;\n    \n    uv *= (2.5 + sin(iTime * 0.23) * 0.5);\n    float radius = length(uv);\n    uv = r(uv, pow(radius * 0.5, 2.0) * -0.2);\n    \n    float d = 1e5;\n    for (int i = 0; i < 5; i++) {\n        float a = float(i) * 6.283 / 5.0 + iTime * 0.2;\n        d = min(d, oneArmDistance(r(uv, a)));\n    }\n    \n    float innerMask = smoothstep(fwidth(d),0.0, d);\n    \n    float angle = atan(uv.y, uv.x) - 0.2 * pow(radius * 0.5,2.0);\n    d -= 0.05 * (sin(angle * 11. + iTime * 1.1 + radius * 0.3) + 0.5 * cos(angle * 19. + iTime * 1.31 + radius * 0.4)) * max(radius - 0.3, 0.);\n    \n    float outerDistance = floor(d * 15.0 - iTime * 0.3);\n    \n    vec3 outerColor = clamp(palette(outerDistance * 0.2 - iTime * 0.1 + angle / 3.1416), 0.0, 1.0);\n    \n    vec3 c = mix(pow(outerColor, vec3(1.4)) * 1.2, vec3(0.0), innerMask);\n\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKXRK.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 70, 95, 95, 196], [198, 198, 228, 228, 358], [360, 360, 383, 383, 482], [484, 484, 541, 541, 1473]], "test": "untested"}
{"id": "3sKXRR", "name": "Test7", "author": "Virg", "description": "asd", "tags": ["lights"], "likes": 1, "viewed": 99, "published": "Public", "date": "1573235943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )  \n{\n    float PI = 3.14159265;\n\t//*sin(iTime+PI/2.)\n    vec2 c1 = vec2(iResolution.x*0.33,iResolution.y*0.33);\n    vec2 c2 = vec2(iResolution.x*0.66,iResolution.y*0.33);\n    vec2 c3 = vec2(iResolution.x*0.5,iResolution.y*0.66);\n    float c1D = 1. - distance(fragCoord,c1+cos(iTime*0.2)*(iResolution.xy/5.))/(iResolution.x*0.66);\n    float c2D = 1. - distance(fragCoord,c2+sin(iTime*0.3+PI/4.)*(iResolution.xy/5.))/(iResolution.x*0.66);\n    float c3D = 1. - distance(fragCoord,c3+sin(iTime)*(iResolution.xy/5.))/(iResolution.x*0.66);\n    vec3 col = vec3(c1D,c2D,c3D);\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 655]], "test": "untested"}
{"id": "3sKXWh", "name": "Tileable textures collection", "author": "alint", "description": "Collection of tileable procedural textures such as: cellular noise, fbm, voronoi, perlin and other.\nGithub link: https://github.com/tuxalin/procedural-tileable-shaders\n\nNOTE. You can use left click and slide to browse through the collection.", "tags": ["procedural", "voronoi", "noise", "fbm", "textures", "cellular", "tileable"], "likes": 14, "viewed": 865, "published": "Public", "date": "1573909352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Alin Loghin\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define SCALE   8.0 \n#define TILES   2.0     \n\n#define SHOW_TILING 1      \n#define ANIMATE 1      \n\n// hashes\n\nuint ihash1D(uint q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nuvec4 ihash1D(uvec4 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nvec2 hash2D(vec2 x)\n{\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 65536.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\nvec3 hash3D(vec2 x) \n{\n    // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec3 v = uvec3(x.xyx * 65536.0) * 1664525u + 1013904223u;\n    v += v.yzx * v.zxy;\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return vec3(v) * (1.0 / float(0xffffffffu));\n}\n\nvec4 hash4D(vec2 x)\n{\n    // based on: pcg4 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec4 v = uvec4(x.xyyx * 65536.0) * 1664525u + 1013904223u;\n\n    v += v.yzxy * v.wxyz;\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v.x += v.y * v.w;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n\n    return vec4(v ^ (v >> 16u)) * (1.0 / float(0xffffffffu));\n}\n\nvec4 hash4D(vec4 x)\n{\n    // based on: pcg4 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec4 v = uvec4(x * 65536.0) * 1664525u + 1013904223u;\n\n    v += v.yzxy * v.wxyz;\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v ^= v >> 16u;\n\n    return vec4(v ^ (v >> 16u)) * (1.0 / float(0xffffffffu));\n}\n\n\nvec2 betterHash2D(vec2 x)\n{\n    uvec2 q = uvec2(x);\n    uint h0 = ihash1D(ihash1D(q.x) + q.y);\n    uint h1 = h0 * 1933247u + ~h0 ^ 230123u;\n    return vec2(h0, h1)  * (1.0 / float(0xffffffffu));\n}\n\n// generates a random number for each of the 4 cell corners\nvec4 betterHash2D(vec4 cell)    \n{\n    uvec4 i = uvec4(cell) + 101323u;\n    uvec4 hash = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    return vec4(hash) * (1.0 / float(0xffffffffu));\n}\n\n// generates 2 random numbers for each of the 4 cell corners\nvoid betterHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 i = uvec4(cell) + 101323u;\n    uvec4 hash0 = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    uvec4 hash1 = ihash1D(hash0 ^ 1933247u);\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n}\n\n// generates 2 random numbers for each of the four 2D coordinates\nvoid betterHash2D(vec4 coords0, vec4 coords1, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 hash0 = ihash1D(ihash1D(uvec4(coords0.xz, coords1.xz)) + uvec4(coords0.yw, coords1.yw));\n    uvec4 hash1 = hash0 * 1933247u + ~hash0 ^ 230123u;\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n} \n\n// generates a random number for each of the 8 cell corners\nvoid betterHash3D(vec3 cell, vec3 cellPlusOne, out vec4 lowHash, out vec4 highHash)\n{\n    uvec4 cells = uvec4(cell.xy, cellPlusOne.xy);  \n    uvec4 hash = ihash1D(ihash1D(cells.xzxz) + cells.yyww);\n    \n    lowHash = vec4(ihash1D(hash + uint(cell.z))) * (1.0 / float(0xffffffffu));\n    highHash = vec4(ihash1D(hash + uint(cellPlusOne.z))) * (1.0 / float(0xffffffffu));\n}\n\n#define multiHash2D betterHash2D\n#define multiHash3D betterHash3D\n\nvoid smultiHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    multiHash2D(cell, hashX, hashY);\n    hashX = hashX * 2.0 - 1.0; \n    hashY = hashY * 2.0 - 1.0;\n}\n\n// common\n\nvec2 noiseInterpolate(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec4 noiseInterpolate(const in vec4 x) \n{ \n    vec4 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec4 noiseInterpolateDu(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    vec2 u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    vec2 du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n    return vec4(u, du);\n}\nvoid noiseInterpolateDu(const in vec3 x, out vec3 u, out vec3 du) \n{ \n    vec3 x2 = x * x;\n    u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n}\n\nfloat distanceMetric(vec2 pos, uint metric)\n{\n    switch (metric)\n    {\n        case 0u:\n            // squared euclidean\n            return dot(pos, pos);\n        case 1u:\n            // manhattam   \n            return dot(abs(pos), vec2(1.0));\n        case 2u:\n            // chebyshev\n            return max(abs(pos.x), abs(pos.y));\n        default:\n            // triangular\n            return  max(abs(pos.x) * 0.866025 + pos.y * 0.5, -pos.y);\n    }\n}\n\nvec4 distanceMetric(vec4 px, vec4 py, uint metric)\n{\n    switch (metric)\n    {\n        case 0u:\n            // squared euclidean\n            return px * px + py * py;\n        case 1u:\n            // manhattam   \n            return abs(px) + abs(py);\n        case 2u:\n            // chebyshev\n            return max(abs(px), abs(py));\n        default:\n            // triangular\n            return max(abs(px) * 0.866025 + py * 0.5, -py);\n    }\n}\n\n// noises\n\nfloat noise(vec2 pos, vec2 scale, float phase, float seed) \n{\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy) + seed;\n\n    vec4 hash = multiHash2D(i);\n    hash = 0.5 * sin(phase + kPI2 * hash) + 0.5;\n    float a = hash.x;\n    float b = hash.y;\n    float c = hash.z;\n    float d = hash.w;\n\n    vec2 u = noiseInterpolate(f);\n    float value = mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n    return value * 2.0 - 1.0;\n}\n\nvec3 noised(vec2 pos, vec2 scale, float phase, float seed) \n{\n    const float kPI2 = 6.2831853071;\n    // value noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy) + seed;\n\n    vec4 hash = multiHash2D(i);\n    hash = 0.5 * sin(phase + kPI2 * hash) + 0.5;\n    float a = hash.x;\n    float b = hash.y;\n    float c = hash.z;\n    float d = hash.w;\n    \n    vec4 udu = noiseInterpolateDu(f);    \n    float abcd = a - b - c + d;\n    float value = a + (b - a) * udu.x + (c - a) * udu.y + abcd * udu.x * udu.y;\n    vec2 derivative = udu.zw * (udu.yx * abcd + vec2(b, c) - a);\n    return vec3(value * 2.0 - 1.0, derivative);\n}\n\nvec2 multiNoise(vec4 pos, vec4 scale, float phase, vec2 seed) \n{\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec4 i = floor(pos);\n    vec4 f = pos - i;\n    vec4 i0 = mod(i.xyxy + vec2(0.0, 1.0).xxyy, scale.xyxy) + seed.x;\n    vec4 i1 = mod(i.zwzw + vec2(0.0, 1.0).xxyy, scale.xyxy) + seed.y;\n\n    vec4 hash0 = multiHash2D(i0);\n    hash0 = 0.5 * sin(phase + kPI2 * hash0) + 0.5;\n    vec4 hash1 = multiHash2D(i1);\n    hash1 = 0.5 * sin(phase + kPI2 * hash1) + 0.5;\n    vec2 a = vec2(hash0.x, hash1.x);\n    vec2 b = vec2(hash0.y, hash1.y);\n    vec2 c = vec2(hash0.z, hash1.z);\n    vec2 d = vec2(hash0.w, hash1.w);\n\n    vec4 u = noiseInterpolate(f);\n    vec2 value = mix(a, b, u.xz) + (c - a) * u.yw * (1.0 - u.xz) + (d - b) * u.xz * u.yw;\n    return value * 2.0 - 1.0;\n}\n\nvec3 gradientNoised(vec2 pos, vec2 scale, float seed) \n{\n    // gradient noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n    \n    vec4 hashX, hashY;\n    smultiHash2D(i, hashX, hashY);\n    vec2 a = vec2(hashX.x, hashY.x);\n    vec2 b = vec2(hashX.y, hashY.y);\n    vec2 c = vec2(hashX.z, hashY.z);\n    vec2 d = vec2(hashX.w, hashY.w);\n    \n    vec4 gradients = hashX * f.xzxz + hashY * f.yyww;\n\n    vec4 udu = noiseInterpolateDu(f.xy);\n    vec2 u = udu.xy;\n    vec2 g = mix(gradients.xz, gradients.yw, u.x);\n    \n    vec2 dxdy = a + u.x * (b - a) + u.y * (c - a) + u.x * u.y * (a - b - c + d);\n    dxdy += udu.zw * (u.yx * (gradients.x - gradients.y - gradients.z + gradients.w) + gradients.yz - gradients.x);\n    return vec3(mix(g.x, g.y, u.y) * 1.4142135623730950, dxdy);\n}\nvec3 gradientNoised(vec2 pos, vec2 scale, mat2 transform, float seed) \n{\n    // gradient noise with derivatives based on Inigo Quilez\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n    \n    vec4 hashX, hashY;\n    smultiHash2D(i, hashX, hashY);\n\n    // transform gradients\n    vec4 m = vec4(transform);\n    vec4 rh = vec4(hashX.x, hashY.x, hashX.y, hashY.y);\n    rh = rh.xxzz * m.xyxy + rh.yyww * m.zwzw;\n    hashX.xy = rh.xz;\n    hashY.xy = rh.yw;\n\n    rh = vec4(hashX.z, hashY.z, hashX.w, hashY.w);\n    rh = rh.xxzz * m.xyxy + rh.yyww * m.zwzw;\n    hashX.zw = rh.xz;\n    hashY.zw = rh.yw;\n    \n    vec2 a = vec2(hashX.x, hashY.x);\n    vec2 b = vec2(hashX.y, hashY.y);\n    vec2 c = vec2(hashX.z, hashY.z);\n    vec2 d = vec2(hashX.w, hashY.w);\n    \n    vec4 gradients = hashX * f.xzxz + hashY * f.yyww;\n\n    vec4 udu = noiseInterpolateDu(f.xy);\n    vec2 u = udu.xy;\n    vec2 g = mix(gradients.xz, gradients.yw, u.x);\n    \n    vec2 dxdy = a + u.x * (b - a) + u.y * (c - a) + u.x * u.y * (a - b - c + d);\n    dxdy += udu.zw * (u.yx * (gradients.x - gradients.y - gradients.z + gradients.w) + gradients.yz - gradients.x);\n    return vec3(mix(g.x, g.y, u.y) * 1.4142135623730950, dxdy);\n}\n\nvec3 gradientNoised(vec2 pos, vec2 scale, float rotation, float seed) \n{\n    vec2 sinCos = vec2(sin(rotation), cos(rotation));\n    return gradientNoised(pos, scale, mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y), seed);\n}\n\nfloat perlinNoise(vec2 pos, vec2 scale, float seed)\n{\n    // based on Modifications to Classic Perlin Noise by Brian Sharpe: https://archive.is/cJtlS\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n\n    // grid gradients\n    vec4 gradientX, gradientY;\n    multiHash2D(i, gradientX, gradientY);\n    gradientX -= 0.49999;\n    gradientY -= 0.49999;\n\n    // perlin surflet\n    vec4 gradients = inversesqrt(gradientX * gradientX + gradientY * gradientY) * (gradientX * f.xzxz + gradientY * f.yyww);\n    // normalize: 1.0 / 0.75^3\n    gradients *= 2.3703703703703703703703703703704;\n    vec4 lengthSq = f * f;\n    lengthSq = lengthSq.xzxz + lengthSq.yyww;\n    vec4 xSq = 1.0 - min(vec4(1.0), lengthSq); \n    xSq = xSq * xSq * xSq;\n    return dot(xSq, gradients);\n}\nfloat perlinNoise(vec2 pos, vec2 scale, mat2 transform, float seed)\n{\n    // based on Modifications to Classic Perlin Noise by Brian Sharpe: https://archive.is/cJtlS\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n\n    // grid gradients\n    vec4 gradientX, gradientY;\n    multiHash2D(i, gradientX, gradientY);\n    gradientX -= 0.49999;\n    gradientY -= 0.49999;\n\n    // transform gradients\n    vec4 m = vec4(transform);\n    vec4 rg = vec4(gradientX.x, gradientY.x, gradientX.y, gradientY.y);\n    rg = rg.xxzz * m.xyxy + rg.yyww * m.zwzw;\n    gradientX.xy = rg.xz;\n    gradientY.xy = rg.yw;\n\n    rg = vec4(gradientX.z, gradientY.z, gradientX.w, gradientY.w);\n    rg = rg.xxzz * m.xyxy + rg.yyww * m.zwzw;\n    gradientX.zw = rg.xz;\n    gradientY.zw = rg.yw;\n\n    // perlin surflet\n    vec4 gradients = inversesqrt(gradientX * gradientX + gradientY * gradientY) * (gradientX * f.xzxz + gradientY * f.yyww);\n    // normalize: 1.0 / 0.75^3\n    gradients *= 2.3703703703703703703703703703704;\n    f = f * f;\n    f = f.xzxz + f.yyww;\n    vec4 xSq = 1.0 - min(vec4(1.0), f); \n    return dot(xSq * xSq * xSq, gradients);\n}\nfloat perlinNoise(vec2 pos, vec2 scale, float rotation, float seed) \n{\n    vec2 sinCos = vec2(sin(rotation), cos(rotation));\n    return perlinNoise(pos, scale, mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y), seed);\n}\n\nvec3 perlinNoised(vec2 pos, vec2 scale, mat2 transform, float seed)\n{\n    // based on Modifications to Classic Perlin Noise by Brian Sharpe: https://archive.is/cJtlS\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec4 f = (pos.xyxy - i.xyxy) - vec2(0.0, 1.0).xxyy;\n    i = mod(i, scale.xyxy) + seed;\n\n    // grid gradients\n    vec4 gradientX, gradientY;\n    multiHash2D(i, gradientX, gradientY);\n    gradientX -= 0.49999;\n    gradientY -= 0.49999;\n\n    // transform gradients\n    vec4 mt = vec4(transform);\n    vec4 rg = vec4(gradientX.x, gradientY.x, gradientX.y, gradientY.y);\n    rg = rg.xxzz * mt.xyxy + rg.yyww * mt.zwzw;\n    gradientX.xy = rg.xz;\n    gradientY.xy = rg.yw;\n\n    rg = vec4(gradientX.z, gradientY.z, gradientX.w, gradientY.w);\n    rg = rg.xxzz * mt.xyxy + rg.yyww * mt.zwzw;\n    gradientX.zw = rg.xz;\n    gradientY.zw = rg.yw;\n    \n    // perlin surflet\n    vec4 gradients = inversesqrt(gradientX * gradientX + gradientY * gradientY) * (gradientX * f.xzxz + gradientY * f.yyww);\n    vec4 m = f * f;\n    m = m.xzxz + m.yyww;\n    m = max(1.0 - m, 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m * m2;\n    // compute the derivatives\n    vec4 m2Gradients = -6.0 * m2 * gradients;\n    vec2 grad = vec2(dot(m2Gradients, f.xzxz), dot(m2Gradients, f.yyww)) + vec2(dot(m3, gradientX), dot(m3, gradientY));\n    // sum the surflets and normalize: 1.0 / 0.75^3\n    return vec3(dot(m3, gradients), grad) * 2.3703703703703703703703703703704;\n}\n\nfloat organicNoise(vec2 pos, vec2 scale, float density, vec2 phase, float contrast, float highlights, float shift, float seed)\n{\n    vec2 s = mix(vec2(1.0), scale - 1.0, density);\n    float nx = perlinNoise(pos + phase, scale, seed);\n    float ny = perlinNoise(pos, s, seed);\n\n    float n = length(vec2(nx, ny) * mix(vec2(2.0, 0.0), vec2(0.0, 2.0), shift));\n    n = pow(n, 1.0 + 8.0 * contrast) + (0.15 * highlights) / n;\n    return n * 0.5;\n}\n\nvec2 randomLines(vec2 pos, vec2 scale, float count, float width, float jitter, vec2 smoothness, float phase, float seed)\n{\n    float strength = jitter * 1.25;\n\n    // compute gradient\n    // TODO: compute the gradient analytically\n    vec2 grad;\n    vec3 offsets = vec3(1.0, 0.0, -1.0) / 1024.0;\n    vec4 p = pos.xyxy + offsets.xyzy;\n    vec2 nv = count * (strength * multiNoise(p, scale.xyxy, phase, vec2(seed)) + p.yw);\n    grad.x = nv.x - nv.y;\n    p = pos.xyxy + offsets.yxyz;\n    nv = count * (strength * multiNoise(p, scale.xyxy, phase, vec2(seed)) + p.yw);\n    grad.y = nv.x - nv.y;\n    \n    float v =  count * (strength * noise(pos, scale, phase, seed) + pos.y);\n    float w = fract(v) / length(grad / (2.0 * offsets.x));\n    width *= 0.1;\n    smoothness *= width;\n    smoothness += max(abs(grad.x), abs(grad.y)) * 0.02;\n    \n    float d = smoothstep(0.0, smoothness.x, w) - smoothstep(max(width - smoothness.y, 0.0), width, w);\n    return vec2(d, mod(floor(v), count));\n}\nvec4 randomLines(vec2 pos, vec2 scale, float count, float width, float jitter, vec2 smoothness, float phase, float colorVariation, float seed)\n{\n    vec2 l = randomLines(pos, scale, count, width, jitter, smoothness, phase, seed);\n    vec3 r = hash3D(l.yy + seed);\n    return vec4(l.x * (r.x < colorVariation ? r : r.xxx), l.x);\n}\n\nvec4 fbmMulti(vec2 pos, vec2 scale, float lacunarity, int octaves, float phase, float seed) \n{    \n    vec4 seeds = vec4(0.0, 1031.0, 537.0, 23.0) + seed;\n    float f = 2.0 / lacunarity;\n    \n    vec4 value = vec4(0.0);\n    float w = 1.0;\n    float acc = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        vec2 ns = vec2(scale / w);\n        vec4 n;\n        n.xy = multiNoise(pos.xyxy, ns.xyxy, phase, seeds.xy);\n        n.zw = multiNoise(pos.xyxy, ns.xyxy, phase, seeds.zw);\n        value += (n * 0.5 + 0.5) * w;\n        acc += w;\n        w *= 0.5 * f;\n    }\n    return value / acc;\n}\n\nvec3 dotsNoise(vec2 pos, vec2 scale, float density, float size, float sizeVariation, float roundness, float seed) \n{\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy);\n    \n    vec4 hash = hash4D(i.xy + seed);\n    if (hash.w > density)\n        return vec3(0.0);\n\n    float radius = clamp(size + (hash.z * 2.0 - 1.0) * sizeVariation * 0.5, 0.0, 1.0);\n    float value = radius / size;  \n    radius = 2.0 / radius;\n    f = f * radius - (radius - 1.0);\n    f += hash.xy * (radius - 2.0);\n    f = pow(abs(f), vec2((mix(20.0, 1.0, sqrt(roundness)))));\n\n    float u = 1.0 - min(dot(f, f), 1.0);\n    return vec3(clamp(u * u * u * value, 0.0, 1.0), hash.w, hash.z);\n}\n\n\n// worley noises\n\nvec2 cellularNoise(vec2 pos, vec2 scale, float jitter, float phase, uint metric, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    multiHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    multiHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = distanceMetric(dx0, dy0, metric);\n    vec4 d1 = distanceMetric(dx1, dy1, metric);\n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 *  multiHash2D(i)) + 0.5) * jitter - f; // 0 0\n    vec4 F = min(d0, d1);\n    // shuffle into F the 4 lowest values\n    F = min(F, max(d0, d1).wzyx);\n    // shuffle into F the 2 lowest values \n    F.xy = min(min(F.xy, F.zw), max(F.xy, F.zw).yx);\n    // add the last value\n    F.zw = vec2(distanceMetric(centerPos, metric), 1e+5);\n    // shuffle into F the final 2 lowest values \n    F.xy = min(min(F.xy, F.zw), max(F.xy, F.zw).yx);\n    \n    vec2 f12 = vec2(min(F.x, F.y), max(F.x, F.y));\n    // normalize: 0.75^2 * 2.0  == 1.125\n    return (metric == 0u ? sqrt(f12) : f12) * (1.0 / 1.125);\n}\nvec3 cellularNoised(vec2 pos, vec2 scale, float jitter, float phase, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    multiHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    multiHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = dx0 * dx0 + dy0 * dy0; \n    vec4 d1 = dx1 * dx1 + dy1 * dy1; \n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 *  multiHash2D(i)) + 0.5) * jitter - f; // 0 0\n    float dCenter = dot(centerPos, centerPos);\n    vec4 d = min(d0, d1);\n    vec4 less = step(d1, d0);\n    vec4 dx = mix(dx0, dx1, less);\n    vec4 dy = mix(dy0, dy1, less);\n\n    vec3 t1 = d.x < d.y ? vec3(d.x, dx.x, dy.x) : vec3(d.y, dx.y, dy.y);\n    vec3 t2 = d.z < d.w ? vec3(d.z, dx.z, dy.z) : vec3(d.w, dx.w, dy.w);\n    t2 = t2.x < dCenter ? t2 : vec3(dCenter, centerPos);\n    vec3 t = t1.x < t2.x ? t1 : t2;\n    t.x = sqrt(t.x);\n    // normalize: 0.75^2 * 2.0  == 1.125\n    return  t * vec3(1.0, -2.0, -2.0) * (1.0 / 1.125);\n}\n\nvec3 voronoi(vec2 pos, vec2 scale, float jitter, float phase, float seed)\n{\n     // voronoi based on Inigo Quilez: https://archive.is/Ta7dm\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n\n    // first pass\n    vec2 minPos, tilePos;\n    float minDistance = 1e+5;\n    for (int y=-1; y<=1; y++)\n    {\n        for (int x=-1; x<=1; x++)\n        {\n            vec2 n = vec2(float(x), float(y));\n            vec2 cPos = hash2D(mod(i + n, scale) + seed) * jitter;\n            cPos = 0.5 * sin(phase + kPI2 * cPos) + 0.5;\n            vec2 rPos = n + cPos - f;\n\n            float d = dot(rPos, rPos);\n            if(d < minDistance)\n            {\n                minDistance = d;\n                minPos = rPos;\n                tilePos = cPos;\n            }\n        }\n    }\n\n    // second pass, distance to edges\n    minDistance = 1e+5;\n    for (int y=-2; y<=2; y++)\n    {\n        for (int x=-2; x<=2; x++)\n        { \n            vec2 n = vec2(float(x), float(y));\n            vec2 cPos = hash2D(mod(i + n, scale) + seed) * jitter;\n            cPos = 0.5 * sin(phase + kPI2 * cPos) + 0.5;\n            vec2 rPos = n + cPos - f;\n            \n            vec2 v = minPos - rPos;\n            if(dot(v, v) > 1e-5)\n                minDistance = min(minDistance, dot( 0.5 * (minPos + rPos), normalize(rPos - minPos)));\n        }\n    }\n\n    return vec3(minDistance, tilePos);\n}\nvec3 cracks(vec2 pos, vec2 scale, float jitter, float width, float smoothness, float warp, float warpScale, bool warpSmudge, float smudgePhase, float seed)\n{\n    vec3 g = gradientNoised(pos, scale * warpScale, smudgePhase, seed);\n    pos += (warpSmudge ? g.yz : g.xx) * 0.1 * warp;\n    vec3 v = voronoi(pos, scale, jitter, 0.0, seed);\n    return vec3(smoothstep(max(width - smoothness, 0.0), width + fwidth(v.x), v.x), v.yz);\n}\n\nfloat metaballs(vec2 pos, vec2 scale, float jitter, float phase, float seed) \n{       \n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec2 i = floor(pos);\n    vec2 f = pos - i;\n    \n    const vec3 offset = vec3(-1.0, 0.0, 1.0);\n    vec4 cells = mod(i.xyxy + offset.xxzz, scale.xyxy) + seed;\n    i = mod(i, scale) + seed;\n    vec4 dx0, dy0, dx1, dy1;\n    multiHash2D(vec4(cells.xy, vec2(i.x, cells.y)), vec4(cells.zyx, i.y), dx0, dy0);\n    multiHash2D(vec4(cells.zwz, i.y), vec4(cells.xw, vec2(i.x, cells.w)), dx1, dy1);\n    dx0 = 0.5 * sin(phase + kPI2 * dx0) + 0.5;\n    dy0 = 0.5 * sin(phase + kPI2 * dy0) + 0.5;\n    dx1 = 0.5 * sin(phase + kPI2 * dx1) + 0.5;\n    dy1 = 0.5 * sin(phase + kPI2 * dy1) + 0.5;\n    \n    dx0 = offset.xyzx + dx0 * jitter - f.xxxx; // -1 0 1 -1\n    dy0 = offset.xxxy + dy0 * jitter - f.yyyy; // -1 -1 -1 0\n    dx1 = offset.zzxy + dx1 * jitter - f.xxxx; // 1 1 -1 0\n    dy1 = offset.zyzz + dy1 * jitter - f.yyyy; // 1 0 1 1\n    vec4 d0 = dx0 * dx0 + dy0 * dy0; \n    vec4 d1 = dx1 * dx1 + dy1 * dy1; \n    \n    vec2 centerPos = (0.5 * sin(phase + kPI2 * multiHash2D(i)) + 0.5) * jitter - f; // 0 0\n    \n    float d = min(1.0, dot(centerPos, centerPos));\n    d = min(d, d * d0.x);\n    d = min(d, d * d0.y);\n    d = min(d, d * d0.z);\n    d = min(d, d * d0.w);\n    d = min(d, d * d1.x);\n    d = min(d, d * d1.y);\n    d = min(d, d * d1.z);\n    d = min(d, d * d1.w);\n    \n    return sqrt(d);\n}\n\nfloat metaballs(vec2 pos, vec2 scale, float jitter, float phase, float width, float smoothness, float seed) \n{       \n    float d = metaballs(pos, scale, jitter, phase, seed);\n    return smoothstep(width, width + smoothness, d);\n}\n\n// fbms\n\nfloat fbm(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float n = noise(p / frequency, frequency, time, seed);\n        value += amplitude * n;\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    return value * 0.5 + 0.5;\n}\n\nvec3 fbmd(vec2 pos, vec2 scale, int octaves, vec2 shift, float timeShift, float gain, vec2 lacunarity, float slopeness, float octaveFactor, float seed) \n{\n    // fbm implementation based on Inigo Quilez\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift.x), cos(shift.y));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n\n    vec3 value = vec3(0.0);\n    vec2 derivative = vec2(0.0);\n    for (int i = 0; i < octaves; i++) \n    {\n        vec3 n =  noised(p / frequency, frequency, time, seed).xyz;\n        derivative += n.yz;\n\n        n *= amplitude;\n        n.x /= (1.0 + mix(0.0, dot(derivative, derivative), slopeness));\n        value += n; \n        \n        p = (p + shift) * lacunarity;\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        shift = shift * rotate;\n        time += timeShift;\n    }\n    \n    value.x = value.x * 0.5 + 0.5;\n    return value;\n}\nvec3 fbmd(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float slopeness, float octaveFactor, float seed) \n{\n    return fbmd(pos, scale, octaves, vec2(shift), timeShift, gain, vec2(lacunarity), slopeness, octaveFactor, seed);\n}\nvec3 fbmd(vec2 pos, vec2 scale, int octaves, vec2 shift, float timeShift, float gain, float lacunarity, float slopeness, float octaveFactor, float seed) \n{\n    return fbmd(pos, scale, octaves, shift, timeShift, gain, vec2(lacunarity), slopeness, octaveFactor, seed);\n}\n\nfloat fbmMetaballs(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float jitter, float interpolate, vec2 width, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n    \n    float n = 1.0;\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float cn = metaballs(p / frequency, frequency, jitter, timeShift, width.x, width.y, seed) * 2.0 - 1.0;\n        n *= cn;\n        value += amplitude * mix(n, abs(n), interpolate);\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    return value * 0.5 + 0.5;\n}\n\nfloat fbmPerlin(vec2 pos, vec2 scale, int octaves, float shift, float axialShift, float gain, float lacunarity, uint mode, float factor, float offset, float seed) \n{\n    float amplitude = gain;\n    vec2 frequency = floor(scale);\n    float angle = axialShift;\n    float n = 1.0;\n    vec2 p = fract(pos) * frequency;\n\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float pn = perlinNoise(p / frequency, frequency, angle, seed) + offset;\n        if (mode == 0u)\n        {\n            n *= abs(pn);\n        }\n        else if (mode == 1u)\n        {\n            n = abs(pn);\n        }\n        else if (mode == 2u)\n        {\n            n = pn;\n        }\n        else if (mode == 3u)\n        {\n            n *= pn;\n        }\n        else if (mode == 4u)\n        {\n            n = pn * 0.5 + 0.5;\n        }\n        else\n        {\n            n *= pn * 0.5 + 0.5;\n        }\n        \n        n = pow(n < 0.0 ? 0.0 : n, factor);\n        value += amplitude * n;\n        \n        p = p * lacunarity + shift;\n        frequency *= lacunarity;\n        amplitude *= gain;\n        angle += axialShift;\n    }\n    return value;\n}\n\nvec3 fbmdPerlin(vec2 pos, vec2 scale, int octaves, vec2 shift, mat2 transform, float gain, vec2 lacunarity, float slopeness, float octaveFactor, bool negative, float seed) \n{\n    // fbm implementation based on Inigo Quilez\n    float amplitude = gain;\n    vec2 frequency = floor(scale);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.3;\n\n    vec3 value = vec3(0.0);\n    vec2 derivative = vec2(0.0);\n    for (int i = 0; i < octaves; i++) \n    {\n        vec3 n = perlinNoised(p / frequency, frequency, transform, seed);\n        derivative += n.yz;\n        n.x = negative ? n.x : n.x * 0.5 + 0.5;\n        n *= amplitude;\n        value.x += n.x / (1.0 + mix(0.0, dot(derivative, derivative), slopeness));\n        value.yz += n.yz; \n        \n        p = (p + shift) * lacunarity;\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        transform *= transform;\n    }\n\n    return clamp(value,-1.,1.);\n}\nvec3 fbmdPerlin(vec2 pos, vec2 scale, int octaves, vec2 shift, float axialShift, float gain, vec2 lacunarity, float slopeness, float octaveFactor, bool negative, float seed) \n{\n    vec2 cosSin = vec2(cos(axialShift), sin(axialShift));\n    mat2 transform = mat2(cosSin.x, cosSin.y, -cosSin.y, cosSin.x) * mat2(0.8, -0.6, 0.6, 0.8);\n    return fbmdPerlin(pos, scale, octaves, shift, transform, gain, lacunarity, slopeness, octaveFactor, negative, seed);\n}\n\nvec4 fbmVoronoi(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float jitter, float interpolate, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n    \n    float n = 1.0;\n    vec4 value = vec4(0.0);\n    for (int i = 0; i < octaves; i++) \n    {\n        vec3 v = voronoi(p / frequency, frequency, jitter, timeShift, seed);\n        v.x = v.x * 2.0 - 1.0;\n        n *= v.x;\n        value += amplitude * vec4(mix(v.x, n, interpolate), hash3D(v.yz));\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    value.x = value.x * 0.5 + 0.5;\n    return value;\n}\n\n\n// warp\n\nfloat fbmWarp(vec2 pos, vec2 scale, vec2 factors, int octaves, vec4 shifts, float timeShift, float gain, vec2 lacunarity, float slopeness, float octaveFactor, bool negative, float seed,\n              out vec2 q, out vec2 r) \n{\n    // domain warping with factal sum value noise\n\n    float qfactor = factors.x;\n    float rfactor = factors.y;\n    q.x = fbmd(pos, scale, octaves, vec2(0.0), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    q.y = fbmd(pos, scale, octaves, vec2(shifts.x), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    q = negative ? q * 2.0 - 1.0 : q;\n    \n    vec2 np = pos + qfactor * q;\n    r.x = fbmd(np, scale, octaves, vec2(shifts.y), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    r.y = fbmd(np, scale, octaves, vec2(shifts.z), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n    r = negative ? r * 2.0 - 1.0 : r;\n    \n    return fbmd(pos + r * rfactor, scale, octaves, vec2(shifts.w), timeShift, gain, lacunarity, slopeness, octaveFactor, seed).x;\n}\n\nfloat perlinNoiseWarp(vec2 pos, vec2 scale, float strength, float phase, float factor, float spread, float seed)\n{\n    vec2 offset = vec2(spread, 0.0);\n    strength *= 32.0 / max(scale.x, scale.y);\n    \n    vec4 gp;\n    gp.x = perlinNoise(pos - offset.xy, scale, phase, seed);\n    gp.y = perlinNoise(pos + offset.xy, scale, phase, seed);\n    gp.z = perlinNoise(pos - offset.yx, scale, phase, seed);\n    gp.w = perlinNoise(pos + offset.yx, scale, phase, seed);\n    gp = pow(gp, vec4(factor));\n    vec2 warp = vec2(gp.y - gp.x, gp.w - gp.z);\n    return pow(perlinNoise(pos + warp * strength, scale, phase, seed), factor);\n}\n\nfloat curlWarp(vec2 pos, vec2 scale, vec2 factors, vec4 seeds, float curl, float seed,\n               out vec2 q, out vec2 r)\n{\n    float qfactor = factors.x;\n    float rfactor = factors.y;\n    vec2 curlFactor = vec2(1.0, -1.0) * vec2(curl, 1.0 - curl);\n    \n    vec2 n = gradientNoised(pos, scale, seed).zy * curlFactor;\n    q.x = n.x + n.y;\n    n = gradientNoised(pos + hash2D(seeds.xx), scale, seed).zy * curlFactor;\n    q.x = n.x + n.y;\n    \n    vec2 np = pos + qfactor * q;\n    n = gradientNoised(np + hash2D(seeds.yy), scale, seed).zy * curlFactor;\n    r.x = n.x + n.y;\n    n = gradientNoised(np + hash2D(seeds.zz), scale, seed).zy * curlFactor;\n    r.y = n.x + n.y;\n\n    return perlinNoise(pos + r * rfactor + hash2D(seeds.ww), scale, seed);\n}\n\n// other\n\nfloat sdfLens(vec2 p, float width, float height)\n{\n    float d = 1.0 / width - width / 4.0;\n    float r = width / 2.0 + d;\n    \n    p = abs(p);\n\n    float b = sqrt(r * r - d * d);\n    vec4 par = p.xyxy - vec4(0.0, b, -d, 0.0);\n    return (par.y * d > p.x * b) ? length(par.xy) : length(par.zw) - r;\n}\nvec3 tileWeave(vec2 pos, vec2 scale, float count, float width, float smoothness)\n{\n    vec2 i = floor(pos * scale);    \n    float c = mod(i.x + i.y, 2.0);\n    \n    vec2 p = fract(pos.st * scale);\n    p = mix(p.st, p.ts, c);\n    p = fract(p * vec2(count, 1.0));\n    \n    // Vesica SDF based on Inigo Quilez\n    width *= 2.0;\n    p = p * 2.0 - 1.0;\n    float d = sdfLens(p, width, 1.0);\n    vec2 grad = vec2(dFdx(d), dFdy(d));\n\n    float s = 1.0 - smoothstep(0.0, dot(abs(grad), vec2(1.0)) + smoothness, -d);\n    return vec3(s , normalize(grad) * smoothstep(1.0, 0.99, s) * smoothstep(0.0, 0.01, s)); \n}\n\nvec3 checkers45(const in vec2 pos, const in vec2 scale, const in vec2 smoothness)\n{\n    // based on filtering the checkerboard by Inigo Quilez \n    vec2 numTiles = floor(scale); \n    vec2 p = pos * numTiles * 2.0;\n    \n    const float angle = 3.14152 / 4.0;\n    const float cosAngle = cos(angle);\n    const float sinAngle = sin(angle);\n\n    p *= 1.0 / sqrt(2.0);\n    p = p * mat2(cosAngle, sinAngle, -sinAngle, cosAngle);\n    p += vec2(0.5, 0.0);\n    vec2 tile = mod(floor(p), numTiles);\n    \n    vec2 w = smoothness;\n    // box filter using triangular signal\n    vec2 s1 = abs(fract((p - 0.5 * w) / 2.0) - 0.5);\n    vec2 s2 = abs(fract((p + 0.5 * w) / 2.0) - 0.5);\n    vec2 i = 2.0 * (s1 - s2) / w;\n    float d = 0.5 - 0.5 * i.x * i.y; // xor pattern\n    return vec3(d, tile);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 p = fract(uv * TILES);\n    vec2 scale = vec2(SCALE);\n\t\n    const float totalCount = 19.0;\n    vec3 col;\n    float current;\n    if(iMouse.z > 0.0)\n    \tcurrent = (iMouse.x / iResolution.x) * totalCount;\n    else\n    {\n        current = mod(iTime * 0.5, totalCount);\n#if ANIMATE == 1\n    \tp += iTime * 0.03;\n#endif\n    }\n\n    current = clamp(floor(current), 0.0, totalCount - 1.0);\n\n    if(current < 1.0)\n    {\n        col = vec3(perlinNoise(p, scale, /*rotation:*/ iTime * 0.25, 0.0)) * 0.5 + 0.5;\n    }\n    else if(current < 2.0)\n    {\n        uint mode = uint(mod(iTime, 5.0));\n        if(mode == 4u)\n        {\n            col += cellularNoised(p, scale, /*jitter:*/ 1.0, /*phase*/ iTime * 0.5, 23.0).yzx * 0.5 + 0.5;\n        }\n        else\n        {\n        \tvec2 cells = cellularNoise(p, scale, /*jitter:*/ 1.0, /*phase:*/ iTime * 0.5, /*metric*/ mode, 0.0);\n        \tcol += 1.0 - cells.x;\n        }\n        \n    }\n    else if(current < 3.0)\n    {\n        col = vec3(perlinNoiseWarp(p, scale, /*strength:*/ 0.9, /*phase:*/ iTime * 0.5, mix(2.0, 6.0, abs(sin(iTime))), /*spread:*/ 0.001, 0.0));\n    }\n    else if(current < 4.0)\n    {\n        vec2 tilePos;\n        vec3 c = cracks(p, scale, /*jitter*/ 0.5 + sin(iTime) * 0.2, /*width:*/ 0.1, /*smoothness:*/ 0.5, /*warp:*/ 0.1, /*warpScale:*/ 4.0, /*warpSmudge:*/ true, /*smudgePhase:*/ iTime * 0.75, 23.0);\n        col += c.x;\n        col *= hash3D(c.yz*0.0001);\n    }\n    else if(current < 5.0)\n    {\n        float jitter = 0.2 + sin(iTime*0.5 + 23.0) * 0.1;\n        col+= randomLines(p + vec2(0.0, iTime * 0.35), scale, /*count*/ 14.0, /*width*/ 0.15, jitter, /*smoothness*/ vec2(0.1, 0.5), /*phase*/ iTime * 0.5, /*colorVariation*/ 0.5 + sin(iTime*0.5) * 0.5, 13.0).rgb;\n    }\n    else if(current < 6.0)\n    {\n       vec3 c = checkers45(p, scale, /*smoothness*/ vec2(0.5));\n       col += c.x;\n        \n       vec4 hash = hash4D(c.yz + mod(floor(iTime * 1.5), 128.0));\n       if(hash.w < (0.5 + sin(iTime * 0.5) * sin(iTime * 0.5) * 0.2))\n       \t\tcol += smoothstep(0.5, 0.0, c.x) * hash.rgb;\n    }\n    else if(current < 7.0)\n    {\n        vec3 d = dotsNoise(p, scale, /*density*/ 0.5 + sin(iTime * 0.5) * 0.25, /*size*/ 0.45, /*sizeVariation*/ 0.7 + sin(iTime + 0.25) * 0.3, /*roundness*/ 0.7 + sin(iTime * 2.0 + 23.0) *  0.3, 0.0);\n        col += hash3D(d.yy) * d.x * (d.z + 0.5);\n    }\n    else if(current < 8.0)\n    {\n        vec2 offset = vec2(iTime,cos(iTime*0.25)*2.)*0.015;\n\t\tcol += fbm(uv + offset, scale, 9, /*shift:*/ 23.0,  /*timeShift: */ iTime * 0.25, /*gain:*/ 0.49, /*lacunarity*/ 2.0, /*octaveFactor:*/ -0.5, 0.0);\n    }\n    else if(current < 9.0)\n    {\n        \n        col += fbmMetaballs(p, scale, 8, 0.0, /*timeShift:*/ iTime * 0.5, /*gain*/ 0.5, /*lacunarity*/ 2.0, /*octaveFactor*/ 0.0, /*jitter*/ 1.0, /*interpolate*/ 0.1, vec2(0.1, 0.03), 0.0); \n    }\n\n    else if(current < 10.0)\n    {\n        vec4 v = fbmVoronoi(p, scale, 16, /*shift*/ 0.5, /*timeShift:*/ iTime * 0.000005, /*gain*/ 0.5, /*lacunarity*/ 2.0, /*octaveFactor:*/ -0.3, /*jitter*/ 1.0, /*interpolate*/ 0.0, 0.00);\n        col = vec3(smoothstep(0.02, 0.10, v.x)) * v.yzw;\n    }\n    else if(current < 11.0)\n    {\n        vec3 tw = tileWeave(p, scale * 0.5, /*count*/ 3.0, /*width*/ 0.75, /*smoothness*/ 0.5 + sin(iTime) * 0.3);\n        col = vec3(fragCoord.x / iResolution.x < 0.5 ? tw.xxx : normalize(vec3(tw.yz, 1.0)) * 0.5 + 0.5);\n    }\n    else if(current < 12.0)\n    {\n        float axialShift = sin(iTime * 4.25) * sin(iTime * 4.25 + 0.53) * 0.64;\n        col = vec3(fbmPerlin(p, scale * 0.5, 16, /*shift*/ -iTime * 0.21, axialShift, /*gain*/ 0.3, /*lacunarity*/ 2.0, /*mode*/ 0u, /*factor*/ 0.75, /*offset*/ 0.0, 0.0)) * 2.0;\n    }\n    else if(current < 13.0)\n    {\n        vec2 phase = vec2(iTime *0.15, iTime *0.05 + 0.5);\n        col = vec3(organicNoise(p, scale, /*density*/ 1.0, phase, /*contrast*/ 0.0, /*highlights*/ 0.25, /*shift*/ 0.5 + 0.4 * sin(iTime),0.));\n    }\n    else if(current < 14.0)\n    {\n        col = fbmd(p, scale, 16, /*shift:*/ vec2(0.0), /*timeShift*/ iTime * 0.5, /*gain:*/ 0.5, /*lacunarity*/ vec2(2.0), /*slopeness:*/ 0.2 + sin(iTime) * 0.2, /*octaveFactor:*/ 0.5, 0.0).yzx * 0.5 + 0.5;\n        col = mix(col, col.zzz * 2.0 - 1.0, step(fragCoord.x / iResolution.x, 0.5));\n    }\n    else if(current < 15.0)\n    {\n        col = fbmdPerlin(p, scale, 8, /*shift:*/ vec2(iTime)*0.01, /*axialShift*/ iTime * 0.2, /*gain:*/ 0.45, vec2(2.0), /*slopeness:*/ 0.5, /* octaveFactor*/ sin(iTime) * 0.5, false, 0.0).yzx;\n        col = mix(normalize(col + vec3(0.,0.,1.)) * 0.5 + 0.5, col.zzz, step(fragCoord.x / iResolution.x, 0.5));\n    }\n    else if(current < 17.0)\n    {\n        // domain warping example\n        \n        int octaves = 16;\n        float gain = 0.5;\n        float lacunarity = 2.0;\n        float slopeness = 0.5;\n        vec2 factors = vec2(1.0);\n        vec4 shifts = vec4(123.0, 235.0, 53.0, 511.0);\n        \n        vec2 q;\n        vec2 r;\n    \tfloat f = current < 16.0 ? fbmWarp(p, scale, factors, octaves, shifts, iTime * 0.1, gain, vec2(lacunarity), slopeness, 0.0, false, 0.0, q, r) :\n        fbmWarp(p, scale, factors, octaves, shifts, iTime * 0.25, gain*0.93, vec2(lacunarity), slopeness, -0.5, true, 0.0, q, r);\n        \n        if (current < 16.0)\n        {\n            col = mix(vec3(0.1,0.5,0.8), vec3(0.6,0.6,0.3), clamp((f * f) * 8.0, 0.0, 1.0));\n            col = mix(col, vec3(0.0, 0.1, 0.05), length(q));\n            col = mix(col, vec3(0.8, 0.8, 0.8), r.x);\n            col = mix(col, col * vec3(0.8, 0.4, 0.2), 0.5 * pow(length(r), 4.0));\n        }\n        else\n        {\n            col = mix(vec3(0.1,0.4,0.7), vec3(0.6,0.5,0.3), clamp((f * f) * 1.0, 6.0, 3.0));\n            col = mix(col, vec3(0.0, 0.1, 0.05), length(q));\n            col = mix(col, vec3(0.1), r.x);\n            col = mix(col, col * vec3(1.8, 0.4, 0.2), 0.75 * pow(length(r), 10.0)) * 0.95;\n        }\n    }\n    else if(current < 18.0)\n    {\n        // domain warping with curl noise example\n\n        vec2 factors = vec2(1.25);\n        float curl = abs(sin(iTime * 0.5));\n        curl *= curl;\n        vec4 seeds = vec4(123.0, 235.0, 53.0, 511.0);\n        scale *= 0.25;\n        \n        vec2 q;\n        vec2 r;\n    \tfloat f = curlWarp(p, scale, factors, seeds, curl, 2.0, q, r);\n        col = vec3(1.0 - f);\n        col = mix(col, vec3(0.0, 0.1, 0.05), length(q));\n        col = mix(col, col * vec3(0.2, 0.4, 0.8), pow(length(r), 2.0));\n    }\n    else if(current < 19.0)\n    {\n        // multi value noise FBM\n        \n        int octaves = 16;\n        float lacunarity = 2.0;\n        \n        vec4 n = fbmMulti(uv, floor(scale * vec2(0.5, 1.)), lacunarity, octaves, iTime, 0.0);\n        n.xy = n.xz - n.yw;\n        vec2 v = 1.0 - pow(abs(n.xy) * 4.0, vec2(0.1));\n        col = vec3(pow(1.0 - v.x * v.y, 3.0));\n    }\n    \n#if SHOW_TILING == 1\n    vec2 pixel = vec2(TILES) / iResolution.xy;\n    uv *= TILES;\n\n    vec2 first = step(pixel, uv) * floor(mod(iTime * 0.75, 4.0)) * 0.25;        \n    uv  = step(fract(uv), pixel);               \n    col = mix(col, vec3(0.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKXWh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1177, 1188, 1210, 1260, 1343], [1345, 1345, 1369, 1419, 1502], [1504, 1504, 1526, 1580, 1756], [1758, 1758, 1779, 1835, 2047], [2049, 2049, 2071, 2154, 2378], [2380, 2380, 2401, 2484, 2801], [2803, 2803, 2824, 2907, 3251], [3254, 3254, 3281, 3281, 3450], [3452, 3512, 3546, 3546, 3689], [3691, 3752, 3814, 3814, 4059], [4061, 4127, 4206, 4206, 4470], [4473, 4533, 4618, 4618, 4903], [4972, 4972, 5034, 5034, 5136], [5138, 5149, 5190, 5190, 5266], [5267, 5267, 5308, 5308, 5384], [5385, 5385, 5428, 5428, 5579], [5580, 5580, 5648, 5648, 5765], [5767, 5767, 5812, 5812, 6223], [6225, 6225, 6277, 6277, 6669], [6671, 6682, 6743, 6743, 7233], [7235, 7235, 7296, 7296, 7965], [7967, 7967, 8031, 8031, 8749], [8751, 8751, 8807, 8868, 9681], [9682, 9682, 9754, 9815, 10979], [10981, 10981, 11053, 11053, 11200], [11202, 11202, 11255, 11351, 12073], [12074, 12074, 12143, 12239, 13300], [13301, 13301, 13371, 13371, 13515], [13517, 13517, 13586, 13682, 14988], [14990, 14990, 15118, 15118, 15433], [15435, 15435, 15557, 15557, 16415], [16416, 16416, 16560, 16560, 16745], [16747, 16747, 16841, 16841, 17338], [17340, 17340, 17456, 17456, 18070], [18073, 18091, 18186, 18186, 19806], [19807, 19807, 19890, 19890, 21478], [21480, 21480, 21555, 21619, 22893], [22894, 22894, 23051, 23051, 23321], [23323, 23323, 23402, 23402, 24748], [24750, 24750, 24860, 24860, 24980], [24982, 24991, 25130, 25130, 25849], [25851, 25851, 26005, 26053, 26918], [26919, 26919, 27075, 27075, 27194], [27195, 27195, 27350, 27350, 27463], [27465, 27465, 27658, 27658, 28491], [28493, 28493, 28658, 28658, 29631], [29633, 29633, 29807, 29855, 30594], [30595, 30595, 30771, 30771, 31048], [31050, 31050, 31228, 31228, 32104], [32107, 32116, 32342, 32392, 33159], [33161, 33161, 33275, 33275, 33782], [33784, 33784, 33911, 33911, 34534], [34536, 34546, 34596, 34596, 34846], [34847, 34847, 34929, 34929, 35448], [35450, 35450, 35533, 35593, 36229], [36231, 36231, 36288, 36288, 43467]], "test": "untested"}
{"id": "3stSWl", "name": "fractal derp", "author": "ArthurSango", "description": "fractal", "tags": ["fratcal"], "likes": 2, "viewed": 199, "published": "Public API", "date": "1573342456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvec2 transUV2(in vec2 uv, in vec2 uv2, in float val){\n    vec2 uvt = uv;\n    vec2 dir = normalize(uv - uv2);\n    uvt+=dir*max(0.0,1.0-distance(uv,uv2))*val;\n    //uvt.x+=sin(uvt.x*26.0+ani.x)*0.02;\n    //uvt.y+=sin(uvt.y*22.0+ani.y)*0.02;\n    return uvt;\n}\nvec2 transUV(in vec2 uv){\n    vec2 uvt = uv;\n    uvt.x+=sin(uvt.x*26.0+iTime*0.6)*0.2;\n    uvt.y+=sin(uvt.y*22.0+iTime*0.6)*0.2;\n    return uvt;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvO = fragCoord/iResolution.xy;\nvec2 uvM = iMouse.xy / iResolution.xy;\n    \n    uvM = vec2( sin(iTime) + 1., cos(iTime)+ 1.) * 0.25 + 0.5;\n  //vec2 uv = transUV2(uvO,uvM,0.1+(sin(iTime*3.0)*0.5+0.5)*0.3);\n    vec2 uv = transUV(uvO);\n   // float t = iTime;\n    uv = fract(uv * 3.);\n\tvec3 col = vec3(1.);\n\n    uv = uv * 2. - 1. ;\n    uv = abs(uv);\n    uv *= mat2( cos( t), sin(t), -sin(t), cos(t) );;\n    uv += step( uv.x, 0.5 ) * step(uv.y, 0.5) * 0.2;\n    \n    uv *= mat2( step( uv.x, 0.5 ), 0.,0.,step( uv.x, 0.5 ));\n    uv += step( uv.x, 0.5 ) * step(uv.y, 0.5) * 0.1;\n    uv *= mat2( step( uv.x, 0.5 ), 0.,0.,step( uv.x, 0.5 ));\n    uv += step( uv.x, 0.5 ) * step(uv.y, 0.5) * 0.1;\n     uv *= mat2( step( uv.x, 0.5 ), 0.,0.,step( uv.x, 0.5 ));\n    uv += step( uv.x, 0.5 ) * step(uv.y, 0.5) * 0.1;\n     uv *= mat2( step( uv.x, 0.5 ), 0.,0.,step( uv.x, 0.5 ));\n    uv += step( uv.x, 0.5 ) * step(uv.y, 0.5) * 0.1;\n    \n    uv = fract(uv);\n    \n    col.x = uv.y + 0.2 ;\n    col.y = 0.;\n    col.z = smoothstep( 0.1, 0.3 ,length(uv) ) * uv.x * uv.y + 0.2;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 70, 70, 273], [274, 274, 299, 299, 420], [421, 421, 478, 528, 1634]], "test": "untested"}
{"id": "3stSWs", "name": "Raymarching [4] Shadows", "author": "camelcoder", "description": "Raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 66, "published": "Public", "date": "1573146422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sd_sphere(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\n\nfloat map(vec3 pos)\n{\n    // create floor\n    float d = pos.y - -0.5;\n    \n    vec3 p = pos;\n    \n    p.xz += vec2(sin(iTime * 0.5), cos(iTime * 0.5));\n    \n    \n    d = min(d, sd_sphere(p, 0.5));\n    \n    d = min(d, sd_sphere(p - vec3(0.3, 0.3, 0), 0.25));\n    d = min(d, sd_sphere(p - vec3(-0.3, 0.3, 0), 0.25));\n    \n    return d;\n}\n\n\nvec3 calc_normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\nfloat cast_ray(vec3 ro, vec3 rd)\n{\n    float total = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        vec3 pos = ro + total * rd;\n        \n        float dist = map(pos);\n        \n        if (dist < 0.001) break; // to close\n        total += dist;\n        if (total > 20.0) { // to far\n            total *= -1.0;\n            break;\n        }\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    fragCoord *= 2.0;\n\tvec2 p = (fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -2.0); // ray origin\n    vec3 rd = normalize(vec3(p, 1.5)); // ray direction\n    \n    vec3 col = vec3(0.6, 0.7, 0.8) - 0.4 * rd.y; // sky\n    col = mix(col, vec3(0.75, 0.8, 0.85), exp(-13.0 * rd.y)); // horizon\n   \n    float total = cast_ray(ro, rd);\n    \n    if (total > 0.0) {\n        vec3 pos = ro + total * rd;\n        vec3 norm = calc_normal(pos);\n        \n        vec3 mate = vec3(0.18); // Don't do full white's\n        \n        // dot(a, b) -> how aligned are a and b\n        vec3 sun = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_dif = clamp(dot(norm, sun), 0.0, 1.0);\n        // step(a, b) -> if a < b then 0 else 1\n        float sun_sha = step(cast_ray(pos + norm * 0.001, sun), 0.0);\n        col = mate * vec3(7.0, 4.5, 3.0) * sun_dif * sun_sha;\n        \n        \n        // Blueish sky light from above\n        float sky_dif = clamp(0.5 + 0.5 * dot(norm, vec3(0, 1, 0)), 0.0, 1.0);\n        col += mate * vec3(0.5, 0.8, 0.9) * sky_dif;\n        \n        // Remove blacks, by bouncing light of the ground\n        float bou_dif = clamp(0.5 + 0.5 * dot(norm, vec3(0, -1, 0)), 0.0, 1.0);\n        col += mate * vec3(0.7, 0.3, 0.2) * bou_dif;\n    }\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [66, 66, 87, 107, 401], [404, 404, 430, 430, 643], [644, 644, 678, 678, 1010], [1012, 1012, 1069, 1120, 2482]], "test": "untested"}
{"id": "3stXDl", "name": "Raymarching [2] Normals", "author": "camelcoder", "description": "Raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 56, "published": "Public", "date": "1573142252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sd_sphere(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat map(vec3 pos)\n{\n    // create floor\n    float d = pos.y - -0.5;\n \n    vec3 p = pos;\n    \n    p.xz += vec2(sin(iTime), cos(iTime));\n    \n    d = min(d, sd_sphere(p, 0.5));\n    \n    d = min(d, sd_sphere(p - vec3(0.3, 0.3, 0), 0.25));\n    d = min(d, sd_sphere(p - vec3(-0.3, 0.3, 0), 0.25));\n    \n    return d;\n}\n\nvec3 calc_normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    fragCoord *= 2.0;\n\tvec2 p = (fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -2.0); // ray origin\n    vec3 rd = normalize(vec3(p, 1.5)); // ray direction\n    \n    vec3 col = vec3(0);\n    \n    /**\n     * Raymarch\n     **/\n    \n    float total = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        vec3 pos = ro + total * rd;\n        \n        float dist = map(pos);\n        \n        if (dist < 0.001) break; // to close\n        total += dist;\n        if (total > 20.0) { // to far\n            total *= -1.0;\n            break;\n        }\n    }\n    \n    if (total > 0.0) {\n        vec3 pos = ro + total * rd;\n        vec3 norm = calc_normal(pos);\n        \n        \n        // col = vec3(norm);\n        // col = vec3(norm.yyy);\n        col = vec3(norm.xy, -norm.z);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [65, 65, 86, 106, 380], [382, 382, 408, 408, 621], [623, 623, 680, 731, 1566]], "test": "untested"}
{"id": "3stXDX", "name": "Font Forest", "author": "ShnitzelKiller", "description": "Extruded interpolated fonts. Mouseable.", "tags": ["3d", "raymarching", "font"], "likes": 14, "viewed": 477, "published": "Public API", "date": "1573022835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by FabriceNeyret2's https://www.shadertoy.com/view/tdcXW2\n// remade in \"real\" 3D with raymarching\n\n#define FDIST 0.5\n#define MAXSTEP 100\n#define TOL 0.001\n#define MAXDIST 20.\n#define INTERP_SCALE -3.\n#define REPEAT_SCALE 1.5\n#define MOUSE_SCALE 0.014\n#define TEXSCALE vec2(1.5, 1.)\n#define TEX_BIAS 0.49803921568\n\n//comment this out if you have weird artifacts where segments don't line up\n#define SHUFFLE\n\nfloat rand(vec2 uv) {\n    return fract(814.*sin(uv.x*15829.+uv.y*874.));\n}\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}\n\nvec2 id2coord(in float id) {\n    #ifdef SHUFFLE\n    id = floor(noise1D(id) * 256.);\n    #endif\n    return vec2(mod(id, 16.), floor(id/16.))/16.;\n}\n\nvoid transform(inout vec3 ro) {\n    vec2 id = floor((ro.xy+REPEAT_SCALE*0.5)/REPEAT_SCALE);\n    float offset = rand(id)*256.;\n    ro = vec3(mod(ro.xy+REPEAT_SCALE*0.5, REPEAT_SCALE)-REPEAT_SCALE*0.5, ro.z*INTERP_SCALE + offset);\n}\n\n/**\nCompute analytic gradient\n*/\nvec3 grad(in vec3 ro) {\n    transform(ro);\n    float t = ro.z;\n    float id = floor(t);\n    vec2 offset = clamp(ro.xy+0.5, 0., 1.)/16.;\n    vec2 coords1 = id2coord(id) + offset;\n    vec2 coords2 = id2coord(id+1.) + offset;\n    \n    vec4 tex1 = textureGrad(iChannel0,coords1,dFdx(offset),dFdy(offset));\n    vec4 tex2 = textureGrad(iChannel0,coords2,dFdx(offset),dFdy(offset));\n    \n    float dist1 = tex1.w-TEX_BIAS;\n    float dist2 = tex2.w-TEX_BIAS;\n    \n    vec2 norm1 = (tex1.yz-TEX_BIAS)*2.;\n    vec2 norm2 = (tex2.yz-TEX_BIAS)*2.;\n    \n    float tf = fract(t);\n    float alpha = smoothstep(0., 1., tf);\n    vec3 n = vec3(norm1 * (1.-alpha) + norm2 * alpha, (dist2 - dist1) * INTERP_SCALE * 6. * (tf - tf*tf));\n    n.y = -n.y;\n    return normalize(n);\n}\n\nfloat map(in vec3 ro) {\n    transform(ro);\n    float t = ro.z;\n    float id = floor(t);\n    vec2 offset = clamp(ro.xy+0.5, 0., 1.)/16.;\n    vec2 coords1 = id2coord(id) + offset;\n    vec2 coords2 = id2coord(id+1.) + offset;\n    \n    float dist1 = textureGrad(iChannel0, coords1,dFdx(offset), dFdy(offset)).w-TEX_BIAS;\n    float dist2 = textureGrad(iChannel0, coords2,dFdx(offset), dFdy(offset)).w-TEX_BIAS;\n    vec2 displacement = abs(ro.xy)-0.5;\n    float alpha = smoothstep(0., 1., fract(t));\n    return max(max(displacement.x, displacement.y), 0.5*(dist1 * (1.-alpha) + dist2*alpha));\n}\n\nvec2 raymarch(in vec3 eye, in vec3 rd) {\n    float t = 0.0;\n    int i;\n    for (i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        float dist = map(pos);\n        t += dist;\n        if (abs(dist) < TOL || t > MAXDIST) break;\n    }\n    return vec2(t, i);\n}\n\nbool shadowmarch(in vec3 eye, in vec3 rd, float lightdist) {\n    float t = 0.0;\n    float minstep = 0.01;\n    for (int i=0; i<50; i++) {\n        vec3 pos = eye + rd * t;\n        float dist = map(pos);\n        if (dist < 0.) return true;\n        else if (t > lightdist) return false;\n        float s = max(dist, minstep);\n        minstep += 0.001;\n        t += s;\n        \n    }\n    return false;\n}\n\nvec3 albedo(in vec3 n, in vec3 ro) {\n    vec2 texcoord1 = ro.yz * TEXSCALE;\n    vec2 texcoord2 = ro.xz * TEXSCALE;\n    vec3 tex1 = texture(iChannel1, texcoord1.yx).xyz;\n    vec3 tex2 = texture(iChannel1, texcoord2.yx).xyz;\n    return (abs(n.x) * tex1 + abs(n.y) * tex2 - 0.5)*0.7 + 0.5;\n}\n\nfloat shade(in vec3 n, in vec3 ro, in vec3 lightpos, in bool shadow) {\n    vec3 l = lightpos - ro;\n    float ldist = length(l);\n    if (shadow && shadowmarch(ro + n*TOL*2., l/ldist, ldist)) {\n    \treturn 0.;\n    }\n    return max(0.,dot(l, n))/ldist*min(1., 2.5/(ldist*ldist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xx;\n\t\n    vec3 up = vec3(0, 0, 1);\n    vec3 eye = vec3(REPEAT_SCALE*0.6*cos(iTime*0.5 + iMouse.x*MOUSE_SCALE), REPEAT_SCALE*0.6*sin(iTime*0.5 + iMouse.x*MOUSE_SCALE), iTime*2.);\n    vec3 lightpos = vec3(REPEAT_SCALE*0.2, REPEAT_SCALE*0.5, iTime*2.+1.5);\n    vec3 lightpos2 = vec3(-REPEAT_SCALE*0.2, -REPEAT_SCALE*0.5, iTime*2.);\n    vec3 w = normalize(vec3(-eye.xy, iMouse.w > 1. ? (iMouse.y-iResolution.y*.5) * MOUSE_SCALE * REPEAT_SCALE * 0.66 : 2.*cos(iTime*0.13)));\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*FDIST + u*uv.x + v*uv.y);\n\tvec2 t = raymarch(eye, rd);\n    vec3 ro = t.x * rd + eye;\n    vec3 n = grad(ro);\n    float fac1 = shade(n, ro, lightpos, true);\n    float fac2 = shade(n, ro, lightpos2, false);\n    vec3 a = albedo(n, ro);\n    float fogfac = min(0.1,t.x*0.005);\n    vec3 finalcol = a*fac1*vec3(0.7, 0.8, 1.) + a*fac2*vec3(0.5, 0.25, 0.25) + vec3(0., 0., 0.05)*n.z/t.x + fogfac*mix(vec3(2, 0.4, 0.0), vec3(2, 3, 5), rd.z*.5+.5);\n    fragColor = vec4(pow(finalcol, vec3(0.6)),1.);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 419, 440, 440, 493], [495, 495, 519, 519, 562], [564, 564, 592, 592, 710], [712, 712, 743, 743, 942], [944, 977, 1000, 1000, 1734], [1736, 1736, 1759, 1759, 2324], [2326, 2326, 2366, 2366, 2591], [2593, 2593, 2653, 2653, 2990], [2992, 2992, 3028, 3028, 3280], [3282, 3282, 3352, 3352, 3560], [3562, 3562, 3619, 3619, 4730]], "test": "untested"}
{"id": "3sVXWK", "name": "Shifting Perforations 2", "author": "ShnitzelKiller", "description": "Automatic oriented cavity placement on more general solids", "tags": ["raytracing", "raymarching", "metaball", "hole", "interior"], "likes": 3, "viewed": 356, "published": "Public API", "date": "1575016789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// size of the windows\n#define STRIDE 0.25\n\n// depth of the holes\n#define DEPTH 0.125\n\n// raymarching\n#define FDIST 0.5\n#define STEPS 50\n#define SHADOWSTEPS 25\n#define MIN_SHADOW_STEP 0.075\n#define TOL 0.005\n#define SHARPNESS 6.5\n\n// distance function for hull geometry\nfloat map(in vec3 ro) {\n    float dist1 = length(ro-vec3(0., 1., 0.))-1.;\n    float dist2 = length(ro-vec3(0., -1., 0.))-1.;\n    float ang = iTime * 0.4564;\n    float dist3 = length(ro-vec3(1.5*cos(ang), 1., 1.5*sin(ang)))-0.4;\n    float dist4 = length(ro-vec3(-1.5*cos(ang), 1., -1.5*sin(ang)))-0.4;\n    float dist5 = length(ro-vec3(0, -1., 0.6))-0.5;\n    \n    float final_dist = -log(exp(-dist1*SHARPNESS) + exp(-dist2*SHARPNESS) + exp(-dist3*SHARPNESS) + exp(-dist4*SHARPNESS))/SHARPNESS;\n    final_dist = log(exp(final_dist*SHARPNESS) + exp(-dist5*SHARPNESS))/SHARPNESS;\n    return final_dist;\n}\n\n// normals of hull geometry\nvec3 grad(in vec3 ro) {\n    vec2 diff = vec2(TOL, 0.);\n    float dx = map(ro + diff.xyy) - map(ro - diff.xyy);\n    float dy = map(ro + diff.yxy) - map(ro - diff.yxy);\n    float dz = map(ro + diff.yyx) - map(ro - diff.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd) {\n    float t=0.;\n    for (int i=0; i<STEPS; i++) {\n        float dist = map(ro + rd*t);\n        t += dist;\n        if (abs(dist) < TOL) {\n            return t;\n        }\n    }\n    return -1.;\n}\n\nfloat shadow_march(in vec3 ro, in vec3 rd) {\n    float t=0.;\n    for (int i=0; i<SHADOWSTEPS; i++) {\n        float dist = map(ro + rd*t);\n        t += max(dist, MIN_SHADOW_STEP);\n        if (dist < 0.) return 0.;\n    }\n    return 1.;\n}\n\n\n// Raytrace box, returns (t_in, t_out)\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    vec3 pin =  - k - n;\n    float tout = min(pout.x, min(pout.y, pout.z));\n    float tin = max(pin.x, max(pin.y, pin.z));\n    if (tin > tout) {\n        return vec2(-1.);\n    }\n    no = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tfloat ang = iTime * 0.3;\n    vec3 eye = 2.5*vec3(cos(ang), sin(ang), .5);\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + FDIST * w);\n    \n    float t = raymarch(eye, rd);\n    vec3 ro = eye + t * rd;\n\tvec3 n = grad(ro);\n    vec3 col;\n    \n    if (t > 0.) {\n        \n        //get offsets and cell IDs and their centroids/normals\n        vec3 offset = vec3(iMouse.x/iResolution.x, iTime*0.3, iMouse.y/iResolution.y);\n        ro += offset;\n        vec3 mask = 1.-step(0.9,abs(fract(ro/STRIDE)-0.5)*2.);\n        vec3 modro = fract(ro/STRIDE);\n        vec3 id = floor(ro/STRIDE);\n        ro -= offset;\n        // cell centroid, normal at centroid, and offset of centroid from surface\n        vec3 cc = (id+0.5)*STRIDE - offset;\n        vec3 nn = grad(cc);\n        float OFFSET = map(cc);\n        \n        // transform to tangent space for raytracing cavities\n        // offset depth by centroid's distance from the surface\n        vec3 uu = normalize(cross(vec3(0., 0., 1.), nn));\n        vec3 vv = cross(nn, uu);\n        mat3 rot = mat3(uu, vv, nn);\n        mat3 rott = transpose(rot);\n        vec3 rd_inner = rott * rd;\n        vec3 ro_inner = rott * (ro-cc) + vec3(0., 0., OFFSET);\n        vec3 n_inner;\n        vec3 dims = vec3(vec2(0.3*STRIDE), DEPTH);\n        vec2 t_inner = box(ro_inner, rd_inner, dims, n_inner);\n        \n        float shadow_fac = 1.;\n        vec3 sundir = normalize(vec3(1., 2., 1.5));\n        if (t_inner.y > 0. && t_inner.x < 0. && mask.x*mask.y*mask.z > 0.5) {\n            // determine inner shadows\n            vec3 sundir_inner = rott * sundir;\n            vec3 n_shadow;\n            vec3 ro_shadow = ro_inner + t_inner.y * rd_inner;\n\t\t\tvec2 t_shadow = box(ro_shadow, sundir_inner, dims, n_shadow);\n            // where the shadow ray hits the cavity in world space; if it's outside the hull, no shadow\n            ro = cc + rot * (ro_shadow - vec3(0., 0., OFFSET) + t_shadow.y * sundir_inner);\n            shadow_fac = step(0., map(ro));\n            n = rot * n_inner;\n        }\n        // compute global shadows\n        if (shadow_fac > 0.5)\n        \tshadow_fac *= shadow_march(ro + n * TOL, sundir);\n        \n        // shade\n        shadow_fac *= max(0., dot(n, sundir));\n        float ambient = abs(dot(n, -sundir));\n        col = shadow_fac * vec3(1., 1., 0.95) + ambient * vec3(0.05, 0.05, 0.04);\n    } else {\n        col = vec3(0.);\n    }\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 270, 293, 293, 869], [871, 899, 922, 922, 1163], [1165, 1165, 1205, 1205, 1398], [1400, 1400, 1444, 1444, 1635], [1638, 1677, 1735, 1735, 2115], [2117, 2117, 2174, 2174, 4762]], "test": "untested"}
{"id": "3sVXWw", "name": "Dithery Test", "author": "spalmer", "description": "test of screen 2D noise function for dithering, supports zoom.\nmouse splitscreen shows the severe color banding that 8-bit buffer quantization would otherwise do to the image.\nApparently, blue noise is ideal for this purpose.", "tags": ["noise", "random", "dithering"], "likes": 2, "viewed": 88, "published": "Public", "date": "1574179278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// test of screen dithering strategies\n\n// I give up!  I don't care anymore, especially about temporal change.\n// All the ALU hashes I have tried just fail or look bad,\n// to the point where I am convinced the standard Bayer table\n// ordered dither produces superior results.\n// It's so much simpler (if you have the table handy)\n// that there's no point wasting futher time on it.\n\n\n// uses a novel local-contiguity-preserving oscillator\n// to eliminate visual popping when animated\n\n// makes an even-integer-frequency triangle wave; like fract but preserves g0 contiguity.\nfloat osctri(float x) \n{\n\tfloat i = floor(x); \n\tx -= i; // now mirror the odd ones to preserve local contiguity\n\tfloat o = mod(i, 2.); //step(1., mod(i, 2.)); //float(int(i) & 1); //\n    return o + x - 2.*o*x; // branchless, eval to either 0 + x - 2*0*x = x, or 1 + x - 2*1*x = 1 - x; one conversion\n}\n\n// a scaled version of smoothstep\n// = ((3 - 2*x)*x + 3)*x/4;\n// It looks like an almost-triangle-wave.  If you want to graph it in Graphmatica:\n// y = ((.75 - .5*x)*x + .75)*x { x : [0,1) } ; y = ((.75 - .5*(2-x))*(2-x) + .75)*(2-x) { x : [1,2) }\n// btw Horner reduction is *not* the most efficient way to evaluate these polynomials\nfloat bentstep(float x)\n{\n\treturn ((.75 - .5*x)*x + .75)*x;\n}\n\n// this oscrand function has a few important qualities:\n// it's locally g0 contiguous everywhere to reduce visual pops when animated slowly;\n// it remaps the mantissa nonlinearly to reduce correlation to the argument, \n// but does so gently so its derivative isn't flat anywhere;\n// the result is a lot like a very sharp sinusoid function\n// but hopefully cheaper to compute than actual sine\n\n// similar to rand(x) but preserves local g0 contiguity; \n// also decorrelates output from input\nfloat oscrand(float x)\n{\n\tx = osctri(x); // fract(x) would destroy contiguity (a little bit)\n\tx = bentstep(x); // *gentle* nonlinear remapping; smoothstep is too much!\n \tx *= 47918.; // tile an even bunch of times after bending\n\tx = osctri(x);\n    return x;\n}\n//\tx *= 1.618034; // involving another mul by Phi; idk, seems unnecessary\n\n// omg Dithery is bad, I don't recall it being quite so pathetic.  but it is!\nfloat Dithery(vec2 p)\n{\n    const float rate = 1e-5; // noise animation speed\n    const float scale = .127;\n    float t = osctri(iTime) * rate;\n    return oscrand(dot(vec2(p), vec2(1.0, 2.017)) * scale + t); // rand has too many discontinuities\n} // result 0..1\n\n// returns unsigned (for use by violet & blue noises)\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(17.1,13.7)))*23456.) * 2. - 1.; // good 'nuff\n//    return Dithery(p); // meh\n}\n\n// see https://shadertoy.com/view/Wtfczs\nfloat violetnoise3(vec2 p)\n{\n    return .5*(hash21(p+vec2(1,0)) + hash21(p+vec2(0,1)) - hash21(p));\n}\n\nfloat violetnoise4(vec2 p)\n{\n    p *= 2.; // looks better with?\n    return (hash21(p+vec2(1,0)) + hash21(p+vec2(0,1))\n          - hash21(p-vec2(1,0)) + hash21(p-vec2(0,1))) * .5;\n}\n\nfloat bluenoise5(vec2 p)\n{\n    return hash21(p)\n        - .25 * (\n\t\t\thash21(p + vec2( 1,0))\n\t\t+\thash21(p + vec2(-1,0))\n\t\t+\thash21(p + vec2(0, 1))\n\t\t+\thash21(p + vec2(0,-1))\n        );\n}\n\nfloat Dither1(vec2 p) // signed wrapper around Dithery\n{\n    float g = Dithery(p);\n\tg = g * 2. - 1.; // unsigned -> signed only needed for Dithery, not Dither2\n    return g;\n}\n\n// A simple dither that works quite a lot better\n// (sorry, based on sine!! haha)\n// actually it's quite directionally biased\n// but tuned in such a way that it lines up\n// well on screen coordinates and\n// produces a hexagonal lattice of sorts\nfloat DitherB(vec2 p)\n{\n//    p.x += step(mod(p.y, 2.), 1.);\n    return sin(osctri(dot(p, vec2(1./6., 4.99/iResolution.x))) * 33.);\n}\n\n// originally from Fly Camera, iirc; works better than most others I've tried!\n// but if you zoom in, it has a severe doubled-pixels problem!\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./3., 1./22.)) * 23456.);\n}\n\nfloat Dither2(vec2 p)\n{\n    return Dither(p + osctri(iTime * 1e-3));\n}\n\n// http://wikipedia.org/wiki/Halton_sequence\n// Van der Corput sequence translator\n// from https://shadertoy.com/view/tdffWS\nfloat H1(int i, int m)\n{\n\tfloat h = 0., r = 1. / float(m), recip = 1.;\n\tint digit;\n\twhile (i != 0) {\n        int k = i / m;\n        digit = i - k * m; //i % m; //\n\t\ti = k;\n\t\th += float(digit) * (recip *= r);\n\t}\n\treturn h;\n}\n\nfloat Dither3(vec2 p)\n{\n    //ivec2 q = ivec2(p);\n     //+ osctri(iTime * 1e-3)\n    int i = int(p.x + 3.*p.y); //q.x + 5*q.y;\n    return H1(i, 5) * 2. - 1.;\n}\n\nuint ReverseBits32(uint n) // reverses the bit pattern, i.e. 1101 becomes 1011\n{\n\tn = ((n >>  1u) & 0x55555555u) | ((n & 0x55555555u) <<  1u);\n\tn = ((n >>  2u) & 0x33333333u) | ((n & 0x33333333u) <<  2u);\n\tn = ((n >>  4u) & 0x0f0f0f0fu) | ((n & 0x0f0f0f0fu) <<  4u);\n\tn = ((n >>  8u) & 0x00ff00ffu) | ((n & 0x00ff00ffu) <<  8u);\n\tn = ((n >> 16u) & 0x0000ffffu) | ((n & 0x0000ffffu) << 16u);\n\treturn n;\n}\n\nfloat Dither4(vec2 p)\n{\n    uint x = uint(p.x + iResolution.x * p.y);\n    uint y = ReverseBits32(x);\n    x ^= (y ^ (y >> 16)); // ^ (y << 16));\n    return float(x & 0xffffu) / exp2(16.) * 2.-1.; //exp2(23.) / float(x >> 9); //\n}\n// an extremely simple bit-munging PRNG\nuint XorSmash(uint x)\n{\n//    x = ReverseBits32(x);\n    for (int i = 11; i-- > 0; x = ((x >> 6) ^ 5u) ^ (x << 3) ^ (x << 1));\n    return x;\n}\n\nfloat Dither5(vec2 p)\n{\n    uint x = uint(p.x + iResolution.x * p.y);\n    x = XorSmash(x);\n    return float(x & 0xffffu) / exp2(16.) * 2.-1.; //exp2(23.) / float(x >> 9); //\n}\n/*\n// it's way too obvious a pattern, looking at it again now.\n// I \"adjusted\" it and now it's trash.  :(\nfloat DitherJimenez2(vec2 p)\n{\n    // Jorge Jimenez called this interleaved gradient noise;  see slide 123 in:\n\t//  http://iryoku.com/downloads/Next-Generation-Post-Processing-in-Call-of-Duty-Advanced-Warfare-v18.pptx\n\t// from Siggraph 2014, but he never explains how they chose the magic constants.\n\t// works great, but it's not mine, and since I didn't build it or pick the constants,\n\t// idk what situations it's really appropriate for or how to adjust it when needed.\n    // osctri seems better than fract in many ways, but brings its own issues :(\n\treturn osctri(108. * osctri(dot(p, vec2(.06711056, .00583715)))) * 2. - 1.; // 1/14.9007846, 1/171.316482\n}\n// older copy just uses fract but I don't like it; the pattern is very linear and obvious.\n// I think I must have botched it somehow.\nfloat DitherJimenez1(vec2 p)\n{\n\treturn fract(52.9829189 * fract(dot(p, vec2(0.06711056, 0.00583715)))) * 2. - 1.; // 1/14.9007846, 1/171.316482\n}\n*/\n\n// Dammit, at this point I can't even find the old thing I thought was awesome before,\n// or if I did, I no longer think it's quite so awesome?  \n\n// At this point I don't even care anymore, I'm just using a bayer texture or table!\n\n// shaders work much better with data from buffers or images, not const arrays!\n// besides this is only 4x4\nfloat DitherBayerLUT(vec2 q)\n{\n    // 4x4 Bayer ordered dither pattern, floats\n\t// TODO try unorm float type\n\tconst float[16] ditherTable = float[16] ( \n\t\t.05885815, .52972337, .17657446, .64743967,\n\t\t.76515597, .29429076, .88287228, .41200706,\n\t\t.23543261, .70629782, .11771630, .58858152,\n\t\t.94173043, .47086521, .82401413, .35314891\n\t);\n\tivec2 p = ivec2(q) & 3; return ditherTable[p.x + 4 * p.y] * 2. - 1.;\n}\n\n// the standard Shadertoy.com Bayer texture is 8x8\nfloat DitherBayerTex(vec2 p) // of course must know the texture channel!\n{\n    return texture(iChannel0, p / iChannelResolution[0].xy).x * 2. - 1.;\n}\n// simple, works well, only problem is that it occupies a sampler!\n\nfloat BlueNoiseTex(vec2 p)\n{\n    return texture(iChannel1, p / iChannelResolution[1].xy).x * 2. - 1.;\n}\n\nfloat WhiteNoiseTex(vec2 p)\n{\n    return texture(iChannel2, p / iChannelResolution[2].xy).x * 2. - 1.;\n}\n\n// theoretically, blue noise is ideal for dithering\n// due to its propensity toward high frequencies\n// especially if it's gaussian value distributed\n// and signed!  But almost anything seems better than nothing.\n// Low frequencies will be noticeable though,\n// and any pattern *will* be noticed by the human eye.\n// violet noise is pretty cheap and easy to compute in a pinch,\n// and though not quite blue, is still way better than white noise.\n#define ChooseDither \\\nbluenoise5 //violetnoise3 //violetnoise4 //\n//BlueNoiseTex //WhiteNoiseTex //DitherBayerTex //DitherBayerLUT //\n//DitherJimenez //hash2_idk //\n//Dither5(p); //Dither4(p); //Dither3(p); //Dither2(p); //Dither1(p); //\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    const float zoom = 1.; //2.; //4.; //8.; //16.; // zoom \n    // use amp of zero if you want to watch the bands crawl by\n    float amp = .6/256.; //.5; //.0; //.5/127.; //.25; //1.; // should be nigh imperceptible at around .7/256.\n    vec2 uv = p / iResolution.xy;\n    // show pattern in PiP window at bottom left if divider doesn't hide it\n    if (all(lessThan(uv, vec2(1./6.)))) amp = .5;\n    p /= zoom;\n    p = floor(p) + .5; // pixellate - be careful not to break the 1:1 case!  round() does not work!\n    // color gradient designed to exhibit banding, which the dithering is expected to be able to counter.\n    c.rgb = .5 + .5 * cos(.1*iTime + .125 * uv.xyx + vec3(0,2,4));\n    float divider = (dot(iMouse,iMouse) < 2.5) ? .085 : iMouse.x / iResolution.x;\n    c += exp2(-1024.*abs(uv.x-divider));\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // gamma correct to srgb gamut\n\t// dithering works best in output gamma, as the quanta are equally spaced.\n    if (uv.x >= divider) {\n\t    float g = ChooseDither(p);\n\t    g *= amp; // dither scale\n\t    c.rgb += g;\n    }\n    c.a = 1.;\n}\n//    c.rgb = vec3(.5); // HACK debug noise only\n//    c.rgb = pow(c.rgb, vec3(1./2.2)); // when just viewing the pattern itself\n\n//\tx = (3.0-2.0*x)*x*x; // smoothstep remaps mantissa nonlinearly, but too much, flattens gradient near 0 and 1 which leaves some nearby values correlated\n//\tx *= 45317.67285; // now tile a whole bunch of times\n//\tif ((int(i)&1)!=0) x = 1.0-x;\n//\treturn fract(x); // and keep the fraction\n//\tg = mix(max(0., 1.-amp), 1., g); // smash up close to white, for use as an attenuation factor\n//\tg = g * .5 + .5; // to near gray\n//\tcol *= g; //vec3(g); // multiply affects brights more; unsure if that's a good thing\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 575, 599, 599, 876], [878, 1212, 1237, 1237, 1273], [1668, 1765, 1789, 1789, 2024], [2100, 2178, 2201, 2201, 2424], [2441, 2495, 2517, 2517, 2630], [2632, 2673, 2701, 2701, 2774], [2776, 2776, 2804, 2804, 2956], [2958, 2958, 2984, 2984, 3143], [3145, 3145, 3201, 3201, 3320], [3322, 3567, 3590, 3627, 3700], [3702, 3844, 3866, 3866, 3922], [3924, 3924, 3947, 3947, 3994], [3996, 4121, 4145, 4145, 4344], [4346, 4346, 4369, 4425, 4504], [4506, 4506, 4586, 4586, 4909], [4911, 4911, 4934, 4934, 5139], [5140, 5180, 5203, 5231, 5321], [5323, 5323, 5346, 5346, 5498], [6784, 6892, 6922, 7000, 7303], [7305, 7356, 7430, 7430, 7505], [7506, 7574, 7602, 7602, 7677], [7679, 7679, 7708, 7708, 7783], [8298, 8471, 8507, 8507, 9587]], "test": "untested"}
{"id": "3sVXWz", "name": "Ordinary Crystal", "author": "ShnitzelKiller", "description": "Aside from fluctuating monetary value, this crystal is perfectly normal.", "tags": ["raytracing", "reflection", "refraction", "glossy", "crystal"], "likes": 11, "viewed": 332, "published": "Public API", "date": "1573803404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n\n#define SPHERESPACING 0.25\n#define SPHEREGRID 0.01\n\n#define BOXDIMS vec3(0.6, 0.6, 1.)\n\n#define ABSORPTION_RATE vec3(0.9, 0.8, 0.8)\n#define IOR 1.33\n//#define SCATTER_FACTOR 0.05\n#define SAMPLES 25\n#define REFLECTIONS 4\n\n#define TIME_T 6.\n#define TIME_H 2.\n#define TIME_L 6.\n\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 ni, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return vec2(-1.);\n    ni = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    no = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nvec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return vec2(-1.);\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    float tout = -pd + tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return vec2(tin, tout);\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\n//raytrace the exterior surroundings\nvec4 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    vec3 col1;\n    if (t < 0.) {\n        t = 1000.;\n        col1 = bgcol(rd);\n    } else {\n        vec2 uv = ro.xy+t*rd.xy;\n        if (max(abs(uv.x), abs(uv.y)) > 8.) col1 = bgcol(rd);\n        else {\n            vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n            float aofac = smoothstep(-0.7, 0.3, length(abs(uv)-min(abs(uv), vec2(0.75))));\n            col1 = mix(vec3(0.2), vec3(0.8), min(checkers.x,checkers.y)) * aofac;\n        }\n    }\n    \n    vec3 ni;\n    vec2 t2 = sphere(ro - vec3(BOXDIMS.x + 0.6, 0., -0.4 + abs(0.8*sin(1.4*iTime))), rd, 0.6, ni);\n    vec3 spherero = t2.x * rd + ro;\n    vec3 spherech = smoothstep(vec3(SPHEREGRID*0.75), vec3(SPHEREGRID), abs(mod(spherero, vec3(SPHERESPACING))*2.-SPHERESPACING));\n    float tea = mix(t, t2.x, step(0., t2.x));\n    return vec4(mix(col1, mix(vec3(1., 0., 0.), mix(vec3(1.), vec3(0.5, 0.6, 0.8), spherero.z+0.5), min(spherech.x, min(spherech.y, spherech.z))), step(0., t2.x)), tea);\n}\n\nvec3 randnorm(vec2 seed, float SCATTER_FACTOR) {\n    vec2 theta = rand2d(seed);\n    theta *= vec2(2.*PI, SCATTER_FACTOR*PI);\n    return vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni, no;\n    vec2 t = box(eye, rd, BOXDIMS, ni, no);\n    vec3 ro = eye + t.x * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    vec4 bgg = background(eye, rd);\n    \n    if (t.x > 0. && t.x < bgg.w) {\n        float t_osc = 0.5*(TIME_H+TIME_L)+TIME_T;\n        float h_l = 0.5*TIME_L/t_osc;\n        float h_h = (0.5*TIME_L+TIME_T)/t_osc;\n        float osc = smoothstep(0., 1., (clamp(abs(mod(iTime, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n        float SCATTER_FACTOR = mix(0.002, 0.02, osc);\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec3 n = randnorm(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6), SCATTER_FACTOR);\n            // reflection\n            vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, nr), 5.);\n            vec3 rdr = reflect(rd, nr);\n            vec3 reflcol = background(ro, rdr).xyz;\n            \n            // refraction, absorption and internal reflection\n            vec3 rd_refr = refract(rd, nr, 1./IOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            vec3 ro_refr = ro;\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                \n                vec3 ni2, no2;\n                vec2 tout = box(ro_refr, rd_refr, BOXDIMS, ni2, no2);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                ro_refr = ro_refr + tout.y * rd_refr;\n                vec3 rd_refr_out = refract(rd_refr, -no2, IOR);\n\n                float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rd_refr_out, no2), 5.);\n                vec3 reps = ro_refr;\n                reps.z = max(reps.z, -0.999);            \n            \trd_refr = reflect(rd_refr, -no2);\n                transmission *= pow(ABSORPTION_RATE, vec3(tout.y));\n            \tinsidecol += accum * (1.-fresnel2) * background(reps, rd_refr_out).xyz * transmission;\n                if (fresnel2 < 0.05) break;\n                accum *= fresnel2;\n            }    \n            \n            \n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(bgg.xyz, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 369, 394, 394, 502], [504, 504, 575, 575, 1007], [1009, 1009, 1071, 1071, 1336], [1338, 1338, 1362, 1362, 1441], [1443, 1480, 1521, 1521, 2579], [2581, 2581, 2629, 2629, 2792], [2794, 2794, 2851, 2851, 5747]], "test": "untested"}
{"id": "3sySDz", "name": "Op--SDF-", "author": "jorge2017a1", "description": "Op--SDF-", "tags": ["opsdf"], "likes": 1, "viewed": 56, "published": "Public", "date": "1573744611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1--*---------nov-14-2019\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n\n\n//Coordinate positioning of each shape\nfloat GetDist(vec3 p) {\t\n\n \t\n    float planeDist = p.y;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,0.5,5.0),vec3(1.5,1.5,0.5));\n    float bx2 = sdBox (p-vec3(0.,0.5,5.0),vec3(0.3,0.5,1.0));\n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n    float tri1 = sdTriPrism (p-vec3(4.5,0.2,6),vec2(3.1,1.2));\n    float bx3 = sdBox (p-vec3(4.5,0.2,6.0),vec3(0.5,1.5,1.5));\n    \n    \n    float sp2 = sdSphere (p-vec3(-5.0,0.0,-4.0), 1.8);\n    float bx4 = sdBox (p-vec3(-5.0,1.2,6.0),vec3(0.5,1.5,3.5));\n    \n    float dif1, dif2, dif3;\n    \n    \n    d=1000.0;\n    d=min(d,planeDist);\n    dif1=differenceSDF(bx1,bx2);\n    dif1=differenceSDF(dif1,sp1);\n    \n    d=min(d, dif1);\n    \n    //intersectSDF\n    //unionSDF\n    //differenceSDF\n    \n    dif2=differenceSDF(tri1,bx3);\n  \t\n    dif3=differenceSDF(sp2,bx4);\n    \n    \n    \n    d = min(d,dif2);\n    d = min(d,dif3);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos1 = vec3(1, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(0, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\n\nfloat GetLightv3(vec3 p) {\n    vec3 lightPos1 = vec3(-1, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(2, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    \n    vec3 lightPos3 = vec3(-2.5, 5.5, -5.5);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos3.xy += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l3 = normalize(lightPos3-p);\n    vec3 n3 = GetNormal(p);\n    \n    float dif3 = clamp(dot(n3, l3), 0., 1.);\n    float d3 = RayMarch(p+n3*SURF_DIST*2., l3);\n    if(d3<length(lightPos3-p)) dif3 *= .1;\n    \n    \n    return (dif1+dif2+dif3)/3.0;\n}\n\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n    \n    vec3 lightPos1 = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    vec3 lightPos2 =lpos;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(0.0, cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n    //vec3 ro = vec3(0, 1.0, 0);\n    \n    vec3 ro = vec3(4.0+4.0*cos(iTime), 2.5, -4.0);\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n    \n    //\n    float d = RayMarch(ro, rd);\n    //vec3 p;\n    \n    //vec3 p = (ro + rd * d )+texture(iChannel0, uv).x;\n    vec3 p = (ro + rd * d );\n    \n    //float dif = GetLight(p);\n    float dif2= GetLightv2(p);\n    \n\n    col = vec3(dif2);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sySDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 127, 160, 160, 225], [230, 248, 284, 284, 353], [354, 369, 400, 400, 550], [551, 571, 607, 607, 694], [695, 711, 743, 771, 832], [836, 886, 932, 932, 964], [966, 966, 1008, 1008, 1040], [1042, 1042, 1089, 1089, 1122], [1127, 1166, 1189, 1189, 2101], [2103, 2103, 2137, 2137, 2371], [2373, 2373, 2397, 2397, 2629], [2631, 2631, 2655, 2655, 3039], [3044, 3044, 3070, 3070, 3871], [3874, 3874, 3900, 3900, 5106], [5110, 5110, 5148, 5148, 5931], [5933, 5933, 5990, 5990, 6566]], "test": "untested"}
{"id": "3sySRK", "name": "CineShader Lava", "author": "edankwan", "description": "Simple ray marching template. View this shader at [url]https://cineshader.com/view/3sySRK[/url]", "tags": ["cineshader"], "likes": 124, "viewed": 106489, "published": "Public API", "date": "1574356401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sySRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]], "test": "untested"}
{"id": "3sySWm", "name": "Strange Crystal 2", "author": "ShnitzelKiller", "description": "Trying more stuff with hybrid raytracing/raymarching", "tags": ["raytracing", "raymarching", "reflection", "refraction"], "likes": 11, "viewed": 307, "published": "Public API", "date": "1574131392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(1., 1., 1.)\n\n#define ABSORPTION_RATE vec3(0.7, 0.5, 0.5)\n#define IOR 1.33\n#define SCATTER_FACTOR 0.02\n#define SAMPLES 25\n#define REFLECTIONS 4\n#define RAYMARCH_STEPS 15\n#define RAYMARCH_TOL 0.005\n\n#define TIME_T 2.\n#define TIME_H 2.\n#define TIME_L 10.\n\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return -1.;\n    if (entering) {\n    \tnn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    } else {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nfloat boxsdf(in vec3 ro, in vec3 r) {\n    vec3 b = abs(ro) - r;\n    float d = max(b.x, max(b.y, b.z));\n    d += 0.005 * (1.+sin(50.*length(ro) - 2.*iTime));\n    return d;\n}\n\nvec3 boxgrad(in vec3 ro, in vec3 r) {\n    vec2 diff = vec2(RAYMARCH_TOL, 0.);\n    float dx = boxsdf(ro + diff.xyy, r) - boxsdf(ro - diff.xyy, r);\n    float dy = boxsdf(ro + diff.yxy, r) - boxsdf(ro - diff.yxy, r);\n    float dz = boxsdf(ro + diff.yyx, r) - boxsdf(ro - diff.yyx, r);\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat hybridbox(in vec3 ro, in vec3 rd, in vec3 r, out vec3 n, in bool entering) {\n    float t = box(ro, rd, r, n, entering);\n    if (t > 0.) {\n        for (int i=0; i<RAYMARCH_STEPS; i++) {\n            float dist = boxsdf(ro + t*rd, r);\n            t += (entering ? dist : -dist);\n            if (dist < RAYMARCH_TOL) {\n                n = boxgrad(ro + t*rd, r);\n                return t;\n            }\n        }\n    }\n    return -1.;\n}\n\nvec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return vec2(-1.);\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    float tout = -pd + tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return vec2(tin, tout);\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\n//raytrace the exterior surroundings\nvec3 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    if (t < 0.) return bgcol(rd);\n    vec2 uv = ro.xy+t*rd.xy;\n    if (max(abs(uv.x), abs(uv.y)) > 8.) return bgcol(rd);\n    vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n    float aofac = smoothstep(-0.5, 1., length(abs(uv)-min(abs(uv), vec2(0.75))));\n    return mix(vec3(0.2), vec3(1.), min(checkers.x,checkers.y)) * aofac;\n}\n\n//raytrace the insides\nvec3 insides(in vec3 ro, in vec3 rd, in float INNERRAD, in mat2 rot, out float tout) {\n    vec3 ni;\n    vec2 t = sphere(ro, rd, INNERRAD, ni);\n    vec3 ro2 = ro + t.x * rd;\n    // shading/texture\n    vec2 checkers = step(mod(rot * ro2.xy, vec2(0.25)), vec2(0.01));\n    vec3 tex = mix(vec3(1.), vec3(0., 0.7, 0.), abs(checkers.x-checkers.y));\n    float fac = -ni.z;\n    \n    //inner background\n    vec3 n;\n    float tb = box(ro, rd, vec3(INNERRAD), n, false);\n    vec3 rob = ro + tb * rd;\n    vec3 checkersb = abs(mod(rob.xyz, vec3(0.5))-0.25)*4.;\n    vec3 texb = mix(vec3(0., 0., 1.), vec3(0.), step(0.25, abs(abs(checkersb.x-checkersb.y)-checkersb.z)));\n    tout = mix(tb, t.x, step(0., t.x));\n    return mix(mix(vec3(0.5), texb, step(0., tb)) * 0.5, tex * fac, step(0., t.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t_osc = 0.5*(TIME_H+TIME_L)+TIME_T;\n    float h_l = 0.5*TIME_L/t_osc;\n    float h_h = (0.5*TIME_L+TIME_T)/t_osc;\n    float osc = smoothstep(0., 1., (clamp(abs(mod(iTime, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n    float INNERRAD = mix(0.5, 1.5, osc);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni;\n    float t = hybridbox(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    if (t > 0.) {\n        float ang = -iTime * 0.33;\n    \tfloat c = cos(ang);\n    \tfloat s = sin(ang);\n    \tmat2 rot = mat2(c, -s, s, c);\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec2 theta = rand2d(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6));\n            theta *= vec2(2.*PI, SCATTER_FACTOR*PI);\n            vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n            // reflection\n            vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n            vec3 rdr = reflect(rd, nr);\n            vec3 reflcol = background(ro, rdr);\n            \n            // refraction & insides\n            \n            //vec3 rd2 = rd.yzx * ni.x + rd.zxy * ni.y + rd.xyz * ni.z;\n            \n            vec3 rd2 = refract(rd, nr, 1./IOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            vec3 no2 = ni;\n            vec3 ro_refr = ro;\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                float tb;\n                //no2 = -no2;\n                vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n                vec3 eye2 = vec3(coords2, -max(INNERRAD, 1.));\n                vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n                rd2trans.z = -rd2trans.z;\n                vec3 internalcol = insides(eye2, rd2trans, INNERRAD, rot, tb);\n                if (tb > 0.) {\n                    //terminate at interior geometry\n                    insidecol += accum * internalcol * transmission * pow(ABSORPTION_RATE, vec3(tb));\n\t\t\t\t\tbreak;\n                } else {\n                    //compute contribution of the light leaked from the environment through this bounce\n                    float tout = hybridbox(ro_refr, rd2, BOXDIMS, no2, false);\n                    no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                    vec3 rout = ro_refr + tout * rd2;\n                    vec3 rdout = refract(rd2, -no2, IOR);\n                    float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rdout, no2), 5.);\n                    rd2 = reflect(rd2, -no2);\n                    \n                    ro_refr = rout;\n                    ro_refr.z = max(ro_refr.z, -0.999);\n\n                    transmission *= pow(ABSORPTION_RATE, vec3(tout));\n                    insidecol += accum * (1.-fresnel2) * background(ro_refr, rdout) * transmission;\n                    if (fresnel2 < 0.1) break;\n                    accum *= fresnel2;\n                }\n            }\n            \n            // background\n            \n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, nr), 5.);\n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(background(eye, rd), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sySWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 391, 391, 499], [501, 501, 575, 575, 1051], [1053, 1053, 1090, 1090, 1225], [1227, 1227, 1264, 1264, 1550], [1552, 1552, 1634, 1634, 1989], [1991, 1991, 2053, 2053, 2318], [2320, 2320, 2344, 2344, 2423], [2425, 2462, 2503, 2503, 2939], [2941, 2964, 3050, 3050, 3744], [3746, 3746, 3803, 3803, 7740]], "test": "untested"}
{"id": "3sySzK", "name": "\tRaymarching [6] Materials", "author": "camelcoder", "description": "Raymarching", "tags": ["raymarching"], "likes": 5, "viewed": 233, "published": "Public", "date": "1574364682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/**\n * SDF's from:\n * http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n **/\n\nfloat sd_sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat sd_box(vec3 p, vec3 s) {\n\tvec3 d = abs(p) - s;\n\treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nmat2 op_rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k)\n{\n    float h = max(k - abs(a - b),0.0);\n    return max(a, b) + h * h * 0.25 / k;\n}\n\n\nvec2 map(vec3 pos)\n{\n\n    float s = 0.75;\n\n    // create floor\n    float d = pos.y;\n    float m = 2.0;\n\n    pos.xz *= op_rotate(iMouse.x / iResolution.x * 8.0);\n    \n\n    pos.y += 0.54;\n\n\tfloat prevd = d;\n\n    { // Base\n    vec3 p = pos - vec3(0, s, 0);\n    d = min(d, sd_box(p, s * vec3(1.75, 0.20, 0.5)) - s * 0.1);\n\td = min(d, sd_box(p, s * vec3(2.0, 0.20, 0.5)) - s * 0.05);\n\n    p.x -= s * 2.15;\n    d = smax(d, -sd_sphere(p, s * 0.12), 0.01);\n    }\n    if (d < prevd)\n        m = 3.0;\n    prevd = d;\n    \n    { // Cap\n    vec3 p = pos - s * vec3(-1.25, 1, 0);\n\tfloat q = sd_box(p, s * vec3(1.75, 0.20, 0.5)) - s * 0.1;\n\n    p = pos - s * vec3(0.1, 1, 0);\n    q = max(q, -sd_box(p, s * vec3(2, 1, 1)));\n    d = min(d, q);\n    }\n\n    { // Clip\n        vec3 p = pos - s * vec3(-1.3, 1.5, 0);\n\t    d = min(d, sd_box(p, s * vec3(0.9, 0.06, 0.25)) - s * 0.02);\n        p -= s * vec3(-1.3, -0.08, 0.0);\n        p.xy *= op_rotate(-0.2);\n\t    d = min(d, sd_box(p, s * vec3(0.4,0.06, 0.25)) - s * 0.02);\n\t\n    }\n    if (d < prevd)\n        m = 4.0;\n    prevd = d;\n\n    \n    return vec2(d, m);\n}\n\n\nvec3 calc_normal(vec3 p)\n{\n    vec2 e = vec2(0.00005, 0.0);\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x));\n}\nvec2 cast_ray(vec3 ro, vec3 rd)\n{\n    float m = -1.0;\n    float total = 0.0;\n    for (int i = 0; i < 200; ++i) {\n        vec3 pos = ro + total * rd;\n        \n        vec2 dist = map(pos);\n\t    m = dist.y;\n        \n        if (dist.x < 0.001) break; // to close\n        total += dist.x;\n        if (total > 20.0) { // to far\n            total *= -1.0;\n            break;\n        }\n    }\n    return vec2(total, m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    fragCoord *= 2.0;\n\tvec2 p = (fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 2.0, -4.5); // ray origin\n    vec3 rd = normalize(vec3(p + vec2(0, -0.75), 2.0)); // ray direction\n    \n    vec3 col = vec3(0.6, 0.7, 0.8) - 0.4 * rd.y; // sky\n    col = mix(col, vec3(0.75, 0.8, 0.85), exp(-13.0 * rd.y)); // horizon\n   \n    vec2 res = cast_ray(ro, rd);\n    float total = res.x;\n    \n    if (total > 0.0) {\n        vec3 pos = ro + total * rd;\n        vec3 norm = calc_normal(pos);\n        \n        vec3 mat = vec3(0.18); \n        if (res.y > 3.5) {\n            mat = vec3(0.007, 0.007, 0.007);\n        } else if (res.y > 2.5) {\n            mat = 0.3 * vec3(0.8, 1.0, 0.00);\n        } else if (res.y > 1.5) {\n            mat = texture(iChannel0, pos.xz * 0.1).xyz * 0.2;\n            mat.r *= 1.1;\n        }\n        \n        // dot(a, b) -> how aligned are a and b\n        vec3 sun = normalize(vec3(sin(iTime * 0.1), 0.4, cos(iTime * 0.1)));\n        float sun_dif = clamp(dot(norm, sun), 0.0, 1.0);\n        // step(a, b) -> if a < b then 0 else 1\n        float sun_sha = step(cast_ray(pos + norm * 0.001, sun).x, 0.0);\n        col = mat * vec3(7.0, 4.5, 3.0) * sun_dif * sun_sha;\n        \n        \n        // Blueish sky light from above\n        float sky_dif = clamp(0.5 + 0.5 * dot(norm, vec3(0, 1, 0)), 0.0, 1.0);\n        col += mat * vec3(0.5, 0.8, 0.9) * sky_dif;\n        \n        // Remove blacks, by bouncing light of the ground\n        float bou_dif = clamp(0.5 + 0.5 * dot(norm, vec3(0, -1, 0)), 0.0, 1.0);\n        col += mat * vec3(0.7, 0.3, 0.2) * bou_dif;\n    }\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sySzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 96, 130, 130, 155], [156, 156, 186, 186, 275], [276, 276, 327, 327, 448], [450, 450, 475, 475, 542], [545, 597, 636, 636, 719], [721, 773, 812, 812, 894], [897, 897, 917, 917, 1986], [1989, 1989, 2015, 2015, 2241], [2242, 2242, 2275, 2275, 2656], [2658, 2658, 2715, 2766, 4451]], "test": "untested"}
{"id": "3syXRc", "name": "RayMarchingCircle Complete", "author": "KeeganPillow", "description": "Fixed my raymarching by giving the collision amount an epsilon.", "tags": ["2d", "raymarch", "shadow"], "likes": 0, "viewed": 84, "published": "Public", "date": "1574617373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITS 256\n#define CIRCLE_RAD_MOD 50.0\n#define NEAR_THRESH 15.0\n#define COLLIDE_THRESH 0.001\n#define DEPTH_STEP_SIZE 1.0\n#define SHADOW_FALL 1.0\n//Finds the distance to a given circle\nfloat distToCirc(vec2 point, vec2 centerCirc, float radius)\n{\n    float dist = length(point - centerCirc);\n    \n    dist -= radius;\n    \n    if (dist < 0.0)\n    {\n        dist = 0.0;\n    }\n    \n   return dist;\n}\n\n//Finds the distance to a given circle\nvec2 closestToCirc(vec2 point, vec2 centerCirc, float radius)\n{\n    return normalize(centerCirc - point) * distToCirc(point, centerCirc, radius);\n}\n\nfloat SampleDepth(vec2 normedDir, vec2 start, float maxDepth, vec2 obj, float radius)\n{\n    //Logic\n    float dist;\n    \n    //Output\n    float depth = 0.0;\n\n    //Has hit\n    for (int i = 0; i < MAXITS; ++i)\n    {\n        //Find distance to nearest object from camera.\n        dist = distToCirc(obj, start, radius);\n        \n        if (dist > COLLIDE_THRESH)\n        {\n            depth = (radius * 2.0);\n            return depth;\n        }\n        if (depth > maxDepth)\n        {\n          return maxDepth;\n        }\n        \n        //Move in direction of raycast.\n        start += normedDir * DEPTH_STEP_SIZE;\n\n        //Add to the depth\n        depth += DEPTH_STEP_SIZE;\n    } //Repeat until distance covered, or collided.\n    return depth;\n}\n\n//Raymarching:\nfloat rayMarching (vec2 CamPos, vec2 pixPos, vec2 obj, float radius)\n{\n    //Logic\n    float dist = 0.0;\n    float totalDist = 0.0;\n    bool hit = false;\n    bool near = false;\n    vec2 Pos = CamPos;\n    \n    //Massage inputs\n    vec2 dirToPix = normalize(pixPos - Pos);\n    float distToCam = length(pixPos - Pos);\n    \n    //Output\n    float depth = 0.0;\n    \n    //Constants\n    const float depthStepSize = 1.0;\n    \n    //Stores the previous distance.\n    float prevDist = 1000.0f;\n    \n    vec2 closestPoint;\n    float distToClosest;\n    \n    //Loop\n    for (int i = 0; i < MAXITS; ++i)\n    {\n    \n        //Find distance to nearest object from camera.\n        dist = distToCirc(obj, Pos, radius);\n        \n        //If the object is hit, sample its depth\n        if (dist <= COLLIDE_THRESH) \n        {\n            return SampleDepth(dirToPix,\n                               Pos,\n                               length(Pos - pixPos),\n                               obj, \n                               radius);\n        }\n        \n        //Otherwise,\n         //Move in direction of raycast.\n         Pos += dirToPix * dist;\n         //Add to the total distance\n         totalDist += dist;\n            \n          //Find closest point for soft-shadows if close enough\n        if (dist < NEAR_THRESH)\n          {\n            near = true;\n          }\n        \n        if (totalDist >= distToCam)\n        {\n            \n            if (near && distToCam > (length(obj - CamPos)))\n            {\n                float dotted = dot(normalize((obj - CamPos)), dirToPix);\n                //depth = (radius * 2.0) * pow(dotted, SHADOW_FALL);\n                \n            }\n            break;\n        }\n        \n        prevDist = dist;\n    } //Repeat until distance covered, or collided.\n    \n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n  vec2 res = iResolution.xy;\n  vec2 mouse = iMouse.xy;\n    \n  //Object\n  vec2 obj = vec2(res.x / 2.0 + sin(iTime) * 20.0, res.y / 2.0);\n      \n  //Main loop:\n\n  //Camera is the mouse position.\n  vec2 camPos = mouse;\n  float radius = min(0.0, sin(iTime)) + CIRCLE_RAD_MOD;\n    \n    //Raymarch to pixel from cam position. \n  float depth = rayMarching(camPos, fragCoord, obj, radius);\n    \n  //Normalize depth\n  depth /= (radius * 2.0);\n  \n  float depthColor = 1.0 - depth;\n    \n  //Check if no object was hit\n  if (depth == 0.0)\n      {\n          \n          fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      }\n  else\n      {\n          fragColor = vec4(depthColor,depthColor,depthColor, 1.0);\n      }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 192, 253, 253, 403], [405, 444, 507, 507, 591], [593, 593, 680, 692, 1341], [1343, 1358, 1428, 1440, 3163], [3165, 3165, 3222, 3222, 3917]], "test": "untested"}
{"id": "3syXRV", "name": "A moving mandelbrot fractal", "author": "Cewein", "description": "A simple mandelbrut factal, made with raymarching!\nthe color is fog based!", "tags": ["mandelbrut"], "likes": 6, "viewed": 464, "published": "Public API", "date": "1574379347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCHING_STEP 128\n\n/////\n// SDF Operation function\n/////\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n/////\n// Scene and primitive SDF function\n/////\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\n#define Scale 2.\n#define iteration 15\n#define Power (7.+ sin(iTime/3.) * 5.)\n#define Bailout 5.\n\nfloat DE(vec3 pos) {\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < iteration ; i++) {\n        r = length(z);\n        if (r>Bailout) break;\n        \n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        \n        // scale and rotate the point\n        float zr = pow( r,Power);\n        theta = theta*Power;\n        phi = phi*Power;\n        \n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n    }\n    return (0.5*log(r)*r/dr);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n\n  \n    float res = DE(samplePoint);\n    //res += sdPlane(-0.5, vec4(0.,1.,0.,1.));\n    return res;\n   \n}\n\n\n/////\n// Ray function\n/////\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget, float fov)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 0.5 / tan(radians(fov)/ 2.0);\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y * 0.5 / tan(radians(fov)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n/////\n// Marching function\n/////\n\nfloat march(vec3 pos, vec3 direction, float start, float end, inout int i)\n{\n    float depth = start;\n    for(i = 0; i < MARCHING_STEP; i++)\n    {\n        float dist =  sceneSDF(pos + direction * depth);\n        if(dist < 0.0001f)\n        {\n            //return depth;\n            break;\n        }\n        depth += dist;\n        if(depth >= end)\n            return end;\n    }\n    return depth;\n}\n\n\n/////\n// Main function\n/////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 at = vec3(0, 0, 0);\n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 pos = vec3(cos(iTime/10.) * 1.75 ,sin(iTime/15.),sin(iTime/10.) * 1.75);\n    \n    int i = 0;\n    \n    vec3 dir = getCameraRayDir(uv, pos, at, 50.f);\n    \n    float dist = march(pos, dir, 0.f,200.f, i);\n    vec3 col = vec3(dist);\n    \n    if((dist - 200.f) > 0.001f)\n    {\n        col = vec3(0.0529, 0.0808, 0.0922);\n    }\n    else\n    {\n        col = vec3(dist*0.4); \n        col = vec3(0.75 + sin(iTime/10.), 0.515, 0.053 + cos(iTime/10.)) * float(i)/float(MARCHING_STEP);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 67, 102, 102, 153], [155, 204, 239, 239, 279], [283, 283, 308, 308, 326], [425, 425, 445, 445, 1088], [1090, 1090, 1124, 1124, 1230], [1233, 1262, 1333, 1417, 1755], [1757, 1757, 1808, 1808, 1934], [1936, 1936, 1982, 1982, 2108], [2110, 2144, 2220, 2220, 2539], [2542, 2572, 2629, 2629, 3233]], "test": "untested"}
{"id": "3syXRz", "name": "DIFF VIZ", "author": "cqann", "description": "A differential equation visualization", "tags": ["dfferential"], "likes": 4, "viewed": 230, "published": "Public API", "date": "1573220930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat xmin = -5.0;\n\tfloat xmax = 5.0;\n\tfloat ymin = -5.0;\n\tfloat ymax = 5.0;\n    vec2 pos = fragCoord.xy / iResolution.xy;\n\tfloat x = (pos.x)*(xmax-xmin)+xmin;\n\tfloat y = (pos.y)*(ymax-ymin)+ymin;\n\tvec2 gr = vec2(x,y);\n    \n    float flT = float(iFrame);\n    float k  = flT*0.05;\n    \n\tfloat dy = log(cos(k*sin(y-x))/sin(k*cos(x+y)) + x*x );\n   \n\tfloat angle = -atan(dy);\n\tfloat hue = (angle+1.570796)/(3.1415962);\n\tvec3 hsb = vec3(hue,1.0,1.0);\n\tvec3 rgb = hsv2rgb(hsb);\n  \tfragColor = vec4(vec3(rgb), 1.0);\n}\n\n//(sin(x+k)-sqrt(abs(cos(x-k))))/tan(x*y)\n//cosh(sin(x+y-3.0*sin(k)))*sin(3.0*cos(k)-x+y) CIRCLE SHIft\n//max(sin(k)*cos(4.0*(x+y)),cos(k)*sin(4.0*x))\n//y*cos(x-k)-x*tan(k)+x*y*x\n//max(y*cos(x-k),max(-x*cos(k),sin(x*y*x)))\n//1.0/cos(x+k) + y*sin(x)\n//y*sin(x)+sin(x*y)*x*cos(k)\n//log(cos(k*sin(y-x))/sin(k*cos(x+y)) + x*x )\n//cos(k)*tan(cos(k*sin(y-x))/sin(k*cos(x+y)) + x*x )", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 250, 250, 765]], "test": "untested"}
{"id": "3syXzV", "name": "Planet Jet and Black Hole", "author": "JohnShadow", "description": "A planet named \"Jet\" and black hole I made for fun FULL SCREEN for best effect.", "tags": ["simulation", "space", "planet", "blackhole"], "likes": 6, "viewed": 260, "published": "Public", "date": "1574397639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float G = 6.67408e-11;\nconst float mass = 1.0e10;\nconst vec3 bhpos = vec3(0, 0, 0); \nconst float planetRadius = 4.0;\nconst vec3 planetPosition = vec3(0, 0, 20.0);\nconst float sdc = 300.0;\nconst float hsdc = 150.0;\nconst float bhrad = 2.0 * G * mass;\n\nstruct RayHit\n{\n    vec3 pos;\n    float dist;\n};\n\n\n// Noise 3D\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n// SDFS\nfloat sphere(vec3 x, vec3 c, float r)\n{\n    return length(x-c)-r;             \n}\nfloat sdDisc( vec3 position, vec3 n, float r )\n{\n    position = abs(position);\n    float dl = length(position) - r;\n\tfloat d = dot(position, n);\n\treturn max(dl, d);\n}\n\n// Xy axis rotation\nvec3 xzRotate(vec3 position, float theta)\n{\n    float dx = position.x * cos(theta) - position.z * sin(theta);\n    float dz = position.x * sin(theta) + position.z * cos(theta);\n\treturn vec3(dx, position.y, dz);\n}\n\n// Planet \"Jet\"\nfloat map(vec3 position)\n{\n\tfloat theta = iTime * 0.25;\n\tposition = xzRotate(position, theta);\n    vec3 spos = position - planetPosition;\n    \n\tfloat s1 = (fbm(position) + fbm(position*2.0) * 0.25) * 0.75;\n    return sphere(spos, vec3(0), planetRadius) + s1;\n}\nfloat getao (vec3 pos, vec3 normal)\n{\n\treturn clamp(map(pos+normal*0.2)/0.2, 0.0, 1.0);\n}\nvec3 getnormal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\n\n\n// Blackhole (BH)\nfloat blackhole(vec3 position)\n{\n    return distance(position, bhpos) - 1.0;\n}\nvec3 holefeild (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( blackhole(p + vec3(eps, 0, 0) ) - blackhole(p - vec3(eps, 0, 0)),\n \t  blackhole(p + vec3(0, eps, 0) ) - blackhole(p - vec3(0, eps, 0)),\n\t  blackhole(p + vec3(0, 0, eps) ) - blackhole(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat calcGrav(float r, float m)\n{\n\treturn G * m/(r * r);\n}\n\n// Ray march\nRayHit marchDisc(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori;\n\tfor(int i = 0; i < 250; ++i)\n    {\n        float bh = blackhole(pos); //get bh distance\n        if(bh <= bhrad) //check if we are under the schwarzchildradius\n            return RayHit(vec3(1.0), 0.0);\n\t\tvec3 bhdir = holefeild(pos); //get the normal in space towards the BH\n        float grav = calcGrav(bh, mass); //calc the gavitation at a point\n        \n        float dd = sdDisc(pos, vec3(0, 1.0, 0), 14.0); //make acceleration disc\n        \n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * min((bh - bhrad), dd); //get new position with BH gravity bending\n        if(dd < 0.001) //check if we hit \n            return RayHit(pos, dd);\n        if(dd > 120.0)\n            return RayHit(vec3(0.0), 0.0);\n    }\n    return RayHit(vec3(0.0), 0.0);\n}\nRayHit marchPlanet(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori;\n    float dmin = 1.0;\n\tfor(int i = 0; i < 250; ++i)\n    {\n        float bh = blackhole(pos); //get bh distance\n        if(bh <= bhrad) //check if we are under the schwarzchildradius\n            return RayHit(vec3(1.0, dmin, float(i)), 0.0);\n\t\tvec3 bhdir = holefeild(pos); //get the normal in space towards the BH\n        float grav = calcGrav(bh, mass); //calc the gavitation at a point\n        \n        float cs = map(pos);\n        dmin = min(dmin, cs);\n        \n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * min((bh - bhrad), cs); //get new position with BH gravity bending\n        if(cs < 0.001) //check if we hit \n            return RayHit(pos, cs);\n        if(cs > 120.0)\n            return RayHit(vec3(0.0, dmin, float(i)), 0.0);\n    }\n    return RayHit(vec3(0.0), 0.0);\n}\nRayHit bhwarp(vec3 ori, vec3 dir)\n{\n    vec3 pos = ori;\n\tfor(int i = 0; i < 10; ++i)\n    {\n        float bh = blackhole(pos); //get bh distance\n        if(bh <= bhrad) //check if we are under the schwarzchildradius\n            return RayHit(vec3(0.0), bh);\n\t\tvec3 bhdir = holefeild(pos); //get the normal in space towards the BH\n        float grav = calcGrav(bh, mass); //calc the gavitation at a point\n        \n       \tdir = normalize(dir - bhdir * grav);\n        pos += dir * (bh - bhrad); //get new position with BH gravity bending\n    }\n    return RayHit(dir, 0.0);\n}\n\n// Night sky\nfloat nightsky(vec3 dir)\n{\n    return noise(dir * 500.0) > 0.9 ? 0.65 : 0.0;\n}\n\n//ray marching view stuff\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(40.0, 10.0, 40.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec3 normal, color;\n\t\n    // Ray march the scene\n    RayHit hitDisc = marchDisc(eye, worldDir);\n\tRayHit hitPlanet = marchPlanet(eye, worldDir);\n\tif(hitDisc.dist != 0.0)\n\t{\n\t\tfloat distinv = 1.0/(length(hitDisc.pos.xz) - 0.5); \n\t\tfloat distinv2 = 2.0 * distinv * distinv * distinv;\n\t\tRayHit warp = bhwarp(eye, worldDir);\n\t\tvec3 sky = vec3(nightsky(warp.pos));\n\t\tvec3 cdist = vec3(sdc, hsdc, hsdc);\n\t\tvec3 disc = abs(fbm(xzRotate(hitDisc.pos, iTime * distinv * 5.0))) * cdist;\n\t\tcolor = disc * distinv2 + sky * (1.0-distinv2);\n\t}\n\tif(hitPlanet.dist != 0.0)\n\t{\n\t\tfloat theta = iTime * 0.25;\n\t\tvec3 position = xzRotate(planetPosition, theta);\n\t\tvec3 planetPos = position - planetPosition;\n\t\tfloat angle = dot(planetPos, vec3(1.0, 0.0, -1.0));\n\t\tnormal = getnormal(hitPlanet.pos);\n\t\tfloat ao = max(getao(hitPlanet.pos, normal), 0.1);\n\t\tif(angle > 0.0) //dumb transparancy ordering\n\t\t\tcolor += 0.8*vec3(1.0, 1.0, 1.0) * ao * max(dot(normal, normalize(bhpos - hitPlanet.pos)), 0.2);\n\t\telse\n\t\t\tcolor = 0.8*vec3(1.0, 1.0, 1.0) * ao * max(dot(normal, normalize(bhpos - hitPlanet.pos)), 0.2);\n\t}\n    if(hitDisc.dist == 0.0 && hitPlanet.dist == 0.0 && hitPlanet.pos.x == 0.0)\n    {\n        RayHit warp = bhwarp(eye, worldDir);\n        color = vec3(nightsky(warp.pos));\n    }\n    if(hitPlanet.pos.y < 1.0 || hitPlanet.dist != 0.0) //fake atmosphere\n    {\n        float dist = hitPlanet.dist != 0.0 ? abs(hitPlanet.dist) : hitPlanet.pos.y;\n        dist = 0.5*(2.0-(dist+1.0));\n        float redshift = 0.5*(2.0-((hitPlanet.pos.z/250.0)+1.0));\n        redshift *= redshift * 2.0;\n        if(hitPlanet.dist != 0.0)\n            color += 0.2*vec3(0.25, dist*(redshift * 1.5), dist*redshift * 1.5);\n        else\n        \tcolor += 0.7*vec3(dist*(1.0-redshift), dist*(redshift * 1.5), dist*redshift * 1.5);\n    }\n\t// Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 427, 450, 450, 489], [491, 491, 517, 517, 922], [924, 924, 945, 945, 1086], [1088, 1096, 1135, 1135, 1176], [1177, 1177, 1225, 1225, 1343], [1345, 1365, 1408, 1408, 1576], [1578, 1594, 1620, 1620, 1854], [1855, 1855, 1892, 1892, 1944], [1945, 1945, 1970, 1970, 2206], [2209, 2227, 2259, 2259, 2305], [2306, 2306, 2331, 2331, 2603], [2604, 2604, 2638, 2638, 2663], [2665, 2678, 2716, 2716, 3502], [3503, 3503, 3543, 3543, 4362], [4363, 4363, 4398, 4398, 4934], [4936, 4949, 4975, 4975, 5027], [5029, 5055, 5120, 5120, 5252], [5253, 5253, 5302, 5337, 5563], [5566, 5566, 5623, 5623, 7716]], "test": "untested"}
{"id": "3tBGRm", "name": "UI noise halo", "author": "magician0809", "description": "UI noise halo", "tags": ["noise", "ui", "halo"], "likes": 7, "viewed": 2031, "published": "Public", "date": "1575012468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx);\n}\nfloat snoise3(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - K2);\n    vec3 d2 = d0 - (i2 - K1);\n    vec3 d3 = d0 - 0.5;\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n\n\n#define time iTime\nconst vec3 color1 = vec3(0.611765, 0.262745, 0.996078);\nconst vec3 color2 = vec3(0.298039, 0.760784, 0.913725);\nconst vec3 color3 = vec3(0.062745, 0.078431, 0.600000);\nconst float innerRadius = 0.6;\nconst float outerRadius = 1.0;\nconst float noiseScale = 0.65;\n\nfloat light1(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * attenuation);\n}\nfloat light2(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * dist * attenuation);\n}\n\nvoid draw( out vec4 _FragColor, in vec2 vUv )\n{\n    vec2 uv = vUv;\n    float ang = atan(uv.y, uv.x);\n    float len = length(uv);\n    float v0, v1, v2, v3, cl;\n    float r0, d0, n0;\n    float r, d;\n    \n    // ring\n    n0 = snoise3( vec3(uv * noiseScale, time * 0.5) ) * 0.5 + 0.5;\n    r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n    d0 = distance(uv, r0 / len * uv);\n    v0 = light1(1.0, 10.0, d0);\n    v0 *= smoothstep(r0 * 1.05, r0, len);\n    cl = cos(ang + time * 2.0) * 0.5 + 0.5;\n    \n    // high light\n    float a = time * -1.0;\n    vec2 pos = vec2(cos(a), sin(a)) * r0;\n    d = distance(uv, pos);\n    v1 = light2(1.5, 5.0, d);\n    v1 *= light1(1.0, 50.0 , d0);\n    \n    // back ring\n    v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n    //v2 *= smoothstep(innerRadius, mix(r0, innerRadius, n0 * 0.5), len);\n    \n    // hole\n    v3 = smoothstep(innerRadius, innerRadius * 1.1, len);\n    \n    // color\n    vec3 c = mix(color1, color2, cl);\n    vec4 col;\n    col.rgb = mix(color3, c, v0);\n    col.rgb += vec3(v1);\n    col.a = max(v0, max(v1, v2)) * v3;\n    col = clamp(col, 0.0, 1.0);\n    \n    //gl_FragColor = col;\n    _FragColor = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    vec4 col;\n    draw(col, uv);\n\n    vec3 bg = vec3(0.0);\n\n    fragColor.rgb = mix(bg, col.rgb, col.a); //normal\n    //fragColor.rgb = col.rgb * col.a + bg; //add\n    //fragColor.rgb = col.rgb * col.a * bg; //mul\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 179], [180, 180, 203, 203, 838], [1123, 1123, 1185, 1185, 1238], [1239, 1239, 1301, 1301, 1361], [1363, 1363, 1410, 1410, 2546], [2548, 2548, 2605, 2605, 2885]], "test": "untested"}
{"id": "4dGBzw", "name": "agnes", "author": "hclarke", "description": "it's a flame\n\nbezier modified from here: https://www.shadertoy.com/view/ltXSDB", "tags": ["2d"], "likes": 3, "viewed": 65, "published": "Public", "date": "1572985686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//color\nconst mat3 YUV_to_RGB = mat3(\n         1.0,1.0,1.0,\n        0.0,-0.39465,2.03211,\n        1.13983,-0.58060,0.0);\n\nconst mat3 XYZ_to_RGB = mat3(\n    3.2406, -0.9689, 0.0557,\n    -1.5372, 1.8758, -0.2040,\n    -0.4986, 0.0415, 1.0570);\n\nconst vec3 D65_XYZ = vec3(.95047, 1.0, 1.08883);\nconst vec3 D65_xyY = vec3(0.31271, 0.32902, 1.0);\nconst vec3 D65_Yuv = vec3(1.0, 0.19784, 0.46834);\nconst vec3 ONE = vec3(1.0,1.0,1.0);\n\nvec3 XYZ_to_xyY(vec3 XYZ) {\n \tfloat inv_sum = 1.0/dot(XYZ,ONE);\n    return XYZ.xyy * vec3(inv_sum,inv_sum,1.0);\n}\n\nvec3 xyY_to_XYZ(vec3 xyY) {\n \tfloat s = xyY.z/xyY.y;\n    float z = 1.0-dot(vec2(1.0,1.0), xyY.xy);\n    return vec3(xyY.x, xyY.z, z) * vec3(s,1.0,s);\n}\n\nvec3 LUV_to_XYZ(vec3 LUV) {\n    vec2 uv = LUV.yz / (13.0*LUV.x) + D65_Yuv.yz;\n    float Y = LUV.x > 8.0 ? \n        D65_Yuv.x * pow((LUV.x+16.0)/116.0, 3.0) : \n    \tLUV.x * D65_Yuv.x * 0.00110705645;\n    float X = Y * 9.0 * uv.x / (4.0*uv.y);\n    float Z = Y * (12.0-3.0*uv.x-20.0*uv.y)/(4.0*uv.y);\n    return vec3(X,Y,Z);\n}\nvec3 LUV_to_RGB(vec3 LUV) {\n \treturn XYZ_to_RGB * LUV_to_XYZ(LUV);   \n}\nvec3 HCL_to_LUV(vec3 HCL) {\n \tvec2 uv = vec2(cos(HCL.x), sin(HCL.x)) * HCL.y;\n    return vec3(HCL.z, uv);\n}\n\n//other stuff\nvec2 lmin(vec2 a, vec2 b) {\n    if(abs(a.x-b.x) < 0.0000000001) {\n      return a.y > b.y ? a : b;\n    }\n    \n    return a.x < b.x ? a : b;\n}\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the distance to the curve, and signed distance to unclamped curve\nvec2 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = solveCubic(k.x, k.y, k.z);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    float unclamped = dis * signBezier(A, B, C, p);\n    \n    t = clamp(t, 0.0, 1.0);\n    pos = A + (c + b*t.x)*t.x;\n    dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    \n    return vec2(dis, unclamped);\n}\n\nvec3 sdFlame(vec2 pos) {\n    \n    if(dot(pos,pos) > 4.0) return vec3(length(pos)-2.0, 0.0, 0.0);\n    \n    float yd = clamp((pos.y + 1.0)* 0.5,0.0, 1.0);\n    \n    pos.x += sin((iTime+yd*0.1)*30.0) * yd * 0.06;\n    pos.x += sin((iTime+yd*0.3)*23.12) * yd * 0.01;\n    pos.y += sin((iTime+yd*0.1 + 1.0)*30.0) * yd * 0.03;\n    pos.x = -abs(pos.x);\n    float w = 0.3;\n    float b = -0.7;\n    float m = -0.3;\n    float t = 1.0;\n    vec2 p0 = vec2(0.0, -1.0);\n    vec2 p1 = vec2(-w, m);\n    vec2 p2 = vec2(-0.2, 0.5);\n    vec2 p3 = vec2(0.0, t);\n    vec2 c0 = vec2(-w, b);\n    vec2 c1 = vec2(-w, -0.2);\n    vec2 c2 = p2 + (p2-c1) * 0.5;\n    vec2 sd = vec2(1000.0, 0.0);\n    sd = lmin(sd, sdBezier(p0, c0, p1, pos));\n    sd = lmin(sd, sdBezier(p1, c1, p2, pos));\n    sd = lmin(sd, sdBezier(p2, c2, p3, pos));\n    \n    float d = sd.x * -sign(sd.y);\n    float id = 1.0;\n    float grad = sd.x*5.0 + (1.-yd) * 4.0;\n    return vec3(d, id, grad);\n}\n\nvec3 sdMidPetal(vec2 pos) {\n    \n    if(dot(pos,pos) > 16.0) return vec3(length(pos)-4.0, 0.0, 0.0);\n    pos.x = abs(pos.x);\n    float w = 0.5;\n    float m = -0.6;\n\tvec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(w, m);\n    vec2 p2 = vec2(0.05, m*2.0);\n    vec2 c0 = vec2(w+0.3, -0.2);\n    vec2 c1 = vec2(0.05, m-0.3);\n    \n    vec2 sd = vec2(1000.0, 0.0);\n    sd = lmin(sd, sdBezier(p0, c0, p1, pos));\n    sd = lmin(sd, sdBezier(p1, c1, p2, pos));\n    \n    float d = sd.x * -sign(sd.y);\n    float id = 2.0;\n    float grad = sqrt(sd.x / w * 1.0);\n    return vec3(d, id, grad);\n}\n\nvec3 sdSidePetal(vec2 pos) {\n    if(dot(pos,pos) > 4.0) return vec3(length(pos)-2.0, 0.0, 0.0);\n    pos.x = abs(pos.x);\n    float w = 0.8;\n    float m = -0.65;\n    float t = 0.1;\n\tvec2 p0 = vec2(0.1, m);\n    vec2 p1 = vec2(w, t);\n    vec2 p2 = vec2(w*1.5, t-0.4);\n    vec2 p3 = vec2(w, m-0.2);\n    vec2 p4 = vec2(0.01, m-0.6);\n    vec2 c0 = vec2(w-0.1, t-0.1);\n    vec2 c1 = vec2(w*1.5, t);\n    vec2 c2 = vec2(w*1.5-0.1, m-0.1);\n    vec2 c3 = vec2(0.1, m-0.2);\n    \n    vec2 sd = vec2(1000.0, 0.0);\n    sd = lmin(sd, sdBezier(p0, c0, p1, pos));\n    sd = lmin(sd, sdBezier(p1, c1, p2, pos));\n    sd = lmin(sd, sdBezier(p2, c2, p3, pos));\n    sd = lmin(sd, sdBezier(p3, c3, p4, pos));\n    \n    float d = sd.x * -sign(sd.y);\n    float id = 2.0;\n    float grad = sqrt(sd.x / w * 2.0);\n    return vec3(d, id, grad);\n}\n\nvec3 scene_min(vec3 a, vec3 b) {\n \treturn a.x < b.x ? a : b;   \n}\n\nvec3 scene_overlay(vec3 a, vec3 b) {\n \treturn b.x < 0.0 ? b : a;   \n}\n\nvec3 sdFlower(vec2 pos) {\n    float h = (pos.y + 4.0) / 5.0;\n    pos.x += sin(iTime*4.0) * 0.04 * h;\n\tvec3 sd = sdFlame(pos);\n    vec2 offset = vec2(0., -0.7);\n    sd = scene_overlay(sd, sdSidePetal(pos-offset));\n    sd = scene_overlay(sd, sdMidPetal(pos-offset));\n    return sd;\n}\n\n\n\nvec3[2] blues = vec3[2](\n  vec3(34.95159658785063, -10.59331738558413, -132.52535570823173),\n  vec3(20.661436824954606, -6.625557844192029, -69.5615969239433)  \n);\n\nvec3[2] golds = vec3[2](\n  vec3(83.81308085207128, 36.40725312134432, 87.9260601163343),\n  vec3(97.9969146434447, 3.902148804569638, 38.55489135455387)\n\n);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 sd = sdFlower(uv * 2.0);\n\t\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if(sd.x >= 0.0) {\n        col = LUV_to_RGB(mix(blues[0], blues[1], min(1., length(uv * 0.1))));\n    }\n    else if(sd.y == 1.0) {\n        vec3 a = HCL_to_LUV(vec3(1.269591657661457,66.76847476254702,91.24781583307198));\n        \n        vec3 b = HCL_to_LUV(vec3(1.21570998919011,32.3252321015046,94.58142126830768));\n        col = LUV_to_RGB(mix(a,b, max(0.,sd.z)));\n    }\n    else if(sd.y == 2.0) {\n     \t\n        col = LUV_to_RGB(mix(golds[0], golds[1], clamp(sd.z, 0.0, 1.0)));  \n    }\n    \n    \n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 428, 455, 455, 541], [543, 543, 570, 570, 693], [695, 695, 722, 722, 1018], [1019, 1019, 1046, 1046, 1090], [1091, 1091, 1118, 1118, 1198], [1200, 1214, 1241, 1241, 1354], [1356, 1419, 1460, 1460, 1526], [1528, 1598, 1648, 1648, 1999], [2001, 2035, 2079, 2079, 2592], [2594, 2668, 2715, 2715, 3487], [3489, 3489, 3513, 3513, 4422], [4424, 4424, 4451, 4451, 4999], [5001, 5001, 5029, 5029, 5813], [5815, 5815, 5847, 5847, 5880], [5882, 5882, 5918, 5918, 5951], [5953, 5953, 5978, 5978, 6234], [6559, 6559, 6616, 6616, 7380]], "test": "untested"}
{"id": "lldBWM", "name": "CIELAB sRGB DCI-P3 Comparison 3D", "author": "Tynach", "description": "Based on my other 3D spinning shader, but now it compares two different colorspaces in the perceptually uniform CIE L*a*b* color space.", "tags": ["color", "space", "rgb", "lab", "spinning", "colorspace", "cielab", "srgb", "cie"], "likes": 7, "viewed": 391, "published": "Public", "date": "1574645791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/******************************************************************************\n * Scroll to just above the functions to change the parameters used to draw   *\n * the diagram                                                                *\n ******************************************************************************/\n\nprecision highp float;\nprecision highp int;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define white(x, y)\\\n\tvec3(x, y, (1.0 - x - y))\n\n#define Bright(w)\\\n\t((w)/w.y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*Bright(space.white)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n// Converts from L*a*b* to nonlinear XYZ; calling\n// toLinear() afterward completes the conversion\nconst mat3 frLab = mat3(\n\t1, 0, 0,\n\t1, 1, 1,\n\t0, 0, 1\n)*mat3(\n\t1.16/500.0, 0, 0,\n\t0, 1.0/100.0, 0,\n\t0, 0, -1.16/200.0\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// Never-popular and antiquated 'HDTV' primaries based mostly on 1953 NTSC\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC and Rec. 601 (525 lines)\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primariesAdobe = Primaries(\n\t0.64, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = white(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = vec3(1.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = white(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = white(0.312713, 0.329016);\n\n// Standard illuminant D65 according to sRGB, Rec. 709, and other display standards\nconst vec3 whiteD65S = white(0.3127, 0.3290);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = white(0.34567, 0.35850);\n\n// Standard illuminant D50 according to ICC standards (they specify a hex value\n// for the 16-bit integer representation, as well as a specific way to decode it,\n// so I did some math to figure out exactly the values they expect)\n//const vec3 whiteD50I = white(31595.0/91393.0, 32768.0/91393.0);\n\n// Floating point representation of ICC D50\nconst vec3 whiteD50I = white(3214.0/9297.0, 10000.0/27891.0);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = white(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = white(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. This is the only difference between sRGB and Rec. 709\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65S, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65S, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65S, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65S, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65S, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Adobe RGB monitors\nconst rgb_space AdobeRgb = rgb_space(primariesAdobe, whiteD65S, gam22);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65S, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65S, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries v1, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries v2, balanced against equal energy white point\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/**********************************************************\n *                                                        *\n *  Change these to adjust various conversion parameters  *\n *                                                        *\n **********************************************************/\n\n// Display colorspace\nconst rgb_space disp = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// Colorspaces to compare\nconst rgb_space space1 = Srgb;\nconst rgb_space space2 = DciP3D65;\n\n// Color Appearance Model (or 'reference') white point\nconst vec3 whiteCam = whiteD50I;\n\n// camMat is an easy way to set the transformation matrix, but both\n// toCam and frCam are what should be used, as they're adapted to the\n// color appearance model white point\nconst mat3 camMat = CIECAM97_1;\nconst mat3 toCam = inverse(diag(camMat*Bright(whiteCam)))*camMat;\nconst mat3 frCam = inverse(camMat)*diag(camMat*Bright(whiteCam));\n\n\n/*\n * Conversion Functions\n */\n\n// Converts display RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\n\tcolor = mix(higher, lower, cutoff);\n\n\treturn color;\n}\n\n// Turns colors that are out-of-gamut into gray\nvec4 gamutTrim(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, color.b));\n\tfloat high = max(color.r, max(color.g, color.b));\n\n\tif (low < 0.0 || high > 1.0) {\n\t\tcolor.a = 0.0;\n\t}\n\n\treturn color;\n}\n\n// Scales a color to the closest in-gamut representation of that color\nvec4 gamutScale(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\n\treturn color;\n}\n\n// Converts one RGB space to another\nvec4 convert(vec4 color, rgb_space from, rgb_space to)\n{\n\t// Modify XYZ↔RGB matrices to perform whitepoint adaptation using a\n\t// wrong Von Kries transformation matrix (CIECAM97_1 has nonlinearities\n\t// in the 'S' cone that is not accounted for in ICC profiles)\n\tmat3 toXyz = frCam*diag((toCam*Bright(whiteCam))/(toCam*Bright(from.white)))*toCam*rgbToXyz(from);\n\tmat3 toRgb = xyzToRgb(to)*frCam*diag((toCam*Bright(to.white))/(toCam*Bright(whiteCam)))*toCam;\n\t// This might be easier to understand (← shows matrix multiplication):\n\t// toRgb = XYZtoRGB←LMStoXYZ←diag(whiteDispInLMS/whiteCamInLMS)←XYZtoLMS\n\t// toXyz = LMStoXYZ←diag(whiteCamInLMS/whiteDispInLMS)←XYZtoLMS←RGBtoXYZ\n\n\t// Convert to XYZ and grab luminosity value\n\tcolor.rgb = toXyz*color.rgb;\n\tfloat luma = color.y;\n\n\t// Convert back into RGB and scale to nearest in-gamut color with\n\t// the same luminosity\n\tcolor.rgb = toRgb*color.rgb;\n\tcolor = gamutScale(color, luma);\n\n\treturn color;\n}\n\n// Converts from XYZ to RGB, with white point adaptation\nvec4 rgb(vec4 color, const rgb_space space)\n{\n\t// Same as in convert(), but we only need to go to RGB\n\tmat3 toRgb = xyzToRgb(space)*frCam*diag((toCam*Bright(space.white))/(toCam*Bright(whiteCam)))*toCam;\n\n\tfloat luma = color.y;\n\n\t// Convert from XYZ to RGB, then remove out-of-gamut colors\n\tcolor.rgb = toRgb*color.xyz;\n\tcolor = gamutTrim(color, luma);\n\n\treturn color;\n}\n\n// From Hornet's shader here: https://www.shadertoy.com/view/4sB3zz\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\n\n// Perspective parameters\n// Chosen so that RGB #FF00FF barely touches the boundaries while spinning\n#define FAR (4.73513408)\n#define NEAR (3.26486592)\n#define FOV (2.0*atan(0.5))\n//#define RIGHT (1.25)\n//#define TOP (1.25)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n\tfloat minRes = min(iResolution.x, iResolution.y);\n\tvec2 ab = (coord - iResolution.xy/2.0)/minRes;\n\n\tivec2 texRes = textureSize(iChannel0, 0);\n\n\t// Color chosen to match the background of this image:\n\t// https://en.wikipedia.org/wiki/File:Lab_color_space.png\n\tfragColor = toLinear(vec4(vec3(104.0/255.0), 1), disp.trc);\n\n\tvec4 color;\n\tvec2 angle;\n\n\tif (iMouse.z == 0.0) {\n\t\tangle = vec2(0, iTime*PI*2.0/5.0);\n\t} else {\n\t\tangle = vec2(-1, 1)*(iMouse.yx - (iResolution.yx - minRes)/2.0)/minRes*PI*2.0 - PI;\n\t}\n\n\tvec2 sinAng = sin(angle);\n\tvec2 cosAng = cos(angle);\n\n\tmat4 movement = mat4( // Swap .y and .z\n\t\t1, 0, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 0, 1\n\t)*inverse(mat4( /* View matrix */\n\t\t1.0/tan(FOV/2.0), 0, 0, 0,\n\t\t0, 1.0/tan(FOV/2.0), 0, 0,\n\t\t0, 0, -FAR/(FAR - NEAR), -1,\n\t\t0, 0, -FAR*NEAR/(FAR - NEAR), 0\n\t)*mat4( /* World matrix */\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, -4, 1\n\t)*mat4( /* Model matrix */\n\t\t1, 0, 0, 0,\n\t\t0, cosAng.x, sinAng.x, 0,\n\t\t0, -sinAng.x, cosAng.x, 0,\n\t\t0, 0, 0, 1\n\t)*mat4( // ↕ Rotation matrices\n\t\tcosAng.y, 0, -sinAng.y, 0,\n\t\t0, 1, 0, 0,\n\t\tsinAng.y, 0, cosAng.y, 0,\n\t\t0, 0, 0, 1\n\t)*mat4( // Scale matrix\n\t\t1.0/128.0, 0, 0, 0,\n\t\t0, 1.0/128.0, 0, 0,\n\t\t0, 0, 1.0/128.0, 0,\n\t\t0, 0, 0, 1\n\t)*mat4( // Translation matrix\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, -50, 1\n\t));\n\n\t// Steps are counted backwards, because we're going from further away to\n\t// closer to the camera; the last sample to give us a color is what we want\n\t// to show.\n\n\t// We could instead quit early, but for this shader I wanted two gamuts to\n\t// compare two gamuts - and lower their opacity where they don't overlap\n\tconst float steps = 120.0;\n\n\tfor (float i = 0.0; i < steps; ++i) {\n\t\tcolor = vec4(ab, 1.0 - i/(steps - 0.5), 1);\n\t\tcolor.z += (texelFetch(iChannel0, ivec2(coord.xy) % texRes, 0).r - 0.5)/(steps - 0.5);\n\t\t//color.z += (hash12n(gl_FragCoord.xy) - 0.5)/steps;\n\n\t\tcolor = movement*color;\n\t\tcolor /= color.w;\n\t\tcolor.a = 1.0;\n\n\t\t// Convert to XYZ\n\t\tcolor.xyz = frLab*color.xyz;\n\t\tcolor = toLinear(color, gamLab);\n\t\tcolor.xyz *= Bright(whiteCam);\n\n\t\t// Convert to RGB and compare colors\n\t\tfloat alpha1 = rgb(color, space1).a/2.0;\n\t\tfloat alpha2 = rgb(color, space2).a/2.0;\n\t\tcolor = gamutScale(vec4(rgb(color, disp).rgb, pow(alpha1 + alpha2, 3.0)), color.y);\n\n\t\t// Mix with current pixel value\n\t\tfragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n\t}\n\n\tfragColor = toGamma(fragColor, disp.trc);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12010, 12065, 12112, 12112, 12330], [12332, 12385, 12431, 12431, 12650], [12652, 12700, 12740, 12740, 12912], [12914, 12985, 13026, 13026, 13340], [13342, 13379, 13435, 13642, 14345], [14347, 14404, 14449, 14505, 14774], [14776, 14875, 14898, 14898, 15026], [15209, 15255, 15306, 15306, 17747]], "test": "untested"}
{"id": "ltlBW8", "name": "Voronoi Traversal w/ Refraction", "author": "glk7", "description": "Traversal of a 2d voronoi grid with refraction. Code and visuals are based on the regular grid analogous shader [url=https://www.shadertoy.com/view/ltXBz7] 2D Grid Traversal w/ Refraction [/url].\n\nThe mouse can be used to point the ray.", "tags": ["voronoi", "refraction", "traversal"], "likes": 23, "viewed": 442, "published": "Public API", "date": "1572879419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float w = 2.;\n\nconst float PI = 3.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//From http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    vec2 ml = vec2(0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(r-mr,r-mr)>0.00001 ) {\n            vec2 l = normalize(r-mr);\n            float d = dot( 0.5*(mr+r), l );\n            if (md > d) { \n        \t\tmd = d;\n                ml = l;\n            }\n        }           \n    }\n\n    return vec3(md, n+mg);\n}\n\n//From https://www.shadertoy.com/view/MtyGWK\nvoid voronoi_s(in vec2 x, inout vec2 n,  inout vec2 f, \n                          inout vec2 mg, inout vec2 mr) {\n\n    n = floor(x);\n    f = fract(x);\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2(n + g);\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md) {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }  \n}\n\nvec3 voronoi_n(vec2 rd, vec2 n,  vec2 f, \n               inout vec2 mg, inout vec2 mr) {\n    float md = 1e5;\n    vec2 cmg = mg;\n    vec2 cmr = mr;\n    vec2 ml = vec2(0.0);\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = cmg + vec2(i,j);\n\t\tvec2 o = hash2(n + g);\n\t\tvec2 r = g + o - f;\n\n    \tvec2 l = r-cmr;\n        \n        if(dot(rd, l) > 1e-5) {\n            float d = dot(0.5*(cmr+r), l)/dot(rd, l);\n            \n            if (d < md) {\n                md = d;\n                mg = g;\n                mr = r;\n                ml = l;\n            }\n        }   \n    }\n    \n    return vec3(md, normalize(ml));\n}\n\nfloat grid(vec2 uv, float e, float v) \n{\n    return smoothstep(0.0, w*e, v);\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(0.07, 0.07 + w*e, length(uv - p)); \n}\n\nfloat segment(vec2 uv, float e, vec2 d, vec2 p, float l) \n{\n    return max(1.0 - min(step(0.0, dot(d, uv - p)), \n                         step(0.0, dot(d, p + d*l - uv))),\n   \t\t       smoothstep(0.015, 0.015 + w*e, abs(dot(vec2(-d.y, d.x), p - uv))));\n}\n\nfloat refract_index(vec2 c) \n{\n    c -= vec2(7.0, 6.0);\n    const float r = 3.0;  \n    return dot(c, c) > r*r ? 1.0 : 2.7;\n}\n\nvec2 traversal(vec2 uv, float e, vec2 uvv, vec2 ro, vec2 rd) \n{   \n    vec2 v = vec2(1.0);\n    \n    vec2 i = vec2(0.0), f = vec2(0.0);\n    vec2 mg = vec2(0.0), mr = vec2(0.0);\n    \n    voronoi_s(ro, i, f, mg, mr);\n    \n    float refri = refract_index(i + mg);    \n    \n    vec2 p = ro;\n    for( int s = 32; s > 0; --s ){\n        \n        //Draw cell and point.\n       \tvec2 c = abs(i + mg - uvv);\n        float cc = 1.0 - step(0.0, -(c.x + c.y));\n        v = min(v, vec2(point(uv, e, p), cc));\n\n        vec2 pmg = mg;\n    \tvec3 vor = voronoi_n(rd, i, f, mg, mr);\n        \n        v.x = min(v.x, segment(uv, e, rd, p, vor.x)); // Draw segment.\n        \n       \tp += rd*vor.x;\n        \n        //Refraction part.\n        #if 1\n        float nrefri = refract_index(i + mg);\n        \n        vec2 reflrd = reflect(rd, -vor.yz);\n        rd = refract(rd, -vor.yz, refri/nrefri);\n        \n        float t = step(0.0, -dot(rd, rd));\n       \trefri = mix(nrefri, refri, t);\n        rd += reflrd*t;\n        mg = mix(mg, pmg, t);\n        #endif\n        \n        vec2 o = mr - mg + f;\n        vec2 ip = floor(p);\n        f = fract(p);\n        \n        mg += i - ip;\n        mr = mg + o - f;\n        i = ip;\n    }\n    \n    v.x = min(v.x, point(uv, e, p)); \n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 25.0 / iResolution.x;\n    vec2 offset = vec2(5.0, 3.0);\n\tvec2 uv = fragCoord.xy*e - offset;\n    \n    vec2 ro = vec2(3.8, 1.2);\n    \n    vec2 rd = (length(iMouse.xy) < 10.0)\n        \t? normalize(vec2(1.0, sin(iTime*0.2) + 1.5))\n    \t\t: normalize(iMouse.xy*e - offset - ro);\n    \n    \n    vec3 v = voronoi(uv);\n    float ri = refract_index(v.yz);\n    vec3 c = vec3(1.0 - step(0.0, 1.0 - ri), 0.2, \n                  step(0.0, 1.0 - ri)) + 0.3;\n    \n    vec2 t = traversal(uv, e, v.yz, ro, rd);\n    c += (1.0 - t.y) * 0.2;\n    c *= t.x;\n    c *= grid(uv, e, v.x);\n    \n\tfragColor = vec4(pow(clamp(c, 0.0, 1.0), vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlBW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 164, 186, 217, 334], [336, 412, 439, 439, 1531], [1533, 1578, 1691, 1691, 2033], [2035, 2035, 2123, 2123, 2688], [2690, 2690, 2730, 2730, 2768], [2770, 2770, 2810, 2810, 2867], [2869, 2869, 2928, 2928, 3122], [3124, 3124, 3154, 3154, 3248], [3250, 3250, 3313, 3313, 4509], [4511, 4511, 4568, 4568, 5213]], "test": "untested"}
{"id": "td3Gzs", "name": "Ray Marching Testorino", "author": "anirul", "description": "Simple raymarching example based on youtube https://www.youtube.com/watch?v=PGtv-dBi2wE&t=\nI actually calculated normal in a different way.", "tags": ["raymarching"], "likes": 0, "viewed": 67, "published": "Public", "date": "1574092185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MIN_DIST .01\n#define MAX_DIST 100.\n\n// Get the distance and normal to the surface \n// (if the distance is < MIN_DIST in w).\nvec4 GetDist(vec3 pos) \n{\n    vec4 sphere = vec4(0., 1., 6., 1.);\n    float distSphere = length(pos - sphere.xyz) - sphere.w;\n    float distPlane = pos.y;\n    if (distSphere < distPlane) \n        return vec4(normalize(pos - sphere.xyz), distSphere);\n    else \n        return vec4(0, 1, 0, distPlane);\n}\n\n// Get the new distance and the normal to the surface.\n// (if the dirance is < MIN_DIST in w).\nvec4 RayMarching(vec3 ray_origin, vec3 ray_direction) \n{\n    float dist0 = 0.0f;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ray_origin + ray_direction * dist0;\n        vec4 normal_dist = GetDist(p);\n        dist0 += normal_dist.w;\n        if (normal_dist.w < MIN_DIST || dist0 > MAX_DIST) \n            return vec4(normal_dist.xyz, dist0);\n    }\n    return vec4(0, 1, 0, dist0);\n}\n\n// Calculate the shade float.\nfloat GetLight(vec3 pos, vec3 normal) \n{\n    vec3 light_pos = vec3(0, 5, 6);\n    light_pos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 light_normal = normalize(light_pos - pos);\n    float light_value = dot(normal, light_normal);\n    float dist_light = \n        RayMarching(pos + normal * MIN_DIST * 2., light_normal).w;\n    if (dist_light < length(light_pos - pos)) light_value *= .1;\n    return light_value;\n}\n\n// Main entry point.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 ray_origin = vec3(0, 1, 0);\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 1));\n    vec4 result = RayMarching(ray_origin, ray_direction);\n    vec3 pos = ray_origin + ray_direction * result.w;\n    float shade = GetLight(pos, result.xyz);\n    vec3 color = vec3(shade);\n\n    // Output to screen\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3Gzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 154, 179, 179, 456], [458, 553, 609, 609, 948], [950, 980, 1020, 1020, 1396], [1398, 1419, 1476, 1476, 1881]], "test": "untested"}
{"id": "td3XRr", "name": "Cda_Test025_Tdh6.glsl", "author": "Cephalopodium", "description": "Tdh Part6 Tdh Rain on Window Shader from YT tutorial (The Art of Code )", "tags": ["tutorial", "glass", "rain", "window", "nightdrive"], "likes": 8, "viewed": 156, "published": "Public", "date": "1574495960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: Cda_Test025_Tdh6.glsl\n// Tag: Glass, rain, window, night-drive, tutorial\n// Desc: Tdh Part6 Tdh Rain on Window Shader from YT tutorial (The Art of Code )\n// Tutorial by Martijn Steinruken aka BigWings 2017\n// uncomment DROP_DEBUG for clarity regarding render buffer not used \n// if weak device comment #define HIGH_QUALITY \n// Music https://SoundCloud.com/zefora/cheyah Mr Bill - Cheyah (Zefora's Digital Rain Mix)\n// 33:00 100q% Thru video The Drive Home - Part 6 of 6 - Rain on Window\n\n/* Logistic fn() eg. Try y=2/(1+pow(E,-6.*(x-0.5))), replacing values with vars \ngives y=maxY/(1+pow(E,-slope*(x - xMidPoint))). Eg #2 for y range 0 to 1, \nwith 3 xy coords (-1,0), (0,0.5) and (1,1) : Use yMax=1, slope ~= 6, xMidPoint = 0; \nAlso yMax=1, slope ~=12, xMidPoint =0: gives coords (-0.5,0) and (0,0.5) and (0.5,1) */\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(a,b,edge,t) S(a-edge,a+edge,t)*S(b+edge,b-edge,t)\n#define sat(x) clamp(x,0.,1.)\n#define streetLightCol vec3(1.,.7,.3)\n#define headLightCol vec3(.8,.8,1.)\n#define tailLightCol vec3(1.,.1,.1)\n#define HIGH_QUALITY \n#define CAM_SHAKE 1.\n#define LANE_BIAS .5\n#define RAIN\n// #define DROP_DEBUG\n#define E 2.7182818\n\n/* vec3 ro,rd; */\n\n// Basically fract(sin(t*largeA)*largeB) gives pseudo rnd()\nfloat N(float t) { \n  return fract(sin(t*10234.324)*123423.23512); \n} \n// returns a random colour given a time value \nvec4 N14(float t) { \n  return fract(sin(t*vec4(123.,1024.,3456.,9564.))*vec4(6547.,345.,8799.,1564.)); \n} \n\n/* CDA different rnd() fns */\nfloat NR(float t) { \n  return fract(sin(t*8234.324)*623423.352); \n} \nfloat NG(float t) { \n  return fract(sin(t*11034.324)*134423.232); \n} \nfloat NB(float t) { \n  return fract(sin(t*9234.324)*273423.517); \n} \n\nfloat logistic(float x,float maxY,float slope,float xMidPoint) {\n   return maxY/(1.+pow(E,-slope*(x - xMidPoint)));\n}\n\n// This is my first structure, Note \";\" after \"}\"\nstruct ray {\n    vec3 o,d; // Def ray with 2 origin and direction vec3's\n};\n    \nray CameraSetup(vec2 uv,vec3 camPos,vec3 la,float zoom) {\n  ray a;                             // define ray \n  a.o = camPos;                      // ray origin set to camera \n  vec3 f = normalize(la-camPos);     // forward \n/* Cross product z of vectors x & y is orthogonal/normal to plane xy with a direction\n   given by the right hand rule.(Eg. Thumb is z vector point out of screen ). */\n  vec3 r = cross(vec3(0,1,0),f);     // right (Cross product)\n  vec3 u = cross(f,r);               // up \n  vec3 c = a.o + f * zoom;           // screen centre\n  vec3 i = c + uv.x * r + uv.y * u;  // intersection pt\n  a.d = normalize(i - a.o);          // ray direction \n  return a;\n}\n\n/* Dot product of 2 vectors a & b with angle c between them is a scalar value, actually \n   the √(a • a) = |a| (the magnitude of vector a). Given P=(a,b) & Q=(c,d) with angle \n   @ between them, then P • Q is ac + bd. The dot product of two normalised vectors,\n   a • b = cos(c), or generally |a||b|cos(c), so to find the angle between them \n   use c= arccos((a • b)/(|a|*|b|)). \n   When vectors are at 90° the • product = 0 as when normalised it represents the \n   amount of a going in direction b, its like projection a onto b,. If c>90° a•b will \n    be -ve indicating opposing directions (or forces) */\n\nvec3 ClosestPt(ray r,vec3 p) {\n    return r.o + max(0.,dot(p-r.o,r.d)) * r.d;\n}\n\nfloat DistRay(ray r, vec3 p) {\n    return length(p-ClosestPt(r,p));\n}\n\n// Bokeh Japanese term that describes out of focus highlights \nfloat Bokeh(ray r, vec3 p, float size, float blur, float pf,float pe, float ssMin ) {   \n    float d = DistRay(r,p);              // define direction\n//  size *= length(p);      // pe=pf=1. stops pts from getting smaller in distance\n    size *= pow(length(p*pf),pe);  // CDA Let's pts enlarge pf=p factor & pe=p exponent         \n    float c = S(size,size*(1.-blur),d);     // define circle around pt p\n    c *= mix(.6,1.,S(size*ssMin,size,d));   // brighten Circumf. when>.8 of radius\n   return c;\n}\n\nvec3 PlaneLights(ray r, float t) {\n    t = -t*10.;  // reverse light direction & increase speed\n    // need to make lights appear alternately from each side \n    float side = step(r.d.x,0.); //*2.+1.;   // if r.d.x -ve side=0 else side =1\n    r.d.x = abs(r.d.x);                  // mirror horizontally to get left side\n//    r.d.y = abs(r.d.y);            //CDA  mirror vertically to get road reflected pts\n    float s = 1./20.;\n    float m = 0.;\n    for (float i=0.;i<1.;i+=s) {\n      float n = N(i);             // *side;\n      if (n>.015) continue; // skip to next plane for 60% of virtual cars \n      for (float q=i;q<i+.25;q+=1./100.) { \n        float ti = fract(t+q+side*s*.5);     // +side*s*.5 shifts lights by half step\n        vec3 p = vec3(2.,2.,100.-(ti*100.));  // def pt,fract resets posn, \n        \n        m += Bokeh(r,p,.01,.1,1.,1.,.88)*pow(ti+(q/50.),5.); // Def Circle,*ti^3 causes dist. fade.  \n   //   m += Bokeh(r,p,.0125,.1,6260.,0.257,.88)*pow(ti+(q/100.),20.); // CDA test lights enlarging A\n   //   m += Bokeh(r,p,.0125,.1,8.,0.65,.88)*pow(ti+(q/100.),20.);    // CDA test lights enlarging B */\n      }\n      float ti = fract(t+side*s*.5); // @ t+side \n      vec3 p = vec3(2.,2.,100.-(ti*100.));  // ti*ti*ti*ti*ti\n   // m += Bokeh(r,p,.015,.1,1.,1.,.88)*pow(ti,10.); // Def Circle,*ti^3 causes dist. fade.   \n      m += Bokeh(r,p,.0125,.1,1.,1.,.88)*ti*3.95;//*ti\n    }\n    return vec3(.3,.3,.99) * m;           // define color jet blue \n}\n\nvec3 StreetLights(ray r, float t) {\n    // need to make lights appear alternately from each side \n    float side = step(r.d.x,0.);         // if r.d.x -ve side=0 else side =1\n    r.d.x = abs(r.d.x);                  // mirror horizontally to get left side\n//    r.d.y = abs(r.d.y);            //CDA  mirror vertically to get road reflected pts\n    float s = 1./10.;\n    float m = 0.;\n    for (float i=0.;i<1.;i+=s) {\n      float ti = fract(t+i+side*s*.5);     // +side*s*.5 shifts lights by half step\n      vec3 p = vec3(2.,2.,100.-(ti*100.));  // def pt,fract resets posn, \n\n      m += Bokeh(r,p,.05,.1,1.,1.,.88)*ti*ti*ti; // Def Circle,*ti^3 causes dist. fade\n/*    m += Bokeh(r,p,.05,.1,6260.,0.257,.88)*ti*ti*ti; // CDA test lights enlarging A\n      m += Bokeh(r,p,.05,.1,8.,0.65,.88)*ti*ti*ti;    // CDA test lights enlarging B */\n    }\n    return vec3 (1.,.7,.3) * m;             // define color sodium lamp\n}\n\nvec3 EnvLights(ray r, float t) {\n    // need to make lights appear alternately from each side \n    float side = step(r.d.x,0.);         // if r.d.x -ve side=0 else side =1\n    r.d.x = abs(r.d.x);                  // mirror horizontally to get left side\n//   r.d.y = abs(r.d.y);            //CDA  mirror vertically to get road reflected pts\n    float s = 1./10.;\n    vec3 c = vec3(0.);       // can't use mask for different colors,so accumulate c\n    for (float i=0.;i<1.;i+=s) {\n      float ti = fract(t+i+side*s*.5);     // +side*s*.5 shifts lights by half step.    \n      vec4 n = N14(i+side*100.);      // Generate random locations based on i & side\n\n      float fade = ti*ti*ti*2.69;                // *ti^3 causes distance fade\n\n      float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;  // 10 * TWO_PI revolutions\n      fade *= occlusion;\n      float x = mix(2.5,10.,n.x);          // x location beyond road \n      float y = mix(0.1,1.5,n.y);          // y locn. from just above ground to 1.5 \n\n      vec3 p = vec3(x,y,50.-(ti*50.));     // def pt,fract resets posn, \n\n      vec3 col = n.wzy;                    // get random color, (blueness ~= height);\n      float envLightSize=NR(sin(i))/40.+.025;     // CDA set light size range .025 to .05\n      c += Bokeh(r,p,envLightSize,.1,1.,1.,.88)*fade*col; // Def Circle\n/*    c += Bokeh(r,p,envLightSize,.1,6260.,0.257,.88)*fade*col; // CDA test lights enlarging A\n      c += Bokeh(r,p,envLightSize,.1,8.,0.65,.88)*fade*col;    // CDA test lights enlarging B */\n    }\n    return c;             //  color\n}\n\nvec3 HeadLights(ray r, float t) {\n    t *=2.;                  // Oncoming traffic twice as frequent as streetlights\n    r.d.x = -r.d.x;          // UK Fix !\n    float w1 = .25;          // Define width of a car\n    float w2 = w1 * 1.2;     // Define width of a car headlight\n\n    float s = 1./30.;        // Car frequency = 30 per sec \n    float m = 0.;            // Mask\n    vec3 bulb;               // CDA defined outside loop mutant car bulb \n\n    for (float i=0.;i<1.;i+=s) {\n      float n = N(i);            // for each car get rnd between 0 and 1\n      if (n>.1) continue;        // skip to next car for 90% of virtual cars \n      bulb = vec3(.9,.9,1.);     // CDA set normal bulb color\n      /* doesn't work as NR(i) fixed only evaluated at compile time ? \n      if (NR(i)<.02) {                    // CDA Probability of mutant bulb \n         bulb = vec3(NR(i),NG(i),NB(i));  // CDA set random bulb color\n      } */\n      float ti = fract(t+i);     // fract() resets Position\n      float z = 100.-(ti*100.);  // Dist along road \n        \n      float fade = ti*ti*ti*ti*ti;  // ti^5 causes dist. fade as light recedes\n      float focus = S(.9,1.,ti); // Step into focus while Dist between .8 and 1.\n      float size = mix(.05,.03,focus);             // reduce size when in focus\n      // defn of pt \"p\" moved inside Bokeh parameters ,\n      m += Bokeh(r,vec3(-1.-w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1a\n      m += Bokeh(r,vec3(-1.+w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 2a\n      m += Bokeh(r,vec3(-1.-w2,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1b\n      m += Bokeh(r,vec3(-1.+w2,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 2b\n\n/*    m += Bokeh(r,vec3(-1.-w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1a\n      m += Bokeh(r,vec3(-1.+w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 2a \n      m += Bokeh(r,vec3(-1.-w2,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1b\n      m += Bokeh(r,vec3(-1.+w2,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 2b */\n\n      float ref = 0.;  // define faint road reflection. Note .9 blur\n      ref += Bokeh(r,vec3(-1.-w2,-.15,z),size*3.,.9,1.,1.,.8)*fade; // Def reflection 1\n      ref += Bokeh(r,vec3(-1.+w2,-.15,z),size*3.,.9,1.,1.,.8)*fade; // Def reflection 2\n \n/*    ref += Bokeh(r,vec3(-1.-w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA ref 1\n      ref += Bokeh(r,vec3(-1.+w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA ref2 */\n\n      m += ref * focus;                            // Add reflection when in focus \n    }\n // return vec3(.9,.9,1.) * m;              // define color blue-white\n    return bulb * m;                        // CDA define bulb color mostly blue-white\n}\n\nvec3 TailLights(ray r, float t) {\n    t /=4.;                  // Overtaken traffic ¼ as frequent as streetlights\n    r.d.x = -r.d.x;          // UK Fix !\n    float w1 = .25;          // Define width of a car\n    float w2 = w1 * 1.2;     // Define width of a car headlight\n\n    float s = 1./15.;        // Car frequency = 15 per sec \n    float m = 0.;            // Mask\n    vec3 bulb;               // CDA defined outside loop - mutant car bulb \n\n    for (float i=0.;i<1.;i+=s) {\n      float n = N(i);            // for each car get rnd between 0 and 1\n      if (n>.5) continue;        // skip to next car for 50% of virtual cars \n      bulb = vec3(1.,.15,.025);    // CDA set normal bulb color RED was (1.,.1,.1)             \n/* Trick : reducing blue from .1 to .03 gives orange blinker eg. Original (1.,.1,.03) - \n  Orange = -25% Green -75% Blue. From Red's Brightness .1 -> .075g .025b, \n  or try .2 -> 0.15g 0.05b halfway = .1125g .0375b */\n\n      /* doesn't work as NR(i) etc fixed, only evaluated at compile time ? \n      if (NR(i)<.02) {                    // CDA Probability of mutant bulb \n         bulb = vec3(NR(i),NG(i),NB(i));  // CDA set random bulb color\n      } */\n      float lane = step(.25,n);  // returns 0 or 1 (as n range is now 0 to .5)\n      float ti = fract(t+i);     // fract resets posn,\n      float z = 100.-(ti*100.);  // dist along road \n      float fade = pow(ti,5.);   // ti^5 causes dist. fade as light recedes\n   //   float fade = ti*ti*ti*ti*ti;  // Not using pow(ti,5) reintroduces BUG\n      float focus = S(.9,1.,ti); // Step into focus while Dist between .9 and 1.\n      float size = mix(.05,.03,focus);      // reduce size when in focus\n      float laneshift = S(1.,.96,ti);       // 1 if far away 0 if close \n      float x = 1.5-(lane*laneshift);       // car position (was -1. for headlights)\n      float tmp3=7.*(lane-.00000001);       // BUG Fix requires var & *..01 Only lane 2\n      float blink = step(0.,sin(t*1000.))*tmp3*step(.796,ti);  // Blinker, off in dist @ .796 was .96\n      // defn of pt \"p\" is now vec3() moved inside Bokeh parameters ,\n      m += Bokeh(r,vec3(x-w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1a\n      m += Bokeh(r,vec3(x+w1,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 2a\n      m += Bokeh(r,vec3(x-w2,.15,z),size,.1,1.,1.,.8)*fade; // Def Circle 1b\n      m += Bokeh(r,vec3(x+w2,.15,z),size,.1,1.,1.,.8)*fade*(1.+blink); // Def Circle 2b\n\n/*    m += Bokeh(r,vec3(x-w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1a\n      m += Bokeh(r,vec3(x+w1,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 2a \n      m += Bokeh(r,vec3(x-w2,.15,z),size,.1,2260.,0.257,.8)*fade; // CDA Circle 1b\n      m += Bokeh(r,vec3(x+w2,.15,z),size,.1,2260.,0.257,.8)*fade*(1.+blink); // CDA Circle 2b */\n\n      float ref = 0.;  // define faint road reflection. Note .9 blur\n      ref += Bokeh(r,vec3(x-w2,-.15,z),size*3.01,.9,1.,1.,.8)*fade; // Def refl 1 BUG Fixed with 3.01\n    //  blink *= 0.0;  // BUG prevented .1 being used\n      float tmp4=(blink-.0000001)*.1;   // Reduce glare by 90%\n      ref += Bokeh(r,vec3(x+w2,-.15,z),size*3.,.9,1.,1.,.8)*fade*(1.+tmp4); // blink);\n      // Def refl2 & blink - Bug *1.0000001 but * 1.00000001 OK\n/*    ref += Bokeh(r,vec3(x-w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA Ref1\n      ref += Bokeh(r,vec3(x+w2,.15,z),size*3.,.1,2260.,0.257,.8)*fade; // CDA Ref2 */\n\n      m += ref * focus;                            // Add reflection when in focus \n    }\n // return vec3(1.,.1,.1) * m;              // define color red\n    return bulb * m;                        // CDA define bulb color mostly Red\n}\n\nvec2 Rain(vec2 uv, float t) {   \n//  vec2 st=uv*10.;     // #1 Rasta flag as ¼'s G,Y,R,Black clockwise from TopLeft\n//  vec2 st=fract(uv*10.);     // #2 makes grid boxes 10 high\n  t *= 40.;               // increase speed of droplets\n    \n  vec2 a = vec2(3.,1.);   // #3 makes boxes 3 * taller \n  vec2 st=uv*a;           // \n    \n  vec2 id=floor(st);\n  st.y +=t*.22;           // Makes entire fame move down, .22 tweak cancels up motion\n  float n = fract(sin(id.x*716.34)*768.34); // noise \n  st.y += n;              // pseudo random #\n  uv.y += n;              //     offsets drops vertically from centre of box \n//  st.x +=n;  // CDA\n//  uv.x +=sin(n*.8*t/19.); // pow(n*.6,2.);   // CDA offsets drops horizontally from centre of box \n\n\n  id = floor(st);      // make box id \n  st = fract(st)-.5;   // #3 within each box uv coords from (0,0) to (1,1),\n                       // #3 -.5 moves origins to centers \n\n  t += fract(sin(id.x*716.34+id.y*1453.7)*768.34)*6.283; // rnd # Time * TWO_PI to \n                     // gives phase difference . \n    \n  float y =-sin(t+sin(t+sin(t)*.5))*.43; // #3 Adds control of vertical posn. of drop \n   // Above modification approximates a saw tooth wave, up quick down slow \n  vec2 p1 = vec2(0.,y);        // #3 .43 above is tweak to prevent drop overlapping its box \n  vec2 o1 = (st-p1)/a;    // #5 define offset 1 \n  float d = length(o1);   // #3 distance to droplet ,/a fixes ellipses \n\n  float m1 = S(.07,.0,d);     // #3 mask for droplet (yellow on black,only RG cols used!)\n\n  vec2 o2 = (fract(uv*a.x*vec2(1.,2.))-.5)/vec2(1.,2.); // #4 Trail of smaller drops,  \n                           // fract=per box,-.5=centred,fn*vec2)/vec2 = more cells  \n  d = length(o2); // dist to drops, \n\n  float m2 = S(.3*(.5-st.y),.0,d)*S(-.1,.1,st.y-p1.y); // #4 mask for smaller droplets \n                              // (.5-st.y) shrinks, * S() prevents trail below drop \n\n//  if (st.x>.46||st.y>.49) m1=1.;    // Debug #3 show vertical & horizontal yellow lines\n \n  return vec2(m1*o1*20.+m2*o2*10.);        // #1& #2 was(st), #3 m1, #4 m\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;                             // moves origin from bottom left to centre\n    uv.x*=iResolution.x/iResolution.y;  // turn ellipse to circle using aspect ratio\n\n    vec2 m = iMouse.xy/iResolution.xy;  // defines m from Mouse to mirror uv.xy coords\n    float t = iTime * (.01+ m.x/5.);   // m.x allows mouse control of playback speed. \n                                       // fixed mouse by adding brackets\n\n    vec3 camPos = vec3(0.6,.2,0);       // camera x position was 0 (now fast lane UK)\n    vec3 la     = vec3(0.6,.2,1);       // look at vec [CDA .9 not .5 4 close overtake]\n//  uv.y += logistic(uv.x,.235,19.,-0.25)*1.0-.23;       // CDA distorted heights \n\n    float rainScale=5.;               // sets drop size, was 3., wee =15. big=.85\n    vec2 rainDistort = Rain(uv*rainScale,t)*.5;    // Add Rain layer 1\n    rainScale=7.;\n    rainDistort += Rain(uv*rainScale,t)*.5;        // Add Rain layer 2\n    \n    uv.x += sin(uv.y*70.)*.005;      // add horizontal wave distortion to scene \n    uv.y += sin(uv.x*117.)*.003;     // add vertical   wave distortion to scene \n\n    ray r = CameraSetup(uv-rainDistort*.5,camPos,la,2.);    // get ray from cam to la\n\n    vec3 col = StreetLights(r,t);\n    col += HeadLights(r,t);\n    col += TailLights(r,t);\n    col += EnvLights(r,t);\n    \n    if (t-float(int(t))>.9) col += PlaneLights(r,t);  // allow 1 in 10 planes to show\n    \n    col += (r.d.y+.25)*vec3(.32,.1,.75);   // add sky gradient\n //   col = vec3(rainDistort,0.);\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);     // draw it\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3XRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1202, 1262, 1280, 1280, 1331], [1333, 1380, 1399, 1399, 1485], [1488, 1518, 1537, 1537, 1585], [1587, 1587, 1606, 1606, 1655], [1657, 1657, 1676, 1676, 1724], [1727, 1727, 1791, 1791, 1844], [1846, 1977, 2034, 2034, 2653], [2655, 3279, 3309, 3309, 3358], [3360, 3360, 3390, 3390, 3429], [3431, 3494, 3579, 3579, 3994], [3996, 3996, 4030, 4030, 5464], [5466, 5466, 5501, 5563, 6382], [6384, 6384, 6416, 6478, 7936], [7938, 7938, 7971, 7971, 10614], [10616, 10616, 10649, 10649, 14224], [14226, 14226, 14255, 14404, 16301], [16303, 16303, 16360, 16410, 18012]], "test": "untested"}
{"id": "tdcSDj", "name": "Wave interference with 2 sources", "author": "linus_yay", "description": "Wave interference with 2 sources", "tags": ["waves"], "likes": 2, "viewed": 181, "published": "Public API", "date": "1572883073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec2 p1, vec2 p2) {\n\treturn sqrt(pow(p1.x - p2.x,2.0) + pow(p1.y - p2.y,2.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2[2] quellen = vec2[2](iMouse.xy, vec2(100.0,100.0));\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    for (int i = 0;i < quellen.length();i++) {\n        float dist = dist(fragCoord, quellen[i]);\n        if (dist < 10.0) {\n            fragColor = vec4(0.0,1.0,0.0,1.0);\n        } else if (dist <= iResolution.x) {\n            fragColor += vec4(0.5,0.2,sin(dist / 5.0 - iTime * 1.5) * 0.5 + 0.5,1.0);\n        }\n    }\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 91], [94, 94, 151, 201, 767]], "test": "untested"}
{"id": "tdcSWl", "name": "Paint Marks Disco Party", "author": "gbunny", "description": "Join the disco party of paint marks that look kind of like colorful kernels of corn.\n(Mouse interaction to make the marks move)", "tags": ["paint", "disco", "corn", "party"], "likes": 3, "viewed": 80, "published": "Public", "date": "1573105693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.14159265359\n\nvec2 rotate2D(vec2 st, float angle){\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    return st;\n}\nvec2 tile(vec2 st, float zoom){\n    st *= zoom;\n    if (mod(st.x, 2.) < 1.){\n        st = vec2(st.y, -st.x);\n    }\n    return fract(st);\n}\n\nfloat proceduralSplatter(vec2 st, float radius, float numCircles){\n    float pct = 0.;\n    st.x -= .5;\n    for (float i = 1.; i < numCircles; i++){\n        st.y -=(.3/ (i+1.));\n        pct +=smoothstep(radius * 1./i, radius * 1./i - .1, length(st));\n    }\n    return pct;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    st.x *= aspect;\n    st += rotate2D(st, PI * .1 * iTime);\n    vec3 color = vec3(sin(iTime / 2.));\n    st += rotate2D(st, PI * .25);\n    vec2 grid2 = tile(st,2.);\n    grid2.y -= .003 * iMouse.y;\n    color = mix(color, vec3(0.2,0.52,0.502 *(iMouse.x * .003)), proceduralSplatter(grid2, .2 , 10.));\n    vec2 grid3 = tile(st, 3.);\n    grid3 -= .1;\n    color = mix(color, vec3(0.6, 0.3, 0.3), proceduralSplatter(grid3, .2 * sin(iTime), 9.));\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 107, 107, 208], [209, 209, 240, 240, 347], [349, 349, 415, 415, 622], [624, 624, 679, 679, 1242]], "test": "untested"}
{"id": "tddSDS", "name": "Proc Gen tutrial", "author": "xdegtyarev", "description": "procgen tutorial", "tags": ["proc"], "likes": 2, "viewed": 48, "published": "Public", "date": "1572812077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void getSkyColor(float x, float y, inout vec3 color) {\n    float h = max(0.0, 1.4 - y - pow(abs(x - 0.5), 3.0));\n    color.r = pow(h, 3.0);\n    color.g = pow(h, 9.0);\n    color.b = 0.3 + pow(max(0.0, h - 0.1), 10.0);\n}\n\nfloat rand(float x){\n    return fract(sin(x)*1000.0);\n}\n\nfloat noise(float x){\n    float i = floor(x);\n    float f = fract(x);\n    return mix(rand(i),rand(i+1.0),f * f * (3.0 - 2.0*f));\n}\n\nfloat terrain(float x){\n    float y = 0.0;\n    for(int oct = 0; oct<10; ++oct){\n        float k = pow(2.0,float(oct));\n        y+=noise(x * k)/k;\n    }\n    return y*0.5;\n}\n\nfloat water(float x){\n    float y = 0.0;\n    y = sin(x*75.0)*0.01 + 0.2;\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2 = vec3(0,0,0);\n\tgetSkyColor(uv.x,uv.y,col2);\n    col = mix(col,col2,sin(uv.x*0.1+0.9));\n    // Output to screen\n    float shift = 0.1 *iTime + 0.2;\n    uv.x += shift;\n    float h = max(water(uv.x), terrain(uv.x));\n    if(uv.y<h) col = vec3(0,0,0);\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 218], [220, 220, 240, 240, 275], [277, 277, 298, 298, 407], [409, 409, 432, 432, 580], [582, 582, 603, 603, 670], [672, 672, 729, 729, 1125]], "test": "untested"}
{"id": "tddXDf", "name": "mitochondria - base", "author": "FabriceNeyret2", "description": "WIP.\nref: https://cdn.the-scientist.com/assets/articleNo/66623/hImg/34228/mitochondria-banner-x.png\nMouse control or click bottom-left for back to auto-rot.", "tags": ["raymarching", "sdf", "short"], "likes": 6, "viewed": 276, "published": "Public API", "date": "1573076611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reusing base ray-marcher https://shadertoy.com/view/XstBWn\n\nfloat K = 4.;\n//#define smin(a,b) pow( pow(a,-K) + pow(b,-K), -1./K ) \n#define ell(v)    length( (v) / vec3(1,2,2) ) \n//#define body(P) min( min(P.x,P.y), min(P.z,P.w))\n//#define body(P) smin( smin(P.x,P.y), smin(P.z,P.w))\n#define rot(a)    mat2(cos(a),-sin(a),sin(a),cos(a) )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime+1.,v0,v1, r,l=1.;\n    vec3  q = iResolution, R,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),      // ray direction\n          p = 30./q, q0;                        // marching point along ray \n    vec2  M = 10.* iMouse.xy / q.xy;\n    mat2  Rx = rot(length(iMouse.xy)<20. ? -t : -M.y ),\n          Ry = rot(length(iMouse.xy)<20. ? -t : M.x );\n    vec4 P;\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.01 ) {\n        q = p,\n        q.xz *= Ry, q.yz *= Rx,                 // camera rotation\n        v0 = v1 = 0.;\n        for (float x = -4.; x <= 2.; x++ ) {    // for each segments\n           //q0 = q-vec3(3.*x,0,0);\n            r = 9., R = 3.*vec3(x,0,sqrt(r*r-x*x)-r);   // vector dist to rotation axis\n            q0 = q - R;                                 // offset\n            q0.xz *= rot(asin(x/r));                    // and rotate\n            l = length(q0)/r;\n            K = 8., v0 += pow( ell(q0), -K );           // inner membrane\n            K = 2., v1 += pow( ell(q0), -K );           // outer membrane\n          //K = 2., v1 += pow( ell(q0)*2.*l, -K );      // (with rot jacobian)\n        }\n        K = 8., v0 = pow(v0, -1./K) - 2.,\n        K = 2., v1 = pow(v1, -1./K) - 2.,\n        v0 = max(v0, -(v0+.15)),  v0 = max(v0, q.y), t = v0,        // thick inner membrane \n        v1 = max(v1, -(v1+.15)),  v1 = max(v1, q.y), t = min(t,v1), // thick outer membrane \n     /* P = vec4( ell(q), ell(q-vec3(3,0,0)), ell(q+vec3(3,0,0)) , ell(q+vec3(6,0,0)) ),\n        K = 8., v = body(P) -2., v = max(v, -(v+.15)),  v = max(v, q.y), t = v,\n        K = 2., v = body(P) -2., v = max(v, -(v+.15)),  v = max(v, q.y), t = min(t,v),\n     */\n       // t = max(t, q.y),\n        p += t*D;                             // step forward = dist to obj\n    }\n    if ( t < .01 )\n        O = t==v1 ? O*vec4(.8,.3,.4,1) + vec4(.2,0,0,0)\n                  : O*vec4(.7,.7,.2,1) + vec4(.4,0,0,0);  // color membranes\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 341, 377, 377, 2307]], "test": "untested"}
{"id": "tddXWl", "name": "Vogel disc", "author": "Wunkolo", "description": "Vogel's method of placing approximately evenly-spaced points equidistantly across the surface of a circle", "tags": ["math"], "likes": 12, "viewed": 465, "published": "Public", "date": "1573170051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265f;\nconst float GoldenAngle = PI * (3.0 - sqrt(5.0));\nconst float PointRadius = 2.0 + 2.0/3.0;\n\nconst vec2 DropShadow = vec2(-0.25, 0.75);\n\nvec2 Vogel(uint sampleIndex, uint samplesCount, float Offset)\n{\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(samplesCount));\n  float theta = float(sampleIndex) * GoldenAngle + Offset;\n  return r * vec2(cos(theta), sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Size = iResolution.y / 2.0;\n    vec2 UV = fragCoord/iResolution.xy;   \n    vec3 Color = mix(vec3(0.75), vec3(0.5), distance(UV,vec2(0.5)));\n    \n    Color = mix(\n        Color,vec3(0.0),\n        smoothstep(PointRadius*2.0, -PointRadius*2.0, abs(Size * 0.90 - distance(fragCoord + DropShadow, iResolution.xy/2.0)))\n    );\n    Color = mix(\n        Color,vec3(1.0),\n        smoothstep(PointRadius*2.0, -PointRadius*2.0, abs(Size * 0.90 - distance(fragCoord, iResolution.xy/2.0)))\n    );\n    \n    UV.x *= iResolution.x / iResolution.y;\n    float Pulse = sin(iTime * 0.0125 * PI * 2.0);\n    uint Samples = uint(1024.0 * Pulse * Pulse);\n    \n    for( uint i = 0u; i < Samples; ++i )\n    {\n        float Phase = float(i) / float(Samples - 1u);\n        vec2 VogelPos =\n            iResolution.xy / 2.0\n            + Vogel(i, Samples, iTime * 0.5)\n            * Size * 0.85;\n        Color = mix(\n            Color,vec3(0.0),\n            smoothstep(PointRadius + 1.0, PointRadius - 1.0, length((fragCoord + DropShadow) - VogelPos))\n       \t);\n        Color = mix(\n            Color,vec3(1.0),\n            smoothstep(PointRadius + 1.0, PointRadius - 1.0, length(fragCoord - VogelPos))\n        );\n    }\n    \n    fragColor = vec4(Color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 229, 229, 406], [408, 408, 465, 465, 1707]], "test": "untested"}
{"id": "tdGSR3", "name": "Vitraux", "author": "Kali", "description": "2D mapping of a 4D fractal using the method described here: https://twitter.com/donaldm38768041/status/1191950149578301440", "tags": ["fractal"], "likes": 17, "viewed": 335, "published": "Public", "date": "1574564765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 3\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec4 fractal(vec2 U) {\n    float m=1e3,t=iTime;\n    U*=.13-sin(t*.2)*.1;\n    U*=rot(sin(t*.1)*3.14);\n    U+=vec2(sin(t),cos(t))*.005*sin(t*.2);\n    vec4 p=vec4(cos(U.x),sin(U.x),cos(U.y),sin(U.y));\n    for (int i=0;i<8;i++) {\n    \tp=abs(p+1.)-abs(p-1.)-p;\n        p=p*1.5/min(1.,dot(p,p))-1.;\n\t\tm=min(m,fract( length(p*2.) -t*.1 ) );\n    }\n    return pow(m,1.7)*normalize(2.+abs(p.xyww))*2.;\n}\n\nvoid mainImage(out vec4 O,vec2 u)\n{\n    vec2 R=iResolution.xy,\n         U=(u-R*.5)/R.y;\n    U*=1.-dot(U,U)/4.;\n    O=vec4(0);\n\tvec2 pix=1./R/float(AA)+max(0.,2.-iTime)*.005;\n    for (int x=-AA;x<AA;x++) \n        for (int y=-AA;y<AA;y++)\n\t\t    O+=fractal(U+vec2(x,y)*pix);\n\n\tO/=float(AA*AA);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 87, 87, 458], [460, 460, 495, 495, 752]], "test": "untested"}
{"id": "tdGSRm", "name": "Pattern Combinator", "author": "robhardwood", "description": "Drawing some combined random patterns", "tags": ["pattern"], "likes": 4, "viewed": 88, "published": "Public", "date": "1573625742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const bool ENABLE_DOUBLE_LAYERS = true;\nconst bool ENABLE_CROSSFIRE     = false;\nconst bool ENABLE_SHADING       = true;\nconst bool ENABLE_AND_PATTERN   = false;\nconst bool ENABLE_INVERSION     = false;\nconst bool ENABLE_LOOPING       = true;\nconst bool ENABLE_LOOP_REWIND   = true;\n\nconst float LOOP_LENGTH = 420.0;\nconst float LAYER_A_SPEED = 144.0;\nconst float LAYER_B_SPEED = 96.0;\n\nconst vec3 COLOR = vec3(0.0, 1.0, 0.0);\n\nint isPrime(int num)\n{\n     if (num <= 1) return 0;\n     if (num % 2 == 0 && num > 2) return 0;\n\n     for(int i = 3; i < int(floor(sqrt(float(num)))); i+= 2)\n     {\n         if (num % i == 0)\n             return 0;\n     }\n     return 1;\n}\n\nint patternA(int x){\n    return ((x*x)&x);\n}\nint patternB(int x){\n    return (x>>7)&x;\n}\n\nfloat isMagical(int x, int y){\n    int v;\n    if (ENABLE_AND_PATTERN)\n        v = x & y;\n    else\n        v = x ^ y;\n    \n    float r = patternA(v) > patternB(v) ? 0.0 : 1.0;\n    if (ENABLE_INVERSION)\n        r = 1.0 - r;\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    if (ENABLE_LOOPING){\n        while(time > LOOP_LENGTH) time -= LOOP_LENGTH;\n        if (ENABLE_LOOP_REWIND && time > LOOP_LENGTH / 2.0)\n            time = LOOP_LENGTH - time;\n    }\n    \n    int XA = int(fragCoord.x + time * LAYER_A_SPEED);\n    int YA = int(fragCoord.y + time * LAYER_A_SPEED);\n   \n    int XB = int(fragCoord.x + time * LAYER_B_SPEED);\n    int YB = int(fragCoord.y + time * LAYER_B_SPEED);\n\n    float VA, VB;\n    if (ENABLE_CROSSFIRE){\n        VA = isMagical(XA, YB);\n        VB = isMagical(XB, YA);\n    } else {\n        VA = isMagical(XA, YA);\n        VB = isMagical(XB, YB);\n    }\n    \n    float V;\n    if (ENABLE_DOUBLE_LAYERS)\n\t    V = VA * VB;\n    else\n        V = VA;\n    \n    float S = 1.0;\n    if (ENABLE_SHADING){\n        vec2 halfRes = iResolution.xy / vec2(2.0, 2.0);\n        float dx = abs(float(fragCoord.x) - halfRes.x) / float(halfRes.x);\n        float dy = abs(float(fragCoord.y) - halfRes.y) / float(halfRes.y);\n        S = 1.0 - sqrt(dx * dx + dy * dy);\n    } else\n        S = 1.0;\n    fragColor = vec4(S * V, S * V, S * V, 1.0) * vec4(COLOR, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 428, 450, 450, 666], [668, 668, 688, 688, 712], [713, 713, 733, 733, 756], [758, 758, 788, 788, 995], [997, 997, 1054, 1054, 2164]], "test": "untested"}
{"id": "tdGSRt", "name": "Polar Rep KIFS", "author": "efairbanks", "description": "Haven't done a raymarch fractal from memory in a while so IDK here's something.", "tags": ["raymarching", "kifs", "idk"], "likes": 10, "viewed": 178, "published": "Public", "date": "1574710926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvec2 c2p(vec2 c){return vec2(atan(c.y,c.x),length(c));}\nvec2 p2c(vec2 p){return vec2(cos(p.x)*p.y,sin(p.x)*p.y);}\nvec2 crep(vec2 uv, float c){\n\tuv=c2p(uv);\n    uv.x=uv.x+PI;\n    uv.x=mod(uv.x,2.*PI/c);\n    uv.x=abs(uv.x-PI/c);\n    uv.x=uv.x-PI;\n    return p2c(uv);\n}\nvec3 look(vec2 uv, vec3 o, vec3 t)\n{\n    vec3 fwd=normalize(t-o);\n    vec3 right=normalize(cross(fwd,vec3(0.,1.,0.)));\n    vec3 up=normalize(cross(fwd,right));\n    return fwd+right*uv.x+up*uv.y;\n}\nfloat box(vec3 p, float s)\n{\n    float d=abs(p.y)-s;\n    d=max(d,abs(p.x)-s);\n    d=max(d,abs(p.z)-s);\n    return d;\n}\nfloat map(vec3 p)\n{\n    p-=6.5;\n    p=mod(p,13.)-6.5;\n    for(int i=0;i<5;i++)\n    {\n        p.xz=crep(p.xz,9.-float(i));\n        p.xz+=0.7-0.01;\n        float t=p.x;\n        p.x=p.y;\n        p.y=p.z;\n        p.z=t;\n    }\n    float d=box(p,0.45);\n    return d;\n}\nvec3 gradient(vec3 p)\n{\n    vec2 e=vec2(0.,0.001);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy)));\n}\nfloat march(vec3 o, vec3 r)\n{\n    float t=0.2;\n    for(int i=0;i<70;i++)\n    {\n        float d=map(o+r*t);\n        if(d<0.004) return t;\n        t+=d*0.8;\n    }\n    return 0.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv=uv-0.5;\n    uv.x=uv.x*iResolution.x/iResolution.y;\n\n\tvec3 o=vec3(cos(iTime),cos(iTime),sin(iTime))*(sin(iTime*0.6)+1.15)*4.;\n    vec3 t=vec3(0.);\n    vec3 r=look(uv,o,t);\n    float d=march(o,r);\n\n    fragColor=vec4(0.);\n    if(d==0.) return;\n    float shade=dot(normalize(vec3(o)),gradient(o+r*d))/pow(1.1,d);\n    // Output to screen\n    fragColor = vec4(vec3(shade),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 42, 42, 80], [81, 81, 98, 98, 138], [139, 139, 167, 167, 291], [292, 292, 328, 328, 488], [489, 489, 517, 517, 607], [608, 608, 627, 627, 870], [871, 871, 894, 894, 1064], [1065, 1065, 1094, 1094, 1242], [1243, 1243, 1300, 1350, 1772]], "test": "untested"}
{"id": "tdGSWw", "name": "Moving camera with spheres", "author": "tomoe", "description": "The Camera position is rotated. ", "tags": ["raymarching"], "likes": 1, "viewed": 236, "published": "Public API", "date": "1574153688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define INFTY 1e6\nconst float sphereSize = 0.15;\nconst float num = 3.0;\n\nfloat sphereSDF(vec3 camPos, vec3 sphPos) {\n    vec3 p =- camPos + sphPos;\n    return length(p) - sphereSize;\n}\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nfloat hitSphere(vec3 camPos, vec3 sphPos, vec3 ray) {\n    vec3 p = - camPos + sphPos;\n    return length(p) * sin(getAngle(p, ray)) - sphereSize;\n}\nvec3 getSpherePos(vec3 camPos, vec3 sphPos, vec3 ray) {\n    vec3 p = - camPos + sphPos;\n    float ang = getAngle(p, ray);\n    float d = length(p);\n    float theta = d*cos(ang) - sqrt(pow(d * cos(ang), 2.0) - pow(d, 2.0) + pow(sphereSize, 2.0));\n    return camPos + theta*ray;\n}\n\nvec3 getNormal(vec3 p, vec3 sphPos) {\n    float d = EPSILON;\n    return normalize(vec3(\n            sphereSDF(p + vec3(d, 0.0, 0.0), sphPos) - sphereSDF(p, sphPos),\n            sphereSDF(p + vec3(0.0, d, 0.0), sphPos) - sphereSDF(p, sphPos),\n            sphereSDF(p + vec3(0.0, 0.0, d), sphPos) - sphereSDF(p, sphPos)\n        ));\n}\nmat3 rotX(float theta) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(theta), cos(theta),\n        0.0, - cos(theta), sin(theta)\n    );\n}\nmat3 rotY(float theta) {\n    return mat3(\n        sin(theta), 0.0, cos(theta),\n        0.0, 1.0, 0.0,\n        - cos(theta), 0.0, sin(theta)\n    );\n}\nmat3 rotZ(float theta) {\n    return mat3(\n        sin(theta), cos(theta), 0.0,\n        - cos(theta), sin(theta), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // pixel position\n    vec2 pixPos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = vec3(0.0, - 0.0, - 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camSide = cross(camDir, camUp);\n    float targetDepth = 1.0;\n    float theta = iTime * 0.3;\n    camPos = rotY(theta) * rotX(theta) * rotZ(theta) * camPos;\n    camDir = rotY(theta) * rotZ(theta) * rotX(theta) * camDir;\n    camUp = rotY(theta) * rotZ(theta) * rotX(theta) * camUp;\n    // camSide = cross(camDir, camUp);\t// moderate deformation\n    float colMode = mod(theta * 2.0 / PI, 2.0); \n    // 0<colMode<1 if 0<theta<PI/2, 1<colMode<2 if PI/2<theta<PI, \n\n    //light\n    vec3 lightDir = vec3(0.0, 0.0, - 5.0);\n    lightDir = normalize(lightDir);\n\n    vec3 ray = normalize(camSide * pixPos.x + camUp * pixPos.y + camDir * targetDepth);\n    vec3 sphPos = vec3(INFTY);\n    bool hit = false;\n    for(float i = - num; i < num; i ++ ) {\n        for(float j = - num; j < num; j ++ ) {\n            for(float k = - num; k < num; k ++ ) {\n                if (hitSphere(camPos, vec3(i, j, k), ray) < EPSILON && distance(camPos, vec3(i, j, k)) > 0.2) {\n                    vec3 p = vec3(i, j, k);\n                    if (distance(p, camPos) < distance(sphPos, camPos)) {\n                        sphPos = p;\n                    }\n                    hit = true;\n                }\n            }\n        }\n    }\n    if (hit) {\n        vec3 rayPos = getSpherePos(camPos, sphPos, ray);\n        vec3 normal = getNormal(rayPos, sphPos);\n        float diff = clamp(dot(lightDir, - normal), 0.1, 1.0);\n        fragColor = mix(\n            vec4(0.0, 0.2667, 1.0, 1.0),\n            vec4(0.0, 1.0, 0.298, 1.0), \n            mod(colMode, 1.0) * diff\n            );       \n    }else {\n        fragColor = vec4(\n            vec3(step(1.0, colMode)), \n            1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 162, 162, 230], [231, 231, 263, 263, 315], [316, 316, 369, 369, 462], [463, 463, 518, 518, 740], [742, 742, 779, 779, 1073], [1074, 1074, 1098, 1098, 1222], [1223, 1223, 1247, 1247, 1371], [1372, 1372, 1396, 1396, 1520], [1521, 1521, 1576, 1598, 3493]], "test": "untested"}
{"id": "tdGXRy", "name": "CodebaseAlpha7", "author": "codebasealpha", "description": "A shader created live on-stream (Episode 73) at https://twitch.tv/codebasealpha. The texture that is flying upward is not the correct image, but I cannot upload the right one!", "tags": ["fire", "smoke", "rocketplume"], "likes": 3, "viewed": 272, "published": "Public API", "date": "1574274441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noiseFunction(vec2 pos)\n{\n    return texture(iChannel0, pos - 0.5).x * 2.0 - 1.0;\n}\n\nfloat fbm(vec2 pos)\n{\n    pos *= 0.02;\n    pos.y += iTime * -0.05;\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    \n    for (int i = 0; i < 4; i++)\n    {\n        sum += amp * noiseFunction(pos * freq);\n        amp *= 0.5;\n        freq *= 3.0;\n    }\n    \n    return sum;\n}\n\nvec2 toPolarCoords(vec2 pos)\n{\n    float radius = length(pos);\n    float angle = atan(pos.y, pos.x);\n    return vec2(radius, angle);\n}\n\nvec2 toRectCoords(vec2 polar)\n{\n    float x = polar.x * cos(polar.y);\n    float y = polar.x * sin(polar.y);\n    \n    return vec2(x,y);\n}\n\nvec3 fire(vec2 pos)\n{\n    pos.y += 0.75;\n    pos *= 5.0;\n    \n    float n = tanh(exp(fbm(pos) - pos.y));\n    vec3 col = mix(vec3(pow(n, 0.4)), vec3(1.5 * n, 1.5 * pow(n,3.0), pow(n, 6.0)), n);\n    \n    return col;\n}\n\nvec4 rocketPlume(vec2 pos)\n{\n    pos.y *= -0.75;\n\n    vec2 p = toPolarCoords(pos);\n    p.x -= 1.2;\n    \n    pos = toRectCoords(p);\n    vec3 col = fire(pos);\n    float alpha = smoothstep(0.1, -0.2, p.x) * (smoothstep(2.5, 2.0, p.y) * smoothstep(0.5, 1.5, p.y));\n    \n    return vec4(col, alpha);\n}\n\nvec4 alf(vec2 pos)\n{\n    pos.y -= 0.06;\n    pos.y *= -1.0;\n    pos *= 4.0;\n    pos += 0.5;\n    float a = pos.x >= 0.0 && pos.x <= 1.0 ? 1.0 : 0.0;\n    float b = pos.y >= 0.0 && pos.y <= 1.0 ? 1.0 : 0.0;\n    vec4 col = texture(iChannel1, pos) * a * b;\n    return col;\n}\n\nvec3 rocketAlf(vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec4 rocketc = rocketPlume(pos);\n    col = mix(col, rocketc.xyz, rocketc.w);\n    vec4 alfc = alf(pos);    \n    col = mix(col, alfc.xyz, alfc.w);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float offset = mix(1.0, -2.1, smoothstep(0.0, 10.0, mod(iTime, 10.0)));\n    uv.y += offset;\n\n    vec3 col = rocketAlf(uv);    \n        \n    fragColor = vec4(\n        col,\n        1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 89], [91, 91, 112, 112, 382], [384, 384, 414, 414, 518], [520, 520, 551, 551, 656], [658, 658, 679, 679, 873], [875, 875, 903, 903, 1171], [1173, 1173, 1193, 1193, 1441], [1443, 1443, 1469, 1469, 1662], [1665, 1665, 1722, 1772, 2065]], "test": "untested"}
{"id": "tdGXWm", "name": "VDrop2", "author": "Del", "description": "Drops", "tags": ["2d", "mod", "drops"], "likes": 17, "viewed": 496, "published": "Public API", "date": "1574164877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// V-Drop - Del 19/11/2019 - this is more the effect I wanted.\n#define PI 3.14159\n#define\tTAU 6.28318\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    if (iMouse.z>0.5)\n        uv.y = 1.0-uv.y;\t\t\t\t\t// V-flip\n    \n    vec3 col = vec3(1.55,0.65,.225);\t\t// Drop Colour\n    uv.x = uv.x*64.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    float t =  iTime*0.4;\n    uv.y *= 0.15;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    yv *= d2*d2;\n    col = col*yv;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 104, 161, 161, 867]], "test": "untested"}
{"id": "tdGXzV", "name": "dark descent 3", "author": "feyrob", "description": "An attempt at creating and optical illusion that makes the screen seem go darker and darker.\nAka 6 shades of gray.", "tags": ["grayscale"], "likes": 0, "viewed": 230, "published": "Public API", "date": "1574429088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sfloor(float a, float pix){\n    \n    float e = floor(a) + max(1.+(fract(a)-1.)/pix,0.);\n    \n\tfloat b = floor(a);\n    return e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv[0];\n\tfloat y = uv[1];\n    \n    \n    \n    float speed = 0.05;\n    //speed = x * 20.0;\n    //float yw = x * 10.0\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //iResolution.x \n    \n    float mtime = -iTime * speed;\n    float bar_count = 6.0;\n    //bar_count = x * 1.0;\n    \n    float pix = bar_count/iResolution.y;\n        \n    \n    float x2 = fragCoord[0];\n    float nx = x2 / iResolution.x;\n    \n    //bar_count = nx * 20.0;\n    //bar_count = x*x * 6.0;\n    //bar_count = x * 6.0;\n    \n    //bar_count = sqrt(x) * 6.0;\n    \n    \n    \n    //float x = fragCoord[1];\n    //float nx = x / iResolution.y;\n        \n    \n    float c = y + mtime;\n    \n    \n    //c = floor(c * bar_count) / bar_count;\n    c = sfloor(c * bar_count, pix) / bar_count;\n    \n    \n    c = c - mtime;\n    \n    c = c * c;\n    //c = c * sqrt(c);\n    //c = c * sqrt(c);\n    //c = c * sqrt(c);\n    \n    vec3 col2 = vec3(c, c, c);\n\n    \n    fragColor = vec4(col2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 135], [137, 137, 194, 194, 1244]], "test": "untested"}
{"id": "tdKSRc", "name": "Rotating shapes and lines", "author": "Maddig", "description": "Using conversions between Polar and Cartesian coordinates to rotate boundaries and using those boundaries to form shapes and lines", "tags": ["2d", "shapes", "rotating", "polar"], "likes": 2, "viewed": 143, "published": "Public", "date": "1575148624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// use conversion between polar and cartesian coordinates to generate rotated boundaries\nfloat drawBoundary(vec2 pos, vec2 fragPos, int iAngle, float radius)\n{   \n    // add 0.001 to avoid 0 division on tan(90) & tan(270)\n    float angle = float(iAngle % 360) + 0.001;\n    \n    // tan(angle) == y / x\n    float gradient = tan(radians(angle));\n    \n    // y = mx + c => c = mx - y\n    float fragEquation = (fragPos.x * gradient) - fragPos.y;\n    \n    // rotate around pos from a radius distance\n    float radx = radius * cos(radians(angle));\n    float rady = radius * sin(radians(angle));\n    \n    // antialiasing\n    float aax = .8 * cos(radians(angle));\n    float aay = .8 * sin(radians(angle));\n    \n    float boundaryPos1 = ((pos.x - rady - aay) * gradient) - (pos.y + radx + aax);\n    float boundaryPos2 = ((pos.x - rady + aay) * gradient) - (pos.y + radx - aax);\n    \n    \n    float inBounds = smoothstep(boundaryPos1, boundaryPos2, fragEquation);\n    return inBounds;\n}\n\n\nfloat drawLine(vec2 pos, vec2 fragPos, int iAngle, float radius, float thickness)\n{\n    thickness /= 2.;\n    float inBounds = drawBoundary(pos, fragPos, iAngle,       thickness + radius) *\n                     drawBoundary(pos, fragPos, iAngle + 180, thickness - radius);\n    \n    return inBounds;\n}\n\n\nfloat drawShape(vec2 pos, vec2 fragPos, int iAngle, float size, float sides)\n{\n    float inBounds = 1.;\n    float sideAngle = 360. / sides;\n    \n    for (float i = 0.; i <= 360.; i += sideAngle)\n    {\n        inBounds *= drawBoundary(pos, fragPos, iAngle + int(i), size);\n    }\n    \n    return inBounds;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 lineCoord = vec2(0.5) * iResolution.xy;\n    vec2 polyCoord = vec2(0.25, 0.75) * iResolution.xy;\n    \n    // iFrame probably isn't a great angle metric for time consistency but it works\n    \n    float b1 = drawBoundary(lineCoord, fragCoord, iFrame + 180, -0.25 * iResolution.y);\n    \n    float l1 = drawLine(lineCoord, fragCoord, 2 * iFrame,                 0.00, 2.);\n    float l2 = drawLine(lineCoord, fragCoord,     iFrame, iResolution.y * 0.25, 1.);\n    \n    float s1 = drawShape(lineCoord, fragCoord, iFrame, 0.16 * iResolution.y, 4.0);\n    float s2 = drawShape(polyCoord, fragCoord, iFrame, 0.1  * iResolution.y, 7.0);\n    \n    // max is the equivilant of drawing both shapes, would have liked to use binary | though\n    vec3 col = vec3(max(s1, s2), max(l1, l2), max(l1, b1));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 159, 221, 975], [978, 978, 1061, 1061, 1277], [1280, 1280, 1358, 1358, 1585], [1590, 1590, 1647, 1697, 2587]], "test": "untested"}
{"id": "tdKSRR", "name": "All possible quadratics", "author": "iq", "description": "All possible quadratic equations can be mapped to the surface of a sphere. Blue: complex solutions. Yellow: real solutions with different signs. White: real negative solutions with same sign. See [url]https://www.youtube.com/watch?v=JJYVqviE2Uk[/url]", "tags": ["3d", "sphere", "mapping", "quadratic", "polynomial"], "likes": 13, "viewed": 1151, "published": "Public API", "date": "1573268788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Something I toyed with a decade ago was mapping all possible\n// quadratic polynomials to the surface of a sphere:\n//\n// http://www.iquilezles.org/blog/?p=1089\n//\n// See also this video: https://www.youtube.com/watch?v=JJYVqviE2Uk\n//\n// Basically, all possible quadratic equations (parabolas) can be\n// mapped to the surface of a sphere. p(x)=ax²+bx+c becomes a point\n// (a,b,c) in 3D space, and since all quadratics of the form\n// (k·a, k·b, k·c) has the same solutions, all space can be\n// collapsed into a unit sphere through vector normalization.\n//\n// In blue are complex solutions.\n// In yellow are real solutions with different signs\n// In white are real solutions with same signs\n//\n// Similar idea, but for cubic equations:\n// https://www.shadertoy.com/view/tsVSRR\n\n//-------------------------------------------------------\n\n// For a point in the sphere's surface p, return a color based on\n// the solutions of the associate quadratic polynomial\nvec3 getColor( in vec3 p )\n{\n    // rotate the solution space (the sphere mapping)\n    float an = 0.5*iTime;\n    float si = sin(an), co = cos(an);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    \n    vec3 col = vec3(0.0);\n    float m = 11.0;\n    \n    // solve quadratic\n    float h = p.y*p.y - 4.0*p.x*p.z;\n    if( h<0.0 )\n    {\n        // Complex solution. Make it blue\n        col = vec3(0.0,0.5,1.0);\n        //m = -h;\n        float f = sqrt(abs(p.z/p.x));\n        m = 1.0*min(f,1.0/f);\n    }\n    else\n    {\n        // Real solution. Yellow if same sign and white if not\n        float t1 = (-p.y-sqrt(h))*0.5/p.x;\n        float t2 = (-p.y+sqrt(h))*0.5/p.x;\n        col = (t1*t2>0.0) ? vec3(1.0,0.9,0.8) : vec3(1.0,0.5,0.1);        \n        \n        m = 16.0*abs(min(min(abs(    t1),abs(    t2)),\n                         min(abs(1.0/t1),abs(1.0/t2))));\n\t}\n    \n    \n    // shade\n    col *= clamp(log(1.0+m),0.0,1.0);\n\n    col *= clamp(log(1.0+16.0*abs(h)),0.0,1.0);\n    \n    // discriminant isolines\n    col *= 0.7 + 0.3*smoothstep(-0.1,0.1,sin(abs(24.0*h)));\n\n#if 0\n    //if( abs(p.x-p.z)<0.01 ) col = vec3(1,0,0);\n\n    //if( abs(h-2.0)<0.01 ) col = vec3(1,0,0);\n    if( abs(h+2.0)<0.01 ) col = vec3(1,0,0);\n    \n    if( abs(p.x-0.0)<0.01 ) col = vec3(1,0,0);\n    //if( abs(p.y-0.0)<0.01 ) col = vec3(0,1,0);\n    if( abs(p.z-0.0)<0.01 ) col = vec3(0,0,1);\n    \n    if( length(p-vec3( 1, 0, 1)/sqrt(2.0))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3(-1, 0,-1)/sqrt(2.0))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3( 1, 0, 0))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3(-1, 0, 0))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3( 0, 0, 1))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3( 0, 0,-1))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3(1, 2,1)/sqrt(6.0))<0.05 ) col = vec3(0,0,0);\n    if( length(p-vec3(1,-2,1)/sqrt(6.0))<0.05 ) col = vec3(0,0,0);\n    \n    \n#endif\n    \n    return col;\n}\n\n//-------------------------------------------------------\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );\n}    \n            \nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    return dot(nor,r)*(sph.w*sph.w)/(l*l*l);\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 plot2D( in vec2 px )\n{\n    vec2 p = px/iResolution.xy;\n    \n#if 1\n    p.x -= 0.5;\n    vec2 a = p.yx*vec2(3.141593, 6.283185);\n        \n    vec3 q = vec3( cos(a.x),\n                   sin(a.x)*cos(a.y),\n                   sin(a.x)*sin(a.y) );\n#else\n    p.y = -0.5 + p.y;\n    vec2 a = p*vec2(6.283185,3.141593);\n        \n    vec3 q = vec3( cos(a.y)*cos(a.x),\n        \t\t   sin(a.y),\n                   cos(a.y)*sin(a.x) );\n#endif    \n    \n    //if( length(q-vec3(0,1,0))<0.1 ) return vec3(1,0,0);\n    \n    return getColor(q);    \n}\n\n//=====================================================\n\nvec3 plot3D( in vec2 px )\n{\n    vec2 p = (-iResolution.xy + 2.0*px)/iResolution.y;\n\n    // camera\n    vec3 ro = vec3(0.0, 0.0, 3.0 );\n    vec3 rd = normalize( vec3(p,-2.0) );\n\n    // sphere\n    vec4 sph = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n    vec3 col = vec3(0.0);\n\n    // intersect geometry\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    vec3 mate = vec3(1.0);\n\n    // plane/floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0-sphOcclusion( pos, nor, sph );\n        mate = vec3(0.2);\n    }\n\n    // sphere\n    float t2 = sphIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph );\n        occ = 0.5 + 0.5*nor.y;\n        mate = getColor(nor);\n    }\n\n    // apply color and lighting\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n\n        vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n        float sha = sphSoftShadow( pos, lig, sph, 2.0 );\n\n        vec3 lin = vec3(1.5)*clamp(dot(nor,lig),0.0,1.0)*sha;\n        lin += 0.5*occ;\n        lin += 0.5*occ*pow(clamp(1.0+dot(nor,rd),0.0,1.0),3.0);\n\n        col = mate*lin;\n        // fog\n        col *= exp( -0.05*tmin );\n    }\n    return col;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p = fragCoord + vec2(float(m),float(n))/float(AA)-0.5;\n        #else    \n        vec2 p = fragCoord;\n        #endif\n \n        // draw stuff\n        vec3 col = (sin(0.7*iTime)<-0.5) ? plot2D(p) : plot3D(p);\n\n        // gamma correction\n        col = pow(col,vec3(0.4545));\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    // output color\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKSRR.jpg", "access": "shaders20k", "license": "mit", "functions": [[1918, 2039, 2067, 2121, 3943], [3945, 4004, 4063, 4063, 4226], [4228, 4228, 4300, 4300, 4495], [4513, 4513, 4574, 4574, 4675], [4677, 4677, 4721, 4721, 4758], [4760, 4760, 4800, 4800, 4833], [4835, 4892, 4919, 4919, 5425], [5427, 5484, 5511, 5511, 6794], [6897, 6897, 6954, 6954, 7599]], "test": "untested"}
{"id": "tdKSRy", "name": "Surface experiments", "author": "tomoe", "description": "with tricky implicit function", "tags": ["raymarching"], "likes": 0, "viewed": 204, "published": "Public API", "date": "1574346730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define INFTY 1e6\n\nfloat surfaceSDF(vec3 p) {\n    float t = iTime * 0.1;\n    return 0.5 * \n        length(\n            mod(\n                vec3(\n                    2.0 * abs(sin(t) * cos(t)) * p.x,\n                    1.0 * abs(cos(t) + sin(0.5 * t)) * p.z,\n                    2.0 * cos(t) * p.y\n                )\n                + vec3(\n                    2.0 * sin(t), \n                    cos(t), \n                    0.0\n                ) \n                ,1.0\n            )\n            - 0.5\n        )\n        - 0.4 * (0.8 * cos(t) + sin(3.0 * p.x)) \n        * (sin(t) + 0.5 * sin(2.0 * p.y)) \n        * cos(4.0 * p.z);\n}\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nvec3 getNormal(vec3 p) {\n    float d = EPSILON;\n    return normalize(vec3(\n            surfaceSDF(p + vec3(d, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec3(0.0, d, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec3(0.0, 0.0, d)) - surfaceSDF(p)\n        ));\n}\nfloat getDiff(vec3 p, vec3 dir) {\n    float d = EPSILON;\n    return (surfaceSDF(p + d*dir) - surfaceSDF(p)) / d;\n}\nmat3 rotX(float t) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(t), cos(t),\n        0.0, - cos(t), sin(t)\n    );\n}\nmat3 rotY(float t) {\n    return mat3(\n        sin(t), 0.0, cos(t),\n        0.0, 1.0, 0.0,\n        - cos(t), 0.0, sin(t)\n    );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 lightDir = vec3(0.0, 4.0, 1.0);\n    \n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    float t = iTime * 0.3;\n    cPos = rotX(t) * rotY(t) * cPos;\n    cDir = rotX(t) * rotY(t) * cDir;\n    cUp = rotX(t) * rotY(t) * cUp;\n    vec3 cSide = cross(cDir, cUp);\n    \n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    float ang = getAngle(ray, - normalize(cPos));\n    vec3 rPos = cPos + (1.0 / cos(ang)) * ray;\n    \n    // marching loop\n    for(int i = 0; i < 120; i ++ ) {\n        rPos += 0.015 * ray;\n        if (surfaceSDF(rPos) < 0.01) {\n            break;\n        }\n    }\n    vec3 normal = getNormal(rPos);\n    float diff = clamp(dot(normalize(lightDir - rPos), normal), 0.01, 1.0);\n\n    // hit check\n    if (surfaceSDF(rPos) < 0.01) {\n        fragColor = vec4(diff * vec3(rPos.x, 1.0, rPos.p), 1.0);\n    } else {\n        fragColor = vec4(vec3(1.0, 1.0, 1.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 91, 91, 676], [677, 677, 709, 709, 761], [762, 762, 786, 786, 1038], [1039, 1039, 1072, 1072, 1153], [1154, 1154, 1174, 1174, 1282], [1283, 1283, 1303, 1303, 1411], [1412, 1412, 1467, 1467, 2612]], "test": "untested"}
{"id": "tdKSWw", "name": "Codevember07 - Shape", "author": "z0rg", "description": "My participation at Codevember \"shape\"", "tags": ["abstract", "pattern", "rotation", "codevember", "goa"], "likes": 3, "viewed": 71, "published": "Public API", "date": "1574192494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 uv)\n{\n  return abs(uv.x)+abs(uv.y);\n}\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\n\nfloat _sub(float a, float b)\n{\n  return max(-a,b);\n}\n\nfloat _union(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat sdf_sqr(vec2 uv, float sz)\n{\n  return lenny(uv*r2d(PI/4.))-sz;\n}\n\nfloat sdf_sqrborder(vec2 uv, float sz, float th)\n{\n  return _sub(sdf_sqr(uv,sz-th),sdf_sqr(uv,sz));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  vec3 acc=vec3(1.);\n  const int cnt = 8;\n  float r=0.2;\n  for (int i=0;i<cnt;++i)\n  {\n    float fi =float(i);\n    float fc = float(cnt);\n    vec2 pos = vec2(sin(iTime+fi),cos(iTime+fi))*r;\n    acc *=sat((vec3(sin(iTime+fi)*0.5+0.9)*sdf_sqrborder(uv-pos,0.9,0.01)*20.));\n  }\n  acc*= sat(sdf_sqr(uv, 0.6)*100.);\n  return col + acc*0.2;\n}\n\nvec3 rdrCross(vec2 uv, float sharp)\n{\n  uv *= r2d(PI/4.);\n  float len = 9.*sin(iTime)*(sin(iTime*7.37));\n  float a = (1.-sat(sdf_sqr(uv*vec2(1.,len), 0.5)*sharp));\n  float b = (1.-sat(sdf_sqr(uv*vec2(len,1.), 0.5)*sharp));\n\n  return vec3(1.)*_union(a,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*(iResolution.xy/iResolution.xx);\n\n  vec3 col;\n  uv*=1.5;\nuv.y = abs(uv.y);\n  uv = uv*r2d(iTime*sign(uv.x)*0.5);\n\n  uv.y = mix(abs(uv.x*uv.y),uv.y,0.5*sin(iTime)+0.5);\n  float modsz = .9*(sin(sign(uv.y)*iTime)*0.2+0.9);\n  uv = mod(uv, vec2(modsz))-vec2(modsz/2.);\n\n  col = rdr(uv);\n  col += 0.5*mix(rdrCross(uv,200.),vec3(1.)*(1.-sat(sdf_sqr(uv,.5)*100.)),-1.);\n\n  col += 0.5*rdrCross(uv*r2d(iTime*3.),10.)*vec3(1.,0.7,0.2);\ncol += 0.5*rdrCross(uv*r2d(-iTime),5.)*vec3(1.,0.7,0.2).xzy;\ncol += vec3(1.,0.9,0.7)*(1.-sat(lenny(uv*2.)))*2.;\n  col *= 1.-lenny(uv*1.)*2.;\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKSWw.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 427, 445, 445, 506], [508, 508, 530, 530, 562], [564, 564, 584, 584, 611], [613, 613, 631, 631, 677], [679, 679, 709, 709, 731], [733, 733, 765, 765, 786], [788, 788, 822, 822, 858], [860, 860, 910, 910, 961], [963, 963, 982, 982, 1331], [1333, 1333, 1370, 1370, 1589], [1591, 1591, 1648, 1648, 2305]], "test": "untested"}
{"id": "tdKXWK", "name": "HyperCol Logo 2D", "author": "Ovizro", "description": "The logo of HyperCol Studio.", "tags": ["2d", "logo"], "likes": 0, "viewed": 48, "published": "Public", "date": "1575038722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float size = 5.0;\n\n#define animationTimeCounter mod(iTime+6.2831*iMouse.x/iResolution.x, 10.0)\n\nvec2 fuv_build(in vec2 uv) {\n    vec2 fuv = uv * 2.0 - 1.0;\n    fuv *= max(iResolution.xy / iResolution.yx, vec2(1.0));\n    return fuv;\n}\n\nmat2 mRotate(float theter) {\n    float c = cos(theter);\n    float s = sin(theter);\n    return mat2(c, -s,\n                s, c);\n}\n\nvoid rotate(inout vec2 uv, in float theter) {\n    uv = mRotate(theter) * uv;\n}\n\nfloat triangle(in vec2 puv) {\n\tfloat e1 = 0.57735 * (1.0 - puv.x) - abs(puv.y); \n    float e2 = puv.x + 1.0; \n\treturn min(smoothstep(0.0, 0.05, e1), smoothstep(0.0, 0.0443, e2));\n}\n\nfloat triangle(in vec2 puv, in float d) {\n    puv.x -= d;\n\treturn triangle(puv);\n}\n\nfloat cdot(in vec2 puv) {\t\t\t//Just a light dot\n    float dist = length(puv);\n\tdist = smoothstep(0.0, 2.4, 2.4 - dist) * 1.1;\n    return pow(dist, 2.4);\n}\n\nfloat cdot(in vec2 puv, in float d) {\n    puv.x += d;\n\treturn cdot(puv);\n}\n\nfloat track(float animationTime) {\t\t\t\t//Running track of graph\n    const float edge0 = log(size) / log(1.618) * 1.3333;\t\t//The angle of beginning\n    const float edge = floor(edge0) * PI * 0.25;\t\t\t\t//Correct rotation angle\n    \n    float frametime = (smoothstep(-5.0, 5.0, animationTime) - 0.5) * 8.0;\n    float theter = edge * (3.0 - frametime);\n    float r = pow(1.618, 2.0 * theter / PI);\t\t\t//Fibonacci helix\n    return max(r, 1.0);\n}\n\nvec2 getPuv(in vec2 fuv, int t, vec2 p, mat2 m) {\n    float r = track(animationTimeCounter - float(t) * 0.2);\n    \n    vec2 puv = (fuv * size - r * p) / 0.4142;\n    return m * puv;\n}\n\nvoid ot(inout float tri, vec2 fuv) {\n\tconst vec4 trianglePos[] = vec4[16] (\t\t//Center position(x,y), 1/size, angle\n\t\tvec4(-1.17, \t-0.464, 4.348, \t1.4),\n\t\tvec4(-0.3356, \t1.176, \t2.1739,\t1.05),\n\t\tvec4(-1.73, \t0.3, \t5.376, \t-0.4),\n\t\tvec4(1.42578,\t-0.042,\t3.760, \t1.24),\n\t\tvec4(0.711,\t\t-0.92,\t4.7619,\t-0.3),\n\t\tvec4(0.551, \t0.64, \t16.667,\t-0.5),\n\t\tvec4(-0.117, \t-0.672,\t25.0, \t1.1),\n\t\tvec4(-1.56, \t-0.17,\t24.39,\t1.15),\n\t\tvec4(-1.26, \t0.728,\t26.3,\t-0.2),\n\t\tvec4(0.86,\t\t-0.7,\t12.5,\t0.0),\n\t\tvec4(1.4933,\t1.14,\t3.70,\t-0.9),\n\t\tvec4(1.36889,\t-0.362,\t14.3,\t1.26),\n\t\tvec4(-0.89245,\t0.1,\t50.0,\t0.1),\n\t\tvec4(1.3511,\t-0.814,\t37.453,\t0.01),\n\t\tvec4(-1.45778,\t-1.16,\t58.82,\t-0.2),\n\t\tvec4(1.39,\t\t-0.722,\t100.0,\t1.25)\n\t);\n\n\tfloat frametime = smoothstep(0.0, 7.0, animationTimeCounter);\n\t\n\tfor (int i = 0; i < trianglePos.length(); ++i) {\n\t\tvec4 pos = trianglePos[i];\n\t\tpos.w -= (1.0 - frametime) * pos.z;\n\t\tvec2 puv = (fuv - pos.xy / frametime) * pos.z;\n\t\trotate(puv, pos.w);\n\t\t\n\t\ttri += triangle(puv, 0.3333);\n\t}\n}\n\nvoid HyperCol_Logo(inout vec3 fcolor, in vec2 fuv0) {\n    vec2 fuv = fuv0;\n    const vec3 logoColor = vec3(0.0, 0.62, 0.9);\n    float logo = 0.0;\n    \n    const float sqrt2 = inversesqrt(2.0);\n    const mat2 rot45 = mat2(sqrt2, -sqrt2,\n                           sqrt2, sqrt2);\n    const float edge0 = log(size) / log(1.618) * 1.3333;\t\t//The angle of beginning\n    const float edge = floor(edge0) * PI * 0.25;\t\t\t\t//Correct rotation angle\n    \n    float frametime = (smoothstep(-6.0, 6.0, animationTimeCounter) - 0.5) * 8.0;\n    float theter = edge * (3.0 - frametime);\n    vec2 p = vec2(cos(theter), sin(theter));\n    mat2 m = mRotate(theter - PI * 0.5);\n   \t\n    for (int i = 0; i < 8; ++i) {\n        fuv = rot45 * fuv;\n        \n        vec2 puv = getPuv(fuv, i, p, m);\n        logo += mix(cdot(puv, 0.3333), triangle(puv), smoothstep(1.5, 3.0, animationTimeCounter));\n    }\n    \n    ot(logo,fuv0);\n    fcolor = mix(fcolor, logoColor, logo);\n}\n\nvec4 HyperCol_Logo_Build(in vec2 uv) {\n    vec2 fuv = fuv_build(uv);\n    vec3 background = vec3(1.0) * smoothstep(1.0, 3.0, animationTimeCounter);\n    \n    HyperCol_Logo(background, fuv);\n    return vec4(background, 1.0) * (1.0 - smoothstep(9.0, 10.0, animationTimeCounter));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = HyperCol_Logo_Build(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 162, 162, 271], [273, 273, 301, 301, 403], [405, 405, 450, 450, 483], [485, 485, 514, 514, 665], [667, 667, 708, 708, 749], [751, 751, 776, 797, 904], [906, 906, 943, 943, 980], [982, 982, 1016, 1044, 1419], [1421, 1421, 1470, 1470, 1603], [1605, 1605, 1641, 1641, 2599], [2601, 2601, 2654, 2654, 3545], [3547, 3547, 3585, 3585, 3824], [3826, 3826, 3883, 3883, 3967]], "test": "untested"}
{"id": "tdKXWw", "name": "Permutation", "author": "nolibab", "description": "Port compo 'Permutation 23' release for Buenzli party 2012 coded by bitphallus.\nAdd rotation.", "tags": ["reflection", "raymarch", "permutation"], "likes": 3, "viewed": 67, "published": "Public", "date": "1574542275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define EPSILON 0.0001\n#define R0 1.0\n#define ETA 1.07\n\nfloat x = 0.;\nvec2 d;\n\n\nvec2 rotate(vec2 p, float t) \n{\nreturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n\nfloat m(vec3 v)\n{\nv.yz = rotate(v.yz, -iTime * 0.125);\nv.zx = rotate(v.zx, iTime * 0.2);   \n    \nv.yz=cos((.5*x))*v.yz+sin((.5*x))*vec2(v.z,-v.y);\nv.xz=cos((.5*x))*v.xz+sin((.5*x))*vec2(v.z,-v.x);\nfloat m=length(v);\nv=abs(normalize(v));\nv=mix(mix(v.zxy,v.yzx,step(v.z,v.y)),v,step(v.y,v.x)*step(v.z,v.x));\nfloat f=max(max(dot(v,vec3(.577)),dot(v.xz,vec2(.934,.357))),\nmax(dot(v.yx,vec2(.526,.851)),dot(v.xz,vec2(.526,.851))));\nf=acos(f-.01)/1.57075;\nf=smoothstep(.25,0.,f);\nreturn m-2.-f*f*.7;\n}\n\n\nfloat m(vec3 v,vec3 x)\n{\nvec3 m=abs(v)-x;\nfloat y=max(m.x,max(m.y,m.z));\nreturn mix(y,length(max(m,0.)),step(0.,y));\n}\n\nfloat t(vec3 v)\n{\nfloat f=dot(v-vec3(0.,-5.,0.),vec3(0.,1.,0.));\nf=min(f,-length(v)+150.);\nf=min(f,length(v-vec3(3.,0.,0.)-1.));\nreturn min(f,m(v-vec3(0.,0.,0.),vec3(1.)));\n}\n\nfloat p(vec3 v)\n{\nreturn t(v);\n}\n\nvec2 m(vec3 v,vec3 y,vec4 m)\n{\nvec3 x=m.xyz-v;\nfloat f=dot(x,y),d=dot(x,x);\nif(f<0.&&d>m.w) return vec2(0.);\nfloat z=d-f*f;\nif(z>m.w) return vec2(0.);\nfloat s=sign(d-m.w);\nreturn vec2(EPSILON*step(z,m.w)*s,f-sqrt(m.w-z)*s);\n}\n\nvec2 p(vec3 v,vec3 m,vec4 x)\n{\nfloat y=-dot(m,x.xyz), f=(dot(v,x.xyz)-x.w)/y;\nreturn vec2(EPSILON*sign(y)*step(0.,f),f);\n}\n\nvec2 m(vec3 v,vec3 y,vec3 m,vec3 x)\n{\nvec3 f=m-x,d=m+x,s=(f-v)/y,z=(d-v)/y,a=min(s,z),p=max(s,z);\nfloat e=min(p.x,min(p.y,p.z)),E=max(max(a.x,0.),max(a.y,a.z));\nvec3 i=step(f,v),w=step(v,d);\nfloat t=step(3.,dot(i,w));\nreturn vec2(EPSILON*(t*-2.+1.)*step(E,e),mix(E,e,t));\n}\n\nvec2 p(vec3 v,vec3 f)\n{\nvec2 s=m(v,f,vec4(0.,-2.,0.,251.203));\nvec3 d=v;\nif(s.x==0.) return s;\nif(s.x>0.) v+=f*s.y;\ns.x=sign(m(v));\nf*=s.x;\nfloat x=0.,y=0.;\nfloat i=0.;\n\ndo\n {\n y=m(v);\n v+=y*f*.5;\n y=abs(y);\n x+=y;\n if(y<x*.001) break;\n i+=1./150.;\n if(i>=1.)break;       \n }\nwhile(i<1.);\n    \nif(i>=1.) return vec2(0.);\ns.x*=y*2.;\ns.y=length(d-v);\nreturn s;\n}\n\n\nvec3 t(vec3 v,vec3 y)\n{\nvec2 f;\nvec3 x=vec3(0.,500.,-1.);\nf=p(v,y,vec4(0.,1.,0.,-5.));\nx=mix(x,vec3(f,0.),abs(sign(f.x))*step(f.y,x.y)*step(0.,f.y));\nf=m(v,y,vec4(0.,0.,0.,22500.));\nf.x*=-1.;\nx=mix(x,vec3(f,1.),abs(sign(f.x))*step(f.y,x.y)*step(0.,f.y));\nf=p(v,y);\nx=mix(x,vec3(f,2.),abs(sign(f.x))*step(f.y,x.y)*step(0.,f.y));\nreturn x;\n}\n\nfloat p(vec3 v,vec3 x,float f,float y_)\n{\nfloat y=y_;\nfloat m=sign(f),d=m*.5+.5;\nwhile(y>0.) \n\t{\n    d-=(y*f-p(v+f*x*y*m))/exp2(y);\n    y-=1.;\n\tif(y<=0.) break;\n    }\nreturn clamp(d,0.,1.);\n}\n\nvec4 m(inout vec3 v,vec3 y,vec3 f,out vec3 d,out bvec2 i)\n{\nvec4 s=vec4(0.);\nd=vec3(0.);\ni=bvec2(false,false);\nv+=y*f.y;\nvec3 z=normalize(vec3(0.,35.,0.)+10.*vec3(cos(x*2.),0.,sin(x*2.))-v);\nif(f.z==0.)\n {\n i=bvec2(false,false);\n d=vec3(0.,1.,0.);\n s=.5*vec4(1.,1.,1.,1.);\n s*=max(dot(d,z),0.);\n s+=.2;\n s*=p(v,z,.3,1.);\n float e=.25;\n vec2 n=fwidth(v.xz),a=n*e*2.;\n float w=max(a.x,a.y);\n vec2 t=fract(v.xz*e),l=smoothstep(vec2(.5),a+vec2(.5),t)+(1.-smoothstep(vec2(0.),a,t));\n vec4 E=vec4(.8),N=vec4(.1),o=E*.5+N*.5,r=mix(E,N,l.x*l.y+(1.-l.y)*(1.-l.x));\n r=mix(r,o,smoothstep(.125,.75,w));\n s*=r;\n }\nelse if(f.z==1.)i=bvec2(false,false),d=-normalize(v),\ns=.5*vec4(1.,1.,1.,1.),s*=max(dot(d,z),0.),s*=p(v,z,.3,6.);\nelse if(f.z==2.)\n {i=bvec2(true,true);\n vec2 a=vec2(.1,0.);\n d=normalize(vec3(m(v+a.xyy)-m(v-a.xyy),m(v+a.yxy)-m(v-a.yxy),m(v+a.yyx)-m(v-a.yyx)));\n s=vec4(1.);\n s*=.5*max(dot(d,z),0.);\n s+=2.*pow(max(dot(reflect(z,d),y),0.),16.);\n }\nreturn s;\n}\n\nfloat n(vec3 v,vec3 y)\n{\nreturn R0+(1.-R0)*pow(1.-abs(dot(y,v)),4.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nd = iResolution.xy;    \nvec3 x=vec3(0.,5.,80.),\nf=normalize(vec3(0.,0.,0.)-x),\ny=normalize(vec3(0.,1.,0.)),\ns=cross(f,y),\ni=vec3(0.,0.,0.),\nz=normalize(vec3(vec2(d.x/d.y,1.)*(fragCoord.xy/d-.5),16.));\ni+=x;\n\nz*=transpose(mat3(s,y,f));\n\nvec3 a=t(i,z);\nif(a.x==0.)\n {\n fragColor=vec4(1.,1.,1.,1.);\n return;\n }\nvec3 e;\nbvec2 w;\nvec4 r=m(i,z,a,e,w),p=mix(exp(-a.y*vec4(2.,.5,.3,1.)),vec4(1.),sign(a.x)*.5+.5);\nvec3 E=i,l=z,o=a,b=e;\nbvec2 c=w;\nfloat k=1.;    \nfor(float N=0.;N<3.;++N)\n {\n k*=n(z,e);\n z=reflect(z,e);\n i+=e*a.x;a=t(i,z);\n if(a.x==0.) break;\n r+=m(i,z,a,e,w)*k;\n if(w.x==false)break;    \n }\nw=c,e=b,a=o,z=l,i=E;\n\n k=1.;   \n for(float N=0.;N<6.;++N)\n {\n vec3 A=z;\n p*=1.-n(z,e);\n z=refract(z,e*sign(a.x),mix(ETA,1./ETA,sign(a.x)*.5+.5));\n if(dot(z,z)==0.) z=reflect(A,e),a.x*=-1.;\n i-=e*a.x;\n a=t(i,z);\n if(a.x==0.) break;\n p*=mix(exp(-a.y*1.3*vec4(.1,.3,.5,1.)),vec4(1.),sign(a.x)*.5+.5);\n r+=m(i,z,a,e,w)*p;\n if(w.y==false)break;    \n }\nfragColor = r;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 112, 112, 162], [165, 165, 182, 182, 660], [663, 663, 687, 687, 781], [783, 783, 800, 800, 957], [959, 959, 976, 976, 991], [993, 993, 1023, 1023, 1218], [1220, 1220, 1250, 1250, 1342], [1344, 1344, 1381, 1381, 1617], [1619, 1619, 1642, 1642, 1979], [1982, 1982, 2005, 2005, 2321], [2323, 2323, 2364, 2364, 2514], [2516, 2516, 2575, 2575, 3476], [3478, 3478, 3502, 3502, 3548], [3551, 3551, 3608, 3608, 4573]], "test": "untested"}
{"id": "tdKXzV", "name": "Tesla Cybertruck", "author": "yasuo", "description": "I thought was a concept car, but it is not...", "tags": ["raymerching"], "likes": 6, "viewed": 413, "published": "Public API", "date": "1574513177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 0.25;\n    \n    // body\n    float b = sdBox(p-vec3(0.0,1.0+y,0.0),vec3(1.3,0.7,2.8));\n    float b2 = sdBox(p-vec3(0.0,1.4+y,1.7),vec3(1.1,0.35,1.0));\n    \n    prevP*= matRotateX(radians(15.0));\n    \n    float _cut = prevP.y -1.75-y;\n    prevP = p;\n    \n    prevP*= matRotateX(radians(-8.0));\n    float _cut2 = prevP.y -1.6-y;\n    \n    vec3 hexP = p-vec3(0.0,0.3+y,-0.0);\n    hexP*= matRotateY(radians(90.0));\n    \n    hexP.x = abs(hexP.x);\n    hexP.x -= 1.7;\n    \n    float hex = sdHexPrism(hexP, vec2(0.6,2.0));\n    prevP = p;\n    \n    prevP.x = abs(prevP.x);\n    prevP.x -= 0.3;\n    prevP*= matRotateY(radians(-40.0));\n    \n    float _cut3 = prevP.z +2.5;\n    \n    b = max(-_cut3,max(-b2,max(-hex,max(_cut2,max(_cut,b)))));\n    \n    prevP = p;\n    vec4 resB = vec4(vec3(0.8),b);\n        \n    // ground\n    vec4 f = vec4(vec3(0.3),_floor*0.6);\n    \n    // mud guard\n    vec3 hexP2 = prevP-vec3(0.0,0.31+y,-0.0);\n    hexP2*= matRotateY(radians(90.0));\n    \n    hexP2.x = abs(hexP2.x);\n    hexP2.x -= 1.7;\n    float hex2 = sdHexPrism(hexP2, vec2(0.7,1.45));\n    float hex3 = sdHexPrism(hexP2, vec2(0.6,1.8));\n    prevP = p;\n    float hexCut = prevP.y-0.55;\n    vec4 resMud= vec4(vec3(0.3),max(-hexCut,max(-hex3,hex2)));\n    \n    // tyres\n    vec3 tyreP = prevP-vec3(0.0,0.3+y,-0.0);\n    tyreP*= matRotateX(radians(90.0))*matRotateZ(radians(90.0));\n    tyreP.x = abs(tyreP.x);\n    tyreP.x -= 1.7;\n    tyreP.y = abs(tyreP.y);\n    tyreP.y -= 1.2;\n    float tyre = sdCappedCylinder(tyreP,0.52,0.2);\n    vec4 resTyre = vec4(vec3(0.2),tyre);\n    prevP = p;\n    \n    // side windows\n    prevP.x*=0.99;\n    prevP.z*=1.1;\n    float gy = -0.05+y;\n    float g = sdBox(prevP-vec3(0.0,1.4+gy,0.0),vec3(1.3,0.3,2.8));\n    \n    prevP*= matRotateX(radians(15.0));\n    \n    float _gcut = prevP.y -1.75-gy;\n    prevP = p;\n    \n    prevP*= matRotateX(radians(-8.0));\n    float _gcut2 = prevP.y -1.6-gy;\n    prevP = p;\n    float _gcut3 = prevP.z -0.6;\n    float _gcut4 = prevP.y -1.3-gy;\n    \n    g = max(-_gcut4,max(_gcut3,max(_gcut2,max(_gcut,g))));\n    prevP = p;\n    vec4 resG = vec4(vec3(0.3),g);\n    \n    // front window\n    prevP*= matRotateX(radians(15.0));\n    float fg = sdBox(prevP-vec3(0.0,1.75+y,-0.7),vec3(1.2,0.01,0.7));\n    vec4 resFG = vec4(vec3(0.3),fg);\n    \n    vec4 model = combine(combine( combine(combine(combine(f,resB),resTyre),resG),resFG),resMud);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 535, 576, 576, 667], [669, 669, 705, 705, 747], [749, 749, 778, 778, 862], [864, 864, 916, 916, 1023], [1025, 1025, 1061, 1061, 1334], [1336, 1336, 1358, 1358, 3795], [3797, 3797, 3830, 3830, 4083], [4085, 4085, 4109, 4109, 4310], [4312, 4312, 4346, 4346, 4660], [4662, 4662, 4705, 4705, 5008], [5010, 5010, 5033, 5033, 5434], [5436, 5436, 5478, 5478, 5673], [5675, 5675, 5732, 5732, 6418]], "test": "untested"}
{"id": "tdKXzz", "name": "Knob Moog", "author": "andremichelle", "description": "Getting addicted building knobs.", "tags": ["knob", "moog"], "likes": 21, "viewed": 567, "published": "Public API", "date": "1573307264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define N 6.\n\nconst float r1 = 0.75;\nconst float r2 = 1./r1;\n\nvec4 over( in vec4 a, in vec4 b ) {\n    return mix(a, b, 1.-a.w);\n}\n\nfloat nCap(vec2 uv, float angle, float r) {\n    float a = atan(uv.y, uv.x)+angle;\n    float b = a/PI*N/2.+PI*r2*2.0;\n    float f = fract(b);\n    float l = length(uv);\n    float d = sin(f*PI*r2) * step(f, r1);\n    return (1.-d*0.12)*r-l;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/-iResolution.y*3.0;\n    \n    float av = sin(iTime)*PI*5./6.; // angle value\n    \n    mat2 m = mat2(cos(av), sin(av), -sin(av), cos(av));\n    \n    float a = atan(uv.y, uv.x);\n    float l = length(uv);\n\tfloat g = -1. + smoothstep(.5, -.5, uv.y) * 2.;\n\n    vec4 col = vec4(vec3(.2+g*.04), 1.); // background\n    \n    if(l < .96) {\n\t    float d = .0;\n        for(float q = 0. ; q < 11. ; q += 1.) {\n            float aq = -PI*1./3.+q*PI*1./6.;\n            mat2 m = mat2(cos(aq), sin(aq), -sin(aq), cos(aq));\n            d += smoothstep(.002, .001, line(uv, vec2(.0, .0), vec2(.88, .0)*m)-.012);\n        }\n        col = over(vec4(vec3(.8), d), col); // divs\n\n        float h = smoothstep(.04, .08, 1.25 - distance(vec2(.0, -1.4), uv))*.2\n            + smoothstep(.40, .7, l)*.01;\n        col = over(vec4(vec3(.04), smoothstep(.001, .3, .88 - distance(uv, vec2(.0, .1)))*.75), col); // shadow\n        col = over(vec4(vec3(.04), smoothstep(.001, .04, .74 - l)), col); // bottom\n        col = over(vec4(vec3(.13+g*.04), smoothstep(.001, .01, .71 - l)), col); // bottom solid\n        col = over(vec4(vec3(.13), smoothstep(.02, .001, abs(.64 - l))), col); // bottom outline\n        col = over(vec4(vec3(.04), smoothstep(0.001, 0.06, nCap(uv+vec2(.0, -.12), av, .64))*.7), col); // cap shadow\n        col = over(vec4(vec3(.09), smoothstep(0.01, 0.02, nCap(uv, av, .64))), col); // cap edge\n        col = over(vec4(vec3(.16)+g*.1+h, smoothstep(0.001, 0.01, nCap(uv, av, .61))), col); // cap solid\n        col = over(vec4(vec3(.24), smoothstep(.001, .01, .46 - l)), col); // cap top\n        col = over(vec4(vec3(.44\n                             + pow(abs(sin(a)),10.)*(0.1+l*1.)\n                             + pow(abs(sin(a+1.4)),64.)*0.12\n                             + abs(sin(l*32.)+.5)*.02\n                             + g*.2\n                            ), smoothstep(.001, .01, .44 - l)), col); // cap metal\n        col = over(vec4(vec3(.34), smoothstep(.001, .01, .050 - distance(uv, vec2(.0, -.52)*m))), col); // value edge\n        col = over(vec4(vec3(.97), smoothstep(.001, .01, .042 - distance(uv, vec2(.0, -.52)*m))), col); // value fill\n    }\n    \n    col.gb += vec2(.004, .006);\n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 116, 116, 148], [150, 150, 193, 193, 388], [390, 390, 437, 437, 556], [558, 558, 615, 615, 2864]], "test": "untested"}
{"id": "tdtSD2", "name": "Furthest segment voronoi", "author": "Ultraviolet", "description": "Inspired by [url] https://members.loria.fr/SHornus/fpvd/ [/url].\nPress [b]space[/b] for switching between furthest/closest.\nUse mouse for changing curve parameters.", "tags": ["voronoi", "segment", "furthest"], "likes": 4, "viewed": 80, "published": "Public", "date": "1572946892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float PI = 3.14159;\n\n//const int nbSpire = 5;\n//const int nbSubdiv = 30;\n#define nbSpire   (iMouse.z>0.5?int(1.+iMouse.y/iResolution.y*10.):5)\n#define nbSubdiv  (iMouse.z>0.5?int(iMouse.x/iResolution.x*50.+2.):30)\n\n//const float theta_max = 2.*PI;\n//#define theta_max  (iMouse.x/iResolution.x*2.*PI)\n#define theta_max  (cos(iTime*.2)*1.8*PI)\nconst float rho_min = 0.1;\nconst float rho_max = 1.;\n\nconst float lineWidth = 1.;\n\n//const bool minMax = false;\n#define minMax  (texelFetch(iChannel0, ivec2(32,2), 0).x>0.5)\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 pol2cart(float theta, float rho)\n{\n    return vec2(cos(theta), sin(theta))*rho;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat theta(int spire, int subdiv)\n{\n    return float(spire)/float(nbSpire)*2.*PI + float(subdiv)/float(nbSubdiv-1)*theta_max;\n}\n\nfloat rho(int spire, int subdiv)\n{\n    return rho_min+(rho_max-rho_min)*float(subdiv)/float(nbSubdiv-1);\n}\n\nvec3 spireColor(int spire, float dist)\n{\n    return hsv2rgb_smooth(vec3(float(spire)/float(nbSpire), 0.8, exp(-dist)*.8+.2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord/iResolution.xy - 0.5)*2.*vec2(iResolution.x/iResolution.y, 1.)*1.0;\n\n    vec3 col = vec3(1.);\n\n    float d_min_min = 1000.;\n    float d_max_min = -1000.;\n    float d_min_max = 1000.;\n    float d_max_max = -1000.;\n    \n    int i_min_min = -1;\n    int i_max_min = -1;\n    int i_min_max = -1;\n    int i_max_max = -1;\n    \n    for(int i=0; i<nbSpire; ++i)\n    {\n        \n        float d_i_min = 1000.;\n        float d_i_max = -1000.;\n        for(int j=0; j<nbSubdiv-1; ++j)\n        {\n\t\t\tvec2 p0 = pol2cart(theta(i,j), rho(i,j));\n\t\t\tvec2 p1 = pol2cart(theta(i,j+1), rho(i,j+1));\n            float d = sdSegment(p, p0, p1);\n            \n            d_i_min = min(d_i_min, d);\n            d_i_max = min(d_i_max, d);\n        }\n\n        if(d_i_min<d_min_min)\n        {\n            d_min_min = d_i_min;\n            i_min_min = i;\n        }\n\n        if(d_i_min>d_max_min)\n        {\n            d_max_min = d_i_min;\n            i_max_min = i;\n        }\n\n        if(d_i_max<d_min_max)\n        {\n            d_min_max = d_i_max;\n            i_min_max = i;\n        }\n\n        if(d_i_max>d_max_max)\n        {\n            d_max_max = d_i_max;\n            i_max_max = i;\n        }\n    }\n    \n    float dist = d_max_min;\n    int i = i_max_min;\n    \n    if(minMax)\n    {\n        dist = d_min_min;\n        i = i_min_min;\n    }\n    \n    vec3 n = normalize(vec3(dFdx(dist), dFdy(dist), .02));\n    vec3 l = normalize(vec3(cos(iTime*.5), sin(iTime*.5), 1.1));\n    float phong = max(dot(n,l), 0.0);\n    float spec = 0.5*pow(max(dot(reflect(vec3(0.0, 0.0, -1.0),n),l), 0.0), 256.);\n    col = spireColor(i, 0.) * phong + vec3(spec);\n    \n    col=mix(col,vec3(0.),mix(1.,0.,clamp(d_min_min*iResolution.y/2. -  lineWidth, -1., 1.)*.5+.5));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 526, 578, 578, 688], [690, 690, 729, 729, 776], [778, 778, 812, 812, 990], [992, 992, 1028, 1028, 1120], [1122, 1122, 1156, 1156, 1228], [1230, 1230, 1270, 1270, 1357], [1360, 1360, 1417, 1417, 3194]], "test": "untested"}
{"id": "tdtSDl", "name": "Maths art", "author": "ircss", "description": "start pattern using lines ", "tags": ["patterns"], "likes": 10, "viewed": 286, "published": "Public API", "date": "1573164141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI             3.14159265359\n#define smoothing      0.006\n#define lineWidth      0.002\n\n#define mainLinesColor vec3(0.8,0.2,0.1)\n#define eLinesColor    vec3(0.6,0.8,0.1)\n#define dotColors      vec3(0.1,0.3,0.)\n\nvoid DrawPoint(vec2 pos, vec2 uv,float size, vec3 dotColor, inout vec3 sceneColor){\n    \n    float d    = distance(uv, pos);\n    sceneColor = mix(dotColor, sceneColor, smoothstep(size, size +smoothing, d));\n    \n}\n\nvoid DrawLine(float m, float c, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n\n    vec2  xy   = vec2(uv.x, uv.x * m + c); \n    float d    = distance(xy, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + smoothing, d));\n    \n}\n\nvoid DrawVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size +smoothing, d));\n    \n}\n\nvoid DrawHalfVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size +smoothing, d)+ m, 0. ,1.)); \n}\n\nvoid DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n          m   += step(len, vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + smoothing, d)+ m, 0. ,1.)); \n}\n\nvoid DrawCurveSide(vec2 graphOrigin, vec2 uvCoordinate, float sideLengths, float numberOfPoints, vec2 side1, vec2 side2, inout vec3 col){\n        float side2Sqr        = dot(side2, side2);\n    \n    DrawHalfVectorWithLength( graphOrigin, normalize( side1), sideLengths,uvCoordinate, lineWidth, mainLinesColor, col);\n    DrawHalfVectorWithLength( graphOrigin, side2, sideLengths,uvCoordinate, lineWidth, mainLinesColor, col);\n    \n    \n\n    for(float i = 1. ; i < numberOfPoints; i ++){\n        \n        float f    = (i / numberOfPoints);\n        \n        vec2 point = graphOrigin + normalize(side1) * f*sideLengths;\n        \n        DrawPoint(point, uvCoordinate, 0.01,dotColors, col); \n        \n        // projection on the other line\n        \n             f        = 1.-f;\n        vec2 endPoint = graphOrigin + normalize(side2) * f*sideLengths;\n        \n\n        DrawPoint(endPoint , uvCoordinate,  0.01,dotColors, col); \n        \n        vec2 e    = point - endPoint; \n        \n        DrawHalfVectorWithLength(endPoint, normalize(e), length(e), uvCoordinate,lineWidth*0.1, eLinesColor, col);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---------------------------------------------------------\n    // ---COORDINATE SETUP\n    \n    vec2  uvCoordinate    =  fragCoord/iResolution.xy;\n    float aCorreection    =  iResolution.x/iResolution.y;\n    \n          uvCoordinate.x *=  aCorreection;\n          uvCoordinate   -=  vec2(aCorreection/2., 0.5);\n    \n    // ---------------------------------------------------------\n\tvec3  col             = vec3(0.6,0.6,0.6);\n\n    \n    vec2  graphOrigin     = vec2(clamp(sin(iTime)*0.5, -1.,0.), 0.);\n    float sideLengths     = 0.5;\n    vec2  side1           = vec2(0., -1.);\n    vec2  side2           = vec2(1.,0.);\n    \n    float numberOfPoints  = 12.* abs(sin(iTime*0.4));\n   \n    \n    DrawCurveSide(graphOrigin, uvCoordinate, sideLengths, numberOfPoints, side1, side2, col);\n    \n          graphOrigin     = vec2(clamp(sin(iTime + PI)*0.5, -1.,0.), 0.);\n\n          side1           = vec2(0., 1.);\n          side2           = vec2(1.,0.);\n    \n    DrawCurveSide(graphOrigin, uvCoordinate, sideLengths, numberOfPoints, side1, side2, col);\n    \n       \n          graphOrigin     = vec2(clamp(sin(iTime)*0.5, 0.,1.), 0.);\n\n          side1           = vec2(0., 1.);\n          side2           = vec2(-1.,0.);\n    \n    DrawCurveSide(graphOrigin, uvCoordinate, sideLengths, numberOfPoints, side1, side2, col);\n    \n          graphOrigin     = vec2(clamp(sin(iTime + PI)*0.5, 0.,1.), 0.);\n\n          side1           = vec2(0., -1.);\n          side2           = vec2(-1.,0.);\n    \n    DrawCurveSide(graphOrigin, uvCoordinate, sideLengths, numberOfPoints, side1, side2, col);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 302, 302, 432], [434, 434, 526, 526, 697], [699, 699, 801, 801, 1061], [1063, 1063, 1169, 1169, 1482], [1484, 1484, 1611, 1611, 1961], [1963, 1963, 2100, 2100, 3065], [3068, 3068, 3125, 3217, 4770]], "test": "untested"}
{"id": "tdtSWX", "name": "Overwatch - Round Ended", "author": "LilBensson", "description": "I wanted to try making the effect that shows up when a round is ended in Overwatch. So here is my take on it! :D", "tags": ["2d", "fire", "overwatch", "roundended"], "likes": 10, "viewed": 164, "published": "Public", "date": "1573349940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nfloat PI = acos(-1.0);\n\nfloat Noise(float n)\n{\n    return fract(sin(n*4616.5451 + 566.163) * 7624.564);\n}\n\nfloat Noise21(vec2 n)\n{\n\treturn fract(sin(n.x*1265.63265 + n.y*7427.8432 + 654.163) * 6432.564);\n}\n\nfloat BetterNoise21(vec2 n)\n{\n    float decimalScale = 1000.0;\n    n = round(n*decimalScale)/decimalScale;\n    \n\tn = fract(n*vec2(573.721, 853.712));\n    n += dot(n, n+64.853);\n    \n    return fract(n.x*n.y);\n}\n\nvec2 BetterNoise22(vec2 n)\n{\n\tfloat p = BetterNoise21(n);\n    \n    return vec2(p, BetterNoise21(p+n));\n}\n\nfloat PerlinNoiseLayer(vec2 p)\n{\n\tfloat offsetStep = 1.0;\n    float gridSize = 10.0;\n    \n    vec2 st = smoothstep(0.0, 1.0, fract(p * gridSize));\n    vec2 id = floor(p * gridSize);\n    \n    float upperLeft  = Noise21(id + vec2(0.0, 0.0));\n    float upperRight = Noise21(id + vec2(offsetStep, 0.0));\n    float lowerLeft  = Noise21(id + vec2(0.0, offsetStep));\n    float lowerRight = Noise21(id + vec2(offsetStep, offsetStep));\n    \n    float upperMix = mix(upperLeft, upperRight, st.x);\n    float lowerMix = mix(lowerLeft, lowerRight, st.x);\n    \n    float finalMix = mix(upperMix, lowerMix, st.y);\n    \n\treturn finalMix;\n}\n\nfloat PerlinNoise(vec2 p)\n{\n    float currentNoise = 0.0;\n    \n    currentNoise += PerlinNoiseLayer(p*4.0)/2.0;\n    currentNoise += PerlinNoiseLayer(p*8.0)/4.0;\n    currentNoise += PerlinNoiseLayer(p*16.0)/8.0;\n    currentNoise += PerlinNoiseLayer(p*32.0)/16.0;\n    currentNoise += PerlinNoiseLayer(p*64.0)/32.0;\n    \n    // Returns value from 0 to 0.96875    \n    return currentNoise;\n}\n\nmat2 Rot(float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat Circle(vec2 uv, vec2 position, float radius)\n{\n\tfloat dist = length(uv - position);\n    \n    dist = smoothstep(radius+0.01, radius, dist);\n    \n    return dist;\n}\n\nvec3 MiddleCircles(vec2 uv, vec3 middleBoxColor)  \n{\n    vec3 col = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 50.0; i++)\n    {\n        float movementSpeed = 0.15;\n        float pt = fract(Noise(i*7412.51 + 742.74) + t*movementSpeed);\n        \n    \tvec2 p = vec2(Noise(i*612.63), Noise(i*137.11 + 467.32));\n        p = p * 2.0 - 1.0;\n        p.y *= 0.15;\n        \n        // Slow down as it comes towards the window edge\n        p.x = (1.0 - pow(pt-1.0, 2.0));\n        \n        // Flip back again\n        p.x *= Noise(i*626.31) < 0.5 ? -1.0 : 1.0;\n        \n        float circleSize = Noise(i*213.74) * 0.028;\n        \n        float c = Circle(uv, p, circleSize);\n        float fade = smoothstep(0.9, 0.0, abs(p.x));\n        fade = clamp(fade, 0.0, 1.0);\n        \n        vec3 circleCol = vec3(c) * middleBoxColor * fade;\n        circleCol = circleCol * pow(fade+1.0, 3.0);\n        \n        col += circleCol;\n    }\n    \n    return col;\n}\n\nvec3 MiddleBox(vec2 uv)\n{\n    vec2 distances = abs(uv);\n\tfloat d = distances.y;\n    \n    float height = 0.2;\n    d = smoothstep(height+0.08, height-0.01, d);\n    d *= 0.8;\n    d = pow(d, 5.0);\n    d *= pow((1.0 - abs(uv.y))*1.5, 2.3);\n    \n    float r = d*clamp(uv.x, 0.0, 1.0);\n    float b = d*clamp(-uv.x, 0.0, 1.0);\n    \n    float lineHeight = 60.0;\n    float horizontalLine = Noise(round(uv.y * lineHeight)/lineHeight);\n    horizontalLine = 1.0 - horizontalLine*0.1;\n    \n    vec3 mainBoxCol = vec3(r, 0.0, b) * horizontalLine;\n    vec3 edges = vec3(1.0);\n    edges *= smoothstep(height-0.08, height+0.01, d);\n    edges *= smoothstep(height+0.2, height+0.15, d);\n    edges *= 0.3;\n    \n    return mainBoxCol + edges;\n}\n\nvec3 ThreeMiddleLights(vec2 uv)\n{\n    float toThePower = 3.0;\n    \n\tfloat currentDistance = 0.0;\n    currentDistance += pow(1.0 - length(uv), toThePower);\n    currentDistance += pow(1.0 - length(uv + vec2(0.9, 0.0)), toThePower);\n    currentDistance += pow(1.0 - length(uv - vec2(0.9, 0.0)), toThePower);\n    \n    return vec3(currentDistance*0.8);\n}\n\nvec3 Smoke(vec2 uv)\n{\n    vec3 finalCol = vec3(0.0);\n    \n    for(float layer = 0.0; layer < 3.0; layer++)\n    {\n        float perl = PerlinNoise(uv*0.3 + vec2(0.04 * layer, 0.0) * iTime * sign(uv.x));\n\n        perl *= pow(abs(uv.x), 2.0) * pow((1.0 - abs(uv.y)) * 0.9, 1.0);\n\n        float r = perl * clamp(uv.x, 0.0, 1.0) * 4.0;\n        float b = perl * clamp(-uv.x, 0.0, 1.0) * 4.0;\n\n        float alpha = 0.3;\n        \n        finalCol += vec3(perl) * vec3(r, 0.0, b) * alpha;\n    }\n    \n    \n\treturn finalCol;\n}\n\nvec3 Fire(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    \n    for(float layers = 0.0; layers < 4.0; layers++)\n    {\n        // The fire\n        vec2 speed = vec2(0.0, -0.6) * t  * (1.0 + 0.1*layers);\n        vec2 layerOffset = vec2(632.763, 1631.631) * layers;\n        \n        float n = PerlinNoise(uv + speed + layerOffset);\n\n        // Decrease alpha the further away it is\n        n *= pow(1.0 - length(uv*vec2(1.0, 0.3)), 7.0)*1.2;\n\n        // Decrease alpha below y = 0.0\n        n *= uv.y > 0.0 ? 1.0 : pow(1.0-abs(uv.y), 10.0); \n\n        float threshold = 0.3 * (1.0 - pow(abs(uv.y), 4.0));\n        n *= smoothstep(threshold-0.06, threshold, n);\n        \n        // Actual fire color\n        //col += vec3(n*n, n*n*n, 0.0)*3.0;\n        col += vec3(n)*1.3;\n    }\n    \n\treturn col;\n}\n\nvec3 MiddleFire(vec2 uv)\n{\n    uv *= Rot(-0.2);\n    uv.x *= 2.5;\n    \n    vec3 f = vec3(0.0);\n    f += Fire(uv);\n    f += Fire(-uv);\n    \n    float middleOffset = 0.1;\n    float r = smoothstep(-middleOffset, -middleOffset+0.3, uv.x);\n    float b = smoothstep(middleOffset, middleOffset-0.3, uv.x);\n    \n    float g = smoothstep(middleOffset, 0.05, abs(uv.x));\n    \n    r += g;\n    b += g;\n    \n\treturn f * vec3(r, g, b);\n}\n\nvec2 ClosestPointLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pb = p-b;\n    vec2 ab = a-b;\n    \n\tfloat t = dot(pb, ab) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec2 closestPoint = t*a + (1.0 - t)*b;\n    \n    return closestPoint;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 closestPoint = ClosestPointLine(p, a, b);\n    float d = length(closestPoint - p);\n    \n    float radius = 0.01;\n    \n    float c = smoothstep(radius, radius*0.98, d);\n    return c;\n}\n\nvec2 VoroGetDotPos(vec2 id, vec2 offset)\n{\n    vec2 voroTime = BetterNoise22(id+offset);\n    \n    return sin(voroTime)*0.45 + offset;\n}\n\n// This part was a combination between the voronoi created by The Art Of Code (BigWings)\n// and some of own methods.\nvec3 Voronoi(vec2 uv)\n{\n    float gridSize = 5.0;\n    \n    uv *= gridSize;\n    \n    vec2 st = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 dotGrid = st;\n    \n    vec2 dotPos = VoroGetDotPos(id, vec2(0.0));\n    \n    float dotRadius = 0.1;\n    \n    float l = length(dotGrid - dotPos);\n    float d = smoothstep(dotRadius, dotRadius-0.01, l);\n    \n    vec2 closestNeighbor = vec2(0.0);\n    float closestNeighborDist = 1000.0;\n    \n    float lineCol = 0.0;\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n    \tfor(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 currentPos = VoroGetDotPos(id, vec2(x, y));\n            \n            // Find best neighbor\n            if(length(currentPos-st) < closestNeighborDist)\n            {\n                closestNeighborDist = length(currentPos-st);\n                closestNeighbor = id + vec2(x, y);\n            }\n            \n        \tlineCol += Line(st, dotPos, currentPos);\n        }\n    }\n    \n    // Take the sides into consideration\n    vec2 up = VoroGetDotPos(id, vec2( 0.0,  1.0));\n    vec2 down = VoroGetDotPos(id, vec2( 0.0, -1.0));\n    vec2 right = VoroGetDotPos(id, vec2( 1.0,  0.0));\n    vec2 left = VoroGetDotPos(id, vec2(-1.0,  0.0));\n    \n    lineCol += Line(st, up, right);\n    lineCol += Line(st, up, left);\n    lineCol += Line(st, down, right);\n    lineCol += Line(st, down, left);\n    \n    float randCol = BetterNoise21(closestNeighbor);\n    \n    vec3 col = vec3(randCol);\n    //col += vec3(lineCol);\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized uv coordinates\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y; \n    \n    vec3 col = vec3(0.0);\n    \n    // Voronoi\n    col += Voronoi(uv)*0.20 * pow(length(uv), 3.0);\n    \n    // Red/Blue box in the background\n    vec3 b = MiddleBox(uv);\n    col += b;\n    \n    // Circles\n    col += MiddleCircles(uv, b);\n    \n    // Smoke from the sides\n    col += Smoke(uv);\n    \n    // Three middle lights\n    col += ThreeMiddleLights(uv) * (b+0.3);\n    \n    // Fire in the middle\n    col += MiddleFire(uv);\n    \n    //col = Fire(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 63, 63, 122], [124, 124, 147, 147, 222], [224, 224, 253, 253, 434], [436, 436, 464, 464, 540], [542, 542, 574, 574, 1165], [1167, 1167, 1194, 1194, 1554], [1556, 1556, 1579, 1579, 1665], [1667, 1667, 1719, 1719, 1835], [1837, 1837, 1889, 1889, 2770], [2772, 2772, 2797, 2797, 3494], [3496, 3496, 3529, 3529, 3845], [3847, 3847, 3868, 3868, 4363], [4365, 4365, 4385, 4385, 5148], [5150, 5150, 5176, 5176, 5572], [5574, 5574, 5621, 5621, 5810], [5812, 5812, 5848, 5848, 6037], [6039, 6039, 6081, 6081, 6174], [6176, 6293, 6316, 6316, 7780], [7782, 7782, 7839, 7872, 8452]], "test": "untested"}
{"id": "tdtXDs", "name": "Metallic tiles", "author": "Kanata", "description": "looks like light over metallic tiles", "tags": ["math", "mathematics"], "likes": 4, "viewed": 274, "published": "Public API", "date": "1573174838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          uv = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 20.0;\n\n    float x = uv.x* scale;\n    float y = uv.y* scale;\n    \n    float a = 1.* sin(0.5* t);\n    float b = 10.* sin(1.2* t);\n    float c = 8.* sin(1.3* t);\n    float d = 10.* sin(1.4* t);\n    float e = 100.* sin(1.* t);\n    float f = -1.* sin(0.78* t);\n    float g = 12.* sin(1.7* t);\n    float h = 6.* sin(1.7* t);\n    float i = 6.* sin(1.7* t);\n    \n    float p = a* x* x* x* x + b* x* x *x + c* x* x + d* x + e\n        + tan(x)* tan(x)* tan(x)* tan(x)* tan(x);\n    float q = f* y* y* y* y + g* y* y* y + h* y* y + i* y\n        + tan(y)* tan(y)* tan(y)* tan(y)* tan(y);\n        \n    O = vec4(vec3(1. / pow(p - q, .15)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 793]], "test": "untested"}
{"id": "tdtXRl", "name": "Outrun Style Ray Marching", "author": "Jordan", "description": "Modified from the tutorial on \"The Art of Code\" https://www.youtube.com/watch?v=PGtv-dBi2wE ", "tags": ["raymarching", "raymarching", "raymarch", "80s", "sphere", "sky", "outrun", "neon", "synthwave"], "likes": 3, "viewed": 141, "published": "Public", "date": "1572667038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MIN_DIST 0.01\n#define MAX_DIST 100.\n\n\nfloat GetDist(vec3 p)\n{\n    vec4 sphere = vec4(0.,pow(sin(iTime),2.)+1.,6.+pow(sin(iTime),2.)*0.5,1.);\n    float d_sphere = length(p-sphere.xyz) - sphere.w;\n    float d_plane = p.y;\n    float d = min(d_plane,d_sphere);\n    return d;\n}\n\n\n\nvec2 RayMarch(vec3 r_origin, vec3 r_direction)\n{\n    float d_origin = 0.;\n    float min_dist = 1000000.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n        vec3 p = r_origin + d_origin*r_direction;\n        float d_surf = GetDist(p);\n        min_dist = min(d_surf, min_dist);\n        d_origin += d_surf;\n        if(d_surf<MIN_DIST || d_origin>MAX_DIST) break;\n    }\n    \n    return vec2(d_origin,min_dist);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3( \n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p)\n{\n\n    vec3 rgb = vec3(0.,0.,0.);\n    vec3 lightPos = vec3(0,3,6);\n    \n    \n    lightPos.xz += vec2(5.*sin(iTime),5.*cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    vec2 rm = RayMarch(p+n*MIN_DIST*1.1,l);\n    float mindist = rm.y;\n    float d = rm.x;\n    if(d<length(lightPos-p)) dif*=0.1;\n    vec3 lightCol = vec3(0,0,0);\n    if(d>=MAX_DIST)\n    \tlightCol = 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));\n    \n    rgb = dif+lightCol;\n    \n    return rgb;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    vec3 r_origin = vec3(0,1,0);\n    vec3 r_direction = normalize(vec3(uv.x,uv.y,1));\n    vec2 rm = RayMarch(r_origin, r_direction);\n    float mindist = rm.y;\n    float dist = rm.x;\n    vec3 p = r_origin + r_direction*dist;\n    vec3 diffuse = GetLight(p);\n    vec3 col = diffuse;\n    \n    fragColor = vec4(col*mindist*2. +vec3(1.5*col.y/dist,0.3*col.z/dist,0.3*col.x/dist),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 92, 92, 303], [307, 307, 355, 355, 719], [721, 721, 745, 745, 941], [943, 943, 966, 966, 1517], [1521, 1521, 1576, 1576, 2020]], "test": "untested"}
{"id": "tdVXRd", "name": "[delete]2D BSpline", "author": "delete", "description": "2d bspline, quadratic bspline, cubic bspline, bezier spline, quadratic analytical bezier spline, cardinal cubic curve, lagrange interpolation", "tags": ["bspline"], "likes": 9, "viewed": 250, "published": "Public", "date": "1575152476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n\n/*\nenable quadratic bezier spline\n1 based on cubic polynomial\n2 based on barycentric coordinate\n*/\n//#define BEZIERANALYTIC 2\n\n#ifndef BEZIERANALYTIC\n\t/*\n\t0 cardinal cubic\n\t1 lagrange interpolation\n\t2 bezier spline\n\t3 Bspline quadratic\n\t4 Bspline cubic\n\t*/\n\t#define CURVETYPE 3\t\n\tconst int controlPointIndex=2;\t\n\t#if 0\n\tconst int P_COUNT=4;\n\tfloat Py[P_COUNT]=float[](0.,2.,1.,2.);\n\tfloat Px[P_COUNT]=float[](1.,1.,3.,3.);\n\t#else\n\tconst int P_COUNT=7;\n\tfloat Py[P_COUNT]=float[](0.,1.,2.,1.,2.,1.,0.);\n\tfloat Px[P_COUNT]=float[](1.,0.,1.,2.,3.,4.,3.);\n\t#endif\n\t\n#else\n\tconst int controlPointIndex=1;\n\tconst int P_COUNT=3;\n\tfloat Py[P_COUNT]=float[](0.,2.,0.);\n\tfloat Px[P_COUNT]=float[](1.,3.,3.);\n#endif \n\n\nvec2 barycentricCoord(vec2 v,vec2 v1,vec2 v2){return inverse(mat2(v1,v2))*v;}\n\nint fact(int n){\n    int res=1;\n    while(n>1){res*=n;--n;}\n    return res;\n}\nint C(int n,int k){return fact(n)/(fact(n-k)*fact(k));}\nvec3 checkboard(vec2 uv){\n\tuv=floor(uv);\n    return vec3(mod(uv.x+uv.y,2.))-0.8;\n}\n\nfloat lineSDF(vec2 p,vec2 p1,vec2 p2){\n\tvec2 v1=p-p1;\n    vec2 v2=p2-p1;\n    vec2 projv1ATv2=dot(v1,v2)*v2/dot(v2,v2);\n    vec2 k=projv1ATv2/v2;\n    \n    if(k.x<0.||k.y<0.)return length(v1);\n    if(k.x>1.||k.y>1.)return length(p-p2);\n\tfloat d=length(v1-projv1ATv2);\n    return d;\n}\nfloat unionSDF(float d1,float d2){return min(d1,d2);}\nfloat CardinalCubic(vec2 xy){\n    float k=3.*sin(iTime*2.);    //0 catmull rom spline\n\tfloat s=(1.-k)/2.;    //scale factor\n\tmat4 B=mat4(0,1,0,0,\n    \t\t-s,0,s,0,\n    \t\t2.*s,s-3.,3.-2.*s,-s,\n    \t\t-s,2.-s,s-2.,s);\n    B=transpose(B);\n    int i=2;\n    float d=100.;\n    const int segments=20;\n    vec2 a,b;\n    a=vec2(Px[1],Py[1]);\n    for(int i=2;i<P_COUNT-1;++i){     \n    \tvec4 py=vec4(Py[i-2],Py[i-1],Py[i],Py[i+1]);\n    \tvec4 px=vec4(Px[i-2],Px[i-1],Px[i],Px[i+1]);   \t\n    \tvec4 ay=B*py;\n    \tvec4 ax=B*px;\n    \tfor(int j=1;j<=segments;++j){\n    \t\tfloat t=float(j)/float(segments);\n    \t    vec4 u=vec4(1.,t,t*t,t*t*t);\n    \t    b=vec2(dot(u,ax),dot(u,ay));\n            d=unionSDF(d,lineSDF(xy,a,b));\n    \t\ta=b;\n        }\n    }\n    return d;\n}\n\nfloat LagrangeInterpolation(vec2 xy){\n    const float interval=0.1;\n    const int pointNum=int(float(P_COUNT-1)/interval)+1;\n    vec2 A,B;\n    A=vec2(Px[0],Py[0]);\n    float d=100.;\n    for(int k=1;k<pointNum;++k){\n        B=vec2(0.);\n        float t=float(k)*interval;\n    \tfor(int i=0;i<P_COUNT;++i){\n    \t    float b=1.;\n    \t    for(int j=0;j<P_COUNT;++j){\n    \t    \tif(i==j)continue;\n    \t    \tb*=(t-float(j))/float(i-j);\n    \t    }\n    \t    B+=b*vec2(Px[i],Py[i]);\n    \t}\n        d=unionSDF(d,lineSDF(xy,A,B));\n        A=B;\n    }\n    return d;\n}\n\nfloat BezierSpline(vec2 xy){  \n    float c[P_COUNT];\n    int hn=P_COUNT/2;\n    for(int i=0;i<=hn;++i){\n    \tc[i]=float(C(P_COUNT-1,i));\n        c[P_COUNT-1-i]=c[i];\n    }\n    const int pointNum=40;\n    vec2 A,B;\n    A=vec2(Px[0],Py[0]);\n    float d=length(xy-A);\n    for(int k=1;k<=pointNum;++k){\n    \tfloat t=float(k)/float(pointNum);\n        B=vec2(0.);\n        for(int i=0;i<P_COUNT;++i){\n        \tB+=c[i]*pow(t,float(i))*pow(1.-t,float(P_COUNT-1-i))*vec2(Px[i],Py[i]);\n        }\n        d=unionSDF(d,lineSDF(xy,A,B));\n        A=B;\n    }\n    return d;\n}\n\nvec3 cubicRoot(float a,float b,float c,float d){\n\tvec3 res;\n    float p=(a*c-b*b/3.)/(a*a);\n    float q=(2.*b*b*b/27.-a*b*c/3.+a*a*d)/(a*a*a);\n    float der=(p*p*p/27.+q*q/4.);\n    if(der<0.){\n        //Trigonometric solution\n        for(int i=0;i<3;++i){\n        \tres[i]=2.*sqrt(-p/3.)*cos(1./3.*acos(3.*q/(2.*p)*sqrt(-3./p))-float(i)*2.*3.141592653/3.)-b/(3.*a);\n        }\n    }else if(der>0.){\n        //Cardano's method, only the real root, the other two complex roots can be computed by muliply (1+-sqrt(3))/2\n        float temp=sqrt(der);\n        vec2 z=-q/2.+vec2(temp,-temp);\n    \tz=sign(z)*pow(abs(z),vec2(1./3.));\n        res=vec3(z.x+z.y-b/(3.*a)); \n    }else{\n\t\tres=vec3(1,-0.5,-0.5)*3.*q/p-b/(3.*a); \n    }\n\treturn res;\n}\n\n\nfloat BezierSplineQuadAnalytic1(vec2 xy){\n\tfloat d=100.;\n    vec2 A=vec2(Px[2],Py[2])-2.*vec2(Px[1],Py[1])+vec2(Px[0],Py[0]);\n    vec2 B=(vec2(Px[1],Py[1])-vec2(Px[0],Py[0]));\n\tvec2 p=vec2(Px[0],Py[0])-xy;\n    vec3 a=clamp(cubicRoot(dot(A,A),3.*dot(A,B),dot(A,p)+2.*dot(B,B),dot(B,p)),0.,1.);\n    for(int i=0;i<3;++i){\n    \td=unionSDF(d,length(a[i]*a[i]*A+2.*B*a[i]+p));\n    }    \n    return d;\n}\nfloat BezierSplineQuadAnalytic2(vec2 xy){\n    vec2 p0=vec2(Px[0],Py[0]),p1=vec2(Px[1],Py[1]),p2=vec2(Px[2],Py[2]);\n\tvec2 v1=p1-p0,v2=p2-p0;\n    vec2 uv=barycentricCoord(xy-p0,2.*v1,v2-2.*v1);\n    return uv.x*uv.x-uv.y;\n}\n\n\n//uniform quad Bspline\nfloat BsplineQuad(vec2 xy){\n    float d=100.;\n    const int kk=3;\n    const int num0=10;\n    const int num1=num0*kk+1;\n    \n    float b[num1];\n    b[0]=0.;\n    int hn=(num1+1)/2;\n    for(int j=0;j<hn;++j){\n        float t=float(j)/float(num0);\n        float tt=fract(t);\n        if(t<1.){\n        \tb[j]=tt*tt*0.5;\n        }\n        else if(t>=1.&&t<2.){\n        \tb[j]=-tt*tt+tt+0.5;\n        }\n        b[num1-1-j]=b[j];\n    }\n    vec2 A,B;\n\tfor(int k=0;k<kk;++k){\n    \tA+=b[(kk-1-k)*num0]*vec2(Px[k],Py[k]);\n    }\n    for(int i=0;i<P_COUNT-kk+1;++i){\n        for(int j=1;j<=num0;++j){\n            B=vec2(0.);\n            for(int k=0;k<kk;++k){\n            \tB+=b[(kk-1-k)*num0+j]*vec2(Px[k+i],Py[k+i]);\n            }\n            d=unionSDF(d,lineSDF(xy,A,B));\n            A=B;\n        }\n    }\n\treturn d;\n}\n\n//uniform\nfloat BsplineCubic(vec2 xy){\n\tfloat d=100.; \n    const int kk=4;\n    const int num0=10;\n    const int num1=num0*kk+1;\n    \n    float b[num1];\n    b[0]=0.;\n    int hn=(num1+1)/2;\n    for(int j=0;j<hn;++j){\n        float t=float(j)/float(num0);\n        float tt=fract(t);\n        if(t<1.){\n        \tb[j]=tt*tt*tt/6.;\n        }\n        else if(t>=1.&&t<2.){\n        \tb[j]=(3.*tt*(tt*(1.-tt)+1.)+1.)/6.;\n        }\n        else if(t>=2.&&t<3.){\n        \tb[j]=(2.*tt*tt*(tt-2.)+4.)/6.;\n        }\n        b[num1-1-j]=b[j];\n    }  \n    vec2 A,B;\n\tfor(int k=0;k<kk;++k){\n    \tA+=b[(kk-1-k)*num0]*vec2(Px[k],Py[k]);\n    }\n    for(int i=0;i<P_COUNT-kk+1;++i){\n        for(int j=1;j<=num0;++j){\n            B=vec2(0.);\n            for(int k=0;k<kk;++k){\n            \tB+=b[(kk-1-k)*num0+j]*vec2(Px[k+i],Py[k+i]);\n            }\n            d=unionSDF(d,lineSDF(xy,A,B));\n            A=B;\n        }\n    }\n\treturn d;\n}\n\n\n\n\nfloat func(vec2 xy){\n    float f=xy.y-xy.x;\n    \n    #ifdef BEZIERANALYTIC\n    switch(BEZIERANALYTIC){\n        case 1:\n    \treturn BezierSplineQuadAnalytic1(xy);\n        case 2:\n        return BezierSplineQuadAnalytic2(xy);\n    }\n    #else\n    switch(CURVETYPE){\n    \tcase 0:\n        f=CardinalCubic(xy);\n        \tbreak;\n        case 1:\n        f=LagrangeInterpolation(xy);\n        \tbreak;\n        case 2:\n        f=BezierSpline(xy);\n        \tbreak;\n        case 3:\n        f=BsplineQuad(xy);\n        \tbreak;\n        case 4:\n        f=BsplineCubic(xy);\n        \tbreak;\n    }   \n    #endif\n    return f;\n}\n\nvec2 funcGrad(vec2 uv){\n    vec2 h=vec2(0.01,0);\n    return vec2(func(uv+h)-func(uv-h),func(uv+h.yx)-func(uv-h.yx))/(2.*h.x);\n}\n\nfloat pointSDF(vec2 uv){\n\tfloat d=100.;\n    for(int i=0;i<P_COUNT;++i){\n    \td=unionSDF(d,length(uv-vec2(Px[i],Py[i])));\n    }\n\treturn d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y*=iResolution.y/iResolution.x;\n    uv*=7.;\n    uv.x-=1.5;\n    uv.y-=1.0;\n    \n    vec2 mo=iMouse.xy/iResolution.xy;\n    mo.y*=iResolution.y/iResolution.x;\n    mo*=7.;\n    mo.x-=1.5;\n    mo.y-=1.0;\n    mo.x-=Px[controlPointIndex];\n    mo.y-=Py[controlPointIndex];\n    \n\n\tvec3 bgColor=checkboard(uv);\n    if(abs(uv.x)<.02||abs(uv.y)<.02)bgColor=vec3(0.0,0.3,.1);\n    vec3 col=bgColor;\n    \n    Py[controlPointIndex]+=mix(sin(iTime)*1.5,mo.y,step(1.,iMouse.z));\n    Px[controlPointIndex]+=mix(0.,mo.x,step(1.,iMouse.z));\n    //plot\n    float f=(func(uv))/length(funcGrad(uv));\n    //float f=abs(func(uv));\n    float e=0.01;\n   \tcol=mix(vec3(0.9),col,smoothstep(0.01,0.02,f));\n    f=sign(f)*clamp((sin(f*100.)*0.5-0.5)*(1.-f)+1.,0.,1.);\n    if(f>0.)col=mix(vec3(0.4),col,f);\n    else col=mix(vec3(0.8,0.5,0.),col,f);\n    \n    //show points\n    float d=smoothstep(0.03,0.04,pointSDF(uv));\n    col=mix(vec3(1.0,0.7,0.0),col,d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 732, 778, 778, 809], [811, 811, 827, 827, 888], [889, 889, 908, 908, 944], [945, 945, 970, 970, 1027], [1029, 1029, 1067, 1067, 1310], [1311, 1311, 1345, 1345, 1364], [1365, 1365, 1394, 1394, 2112], [2114, 2114, 2151, 2151, 2665], [2667, 2667, 2695, 2695, 3223], [3225, 3225, 3273, 3273, 3959], [3962, 3962, 4003, 4003, 4358], [4359, 4359, 4400, 4400, 4579], [4582, 4605, 4632, 4632, 5408], [5410, 5420, 5448, 5448, 6322], [6327, 6327, 6347, 6347, 6931], [6933, 6933, 6956, 6956, 7060], [7062, 7062, 7086, 7086, 7201], [7202, 7202, 7259, 7309, 8342]], "test": "untested"}
{"id": "tdVXWV", "name": "1D SDF Primitives", "author": "edubart", "description": "Why not use SDFs for 1D too? It can be an easy introduction for a beginner in the concept.", "tags": ["sdf", "distance", "1d"], "likes": 8, "viewed": 501, "published": "Public API", "date": "1575059746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by edubart - https://github.com/edubart\n//\n// Why not use SDFs for 1D too? It can be an easy introduction\n// for a beginner in the concept. If you consider the space of\n// a single line the signed distance from points and segments\n// can be computed using a SDF function. Operatios like\n// limited repetition, space scaling, translating, etc\n// works the same as in 2D/3D.\n//\n// This shader contains the following 1D SDF primitives examples:\n// 1. The first line shows the signed field for a point.\n// 2. The second line shows the signed field for a segment.\n// 3. The third line shows the signed field for a half line.\n// 4. The forth line shows SDF operations like scale and limited repetition.\n//\n// Inspired by Inigo Quilez 2D/3D SDF primitives.\n\n#define LINE_HEIGHT 0.03\n\n// Point at the origin\nfloat sd_point(float p) {\n\treturn abs(p);\n}\n\n// Line segment with its center at the origin\nfloat sd_segment(float p, float size) {\n\treturn abs(p) - size;\n}\n\n// Half line begining at the origin and going to the left\nfloat sd_halfline(float p) {\n\treturn p;\n}\n\n// 1D limited repetition\nfloat op_rep_lim(float p, float c, float l) {\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// First scene (point)\nfloat map1(float p) {\n    float q = p - sin(iTime)*0.1;\n   \treturn sd_point(q);\n}\n\n// Second scene (line segment)\nfloat map2(float p) {\n    float size = 0.3 + sin(iTime)*0.2;\n    return sd_segment(p, size);\n}\n\n// Third scene (half line)\nfloat map3(float p) {\n    float q = p - sin(iTime)*0.1;\n   \treturn sd_halfline(q);\n}\n\n// Fourth scene (many elements)\nfloat map4(float p) {\n    // scale space\n    p *= 0.9+0.1*sin(iTime);\n    \n    // repeated points\n    float q = op_rep_lim(p - -0.4, 0.1, 2.0);\n    float d = sd_point(q);\n    \n    // line segment\n    d = min(d, sd_segment(p - 0.2, 0.1));\n    \n    // half line\n    d = min(d, sd_halfline(-(p - 0.6)));\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // screen uv coords in the range [-1,1]\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    \n    // current view point in the line in the range [-1,1]\n\tfloat p = uv.x;\n    \n    // compute the neartest point\n    float d;\n    if(abs(uv.y - 0.6) < LINE_HEIGHT) { // first line\n        d = map1(p);\n    } else if(abs(uv.y - 0.2) < LINE_HEIGHT) { // second line\n        d = map2(p);\n    } else if(abs(uv.y + 0.2) < LINE_HEIGHT) { // third line\n        d = map3(p);\n    } else if(abs(uv.y + 0.6) < LINE_HEIGHT) { // third line\n        d = map4(p);\n    } else {\n        // background\n    \tfragColor = vec4(vec3(0.03),1.0);\n        return;\n    }\n\n    // colorize distance field\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-2.0*abs(d));\n    col *= 0.8 + 0.2*cos(320.0*d);\n    col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[788, 811, 836, 836, 854], [856, 902, 941, 941, 966], [968, 1026, 1054, 1054, 1067], [1069, 1094, 1139, 1139, 1180], [1182, 1205, 1226, 1226, 1286], [1288, 1319, 1340, 1340, 1413], [1415, 1442, 1463, 1463, 1526], [1528, 1560, 1581, 1600, 1876], [1878, 1878, 1933, 1977, 2839]], "test": "untested"}
{"id": "tdVXzK", "name": "Random Pipes", "author": "kamyarinfinity", "description": "A procedural pipe connection", "tags": ["procedural", "2d"], "likes": 3, "viewed": 59, "published": "Public", "date": "1574488347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define INF 1000000.\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec2 repeat(vec2 uv, vec2 tile, vec2 off) {\n    return fract(uv * tile-off);\n}\n\nfloat circle(vec2 uv, float radius) {\n \tfloat c = length(uv - 0.5);\n    return c - radius;\n}\nvec3 norm_circle(vec2 uv, float radius) {\n    vec2 n2d = (uv - 0.5);\n    return normalize(vec3(n2d, sqrt(radius*radius-dot(n2d,n2d))));\n}\n\nvec2 line(vec2 uv, vec2 xy, float thickness) {\n    return abs (uv - xy).yx - thickness;\n}\n\nvec4 norm_line(vec2 uv, vec2 xy, float thickness) {\n    vec2 dist = (uv - xy).yx;\n    vec2 up=sqrt(thickness*thickness-dist*dist);\n    return vec4(normalize(vec2(dist.x,up.x)),\n                normalize(vec2(dist.y,up.y)));\n}\n\nvec2 pipe_id(vec2 uv, vec2 tile, vec2 off) {\n\treturn floor(uv * tile + off);\n}\n\nfloat random_select(vec2 id) {\n\treturn INF*(1.-floor(rand(id)+0.5));\n}\n\nfloat mask(float d) {\n  vec2 R = iResolution.xy;\n  float mx = max(R.x, R.y);\n  return smoothstep(1.0,.0,(d+10./mx)*mx/20.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 R = iResolution.xy;\n  float mx = max(R.x, R.y);\n  vec2 center = R / 2.0;\n  vec2 uv_static = fragCoord.xy / mx;\n  vec2 uv_full = uv_static;\n\n  uv_full += iTime/10.0;\n    \n  const float tile_size = 10.0;\n  const float radius = 0.33;\n    \n  vec2 uv = repeat(uv_full, vec2(tile_size), vec2(0.0));\n    \n  float c = circle(uv, radius);\n  \n  vec2 l = line(uv,vec2(0.5), 0.15);\n  \n  vec2 id1 = pipe_id(uv_full, vec2(tile_size), vec2(0.5, 0.0));\n  vec2 id2 = pipe_id(uv_full, vec2(tile_size), vec2(0.0, 0.5));\n    \n  l.x += random_select(id1*1.1);\n  l.y += random_select(id2);\n\n  float col = c;\n  col = min(col, l.x);\n  col = min(col, l.y);\n  col = mask(col);\n    \n  float mask_c = mask(c);\n  float mask_l = col - mask_c;\n    \n  // lighting\n  vec3 pos = vec3(uv_static, max(-c,0.0));\n  vec3 light_pos = vec3(0.7,0.7,0.6);\n  light_pos.xy = vec2(cos(iTime)*cos(iTime/2.0),sin(iTime)*cos(iTime/2.0));\n  vec3 light_dir = light_pos - pos;\n  light_dir = normalize(light_dir);\n    \n  vec3 red = vec3(1,0,0);\n  vec3 yellow = vec3(1,1,0);\n  vec3 white = vec3(1.);\n  vec3 sky_blue = vec3(0.5,0.8,1.);\n\n  // background shading\n  float light_dist = clamp(1.-length(light_pos.xy-uv_static),0.0,1.0);\n  vec3 bg = white * light_dist + sky_blue * (1. - light_dist);\n  float bg_mask = 1. - mask_c - mask_l;\n  vec3 col_bg = bg * bg_mask;\n  \n  // sphere shading\n  vec3 col_c = mask_c * (red * dot(norm_circle(uv, radius), light_dir));\n  col_c = max(col_c,0.0);\n  col_c = mix(sky_blue*0.3,col_c, length(col_c));\n\n  // cylinder shading\n  vec4 nl = norm_line(uv,vec2(0.5), 0.15);\n  vec3 col_l = max(mask_l * (yellow * dot(vec3(0.0,nl.xy), light_dir)),0.0);\n  col_l += max(mask_l * (yellow * dot(vec3(nl.z,0.0,nl.w), light_dir)),0.0);\n\n  fragColor = vec4(col_c + col_l + col_bg, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 134], [136, 136, 179, 179, 214], [216, 216, 253, 253, 308], [309, 309, 350, 350, 446], [448, 448, 494, 494, 537], [539, 539, 590, 590, 764], [766, 766, 810, 810, 844], [846, 846, 876, 876, 916], [918, 918, 939, 939, 1044], [1046, 1046, 1103, 1103, 2865]], "test": "untested"}
{"id": "tdVXzy", "name": "Another FBM Remix", "author": "dust", "description": "More FBM fun between builds", "tags": ["procedural", "noise", "fbm", "rgb", "animation"], "likes": 0, "viewed": 53, "published": "Public", "date": "1574363887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv));\n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))),\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))));\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n        \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = offs;//soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n// Compute fractal noise for a given pixel position\nvec3 fbm(vec2 uv)\n{\n    const uint depth = 24u;\n    const vec2 dFreq = vec2(1.01f, 1.02f);\n    const float dAmpl = 1.2f;\n    vec2 srct = vec2(1.0f);//vec2((sin(iTime) * 0.1f, cos(iTime) * 0.1f));// + vec2(200.0f);\n    vec2 t = srct;//min((srct * (0.075 / log(srct)) + sin(srct * 0.01)), 400.0);\n    vec2 sfreq = vec2(1.01f + (sin(t) * 2.0)); // Starting noise scaling frequency\n    vec2 rfreq = vec2(1.1f); // Starting noise rotational frequency\n    float ampl = 0.25f; // Starting noise intensity\n    float f = 0.0f;\n    for (uint i = 0u; i < depth; i += 1u)\n    {\n        float f0 = Perlin(uv);\n        f += ampl * f0 * abs(Perlin(uv));\n        ampl *= dAmpl;\n        uv += (sfreq + rfreq) * ampl;\n    }\n    return vec3(f, pow(ampl, dAmpl), uv.x * uv.y);\n}\n\n//#define NOISE_MIRR\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    float cellSize = 0.0825f + Perlin((fragCoord / iResolution.y + (sin(vec2(iTime, log(iTime))) + 1.8f)) * 0.01f);\n    #ifdef NOISE_MIRR\n    \tfloat hAspect = (iResolution.x / iResolution.y) * 0.5f;\n    \tvec2 uv = abs((fragCoord / iResolution.y) - vec2(hAspect, 0.5f)) / cellSize;\n    #else\n    \tvec2 uv = (fragCoord / iResolution.y) / cellSize;\n    #endif\n    //uv += (vec2(0.1) + texture(iChannel1, uv).rr) * 0.1;\n    // Generate per-channel fbm()\n    // fbm(p + fbm(p + fbm(p)))\n    // FBM recursion function from iq through the Book of Shaders:\n    // http://www.iquilezles.org/www/articles/warp/warp.htm\n    // https://thebookofshaders.com/13/\n    vec2 uv2 = uv + vec2(sin(iTime), cos(iTime));\n\tvec3 rgb = fbm(uv + fbm(uv2).xy); //vec3(r, g, r * g);\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 122, 144, 144, 653], [655, 696, 717, 717, 859], [861, 928, 951, 982, 2443], [2445, 2497, 2516, 2516, 3255], [3257, 3278, 3333, 3400, 4218]], "test": "untested"}
{"id": "tdVXzz", "name": "Raytracing Sphere", "author": "foez", "description": "using raytracing to plot a sphere and moving it with sines and cosines,\nMy question is why is it getting distorted and how do i fix it?", "tags": ["question"], "likes": 2, "viewed": 118, "published": "Public", "date": "1573307505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool rayIntersect(vec3 ro, vec3 rd) {\n\tfloat time = iTime;\n    vec3 sphere_center = 3.*vec3(sin(time)*cos(time), cos(time), 0);\n    vec3 sphere_to_ray = ro - sphere_center;\n    \n    float a = dot(rd, rd);\n    float b = 2.*dot(rd, sphere_to_ray);\n    float c = dot(sphere_to_ray, sphere_to_ray) - 0.2;\n    \n    return b*b - 4.*a*c > 0.;\n    \n}\n\nvec4 render(vec2 uv)\n{ \n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    \n    vec3 col = vec3(0);\n    if(rayIntersect(ro, rd)) {\n        col = vec3(1);\n    }\n    \n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2.*fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    fragColor = render(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 342], [344, 344, 366, 366, 562], [564, 564, 621, 621, 741]], "test": "untested"}
{"id": "tdyXDz", "name": "Ad Vitellionem Paralipomena", "author": "blauwmaan", "description": "Good help from tutorial Art of Code... my first shader.", "tags": ["circle"], "likes": 1, "viewed": 200, "published": "Public API", "date": "1573774474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\n\nvec2 random (vec2 p) {\n  vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n                 \n               \n}\n\n                 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n   \n    float m = 0.;\n    float t = iTime;\n  \n    \n    float minDist = 1.;\n    float cellSet = 0.;\n     vec3 col = vec3(0);\n   \n        for(float i=0.; i<100.; i++) {\n            vec2 n = random(vec2(i));\n            vec2 p = sin(n*t)*1.5;\n\n            float d = length(uv-p);\n            m += smoothstep(.05, .03, d);\n\n             if(d<minDist) {\n                 minDist = d;\n                 cellSet = i;\n\n             }\n            col = vec3(minDist);\n        \t}\n    \n       \n \t\n    col += Circle(uv, vec2(0.4*sin(t), -0.1), .4, 0.04);\n    col -= Circle(uv, vec2(.1*sin(2.*t), 0.1), .1, 0.01);\n    col -= Circle(uv, vec2(.3*sin(t), 0.1), .1, 0.15);\n    col -= Circle(uv, vec2(.3*sin(t), 0.), .1, 0.1);\n    col -= Circle(uv, vec2(.3*sin(t), -.1), .1, 0.1);\n    col -= Circle(uv, vec2(.3*sin(t), -.2), .1, 0.15);\n    col -= Circle(uv, vec2(.9, 0.2*sin(2.+t)), .1, 0.01);\n    col -= Circle(uv, vec2(1, 0.2*sin(5.+t)), .1, 0.01);\n    col -= Circle(uv, vec2(1.1, 0.2*sin(7.+t)), .1, 0.01);\n    col += Circle(uv, vec2(tan(t)*-.5, -0.5), sin(t)*.1, 0.01);\n    col += Circle(uv, vec2(cos(t)*-.7, 0.7), .1, 0.01);\n  //col += Circle(uv, vec2(cos(t)*-.7, 0.0), cos(t*sin(tan(t*2.))+.1), 0.01);\n    \n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 141], [144, 144, 166, 166, 324], [344, 344, 401, 401, 1730]], "test": "untested"}
{"id": "tdyXzK", "name": "Local Spot Noise : Filtering", "author": "H4w0", "description": "Shader snippet of our paper \"Local Spot Noise for Procedural Surface Details Synthesis\" at Computer & Graphics.", "tags": ["procedural", "filtering", "lsn", "spotnoise"], "likes": 15, "viewed": 472, "published": "Public API", "date": "1574412813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//=======================================================\n//= Filtered Local Spot Noise \n//=======================================================\n//== Local Spot Noise for Procedural Surface Details Synthesis  \n//== https://acavalier.github.io/research/local-spot-noise-paper\n//=======================================================\n//== Analytic Filtering - https://www.shadertoy.com/view/tdyXzK\n//== Normal Mapping - https://www.shadertoy.com/view/Wdc3W7\n//== Control Map - https://www.shadertoy.com/view/Ws33W7\n//=======================================================\n//== Authors : Arthur Cavalier, Guillaume Gilet, Djamchid Ghazanfarpour\n//=======================================================\n\n\n//--------------------------------------------------------------------------------------------------------\n// User Parameters ---------------------------------------------------------------------------------------\nconst uint  LSN_GLOBAL_SEED = 0u;\nconst float LSN_RESOLUTION  = 40.;\nconst int   LSN_IMPULSES    = 3;\n#define KERNEL_ANIMATION\n\n//--------------------------------------------------------------------------------------------------------\n// Constants ---------------------------------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n//--------------------------------------------------------------------------------------------------------\n// RayTracing---------------------------------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n// Matrix Maths ------------------------------------------------------------------------------------------\nfloat det2x2(in mat2 m)         {return (m[0][0]*m[1][1] - m[0][1]*m[1][0]);}\nmat2  inv2x2(in mat2 m)         {return (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);}\nmat2  tra2x2(in mat2 m)         {return mat2(m[0][0],m[1][0],m[0][1],m[1][1]);}\n\n//--------------------------------------------------------------------------------------------------------\n// PRNG --------------------------------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//--------------------------------------------------------------------------------------------------------\n// Gaussians utils ---------------------------------------------------------------------------------------\n\n/* Elliptical Gaussian Covariance Matrix    */\n/* From RotationAngle, ScaleX, ScaleY       */\n/* Geometric definition of the CovMatrix    */\nmat2 RxSxSxRinv(in float theta, in float sx, in float sy)\n{\n    float A = cos(theta);\n    float B = sin(theta);\n    float A2 = A*A;\n    float B2 = B*B;\n    float sx2 = sx*sx;\n    float sy2 = sy*sy;\n\n    float r00 = A2*sx2+B2*sy2;\n    float r11 = A2*sy2+B2*sx2;\n    float r01 = A*B*sx2-A*B*sy2;\n    float r10 = r01;\n    return mat2(r00,r01,r10,r11);\n}\n\n/* K : \\lambda    */\n/* M : \\mu        */\n/* S : \\Sigma     */\nfloat gaussian(in vec2 X, in float K, in vec2 M, in mat2 S)\n{\n    vec2 P = X-M;\n    return( K * exp( -0.5 * dot(P,inv2x2(S)*P) ) );\n}\n\n/* K : \\lambda                              */\n/* M : \\mu                                  */\n/* S : \\Sigma                               */\n/* Kp: Pixel footprint amplitude            */\n/* Sp: Pixel footprint covariance matrix    */\nfloat gaussian_filtered(in vec2 X, in float K, in vec2 M, in mat2 S, in float Kp, in mat2 Sp)\n{\n    mat2  invSp = inv2x2(Sp);\n    mat2  invS = inv2x2(S);\n    vec2  XM = X-M;\n    mat2  S3 = inv2x2(invSp + invS);   \n    return m_2_pi * sqrt(det2x2(S3)) * gaussian(XM,K*Kp,vec2(0.),S+Sp);\n}\n\n\n//--------------------------------------------------------------------------------------------------------\n// Custom Kernel -----------------------------------------------------------------------------------------\nfloat kernel(in uint prng, in vec2 xy, in int cell_id, in float Kp, in mat2 Sp, in bool anti_aliasing, in float orientation)\n{\n    float theta = orientation; \n    if(cell_id%2 == 0)\n        theta += m_pi_2;\n\n    if(anti_aliasing)\n        return gaussian_filtered(xy, 1., vec2(0.0), RxSxSxRinv(theta,0.6,0.05), Kp, Sp);\n    return gaussian(xy, 1., vec2(0.0), RxSxSxRinv(theta,0.6,0.05));\n}\n\n//--------------------------------------------------------------------------------------------------------\n// Local Spot Noise --------------------------------------------------------------------------------------\nfloat local_spot_noise(in vec2 texture_coords, in bool anti_aliasing)\n{\n    vec2 scaled_coords = LSN_RESOLUTION * texture_coords ;   \n    vec2 cell_coords = fract(scaled_coords);\n    vec2 cell_index = floor(scaled_coords);\n\n    vec2 dUdx = 0.5 * dFdx(scaled_coords);\n    vec2 dUdy = 0.5 * dFdy(scaled_coords);\n    mat2  Jc = mat2(dUdx,dUdy); \n    mat2  Sp = Jc*tra2x2(Jc);\n    float Kp = 1.0/(m_2_pi*sqrt(det2x2(Sp))); \n\n    ivec2 cell_ID;\n    uint  seed, prng;\n    vec2  cell_shot;\n\n    \n    float distribution \t= 0.;\n    float chaos_max \t= 0.;\n    float orientation \t= 0.;\n    float perturbation \t= 0.;\n    \n#ifdef KERNEL_ANIMATION    \n    distribution  = clamp( 0.5*sin(iTime), 0., 1. ); \n    chaos_max     = clamp( 0.2*sin(0.2*iTime), 0., 1. ) * m_pi_2; \n    orientation   = clamp( cos(iTime), 0., 1. ) * m_pi_2;\n#endif\n    \n    float sum = 0.0;\n    float wei = 1.0/float(LSN_IMPULSES);\n    float amp = 1.0;\n\tfor (int m = -1; m <= +1; m++)\n    for (int n = -1; n <= +1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed  = cell_seed(cell_ID, LSN_GLOBAL_SEED);\n        prng  = wang_hash(seed);\n\n\n        vec2 xy = cell_coords-vec2(m,n);\n        for(int k=0;k<LSN_IMPULSES;k++)\n        {\n            cell_shot.x = myrand_uniform_m_M(prng, 0.5-distribution, 0.5+distribution);  \n            cell_shot.y = myrand_uniform_m_M(prng, 0.5-distribution, 0.5+distribution); \n            perturbation = myrand_uniform_m_M(prng, 0., chaos_max);\n            sum += kernel(prng, xy-cell_shot, cell_ID.x+cell_ID.y, Kp, Sp, anti_aliasing, orientation + perturbation);\n        }\n    }\n    return sum * wei;\n}\n\n\n//--------------------------------------------------------------------------------------------------------\n// Main --------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = ((2.*fragCoord.xy-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(0.1*iTime + 6.0*mouse.x), 2.3 + 2.0*mouse.y, -0.5+3.5*sin(0.1*iTime + 6.0*mouse) );\n    vec3 target = vec3( 0.5, -0.4, -0.5 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(0.),1.);\n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,0.));\n    if(hit>0.0)\n    {\n        vec3 hit_position = (origin + hit*direction);\n        vec2 texture_coords = hit_position.xz/5.;\n        bool AA = (coords.x > 0.);      \n\n        float spot_noise = local_spot_noise(texture_coords,AA);\n        fragColor.rgb   = vec3(spot_noise);\n    }\n    fragColor.rgb*= smoothstep( 0.0, 0.01, abs(coords.x) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1389, 1603, 1709, 1709, 1934], [1936, 1936, 2001, 2001, 2062], [2064, 2278, 2311, 2311, 2355], [2356, 2356, 2389, 2389, 2455], [2456, 2456, 2489, 2489, 2535], [2537, 3166, 3235, 3235, 3346], [3347, 3347, 3416, 3416, 3538], [3539, 3539, 3608, 3608, 3653], [3654, 3654, 3723, 3723, 3767], [3768, 3768, 3837, 3837, 3886], [4103, 4244, 4303, 4303, 4594], [4596, 4659, 4720, 4720, 4792], [4794, 5029, 5124, 5124, 5316], [5319, 5533, 5659, 5659, 5921], [5923, 6137, 6208, 6208, 7792], [7795, 8009, 8066, 8066, 9007]], "test": "untested"}
{"id": "ts3SDX", "name": "flying squirrels", "author": "thisisthais", "description": "my output from the devtea led by char ", "tags": ["tiling", "distancefunctions"], "likes": 2, "viewed": 69, "published": "Public", "date": "1572983846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530718\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat equiTri(vec2 p){\n  float side=sqrt(3.);\n  p.x=abs(p.x)-1.;\n  p.y=p.y+1./side;\n  if(p.x+side*p.y>0.){\n    p=vec2(p.x-side*p.y,-side*p.x-p.y)/2.;\n  }\n  p.x-=clamp(p.x,-2.,0.);\n  return-length(p)*sign(p.y);\n}\n\nfloat sdCircle(vec2 p,float r)\n{\n  return length(p)-r;\n}\n\nfloat sdPentagon(in vec2 p,in float r)\n{\n  const vec3 k=vec3(.809016994,.587785252,.726542528);\n  p.x=abs(p.x);\n  p-=2.*min(dot(vec2(-k.x,k.y),p),0.)*vec2(-k.x,k.y);\n  p-=2.*min(dot(vec2(k.x,k.y),p),0.)*vec2(k.x,k.y);\n  return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\n// As t runs from 0 to 1 (our normalized palette index or domain),\n//the cosine oscilates c times with a phase of d.\n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette(float t,vec3 a,vec3 b,vec3 c,vec3 d)\n{\n  return a+b*cos(6.28318*(c*t+d));\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p,float a){\n  p=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nvec2 tile(vec2 st,float zoom){\n  st*=zoom;\n  // _st.x += step(1., mod(_st.y,2.0)) * 0.5;\n  return fract(st+iTime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 myRes = iResolution.yy;\n  vec2 st=fragCoord/myRes.xy;\n  vec3 color=vec3(0.);\n\n  st=tile(st,4.);\n\n  // normalize the coordinate space\n  st-=vec2(.5);\n  st*=2.;\n\n  // spiiiiiin\n  pR(st,mod(iTime,TWO_PI));\n  \n  // distance shapes\n  float triangle=equiTri(st*vec2(3.));\n  float circle=sdCircle(st*vec2(3.),.5);\n  float pentagon=sdPentagon(st*vec2(3.),.5);\n  float changingShape=sin(iTime)*(triangle-circle)+circle;\n  // this makes a flying squirrel\n  changingShape=sin(iTime)*(changingShape-pentagon)+pentagon;\n  \n  vec3 col=cosPalette(.5,vec3(.5),vec3(.5),vec3(1.),vec3(iTime*.01,iTime*.1,iTime*.2));\n  \n  // lighting: darken at the center\n  col=vec3(changingShape)*col;\n  \n  // output: pixel color\n  fragColor=vec4(col.rgb,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3SDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 138, 160, 160, 349], [351, 351, 383, 383, 407], [409, 409, 449, 449, 692], [694, 966, 1020, 1020, 1057], [1059, 1297, 1327, 1327, 1365], [1367, 1367, 1397, 1397, 1483], [1485, 1485, 1539, 1539, 2274]], "test": "untested"}
{"id": "ts3SRs", "name": "Rounded Tetrahedron", "author": "Dain", "description": "There are many tetrahedrons on shadertoy that don't round(not euclidean)-- I wanted one that did--\nIs it euclidean accurate? IDK but seems reasonable at least-\nYou can also create octrahedon and other cutoff polyhedron shapes by adjusting gTetOffset\n", "tags": ["tetrahedron", "octahedron"], "likes": 3, "viewed": 311, "published": "Public API", "date": "1572610703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//There are many tetrahedrons on shadertoy that don't round(not euclidean)-- I wanted one that did--//\n//Is it euclidean accurate? IDK but seems reasonable at least-(it lines up with a euclidean sphere at least)\n//You can also create octrahedon and other cutoff polyhedron shapes by adjusting gTetOffset\n//Also irregular shaped tetrahadron by using non-uniform box\n\nfloat maxElem(vec4 a){\n    return max(a.x, max(a.y, max(a.z,a.w)));\n}\n//A box in 4D tetrahedral space\nfloat sdBox4( vec4 p, vec4 b )\n{\n    vec4 d = abs(p) - b;\n    return min(maxElem(d),0.0) + length(max(d,0.0));\n}\n\nfloat gTetOffset = 1.0;//using 1 makes this a tet, using 0 makes it an octahedron\n\n//Convert from euclidean to tetrahedral space\nvec4 GetTetCoord(vec3 p){\n    float offset = gTetOffset;//sqrt(2.0);\n    float s1 = 1.0/sqrt(4.0);\n    float s2 = 1.0/sqrt(2.0);\n    float s3 = 1.0;\n    \n    return vec4(offset - p.z*s1 - s2*p.x,\n                offset - p.z*s1 + s2*p.x,\n                offset + p.z*s1 + s2*p.y,\n                offset + p.z*s1 - s2*p.y)*s3;\n}\n\nfloat sdTetrahedron(vec3 p, float size, float roundness){\n    vec4 t = GetTetCoord(p); \n    \n    float scaleDown = 1.0/sqrt(4.0);//scale it to match expectation of size--\n    float offsetSize = gTetOffset;//offset size to expectation of tet\n    size = size*scaleDown + offsetSize ;\n    \n  //roundness *= scaleDown;\n    return sdBox4(t, vec4(size))-roundness; //rounded tetrahedon, yah!\n    //return sdBox4(t, vec4(size,size*.05,size*1.0, size*3.0))-roundness; //can do irregular shaped tets also\n  //return maxElem(abs(t)) - size;//max norm tetrahedron as seen in many shadertoys\n}\n                \n//Rest of code by mostly by paniq\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,1.0);\n}\n\nvec2 add_plane(vec3 p, vec2 m) {\n    return min2(plane(p),m);\n}\n\nvec2 doModel( vec3 p ) {\n\n    float Size = 1.5;\n   // float d = Tetrahedron(p, Size, 0.0);\n    float d = sdTetrahedron(p, abs(cos(iTime*.1))*.5 + .50, .8*abs(sin(iTime*.3)));\n\t// d = min(d,length(p)-Size);//use to verify sphere size and tet match up\n    return add_plane(p, vec2(d,0.0));\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    float k = doModel(pos).y;\n    float d = doModel(vec3(pos.x,0.0,pos.z)).x;\n    \n    float w = abs(mod(d, 0.1)/0.1 - 0.5);\n    \n    return mix(vec4(0.1,.01,1.0,0.1), //nor * 0.5 + 0.5,\n               vec4(1.0,1.0,1.0,0.0) * w,\n               clamp(k,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n\tfloat cos_Ol = max(0.0, dot(nor, lig));\n    vec3 h = normalize(lig - rd);\n    float cos_Oh = max(0.0,dot(nor, h));\n    float dif = cos_Ol;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(0.8, 0.7, 0.6)*sha;\n    \n    lin += vec3(0.20,0.30,0.30);\n\n    \n    vec3 col = mal.rgb*lin;\n\n    // specular\n    col += cos_Ol * pow(cos_Oh,40.0);\n    \n    // envmap\n //   col += mal.w*Texture2D(iChannel0, reflect(rd,nor)).rgb;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<80; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n        if(h <= 0.0){\n            break;\n        }\n        t +=abs(h);\n        if(t > 20.0){\n            break;\n        }\n      //  t += max(h, 0.;\n\t//\tt += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n  //  vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n   // vec3 ro, ta;\n    //doCamera( ro, ta, iTime, m.x );\n    //doCamera( ro, ta, 3.0, 0.0 );\n\n    // camera matrix\n   // mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\t//vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \tfloat an = 1.1 + 0.05*(iTime-10.0) - 7.0*m.x;\n    \n\tvec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.2,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = ff_filmic_gamma3(col * 0.6); //pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3SRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 366, 388, 388, 435], [436, 468, 500, 500, 580], [665, 711, 736, 736, 1038], [1040, 1040, 1097, 1097, 1621], [1639, 1674, 1757, 1757, 1880], [1882, 1882, 1909, 1909, 1944], [1946, 1946, 1973, 1973, 2004], [2006, 2006, 2033, 2033, 2063], [2066, 2066, 2087, 2087, 2119], [2121, 2121, 2153, 2153, 2184], [2186, 2186, 2210, 2210, 2475], [2477, 2830, 2875, 2875, 3140], [3142, 3353, 3437, 3437, 4078], [4080, 4080, 4130, 4130, 4549], [4551, 4551, 4583, 4583, 5003], [5005, 5005, 5053, 5053, 5632], [5634, 5634, 5698, 5698, 5876], [5878, 5878, 5914, 5914, 6008], [6010, 6010, 6067, 6067, 7787]], "test": "untested"}
{"id": "ts3XDj", "name": "Spherical harmonics optimized", "author": "TimoKinnunen", "description": "Going up to L=16 without totally completely blowing up!", "tags": ["solver", "spherical", "harmonics", "sh", "factorials"], "likes": 8, "viewed": 426, "published": "Public API", "date": "1572884324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on Spherical harmonics solver by Roninkoi\n// @ https://www.shadertoy.com/view/3dKGWG\n//\n// Thanks mainly to optimized factorial calculations this shader gets upto order L=16\n// while still retaining a little bit of semblance!\n//\n// (Factorials are incredibly wasteful, both computationally and cognitively,\n// for simple things like multiplying all the numbers between A and B together.)\n//\n// Changes: \n// - Automatic mode to go through all configurations (using triangular numbers!)\n// - Combining factorials to cancel unnecessary calculations\n// - Calculating factorials using floating-point to cope better with the range of values\n// - Using bit-shifting to calculate powers of -1 without looping\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four bands of Spherical Harmonics functions (or atomic orbitals if you want). For\n// reference and fun.\n\nprecision highp float;\n\n// azimuthal quantum number\n#define L 11\n\n// magnetic quantum number\n#define M 1\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n#define AUTOMATIC\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n#define PI 3.1415926535898\n#define E 2.7182818284591\n\nint factorial(int n) // n!\n{\n    int r = 1;\n    \n    for (int i = 2; i <= n; ++i) {\n        r *= i;\n    }\n    \n    return r;\n}\nfloat factorialDiv(int n, int j) // ((n+j)!)/((n-j)!)\n{\n    float r = 1.0;\n    for (int i = n-j+1; i <= n+j; i++) {\n        r *= float(i);\n    }\n    \n    return r;\n}\nfloat factorialMul(int n, int j) // ((n+j)!)*(n!)\n{\n    float r1 = 1.0;\n    for (int i = 2; i <= n; i++) {\n        r1 *= float(i);\n    }\n    float r2 = 1.0;\n    for (int i = n+1; i <= n+j; i++) {\n        r2 *= float(i);\n    }\n    \n    return r1*r1*r2;\n}\nfloat factorialDivDividedByMul(int l, int k, int m) { // ((l+k)!)/((l-k)!) /  ((k+m)!)*(k!)\n\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    for (int i = l-k+1; i <= l+k  ; i++) r1 *= float(i);\n    for (int i = 2    ; i <=   k  ; i++) r2 *= float(i);\n    for (int i = k+1  ; i <=   k+m; i++) r3 *= float(i);\n    return r1/(r2*r2)/r3;\n}\n\nfloat powerim1(float x, int n) // negative power\n{\n    return float(1-((n&1)<<1));\n}\n\nfloat poweri(float x, int n) // negative power\n{\n/*    float p = 1.;\n    \n    for (int k = 0; k < n; ++k) {\n        p *= x;\n    }\n    \n    return p;*/\n    return pow(x,float(n));\n}\n\n// hypergeometric\nfloat F(int l, int m, int k, float x)\n{\n    //float f0 = float(factorialDiv(l + k)) / float(factorial(l - k));\n    //float f0 = factorialDiv(l,k);\n    float f0 = factorialDivDividedByMul(l,k,m);\n         \n    //float f1 = powerim1(-1., k) / float(factorial(m + k) * factorial(k));\n    //float f1 = powerim1(-1., k) / factorialMul(k, m);\n    float f1 = powerim1(-1., k);\n    \n    float f2 = poweri((1. - x) * 0.5, k);\n    \n    return f0 * f1 * f2;\n}\n\n// Legendre polynomials from hypergeometric, negative m\nfloat Pgm(int l, int m, float x)\n{\n    float lf = float(l);\n    float mf = float(m);\n    \n    float a = pow((1. - x) / (1. + x), mf * 0.5);\n    \n    float s = 0.0;\n    \n    for (int k = 0; k <= l; ++k) {\n        s += F(l, m, k, x);\n    }\n    \n    return a * s;\n}\n\n// Legendre polynomials from hypergeometric\nfloat Pg(int l, int m, float x)\n{\n    float lf = float(l);\n    float mf = float(m);\n    \n    //float a = float(factorial(l + m) / factorial(l - m));\n    \n    float pm = Pgm(l, m, x);\n    \n    //return a * pm;\n    return pm;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SH( in int l, in int m, in vec3 s ) \n{\n    vec3 ns = normalize(s);\n    \n    if (m < 0) {\n        float c = ns.x;\n        ns.x = ns.z;\n        ns.z = c;\n        m = -m;\n    }\n    \n    // quantum mechanics convention\n    float a0 = sqrt(\n//    \tfloat(2 * l + 1) / float(factorial(l + m)/factorial(l - m)) / (4.0 * PI)\n//    \tfloat(2 * l + 1) * float(factorial(l + m)/factorial(l - m)) / (4.0 * PI)\n    \tfloat(2 * l + 1) * factorialDiv(l,m) / (4.0 * PI)\n    );\n    \n    // spherical coordinates\n    float thetax = ns.y;\n    float phi = atan(ns.z, ns.x);\n    \n    float pl = Pg(l, m, abs(thetax));\n    if (thetax < 0.0) pl *= powerim1(-1., l + m);\n    \n    float r = powerim1(-1.0, (m)) * a0 * cos(float(m) * phi) * pl;\n    \n    return r;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p;\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\n    int l = L;\n    int m = M;\n    #ifdef AUTOMATIC\n    int x = ((iFrame>>1)&0x7FF)/15;\n    int Y = int(floor(sqrt(0.25+float(2*x))-0.5));\n    int X = int(floor(float(x)-0.5*float(Y+Y*Y)));\n    l = Y+1;\n    m = X+1;\n    #endif\n\td=length(p00); n=p00/d; r = SH(l, m, p ); s = SHAPE; res = s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 3.0;//10.0;\n    float h = 1.0;\n    float t = 1.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<100; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n        vec3 p = ro+rd*t ;\n\t    vec3 res = map(p);\n        h = res.x;\n\t\tm = res.yz;\n        //t += h*0.3;\n        t += h*0.2;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x;\n    float am = 2.*iMouse.y/iResolution.y - 1.;\n    float turn = radians(360./256.)*float(iFrame&0xFF);\n    vec3  ro = vec3(1.5*sin(an+turn),1.5*sin(am),1.5*cos(an+turn)) * 1.0;\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.5,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3XDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1195, 1334, 1362, 1362, 1460], [1461, 1461, 1516, 1516, 1626], [1627, 1627, 1678, 1678, 1880], [1881, 1881, 1934, 1972, 2232], [2234, 2234, 2284, 2284, 2318], [2320, 2320, 2368, 2470, 2500], [2502, 2520, 2559, 2666, 2968], [2970, 3026, 3060, 3060, 3288], [3290, 3334, 3367, 3367, 3559], [3561, 3622, 3666, 3666, 4364], [4366, 4366, 4389, 4389, 4931], [4933, 4933, 4975, 4975, 5364], [5366, 5366, 5398, 5398, 5622], [5624, 5624, 5681, 5695, 7398]], "test": "untested"}
{"id": "ts3XRs", "name": "Halftone metaballs", "author": "bitless", "description": "test of halftone effect", "tags": ["2d", "voronoi", "metaballs", "halftone"], "likes": 7, "viewed": 201, "published": "Public", "date": "1572613441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Halftone Metaballs\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*4378.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 2.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m =10.;\n\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n           \n            m = min(m,m*dist);\n        }\n    }\n\t\n    st *= 20.;\n    vec2 pt = vec2(floor(st)+0.5);\n    float c = (1.0-length(st-pt))*(1.0-m*0.5);\n    color = vec3(1.0-smoothstep(0.,0.075,abs(0.4-c)));\n\n\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3XRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 139, 163, 163, 255], [258, 258, 315, 315, 1120]], "test": "untested"}
{"id": "tscSRS", "name": "Ray marched improved shadows", "author": "nurof3n", "description": "3 different shadowing techniques.\nNotice the difference between usual soft shadows and the diffrShadow function shadows. \nFurther improvement (with penumbras): https://www.shadertoy.com/view/WdyXRD", "tags": ["raymarching", "shadow"], "likes": 14, "viewed": 533, "published": "Public", "date": "1573458958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//credit: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\n#define SHADOW_ITER 128\n#define AO_ITER 3\n#define MARCH_ITER 200\n#define MAX_MARCH_DIST 50.0\n#define EPS 0.00005\n#define FOV 45.0\n\n//raise this for higher fidelity\n#define AA 1.\n\nstruct PointLight {\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\nstruct Material {\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float specularPow;\n    float specularIntensity;\n};\nstruct Sphere {\n    vec3 O;\n    float radius;\n};\nstruct Box {\n\tvec3 O;\n    vec3 size;\n};\nstruct Wall {\n    float x;\n};\nconst Material M1 = Material(vec3(0.75, 0.73, 0.6), vec3(1.), 25., 1.7);\nconst Material M2 = Material(vec3(0.2,0.4,1.0), vec3(1.), 2., .3);\nconst Material M3 = Material(vec3(0.39, 0.8, 0.9), vec3(1.), 5., 1.);\n\nSphere S = Sphere(vec3(-1.,-1.,-5.), 1.);\nBox B = Box(vec3(2., -.6, -3.), vec3(.3,1.4,.3));\nWall Wx = Wall(-3.);\nWall Wy = Wall(-2.);\nWall Wz = Wall(-15.);\n\nvec2 minim(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n/*\n---------------SDFs---------------\n*/\n\nfloat planexSDF(float x, vec3 point) {\n \treturn point.x - x;   \n}\nfloat planeySDF(float y, vec3 point) {\n \treturn point.y - y;   \n}\nfloat planezSDF(float z, vec3 point) {\n    return point.z - z;\n}\nfloat sphereSDF(vec3 O, float radius, vec3 point) {\n \treturn length(point - O) - radius;   \n}\nfloat boxSDF(vec3 O, vec3 dim, vec3 point)\n{\n    point -= O;\n    vec3 q = abs(point) - dim;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\nvec2 sceneSDF(vec3 point) {\n    vec2 b = vec2(boxSDF(B.O, B.size, point), 3.);\n    vec2 s = vec2(sphereSDF(S.O, S.radius, point), 1.);\n    vec2 p1 = vec2(planexSDF(Wx.x, point), 2.);\n    vec2 p2 = vec2(planeySDF(Wy.x, point), 2.); \n    vec2 p3 = vec2(planezSDF(Wz.x, point), 2.);\n    return minim(b, minim(s, minim(p1, minim(p2, p3))));\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPS, p.y, p.z)).x - sceneSDF(vec3(p.x - EPS, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPS, p.z)).x - sceneSDF(vec3(p.x, p.y - EPS, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPS)).x - sceneSDF(vec3(p.x, p.y, p.z - EPS)).x\n    ));\n}\n\n/*\n-------------MARCHING---------------\n*/\n\nvec2 marchStep(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MARCH_ITER; i++) {\n        vec2 dist = sceneSDF(eye + depth*dir);\n        if (dist.x < EPS)\n\t\t\treturn vec2(depth, dist.y);\n        \n        depth += dist.x;\n        if (depth >= end) \n            return vec2(end, 0.);\n    }\n    \n    return vec2(end, 0.);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y/2.) / tan(radians(fieldOfView / 2.));\n    return normalize(vec3(xy, -z));\n}\n\n/*\n----------------AO---------------\n*/\n\n//\tThis has faster falloff for AO intensity and fewer iterations\nfloat AO(vec3 point, vec3 dir, float start) {\n\tfloat depth = start, dist;\n    float step = 0.05, falloff = 1.0;\n    float ao = 0.0;\n    for(int i = 0; i < AO_ITER; ++i) {\n        dist = sceneSDF(point + depth*dir).x;\n        ao += falloff*clamp(depth - dist, 0.0, 1.0);\n        depth += step;\n        falloff *= 0.9;\n    }\n    \n    return clamp(1.0 - 1.5*ao, 0.0, 1.0);\n}\n\n/*\n-------------SHADOWS-------------\n*/\n//  Traditional, geometrical sharp shadows\nfloat sharpShadow(vec3 point, vec3 dir, float start, float end) {\n \tfloat depth = start, dist;\n    for(int i = 0; i < SHADOW_ITER; ++i) {\n     \tdist = sceneSDF(point + depth*dir).x;  \n        depth += dist;\n        if(depth >= end)\n            return 1.0;\n        if(dist < EPS)\n            return 0.0;\n    }\n\n    return 1.0;\n}\n//\tNot very realistic, the soft shadow actually expands with distance\n//and exceeds the geometrical projection\nfloat softShadow(vec3 point, vec3 dir, float start, float end) {\n \tfloat depth = start, dist, prevdist = 10e9;\n    float shadow = 1.0;\n    for(int i = 0; i < SHADOW_ITER; ++i) {\n     \tdist = sceneSDF(point + depth*dir).x;\n        if(depth > end || shadow < EPS)\n            break;\n    //Traditional\n        //shadow = min(shadow, 35.*dist/min(depth, 5.));\n    //Sebastian Aaltonen's improvement\n        float delta = dist*dist/(2.*prevdist);\n        float dist2 = sqrt(dist*dist - delta*delta);\n    //We clamp depth because we dont want the shadow to grow big and not look realistic\n        shadow = min(shadow, 35.*dist2/max(0.0, min(depth - delta, 5.))); \n        prevdist = dist;\n    \n        depth += dist;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n//\tA more realistic model in which the casted ray goes through objects so that the shadow stays\n//inside the geometrical projection, it doesnt expand and instead it softens on the inside edges like irl\nfloat diffrShadow(vec3 point, vec3 dir, float start, float end) {\n \tfloat depth = start, dist;\n    float shadow = 1.0;\n    for(int i = 0; i < SHADOW_ITER; ++i) {\n     \tdist = sceneSDF(point + depth*dir).x;\n        if(depth > end || shadow < -1.0)\n            break;\n        \n        shadow = min(shadow, 40.*dist/depth);\n    \tdepth += clamp(dist, 0.005, 10.0);\n    }\n    \n    shadow = max(shadow, -1.0);\n    return smoothstep(-1.0, 0.0, shadow);\n}\n\n/*\n---------------PHONG---------------\n*/\n\nvec3 PhongContribForPointLight(vec3 point, vec3 normal, Material M, PointLight light) {\n\tvec3 lightDir = light.pos - point;\n    float d = length(lightDir);\n    lightDir = lightDir / d;\n    float attenuation = 1./ (.02*d*d + d + 1.);\n\n    float cosine = max(0., dot(normal, lightDir));\n    //vec3 scaledNormal = normal * cosine;\n    vec3 specular = vec3(0.);\n    if(cosine > EPS) {\t//remove condition for smooth transition at extreme angles\n        vec3 reflected = reflect(-lightDir, normal);\t//normalize(2.*scaledNormal - lightDir);\n        specular = light.color * M.specularIntensity * M.specularColor * attenuation *\n        \t\t\t\tpow( max(0., dot(reflected, normalize(-point)) ), M.specularPow );\n    }\n    \n    vec3 diffuse = light.color * M.diffuseColor * light.intensity * attenuation * cosine;\n    return diffuse + specular;  \n}\nvec3 PhongIllumination(vec3 point, vec3 normal, float colorCode) {\n    Material M;\n    if(colorCode == 1.)\n        M = M1;\n    else if(colorCode == 2.)\n        M = M2;\n    else\n        M = M3;\n    \n    vec3 ambient = vec3(.79,.79,1.) * .05;\n    vec3 color = ambient;\n    \n    PointLight light = PointLight(vec3(5.0 + .5*sin(iTime), 3.+cos(iTime), -1.0), vec3(.9, 1., .7), 4.);\n    vec3 lightDir = light.pos - point;\n    float lightDist = length(lightDir);\n    lightDir /= lightDist;\n\n    //! Soft Shadows cause problems with banding at high distances !\n    //Change shadow technique here\n    color += PhongContribForPointLight(point, normal, M, light) * diffrShadow(point, lightDir, .01, lightDist);\n    \n    light = PointLight(vec3(1.-cos(iTime),1.,4.), vec3(1., .7, .8), 4.);\n    lightDir = light.pos - point;\n    lightDist = length(lightDir);\n    lightDir /= lightDist;\n    //Change shadow technique here\n    color += PhongContribForPointLight(point, normal, M, light) * diffrShadow(point, lightDir, .01, lightDist);\n    \n    return color * AO(point, normal, 0.001);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.,0.,5.);\n    vec3 color = vec3(.0);\n    vec2 offset;\n    //MSAA\n    for(float i = 1.; i <= AA; ++i) {\n    \toffset.x = -0.5 + i/(AA+1.);\n         for(float j = 1.; j <= AA; ++j) {\n            offset.y = -0.5 + j/(AA+1.);\n            vec2 pixel = fragCoord + offset;\n             \n            vec3 rayDir = rayDirection(FOV, iResolution.xy, pixel);\n            vec2 inters = marchStep(eye, rayDir, .5, MAX_MARCH_DIST);\n\n            if(inters.x < MAX_MARCH_DIST - EPS) {\n                vec3 hit = eye + inters.x * rayDir;  \n                vec3 normal = getNormal(hit);\n                color += PhongIllumination(hit, normal, inters.y);\n    \t\t} \n        }\n    }\n    color /= AA*AA;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 944, 972, 972, 1001], [1003, 1045, 1083, 1083, 1110], [1111, 1111, 1149, 1149, 1176], [1177, 1177, 1215, 1215, 1241], [1242, 1242, 1293, 1293, 1335], [1336, 1336, 1380, 1380, 1495], [1496, 1496, 1523, 1523, 1834], [1836, 1836, 1860, 1860, 2158], [2160, 2204, 2264, 2264, 2570], [2572, 2572, 2637, 2637, 2773], [2816, 2881, 2926, 2926, 3252], [3254, 3337, 3402, 3402, 3664], [3665, 3776, 3840, 3840, 4535], [4536, 4738, 4803, 4803, 5185], [5187, 5230, 5317, 5317, 6065], [6066, 6066, 6132, 6132, 7137], [7139, 7139, 7196, 7196, 7939]], "test": "untested"}
{"id": "tscSzl", "name": "2019-11-01 hexagon", "author": "sinclav", "description": "triangle test", "tags": ["2s"], "likes": 4, "viewed": 91, "published": "Public", "date": "1572600527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979\n#define TWOPI (PI * 2.0)\n\nfloat tri(vec2 p, vec2 c, float r, float a) {\n    int n = 6;\n    vec2 pc = p - c;\n    float th = atan(pc.x, pc.y) + PI + a;\n    float thr = TWOPI / float(n);\n    float d = cos(floor(th/thr+0.5)*thr-th)*length(pc);\n    return smoothstep(r,r+0.01,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime / 1.92;\n    vec2 p = fragCoord / iResolution.xy;\n    vec2 pc = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    pc *= 2.0;\n    \n    //vec3 col = vec3(d);\n    float r = mod(t, 1.0); \n    float a = t;\n    float d = 0.0;\n    for (int i=1; i<=4; i++) {\n        float r2 = pow(mod(r + float(i) * 0.25, 1.0) * 1.9, 1.24);\n        d += (tri(pc, vec2(0.0), r2, a) * (1.0 - tri(pc, vec2(0.0), r2 + 0.01, a*1.5)));\n    }\n    vec3 col = vec3(1.0-d);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 99, 99, 304], [306, 306, 363, 363, 868]], "test": "untested"}
{"id": "tscXDf", "name": "Raymarching Operator", "author": "zrcoy", "description": "Raymarching Operator for few basic shapes", "tags": ["raymarchingoperator"], "likes": 1, "viewed": 498, "published": "Public API", "date": "1572998484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define SURF_DIST .01\n#define MAX_DIST 100.\n#define PI 3.14159265359\n\nfloat DToRad(float d)//degree to radian\n{\n \t return d /180.f * PI  ;\n}\n\nmat2 Rot(float angle)\n{\n \tfloat s = sin(angle);\n    float c= cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b , float k)\n{\n \tfloat h = clamp(.5 + .5*(b -a)/k, 0., 1.);\n    return mix(b,a,h) - k*h*(1.f - h);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n \treturn length(p) - r;   \n}\n\nfloat Torus(vec3 p, float r1, float r2)//r1 bigger radius\n{\n    float x = length(p.xz) - r1;\n    float y = p.y;\n    float d = length(vec2(x,y));\n    return d - r2;\n}\n\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r, vec3 pos)\n{\n    p-=pos;\n \tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float ratio = clamp((dot(ap, ab) / dot(ab,ab)), 0., 1.);\n    \n    vec3 PointC = a + ab * ratio;\n    return length(PointC - p)-r;\n}\n\n\nfloat Cylinder(vec3 p, vec3 a, vec3 b, float r, vec3 pos)\n{\n    p-=pos;\n \tvec3 ab = b-a;\n    vec3 ap = p-a;\n    float t = dot(ap, ab) / dot(ab,ab);    \n    vec3 PointC = a + ab * t;\n    float d = length(PointC - p)-r;\n    float y = abs(t-.5f) - .5f;// make the dist on y range from infinite...0...-0.5...0...infinite \n\tfloat e = length(max(vec2(d,y),0.));\n    float i = min(max(d,y),0.);\n    return e+i;\n}\n\nfloat Link( in vec3 p, in float le, in float r1, in float r2 ,vec3 pos )\n{\n    p-=pos;\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat Box(vec3 p, float side)\n{\n    float dx = max(abs(p.x) - side,0.);\n    float dy = max(abs(p.y) - side,0.);\n    float dz = max(abs(p.z) - side,0.);\n    return length(vec3(dx,dy,dz));\n}\n\nfloat GetDist(vec3 p)//a simple scene with just a ground plane and a sphere\n{\n    float t = iTime;\n    \n    // ground plane\n    float pd = p.y;\n    \n    // rotating box & sphere transformation\n    vec3 bp = p ;\n    bp -= vec3(0,.75,3);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float dsBox = Box(bp, 1.f);\n    float dsSphere = Sphere(bp,1.8f);\n    vec3 sp_B = p;\n    sp_B -= vec3(0, 2.75f,3);\n    sp_B.y -= 2.f*(sin(iTime * .5f));\n    float dsSp_Blend = Sphere(sp_B,.8f);\n    \n    \n    \n    //Cylinder\n    \n    vec3 CylinderP = vec3(1.f,1.f,0.f);\n    CylinderP.xz+=vec2(sin(iTime)*5.f, cos(iTime)*5.f);//move\n    CylinderP.xz *= Rot(iTime*1.5f);\n    float dsCylinder = Cylinder(p, vec3(0,2,0),vec3(3,2,0),.2f, CylinderP);\n    float dsCylinder2 = Cylinder(p, vec3(1.5f,2,-1.5f),vec3(1.5f,2,1.5f),.2f, CylinderP);\n    float dsCylinder3 = Cylinder(p, vec3(1.5f,2.f+1.5f,0),vec3(1.5f,2.f-1.5f,0),.2f, CylinderP);\n    dsCylinder = mix(dsCylinder, dsCylinder2, abs(sin(iTime)));\n    dsCylinder = smin(dsCylinder, dsCylinder3,.3);\n    \n    \n    //Sphere substraction\n    vec3 Sp1 = vec3(-2.f, 1.f, -2.f);\n    Sp1 = p-Sp1;//translate    \n    Sp1.y -= abs(sin(iTime));//jump\n    Sp1.xz +=vec2(sin(iTime), cos(iTime));   \n    vec3 Sp2 = vec3(-1.f, 1.f, -2.f);\n    Sp2 = p-Sp2;   \n    Sp2.y -= abs(sin(iTime));\n    Sp2.x += .4f*sin(iTime);    \n    float dsSp = Sphere(Sp1, 1.f);\n    float dsSp2 = Sphere(Sp2, .8f);\n    dsSp = max(-dsSp2,dsSp);\n    dsSp = smin(dsSp,dsCylinder,.3f);\n    \n    \n    //Torus\n    \n    vec3 torusP = p;\n    torusP -= vec3(3.f + sin(iTime) * 5.f,1.f,(-2.f) + cos(iTime)*5.f);\n    torusP.y -= abs(sin(iTime)) * 3.f;//translate\n    torusP *= vec3(1.f + abs(sin(iTime)),1,1);//scale\n    torusP.yz *= Rot(DToRad(90.f));//rotate\n    \n    float dsTorus = Torus(torusP, 1.f,.25f);\n      \n    \n    \n    \n    //final dist calculation\n    float d;\n    d = mix(dsBox, dsSphere, abs(sin(iTime)));\n    d = smin(d,dsSp_Blend,.4f);\n    d = min(d, pd);\n    d = min(d, dsCylinder);\n    d = min(d, dsSp);\n    d = min(d,dsTorus/2.f);\n    \n    return d;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarching(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\n\nfloat GetLight(vec3 p, vec3 lightPos) {\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.f;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0. , 1.);\n    float shadowR = RayMarching(p + n * SURF_DIST * 2., l);\n    if(shadowR < length(p -  lightPos))\n        dif *= .1f;\n    return dif;\n}\n\nvec3 Ray(vec2 uv, vec3 ro, vec3 lookat, float dToScreen)//lookat camera\n{\n    vec3 f = normalize(lookat - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),f));\n    vec3 up = normalize(cross(f, right));\n    vec3 center = ro + f * dToScreen; \n    vec3 intersectP = center + uv.x * right + uv.y * up;\n    return normalize(intersectP - ro);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -10);\n    ro.yz *= Rot(-m.y+.7f);\n    ro.xz *= Rot(m.x*2.f *PI);\n    \n    \n    vec3 rd = Ray(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarching(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 light1 = vec3(0, 10, 2);\n\n    \tfloat dif = GetLight(p, light1);\n\n    \tcol = vec3(dif);\n    }\n    \n    fragColor = vec4(col,1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 133, 133, 162], [164, 164, 187, 187, 268], [270, 270, 310, 310, 396], [398, 398, 429, 429, 458], [460, 460, 519, 519, 625], [627, 627, 685, 685, 868], [871, 871, 930, 930, 1276], [1278, 1278, 1352, 1352, 1470], [1472, 1472, 1503, 1503, 1660], [1662, 1662, 1739, 1739, 3728], [3731, 3731, 3755, 3755, 3945], [3947, 3947, 3984, 3984, 4200], [4204, 4204, 4243, 4243, 4550], [4552, 4552, 4625, 4625, 4891], [4895, 4895, 4952, 4952, 5465]], "test": "untested"}
{"id": "tsdXWX", "name": "symmetric pattern", "author": "talon", "description": "just play around with basic things like matrix,color...\nthen create pattern like this one.", "tags": ["2dpattern"], "likes": 4, "viewed": 301, "published": "Public API", "date": "1573055023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 st ,float sita ){\n    mat2 rotate = mat2(vec2(sin(sita),cos(sita)),\n                       vec2(-cos(sita),sin(sita)));\n    return rotate * st;\n}\n\nfloat bendedRect(vec2 st ,vec2 rect ,float offset ,float timeOffset ,float timeFactor){\n    float sita = iTime * timeFactor +timeOffset;\n    \n    st = abs(st);\n    st = rotate(st ,sita);\n    st.y -= offset;\n    \n    float blur = 0.3;\n    float a = smoothstep(-0.08*st.x*st.x-rect.y/2.0-blur ,-0.08*st.x*st.x-rect.y/2.0 ,st.y);\n    float b = 1.0 - smoothstep(-0.12*st.x*st.x+rect.y/2.0 ,-0.12*st.x*st.x+rect.y/2.0+blur ,st.y);\n    float c = smoothstep(-rect.x/2.0-blur ,-rect.x/2.0 ,st.x);\n    float d = 1.0 - smoothstep(rect.x/2.0 ,rect.x/2.0+blur ,st.x);\n    \n    return a * b * c * d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 20.;\n\n    vec3 color = vec3(0.0);\n    for(float i=0.0;i<12.0;i++){\n        float r = bendedRect(uv ,vec2(4.0 - i*0.3 ,0.4 ),10.0-i*0.8 ,20.0 - i*20. ,2.8-0.2*i);\n        color += r;\n    }\n    \n    uv = rotate(uv ,iTime);\n\t\n    // Output to screen\n    fragColor = vec4(color * vec3(0.6+uv.x/10.,0.5,0.6+uv.y/10.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 162], [164, 164, 251, 251, 752], [755, 755, 812, 862, 1290]], "test": "untested"}
{"id": "tsG3zR", "name": "Laser Renderer", "author": "FreddyDoll", "description": "Rendering Lines in 3D space", "tags": ["3d", "lines", "vector", "renderer"], "likes": 4, "viewed": 384, "published": "Public", "date": "1573388746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 beamCol = vec3(.5,.2,.1);\nconst vec3 glowCol = vec3(0.2,.5,0.2);\n\nconst int pointCount = 8;\nconst vec3 points[pointCount] = vec3[pointCount](\n    vec3(.2,+.2,+.2),\n    vec3(.2,+.2,-.2),\n    vec3(.2,-.2,-.2),\n    vec3(.2,-.2,+.2),\n    \n    vec3(-.2,+.2,+.2),\n    vec3(-.2,+.2,-.2),\n    vec3(-.2,-.2,-.2),\n    vec3(-.2,-.2,+.2)\n);\n\nconst int lineCount = 12;\nconst ivec2 lines[lineCount] = ivec2[lineCount](\n    ivec2(0,1),\n    ivec2(1,2),\n    ivec2(2,3),\n    ivec2(3,0),\n    \n    ivec2(4,5),\n    ivec2(5,6),\n    ivec2(6,7),\n    ivec2(7,4),\n    \n    ivec2(0,4),\n    ivec2(1,5),\n    ivec2(2,6),\n    ivec2(3,7)\n    );\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 dLine(vec2 p, vec2 start, vec2 end,float thickness)\n{\n    \n    vec2 dir = normalize(end-start);\n    float l = length(start-end);\n    vec2 ndir = vec2(dir.y,-dir.x);\n    float dLine = abs(dot(start-p,ndir));\n    float dFuss = dot(p-start,dir);\n    if(dFuss<0.)\n        dLine = length(p-start);\n    else if(dFuss > l)\n        dLine = length(p-(start+l*dir));\n        \n    thickness+=(rand(p*iTime*dFuss)-0.5)*0.001;\n        \n    vec3 ret=smoothstep(3.*thickness,thickness*1.1,dLine)*beamCol;\n    if(dLine>thickness)\n        ret+=smoothstep(8.*thickness,thickness,dLine)*glowCol;\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/max(iResolution.x,iResolution.y);\n\n    vec3 up = vec3(0.,0.,1.);\n    float camDist = (sin(iTime*.2)+2.);\n    vec3 camPos = vec3(camDist*sin(iTime),camDist*cos(iTime),0.8*sin(iTime*0.8));\n    vec3 camDir = normalize(-camPos);\n    vec3 camX = cross(camDir,up);\n    vec3 camY = cross(camDir,camX);\n    \n    mat3 camFrame = mat3(camX,camY,camDir);\n    \n    vec3 projected[pointCount];\n    for(int n=0;n<pointCount;n++)\n    {\n\t\tprojected[n] = (points[n] - camPos)*camFrame;\n        projected[n].xy /= projected[n].z;\n    }\n\n    fragColor = vec4(0.,0.,0.,1.0);\n    for(int n=0;n<lineCount;n++)\n    {\n    \tfragColor += vec4(dLine(uv,projected[lines[n].x].xy,projected[lines[n].y].xy,0.003/projected[lines[n].y].z),1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsG3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 645, 645, 717], [719, 719, 777, 777, 1318], [1321, 1321, 1378, 1378, 2142]], "test": "untested"}
{"id": "tsGSD3", "name": "BW lines sketch 3", "author": "rrrzzz", "description": "blank", "tags": ["simple", "trigonometric", "curve"], "likes": 5, "viewed": 114, "published": "Public", "date": "1575140244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 6.28318530718\n#define Multiplier 200000.\n\n//rotate, make lines of varied form, create a silhouette when there are lots of lines\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\t\n\tvec3 pixel = vec3(0.0);\n    \n//\tfloat y = cos(mod(10.*iTime, 100.)*TWOPI*p.y); \n    float value = p.y * p.x;\n\tfloat y = cos(Multiplier*TWOPI*value + iTime*4.); \n\t                            \n\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\t\n\tpixel = vec3(y); \n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 143, 200, 200, 609]], "test": "untested"}
{"id": "tsGSRc", "name": "trippy rainbow 2", "author": "sklappal", "description": "rainbow", "tags": ["rainbow"], "likes": 1, "viewed": 60, "published": "Public", "date": "1574588530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 center = vec2(0.5) + vec2(cos(iTime)*0.2, sin(iTime)*0.2);\n    \n    vec2 spher = center - uv;\n    \n    float dist = length(spher);\n    float angle = (atan(spher.x, spher.y) + M_PI) / ( 2.0 * M_PI);\n    angle += iTime + dist*(2.0*sin(0.1*iTime));\n    \n\n    // Output to screen\n    fragColor = vec4(hsl2rgb(vec3(angle, 0.8, 0.5)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 75, 75, 218], [220, 220, 277, 327, 713]], "test": "untested"}
{"id": "tsGSRK", "name": "Lava Lamp Like", "author": "aethelwhat", "description": "Copy pasted very poorly from my first ray marcher in an opengl project. ", "tags": ["raymarching", "ray", "march"], "likes": 3, "viewed": 308, "published": "Public API", "date": "1575074032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n * I'm aware half this code isn't even used, \n * its a playground from my first raymarcher\n * \n */\n\nconst int MAX_MARCHES = 255;\nconst float MIN_DIST = 0.05f;\nconst float EPSILON = 0.001f;\nconst vec3 temp_albedo = vec3(0.4f,0.3f,0.8f);\nconst vec3 sunlight = vec3(1.0f,1.0f,1.0f);\n\n#define pi 3.14159265358979\n\nstruct Ray {\n    vec3 o;     // origin\n    vec3 d;     // direction - always set with normalized vector\n};\n\nfloat percentOfMarches(float marches){\n\treturn (marches / float(MAX_MARCHES));\n}\n\nRay createRay(vec3 o, vec3 d)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    return r;\n}\n\nstruct Camera\n{\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lensRadius;\n};\n\nCamera createCamera(\n    vec3 lookFrom,\n    vec3 lookAt,\n    vec3 worldUp,\n    float fovy,\n    float aspect)\n{\n    float theta = fovy * pi / 180.0;\n    float halfHeight = tan(theta * 0.5);\n    float halfWidth = aspect * halfHeight;\n\n    Camera cam;\n    cam.origin = lookFrom;\n    cam.w = normalize(lookFrom - lookAt);\n    cam.u = normalize(cross(worldUp, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.lowerLeftCorner = cam.origin - halfWidth * cam.u - halfHeight * cam.v - cam.w;\n    //cam.lowerLeftCorner = cam.origin - halfWidth  - halfHeight;\n    cam.horizontal = 2.0 * halfWidth * cam.u;\n    cam.vertical = 2.0 * halfHeight * cam.v;\n    return cam;\n}\n\nRay getRay(Camera cam, vec2 uv)\n{\n    return createRay(\n        cam.origin,\n        normalize(cam.lowerLeftCorner + uv.x * cam.horizontal + uv.y * cam.vertical - cam.origin));\n}\n\nvec3 modPoint(vec3 pt, vec3 c){\n\treturn mod(pt+0.5*c,c)-0.5*c;\n}\n\nfloat sphereSdf(vec3 pt, vec3 circleOrigin, float circleRadius){\n\treturn length(pt - circleOrigin) - circleRadius;\n}\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// map\nfloat distanceEstimator(vec3 pt){\n\tfloat speed = 3.0;\n\tfloat period = 3.0;\n\tfloat movement = (fract(iTime/speed)- .5)*period;\n\tvec2 c1 = vec2(sphereSdf(modPoint(pt,vec3(period)),vec3(0.),.4) , 23.0);\n\tvec3 moving = vec3(0.,(fract(iTime/speed) - .5)*period ,0.); // range of y -period to period\n\tvec2 c2 = vec2(sphereSdf(modPoint(pt-moving,vec3(period)),vec3(0.),.5) , 43.0);\n\n\treturn opSmoothUnion(c1,c2,0.5).x;\n\t//return opSmoothUnion(c1,c2,0.5).x;\n\t\n}\n\nconst float minRadius2 = 1.0;\nconst float fixedRadius2 = 2.0;\nconst float foldingLimit = 2.0;\n\nfloat dist_field(vec3 p) {\n    p.x += cos(0.1 * p.y ) + cos(0.07 * p.z);\n    p.y += cos(0.1 * p.z );\n    p.z += 3.0*cos(0.1 * p.x);\n\tp = max(cos(abs(p)), -0.8);\n    return length(p) - 0.2;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        distanceEstimator(vec3(p.x + EPSILON, p.y, p.z)) - distanceEstimator(vec3(p.x - EPSILON, p.y, p.z)),\n        distanceEstimator(vec3(p.x, p.y + EPSILON, p.z)) - distanceEstimator(vec3(p.x, p.y - EPSILON, p.z)),\n        distanceEstimator(vec3(p.x, p.y, p.z  + EPSILON)) - distanceEstimator(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 estimateNormalDistField(vec3 p) {\n    return normalize(vec3(\n        dist_field(vec3(p.x + EPSILON, p.y, p.z)) - dist_field(vec3(p.x - EPSILON, p.y, p.z)),\n        dist_field(vec3(p.x, p.y + EPSILON, p.z)) - dist_field(vec3(p.x, p.y - EPSILON, p.z)),\n        dist_field(vec3(p.x, p.y, p.z  + EPSILON)) - dist_field(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, vec3 cam_position){\n\t\n\tvec3 point = ro + rd * MIN_DIST;\n\tint i = 0;\n\tfor(i = 0; i < MAX_MARCHES; ++i){\n\n\t\tfloat dist = distanceEstimator(point);\n\t\t//float dist = dist_field(point);\n\n\t\tif(dist < EPSILON && length(point - cam_position ) > 1.0){\n\n\t\t\tbreak;\n\t\t}\n\t\tpoint += rd * dist;\n\t}\n\treturn vec4(point, float(i));\n}\n\nvec4 getColor2(vec3 point, float marches, vec3 rd){\n\n\tvec4 color = vec4(0.0);\n\tvec3 normal = estimateNormal(point);\n\t//vec3 normal = estimateNormalDistField(point);\n\tvec3 albedo = rd;\n\tvec3 surface = albedo * dot(normal,sunlight);\n\tvec3 absnormal = abs(normal);\n\tcolor = vec4(absnormal.rgb,1.0f);\n\tcolor = vec4(surface.rgb,1.0f);\n\t//color = mix(vec4(vec3(marchColor(marches)),1.0f),color,0.2);\n\t\n\treturn color;\n}\n\nvec4 getColor(vec3 point, float marches){\n\n\tvec4 color = vec4(1.0);\n\tvec3 normal = estimateNormal(point);\n\t//color = texture(skybox,normal);\n\tvec4 albedo = vec4(normalize(point),1.0);\n\tcolor = mix(albedo,color,0.6);\n    color = mix(vec4(normal,1.0), color, 0.9);\n    //vec4 fog = albedo;\n    //color = mix(color, fog, percentOfMarches(marches));\n\treturn color;\n}\n\nvec3 reflection(vec3 dir, vec3 normal){\n\treturn dir - 2. * dot(dir, normal) * normal;\n}\n\nvec4 bounceRay(vec3 pt, vec3 rd, vec3 cam_position){\n\tvec4 result = rayMarch(pt, rd, cam_position);\n\tvec4 color = getColor(result.xyz, result.w);\n\n\t// bounce once\n\t//vec4 result2 = rayMarch(result.xyz,estimateNormal(result.xyz));\n\t//vec4 color2 = getColor(result2.xyz,result2.w);\n\t//return mix(color,color2,0.9);\n\n\t// bounce many times\n\tvec4 result2 = result; // to start\n\tfor(int i = 0; i < 0; ++i){\n\t\tvec3 normal =  estimateNormal(result2.xyz);\n\t\trd = reflection(rd, normal);\n\t\tresult2 = rayMarch(result2.xyz, rd, cam_position);\n\t\tvec4 color2 = getColor(result2.xyz,result2.w);\n\t\tcolor = mix(color,color2,0.6);\n\t}\n\treturn color;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy;\n\n    //vec3 camPos = vec3(mouse.x * 10.0, mouse.y * 5.0, 8.0);\n    vec3 camPos = vec3(1.5, 6.0, 11.0);\n    \n    vec3 camTarget = vec3(0.0, 12.0, -10.0);\n    float fovy = 80.0;\n    Camera cam = createCamera(\n        camPos,\n        camTarget,\n        vec3(0.0, 1.0, 0.0),    // world up vector\n        fovy,\n        iResolution.x / iResolution.y);\n    \n\tvec3 rayDir3 = getRay(cam, uv).d;\n\n\t//vec3 rayDir3 = normalize(ray_dir.xyz);\n\t\n    //vec3 point = camera_position;\n    vec3 point = camPos;\n    \n\tvec4 color = bounceRay(point,rayDir3,camPos);\n\t//vec4 color = getColor(result.xyz, result.w);\n\n\t\n\tfragColor = color;\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 422, 460, 460, 502], [504, 504, 535, 535, 588], [733, 733, 843, 843, 1396], [1398, 1398, 1431, 1431, 1575], [1577, 1577, 1608, 1608, 1641], [1643, 1643, 1707, 1707, 1759], [1761, 1761, 1810, 1810, 1914], [1916, 1923, 1956, 1956, 2376], [2473, 2473, 2499, 2499, 2663], [2665, 2665, 2694, 2694, 3058], [3060, 3060, 3098, 3098, 3420], [3422, 3422, 3473, 3473, 3769], [3771, 3771, 3822, 3822, 4183], [4185, 4185, 4226, 4226, 4547], [4549, 4549, 4588, 4588, 4636], [4638, 4638, 4690, 4690, 5271], [5274, 5274, 5331, 5381, 6066]], "test": "untested"}
{"id": "tsGSRy", "name": "Retro Sunrise", "author": "propagant", "description": "Playing around with ShaderToy. Pretty tool... Made this! Simple & easy retro scene reacting to the music that I made.", "tags": ["raymarching", "music", "sunrise", "react"], "likes": 1, "viewed": 263, "published": "Public API", "date": "1574346843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define STEPS 45\n#define MAX_RENDER 5.0\n\nfloat freq;\n\nfloat Sphere(vec3 p, vec4 s)\n{\n    return length(p-s.xyz)-s.w;\n}\n\nvec4 GetDist(vec3 p, int i)\n{\n    vec4 sphere = vec4(0.5, .1,0., Sphere(p,vec4(0., cos(iTime * .2) *0.5, 3., .8 + (freq*.8))));\n    vec4 ground = vec4(0.5, 0.1, 0.6, p.y+.8);\n    vec4 group = vec4((sphere.w<ground.w)?sphere.xyz:ground.xyz, min(sphere.w, ground.w));\n    return group;\n}\n\n\nvec4 rayMarch(vec3 ro, vec3 rd)\n{\n    float originD = 0.0;\n    vec3 col = vec3(0.0);\n    \n \tfor(int i = 0; i < STEPS; i++)\n    {\n        freq = clamp( 2.9*pow( texture( iChannel0, vec2(0.2 + 0.2*float(i)/24.0, 0.15 ) ).x, 3.0 ), 0.0, 1.0 );\n        \n        vec3 pos = ro + rd * originD;\n        vec4 screenP = GetDist(pos, i);\n        originD += screenP.w;\n        col += screenP.xyz;\n        \n        if(originD > MAX_RENDER)\n        {\n            col = abs(vec3(float(i)/(freq * 16.)+abs(sin(iTime/8.))*-1.));\n        \tcol += vec3(1.-rd.y * 8.) + vec3(4.2,0.8,3.9);\n            break;\n        }\n    }\n    \n    return vec4(col,originD);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.y -= 0.5;\n    \n    vec3 ro = vec3(0.0,0.0,-.8);\n    vec3 rd = normalize(vec3(uv.xy,1.0));\n    \n    vec4 c = rayMarch(ro,rd);\n    c/=8.;\n    \n    vec3 col = vec3(c);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XtXGDs", "previewfilepath": "https://soundcloud.com/matejvanco/my-ambition?in=matejvanco/sets/electronic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/matejvanco/my-ambition?in=matejvanco/sets/electronic", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 86, 86, 120], [122, 122, 151, 151, 407], [410, 410, 443, 443, 1050], [1052, 1052, 1109, 1109, 1417]], "test": "untested"}
{"id": "tsGSz3", "name": "Dot Color Swirl", "author": "undeadmockingbird", "description": "A colorful swirl produced with the dot product.", "tags": ["dotproduct"], "likes": 2, "viewed": 93, "published": "Public", "date": "1574574386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xy;\n  vec3 c = uv.xyx / dot(uv.xy, uv.xy) * (cos(iTime / 10.0) + 1.0)\n         + uv.yxx / dot(uv.xy, uv.xy) * (sin(iTime / 10.0) + 1.0);\n  for(int i = 0; i < 10; i++) {\n    float t = tan(dot(uv,uv) / 20.0) - 0.35 * sin(dot(c,c)) - 0.35 * cos(dot(c,c));\n    c += t / 50.0;\n  }\n  c += texture(iChannel0,uv).rgb;\n  c += tan(c * (sin(iTime / 5.0) + 2.0) * 5.0);\n  fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 507]], "test": "untested"}
{"id": "tsGSzc", "name": "Pasta wires", "author": "avin", "description": "Impressed by j2rgb's artwork https://twitter.com/j2rgb/status/1164240582870331392\n\n", "tags": ["lines"], "likes": 35, "viewed": 782, "published": "Public API", "date": "1574603080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n\n#define COUNT 22.\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid rotate(in float angle, inout vec2 uv)\n{    \n    float ca = cos(angle);\n    float sa = sin(angle);\n    uv *= mat2(ca, -sa, sa, ca);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;           \n    rotate(.5, uv);\n    float t = iTime*.75;\n    \n    float sm = (1./iResolution.y * 2.);\n    \n    vec3 res = vec3(0.);\n    \n    for(float i=0.; i<COUNT;i+=1.){\n        vec2 oiuv = uv;\n        vec2 iuv = uv;\n        \n        iuv.x += rand1(i+COUNT)*.5 - .25;\n        \n        iuv.x += simplex_noise(vec3(i, oiuv.y + t, rand1(i+COUNT)))*.25;\n\n        float angle = rand1(i)*.5;\n        rotate(angle, iuv);        \n        \n        float perc = i/COUNT;\n        \n        float width = (perc + .5)*.015 - rand1(i+COUNT*3.)*.01;\n        float ism = sm; // + (1. - perc)*.025;\n            \n    \tfloat g = smoothstep(width + ism, width, abs(iuv.x));\n        \n        float gSh = smoothstep(width, width + ism*10., abs(iuv.x));\n        \n        res = res*clamp(gSh + .5, .0, 1.);\n        \n        vec3 lineCol = hsv2rgb(vec3(.5 + rand1(i+COUNT*2.)*.41, rand1(i)*.5+.25, 1.0)).rgb;\n        \n        res = mix(res, lineCol,  g);\n    }               \n\n    // Output to screen\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 179, 179, 306], [348, 348, 370, 370, 522], [524, 524, 553, 553, 1217], [1219, 1219, 1263, 1263, 1357], [1359, 1359, 1416, 1416, 2491]], "test": "untested"}
{"id": "tsGSzw", "name": "waterphobia", "author": "artemshypulya", "description": "sea", "tags": ["ocean"], "likes": 10, "viewed": 367, "published": "Public API", "date": "1573611639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A documented, altered, recolored version of \"Seascape\".\n// The famous original at:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// Commenting added by bteitler\n//  HSV/color adjustments and additional commenting by CaliCoastReplay - 2016\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// PI is a mathematical constant relating the ratio of a circle's circumference (distance around\n// the edge) to its diameter (distance between two points opposite on the edge).  \n// Change pi at your own peril, with your own apologies to God.\nconst float PI\t \t= 3.14159265358;\n\n// Can you explain these epsilons to a wide graphics audience?  YOUR comment could go here.\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM\t(0.1 / iResolution.x)\n\n// Constant indicaing the number of steps taken while marching the light ray.  \nconst int NUM_STEPS = 4;\n\n//Constants relating to the iteration of the heightmap for the wave, another part of the rendering\n//process.\nconst int ITER_GEOMETRY = 2;\nconst int ITER_FRAGMENT =5;\n\n// Constants that represent physical characteristics of the sea, can and should be changed and \n//  played with\nconst float SEA_HEIGHT = 1.1;\nconst float SEA_CHOPPY = 5.0;\nconst float SEA_SPEED = 0.9;\nconst float SEA_FREQ = 0.14;\nconst vec3 SEA_BASE = vec3(0.11,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.55,0.9,0.7);\n#define SEA_TIME (iTime * SEA_SPEED)\n\n//Matrix to permute the water surface into a complex, realistic form\nmat2 octave_m = mat2(1.7,1.1,-1.1,1.4);\n\n//Space bar key constant\nconst float KEY_SP    = 32.5/256.0;\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts red-green-blue color to hue-saturation-value color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//CaliCoastReplay :  These HSV/RGB translation functions are\n//from http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n//This one converts hue-saturation-value color to red-green-blue color\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \t//d += sea_octave((uv-SEA_TIME)*freq,choppy);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *=  octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        \n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m/1.2;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.45;\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n))*0.89;    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.27; \n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n\n//CaliCoastReplay :  Keyboard checking function from the iChannel representing keyboard input\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 1.0) ).x;\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 500.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 0.3 + iMouse.x*0.01; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n\n    // bteitler: Calculated a vector that smoothly changes over time in a sinusoidal (wave) pattern.  \n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.25,time);\n    \n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5, at x 0 (zero), and flies over the ocean in the z axis over time.\n    vec3 ori = vec3(0.0,3.5,time*5.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    // dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // CaliCoastReplay:  Get the sky and sea colors\n\tvec3 skyColor = getSkyColor(dir);\n    vec3 seaColor = getSeaColor(p,n,light,dir,dist);\n    \n    //Sea/sky preprocessing\n    \n    //CaliCoastReplay:  A distance falloff for the sea color.   Drastically darkens the sea, \n    //this will be reversed later based on day/night.\n    seaColor /= sqrt(sqrt(length(dist))) * 1.2;\n    \n    \n    //CaliCoastReplay:  Day/night mode\n    bool night; \t \n    if( isKeyPressed(KEY_SP) > 0.0 )    //night mode!\n    {\n        //Brighten the sea up again\n    \tseaColor *= seaColor * 8.5;\n        //Turn down the sky and adjust\n    \tskyColor /= 1.79;\n        skyColor.z *= 1.29;\n        skyColor.z -= 0.07;\n        night = true;\n    }\n    else  //day mode!\n    {\n        //Brighten the sea up again\n    \tseaColor *= sqrt(sqrt(seaColor)) * 5.0;\n        skyColor *= 0.95;\n        night = false;\n    }\n\n    \n    //CaliCoastReplay:  A slight \"constrasting\" for the sky to match the more contrasted ocean\n    skyColor *= skyColor / 1.1;\n    \n    \n    //CaliCoastReplay:  A simple but pretty beautiful hack that actually darkens\n    //the highest-value spots somewhat to add even more contrast\n    vec3 seaHsv = rgb2hsv(seaColor);\n    if (seaHsv.z > .78 && length(dist) < 50.0)\n        seaHsv.z -= (0.85 - seaHsv.z) * 1.8;\n    seaColor = hsv2rgb(seaHsv);\n    \n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    \n    vec3 color = mix(\n        skyColor,\n        seaColor,\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n        \n    // Postprocessing\n    \n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n    \n    // CaliCoastReplay:  Adjust hue, saturation, and value adjustment for an even more processed look\n    // hsv.x is hue, hsv.y is saturation, and hsv.z is value\n    vec3 hsv = rgb2hsv(fragColor.xyz);    \n    //CaliCoastReplay: Increase saturation slightly\n    hsv.y += 0.091;\n    //CaliCoastReplay:\n    //A pseudo-multiplicative adjustment of value, increasing intensity near 1 and decreasing it near\n    //0 to achieve a more contrasted, real-world look\n    hsv.z *= sqrt(hsv.z) * 1.2; \n    \n    if (night)    \n    {\n    ///CaliCoastReplay:\n    //Slight value adjustment at daynight to turn down global intensity\n        hsv.z -= 0.045;\n        hsv*=0.7;\n    }\n    else\n    {\n      //CaliCoastReplay:\n        //Add green tinge to the high range\n      //Turn down intensity in day in a different way     \n        \n        hsv.z *= 0.9;\n        \n        //CaliCoastReplay:  Hue alteration \n        hsv.x -= hsv.z/10.0;\n        //Final brightening\n        hsv.z *= 1.2;\n    }\n    \n    //CaliCoastReplay:    \n    //Replace the final color with the adjusted, translated HSV values\n    fragColor.xyz = hsv2rgb(hsv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGSzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1627, 1860, 1882, 1882, 2213], [2215, 2448, 2470, 2470, 2639], [2641, 2715, 2741, 2741, 3087], [3089, 3555, 3577, 3577, 3660], [3662, 3923, 3949, 3949, 5583], [5585, 5667, 5705, 5705, 5747], [5749, 5817, 5863, 5863, 5967], [5969, 6059, 6085, 6085, 6223], [6225, 6748, 6789, 7191, 10343], [10345, 10514, 10533, 10533, 12818], [12820, 12990, 13018, 13018, 15312], [15314, 15556, 15619, 15755, 16642], [16644, 16984, 17019, 17362, 18402], [18405, 18499, 18530, 18530, 18580], [18582, 18645, 18701, 18701, 22014], [22016, 22024, 22081, 22216, 28483]], "test": "untested"}
{"id": "tsKSRh", "name": "Glass Refuge 2", "author": "ShnitzelKiller", "description": "A less hellish version for easy viewing.", "tags": ["raytracing", "raymarching", "reflection", "refraction", "glossy"], "likes": 11, "viewed": 305, "published": "Public API", "date": "1573445252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 25\n#define TOL 0.01\n#define FDIST 0.5\n#define MAXDIST 50.\n#define PI 3.1415927\n\n#define PLANE_HEIGHT -0.6\n\n#define SAMPLES 10\n#define GRID_SCALE 40.\n#define GRID_MAGNITUDE 0.025\n#define RADIUS 0.6\n#define SPACING 1.5\n#define OSC_MAGNITUDE 0.75\n#define OSC_SPEED 0.75\n#define ROT_SPEED 2.\n#define STRIPE_WIDTH 0.5\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat rand(in vec2 uv) {\n    return fract(865.1445*sin(dot(vec2(-1995.11, 144.969), uv)));\n}\n\nfloat map(in vec3 ro, out vec2 uv) {\n    vec2 id = floor(ro.xy/SPACING + 0.5);\n\tfloat offset = rand(id) * 2.*PI;\n    float angle = ROT_SPEED * iTime + offset;\n    //float angle = iTime*(ROT_SPEED*(offset-0.5));\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    ro.xy = mod(ro.xy + SPACING*0.5, vec2(SPACING))-SPACING*0.5;\n\tuv = rot * ro.xy;\n    return length(ro - vec3(0., 0., OSC_MAGNITUDE) * abs(sin(iTime * OSC_SPEED*0.75 + offset)))-RADIUS;\n}\n\nvec3 getnormal(vec3 ro) {\n    vec2 uv;\n    vec2 d = vec2(TOL, 0.0);\n    float x1 = map(ro+d.xyy, uv);\n    float x2 = map(ro-d.xyy, uv);\n    float y1 = map(ro+d.yxy, uv);\n    float y2 = map(ro-d.yxy, uv);\n    float z1 = map(ro+d.yyx, uv);\n    float z2 = map(ro-d.yyx, uv);\n    return normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2));\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd, out vec2 uv) {\n    float t = 0.;\n    for (int i=0; i<MAX_STEP; i++) {\n        float dist = map(ro+t*rd, uv);\n        t += dist;\n        if (dist < TOL) {\n            return vec2(t, 1.);\n        } else if (dist > MAXDIST) break;\n    }\n    return vec2(t, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 eye = vec3(iTime, 10.*sin(iTime*0.2), 0.5);\n    float mouseX = iMouse.z > 1. ? 2.*iMouse.x/iResolution.x-0.5 : 0.;\n    float mouseY = iMouse.w > 1. ? 2.*iMouse.y/iResolution.y-0.5 : 0.;\n    vec3 w = normalize(vec3(1., cos(iTime*0.2) - mouseX, mouseY + 0.5*sin(iTime*0.1367)));\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    rd.z = -abs(rd.z);\n    \n    //project onto plane\n    vec3 ro = eye + ((PLANE_HEIGHT-eye.z)/rd.z) * rd;\n    \n    vec3 col = vec3(0.);\n    vec3 bgcol = mix(vec3(1.), vec3(0., 1., 1.), abs(rd.z));\n    \n    float horiz = length(ro.xy - eye.xy);\n    if (rd.z > 0. || horiz > MAXDIST) {\n        fragColor = vec4(bgcol, 1.);\n        return;\n    }\n\n    for (int i=0; i<SAMPLES; i++) {\n        vec2 theta = rand2d(ro.xy + float(i) * vec2(104., -30.6));\n        theta *= vec2(2.*PI, 0.02*PI);\n        vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n        n = normalize(n + vec3(vec2(GRID_MAGNITUDE, GRID_MAGNITUDE)*cos(ro.xy*GRID_SCALE), 0.));\n        vec3 newrd = reflect(rd, n);\n        vec2 uv2;\n        vec2 t = raymarch(ro, newrd, uv2);\n\t\tvec3 newro = ro + newrd*t.x;\n        //lighting\n        if (t.y > 0.5) {\n            //shapes\n            vec3 normal = getnormal(newro);\n            float fac = max(0., dot(normal, vec3(0., 0., -1.)));\n            vec2 stripe = step(vec2(STRIPE_WIDTH), mod(uv2, vec2(STRIPE_WIDTH*2.)));\n            vec3 tex = mix(vec3(0., 0.6, 1.), vec3(1., 1., 0.), abs(stripe.x - stripe.y));\n            col += tex * fac;\n        } else {\n            //background color\n            col += bgcol;\n        }\n    }\n    col /= float(SAMPLES);\n    col = mix(bgcol, col, smoothstep(MAXDIST, MAXDIST-50., horiz));\n    \n    fragColor = vec4(pow(col, vec3(0.5)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 356, 356, 464], [466, 466, 490, 490, 558], [560, 560, 596, 596, 1046], [1048, 1048, 1073, 1073, 1395], [1397, 1397, 1449, 1449, 1694], [1696, 1696, 1753, 1753, 3683]], "test": "untested"}
{"id": "tsKSWw", "name": "Codevember06 - Music", "author": "z0rg", "description": "My participation at codevember 06 \"Music\"", "tags": ["light", "codevember", "dnb", "drumnbass"], "likes": 6, "viewed": 256, "published": "Public API", "date": "1574192722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nfloat _union(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat sdf_cir(vec2 uv, float r)\n{\n  return length(uv)-r;\n}\n\nfloat sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nfloat rdrCir(vec2 uv, float r, float th)\n{\n  float col= sat(1.-_sub(sdf_cir(uv, r),sdf_cir(uv,r-th))/0.005);\n col += abs(uv.y)-(sin(25.*uv.x+iTime)*0.2+0.2)*0.1;\nreturn col;\n}\n\nvec3 rdrChroma(vec2 uv)\n{\n  float r = length(uv)*0.15;\n//  uv = uv+vec2(sin(iTime),cos(iTime))*0.2;\n  vec3 col;\n\n  col.r = rdrCir(uv+uv*r,0.1,0.01);\n  col.g = rdrCir(uv,0.1,0.01);\n  col.b = rdrCir(uv-uv*r,0.1,0.01);\n  return col;\n}\n\nbool inTriangle(vec2 A, vec2 B, vec2 C, vec2 P, float thick)\n{\n  vec2 v0 = C - A ;\n  vec2 v1 = B - A ;\n  vec2 v2 = P - A; // Compute dot products\n  float dot00 = dot(v0, v0) ;\n  float dot01 = dot(v0, v1) ;\n  float  dot02 = dot(v0, v2) ;\n  float dot11 = dot(v1, v1) ;\n  float dot12 = dot(v1, v2) ;\n  // Compute barycentric coordinates\n  float invDenom = 1. / (dot00 * dot11 - dot01 * dot01) ;\n  float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n   float v = (dot00 * dot12 - dot01 * dot02) * invDenom ;\n   // Check if point is in triangle return\n   ;\n   return (u >= 0.) && (v >= 0.) && (u + v < 1.) &&\n   (u<thick||v<thick||(u+v)>1.-thick);\n}\n\nfloat curve(float a)\n{\n  return max(mod(iTime,10.)/10.,0.5)*(sin(iTime+a*102.4)*0.5+0.5)*((sin(a*5.-iTime*15.)*0.3+0.3)+(sin((iTime+a)*13.5)*0.5+0.5));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 acc;\n\n  for (int i= 0;i<16;++i)\n  {\n    float fi = float(i);\n    acc += rdrChroma(uv*float(i+1)*0.02*(sin(iTime)*0.2+0.5)*sin(fi+iTime))*(fi/32.)*length(uv);\n  }\n\n  vec2 posT= vec2(0.,0.);\n  float rT = 1.7+float(mod(iTime,0.25*sin(iTime)));\n  float aT = (PI*2.)/3.;\n  float offA = iTime;\n\n  vec2 A = vec2(rT*sin(aT*1.+offA),rT *cos(aT*1.+offA))-posT;//+vec2(0.,0.1*sin(iTime));\nvec2 B = vec2(rT*sin(aT*2.+offA),rT *cos(aT*2.+offA))-posT;\nvec2 C = vec2(rT*sin(aT*3.+offA),rT *cos(aT*3.+offA))-posT;\nif(inTriangle(A,B,C,uv,0.1))\n  acc=1.-acc;\n\nacc*= mix(vec3(1.),vec3(1.,0.,0.),1.-sat(sdf_rect(uv-vec2(0.,0.),vec2(0.5,2.5))*25.));\nacc += (mod(uv.x,0.1)*20.)*vec3(0.4,0.4,0.89)* sat(1.-length(uv))*sat((abs(curve(uv.x)*.5)-abs(uv.y))*5.);\n  acc+=(sin(iTime)*0.2+1.3)*2.*pow(sat((1.-lenny(uv*.5))*1.),3.)*vec3(.4,.4,.89);\n  return acc;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv = uv-(iResolution.xy/iResolution.xx)*0.5;\nuv*=6.;\n vec3 col;// = vec3(length(uv));\n col += rdr(uv);\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKSWw.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 428, 449, 449, 479], [480, 480, 500, 500, 527], [529, 529, 559, 559, 581], [583, 583, 615, 615, 636], [638, 638, 671, 671, 696], [698, 698, 732, 732, 780], [782, 782, 824, 824, 957], [959, 959, 984, 984, 1190], [1192, 1192, 1254, 1254, 1838], [1840, 1840, 1862, 1862, 1993], [1995, 1995, 2014, 2014, 2855], [2859, 2859, 2916, 2916, 3097]], "test": "untested"}
{"id": "tsKXR1", "name": "simple hive", "author": "fancyzero", "description": "alternative Voronin, use second smallest distance instead of the smallest", "tags": ["cellnoise"], "likes": 4, "viewed": 82, "published": "Public", "date": "1573612662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 noise2(vec2 uv)\n{\n    \n    return normalize(texture(iChannel0,uv).xy+0.001);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y*5.+iTime;\n\n    vec2 fuv = fract(uv);\n    vec2 guv = floor(uv);\n    vec2 site = noise2(guv*0.023)*0.5;\n\tfloat d =floor( (1.-length(fuv - (site+0.5)))+0.11);\n    \n    float mind = 1000000.;\n    float mind2 = 1000000.;\n    for ( int x = -1; x <=1; x++)\n        for ( int y = -1; y <=1; y++)\n        {\n            vec2 testuv = vec2(guv.x + float(x), guv.y + float(y));\n            vec2 site = noise2(testuv*0.023)*0.5 +testuv;\n            float dist = length((fuv+guv) - (site+0.5));\n            if (mind > dist )\n            {\n               \tmind2 = mind;\n                mind = dist;\n            }\n        }\n\n    // Output to screen\n    fragColor = 1.-vec4(mind2,mind2,mind2,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 83], [85, 85, 142, 192, 913]], "test": "untested"}
{"id": "tsKXRd", "name": "Many color balls", "author": "avin", "description": "visual experiment", "tags": ["colors", "balls"], "likes": 3, "viewed": 368, "published": "Public API", "date": "1574792031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n\n\nfloat map(vec3 p) {\t\n    vec3 pp = floor(p+.1);\n    p += vec3(\n        iTime * (rand1(pp.z) - .5),\n        iTime * (rand1(pp.z + 200.) - .5), \n        0.\n    );\n        \n\treturn length(\n        (fract(p) - 0.5)                \n    ) - .15 + sin(iTime*2.)*.025;\n}\nvec3 getN(vec3 p) {\n\tfloat t = map(p);\n\tvec2 d = vec2(0.001, .0);\n\treturn normalize(vec3(\n\t\tt - map(p + d.xyy),\n\t\tt - map(p + d.yxy),\n\t\tt - map(p + d.yyx)));\n\t\t\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;       \n\n    vec3 dir = normalize(vec3(uv, 1.));\n\tvec3 pos = vec3(-50 , 50, 1.);\n\tfloat t= 0.0;\n\tfor(int i = 0 ; i < 200; i++ ) {\n\t\tt += map(dir * t * 1.0 + pos);        \n\t}\n\tvec3 ip = dir * t + pos;\n\tvec3 L = normalize(vec3(1,2,3));\n\tvec3 N = getN(ip);\n\n    vec3 ipp = floor(ip);    \n    \n    ipp = floor(ipp);    \n    vec3 vip = ip + vec3(\n        iTime * (rand1(ipp.z) - .5),\n        iTime * (rand1(ipp.z + 200.) - .5), \n        0.\n    );\n    vip = floor(vip);\n    \n    vec3 col = hue(rand1(floor(vip.z*vip.x*vip.y)*.1)).rgb;       \n    \n    fragColor = vec4(col * dot(L, N), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 153, 153, 396], [397, 397, 416, 416, 559], [565, 565, 622, 622, 1274]], "test": "untested"}
{"id": "tsKXRK", "name": "Heart Pump Animated", "author": "edubart", "description": "Animated heart", "tags": ["raymarch", "animated", "heart"], "likes": 4, "viewed": 118, "published": "Public", "date": "1574466254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 100.0\n#define MAX_STEPS 128\n#define SURF_DIST 0.0001\n#define M_PI 3.1415926535897932384626433832795\n#define AA 2\n\n#define MATERIAL_BODY 1\n\nstruct Hit {\n    float d;\n    int material;\n};\n\n// Distance to sphere at origin of radius `r`\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n#define check_hit(m) if(dist < mindist) { material = m; mindist = dist; }\n\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\n// Return the closest surface distance to point p\nHit get_sdf(vec3 p) {\n    float mindist = MAX_DIST;\n    int material = 0;\n    float dist;\n\n    // heart\n    vec3 q = p;\n    q.x = abs(q.x);\n    q.x = almostIdentity(q.x, 2.0, 1.0);\n    q.z = q.z*(2.0 - q.y/15.0);\n    q.y = 4.0 + 1.2*q.y - q.x*sqrt(max((20.0-q.x)/15.0, 0.0));\n    dist = sd_sphere(q, 15.0 + pow(0.5 + 0.5*sin(iTime*10.0 + q.y/25.0 + q.x/12.0 + q.z/20.0), 4.0)*3.0);\n    dist /= 3.0;\n    check_hit(MATERIAL_BODY);\n\n    return Hit(mindist, material);\n}\n\n// Get normal at point `p` using the tetrahedron technique for computing the gradient\nvec3 get_normal(vec3 p) {\n    const float eps = 0.01;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize(e.xyy*get_sdf(p + e.xyy*eps).d + \n                     e.yyx*get_sdf(p + e.yyx*eps).d + \n                     e.yxy*get_sdf(p + e.yxy*eps).d + \n                     e.xxx*get_sdf(p + e.xxx*eps).d);\n}\n\n// March a ray from `rayfrom` along the `raydir` direction and return the closet surface distance\nHit ray_march(vec3 rayfrom, vec3 raydir) {\n    // begin at ray origin\n    float t = 0.0;\n    Hit hit;\n    // ray march loop\n    for(int i=0; i<MAX_STEPS; ++i) {\n        // compute next march point\n        vec3 p = rayfrom+t*raydir;\n        // get the distance to the closest surface\n        hit = get_sdf(p);\n        // hit a surface\n        if(abs(hit.d) < (SURF_DIST*t))\n            break;\n        // increase the distance to the closest surface\n        t += hit.d;\n    }\n    if(t > MAX_DIST)\n        hit.material = 0;\n    // return the distance to `rayfrom`\n    hit.d = t;\n    return hit;\n}\n\n// Hard shadows\nfloat hard_shadow(vec3 rayfrom, vec3 raydir, float tmin, float tmax) {\n    float t = tmin;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayfrom + raydir*t;\n        float h = get_sdf(p).d;\n        if(h < SURF_DIST)\n            return 0.0;\n        t += h;\n        if(t > tmax)\n            break;\n    }\n    return 1.0;\n}\n\n// Get occlusion along `normal` from point of view `rayfrom`\nfloat get_occlusion(vec3 rayfrom, vec3 normal) {\n    const int AO_ITERATIONS = 5;\n    const float AO_START = 0.01;\n    const float AO_DELTA = 0.11;\n    const float AO_DECAY = 0.95;\n    const float AO_INTENSITY = 1.0;\n\n    float occ = 0.0;\n    float decay = 1.0;\n    for(int i=0; i<AO_ITERATIONS; ++i) {\n        float h = AO_START + float(i) * AO_DELTA;\n        float d = get_sdf(rayfrom + h*normal).d;\n        occ += (h-d) * decay;\n        decay *= AO_DECAY;\n    }\n    return clamp(1.0 - occ * AO_INTENSITY, 0.0, 1.0);\n}\n\n// Return diffuse albedo color for material\nvec3 get_material_diffuse(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.3, 0.0, 0.0);\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\n// Return specular color for material\nvec3 get_material_specular(vec3 p, int material) {\n    switch(material) {\n        case MATERIAL_BODY:\n            return vec3(0.3, 0.05, 0.05)*3.0;\n        default:\n            return vec3(0.0);\n    }\n}\n\n// Compute the scene light at a point\nvec3 get_light(vec3 raydir, vec3 p, int material) {\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    vec3 normal = get_normal(p);\n    float occlusion = get_occlusion(p, normal);\n\n    // sun light\n    const float SUN_INTENSITY = 1.0;\n    const float SUN_SHINESS = 8.0;\n    const vec3 SUN_DIRECTION = normalize(vec3(0.6, 0.35, 0.5));\n    const vec3 SUN_COLOR = vec3(1.0,0.77,0.6);\n\n    float sun_diffuse = clamp(dot(normal, SUN_DIRECTION), 0.0, 1.0);\n    float sun_shadow = hard_shadow(p, SUN_DIRECTION, 0.01, 20.0);\n    float sun_specular = pow(clamp(dot(reflect(SUN_DIRECTION, normal), raydir), 0.0, 1.0), SUN_SHINESS);\n\n    diffuse += SUN_COLOR * (sun_diffuse * sun_shadow * SUN_INTENSITY);\n    specular += SUN_COLOR * sun_specular;\n\n    // sky light\n    const float SKY_INTENSITY = 1.0;\n    const float SKY_SHINESS = 8.0;\n    const float SKY_BIAS = 0.5;\n    const vec3 SKY_COLOR = vec3(0.50,0.70,1.00);\n    const vec3 SKY_DIRECTION = vec3(0.0, 1.0, 0.0);\n\n    float sky_diffuse = SKY_BIAS + (1.0 - SKY_BIAS)*clamp(dot(normal, SKY_DIRECTION), 0.0, 1.0);\n    float sky_specular = pow(clamp(dot(reflect(SKY_DIRECTION, normal), raydir), 0.0, 1.0), SKY_SHINESS);\n    diffuse += SKY_COLOR * (SKY_INTENSITY * sky_diffuse * occlusion);\n    specular += SKY_COLOR * (sky_specular * occlusion);\n\n    // fake indirect light\n    const float INDIRECT_INTENSITY = 0.2;\n    const float INDIRECT_SHINESS = 8.0;\n    const vec3 INDIRECT_COLOR = SUN_COLOR;\n\n    vec3 ind_dir = normalize(SUN_DIRECTION * vec3(-1.0,0.0,1.0));\n    float ind_diffuse = clamp(dot(normal, ind_dir), 0.0, 1.0);\n    float ind_specular = pow(clamp(dot(reflect(ind_dir, normal), raydir), 0.0, 1.0), INDIRECT_SHINESS);\n    diffuse += INDIRECT_COLOR * (ind_diffuse * INDIRECT_INTENSITY);\n    specular += INDIRECT_COLOR * (ind_specular * INDIRECT_INTENSITY);\n\n    // fresnel light\n    const float FRESNEL_INTENSITY = 2.0;\n    const vec3 FRESNEL_COLOR = SUN_COLOR;\n    float fresnel_diffuse = clamp(1.0+dot(raydir, normal), 0.0, 1.0);\n    diffuse += FRESNEL_COLOR * (FRESNEL_INTENSITY * fresnel_diffuse * (0.5 + 0.5*sun_diffuse));\n    \n    // apply material\n    vec3 col = diffuse * get_material_diffuse(p, material) +\n               specular * get_material_specular(p, material);\n\n    // gamma correction\n    col = pow(col, vec3(0.4545));\n\n    return col;\n}\n\nvec3 get_sky_background(vec3 raydir) {\n    const vec3 SKY_COLOR1 = vec3(0.4,0.75,1.0);\n    const vec3 SKY_COLOR2 = vec3(0.7,0.8,0.9);\n    vec3 col = mix(SKY_COLOR2, SKY_COLOR1, exp(10.0*raydir.y));\n    return col;\n}\n\n// Return camera transform matrix looking from `lookfrom` towards `lookat`, with tilt rotation `tilt`,\n// vertical field of view `vfov` (in degrees), at coords `uv` (in the range [-1,1])\nvec3 get_ray(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n    // camera up vector\n    vec3 vup = vec3(sin(tilt), cos(tilt), 0.0);\n    // camera look direction\n    vec3 lookdir = normalize(lookat - lookfrom);\n    // unit vector in camera x axis\n    vec3 u = cross(lookdir, vup);\n    // unit vector in camera y axis\n    vec3 v = cross(u, lookdir);\n    // vector in camera z axis normalized by the fov\n    vec3 w = lookdir * (1.0 / tan(vfov*M_PI/360.0));\n    // camera transformation matrix\n    mat3 t = mat3(u, v, w);\n    // camera direction\n    return normalize(t * vec3(uv, 1.0));\n}\n\nvec3 render(vec2 uv) {\n    float theta = 10.0*iMouse.x/iResolution.x + iTime;\n    vec3 lookat = vec3(0.0, 1.0, 0.0);\n    vec3 lookfrom = vec3(80.0*sin(theta), 5.0, 80.0*cos(theta));\n    vec3 raydir = get_ray(lookfrom, lookat, 0.0, 30.0, uv);\n    Hit hit = ray_march(lookfrom, raydir);\n    vec3 p = lookfrom + raydir * hit.d;\n    if(hit.material > 0)\n        return get_light(raydir, p, hit.material);\n    else\n        return get_sky_background(raydir);\n}\n\nvec3 render_aa(vec2 uv) {\n#if AA > 1\n    float w = 1.0/iResolution.y;\n    vec3 col = vec3(0.0);\n    for(int n=0; n<AA*AA; ++n) {\n        vec2 o = 2.0*(vec2(float(int(n / AA)),float(int(n % AA))) / float(AA) - 0.5);\n        col += render(uv + o*w);\n    }\n    col /= float(AA*AA);\n    return col;\n#else\n    return render(uv);\n#endif\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n    // uv coords in range from [-1,1] for y and [-aspect_ratio,aspect_ratio] for x\n    vec2 uv = 2.0 * ((fragcoord-0.5*iResolution.xy) / iResolution.y);\n    // render the entire scene\n    vec3 col = render_aa(uv);\n    // set the finished color\n    fragcolor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 250, 284, 284, 312], [390, 390, 441, 441, 570], [572, 622, 643, 643, 1088], [1090, 1176, 1201, 1201, 1479], [1481, 1579, 1621, 1648, 2172], [2174, 2190, 2260, 2260, 2516], [2518, 2579, 2627, 2627, 3099], [3101, 3145, 3194, 3194, 3350], [3352, 3390, 3440, 3440, 3592], [3594, 3632, 3683, 3683, 5953], [5955, 5955, 5993, 5993, 6170], [6172, 6359, 6434, 6458, 6959], [6961, 6961, 6983, 6983, 7415], [7417, 7417, 7442, 7442, 7749], [7751, 7751, 7806, 7889, 8081]], "test": "untested"}
{"id": "tsKXRw", "name": "Spinning Optical Illusion", "author": "gbunny", "description": "Started out with polar functions to create flower petals. And then I started questioning what it would look like to stress test the screen with 6000 petals. Ended up creating an optical illusion that is making me thoroughly nauseous. Enjoy & mouse around.", "tags": ["flower", "optical", "illusion", "polar"], "likes": 1, "viewed": 77, "published": "Public", "date": "1573686205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Flower(vec2 st, vec3 color, float numOfPetals, float centeringX, float centeringY){\n    st.x -= centeringX;\n    st.y -= centeringY;\n    float radius = length(st) * 2.0;\n    float a = atan(st.y,st.x);\n    float f= abs(cos(a*numOfPetals*.5))+.4;\n    vec3 temp = vec3(1. - smoothstep(f,radius, .9));\n    temp += color;\n    return temp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    st.x *= aspect; \n    vec3 color = Flower(st, vec3(sin(iTime/20.),cos(iTime /20.)*0.30,sin(iTime/20.*0.73)), sin(iTime/100.) * 6000., iMouse.x / (iResolution.x / aspect), iMouse.y/iResolution.y);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 88, 88, 339], [341, 341, 398, 398, 722]], "test": "untested"}
{"id": "tsKXzh", "name": ".triangle", "author": "levonchic", "description": "Triange with distance cast", "tags": ["triangle"], "likes": 0, "viewed": 72, "published": "Public", "date": "1573459763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.14159265359\n#define PI0 6.28318530718\n#define PI2 1.57079632679\n#define PI4 0.78539816339\n\n// SQRT\nfloat circle(vec2 v, vec2 center, float radius) {\n    return distance(v, center) - radius;\n}\n\n// Segment from A to B as line\nfloat segment(vec2 v, vec2 A, vec2 B) {\n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\n// Segment from A to B as segment\nfloat segment_check(vec2 v, vec2 A, vec2 B, float far) {\n    vec2 b = B - A;\n    vec2 a = v - A;\n    float frac = dot(a, b) / dot(b, b);\n    if (frac < 0.0 || frac > 1.0)\n        return far;\n    \n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\n// Distance to color function\nvec4 color(float dist) {\n\tvec4 c;\n\tc.a = 1.0;\n\t// c.r = 0.3 * sin(dist * 2.0 * PI * 40.0 + iTime * 2.0 * PI * 2.0);\n\t// c.g = 0.7 * sin(dist * 2.0 * PI * 80.0 + iTime * 2.0 * PI * 2.0);\n\t// c.b = 0.3 * sin(dist * 2.0 * PI * 120.0 + iTime * 2.0 * PI * 2.0);\n\t\n    // c.r = c.g = c.b = sin(dist * PI * 40.0 + mod(iTime, 1.0) * PI * 8.0);\n    //if (dist < 0.0120 * PI)\n\t//c.r = c.g = c.b = sin(dist * PI * 40.0 + PI2);\n    \n    // Neon\n\tc.r = c.g = c.b = 1. / pow(2.0 + 0.5 * sin(iTime * 2.0), dist * 100.);\n    c.g *= 1.0;\n    c.r *= 0.3;\n    c.b *= 0.7;\n\t\n    return c;\n}\n\nfloat triangle(vec2 uv, vec2 A, vec2 B, vec2 C, float far) {\n    float mn = far;\n    mn = min(mn, segment_check(uv, A, B, 10.0));\n    mn = min(mn, segment_check(uv, B, C, 10.0));\n    mn = min(mn, segment_check(uv, C, A, 10.0));\n    mn = min(mn, circle(uv, A, 0.0));\n    mn = min(mn, circle(uv, B, 0.0));\n    mn = min(mn, circle(uv, C, 0.0));\n    return mn;\n}\n\n// DISPLAY\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / max(iResolution.x, iResolution.y);\n    \n    vec2 A = 0.1 * vec2(cos(1.0 * PI / 3.0 + iTime), sin(1.0 * PI / 3.0 + iTime));\n    vec2 B = 0.1 * vec2(cos(3.0 * PI / 3.0 + iTime), sin(3.0 * PI / 3.0 + iTime));\n    vec2 C = 0.1 * vec2(cos(5.0 * PI / 3.0 + iTime), sin(5.0 * PI / 3.0 + iTime));\n    \n    float mn = 10.0; // abs(circle(uv, vec2(0.0), 0.2));\n    \n    mn = min(mn, triangle(uv, A, B, C, 10.0));\n    \n    fragColor = color(mn);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 113, 162, 162, 205], [207, 238, 277, 277, 390], [392, 426, 482, 482, 734], [736, 766, 790, 790, 1336], [1338, 1338, 1398, 1398, 1696], [1698, 1709, 1764, 1764, 2252]], "test": "untested"}
{"id": "tsKXzm", "name": "Voronoi edge extraction explaine", "author": "fancyzero", "description": "an animation to explain the process of edge extraction of a single Voronoi cell\n\ntodo: add on-screen comments", "tags": ["voronoi", "edge"], "likes": 16, "viewed": 218, "published": "Public", "date": "1573800799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 ZhouLin \n\n\n// a demo shows how to extract edge of a single cell of 5 sites voronoi diagram\n// the red point: voronoin site\n// the blue line: segment defined by two sites\n// the green point: middle point of connection lines\n// the brown line: a line  perpendicular to connection line and pass middle point\n\n#define POINT_COUNT 5\nvec2 sites[POINT_COUNT];\n\nvec3 EdgeColor1 = vec3(0.,0.,0.)/255.0;\nvec3 EdgeColor2 = vec3(255.,255.,255.)/255.0;\n\n#define saturate(x) clamp(x,0.,1.)\n\nvec2 DistToLine( vec2 uv, vec2 o, vec2 d )\n{\n    float t = dot(uv-o, d);\n    d = d.yx*vec2(-1.,1.);\n    float dist = dot(uv-o,d);\n    return vec2(abs(dist), t);\n}\n\nvec4 DrawPoint( vec2 uv, vec2 pos, vec3 col, float size)\n{\n    size *= 0.03;\n    float dist = length(uv- pos);\n    return vec4(col,smoothstep(0.,size,(size- dist)*1.5));\n}\n\nvec4 DrawSites( float dist )\n{\n    return vec4(1.,0.,0., clamp((1.-dist*40.)*2., 0.,1.));\n}\n\nvec4 DrawLineSegment(vec2 a, vec2 b, vec2 uv)\n{\n    if (dot(a-b,a-b) < 0.0001)\n        return vec4(0.,0.,0.,0.);\n\tvec2 o = (a+b)/2.;\n    vec2 d = normalize(a-b);\n        \n    vec2 dist = DistToLine(uv, o, d);\n\n    \n    float brightness = smoothstep(0.995,1.,1.-dist.x)*2.;\n    return  saturate(vec4(1.,1.,1., brightness*saturate(ceil(1.-abs((dist.y)/length(a-b)*2.)))));    \n}\n\n\nvec4 GetEdgeLine(vec2 a, vec2 b)\n{\n    return vec4((b + a)/2.,normalize(a-b).yx * vec2(-1.,1.));\n}\n\nvec4 DrawEdgeLine(vec2 a, vec2 b, vec2 uv, float size)\n{\n    vec4 edge = GetEdgeLine(a,b);\n\tvec2 o = edge.xy;\n\tvec2 d = edge.zw;\n\tvec4 ret = (DrawLineSegment(o+d*size, o-d*size,uv));\n    ret.xyz = vec3(.8,0.4,0.2);\n    return ret;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    sites[0]=vec2(0.6,0.2);\n    sites[1]=vec2(1.2,.8);\n    sites[2]=vec2(0.9,0.5);\n    sites[3] =vec2(0.45,0.733);\n    sites[4]=vec2(0.9,0.12);\n\n    float time = iTime;\n    vec2 uv = fragCoord/iResolution.y;\n\tfloat threshDist = time/10.;\n\n    float minDist = 1000.;\n    vec2 minP;\n\n    for ( int i = 0; i < POINT_COUNT; i++)\n    {\n\t\tvec2 p = sites[i];\n        float dist = length(uv - p );\n        if ( minDist > dist )\n        {\n            minP = p;\n            minDist = dist;  \n        }\n    }    \n\n    float rawDist = minDist;\n    if ( minDist > threshDist)\n    {\n        minDist = 1.;\n    }\n    else\n    {\n        minDist = smoothstep(-1.,1.,sin(minDist*150.)) * (1.-minDist*0.8);\n    }\n\n    vec4 siteCol = DrawSites(rawDist);\n    vec4 col = mix( vec4(minDist),siteCol, siteCol.a);\n\n    const int EXAMPLE_SITE = 2;\n    \n    float tOffset = 5.;\n    vec4 c = vec4(.0,.4,.8,1.)*DrawLineSegment(sites[EXAMPLE_SITE], mix(sites[EXAMPLE_SITE],sites[0],saturate(time-tOffset)), uv);\n    col = mix(col, c, c.a);   \n    tOffset+=1.;        \n    c = DrawPoint(uv, (sites[EXAMPLE_SITE]+sites[0])*0.5,vec3(0.,1.,0.),saturate(time-tOffset));\n    col = mix(col, c, c.a);\n    tOffset+=1.;\n    \n\tc = vec4(.0,.4,.8,1.)*DrawLineSegment(sites[EXAMPLE_SITE], mix(sites[EXAMPLE_SITE],sites[1],saturate(time-tOffset)), uv);\n    col = mix(col, c, c.a);\n    tOffset+=1.;\n    c = DrawPoint(uv, (sites[EXAMPLE_SITE]+sites[1])*0.5,vec3(0.,1.,0.),saturate(time-tOffset));\n    col = mix(col, c, c.a);\n    tOffset+=1.;\n    \n\tc =vec4(.0,.4,.8,1.)* DrawLineSegment(sites[EXAMPLE_SITE], mix(sites[EXAMPLE_SITE],sites[3],saturate(time-tOffset)), uv);\n    col = mix(col, c, c.a);\n    tOffset+=1.;\n        c = DrawPoint(uv, (sites[EXAMPLE_SITE]+sites[3])*0.5,vec3(0.,1.,0.),saturate(time-tOffset));\n    col = mix(col, c, c.a);\n    tOffset+=1.;\n    \n\tc =vec4(.0,.4,.8,1.)* DrawLineSegment(sites[EXAMPLE_SITE], mix(sites[EXAMPLE_SITE],sites[4],saturate(time-tOffset)), uv);\n    col = mix(col, c, c.a); \n    tOffset+=1.;\n    c = DrawPoint(uv, (sites[EXAMPLE_SITE]+sites[4])*0.5,vec3(0.,1.,0.),saturate(time-tOffset));\n    col = mix(col, c, c.a);\n    tOffset+=1.;\n\n\n \n   \tc = DrawEdgeLine( sites[EXAMPLE_SITE],sites[0],uv, saturate(time - tOffset));\n    col = mix( col, c,c.a);\n\ttOffset+=1.;\n    \n    c = DrawEdgeLine( sites[EXAMPLE_SITE],sites[1],uv, saturate(time - tOffset));\n    col = mix( col, c,c.a);\n\ttOffset+=1.;\n    \n    c = DrawEdgeLine( sites[EXAMPLE_SITE],sites[3],uv, saturate(time - tOffset));\n    col = mix( col, c,c.a);\n\ttOffset+=1.;\n    \n    c = DrawEdgeLine( sites[EXAMPLE_SITE],sites[4],uv, saturate(time - tOffset));\n    col = mix( col, c,c.a);\n\ttOffset+=1.;\n    \n    // mask for point example_site\n    vec4 edge;\n    float mask = 1.;\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[0]);\n   \tmask = (ceil(-dot(uv-edge.xy, edge.wz*vec2(-1.,1.))));\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[1]);\n    mask*= (ceil(-dot(uv-edge.xy, edge.wz*vec2(-1.,1.))));\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[3]);\n    mask*= (ceil(-dot(uv-edge.xy, edge.wz*vec2(-1.,1.))));\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[4]);\n    mask*= (ceil(-dot(uv-edge.xy, edge.wz*vec2(-1.,1.))));    \n    \n\n    \n    float maskProgress = saturate(time-tOffset);\n\n    float mask2Progress = saturate(time-tOffset);\n    tOffset +=1.;\n    \n    vec4 col2 = vec4(1.0);\n    float mask2 = saturate(mask + 0.3);\n    //min distance to edge0\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[0]);\n    float distToEdge0 = DistToLine( uv, edge.xy, edge.zw).x;\n    //min distance to edge0 and 1\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[1]);\n    float distToEdge1 =DistToLine( uv, edge.xy, edge.zw).x;\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[3]);\n    float distToEdge3=  DistToLine( uv, edge.xy, edge.zw).x;\n    edge = GetEdgeLine(sites[EXAMPLE_SITE],sites[4]);\n    float distToEdge4 =  DistToLine( uv, edge.xy, edge.zw).x;    \n    \n    if (distToEdge0 > saturate(time-tOffset))\n        distToEdge0 = 100.;    \n    tOffset++;\n    if (distToEdge1 > saturate(time-tOffset))\n        distToEdge1 = 100.;    \n    tOffset++;\n    if (distToEdge3 > saturate(time-tOffset))\n        distToEdge3 = 100.;    \n    tOffset++;\n    if (distToEdge4 > saturate(time-tOffset))\n        distToEdge4 = 100.;        \n    tOffset++;\n    \n    float distToEdge =saturate( min(min(distToEdge0, distToEdge1),min(distToEdge3, distToEdge4)));\n\n    //min distance to edge0 and 1 and 3\n    //min distance to edge0 and 1 and 3 and 4\n    \n    \n    col2 =vec4(distToEdge);\n    tOffset +=1.;\n    vec3 colDistToEdgeIsoLine = mix(EdgeColor1, EdgeColor2,(smoothstep(-1.,0.3,sin(distToEdge*200.)))*((distToEdge)*2.5+0.3));\n    col2.xyz = mix(col2.xyz, colDistToEdgeIsoLine, saturate(time-tOffset+5.));\n    \n   \tcol = mix(vec4(0.),col,mix(1.,mask2,mask2Progress));\n    col = mix( col, col2,maskProgress*mask);\n    fragColor = col;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXzm.jpg", "access": "shaders20k", "license": "mit", "functions": [[51, 517, 561, 561, 679], [681, 681, 739, 739, 852], [854, 854, 884, 884, 945], [947, 947, 994, 994, 1323], [1326, 1326, 1360, 1360, 1424], [1426, 1426, 1482, 1482, 1663], [1665, 1665, 1722, 1722, 6599]], "test": "untested"}
{"id": "tstSDn", "name": "shadetober #22 (ghost)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 15, "viewed": 325, "published": "Public API", "date": "1573112470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdUnevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(p, vec2(-b, a));\n  if (k < 0.0)\n    return length(p) - r1;\n  if (k > a * h)\n    return length(p - vec2(0.0, h)) - r2;\n  return dot(p, vec2(a, b)) - r1;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat wiggles(vec2 p, float h, float freq, float amp, float speed) {\n  return p.y - (h + sin((iTime * speed + p.x) * freq) * amp);\n}\n\nfloat arms(vec2 p, float h, float l, float freq, float amp) {  \n  return sdLine(p + vec2(0., h) + vec2(0., sin(p.x * freq) * amp), vec2(-l, 0.), vec2(l, 0.)) - .1;\n}\n\nfloat map(vec2 uv) {\n  uv.x += sin((uv.y + iTime) * 4.) * .05;\n  uv.y += sin(iTime) * .2+.15;\n    \n  float dist = 100.;\n\n  float body = sdUnevenCapsule(uv + vec2(0., .2), .5, .4, .5);\n  dist = max(-dist, body);\n\n  float wigg = wiggles(uv, -.3, 8., .1, .5);\n  dist = max(-wigg, dist);\n\n  float arms = arms(uv, -.1, .7, 8., .1 * sin(iTime));\n  dist = min(arms, dist);\n    \n  float eyel = length(uv - vec2(-.18,.4 + sin(iTime) * .02)) - .1;\n  dist = max(-eyel, dist);\n    \n  float eyer = length(uv - vec2(.2,.3 + sin(iTime * 1.2) * .03)) - .1;\n  dist = max(-eyer, dist);\n    \n  float mouthwiggle = .76 + sin(iTime*3.) * .01;\n    float mouthwid = .1 + sin(iTime*2.) * .01;\n  float mouth = sdArc(uv + vec2(.04,-0.35), vec2(sin(TAU*mouthwiggle), cos(TAU*mouthwiggle)), vec2(sin(TAU* mouthwid), cos(TAU* mouthwid)), .15, .02);\n    dist = max(-mouth, dist);\n\n  return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n  float ghost = map(uv);\n\n  //vec3 col = vec3(step(0.,ghost));\n  vec3 col = pow(abs(vec3(ghost)), vec3(.2));\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 98, 158, 158, 404], [406, 406, 453, 453, 572], [574, 574, 649, 649, 833], [835, 835, 903, 903, 967], [969, 969, 1030, 1030, 1134], [1136, 1136, 1156, 1156, 2003], [2005, 2005, 2060, 2108, 2340]], "test": "untested"}
{"id": "tstSDs", "name": "Tray Racer", "author": "ShnitzelKiller", "description": "May Rarching", "tags": ["raymarching", "pun"], "likes": 14, "viewed": 318, "published": "Public API", "date": "1573272474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.5\n#define MAXSTEP 100\n#define TOL 0.005\n#define MAXDIST 100.\n\n#define BEVEL 0.2\n#define EXTRUDE 0.05\n\n#define RAD 0.3\n#define WHEELDEPTH 0.2\n\n#define LENGTH 1.\n#define WIDTH 0.75\n\n#define AO_SAMPLES 5\n#define AO_STRENGTH 2.\n\n#define LAP_LENGTH 200.\n#define RACESPEED 20.\n\nvec3 lightdir = normalize(vec3(1.));\n\nfloat wheelsdf(in vec3 p) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(RAD, WHEELDEPTH);\n  \tfloat dist = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return min(max(length(p.xz)-0.1, p.y), max(dist, -(length(p+vec3(0., -0.55, 0.))-0.4)));\n}\n\n// minimum d.x keeping track of the closest material in d.y\nvec2 condmin(in vec2 d1, in vec2 d2) {\n    return vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 trayracer(in vec3 ro) {\n    //tray\n    vec3 dims = vec3(LENGTH, WIDTH, 0.0);\n    vec3 d = abs(ro)-dims;\n    float dist = length(max(d,0.0)) + \n\t       min(max(d.x, max(d.y, d.z)),0.0);\n    dist = abs(dist-BEVEL-0.5*EXTRUDE) - 0.5*EXTRUDE;\n    dist = max(ro.z, dist);\n    \n    //wheels\n    float offset = (RAD+BEVEL);\n    vec3 wheelro = vec3(abs(ro.xy), ro.z) - vec3(LENGTH, WIDTH, -offset);\n    float wheel_dist = wheelsdf(wheelro);\n    return condmin(vec2(dist, 1.), vec2(wheel_dist, 2.));\n}\n\nvec2 map(in vec3 ro, out vec2 uv) {\n    \n    vec4 o1 = vec4(1., 0.5, 0.75, 0.4) * sin(iTime * vec4(0.2, 0.45, 0.8, 0.15) + vec4(-1., 4.3, 2.15, 9.81));\n    float offset1 = o1.x + o1.y + o1.z + o1.w;\n    \n    vec4 o2 = vec4(0.45, 0.7, 0.1, 0.1) * sin(iTime * vec4(0.6, 0.7, 4.1, 4.) + vec4(-8., -2., 1.1, 0.7));\n    float offset2 = o2.x + o2.y + o2.z + o2.w;\n    \n    vec3 ro1 = ro + vec3(2.*offset1 + offset2, 1.4, 0.);\n    vec3 ro2 = ro + vec3(0., -1.4, 0.);\n    \n    vec2 d1 = trayracer(ro1);\n    vec2 d2 = trayracer(ro2);\n    uv = d1.x < d2.x ? ro1.xy : ro2.xy;\n    vec2 d = condmin(\n        d1,\n        d2\n    );\n    //ground\n    float ground_dist = ro.z+BEVEL+2.*RAD;\n    d = condmin(d, vec2(ground_dist, 3.));\n    \n    //walls\n    float wall_dist = max(ro.y + 5., ro.z - 3.);\n    return condmin(d, vec2(wall_dist, 4.));\n}\n\nvec3 getnormal(vec3 ro) {\n    vec2 uv;\n    vec2 d = vec2(TOL, 0.0);\n    float x1 = map(ro+d.xyy, uv).x;\n    float x2 = map(ro-d.xyy, uv).x;\n    float y1 = map(ro+d.yxy, uv).x;\n    float y2 = map(ro-d.yxy, uv).x;\n    float z1 = map(ro+d.yyx, uv).x;\n    float z2 = map(ro-d.yyx, uv).x;\n    return normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2));\n}\n\nvec3 raymarch(in vec3 eye, in vec3 rd, out vec2 uv) {\n    float t = 0.0;\n    int i;\n    for (i=0; i<MAXSTEP; i++) {\n        vec3 pos = eye + rd*t;\n        vec2 dist = map(pos, uv);\n        t += dist.x;\n        if (abs(dist.x) < TOL) {\n            return vec3(t, dist.y, i);\n        } else if (t > MAXDIST) break;\n    }\n    return vec3(t, 0., i);\n}\n\nbool shadowmarch(in vec3 eye, in vec3 rd) {\n    float t = 0.;\n    vec2 uv;\n    for (int i=0; i<20; i++) {\n        vec3 pos = eye + rd*t;\n        vec2 dist = map(pos, uv);\n        t += max(0.03, dist.x);\n        if (dist.x < 0.) return true;\n    }\n    return false;\n}\n\nfloat occlusion(vec3 ro, vec3 rd){\n    vec2 uv;\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++){\n        d = map(ro + 0.1 * k * rd, uv).x;\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(AO_STRENGTH * occ, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xx;\n\t\n    vec3 up = vec3(0, 0, 1);\n    vec3 eye = vec3(2. * sin(iTime*0.4), 5., 1.);\n\tvec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*FDIST + u*uv.x + v*uv.y);\n    vec2 texcoords;\n\tvec3 t = raymarch(eye, rd, texcoords);\n    \n    vec3 col;\n    vec3 ro = eye + rd*t.x;\n\tfloat racepos = ro.x + iTime * RACESPEED;\n    \n    if (t.y < 0.5) {\n        //sky\n        col = vec3(0.5, 0.8, 1.);\n    } else if (t.y < 1.5) {\n        //tray\n        vec3 tex = texture(iChannel1, texcoords).xyz;\n        col = max(tex, vec3(0.25));\n    } else if (t.y < 2.5) {\n        //wheels\n        col = vec3(0.3, 0.3, 0.3);\n    } else if (t.y < 3.5) {\n        //ground\n        \n        vec3 asphalt = vec3(0.4, 0.4, 0.4);\n        vec3 mediancol = vec3(0.9);\n        float medianfac = step(abs(ro.y), 0.2) * step(mod(racepos, 2.), 1.);\n        float prixfac = abs(step(mod(racepos, 1.), 0.5) - step(mod(ro.y, 1.), 0.5)) * step(abs(mod(racepos + 0.5*LAP_LENGTH, LAP_LENGTH)-0.5*LAP_LENGTH), 2.);\n        medianfac = max(medianfac, prixfac);\n        vec3 roadcol = mix(asphalt, mediancol, medianfac);\n        col = mix(vec3(0.5, 1., 0.0), roadcol, step(abs(ro.y), 4.));\n    } else {\n        //wall\n        vec3 tex = texture(iChannel0, vec2(racepos, ro.z) * 0.2).xyz;\n        col = tex;\n    }\n    vec3 n = getnormal(ro);\n    bool shadowed = shadowmarch(ro + n*TOL, lightdir);\n    float fac = max(0.3, shadowed ? 0. : max(0., dot(n, lightdir)));\n    \n    float aofac = occlusion(ro, n);\n    \n    //float aofac = m\n    \n    col = fac * col * vec3(2.05, 2.05, 2.) * aofac;\n    \n    \n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 353, 353, 574], [576, 636, 674, 674, 745], [747, 747, 775, 786, 1244], [1246, 1246, 1281, 1281, 2073], [2075, 2075, 2100, 2100, 2434], [2436, 2436, 2489, 2489, 2783], [2785, 2785, 2828, 2828, 3051], [3053, 3053, 3087, 3087, 3371], [3373, 3373, 3430, 3430, 5143]], "test": "untested"}
{"id": "tsVSRR", "name": "All possible cubics", "author": "iq", "description": "All possible cubic equations can be mapped to volume of a finite box. Blue: complex solutions. Yellow: real solutions Isolines indicate discriminant.", "tags": ["3d", "mapping", "cubic", "polynomial"], "likes": 3, "viewed": 606, "published": "Public API", "date": "1573268800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//-------------------------------------------------------\n\n// For a point p in the unit box, return a color\n// based on the solutions of the associated cubic\n// polynomial. The point p is interprested as the \n// 3 polar angles of a 4D point in a unit sphere,\n// and that 4D point maps to a unique cubic\n// polynomials a,b,c,d coefficients.\nvec3 getColor( in vec3 pb ) // p is in -1..1\n{\n    vec3 col = vec3(0.0);\n    float m = 0.0;\n\n    \n    //-------------------------------------------------------\n    \n    // convert from box space to cannoincal 0..1\n    pb = 0.5 + 0.498*pb/vec3(1.0,1.0,2.0); \n    \n    pb += vec3(0.5,0.5,0.5);\n    \n    // convert to 4D polar coordinates with radius=1\n    pb *= vec3(3.141593,3.141593,6.283185);\n    \n    // convert to cartesian 4D\n    vec4 ps = vec4( cos(pb.x),\n                    sin(pb.x)*cos(pb.y),\n                    sin(pb.x)*sin(pb.y)*cos(pb.z),\n                    sin(pb.x)*sin(pb.y)*sin(pb.z) );\n    \n    //-----------------------------\n    // make lead coefficient=1\n    ps /= ps.x;\n    \n#if 1\n    //-----------------------------\n    // compute depressed cubic t^3 + pt + q = 0\n    float p = (3.0*ps.z - ps.y*ps.y)/3.0;\n    float q = (2.0*ps.y*ps.y*ps.y - 9.0*ps.y*ps.z + 27.0*ps.w)/27.0;\n    \n    // discriminant\n    float h = -4.0*p*p*p - 27.0*q*q;\n#else    \n    // discriminant\n    float h = 18.0*ps.y*ps.z*ps.w - 4.0*ps.y*ps.y*ps.y*ps.w + ps.y*ps.y*ps.z*ps.z - 4.0*ps.z*ps.z*ps.z - 27.0*ps.w*ps.w;\n#endif    \n    \n    if( h<0.0 )\n    {\n        // 1 real, 2 complex roots. Make it blue, and shade it\n        // based on modulo of the roots\n        m = -h;//length(vec2(-p.y,sqrt(-h)))*0.5/abs(p.x);\n        col = vec3(0.0,0.5,1.0);\n    }\n    else\n    {\n        // 3 real roots. Make it yellow if possitive and\n        // purple is negative, and shader it based on size\n        // of the first root\n        m = h;//1.0;//(-p.y-sqrt(h))*0.5/p.x;\n        col = vec3(1.0,0.5,0.0);// : vec3(1.0,0.0,0.5);\n\t}\n    \n    // discriminant --> geometric mean of root differences\n    h = pow(abs(h),1.0/6.0);\n    col *= 0.7 + 0.3*smoothstep(-0.1,0.1,sin(abs(12.0*h))); // discriminant isolines\n    //col *= h;\n    return col;\n}\n\n//-------------------------------------------------------\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ro -= cen;\n    \n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n\n\treturn vec4( tN, nor );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat boxShadow( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    ro -= cen;\n\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (0.0 - ro.y)/rd.y;\n}\n\n//=====================================================\n\nvec3 plot3D( in vec2 px )\n{\n    vec2 p = (-iResolution.xy + 2.0*px)/iResolution.y;\n\n    // camera\n     // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 4.0*cos(an), 4.0, 4.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n    \n    // sphere\n    //vec3 box = vec3( 1.0 );\n    \n    float h = 0.5+0.49995*sin(1.0*iTime);\n    //h = 1.0;\n    vec3 box_cen = vec3(0.0,h,0.0);\n    vec3 box_rad = vec3(1.0,h,2.0);\n       \n\n    vec3 col = vec3(0.0);\n\n    // intersect geometry\n    float tmin = 1e10;\n    vec3 nor;\n    float occ = 1.0;\n    vec3 mate = vec3(1.0);\n\n    // plane/floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + t1*rd;\n        nor = vec3(0.0,1.0,0.0);\n        occ = 1.0;//-sphOcclusion( pos, nor, sph );\n        float d = sdBox( pos.xz, box_rad.xz );\n        occ = 0.2 + 0.8*clamp(1.0 - 1.0/(1.0+d*d),0.0,1.0);\n            \n        mate = vec3(0.2);\n    }\n\n    // box\n    vec4 t2 = boxIntersect( ro, rd, box_cen, box_rad );\n    if( t2.x>0.0 && t2.x<tmin )\n    {\n        tmin = t2.x;\n        vec3 pos = ro + t2.x*rd;\n        nor = t2.yzw;\n        occ = 0.2+0.8*clamp(pos.y/2.0,0.0,1.0);\n        mate = getColor(pos);\n\n        // wireframe\n        mate *= 1.0 - (1.0-abs(nor.x))*smoothstep( box_rad.x-0.04, box_rad.x-0.02, abs(pos.x-box_cen.x) );\n        mate *= 1.0 - (1.0-abs(nor.y))*smoothstep( box_rad.y-0.04, box_rad.y-0.02, abs(pos.y-box_cen.y) );\n        mate *= 1.0 - (1.0-abs(nor.z))*smoothstep( box_rad.z-0.04, box_rad.z-0.02, abs(pos.z-box_cen.z) );\n    }\n\n    // apply color and lighting\n    if( tmin<1000.0 )\n    {\n        vec3 pos = ro + tmin*rd;\n\n        vec3 lig = normalize( vec3(0.6,0.2,0.4) );\n\n        float sha = step( boxShadow( pos+0.01*nor, lig, box_cen, box_rad ), 0.0 );\n\n        vec3 lin = vec3(0.0);\n        lin += vec3(1.5)*clamp(dot(nor,lig),0.0,1.0)*sha;\n        lin += 0.5*occ;\n        //lin += 0.5*occ*pow(clamp(1.0+dot(nor,rd),0.0,1.0),3.0);\n\n        col = mate*lin;\n        //col = vec3(occ);\n        //col = mate;\n        // fog\n        col *= exp( -0.05*tmin );\n    }\n    return col;\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p = fragCoord + vec2(float(m),float(n))/float(AA)-0.5;\n        #else    \n        vec2 p = fragCoord;\n        #endif\n \n        vec3 col = plot3D(p);\n\n        // gamma correction\n        col = pow(col,vec3(0.4545));\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVSRR.jpg", "access": "shaders20k", "license": "mit", "functions": [[1136, 1417, 1463, 1463, 3245], [3306, 3374, 3446, 3446, 3844], [3847, 3915, 3985, 3985, 4256], [4258, 4258, 4296, 4296, 4378], [4380, 4380, 4420, 4420, 4452], [4454, 4511, 4538, 4538, 6832], [6935, 6935, 6992, 6992, 7559]], "test": "untested"}
{"id": "tsVSzW", "name": "KodeLife Default Shader Port", "author": "jeanlescure", "description": "Experimenting with a workflow using both ShaderToy and KodeLife for my shader creations.\n\nDecided to port the default shader from KodeLife into ShaderToy. Definitely enjoyed a great deal of learning.", "tags": ["interactive", "port", "microphone", "kodelife"], "likes": 3, "viewed": 235, "published": "Public", "date": "1573555579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * (fragCoord / iResolution.xy);\n    fragColor = vec4(\n        abs(sin(cos(iTime+3.*uv.y)*2.*uv.x+iTime)),\n        abs(cos(sin(iTime+2.*uv.x)*3.*uv.y+iTime)),\n        (texture(iChannel0,vec2(.45,.25)).x / 100.) * 100.0,\n        1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 315]], "test": "untested"}
{"id": "tsVSzz", "name": "modspace", "author": "ArthurSango", "description": "modulo", "tags": ["modulo"], "likes": 1, "viewed": 212, "published": "Public API", "date": "1573342501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\n\nmat2 rot( float a) {\n\n  return mat2( cos(a), - sin(a), sin(a), cos(a) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t1 = t/10.;\n    \n   // uv -= 0.5;\n    vec3 col = vec3(0.);\n\n    uv = abs( 2. * uv - 1.) ;\n   // uv += 0.5;\n    vec2 g = uv;\n    uv = abs( mod(uv.x,2.) * uv - 1.) ;\n\n    uv = fract(uv * 8. * mod(2.,uv.x + uv.y)* (1.+sin(t)));\n    \n    mat2 r = rot(t) * step( 0.5, uv.x );\n  //  uv *= r;\n    \n    uv *= rot( uv.x );\n    \n  \n    \n    col.r = uv.y ;\n    col.g = uv.x;\n    \n   col.b = length(uv);\n    \n  //  col.r = dot(uv,g);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 38, 38, 92], [96, 96, 153, 203, 723]], "test": "untested"}
{"id": "tsVXDz", "name": "Animated truchet", "author": "adroitwhiz", "description": "Truchet tiles that change over time.", "tags": ["truchet", "pattern", "tiles"], "likes": 8, "viewed": 173, "published": "Public", "date": "1573831042", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat lineFromDistance(float dist, float size) {\n    const float thickness = 2.0;\n\treturn clamp((abs(dist - 0.5) * size) - (thickness - 1.0), 0.0, 1.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float size = 25.0;\n    const float period = 2.0;\n    \n    //vec2 coord = fragCoord + vec2(0.0, iTime * -10.0);\n    vec2 coord = fragCoord;\n\n    vec2 pixCoord = floor(coord / size) * size;\n    \n    float time = iTime * (rand(pixCoord) + 0.5) * 0.5;\n    \n    float blend = abs((mod(time, period) / period) - 0.5) * 2.0;\n    \n    float rand1 = rand(pixCoord + floor(time / period)) > 0.5 ? 1.0 : 0.0;\n    float rand2 = rand(pixCoord + floor(((time + 99.9) + period * 0.5) / period)) > 0.5 ? 1.0 : 0.0;\n    \n    float randVal = mix(rand1, rand2, smoothstep(0.25, 0.75, blend));\n    \n    vec2 modcoord = mod(coord, size) / size;\n    \n    if (randVal > 0.5) {\n    \tmodcoord.x = 1.0 - modcoord.x;\n    }\n    \n    float boxMix = 1.0 - (abs(randVal - 0.5) * 2.0);\n    \n    float box1 = lineFromDistance(sdBox(modcoord, vec2(boxMix * 0.5)) + (boxMix * 0.5), size);\n    float box2 = lineFromDistance(sdBox(1.0 - modcoord, vec2(boxMix * 0.5)) + (boxMix * 0.5), size);\n    \n    vec3 outcolor = vec3(box1 * box2);\n\n    // Output to screen\n    fragColor = vec4(outcolor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 142, 142, 248], [250, 250, 287, 287, 371], [373, 373, 430, 430, 1503]], "test": "untested"}
{"id": "tsVXzh", "name": "Strange Crystal", "author": "ShnitzelKiller", "description": "Raytracing only. Playing around with refraction and internal reflection, plus non-euclidian geometry.", "tags": ["raytracing", "reflection", "refraction", "glossy"], "likes": 12, "viewed": 410, "published": "Public API", "date": "1573786289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(0.75, 0.75, 1.)\n\n#define ABSORPTION_RATE vec3(0.7, 0.5, 0.5)\n#define IOR 1.33\n#define SCATTER_FACTOR 0.02\n#define SAMPLES 25\n#define REFLECTIONS 4\n\n#define TIME_T 2.\n#define TIME_H 2.\n#define TIME_L 10.\n\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return -1.;\n    if (entering) {\n    \tnn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    } else {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return vec2(-1.);\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    float tout = -pd + tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return vec2(tin, tout);\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\n//raytrace the exterior surroundings\nvec3 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    if (t < 0.) return bgcol(rd);\n    vec2 uv = ro.xy+t*rd.xy;\n    if (max(abs(uv.x), abs(uv.y)) > 8.) return bgcol(rd);\n    vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n    float aofac = smoothstep(-0.5, 1., length(abs(uv)-min(abs(uv), vec2(0.75))));\n    return mix(vec3(0.2), vec3(1.), min(checkers.x,checkers.y)) * aofac;\n}\n\n//raytrace the insides\nvec3 insides(in vec3 ro, in vec3 rd, in float INNERRAD, in mat2 rot, out float tout) {\n    vec3 ni;\n    vec2 t = sphere(ro, rd, INNERRAD, ni);\n    vec3 ro2 = ro + t.x * rd;\n    // shading/texture\n    vec2 checkers = step(mod(rot * ro2.xy, vec2(0.25)), vec2(0.01));\n    vec3 tex = mix(vec3(1.), vec3(0., 0.7, 0.), abs(checkers.x-checkers.y));\n    float fac = -ni.z;\n    \n    //inner background\n    vec3 n;\n    float tb = box(ro, rd, vec3(INNERRAD), n, false);\n    vec3 rob = ro + tb * rd;\n    vec3 checkersb = abs(mod(rob.xyz, vec3(0.5))-0.25)*4.;\n    vec3 texb = mix(vec3(0., 0., 1.), vec3(0.), step(0.25, abs(abs(checkersb.x-checkersb.y)-checkersb.z)));\n    tout = mix(tb, t.x, step(0., t.x));\n    return mix(mix(vec3(0.5), texb, step(0., tb)) * 0.5, tex * fac, step(0., t.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t_osc = 0.5*(TIME_H+TIME_L)+TIME_T;\n    float h_l = 0.5*TIME_L/t_osc;\n    float h_h = (0.5*TIME_L+TIME_T)/t_osc;\n    float osc = smoothstep(0., 1., (clamp(abs(mod(iTime, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n    float INNERRAD = mix(0.5, 1.5, osc);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    if (t > 0.) {\n        float ang = -iTime * 0.33;\n    \tfloat c = cos(ang);\n    \tfloat s = sin(ang);\n    \tmat2 rot = mat2(c, -s, s, c);\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec2 theta = rand2d(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6));\n            theta *= vec2(2.*PI, SCATTER_FACTOR*PI);\n            vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n            // reflection\n            vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n            vec3 rdr = reflect(rd, nr);\n            vec3 reflcol = background(ro, rdr);\n            \n            // refraction & insides\n            \n            //vec3 rd2 = rd.yzx * ni.x + rd.zxy * ni.y + rd.xyz * ni.z;\n            \n            vec3 rd2 = refract(rd, nr, 1./IOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            vec3 no2 = ni;\n            vec3 ro_refr = ro;\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                float tb;\n                //no2 = -no2;\n                vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n                vec3 eye2 = vec3(coords2, -max(INNERRAD, 1.));\n                vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n                rd2trans.z = -rd2trans.z;\n                vec3 internalcol = insides(eye2, rd2trans, INNERRAD, rot, tb);\n                if (tb > 0.) {\n                    //terminate at interior geometry\n                    insidecol += accum * internalcol * transmission * pow(ABSORPTION_RATE, vec3(tb));\n\t\t\t\t\tbreak;\n                } else {\n                    //compute contribution of the light leaked from the environment through this bounce\n                    float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                    no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                    vec3 rout = ro_refr + tout * rd2;\n                    vec3 rdout = refract(rd2, -no2, IOR);\n                    float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rdout, no2), 5.);\n                    rd2 = reflect(rd2, -no2);\n                    \n                    ro_refr = rout;\n                    ro_refr.z = max(ro_refr.z, -0.999);\n\n                    transmission *= pow(ABSORPTION_RATE, vec3(tout));\n                    insidecol += accum * (1.-fresnel2) * background(ro_refr, rdout) * transmission;\n                    if (fresnel2 < 0.1) break;\n                    accum *= fresnel2;\n                }\n            }\n            \n            // background\n            \n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, nr), 5.);\n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(background(eye, rd), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 342, 342, 450], [452, 452, 526, 526, 1002], [1004, 1004, 1066, 1066, 1331], [1333, 1333, 1357, 1357, 1436], [1438, 1475, 1516, 1516, 1952], [1954, 1977, 2063, 2063, 2757], [2759, 2759, 2816, 2816, 6741]], "test": "untested"}
{"id": "tsVXzz", "name": "blue bottle", "author": "mgjunior", "description": "where is my bear", "tags": ["raymarching"], "likes": 7, "viewed": 177, "published": "Public", "date": "1573307773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float perStep=0.4;\nconst float PI = 3.14;\nconst float epsilon = 0.001;  \n\nstruct Ray\n{\n    vec3 from;\n    vec3 dir;\n};\n\nbool hitPlane(in Ray ray,in vec3 planeN,in vec3 planeC,inout vec3 hitPos)\n{\n    // ray hit plane \n    vec3 from =ray.from;\n    vec3 dir = ray.dir;\n    //(F-C)。N + t (D。N) = 0\n    // t  = (C-F)。N / (D。N)\n    // t  = (A / (B)\n    float B = dot(dir, planeN);\n    float A = dot(planeC- from, planeN);\n\n    // avoid divide by 0\n    if (abs(B) < epsilon)\n        return false;\n\n    float t = A / B;\n    hitPos = from + t * dir;\n    \n    if(t>0.0)\n    \treturn true;\n}\n\nRay[4] createRayDiff(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    vec2[4] multisampleDiff;\n    float x = 0.5;\n    float y =0.5;\n    // offset from p\n    multisampleDiff[0]=vec2(x,y)/iResolution.y;   \n    multisampleDiff[1]=vec2(-y,x)/iResolution.y; \n    multisampleDiff[2]=vec2(-x,-y)/iResolution.y;\n    multisampleDiff[3]=vec2(y,-x)/iResolution.y;\n\n    Ray[4] rays;\n    for(int i=0;i<4;++i){\n        rays[i].from =p+( multisampleDiff[i].x*xAxis + multisampleDiff[i].y*yAxis );\n        rays[i].dir =normalize(rays[i].from-eye);\n    }\n\n    return rays;\n}\n\n// from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdVerticalCapsule( vec3 p, float h, float r,float offset )\n{\n    p.y -= clamp( p.y, offset, h+offset );\n    return length( p ) - r;\n}\n\nfloat bottle(vec3 pos){\n\tfloat H =2.,R =1.,Offset=0.;\n\tfloat h=1.,r=0.25,offset =3.;\n    \n    //return sdVerticalCapsule(pos,h,r,offset);\n    return min(sdVerticalCapsule(pos,H,R,Offset),sdVerticalCapsule(pos,h,r,offset));\n}\n\n// gradient is normal\nvec3 getNormal(vec3 pos){\n    float delta =0.01;\n    vec3 temp=vec3(bottle(pos+vec3(delta,0.,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,delta,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,0.,delta))-bottle(pos)\n                  );\n\treturn normalize(temp);\n}\n\nvec3 shading(Ray ray,vec3 eye){\n    vec3 shadingColor = vec3(0.0,0.0,0.0);\n    \n    // obj 3 axis and offset\n    vec3 obj_offset=vec3(0.,1.,0.);\n    vec3 zAxis =vec3(0.,0.,1.);\n    float para_obj_rot=iTime;\n    vec3 yAxis = vec3(-sin(para_obj_rot),cos(para_obj_rot),0.);\n    vec3 xAxis =vec3(cos(para_obj_rot),sin(para_obj_rot),0.);\n    \n    // to local space\n    vec3 temp=(ray.from-obj_offset);\n    Ray localRay;\n    localRay.from =vec3(dot(xAxis,temp),dot(yAxis,temp),dot(zAxis,temp));\n    localRay.dir=vec3(dot(xAxis,ray.dir),dot(yAxis,ray.dir),dot(zAxis,ray.dir));\n    \n    vec3 lightDir=normalize(vec3(1.,1.,1.));\n    vec3 localLightDir =vec3(dot(xAxis,lightDir),dot(yAxis,lightDir),dot(zAxis,lightDir));\n    \n    temp= eye-obj_offset;\n    vec3 localEye =vec3(dot(xAxis,temp),dot(yAxis,temp),dot(zAxis,temp));\n    \n    vec3 back_color=vec3(0.2,0.2,0.2);\n    //vec3 water_color =vec3(0.4,0.1,0.6);\n    vec3 water_color =vec3(1.0,0.9,0.15);\n    \n    //front side of bottle\n    bool hit_bottle;\n    vec3 bottle_color;\n    vec3 bottle_hit_pos;\n    float dist_bottle_to_eye;\n    for(int i=0;i<20;i++){\n    \tfloat dist = bottle(localRay.from);\n        if(dist<0.01){\n            \n            //shading bottle color\n            vec3 n=getNormal(localRay.from);\n        \tbottle_color= vec3(0.0,1.0,0.75)*max(0.,dot(n,localLightDir))\n                +vec3(1.0,1.0,0.0)*max(0.,dot(n,-localLightDir));\n            \n            hit_bottle=true;\n            bottle_hit_pos= localRay.from;\n            dist_bottle_to_eye=length(localRay.from-localEye);\n            break;\n        }\n        \n        localRay.from+=dist*localRay.dir;\n    }\n    \n    \n    //back side of bottle\n    localRay.from+=100.*localRay.dir;\n    localRay.dir=-localRay.dir;\n    \n    float dist_back_bottle_to_eye;\n    for(int i=0;i<20;i++){\n        float dist = bottle(localRay.from);\n        if(dist<0.01){\n\n            dist_back_bottle_to_eye=length(localRay.from-localEye);\n            break;\n        }\n        \n        localRay.from+=dist*localRay.dir;\n    }\n    \n    //plane of water\n    float param_plane_rot=0.5*PI+0.1*PI*(sin(iTime*5.0));\n    vec3 planeN =vec3(0.,sin(param_plane_rot),cos(param_plane_rot));\n    vec3 help = vec3(0.0,1.0,0.0);\n    vec3 planeAxisX = vec3(1.0,0.0,0.0);\n    float lower_factor=1.5;\n     \n    //pull cos funciton  down，for reasonable water level\n    vec3 planeC =obj_offset+vec3(0.,(cos(iTime)-1.0)*lower_factor+1.0,0.);\n    \n\tvec3 planeColor;\n    vec3 hitPos;\n    bool hit_plane=hitPlane(ray,planeN,planeC,hitPos);\n    if(hit_plane )\n    {\n        float d=length(hitPos-eye);\n        //between back side of bottle and front side of bottle\n        if(d<dist_back_bottle_to_eye && d>dist_bottle_to_eye )\n        {\n            float thickness_inverse =min(max(1.0-(dist_back_bottle_to_eye-d)*0.3,0.),1.);\n            return mix(vec3(0.1)+water_color*thickness_inverse,bottle_color,0.25);  \n        }\n    }\n    \n    vec3 bottle_hit_pos_world = obj_offset\n        + bottle_hit_pos.x* xAxis+bottle_hit_pos.y* yAxis+bottle_hit_pos.z* zAxis;\n    \n    bool normalBackFace =dot(bottle_hit_pos_world-planeC,planeN)<0.0;\n    \n    if(hit_bottle)\n    {\n        \n        if(normalBackFace){\n    \t\tfloat thickness_inverse =min(max(1.0-(dist_back_bottle_to_eye-dist_bottle_to_eye)*0.3,0.),1.);\n        \treturn mix(back_color,mix(water_color*thickness_inverse,bottle_color,0.25),0.5);\n        }else\n            return mix(back_color,bottle_color,0.5);       \n    }\n    \t\n    shadingColor=back_color;\n    return shadingColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // weight (from -1 to 1)\n    vec2 weight = fragCoord/iResolution.xy;\n    weight= weight*2.0-1.0;\n\n    vec3 lookAt =vec3(0.0,1.0,0.0);\n    vec3 eye = vec3(0.0,1.0,5.0);\n    //vec3 eye = lookAt+ 5.0*vec3(cos(iTime),0.0,sin(iTime))+vec3(0.0,1.0,0.0);\n\n    // camera 3 axis\n    vec3 zAsix = normalize(eye-lookAt);\n    vec3 yAxis = vec3(0.0,1.0,0.0);\n    vec3 xAxis = cross(yAxis,zAsix);\n    \n    //near plane of view frustum (z = -1)\n    float fovDegree =90.0;\n    float halfFov = radians(0.5*fovDegree);\n    float tanH = tan(halfFov);\n    float tanW = tanH*iResolution.x/iResolution.y;\n\n    // generate point from the plane\n    vec3 pointOnPlane = eye -zAsix + xAxis*weight.x*tanW + yAxis*weight.y*tanH;\n\n    // disturb ray dir\n    float A =0.1*sin(0.5*iTime);\n    //pointOnPlane+=vec3(A*sin(10.*weight.y+5.*iTime),0.,0.);\n    \n    // Antialiasing\n    Ray[4] rays =createRayDiff(eye,xAxis,yAxis,pointOnPlane);\n    \n    vec3 color= vec3(0.0,0.0,0.0);\n    for(int i=0;i<1;++i)\n        color += shading(rays[i],eye);\n    // color *=0.25;\n\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 201, 223, 594], [1151, 1231, 1297, 1297, 1370], [1372, 1372, 1395, 1395, 1596], [1598, 1620, 1645, 1645, 1901], [1903, 1903, 1934, 1934, 5414], [5416, 5416, 5473, 5502, 6545]], "test": "untested"}
{"id": "tsySDw", "name": "AMAZE Ray Marching Workshop", "author": "enci", "description": "A simple shader for a ray marching workshop at AMAZE 2019 festival", "tags": ["3d", "temple", "procedrual"], "likes": 13, "viewed": 246, "published": "Public", "date": "1574160304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define TAU (2.0*PI)\n#define EPSILON 0.0001\n#define MAX_STEPS 264\n#define SPEED 0.5\n#define LIGHT_SPEED 10.0\n#define LIGHT_RADIUS 0.6\n#define MAX_FLT  65504.0\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n///// Shapes /////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCylinderY(vec3 p, vec3 c)\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCylinderZ(vec3 p, vec3 c)\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\nfloat sdCylinderX(vec3 p, vec3 c)\n{\n  return length(p.zy-c.xy)-c.z;\n}\n\n///// Combine shapes /////////////////////////////////////////////////////////////////////////////////////////\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat opUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nvoid opRepeat(inout float coor, float repeat)\n{\n  coor = mod(coor + repeat * 0.5, repeat) - repeat * 0.5;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n///// My scene /////////////////////////////////////////////////////////////////////////////////////////\n\nvec4 getLightPos()\n{  \n  float x = iTime * SPEED * 12.0 + 18.0;\n  return vec4(\n    x,\n    sin(x * (PI / 6.0)) * 2.0 + 3.0,\n    sin(x * (PI / 12.0) + PI * 0.5) * 13.0 + 6.0,\n    LIGHT_RADIUS * 0.5 + abs(sin(x * (PI / 3.0))) * LIGHT_RADIUS * 0.5);\n}\n\nfloat floorSdf(vec3 pos)\n{\n  opRepeat(pos.x, 1.0);\n  opRepeat(pos.z, 1.0);\n  return sdRoundBox(pos, vec3(0.45, 0.2, 0.45), 0.05);\n}\n\nfloat debugPillarSdf(vec3 pos)\n{\n  opRepeat(pos.x, 12.0);\n  float c0 = sdCylinderY(pos, vec3(6.0, 6.0, LIGHT_RADIUS * 0.1));\n  //float c1 = sdCylinderY(pos, vec3(0.0, 6.0 + LIGHT_RADIUS, LIGHT_RADIUS * 0.1));\n  return c0;\n}\n\nfloat ceilingSdf(vec3 pos)\n{ \n  pos -= vec3(6.0, 5.0, 6.0);\n  float b = sdPlane(pos, vec4(0.0, -1.0, 0.0, 0.0)); \n  const float repeat = 12.0;\n  opRepeat(pos.x, repeat);\n  opRepeat(pos.z, repeat);\n  float cz = sdCylinderZ(pos, vec3(0.0, 0.0, 5.0));\n  float cx = sdCylinderX(pos, vec3(0.0, 0.0, 5.0));\n  float c = min(cz, cx);   \n  return opSubtraction(c, b);\n}\n\nfloat pillarsSdf(vec3 pos)\n{\n  const float repeat = 12.0;\n  opRepeat(pos.x, repeat);\n  opRepeat(pos.z, repeat);\n\n  float d = MAX_FLT;\n  float pillar = sdBox(pos, vec3(1.0, 5.0, 1.0));\n  float base = sdBox(pos, vec3(1.5, 0.5, 1.5));  \n  float top = sdBox(pos - vec3(0.0, 4.5, 0.0), vec3(1.25, 0.2, 1.25));\n  d = opUnionStairs(pillar, base, 0.5, 3.0);\n  d = opUnionStairs(d, top, 0.3, 2.0);\n  return d;\n}\n\nfloat sdf(vec3 pos)\n{    \n  float d = MAX_FLT;\n  d = floorSdf(pos);\n  d = min(d, pillarsSdf(pos));\n  d = min(d, ceilingSdf(pos));\n  //d = min(d, debugPillarSdf(pos));\n  vec4 light = getLightPos();\n  d = min(d, sdSphere(pos - light.xyz, light.w));\n  return d;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nfloat castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0; // Stores current distance along ray\n     \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float res = sdf(rayOrigin + rayDir * t);\n        if (res < (EPSILON * t))\n        {\n            return t;\n        }\n        t += res;\n    }\n     \n    return -1.0;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = sdf(pos);\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( sdf(pos + eps_zero.xyy), sdf(pos + eps_zero.yxy), sdf(pos + eps_zero.yyx) ) - c);\n}\n\nfloat trPlane(vec3 rayOrigin, vec3 rayDir, vec4 normal)\n{  \n\tfloat d = dot(normal.xyz, rayDir);\n\n  // Normal and ray perpendicular \n\tif (d == 0.0)\n\t\treturn -1.0;\n\t\n\tfloat t = (normal.w - dot(normal.xyz, rayOrigin)) / d;\n\n\t// Behind ray\n  if (t <= 0.0)\n  \treturn -1.0;\n\t\n\treturn t;\n}\n\nvoid debugPlane(inout vec3 color, vec3 rayOrigin, vec3 rayDir, float dist)\n{\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  float t = trPlane(rayOrigin, rayDir, vec4(up, 0.0));  \n\n  if(t > 0.0 && (t < dist || dist == -1.0))\n  {\n    vec3 pos = rayOrigin + rayDir * t;\n    float d = sdf(pos);\n\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\t  col *= 1.0 - exp(-2.0 * abs(d));\n\t  col *= 0.8 + 0.2 * cos(20.0 * d);\n\t  col = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 0.15, abs(d)) );\n    color = col;\n  }\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{ \n\tfloat t = castRay(rayOrigin, rayDir);\n\n\t//vec3 L = normalize(vec3(sin(iTime)*1.0, cos(iTime*0.5)+0.5, -0.5));\n  vec3 color;\n  vec3 backColor = vec3(0.35, 0.35, 0.35);\n\n  if (t == -1.0)\n  {\n    color = backColor;\n  }\n  else\n  {\n      vec3 pos = rayOrigin + rayDir * t;\n      //vec3 objectSurfaceColour = vec3(0.9, 0.7, 0.7);\n      vec3 objectSurfaceColour = vec3(1.0, 1.0, 1.0);\n      vec3 ambient = vec3(0.02, 0.021, 0.02);\n      vec3 N = calcNormal(pos);\n\n      vec4 lightInfo = getLightPos();\n      vec3 light = lightInfo.xyz - pos;\n      float d = length(light);\n      vec3 L = normalize(light);\n\n      if(d < lightInfo.w * 1.01)\n      {\n        color = vec3(1.0, 1.0, 1.0);        \n      } \n      else\n      {\n        float intensity = 0.4 + (1.0 + sin( iTime * LIGHT_SPEED * 2.0 )) * 0.0;\n        intensity *= 0.5 / clamp((d * d), 0.0, 1.0);\n        // L is vector from surface point to light, N is surface normal. N and L must be normalized!\n        float NoL = max(dot(N, L), 0.0);\n        vec3 LDirectional = vec3(0.9, 0.9, 0.8) * NoL;\n        vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n\n        float shadowCast = castRay(lightInfo.xyz - L * (lightInfo.w + 0.5), -L);\n        if(shadowCast <= (d - (lightInfo.w + 0.51)))\n          intensity *= 0.3;\n\n        vec3 diffuse = objectSurfaceColour * (LDirectional + LAmbient) * intensity;\n\n        color = mix(diffuse, backColor, saturate(t / 200.0));\n      }\n  }\n\n  color = pow(color, vec3(0.4545));\n  debugPlane(color, rayOrigin, rayDir, 5.0);\n \t\n  return color;\n}\n\nvec3 calculateCameraPos()\n{  \n  return vec3(iTime * SPEED * 12.0, 3.0, 6.0);\n}\n\nvec2 barrelDistortion(vec2 uv, float k)\n{\n  float rd = length(uv);    \n  float ru = rd * (1.0 + k * rd * rd);\n  uv /= rd;\n  uv *= ru;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec3 cameraPos = calculateCameraPos();\n  vec3 lookAt =  cameraPos + vec3(10.0, 0.0, 0.0);\n\n  vec2 uv = normalizeScreenCoords(fragCoord);  \n  uv = barrelDistortion(uv, 0.25);\n\n  vec3 rayDir = getCameraRayDir(uv, cameraPos, lookAt);\n    \n  vec3 col = render(cameraPos, rayDir);\n    \n  fragColor = vec4(col,1.0); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsySDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 211, 211, 248], [250, 353, 398, 398, 498], [500, 500, 529, 529, 624], [626, 626, 657, 657, 691], [693, 693, 726, 726, 752], [754, 754, 789, 789, 823], [825, 825, 860, 860, 894], [896, 896, 931, 931, 965], [967, 1174, 1231, 1231, 1342], [1344, 1344, 1391, 1391, 1451], [1453, 1453, 1496, 1496, 1518], [1520, 1626, 1646, 1646, 1873], [1875, 1875, 1901, 1901, 2006], [2008, 2008, 2040, 2040, 2231], [2233, 2233, 2261, 2261, 2593], [2595, 2595, 2623, 2623, 2997], [2999, 2999, 3020, 3020, 3259], [3261, 3261, 3321, 3405, 3718], [3720, 3720, 3764, 3764, 4045], [4047, 4047, 4093, 4093, 4219], [4221, 4221, 4248, 4269, 4442], [4444, 4444, 4501, 4501, 4726], [4728, 4728, 4804, 4804, 5230], [5232, 5232, 5274, 5274, 6793], [6795, 6795, 6822, 6822, 6873], [6875, 6875, 6916, 6916, 7023], [7025, 7025, 7082, 7082, 7418]], "test": "untested"}
{"id": "tsySR3", "name": " sphere tracing test-mod2", "author": "jorge2017a1", "description": " sphere tracing test-mod2", "tags": ["spheretracingtestmod2"], "likes": 2, "viewed": 59, "published": "Public", "date": "1574566237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Created by neur0sys in 2019-11-22\n//modificado por jorge 23-11-2019\n\nconst int NONE = 0;\nconst int SPHERE = 1;\nconst int PLANE = 2;\nconst int TORUS = 3;\nconst int BOX = 4;\nconst int LIGHT = 5;\n\nconst vec3 sphere_pos = vec3(2.0, -2.0, -5.0);\nconst vec3 box_pos = vec3(-2.0, -2.0, -5.0);\nconst vec3 torus_pos = vec3(0.0, 2.0, -5.0);\nconst vec3 plane_pos = vec3(0.0, -2.0, 0.0);\n\nstruct Obj {\n    int type;\n    float d;\n};\n\n\n// sdf primitives https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  float t = iTime;\n  //p.xz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  //p.yz *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  //p.xy *= mat2(cos(t), -sin(t), sin(t), cos(t));\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float t0 = iTime;\n  p.xz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.yz *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  p.xy *= mat2(cos(t0), -sin(t0), sin(t0), cos(t0));\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvec3 traceAmbient()\n{\n    // ambient\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * vec3(1.0);\n    return ambient;\n}\n\nvec3 traceDiffuse(vec3 lightDir, vec3 n)\n{\n    // diffuse\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0);\n    \n    vec3 c = vec3(1.0);\n    \n    return diffuse * c;\n}\n\nvec3 traceSpecular(vec3 lightDir, vec3 hit, vec3 l0, vec3 n)\n{\n    // specular\n    vec3 viewDir = normalize(hit - l0);\n    vec3 reflectDir = reflect(lightDir, n); \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);\n    return vec3(spec);\n}\n\nvec3 getLightPos()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 2.0, -15.0);\n    lightPos.z += cos(t0) * 8.0;\n    lightPos.x += sin(t0) * 8.0;\n    return lightPos;\n}\n\n\nvec3 getLightPosv2()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 1.0, -2.0);\n    lightPos.x += sin(t0) * 4.0;\n    \n    return lightPos;\n}\n\n\nvec3 traceLight(vec3 n, vec3 hit, vec3 l0)\n{\n    vec3 lightDir = normalize(getLightPos() - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n   \n    return ambient + diffuse + spec;\n    \n    \n    \n}\n\n\n\n\n\n\nvec3 traceLightLuz(vec3 n, vec3 hit, vec3 l0, vec3 luz)\n{\n    vec3 lightDir = normalize(luz - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n    \n  \n   \n    return ambient + diffuse + spec;\n}\n\n\n\n\n#define EPSILON 1e-3\nconst vec3 e = vec3(0.01, 0, 0);\n\nvec3 nBox(vec3 p, vec3 b) {\n    float d = sdBox(p, b);\n\tvec3 n = d - vec3(\n    \tsdBox(p - e.xyy, b),\n        sdBox(p - e.yxy, b),\n        sdBox(p - e.yyx, b)\n    );\n    return normalize(n);\n}\n\nvec3 nSphere(vec3 p, float s) {\n    float d = sdSphere(p, s);\n\tvec3 n = d - vec3(\n    \tsdSphere(p - e.xyy, s),\n        sdSphere(p - e.yxy, s),\n        sdSphere(p - e.yyx, s)\n    );\n    return normalize(n);\n}\n\nvec3 nTorus(vec3 p, vec2 t) {\n    float d = sdTorus(p, t);\n\tvec3 n = d - vec3(\n    \tsdTorus(p - e.xyy, t),\n        sdTorus(p - e.yxy, t),\n        sdTorus(p - e.yyx, t)\n    );\n    return normalize(n);\n}\n\nvec3 mapLight(Obj obj, vec3 hit, vec3 l0)\n{\n    vec3 col;\n    vec3 n = vec3(0.0);\n    \n    if (obj.type == PLANE) {\n        n = vec3(0.0, 1.0, 0.0);\n        col=vec3(1,0,0);\n    } else if (obj.type == SPHERE) {\n    \tn = nSphere(hit - sphere_pos, 1.0);\n        col=vec3(1,1,0);\n        \n    } else if (obj.type == BOX) {\n    \tn = nBox(hit - box_pos, vec3(1.0));\n        col=vec3(1,0,1);\n            \n        \n    } else if (obj.type == TORUS) {\n    \tn = nTorus(hit - torus_pos, vec2(1.5, 0.5));\n        col=vec3(0,1,1);\n        \n    } else if (obj.type == LIGHT) {\n    \treturn vec3(1.0);\n    }\n\n    return (traceLight(n, hit, l0)*col+traceLightLuz(n, hit, l0,getLightPosv2())*col)/1.5;\n    //return traceLightLuz(n, hit, l0,vec3(0.0, 1.0, 1.0))*col;\n}\n\nObj map(vec3 p)\n{\n\n   \n    float d = 1e6;\n    float t = 0.0;\n    int type = NONE;\n    \n    t = sdSphere(sphere_pos - p, 1.0);\n    if (t < d) { type = SPHERE; d = t; }\n    \n    t = sdSphere(getLightPos() - p, 0.25);\n    if (t < d) { type = LIGHT; d = t; }\n    \n    //t = sdSphere(getLightPosv2() - p, 0.5);\n    //if (t < d) { type = LIGHT; d = t; }\n    \n    \n    t = sdBox(box_pos - p, vec3(1.0));\n    if (t < d) { type = BOX; d = t; }\n    \n    t = sdTorus(torus_pos - p, vec2(1.5, 0.5));\n    if (t < d) { type = TORUS; d = t; }\n    \n    t = sdPlane(plane_pos - p, normalize(vec4(0.0, -1.0, 0.0, 5.0)));\n\tif (t < d) { type = PLANE; d = t; }\n    \n    return Obj(type, d);\n}\n\nObj trace(vec3 o, vec3 r)\n{\n    Obj obj = Obj(NONE, 1e6);\n    \n    float t = 0.0;\n    for (int i = 0; i < 32; i++) {\n        vec3 p = o + r * t;\n        obj = map(p);\n        t += obj.d;\n        if (obj.d < 1e-3) {\n        \tbreak;\n        }\n    }\n    \n    obj.d = t;\n    \n    return obj;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // [-1, 1]\n    uv = uv * 2.0 - 1.0;\n    \n    // aspect corrected\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(uv, -1.0);\n    \n    Obj obj = trace(o, r);\n    \n    vec3 hit = o + obj.d * r;\n    \n    vec3 light = mapLight(obj, hit, o);\n    \n    float fog = 1.0 / (1.0 + obj.d * obj.d * 0.01);\n    \n\tvec3 c = vec3(1.0);\n\n    c = vec3(c * fog * light);\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsySR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 516, 551, 551, 575], [577, 577, 608, 608, 867], [869, 869, 902, 902, 1146], [1148, 1148, 1181, 1207, 1238], [1240, 1240, 1261, 1276, 1379], [1381, 1381, 1423, 1438, 1580], [1582, 1582, 1644, 1660, 1834], [1836, 1836, 1856, 1856, 2010], [2013, 2013, 2035, 2035, 2160], [2163, 2163, 2207, 2207, 2458], [2465, 2465, 2522, 2522, 2756], [2816, 2816, 2843, 2843, 3007], [3009, 3009, 3040, 3040, 3216], [3218, 3218, 3247, 3247, 3419], [3421, 3421, 3464, 3464, 4171], [4173, 4173, 4190, 4190, 4844], [4846, 4846, 4873, 4873, 5135], [5137, 5137, 5194, 5194, 5683]], "test": "untested"}
{"id": "tsySWR", "name": "Codevember05 - Light", "author": "z0rg", "description": "A new way of sdf squares, sdf a diamond then rotate it by 45 degrees.", "tags": ["light", "square", "geometry", "codevember"], "likes": 7, "viewed": 185, "published": "Public API", "date": "1573749913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 uv)\n{\n  return abs(uv.x)+abs(uv.y);\n}\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\n\nfloat _sub(float a, float b)\n{\n  return max(-a,b);\n}\n\nfloat _union(float a, float b)\n{\n  return min(a,b);\n}\n\nfloat sdf_sqr(vec2 uv, float sz)\n{\n  return lenny(uv*r2d(PI/4.))-sz;\n}\n\nfloat sdf_sqrborder(vec2 uv, float sz, float th)\n{\n  return _sub(sdf_sqr(uv,sz-th),sdf_sqr(uv,sz));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  vec3 acc;\n  const int cnt = 8;\n  float sp=0.1;\n  for (int i=0;i<cnt;++i)\n  {\n    float fi =float(i);\n    float fc = float(cnt);\n    vec2 pos = vec2(fi-fc*.5)*sp;\n    acc +=vec3(float(i)/8.+0.1,pos.x*4.-sin(iTime*2.)*.5,pos.y*5.)*0.5*sat(1.-(vec3(sin(iTime+fi)*0.5+0.9)*sdf_sqrborder(uv-pos,0.3,0.01)*10.));\n  }\n  return col + acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*(iResolution.xy/iResolution.xx);\n    vec2 ouv = uv;\n  uv *= 2.;\n  vec3 col;\n  uv.y+=uv.x;\n  uv.x*=1.5;\n  col = rdr(uv);\n    col += (1.-lenny(ouv))*vec3(.35,.27,.59).zyx;\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsySWR.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 427, 445, 445, 506], [508, 508, 530, 530, 562], [564, 564, 584, 584, 611], [613, 613, 631, 631, 677], [679, 679, 709, 709, 731], [733, 733, 765, 765, 786], [788, 788, 822, 822, 858], [860, 860, 910, 910, 961], [963, 963, 982, 982, 1329], [1331, 1331, 1388, 1388, 1650]], "test": "untested"}
{"id": "tsySzd", "name": "Twitch: You Are Inside A Heart", "author": "blackle", "description": "experimenting iq's swiss cheese noise, but in reverse (adding up domain repeated objects instead of subtracting from a volume)\n\ntwitch recording: https://www.twitch.tv/videos/513390770", "tags": ["noise", "twitch", "liveshader"], "likes": 12, "viewed": 495, "published": "Public API", "date": "1574736118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float k) {\n  int x = FK(k);int y = FK(cos(k));\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float k) {\n  float t1 = hash(k);\n  float t2 = hash(t1);\n  float t3 = hash(t2);\n  return vec3(t1, t2, t3);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat bumps(vec3 p, float scale) {\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p)-scale*0.5;\n}\n\nfloat comp(vec3 p, vec3 off, vec3 rot) {\n  float phi = acos(rot.x);\n  float theta = rot.y * acos(-1.);\n  float lambda = rot.z * acos(-1.);\n  vec3 ax = vec3(cos(phi), sin(theta)*sin(phi), cos(theta)*sin(phi));\n  \n  p = erot(p, ax, lambda);\n  p += off;\n\n  vec3 ind = floor(p);\n  p = fract(p)-0.5;\n  p *= mod(ind,2.)*2.-1.;\n  \n  return (p.x+p.y+p.z)/sqrt(3.);\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat bpm = 60.;\n\nfloat scene(vec3 p) {\n  float dist = 100000.;\n  \n  for (int i = 0; i < 10; i++) {\n    float rnd = cos(float(i));\n    vec3 off = hash3(rnd);\n    vec3 rot = hash3(cos(rnd));\n    float str = hash(cos(cos(rnd)));\n    float d = comp(p, vec3(off)*str*iTime*0.3, vec3(rot))+0.6;\n    dist = sminCubic(dist, d, 0.5);\n  }\n  \n  float off = sin(p.x*0.5);\n  float bt = pow(abs(fract(iTime/60.*bpm + off)-0.5)*2., 2.);\n  return mix(dist, bumps(p, 0.04), 0.5*bt);\n}\n\n#define AP(f,k) vec3(f(k[0]),f(k[1]),f(k[2]))\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - AP(scene,k));\n}\n\nvec3 gam(int x,int y, int z) {\n  return pow(vec3(float(x),float(y),float(z))/float(0xff),vec3(2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 cam = normalize(vec3(0.5, uv));\n  vec3 init = vec3(0, iTime/7., 0);\n  vec3 p = init;\n  bool hit = false;\n  float sgn = 1.;\n  for (int i = 0; i < 50; i++) {\n    float dist = scene(p);\n    if (i == 0) sgn = sign(dist);\n    dist *= sgn;\n    if (abs(dist)<0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) break;\n    p += cam*dist;\n  }\n  \n  vec3 n = norm(p);\n  vec3 rf = reflect(cam,n);\n  float col1 = dot(rf, normalize(vec3(-1,-0.6,0)))*0.5+0.5;\n  float col2 = dot(rf, normalize(vec3(-1,0.5,0)))*0.5+0.5;\n  float fog = pow(exp(-distance(p, init)*0.5)/exp(0.), 2.);\n  //Corn Harvest #876310 / Blue Romance #C6F5E0\n  fragColor.xyz = sqrt(mix(gam(0x07,0x03,0x10), gam(0x87,0x63,0x10)*col2 + gam(0xC6,0xF5,0xE0)*col1, fog));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsySzd.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 249, 270, 270, 350], [352, 352, 373, 373, 470], [472, 472, 510, 510, 574], [576, 576, 610, 610, 676], [678, 678, 718, 718, 1036], [1038, 1038, 1084, 1084, 1170], [1190, 1190, 1211, 1211, 1640], [1688, 1688, 1707, 1707, 1791], [1793, 1793, 1823, 1823, 1893], [1895, 1895, 1952, 1952, 2833]], "test": "untested"}
{"id": "tsyXRW", "name": "Twitch: Trans Clouds", "author": "blackle", "description": "made during a twitch livestream: https://www.twitch.tv/videos/504928985", "tags": ["clouds", "twitch", "liveshader"], "likes": 9, "viewed": 364, "published": "Public API", "date": "1573515126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat hash2(float a, float b) {\n  return hash(vec2(a, b));\n}\n\nfloat hash3(float a, float b, float c) {\n  return hash(vec2(hash(vec2(a,b)),c));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(p,ax);\n}\n\nfloat rep(vec3 p, vec3 sc, vec3 off, float ro) {\n  p = erot(p, vec3(0,1,0), ro);\n  p = erot(p, vec3(0,0,1), 3.1415*hash2(ro, ro));\n  p = erot(p, vec3(1,0,0), 3.1415*hash3(ro, ro, ro));\n  p -= off*sc;\n  p = (fract(p/sc)-0.5)*sc;\n  return length(p);\n}\n\nfloat scene(vec3 p) {\n  float dist = 0.;\n  float cum = 0.;\n  for (int i = 0; i < 10; i ++) {\n    float ro = hash2(float(i+1), 2.3238) * 3.14159;\n    vec3 off = vec3(hash2(float(i+1), 384.12), hash2(float(i+1), 6969.0), hash2(float(i+1), 420.348));\n    float sc = 1./float(i+1);\n    dist += rep(p, vec3(sc), off, ro);\n    cum += 1.;\n  }\n  return (dist - 1.2)/sqrt(cum);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*200.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    if (d > 0.0) {\n        //red tint\n        color *= vec3(1.0,0.56,0.4);\n    } else {\n        //blue tint\n        color *= vec3(0.4,0.9,1.0);\n        \n    }\n    return color;\n}\n\nvec3 planeinterp(vec3 a, vec3 b, vec3 c, vec3 d, vec2 k) {\n  a = a*a;\n  b = b*b;\n  c = c*c;\n  d = d*d;\n  return mix(mix(a,b,k.x),mix(c,d,k.x),k.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv *=3.;\n  \n  vec3 cam = normalize(vec3(1, uv));\n  float ro = iTime/12.;\n  float str = 2.;\n  vec3 init = vec3(-4.+iTime/5., cos(ro)*str, sin(ro)*str);\n  vec3 p = init;\n  float k = 1.;\n  float iter = 20. + cos(iTime/2.)*10.;\n  for( int i = 0; i < int(iter); i++) {\n    float dst = scene(p);\n    if (i == 0) k = sign(dst);\n    dst*=k;\n    if (abs(dst) < 0.001) { break; }\n    \n    if (distance(p, init) > 100.) break;\n    p += cam*dst;\n  }\n  \n  float hs1 =  hash(uv*iTime)*0.05;\n  float hs2 =  hash(uv*iTime*43.43)*0.05;\n  float c = length(sin(p)*0.5+0.5)/sqrt(3.) + hs1;\n  float d = 1.-exp(-distance(init,p))/exp(0.) + hs2;\n  fragColor.xyz = sqrt(planeinterp(\n    vec3(78./255., 58./255., 88./255.), vec3(54./255., 193./255., 251./255.),\n    vec3(192./255., 69./255., 124./255.), vec3(241./255., 255./255., 194./255.),\n    vec2(c, d)\n  ));\n  //fragColor.xyz = shadeDistance(scene(vec3(uv, iTime*0.1)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 75, 75, 155], [157, 157, 188, 188, 217], [219, 219, 259, 259, 301], [303, 303, 341, 341, 405], [407, 407, 455, 455, 656], [658, 658, 679, 679, 1028], [1030, 1030, 1059, 1059, 1485], [1487, 1487, 1545, 1545, 1636], [1638, 1638, 1695, 1695, 2739]], "test": "untested"}
{"id": "tsyXW1", "name": "Grippy Rubber Texture", "author": "blackle", "description": "an interesting texture", "tags": ["rubber"], "likes": 11, "viewed": 165, "published": "Public", "date": "1573885542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat torus(vec3 p, vec2 di) {\n    vec2 crd = vec2(p.x, length(p.yz));\n    return length(crd-vec2(0,di.x))-di.y;\n}\n\nfloat scene(vec3 p) {\n    vec3 p1 = vec3(p.x, fract(p.yz+0.0)-0.5);\n    vec3 p2 = vec3(p.x, fract(p.yz+0.5)-0.5);\n    float ball = torus(p1, vec2(0.25,0.05));\n    float dough = torus(p2, vec2(0.3,0.1));\n    return sminCubic(sminCubic(dough,ball,0.15),-p.x,0.1);\n}\n\n#define AP(f,k) vec3(f(k[0]),f(k[1]),f(k[2]))\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - AP(scene,k));\n}\n\nfloat light(vec3 p, vec3 n, vec3 l) {\n    float comp = dot(n,normalize(l-p));\n    float power = mix(4.,9.,texture(iChannel0, mat2(cos(0.1),-sin(0.1),sin(0.1),cos(0.1))*p.yz*atan(-1.)).x);\n    \n    return pow(abs(comp),power)*sign(comp)*0.9+0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(0.9,uv));\n    vec3 init = vec3(-4.+sin(iTime/4.),0,iTime/3.);\n    vec3 p = init;\n    bool hit = false;\n    \n    for (int i = 0; i < 100; i++) {\n        float dist = scene(p);\n        if (abs(dist) < 0.001) { hit = true; break; }\n        if (distance(init, p) > 100.) break;\n        p += cam*dist;\n    }\n    vec3 l1 = init+vec3(2.2,cos(iTime*3.),sin(iTime*2.));\n    vec3 l2 = init+vec3(2.1,cos(iTime*3.),sin(iTime*2.));\n    vec3 l3 = init+vec3(2.0,cos(iTime*3.),sin(iTime*2.));\n    vec3 n = norm(p);\n    fragColor.xyz = hit ? vec3(light(p, n, l1), light(p, n, l2), light(p, n, l3)) : vec3(0.25);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyXW1.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 230, 276, 276, 362], [364, 364, 394, 394, 478], [480, 480, 501, 501, 743], [791, 791, 810, 810, 896], [898, 898, 935, 935, 1144], [1146, 1146, 1203, 1253, 1941]], "test": "untested"}
{"id": "tsyXzy", "name": "Cavespider", "author": "sirjofri", "description": "Use mouse to control zoom and vignette strength.", "tags": ["math", "sine", "pattern"], "likes": 3, "viewed": 271, "published": "Public API", "date": "1574282382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = uv - vec2(.5, .5);\n    nuv *= 10.+(iMouse.x/iResolution.x)*10.+sin(iTime);\n\n    float val = smoothstep(0.5, 1.5, abs(sin(nuv.x+sin(nuv.x*nuv.y-iTime))));\n    \n    vec3 col = val * vec3((.5+sin(iTime)*.5)*abs(nuv.x), (.5+cos(iTime)*.5)*abs(nuv.x), .5-sin(iTime)*.5);\n    \n    float vig = smoothstep(0., 0.1, uv.x*(1.-uv.x)*uv.y*(1.-uv.y));\n    float vigstr = mix(1., vig, iMouse.y/iResolution.y);\n\n    fragColor = vec4(vigstr*col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 549]], "test": "untested"}
{"id": "ttSGzh", "name": "cheap sky simulation", "author": "Jodie", "description": "sky", "tags": ["sky"], "likes": 16, "viewed": 278, "published": "Public", "date": "1573942691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define atmosphereHeight 8228.\n#define earthRadius 6371000.\n#define mieHeight 1200\n#define sunColor vec3( 1., .899, .828 )\n#define ozoneHeight 30000.\n// http://skyrenderer.blogspot.com/2012/10/ozone-absorption.html\n#define ozoneCoefficient (vec3(3.426, 8.298, .356) * 6e-5 / 100.)\n#define mieCoefficient 2e-6 // adjust for foggier look\n\n// ( Riley, Ebert, Kraus )\n//#define rayleighCoefficient vec3(5.8e-6  , 1.35e-5 , 3.31e-5 )\n// ( Bucholtz )\n//#define rayleighCoefficient vec3(4.847e-6, 1.149e-5, 2.87e-5 ) \n// ( Thalman, Zarzana, Tolbert, Volkamer )\n//#define rayleighCoefficient vec3(5.358e-6, 1.253e-5, 3.062e-5)\n// ( Penndorf )\n#define rayleighCoefficient vec3(5.178e-6, 1.226e-5, 3.06e-5 )\n\n#define up vec3(0,1,0)\n\nvec3 getSkyThicknesses(const vec3 rd){\n    const vec4 sr = earthRadius + vec4(\n        atmosphereHeight,\n        mieHeight,\n        ozoneHeight,\n        ozoneHeight + atmosphereHeight\n    );\n    const float r2 = earthRadius * earthRadius;\n    \n    //float b = dot(rd, -up) * earthRadius;\n    float b = -rd.y * earthRadius;\n    vec4 z = sqrt( sr * sr + (b * b - r2) );\n\n    return vec3(b+z.xy, z.w-z.z);\n}\n\n// Improved Rayleigh phase for single scattering\n// https://old.cescg.org/CESCG-2009/papers/PragueCUNI-Elek-Oskar09.pdf\n// note: integral from -1 to 1 of function in the paper is 2.24\n#define phaseRayleigh(a) (( .4 * (a) + 1.12 )/2.24)\n\n// (Henyey Greenstein)\n// https://www.astro.umd.edu/~jph/HG_note.pdf\nfloat phaseg(float x,float g){\n    const float  b = 1./2.;\n    float a = inversesqrt(1.+g*g-2.*g*x);\n\treturn b*(1.-g*g)*a*a*a;\n}\nfloat phaseMie(const float VdotL, const float depth){\n    float g = exp2( depth * -15e-5 );\n    return phaseg(VdotL, g);\n}\n\nvec3 getSky(const vec3 V, const vec3 L) {\n    \n    const float ln2 = log(2.);\n\n    const mat3 coeffs = mat3(\n        rayleighCoefficient      / ln2,\n        vec3(mieCoefficient*1.11)/ ln2, // mie absorbs (Bruneton)\n        ozoneCoefficient         / ln2\n    );\n    \n    vec3 thicknesses = getSkyThicknesses(V);\n    float VdotL = dot(V, L);\n\n    vec3 rayleighScatter =(thicknesses.x * phaseRayleigh(VdotL))          * rayleighCoefficient;\n    float     mieScatter = thicknesses.y * phaseMie(VdotL, thicknesses.y) *      mieCoefficient;\n\n\tvec3 scattering = rayleighScatter + mieScatter;\n    \n    vec3 sunCoeff = coeffs * getSkyThicknesses(L);\n    vec3 viewCoeff = coeffs * thicknesses;\n    vec3 absorption = (exp2(-viewCoeff)-exp2(-sunCoeff)) / ( (sunCoeff - viewCoeff) * ln2 );\n    \n    //  integral of x from 0 to 1\n    //  exp2( -a*x - b*(1-x) )\n    //\n    //     2⁻ᵃ - 2⁻ᵇ\n    //     ---------\n    //  (a - b) * ln(2)\n\n    return sunColor * scattering * absorption;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 L = vec3(0,cos(iTime/2.),sin(iTime/2.));\n    vec3 V = normalize(vec3(fragCoord * 2.0 - iResolution.xy, iResolution.x));\n    \n    vec3 m = normalize(vec3(iMouse.xy*2.0-iResolution.xy,iResolution.x));\n    //vec3 t = normalize(cross(up,m));\n    vec3 t = vec3(m.z,0,-m.x)*inversesqrt(1.-m.y*m.y);\n    \n    V *= mat3(t,cross(m,t),m);\n    \n    fragColor.rgb = pow(getSky(V,L),vec3(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 723, 761, 761, 1127], [1366, 1435, 1465, 1465, 1563], [1564, 1564, 1617, 1617, 1686], [1688, 1688, 1729, 1729, 2665], [2667, 2667, 2723, 2723, 3119]], "test": "untested"}
{"id": "Wd3SDB", "name": "RayMarch/Sphere Tracing Demo", "author": "sirArthurDayne", "description": "This is my first try with 3d and RayMarch for creating the primitives. The code includes render, skybox, lighting, soft shadows, diffuse light and reflections, hope you like it!!. Please leave a comment or recomendations so i can improve my code.", "tags": ["3d", "reflection", "raymarch", "materials", "3dproyection"], "likes": 9, "viewed": 386, "published": "Public API", "date": "1572729960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//I Make this Raymarch proyect for learning 3d computer graphics. This code can be use and modify by anyone.\n//The code was wrote on GLSL and Kodelife IDE, then i make the port to ShaderToy.\n//Please leave a comment o suggestion so i can improve and make better 3d graphics.\n\n//Material var\n float reflectionFactor = 0.0;\n\n\nfloat MaxComp(in vec3 pos)\n{\n    return max(pos.x, max(pos.y, pos.z));\n}\n\n\nvoid Rotate(inout vec2 pos, float angle)\n{\n    pos = vec2(pos.x * cos(angle) + pos.y * sin(angle), - pos.x * sin(angle) + pos.y * cos(angle));\n}\n\nfloat DSphere(in vec3 pos, in float radius)\n{\n    return length(pos) - radius;\n}\n\n\nfloat DBox(in vec3 pos, in vec3 b)\n{\n    vec3 di = abs(pos) - b;\n    float mc = MaxComp(di);\n    return min(mc, length(max(di, 0.0)));\n}\n\n\n//soft min that allows object to fuse into the other \nfloat Smin(float a, float b, float k)\n{\n//when the object are far, the return value is 'a' or 'b' \n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res)/k;\n}\n\n//Holds all the geometries that will be render to screen\nfloat DistanceEstimator(in vec3 pos)\n{\n    float sphere1 = DSphere(pos, 0.62);\n    float box = DBox(pos, vec3(0.5));\n    //float holeBox = max(box, -sphere1);\n    for(int i = 0; i < 12; i++)\n    {\n        vec3 offset = vec3(2.0 * sin(iTime *0.25), 0.0, 2.0 * cos(iTime));\n        Rotate(offset.xz, float(i));\n        float sphere2 = DSphere(pos - sin(iTime*0.3) * offset , 0.15);\n        sphere1 = Smin(sphere1, sphere2, 10.0);\n    }\n    float boxBase = DBox(pos - vec3(0.0, -0.50, 0.5 * cos(iTime)), vec3(0.9, 0.1, 1.0)); \n    float scene_obj =  min(boxBase, sphere1);\n    if (scene_obj == boxBase) reflectionFactor = 0.7;\n    else reflectionFactor = 0.3;\n    \n    return scene_obj;\n}\n\nvec3 normal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);//epsilon: small number to work with\n    vec3 nor;\n    //finds the ratio of change(slope) in x,y,z... similar to derivative \n    nor.x = DistanceEstimator(pos + eps.xyy) - DistanceEstimator(pos - eps.xyy);\n    nor.y = DistanceEstimator(pos + eps.yxy) - DistanceEstimator(pos - eps.yxy);\n    nor.z = DistanceEstimator(pos + eps.yyx) - DistanceEstimator(pos - eps.yyx);\n    return normalize(nor);\n}\n\n#define LIGHT_POS_1 20.0*vec3(-0.3, 0.15, 1.0)\n#define LIGHT_POS_2 20.0*vec3(-0.33, -0.2, -1.0)\n#define LIGHT_COL_1 vec3(1.0, 7.0/8.0, 3.0/4.0)\n#define LIGHT_COL_2 vec3(1.0, 3.0/4.0, 7.0/8.0)\n\nfloat saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\n\n\n//allows to make a visible sun\nvec3 getSkyColor(in vec3 rd)\n{\n    vec3 lightDir1 = normalize(LIGHT_POS_1);\n    vec3 lightDir2 = normalize(LIGHT_POS_2);\n    float ld1 = max(dot(lightDir1, rd), 0.0);\n    float ld2 = max(dot(lightDir2, rd), 0.0);\n    vec3 final = vec3(0.125);\n    \n    //skybox color\n    //if ((rd.y > abs(rd.x)) && (rd.y > abs(rd.z * 0.25))) final = vec3(2.0) * rd.y;\n    //float roundBox = length(max(abs(rd.xz/max(0.0, rd.y)) - vec2(0.9, 4.0), 0.0)) - 0.1;\n    //final += vec3(0.8) * pow(saturate(1.0 - roundBox * 0.5), 6.0);\n    \n    const float SUN_INSTENSITY = 200.0;\n    const float SUN_REFLECTION_OBJECT = SUN_INSTENSITY /2.0;\n    \n    //sun1\n    final += pow(LIGHT_COL_1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 10.0);\n    final += LIGHT_COL_1 * pow(ld1, SUN_REFLECTION_OBJECT);\n    //sun2\n    final += pow(LIGHT_COL_2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 10.0);\n    final += LIGHT_COL_2 * pow(ld2, SUN_INSTENSITY);\n    \n    return final;\n}\n\n\n\n#define MAX_TOLERANCE 0.001\n#define MAX_RAY_LENGTH 32.0\n#define MAX_RAY_MARCHES 144.0\n#define VIOLET vec3(0.50, 0.0, 0.8);\n#define DARK_BLUE vec3(0.20, 0.0, 1.0);\n#define WHITE vec3(1.0)    \n\n\n//ro: ray origin\n//rd: ray direction(normalize vector)\n\n//RAYMARCHING: a form to implement raytracing\nfloat RayMarch(in vec3 ro, in vec3 rd)\n{\n    float distanceOrigin = 0.1;\n    for(int i = 0; i < int(MAX_RAY_MARCHES); i++)\n    {\n        vec3 pos = ro + distanceOrigin * rd;\n        float distance = DistanceEstimator(pos);\n        if (distance < MAX_TOLERANCE || distanceOrigin > MAX_RAY_LENGTH) break;//miss the ray\n        distanceOrigin += distance;//add shortest distance\n    }\n    return distanceOrigin;\n}\n\n//post proccessing\n//ld: ligth direction\nfloat DiffuseLighting(in vec3 nor, in vec3 ld)\n{\n    //the result tends to 1 if the normal and ligth are are pointing the same way\n    return max(dot(nor,ld), 0.0);\n}\n\n//allows to show the origin of the ligth source on screen\nfloat Specular(in vec3 nor, in vec3 ld, in vec3 rd)\n{\n    return pow(max(dot(reflect(ld, nor), rd),0.0), 75.0);\n}\n\n//basic shadows\nfloat SoftShadow(in vec3 pos, in vec3 ld, float mint, float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++)\n    {\n        //applies shadow base on the geometry render\n        float distance = DistanceEstimator(pos + ld*t); \n        res = min(res, k*distance/t);\n        t += max(distance, mint*0.2);\n    }\n    return clamp(res, 0.25, 1.0);\n}\n\n\n//render: call the raymarch function, base on result compute a color\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 skyColor = mix(vec3(0.8, 0.8, 1.0) * 0.3, vec3(0.8, 0.8, 1.0)*0.6, rd.y * 0.75 + 0.25);\n    vec3 sphereColor =  vec3(0.75, 0.70, 1.00);\n    vec3 aggregateColor = vec3(0.0);\n    vec3 lightPosition =  vec3(1.5, 3.0, -1.0) * -2.0;\n\n   \n    float agregateReflectionFactor = 1.0;\n    \n    //applies refractions by recalculate point(RAYTRACING MAGIC)\n    for(int i =0; i < 3; i++)\n    {\n        float t = RayMarch(ro, rd);//distance to object    \n        //ray intersect object\n        if (t < MAX_RAY_LENGTH) \n        {\n            //diffuse ligth contact the surface of object\n            vec3 position = ro + t * rd; \n            vec3 lightDir = normalize(position - lightPosition);\n            float d = DiffuseLighting(normal(position), lightDir);//ambient light\n            //specular lighting\n            //float spec = Specular(normal(position), lightDir, rd);\n            //add shadows \n            float shadow = SoftShadow(position, lightDir, 0.01, 16.0);\n            //get sky reflection(easy way) \n            vec3 reflectionDir =  reflect(rd, normal(position));\n            \n            aggregateColor += agregateReflectionFactor * reflectionFactor * sphereColor * d * shadow;\n            agregateReflectionFactor *= 1.0 - reflectionFactor;\n            ro = position;\n            rd = reflectionDir;\n        }\n        else\n        {\n            aggregateColor += agregateReflectionFactor * getSkyColor(rd);//ray missed\n            break;\n        }\n        \n    }\n    \n    return aggregateColor;\n}\n\nvec3 tonemapping(in vec3 col)\n{   \n    return col / (1.0 + col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 outputColor = vec3(0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\t\n   //camera setup\n    vec3 ro = vec3(5.0, 2.0, 2.0);   \n    \n    //rotation especcify the axis view\n    Rotate(ro.xz, iTime*0.25);\n    \n    vec3 ww = normalize(vec3(0.0, -1.0, 0.0)-ro);//z\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));//x\n    vec3 vv = normalize(cross(ww,uu));//y\n    \n    //ray direction\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.5 * ww);   \n    //get distance to object\n    outputColor = Render(ro + vec3(0.25, 0.25, 0.0), rd);\n    // Output to screen\n    fragColor = vec4(outputColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3SDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[276, 324, 352, 352, 396], [399, 399, 441, 441, 543], [545, 545, 590, 590, 625], [628, 628, 664, 664, 764], [767, 821, 860, 919, 988], [990, 1047, 1085, 1085, 1732], [1734, 1734, 1760, 1760, 2194], [2389, 2389, 2417, 2417, 2450], [2454, 2485, 2515, 2515, 3405], [3658, 3704, 3744, 3744, 4114], [4116, 4157, 4205, 4287, 4323], [4325, 4383, 4436, 4436, 4496], [4498, 4514, 4578, 4578, 4885], [4888, 4957, 4994, 4994, 6508], [6510, 6510, 6541, 6541, 6576], [6579, 6579, 6636, 6636, 7302]], "test": "untested"}
{"id": "Wd3SDM", "name": "shadetober #24 (dizzy)", "author": "percentcer", "description": "Inktober, but with shaders\n\nWanted to try out Truchet tiling!", "tags": ["truchet", "inktober", "shadertober", "shadetober", "inktober2019"], "likes": 4, "viewed": 266, "published": "Public API", "date": "1573461527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\nmat2 rot(float a) { \n    return mat2(\n    cos(a), sin(a),\n        -sin(a), cos(a)\n    );\n}\n\n// gotta do a Truchet tiling amirite\n#define TAU 6.283\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //----------------------------------- tiling and camera ------------------------------\n    // fb_uv: original framebuffer uv\n    // uv: uv of the each cell\n    // s_uv: scaled uv\n    // cell: vec2 of cell coords\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec2 fb_uv = uv;\n    float ytiles = 5. * (sin(iTime) + 2.);\n    vec2 s_uv = uv * ytiles;\n    \n    // move the \"camera\" around\n    s_uv -= ytiles * .5;\n    mat2 canvasRotation = rot(iTime);\n    s_uv *= canvasRotation;\n    s_uv += ytiles * .5;\n    s_uv += iTime * 5.;\n    \n    uv = fract(s_uv);    \n    vec2 cell = floor(s_uv);\n    \n    //----------------------------------- truchet stuff -----------------------------------\n    \n    float noise = floor(.5 + texture(iChannel0, cell * .01).r);\n    \n    // temp change origin for rotation\n    uv -= .5;\n    mat2 cellRotation = rot(TAU / 4. * noise);\n    uv *= cellRotation;\n    uv += .5;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x *= aspect;\n    \n    vec3 col = vec3(.2,.5,.9);\n    \n    const float width = 0.1;\n    const float st = (.5 - width);\n    const float en = (.5 + width);\n    const float specpower = 6.;\n    vec3 lcolor = vec3(.1, .9, 1.) * .6;\n    vec3 scolor = vec3(1.);\n    \n    vec2 lp = normalize(mouse - fb_uv);\n    vec3 lp3 = normalize(vec3(lp, 1.));\n    \n    // --- bottom left circle ---\n    float d = length(uv);\n    float t = (d - st) / (en - st);\n    t = clamp(t, 0., 1.);\n\tfloat z = sin(t * PI);\n    vec2 tang = canvasRotation * cellRotation * (normalize(uv) * (t * 2. - 1.));\n    vec3 tcol = vec3(tang.xy, z);\n    float incd = clamp(dot(tcol, lp3), 0., 1.);\n    //float masking = (1. - pow(abs(cos(PI * z/2.)), 10.));\n    // todo the \"masking\" term fixes the soft z but edges get crackly when the camera zooms out so whatev\n    col = mix(col, incd * lcolor + pow(incd, specpower) * scolor, z);\n    \n    // --- top right circle ---\n    float e = length(uv - 1.);\n    t = 1. - (e - st) / (en - st);\n    t = clamp(t, 0., 1.);\n\tz = sin(t * PI);\n    tang = canvasRotation * cellRotation * (normalize(1. - uv) * (t * 2. - 1.));\n    tcol = vec3(tang.xy, z);\n    incd = clamp(dot(tcol, lp3), 0., 1.);\n    //masking = (1. - pow(abs(cos(PI * z/2.)), 10.));\n    col = mix(col, incd * lcolor + pow(incd, specpower) * scolor, z);\n\n    // fake light\n    col *= 1.5-length(fb_uv - mouse)*.5;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3SDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 109], [111, 166, 223, 439, 2666]], "test": "untested"}
{"id": "Wd3SDX", "name": "Block Wall", "author": "andremichelle", "description": "random data", "tags": ["fields"], "likes": 8, "viewed": 802, "published": "Public API", "date": "1573028415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand(vec2 p)\n{\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(262144, 32768)*n);     \n}\n\n\nfloat sdRoundBox(vec2 p, vec2 b, float r)\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,.0)) + min(max(q.x,q.y),.0) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col;\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    float g = smoothstep(.0, .25, uv.y+.15)+.25;\n\tuv.y = 1. - abs(uv.y);\n    uv *= 20.;\n    vec2 fl = floor(uv);\n    vec2 fr = (fract(uv)-.5)*2.;\n    float a = sdRoundBox(fr, vec2(.7, .7), .1);\n    float s = smoothstep(0.1, 0.01, a);\n    vec2 ran = rand(fl);\n    float t = pow(abs(sin(ran.x*6.2831 + iTime*(.25 + ran.y))), 8.);\n    col = vec3(ran.x * ran.y, ran.y, .0)*g*s*t;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3SDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 108], [111, 111, 154, 154, 234], [236, 236, 291, 291, 772]], "test": "untested"}
{"id": "Wd3SWl", "name": "[phreax] cube waves", "author": "phreax", "description": "Experimenting with grid offsets", "tags": ["raymarching", "grid", "cube"], "likes": 6, "viewed": 113, "published": "Public", "date": "1573081366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tt, cy; \n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat box(vec3 p, vec3 r) {\n\tp = abs(p) - r;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec2 repeat(inout vec2 p, vec2 s) {\n    vec2 id = floor(p/s-.5);\n    // p = (fract(p/s-.5)-.5)*s;\n    p = mod(p+.5*s, s)-.5*s;\n    return id;\n}\n\n\nfloat N21(vec2 p) {\n\treturn fract(sin(dot(p, vec2(341.234, 934.838)))*34234.23);\n}\n\n\nfloat map(vec3 p) {\n    vec2 id = repeat(p.xz, vec2(3.2));\n    float h = N21(id);\n    vec2 c = vec2(1, -5.);\n    float s = cos(length(id+c)+tt*2.)*.3 +.6;\n    float w = sin(length(id+c)*0.7+tt*3.)*1.5;\n    p.y += (exp(w)-1.5)*.7;\n    cy = p.y;\n    p.xy *= rot(h+0.3*tt*h*sign(h-.5));\n  \n    return (box(p, vec3(s))-.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    tt = iTime;\n    \n\tvec3 ro = vec3(0, -10., -20),\n         rd = normalize(vec3(-uv, .7)),\n         l = normalize(vec3(0, -1, -4.));\n    \n    rd.yz *= rot(.6);\n    \n    vec3 col, bg;\n    col = bg = mix(vec3(.78, .97, .99), vec3(.3), -(uv.y-0.3));  \n    \n    \n    float i, d, t = 0.1;\n    \n    vec3 p;\n    for(i=0.; i<100.; i++) {\n     \tp = ro + t*rd;\n    \td = map(p);\n        if(t < 0.0001 || t > 90.) break;       \n\t\tt += d;\n    }\n    \n    vec2 e = vec2(.0005, -.0005);\n    if(d < 0.001) {\n        \n        vec3 n = normalize(e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                           e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        float ch = p.y - cy; // cube height\n        float dif = max(dot(n, normalize(p-l)), .0);\n        float fog = 1.-exp(-.00002*t*t*t);\n        \n        // subsurface scattering from evvvvil\n        float sss = smoothstep(0., 1., map(p+l*.4));\n        \n        vec3 al = mix(vec3(0.1, 0.6, 0.8)*.9, vec3(.15, 0, 1), ch);\n        col = al*.4 + 0.8*al*(dif+sss);\n        col = mix(col, bg, 0.5*fog);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3SWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 35, 35, 84], [86, 86, 113, 113, 198], [200, 200, 235, 235, 343], [346, 346, 365, 365, 428], [431, 431, 450, 450, 752], [755, 755, 812, 812, 1967]], "test": "untested"}
{"id": "Wd3SWS", "name": "Ripple screensaver", "author": "gabrielmuller", "description": "it be like that", "tags": ["screensaver"], "likes": 4, "viewed": 107, "published": "Public", "date": "1572710523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash(float n) {\n    return floor(vec2(fract(sin(n)*138.5453123), fract(sin(n)*832.83037595)) * 7.) / 7.;\n}\n\nfloat rippleValue(float n, vec2 uv) {\n    vec2 params = hash(n + 0.3859903);\n    params.x = params.x * 0.1 + 0.01;\n    float ripple = floor(iTime * params.x + 10.);\n    float distance = length(uv - hash(ripple * n) * vec2(iResolution.x/iResolution.y, 1.0));\n    float peak = fract(iTime * params.x) * 2.0;\n    float spread = peak * 0.1;\n    return pow((smoothstep(peak-spread, peak, distance) - smoothstep(peak, peak+spread, distance)), 0.2) / pow(peak, 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    vec3 value = vec3(0.);\n    for (int i = 0; i < 20; i++) {\n        float v = rippleValue(float(i), uv) * 2.;\n        value += pow(vec3(v, v * 0.5, 0.), vec3(2.2));\n        if (i % 6 == 0) value = value.xzy;\n        if (i % 6 == 1) value = value.zyx;\n        if (i % 6 == 2) value = value.yxz;\n        if (i % 6 == 3) value = value.zxy;\n        if (i % 6 == 4) value = value.yzx;\n\n    }\n    value = pow(value, vec3(1./2.2));\n    fragColor = vec4(vec3(value*0.2 * (iMouse.y/iResolution.y + 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3SWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 111], [113, 113, 150, 150, 574], [576, 576, 632, 632, 1178]], "test": "untested"}
{"id": "wd3XDS", "name": " Menger Spongen1", "author": "jorge2017a1", "description": " Menger Spongen1\n", "tags": ["mengerspongen1"], "likes": 0, "viewed": 89, "published": "Public", "date": "1572751413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// http://www.iquilezles.org/www/articles/menger/menger.htm\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    //float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n\t//float off = 1.5*sin( 0.01*iTime );\n    \n    float ani = 1.0;\n\tfloat off = 1.0;\n\t\n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        //p = mix( p, ma*(p+off), ani );\n       \n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        \n        s *= 3.0;\n        \n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.005, 0.1 );\n    }\n    return clamp(res,0.5,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\n// light\nvec3 light = normalize(vec3(1.0,0.9,0.3));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\n    vec3 col = mix( vec3(0.3,0.2,0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y );\n    \n    \n\t\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.x>0.0 )\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n\t\t\n        float occ = tmat.y;\n\t\tfloat sha = softshadow( pos, light, 0.01, 64.0 );\n\n\t\tfloat dif = max(0.1 + 0.9*dot(nor,light),0.0);\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float bac = max(0.4 + 0.6*dot(nor,vec3(-light.x,light.y,-light.z)),0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00*dif*vec3(1.10,0.85,0.60)*sha;\n        lin += 0.50*sky*vec3(0.10,0.20,0.40)*occ;\n        lin += 0.10*bac*vec3(1.00,1.00,1.00)*(0.5+0.5*occ);\n        lin += 0.25*occ*vec3(0.15,0.17,0.20);\t \n\n        /*\n        vec3 matcol = vec3(\n            0.5+0.5*cos(0.0+2.0*tmat.z),\n            0.5+0.5*cos(1.0+2.0*tmat.z),\n            0.5+0.5*cos(2.0+2.0*tmat.z) );\n        col = matcol * lin;\n        \n        */\n        \n        col =  lin;\n        \n    }\n\n    //return pow( col, vec3(0.4545) );\n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*iTime),1.0+1.0*cos(iTime*.13),2.5*cos(0.25*iTime));\n\n#if AA>1\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n        vec3 ww = normalize(vec3(0.0) - ro);\n        vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        col += render( ro, rd );\n    }\n    col /= float(AA*AA);\n#else   \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    vec3 col = render( ro, rd );\n#endif        \n    \n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.0,1.0,2.5), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3XDS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1247, 1274, 1274, 1305], [1306, 1306, 1337, 1337, 1428], [1556, 1556, 1579, 1579, 2324], [2326, 2326, 2368, 2368, 2635], [2637, 2637, 2702, 2702, 2928], [2930, 2930, 2960, 2960, 3198], [3200, 3253, 3292, 3316, 4345], [4347, 4347, 4404, 4418, 5419], [5422, 5422, 5516, 5516, 5735]], "test": "untested"}
{"id": "WdcGD7", "name": "Noktowizor", "author": "Sardax", "description": "noktowizor", "tags": ["noktowizor"], "likes": 2, "viewed": 29, "published": "Public", "date": "1574368396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0.0), vec2(1.0));\n}\nfloat sawTooth(float t) \n{\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\n\n//nv general settings\n#define NV_BRIGHTNESS 2.5\n#define NV_COLOR      vec3(1.0, 0.40, 0.53) //can be higher than 1 bcuz i saturated it\n#define NV_BLURRING vec3(0.001,0.002,0.003)\n\n//effect settings\n#define FLICKERING_INTENSITY 0.0015\n#define FLICKERING_FREQ 50.0\n#define NOISE_INTENSITY 0.15\n#define SCANLINES_INTENSITY 0.025\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 image = texture( iChannel0, uv);\n    \n     //cheap noise\n    float noise  = fract(sin(dot(uv, vec2(12.0, 78.0) + (iTime*3.17f) )) * 43758.0); \n    image += noise*NOISE_INTENSITY;\n    \n    //just scanlines\n    image += SCANLINES_INTENSITY*sawTooth((uv.y*(iTime*iTime))*iResolution.y);\n    \n    //image flickering\n    image += FLICKERING_INTENSITY * sin(iTime*FLICKERING_FREQ);  \n             \n    //fast CA, and multipling image for better brightness\n    image += texture( iChannel0, uv + NV_BLURRING.x)*NV_BRIGHTNESS;\n    image += texture( iChannel0, uv + NV_BLURRING.y)*NV_BRIGHTNESS;\n    image += texture( iChannel0, uv + NV_BLURRING.z)*NV_BRIGHTNESS;\n\n\n    //fast color remover\n    image.g = ((image.r + image.g + image.b)/3.f)*saturate(NV_COLOR.x);\n    image.r = ((image.r + image.g + image.b)/3.f)*saturate(NV_COLOR.y);\n    image.b = ((image.r + image.g + image.b)/3.f)*saturate(NV_COLOR.z);\n\n\n        \n    fragColor = image;\n    \n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 58], [60, 60, 83, 83, 128], [130, 130, 153, 153, 198], [199, 199, 225, 225, 280], [462, 611, 668, 668, 1661]], "test": "untested"}
{"id": "wdcSzl", "name": "video transition 4", "author": "ankd", "description": "my video transition pattern.", "tags": ["effect", "transition"], "likes": 8, "viewed": 237, "published": "Public", "date": "1572598443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This source code is under Public Domain CC0 1.0.\n// https://creativecommons.org/publicdomain/zero/1.0/deed.en\n\n#define GRID_SIZE 20.\n\nconst float PI = acos(-1.);\n\nfloat screenIn(in vec2 uv) { return step(abs(uv.x-0.5), 0.5) * step(abs(uv.y-0.5), 0.5); }\nmat2 rotate(in float r) { float c=cos(r),s=sin(r); return mat2(c,-s,s,c); }\nfloat hash(in float v) { return fract(sin(v)*43237.5324); }\nfloat hash(in vec2 v) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*43237.5324); }\n\n// video getter\nvec4 tex1(in vec2 st) { return texture(iChannel0, st); }\nvec4 tex2(in vec2 st) { return texture(iChannel1, st); }\n\n// transition\n// ratio - value to select video, 0~1\n// st - uv coordination of the pixel.\nvec4 transition(float ratio, in vec2 st) {\n    vec2 uv = st;\n    uv *= rotate(PI/6.);\n    \n    uv.y *= GRID_SIZE;\n    vec2 id = vec2(0.);\n    id.y = floor(uv.y);\n    uv.x *= GRID_SIZE*hash(id.y);\n    id.x = id.y + floor(uv.x);\n    \n    float angle = sign(hash(id.x)*2.-1.);\n    float offset = hash(id.x + id.y)+1.414;\n    \n    vec2 uv1 = st;\n    vec2 uv2 = st + vec2(angle * offset * ratio, 0.)*rotate(-PI/6.);\n    \n    return screenIn(uv2)<1. ? tex2(uv1) : tex1(uv2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float ratio = smoothstep(-1., 1., sin(iTime));\n    vec4 video = transition(ratio, uv);\n    \n    vec3 col = uv.y<0.04 ? vec3(step(uv.x, ratio)) : video.rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcSzl.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 166, 194, 194, 256], [257, 257, 282, 282, 332], [333, 333, 357, 357, 392], [393, 393, 416, 416, 479], [481, 497, 520, 520, 553], [554, 554, 577, 577, 610], [612, 702, 744, 744, 1172], [1174, 1174, 1231, 1231, 1470]], "test": "untested"}
{"id": "WddSDr", "name": "Horizon Zero Dawn Clouds 2D", "author": "piyushslayer", "description": "2D cloudscapes modeled after the clouds in Horizon Zero Dawn (see code description for more details). The lighting is just a fake 2d ray marched uv offset and is no way physically based, but still kinda looks better than having no lighting at all. ", "tags": ["noise", "clouds", "fbm", "perlin", "curl", "worley", "horizon"], "likes": 29, "viewed": 1956, "published": "Public API", "date": "1573335626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\nI tried modeling clouds using perlin-worley noise as described by Andrew Schneider\nin the chapter Real-Time Volumetric Cloudscapes of GPU Pro 7. There are two types\nof worley fbm functions used, a low frequency one to model the cloud shapes, and\na high frequency one used to add finer details around the edges of the clouds. Finally,\na simple 2D ray march along the light direction to add some fake lighting and shadows\nto the cloudscapes.\n\nDrag around the sun with the mouse to see a change in the lighting.\n*/\n\n#define CLOUD_COVERAGE .8\n#define CLOUD_AMBIENT .01\n\n// Hash functions by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*uvec2(1597334673U, 3812015801U);\n\tq = (q.x ^ q.y) * uvec2(1597334673U, 3812015801U);\n\treturn vec2(q) * (1.0 / float(0xffffffffU));\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Noise function by morgan3d\nfloat perlinNoise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec2 curlNoise(vec2 uv)\n{\n    vec2 eps = vec2(0., 1.);\n    \n    float n1, n2, a, b;\n    n1 = perlinNoise(uv + eps);\n    n2 = perlinNoise(uv - eps);\n    a = (n1 - n2) / (2. * eps.y);\n    \n    n1 = perlinNoise(uv + eps.yx);\n    n2 = perlinNoise(uv - eps.yx);\n    b = (n1 - n2)/(2. * eps.y);\n    \n    return vec2(a, -b);\n}\n\nfloat worleyNoise(vec2 uv, float freq, float t, bool curl)\n{\n    uv *= freq;\n    uv += t + (curl ? curlNoise(uv*2.) : vec2(0.)); // exaggerate the curl noise a bit\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    float minDist = 100.;\n    for (float y = -1.; y <= 1.; ++y)\n    {\n        for(float x = -1.; x <= 1.; ++x)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 h = hash22(id + offset) * .8 + .1; // .1 - .9\n    \t\th += offset;\n            vec2 d = gv - h;\n           \tminDist = min(minDist, dot(d, d));\n        }\n    }\n    \n    return minDist;\n}\n\nfloat perlinFbm (vec2 uv, float freq, float t)\n{\n    uv *= freq;\n    uv += t;\n    float amp = .5;\n    float noise = 0.;\n    for (int i = 0; i < 8; ++i)\n    {\n        noise += amp * perlinNoise(uv);\n        uv *= 1.9;\n        amp *= .55;\n    }\n    return noise;\n}\n\n// Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nvec4 worleyFbm(vec2 uv, float freq, float t, bool curl)\n{\n    // worley0 isn't used for high freq noise, so we can save a few ops here\n    float worley0 = 0.;\n    if (freq < 4.)\n    \tworley0 = 1. - worleyNoise(uv, freq * 1., t * 1., false);\n    float worley1 = 1. - worleyNoise(uv, freq * 2., t * 2., curl);\n    float worley2 = 1. - worleyNoise(uv, freq * 4., t * 4., curl);\n    float worley3 = 1. - worleyNoise(uv, freq * 8., t * 8., curl);\n    float worley4 = 1. - worleyNoise(uv, freq * 16., t * 16., curl);\n    \n    // Only generate fbm0 for low freq\n    float fbm0 = (freq > 4. ? 0. : worley0 * .625 + worley1 * .25 + worley2 * .125);\n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\n    float fbm3 = worley3 * .75 + worley4 * .25;\n    return vec4(fbm0, fbm1, fbm2, fbm3);\n}\n\nfloat clouds(vec2 uv, float t)\n{\n    float coverage = hash12(vec2(uv.x * iResolution.y/iResolution.x, uv.y)) *\n        .1 + (CLOUD_COVERAGE * .5 + .5); // coverage between whatever value and 1.\n \tfloat pfbm = perlinFbm(uv, 2., t);\n    vec4 wfbmLowFreq = worleyFbm(uv, 1.6, t * 1.25, false); // low freq without curl\n    vec4 wfbmHighFreq = worleyFbm(uv, 8., t * 1.5, true); // high freq with curl\n    float perlinWorley = remap(abs(pfbm * 2. - 1.),\n                               1. - wfbmLowFreq.r, 1., 0., 1.);\n    perlinWorley = remap(perlinWorley, 1. - coverage, 1., 0., 1.) * coverage;\n    float worleyLowFreq = wfbmLowFreq.g * .625 + wfbmLowFreq.b * .25\n        + wfbmLowFreq.a * .125;\n    float worleyHighFreq = wfbmHighFreq.g * .625 + wfbmHighFreq.b * .25\n        + wfbmHighFreq.a * .125;\n    float c = remap(perlinWorley, (worleyLowFreq - 1.) * .64, 1., 0., 1.);\n    c = remap(c, worleyHighFreq * .08, 1., 0., 1.);\n    return max(0., c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    float t = mod(iTime + 600., 7200.) * .03;\n    \n    // set up 2D ray march variables\n    vec2 marchDist = vec2(.35 * max(iResolution.x, iResolution.y)) / iResolution.xy;\n    const float steps = 10.;\n    float stepsInv = 1. / steps;\n    vec2 sunDir = normalize(m - uv) * marchDist * stepsInv;\n    vec2 marchUv = uv;\n    float cloudColor = 1.;\n    float cloudShape = clouds(uv, t);\n    \n    // 2D ray march lighting loop based on uncharted 4\n    for (float i = 0.; i < marchDist.x; i += marchDist.x * stepsInv)\n    {\n        marchUv += sunDir * i;\n   \t\tfloat c = clouds(marchUv, t);\n        cloudColor *= clamp(1. - c, 0., 1.);\n    }\n    \n    cloudColor += CLOUD_AMBIENT; // ambient\n    // beer's law + powder sugar\n    cloudColor = exp(-cloudColor) * (1. - exp(-cloudColor*2.)) * 2.;\n    cloudColor *= cloudShape;\n    \n    vec3 skyCol = mix(vec3(.1, .5, .9), vec3(.1, .1, .9), uv.y);\n    vec3 col = vec3(0.);\n    col = skyCol + cloudShape;\n  \tcol = mix(vec3(cloudColor) * 25., col, 1.-cloudShape);\n    float sun = .002 / pow(length(uv - m), 1.7);\n    col += (1. - smoothstep(.0, .4, cloudShape)) * sun;\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[570, 604, 626, 626, 774], [776, 776, 797, 797, 957], [959, 959, 1017, 1017, 1067], [1069, 1099, 1126, 1126, 1438], [1440, 1440, 1465, 1465, 1759], [1761, 1761, 1821, 1821, 2344], [2346, 2346, 2394, 2394, 2608], [2610, 2713, 2770, 2847, 3575], [3577, 3577, 3609, 3609, 4525], [4527, 4527, 4584, 4584, 5810]], "test": "untested"}
{"id": "WddSDs", "name": "stripes to triangles, colorful", "author": "thisisthais", "description": "an exercise from chapter 9 of the book of shaders", "tags": ["triangle", "colors", "shapes", "stripes", "tiling", "rotation", "tboss"], "likes": 2, "viewed": 58, "published": "Public", "date": "1573152808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st,float _angle){\n  _st-=.5;\n  _st=mat2(cos(_angle),-sin(_angle),\n  sin(_angle),cos(_angle))*_st;\n  _st+=.5;\n  return _st;\n}\n\nvec2 tile(vec2 _st,float _zoom){\n  _st*=_zoom;\n  return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n  \n  //  Scale the coordinate system by 2x2\n  _st*=2.;\n  \n  //  Give each cell an index number\n  //  according to its position\n  float index=0.;\n  index+=step(1.,mod(_st.x,2.));\n  index+=step(1.,mod(_st.y,2.))*2.;\n  \n  //      |\n  //  2   |   3\n  //      |\n  //--------------\n  //      |\n  //  0   |   1\n  //      |\n  \n  // Make each cell between 0.0 - 1.0\n  _st=fract(_st);\n  \n  // Rotate each cell according to the index\n  // 0 rotates 0\n  if(index==1.){\n    //  Rotate cell 2 by -90 degrees\n    _st=rotate2D(_st,PI*-.5);\n  }else if(index==2.){\n    //  Rotate cell 1 by 90 degrees\n    _st=rotate2D(_st,PI*.5);\n  }else if(index==3.){\n    //  Rotate cell 3 by 180 degrees\n    _st=rotate2D(_st,PI);\n  }\n  \n  return _st;\n}\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\n// As t runs from 0 to 1 (our normalized palette index or domain),\n//the cosine oscilates c times with a phase of d.\n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette(float t,vec3 a,vec3 b,vec3 c,vec3 d)\n{\n  return a+b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 myRes = iResolution.yy/1.5;\n  vec2 st=fragCoord.xy/myRes.xy;\n  \n  st=tile(st,3.);\n  st=rotateTilePattern(st);\n  \n  // Make more interesting combinations\n  st=tile(st,3.);\n  st=rotate2D(st,-PI*iTime*.15);\n  //st = rotateTilePattern(st*2.);\n  // st = rotate2D(st,PI*u_time*0.25);\n  \n  vec3 color=cosPalette(iTime/10.,vec3(.8),vec3(.3),vec3(1.),vec3(iTime*.01,iTime*.1,iTime*.2));\n  // step(st.x,st.y) just makes a b&w triangles\n  // but you can use whatever design you want.\n  fragColor=vec4(vec3(step(st.x,st.y))*color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 72, 72, 179], [181, 181, 213, 213, 250], [252, 252, 285, 329, 1006], [1008, 1280, 1334, 1334, 1371], [1373, 1373, 1427, 1427, 1959]], "test": "untested"}
{"id": "WddXDf", "name": "Trypophobia [contest]", "author": "warlock", "description": "Made with help of the awesome tutorial videos from BigWIngs\n\nhttps://www.youtube.com/watch?v=l-07BXzNdPw - Voronoi\n\nSpecial for competition of webgl enthusiast's community https://discord.gg/W9kTZAx", "tags": ["raymarching", "voronoi", "trypophobia"], "likes": 13, "viewed": 370, "published": "Public", "date": "1573059493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n//#define SHADOWS // optional shadows\n\n#define PI 3.1415926\n#define minDistance 100.\n#define SEED 345.\n#define iTime (iTime+SEED)\n\n\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 voronoi(vec2 p){\n\tvec2 gv = fract(p) - 0.5;\n    vec2 id = floor(p);\n    float minDist = minDistance;\n    float d = 0.;\n    vec2 cid = vec2(0);\n    for (float y = -1.; y <= 1.; y++){\n        for (float x = -1.; x <= 1.; x++){\n        \tvec2 offs = vec2(x, y);\n            \n            vec2 n = N22(id + offs);\n            vec2 p = offs + sin(n * SEED) * .25;\n            p += cos(n * iTime) * 0.0666;\n            d = length(gv - p);\n            if (d < minDist) {\n            \tminDist = d;\n                cid = n;\n            }\n        }\n    }\n    \n    vec2 mult = cid * iTime * PI * 0.5;\n    \n    return vec2(minDist, minDist * 8. + (sin(mult) * cos(mult * .25)));\n}\n\nvec2 sdFloor(vec3 p){\n    float d = p.y;\n    \n    vec2 vor = voronoi(p.xz);\n    float v = vor.x;\n    v = sin(v * PI * 1.5) * (0.25 + sin(vor.y) * 0.25) + 0.25;\n   \n    d -= pow(v, 4.);\n    \n    float r = texture(iChannel0, p.xz).r;\n\tr = pow(r, 2.) * 0.05;\n    d += r;\n\t\n    float g = texture(iChannel1, p.xz * 0.5).g;\n    d += pow(g, 4.) * 0.05;         \n    \n    return vec2(d * 0.5, vor.y);\n}\n\n\nvec2 GetDist( vec3 p ){\n\n    return sdFloor(p);\n}\n\nvec2 RayMarch( vec3 ro, vec3 rd ){\n    \n\tvec2 dO = vec2(0.);\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n    \tvec3 p = ro + rd * dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x;\n        dO.y = dS.y;\n        if (dO.x > MAX_DIST || dO.x < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal( vec3 p ){\n    \n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = vec3(\n        GetDist(p + e.xyy).x - GetDist(p - e.xyy).x,\n        GetDist(p + e.yxy).x - GetDist(p - e.yxy).x,\n        GetDist(p + e.yyx).x - GetDist(p - e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat GetLight( vec3 p ){\n    \n\tvec3 lightPos = vec3(0, 5, 0);\n    lightPos.xz += vec2(cos(iTime * 0.328), sin(iTime)) * 2.;\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float plDist = length(lightPos - p);\n    #ifdef SHADOWS\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l).x;\n        if (d < plDist) dif *= 0.25;\n    \n    #endif\n    dif *= smoothstep(10., 0., plDist);\n    \n    return dif;\n}\n\nvec3 setFromSphericalCoords( float radius, float phi, float theta ) { // stolen from three.js :-P\n    \t\n    \tvec3 v = vec3(0);\n    \n    \tfloat sinPhiRadius = sin( phi ) * radius;\n\t\t\n\t\tv.x = sinPhiRadius * sin( theta );\n\t\tv.y = cos( phi ) * radius;\n\t\tv.z = sinPhiRadius * cos( theta );\n\n\t\treturn v;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    \n    // camera settings ---------------------------------------\n    \n        \n    // angles\n    \n    float distToOrigin = 7.5;\n    float phiStart = PI / 4.;\n    float thetaStart = PI / 3.;\n    \n    vec2 mouse = iMouse.w > 0.5 ? (iMouse.xy * 2. - iResolution.xy)  / iResolution.xy: vec2(0);\n    \n    vec3 lookAt = vec3(0, 0, 0);\n    \n    float phi = phiStart - mouse.y * (PI / 6.1);\n    float theta = thetaStart + mouse.x * PI;\n    \n    vec3 ro = setFromSphericalCoords(distToOrigin, phi, theta);\n\n    \n    float zoom = 1.;\n    vec3 f = normalize(lookAt - ro),\n        r = normalize(cross(vec3(0, 1, 0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i - ro);\n    \n    // -------------------------------------------------------\n    \n    vec2 d = RayMarch( ro, rd );  // returns distance(x) and data for gradient (y);\n    \n    vec3 p = ro + rd * d.x;\n\n    float dif = GetLight(p) * 1.5;\n    \n    //vec3 col = vec3(0.125, 0.3, 0.25);\n    //vec3 col = vec3(1,0.5,0.5);\n    vec3 col = vec3(0.5, 0.25, 0.5);\n    \n    col = mix(col, texture(iChannel0, p.xz).rgb, 0.25);\n    \n    col = mix(col, vec3(0.9, 0.05, 0.05) * 1.5, smoothstep(1., 0., d.y));\n    col = mix(col, vec3(0, 0, 0), smoothstep(0.5, 1., d.y) - smoothstep(1.25, 1.5, d.y));\n    //col = mix(col, vec3(0.5, 0, 0.75), smoothstep(0.14, 0.15, p.y) - smoothstep(0.15, 0.16, p.y));\n    \n    col *= dif;\n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "lts3DX", "previewfilepath": "https://soundcloud.com/myuu/the-unknown-horror-ambience", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/myuu/the-unknown-horror-ambience", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 199, 216, 216, 350], [352, 352, 373, 373, 1023], [1025, 1025, 1046, 1046, 1419], [1422, 1422, 1445, 1445, 1471], [1473, 1473, 1507, 1507, 1766], [1768, 1768, 1793, 1793, 2043], [2045, 2045, 2070, 2070, 2525], [2527, 2527, 2596, 2624, 2827], [2830, 2830, 2887, 2887, 4429]], "test": "untested"}
{"id": "WddXDl", "name": "music shader 1", "author": "ArthurSango", "description": "rfr", "tags": ["music"], "likes": 4, "viewed": 335, "published": "Public API", "date": "1573342518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nmat2 rot(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 fuck(float _angle){\n    return mat2(acos(_angle),-sin(_angle),\n                -sin(_angle),tan(_angle));\n}\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n  \n   \n     \n   \n    uv = abs( 2. * uv - 1. );\n    \n    // uv *= rot(   time / 10.);\n      uv *= rot( fbm(uv) * time / 10.);\n    \n   //  uv *= rot(   uv.x * 3.14);\n   \n    vec3 col = vec3( 0.);\n   \n    vec4 t = texture( iChannel0, uv);\n   \n   \n    float m = t.x + fbm(uv);\n   // m = t.x + 0.3;\n    uv *= fuck(m);\n    float r = m * 6.28;\n    \n    float c = ( sin(iTime) + 1. ) * m; \n    \n    \n    uv = fract( m * 10. * uv);\n    \n    float dist = distance( uv, vec2(0.5 * m ) );\n    \n    \n  //  col = l.xyz;\n  \n    // uv *= mat2( cos(r), sin(r), -sin(r), cos(r) );\n    \n    col.x += uv.x;\n    col.z = dist ;\n    col.y = dot( vec2(c), uv);\n    \n   \n   \n   // col.z += abs(sin(r));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 214, 240, 240, 620], [640, 640, 664, 686, 940], [942, 942, 965, 965, 1051], [1052, 1052, 1076, 1076, 1164], [1184, 1184, 1241, 1241, 2002]], "test": "untested"}
{"id": "wddXDX", "name": "torus-mapped noise", "author": "visy", "description": "torus mapped noise, based on tweet by Donald Mitchell and the fast 4d noise from \"webgl-noise\" package, license in comments.", "tags": ["torusnoise"], "likes": 5, "viewed": 366, "published": "Public", "date": "1573061049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float s = 30.0+cos(iTime*0.1+uv.x)*10.;\n    float s2 = 30.0+cos(iTime*0.1+uv.x)*10.;\n    float s3 = 30.0+cos(iTime*0.1+uv.x)*10.;\n    \n    float ox = iTime*10.5;\n    float oy = -iTime*1.0;\n    \n    float zz = cos(uv.y*5.*cos(iTime*0.1))*sin(uv.x*sin(iTime*0.1));\n    \n    // torus mapping: 2d periodic tiling texture by embedding a 4d torus\n    float noise = snoise(vec4(sin(ox+uv.x*s+zz), cos(ox+uv.x*s-zz), sin(oy+uv.y*s-zz), cos(oy+uv.y*s+zz)));\n\tfloat noise2 = snoise(vec4(sin(ox+uv.x*s2+zz), cos(ox+uv.x*s2-zz), sin(oy+uv.y*s2-zz), cos(oy+uv.y*s2+zz)));\n\tfloat noise3 = snoise(vec4(sin(ox+uv.x*s3+zz), cos(ox+uv.x*s3-zz), sin(oy+uv.y*s3-zz), cos(oy+uv.y*s3+zz)));\n\n    vec3 col = vec3(noise,noise2*2., noise3*3.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddXDX.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 250, 271, 271, 320], [322, 322, 345, 345, 394], [396, 396, 418, 418, 458], [460, 460, 484, 484, 524], [526, 526, 554, 554, 606], [608, 608, 638, 638, 690], [692, 692, 724, 724, 987], [995, 1069, 1093, 1093, 3571], [3573, 3573, 3630, 3630, 4428]], "test": "untested"}
{"id": "WddXRl", "name": "celestial chaos", "author": "HiDeF", "description": "the stars warp and fade around us.", "tags": ["raymarch"], "likes": 2, "viewed": 336, "published": "Public API", "date": "1572629000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cubeSDF(vec3 p) {\n    \n    vec3 d = abs(p) - vec3(1);\n\n\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.);\n\n\n    float outsideDistance = length(max(d, 0.));\n    \n    //edit this line to make it look different!!!!\n    float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(iTime * p.z) * 0.25;\n\n    return insideDistance + outsideDistance + displacement;\n}\n\nfloat trace (vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = fract(cubeSDF(p)) * 10.0 - 1.0;\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 o = vec3(0.0, 0.0, -3.0);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 375], [377, 377, 407, 407, 583], [585, 585, 642, 692, 1059]], "test": "untested"}
{"id": "WdG3R3", "name": "Torsion_pendulum_clock_detailed", "author": "Caramoule", "description": "A torsion pendulum clock made only of primitives and displayed with ray tracing.\n\nUncomment the line 514 and comment the line 513 to call a simplified version of the object with pendulums and clock hands animation. Or check my other Shadertoy clock.", "tags": ["raytracing", "clock", "implicit", "surface"], "likes": 1, "viewed": 56, "published": "Public", "date": "1573155912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs - Base code by Eric Galin\n// Etienne LUQUIN\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.0;\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R)\n{\n  float u = clamp(x/R,0.0,1.0);\n  float v = (1.0-u*u);\n  return v*v*v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment Skeleton\n// p : point origine\n// a : point a\n// b : point b\n// e : energy associated to skeleton\n// R : radius thickness\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 u = normalize(b - a);\n    float distFinal = 0.0;\n    \n    if (dot(u, (p - a)) < 0.0)\n    {\n        distFinal = distance(p, a);\n    }\n    else if (dot(u, (p - b)) > 0.0)\n    {\n        distFinal = distance(p, b); \n    }\n    else\n    {\n        float distPA = distance(p, a);\n        float L = dot((p - a), u);\n        distFinal = sqrt( (distPA * distPA) - (L * L) );\n    }\n    return e * falloff(distFinal, R);\n}\n\n// Disk Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat disk(vec3 p, vec3 c, vec3 dir, float ray, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n                  \n    if(L < ray)\n    {\n      distFinal = abs(HP);   \n    }\n    else\n    {\n      distFinal = sqrt( ((L - ray) * (L - ray)) + (HP * HP) );\n    }\n    \n    return e * falloff(distFinal, R);\n}\n\n// Tore Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat tore(vec3 p, vec3 c, vec3 dir, float ray, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n                  \n    distFinal = sqrt( ((L - ray) * (L - ray)) + (HP * HP) ); \n    \n    return e * falloff(distFinal, R);\n}\n\n// Cylinder Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// h : float height of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat cylinder(vec3 p, vec3 c, vec3 dir, float ray, float h, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n    float hMax = max(0.0, abs(HP) - h);           \n    \n    if(L < ray)\n    {\n      distFinal = hMax;\n    }\n    else\n    {\n      distFinal = sqrt( (L - ray) * (L - ray) + hMax * hMax );\n    }\n     return e * falloff(distFinal, R);\n}\n\n// Sphere Skeleton\n// p : point origine\n// c : point center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat sphere(vec3 p, vec3 c, float ray, float e, float R)\n{\n  return e * falloff(max(0.0, distance(p, c) - ray), R);\n}\n\n// Bubble Skeleton\n// p : point origine\n// c : point center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat bubble(vec3 p, vec3 c, float ray, float e, float R)\n{\n  float distFinal = 0.0;\n  float distCP = distance(p, c);\n    \n  if(distCP < ray)\n  {\n  \tdistFinal = ray;  \n  }\n  else\n  {\n    distFinal = distCP - ray;\n  }\n  return e * falloff(distFinal, R);\n}\n\n// Box Skeleton\n// p : point origine\n// a : point corner of skeleton\n// dir : orientation of the skeleton not implemented yet\n// h : float height\n// w : float width\n// d : float depth\n// e : energy associated to skeleton\n// R : radius thickness\nfloat box(vec3 p, vec3 a, vec3 dir, float w, float h, float d, float e, float R)\n{\n  // ne prend pas enore en compte l'orientation et les valeurs negatives\n  vec3 u = normalize(dir);\n  float distFinal = 0.0;\n\n  float maxAx = a.x + w;\n  float maxAy = a.y + h;\n  float maxAz = a.z + d;    \n    \n  if(p.x < a.x)\n    distFinal += (a.x - p.x) * (a.x - p.x);\n  else if(p.x > maxAx)\n    distFinal += (maxAx - p.x) * (maxAx - p.x);\n      \n  if(p.y < a.y)\n    distFinal += (a.y - p.y) * (a.y - p.y);\n  else if(p.y > maxAy)\n    distFinal += (maxAy - p.y) * (maxAy - p.y);\n      \n  if(p.z < a.z)\n    distFinal += (a.z - p.z) * (a.z - p.z);\n  else if(p.z > maxAz)\n    distFinal += (maxAz - p.z) * (maxAz - p.z);\n    \n  return e * falloff(distFinal, R);\n}\n\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Difference\n// a,b : field function of the sub-trees\nfloat Diff(float a,float b)\n{\n    return min(a, 2.0 * T - b);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n   return min(a,b);\n}\n\n\n// Complex objects creation\n\n// Modelisation de la base horloge\nfloat Base(vec3 p, bool simplified)\n{\n  float baseCy1 = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 12.0, 0.5, 1.0, 2.0);\n  float baseDi1 = disk(p, vec3(0.0, 1.5, 0.0), vec3(0.0, 1.0, 0.0), 11.0, 1.0, 1.5);\n  float base = Blend(baseCy1, baseDi1);\n      \n  float baseDi2 = disk(p, vec3(0.0, 2.5, 0.0), vec3(0.0, 1.0, 0.0), 10.0, 1.0, 1.5);\n  base = Blend(base, baseDi2);\n    \n  float basePillar3 = cylinder(p, vec3(-3.0, 5.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 2.5, 1.0, 1.0); \n  base = Blend(base, basePillar3);\n   \n  if(!simplified)\n  {\n \t  float basePillar1 = disk(p, vec3(3.0, 3.1, 5.5), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 0.3);\n \t  base = Blend(base, basePillar1);\n      \n      float basePillar2 = disk(p, vec3(3.0, 3.1, -5.5), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 0.3);\n      base = Blend(base, basePillar2);\n\n      float holeTo1 = tore(p, vec3(0.0, 3.0, 0.0), vec3(0.0, 1.0, 0.0), 9.0, 1.0, 0.5);\n      base = Diff(base, holeTo1);\n\n      float holeCy1 = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 10.0, 1.0, 1.0, 1.0);\n      base = Diff(base, holeCy1);\n  }\n  \n  return base;\n}\n\n// Modelisation du mechanisme derriere le cadran\nfloat Battery(vec3 p, bool simplified)\n{\n  float pillarCy1 = cylinder(p, vec3(3.0, 8.0, 5.5), vec3(0.0, 1.0, 0.0), 0.3, 6.0, 1.0, 1.0);\n  float pillarCy2 = cylinder(p, vec3(3.0, 8.0, -5.5), vec3(0.0, 1.0, 0.0), 0.3, 6.0, 1.0, 1.0);\n  float battery = Union(pillarCy1, pillarCy2);  \n        \n  float batteryBox1 = box(p, vec3(-3.0, 14.0, -6.2), vec3(0.0, 1.0, 0.0), 7.0, 0.5, 12.4, 1.0, 0.2);\n  battery = Union(battery, batteryBox1);\n    \n  float batteryBox2 = box(p, vec3(-3.0, 14.5, -3.5), vec3(0.0, 1.0, 0.0), 5.2, 7.0, 7.0, 1.0, 0.2);\n  battery = Blend(battery, batteryBox2);\n    \n  float pillarCy3 = cylinder(p, vec3(-3.0, 17.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 5.0, 1.0, 1.0); \n  battery = Blend(battery, pillarCy3);\n    \n  if(!simplified)\n  {\n      float holeBox3 = box(rotateY(p, 10.0), vec3(-5.0, 13.0, -8.2), vec3(0.0, 1.0, 0.0), 6.0, 2.0, 3.0, 1.0, 0.1);\n  \t  battery = Diff(battery, holeBox3);\n      \n      float holeBox4 = box(rotateY(p, -10.0), vec3(-5.0, 13.0, 5.2), vec3(0.0, 1.0, 0.0), 6.0, 2.0, 3.0, 1.0, 0.1);\n  \t  battery = Diff(battery, holeBox4);\n  }\n    \n  float holeBox1 = box(p, vec3(3.0, 13.0, -4.0), vec3(0.0, 1.0, 0.0), 8.0, 2.0, 8.0, 1.0, 0.2);\n  battery = Diff(battery, holeBox1);\n    \n  return battery;\n}\n\n// Modelisation du cadran \t\nfloat Dial(vec3 p, bool simplified)\n{\t\n  float dial = disk(p, vec3(3.0, 18.0, 0.0), vec3(1.0, 0.0, 0.0), 5.0, 1.0, 1.5);\n  float holeCy1 = cylinder(p, vec3(4.7, 18.0, 0.0), vec3(1.0, 0.0, 0.0), 4.3, 1.0, 1.0, 1.0);\n  dial = Diff(dial, holeCy1);\n  \n  float midSeg1 = segment(p, vec3(3.0, 18.0, 0.0), vec3(3.7, 18.0, 0.0), 1.0, 0.5);\n  dial = Union(dial, midSeg1);\n    \n  if(!simplified)\n  {\n      float twelve = segment(p, vec3(3.2, 21.5, 0.6), vec3(3.2, 22.0, 0.6), 1.0, 0.3);\n      twelve = Union(twelve, segment(p, vec3(3.2, 21.5, 0.2), vec3(3.2, 22.0, 0.2), 1.0, 0.3));\n      twelve = Union(twelve, segment(p, vec3(3.2, 21.5, -0.3), vec3(3.2, 22.0, -0.7), 1.0, 0.3));\n      twelve = Union(twelve, segment(p, vec3(3.2, 22.0, -0.3), vec3(3.2, 21.5, -0.7), 1.0, 0.3));\n      dial = Union(dial, twelve);\n\n      float three = segment(p, vec3(3.2, 17.75, 3.5), vec3(3.2, 18.25, 3.5), 1.0, 0.3);\n      three = Union(three, segment(p, vec3(3.2, 17.75, 3.9), vec3(3.2, 18.25, 3.9), 1.0, 0.3));\n      three = Union(three, segment(p, vec3(3.2, 17.75, 4.3), vec3(3.2, 18.25, 4.3), 1.0, 0.3));\n      dial = Union(dial, three);\n\n      float six = segment(p, vec3(3.2, 14.5, -0.7), vec3(3.2, 14.0, -0.4), 1.0, 0.3);\n      six = Union(six, segment(p, vec3(3.2, 14.0, -0.4), vec3(3.2, 14.5, -0.1), 1.0, 0.3));\n      six = Union(six, segment(p, vec3(3.2, 14.5, 0.3), vec3(3.2, 14.0, 0.3), 1.0, 0.3));\n      dial = Union(dial, six);\n\n      float nine = segment(p, vec3(3.2, 17.75, -3.9), vec3(3.2, 18.25, -3.5), 1.0, 0.3);\n      nine = Union(nine, segment(p, vec3(3.2, 17.75, -3.5), vec3(3.2, 18.25, -3.9), 1.0, 0.3));\n      nine = Union(nine, segment(p, vec3(3.2, 17.75, -4.3), vec3(3.2, 18.25, -4.3), 1.0, 0.3));\n      dial = Union(dial, nine);\n  }   \n    \n  return dial;\n}\n\n// Modelisation de l'engrenage qui tourne\nfloat Clockwork(vec3 p, float t, bool simplified)\n{\n  float clockwork = cylinder(p, vec3(-3.0, 10.0, 0.0), vec3(0.0, 1.0, 0.0), 0.2, 3.0, 1.0, 1.0); \n  \n  if(!simplified)\n  {\n      float t1 = t + M_PI/2.0;\n      float t2 = t + M_PI;\n      float t3 = t + (3.0 * M_PI)/2.0;\n\n      float holeSeg1 = segment(p, vec3(cos(t) - 3.0, 12.0, -sin(t)), \n                                    vec3(cos(t1) - 3.0, 8.0, -sin(t1)), 1.0, 1.4); \n      clockwork = Diff(clockwork, holeSeg1);\n\n      float holeSeg2 = segment(p, vec3(cos(t2) - 3.0, 12.0, -sin(t2)), \n                                    vec3(cos(t3) - 3.0, 8.0, -sin(t3)), 1.0, 1.4); \n      clockwork = Diff(clockwork, holeSeg2);\n  }\n    \n  return clockwork;\n}\n\n// Modelisation des aiguilles qui tournent\nfloat HandMoving(vec3 p, float t)\n{\n  float t1 = t / 12.0;\n  \n  float hands = segment(p, vec3(3.4, 18.0, 0.0), \n                        vec3(3.4, cos(t) * 3.0 + 18.0,  sin(t) * 3.0),\n                        1.0, 0.2);\n  hands = Union(hands, segment(p, vec3(3.7, 18.0, 0.0), \n                        vec3(3.8, cos(t1) * 2.0 + 18.0,  sin(t1) * 2.0),\n                        1.0, 0.2));\n  return hands;\n}\n\n// Modelisation des pendules qui tournent\nfloat PendulumMoving(vec3 p, float t)\n{\n  float t1 = t + M_PI/2.0;\n  float t2 = t + M_PI;\n  float t3 = t + (3.0 * M_PI)/2.0;\n    \n  float ball1 = sphere(p, vec3(cos(t) * 3.0 - 3.0, 6.0, sin(t) * 3.0), 1.2, 1.0, 1.0);\n  float ball2 = sphere(p, vec3(cos(t1) * 3.0 - 3.0, 6.0, sin(t1) * 3.0), 1.2, 1.0, 1.0);\n  float pendulums = Union(ball1, ball2);\n    \n  float ball3 = sphere(p, vec3(cos(t2) * 3.0 - 3.0, 6.0, sin(t2) * 3.0), 1.2, 1.0, 1.0);\n  pendulums = Union(pendulums, ball3);\n    \n  float ball4 = sphere(p, vec3(cos(t3) * 3.0 - 3.0, 6.0, sin(t3) * 3.0), 1.2, 1.0, 1.0);\n  pendulums = Union(pendulums, ball4);\n    \n  float attachSeg1 = segment(p, vec3(cos(t) * 3.0 - 3.0, 6.0, sin(t) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg1);\n    \n  float attachSeg2 = segment(p, vec3(cos(t1) * 3.0 - 3.0, 6.0, sin(t1) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg2);\n    \n  float attachSeg3 = segment(p, vec3(cos(t2) * 3.0 - 3.0, 6.0, sin(t2) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg3);\n    \n  float attachSeg4 = segment(p, vec3(cos(t3) * 3.0 - 3.0, 6.0, sin(t3) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3);  \n  pendulums = Blend(pendulums, attachSeg4);\n    \n  return pendulums;\n}\n \nfloat Object_complex(vec3 p)\n{\n  float t = iTime;\n    \n  // base horloge\n  float base = Base(p, false);\n    \n  // arriere du cadran\n  float battery = Battery(p, false);\n  float finalObj = Union(base, battery);\n\n  // cadran\n  float dial = Dial(p, false);\n  finalObj = Union(finalObj, dial);\n \n  // engrenage\n  float clockwork = Clockwork(p, t, false);\n  finalObj = Union(finalObj, clockwork);\n    \n  // aiguilles\n  float hands = HandMoving(p, t);\n  finalObj = Union(finalObj, hands);\n   \n  // pendules\n  float pendulums = PendulumMoving(p, t);\n  finalObj = Blend(finalObj, pendulums);\n    \n  return finalObj;  \n}\n\nfloat Object_simplified(vec3 p)\n{\n  float t = iTime;  \n  \n  // base horloge\n  float base = Base(p, true);\n    \n  // arriere du cadran\n  float battery = Battery(p, true);\n  float finalObj = Union(base, battery);\n\n  // cadran\n  float dial = Dial(p, true);\n  finalObj = Union(finalObj, dial);\n \n  // mecanisme\n  float clockwork = Clockwork(p, t, true);\n  finalObj = Union(finalObj, clockwork);\n    \n  // aiguilles\n  float hands = HandMoving(p, t);\n  finalObj = Union(finalObj, hands);\n   \n  // pendules\n  float pendulums = PendulumMoving(p, t);\n  finalObj = Blend(finalObj, pendulums);\n    \n  return finalObj;\n}\n    \n// Potential field of the object\n// p : point\nfloat Object(vec3 p)\n{\n  p.z=-p.z;\n    \n  // utilisation de mes fonctions\n  //float v = segment(p, vec3(0.0, 0.0, 0.0), vec3(3.0, 0.0, 3.0), 1.0, 4.0);\n  //float v = disk(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 1.0, 1.0);\n  //float v = tore(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 1.0, 1.0);\n  //float v = sphere(p, vec3(0.0, 0.0, 0.0), 3.0, 1.0, 1.0);\n  //float v = bubble(p, vec3(0.0, 0.0, 0.0), 3.0, 1.0, 1.0);\n  //float v = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 5.0, 1.0, 1.0);\n  //float v = box(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 5.0, 4.0, 1.0, 1.0);\n    \n  float finalObj = Object_complex(p);\n  //float finalObj = Object_simplified(p);\n\n  return finalObj - T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = Object(p);\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(0.4, 0.3, 0.75), vec3(0.75, 0.85, 1.0), d.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*Background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  //vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n  vec3 ro = vec3(0.0, 10.0, 30);\n  \n  // position camera base\n  ro = rotateY(ro, 90.0);\n  rd = rotateY(rd, 90.0);\n  ro = rotateZ(ro, -0.2);\n  rd = rotateZ(rd, -0.2);\n  \n  vec2 mouse = iMouse.xy / iResolution.xy;\n  ro = rotateY(ro, -mouse.x * 5.0);\n  rd = rotateY(rd, -mouse.x * 5.0);\n  ro = rotateZ(ro, -mouse.y * 5.0);\n  rd = rotateZ(rd, -mouse.y * 5.0);\n   \n    \n  //float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n    \n    \n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = Background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdG3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 369, 400, 400, 498], [500, 500, 531, 531, 630], [632, 632, 663, 663, 762], [765, 828, 861, 861, 934], [951, 1069, 1116, 1116, 1153], [1155, 1287, 1344, 1344, 1763], [1765, 1961, 2028, 2028, 2415], [2417, 2613, 2680, 2680, 2987], [2989, 3221, 3301, 3301, 3715], [3717, 3850, 3909, 3909, 3968], [3970, 4103, 4162, 4162, 4357], [4359, 4604, 4686, 4759, 5346], [5363, 5416, 5446, 5446, 5464], [5466, 5521, 5550, 5550, 5584], [5586, 5674, 5704, 5704, 5727], [5729, 5824, 5861, 5861, 5883], [5915, 5950, 5987, 5987, 7040], [7042, 7091, 7131, 7131, 8323], [8325, 8353, 8390, 8390, 10112], [10114, 10156, 10207, 10207, 10860], [10862, 10905, 10940, 10940, 11306], [11308, 11350, 11389, 11389, 12756], [12759, 12759, 12789, 12789, 13370], [13372, 13372, 13405, 13405, 13980], [13986, 14032, 14054, 14054, 14755], [14757, 14797, 14828, 14828, 15049], [15051, 15156, 15207, 15207, 15638], [15640, 15745, 15802, 15802, 16253], [16256, 16297, 16322, 16322, 16396], [16398, 16459, 16487, 16504, 16821], [16823, 16855, 16879, 16879, 16960], [16963, 16963, 17020, 17020, 18177]], "test": "untested"}
{"id": "wdGSD1", "name": "HexMatrixUniverse_Aelfcraeft", "author": "XiaoHouzi", "description": "warping hexagonal mesh with universe within", "tags": ["hexuniverse"], "likes": 14, "viewed": 625, "published": "Public API", "date": "1574667890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nvec4 Grid(vec2 point, float num)\n{\n    vec2 r = vec2(1, 1.732);\n    vec2 h = r*.5;\n    vec2 uv = point*num;\n    \n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv-h, r) - h;\n    \n    uv = length(a)<length(b)? a:b;\n    vec2 id = floor(point*num);\n    \n    return vec4(uv, id); \n}\n\nfloat Hex(vec2 uv)\n{\n    uv=abs(uv);\n    float c = dot(uv, normalize(vec2(1, 1.732))); \n    c=max(c, uv.x);\n    float d = atan(uv.x, uv.y);\n    \n    return c;\n}\n\nvec2 Polar(vec2 uv)\n{\n    return vec2 (length(uv), atan(uv.x, uv.y)+3.1415);\n}\n\nfloat N21(vec2 p)\n{\n    p=fract(p*vec2(233.34, 851.73));\n    p+=dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n=N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offs)\n{\n    vec2 n =N22(id+offs)*iTime;\n\n    return offs+sin(n)*.4;\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t=clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n    float d = DistLine(p,a,b);\n    float f = 1.-min(length(p-a), length(p-b));\n    float m= S(f*2., .2, d*20.);\n    m *=S(1.2, .8, length(a-b));\n    m *= f*f*f;\n    return m;\n}\n\nfloat Layer(vec2 uv)\n{\n    float m=0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n  \n    vec2 p[9];\n    int i=0;\n    for(int x=-1; x<2; x++)\n        for(int y=-1; y<2; y++)\n        {\n            p[i++] = GetPos(id, vec2(x,y));\n        }\n    for(int i=0; i<9; i++)\n    {\n        m+=Line(gv, p[4], p[i]);\n        \n        float j = length(vec2(p[i] - gv)*15.);\n        float spark =1. / dot(dot(j,j), j);\n        m+= spark * sin(iTime+id.x+id.y)*.5;\n    }\n    m+=Line(gv, p[1], p[3]);\n    m+=Line(gv, p[1], p[5]);\n    m+=Line(gv, p[7], p[3]);\n    m+=Line(gv, p[7], p[5]);\n    \n    return m;\n}\n\nvec3 Universe(vec2 uv, float m)\n{\n    if (m>0.) return vec3(0);\n    float t = iTime*.1;\n    mat2 rot = mat2(cos(t), -sin(t), sin(t), cos(t));\n    uv *=rot;\n    \n    for(float i=0.; i<1.; i+= 1./4.)\n    {\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n            \n        m+=Layer(uv*size+i*20.)*fade;\n    }\n    \n    vec3 base = sin(t*vec3(.3, .5, .7))*.2 +.6;\n    return vec3(m*base);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    //uv += iTime/10.;\n\tvec4 coord = Grid(uv, 20.);\n    vec2 st = coord.xy;\n    \n    // c= hex radius\n    float r = length(Hex(st));\n    float index = ((coord.w*3.) + (coord.z*3.))*.06;\n    float d = length(fragCoord - iResolution.xy/2.)/iResolution.y;\n    float r1 = smoothstep(.3+sin(iTime+d*3.)*.1,.4+sin(iTime+d*3.)*.1732 ,r);\n    float r2 = smoothstep(.27+sin(iTime+d*3.)*.1,.37+sin(iTime+d*3.)*.15 ,r);\n    \n    vec3 col = vec3(.0, .3, .4+(sin(iTime*.3+d)*.2))*(.5-r)*step(r1, .5);\n    if (r>r1 && r<r2) col+=vec3(.2);\n    \n    col +=Universe(uv, col.b);    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 70, 70, 313], [315, 315, 335, 335, 475], [477, 477, 498, 498, 555], [557, 557, 576, 576, 665], [667, 667, 685, 685, 737], [739, 739, 772, 772, 834], [836, 836, 876, 876, 994], [996, 996, 1032, 1032, 1209], [1211, 1211, 1233, 1233, 1811], [1813, 1813, 1846, 1846, 2271], [2273, 2273, 2330, 2330, 2992]], "test": "untested"}
{"id": "WdGSz3", "name": "wave sim", "author": "Nitato_", "description": "trying to simulate transverse/longitudinal waves in shadertoy\n\nfar from perfect and i'm sure many optimisations/modifications can be made to both make it cleaner/more efficient and more mathematically accurate\n\nsuggestions welcome", "tags": ["2d", "waves", "simulation"], "likes": 7, "viewed": 207, "published": "Public API", "date": "1574800201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Useful macro for time\n#define time iTime\n// Functions defining a circle, vertical line and horizontal line\nfloat circle (vec2 p, float r)\n{\n\treturn length(p) - r;\n}\nfloat vline (vec2 p) \n{\n\treturn abs(p.x);\n}\nfloat hline (vec2 p)\n{\n\treturn abs(p.y);\n}\n// Merge two objects (used for the circles)\nvec2 merge(vec2 d1, vec2 d2) {\n    return abs(d1).x<abs(d2.x) ? d1 : d2;\n}\n// Repeat function using fract\nvec4 cRep4(vec2 p, float n) \n{\n     vec2 pn = p * n;\n     return vec4(fract(pn) * 2.0 - 1.0, floor(pn)+vec2(1.0));\n}\n//\nfloat asLine(float d) {\n    return smoothstep(.1,.0,abs(d));\n}\n\nfloat asDisc(float d) {\n    return smoothstep(.2,.1,d);\n}\n// Do points of given cell\nvec2 doCell(vec2 local, vec2 cellCoord, vec2 cellOffset) \n{\n    vec2 l = local - cellOffset * 2.0; // adjusted local coords\n    vec2 id = cellCoord + cellOffset; // cell coordinates/id\n    float c = circle(l+vec2(sin(time*1.7+id.x*id.y*-.02)*id.y*.2, cos(time*1.7+id.x*id.y*-.02)*id.y*.2), .1);\n    return vec2(c, id.x*id.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv = Pixel normalised coordinates\n\tvec2 uv = (2.*fragCoord-iResolution.xy )/iResolution.y;\n    // Lines to form divisions between panels\n    float line1 = smoothstep(.01, .02, vline(uv));\n    float line2 = smoothstep(.01, .02, hline(uv));\n    \n    //Checking which area the current pixel is in and running the appropriate code for that panel\n    if (uv.x < 0. && uv.y < 0.) \n    {   \n        // Bottom left panel\n    \tuv = uv + vec2(.9, .51);\n    \t\n        // c1 is the large circle, c2 is the moving one\n    \tfloat c1 = smoothstep(.02, .001, abs(circle(uv, (.4))));\n    \tfloat c2 = smoothstep(.02, .01, circle(uv+vec2(sin(time*2.), cos(time*2.))*.4, (.05)));\n        \n        fragColor = vec4(vec3(c1+c2, .1, .1)*line1*line2, 1.0);\n    }\n    else if (uv.y > 0.)\n    {\t\n        // Top panel\n  \n        float surface = 13.;                     \n        vec4 cell = cRep4(uv, 15.);\n        vec2 dist = vec2(100.0,0);\n        // Looking at neighbouring and displaying dots leaking from other cells to prevent cutoff\n        if(cell.w<surface-2.) {\n            dist = merge(dist, doCell(cell.xy, cell.zw, vec2(-1,1)));\n            dist = merge(dist, doCell(cell.xy, cell.zw, vec2(1,1)));\n            dist = merge(dist, doCell(cell.xy, cell.zw, vec2(0,1)));\n        }\n        if(cell.w<surface-1.) {\n            dist = merge(dist, doCell(cell.xy, cell.zw, vec2(0.0)));\n            dist = merge(dist, doCell(cell.xy, cell.zw, vec2(1,0)));\n            dist = merge(dist, doCell(cell.xy, cell.zw, vec2(-1,0)));\n        }\n        if(cell.w<surface) {\n        \tdist = merge(dist, doCell(cell.xy, cell.zw, vec2(1,-1)));\n        \tdist = merge(dist, doCell(cell.xy, cell.zw, vec2(-1,-1)));\n        \tdist = merge(dist, doCell(cell.xy, cell.zw, vec2(0,-1)));\n        }\n            \n        \n        fragColor = vec4(vec3(asDisc(dist.x), .1, .1), 1.);//vec4(vec3(c3, .1, .1)*line2, 1.0);\n    }\n    else\n    { \t\n        // Bottom right panel\n     \t// Defining the plane waves, i.e. lines\n     \tfloat planewave = sin(uv.x*30.+iTime*10.)*.7+.3;\n    \n    \tfragColor = vec4(planewave*.7, .1, .1, 1.)*line1*line2;       \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 110, 142, 142, 167], [168, 168, 191, 191, 211], [212, 212, 234, 234, 254], [255, 299, 329, 329, 373], [374, 405, 435, 435, 521], [522, 525, 548, 548, 587], [589, 589, 612, 612, 646], [647, 674, 733, 733, 1001], [1002, 1002, 1059, 1100, 3173]], "test": "untested"}
{"id": "wdGSzt", "name": "Joker's cage", "author": "avin", "description": ">>> USE MOUSE <<<\n", "tags": ["infinity"], "likes": 9, "viewed": 441, "published": "Public API", "date": "1574717293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t\t3.14159265359\n\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\nvoid rotate(in float angle, inout vec2 uv)\n{    \n    float ca = cos(angle);\n    float sa = sin(angle);\n    uv *= mat2(ca, -sa, sa, ca);\t\n}\n\nfloat map(vec3 p) \n{\n    return length(mod(p, 2.0) - 1.0) - 1.375;\n}\n\nvec3 getNormal(vec3 p) \n{\n    float t = map(p);\n    vec2 d = vec2(.5, 0.0);\n    return normalize(vec3(t - map(p + d.xyy), t - map(p + d.yxy), t - map(p + d.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    \n    rotate(iTime*.5, uv);\n    \n    float tZ = (sin(iTime) * 0.25 + 0.5) * 0.75 + .25;\n\n    vec3 camDir = normalize(vec3(uv*5. , 1.1));\n        \n    // Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.2 + 0.2 * cos (iTime * 0.5));\n\tfloat pitchAngle = PI * (0.1 * cos (iTime * 0.3) - 0.05);\n\t\n\tyawAngle += 4.0 * PI * iMouse.x / iResolution.x;\n\tpitchAngle += PI * 0.3 * (1.0 - iMouse.y / iResolution.y);\n    \n    float cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n    \n    mat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tcamDir = cameraOrientation * camDir;\n    \n    vec3 camPos = vec3(1.0, 1. , - iTime * 3.);    \n    \n    float t = 0.0;\n    for(int i = 0 ; i < 100; i += 1) {\n        t += map(camDir * t + camPos);        \n    }\n    vec3 surf = camDir * t + camPos;    \n    vec3 light = normalize(vec3(0.0, 0.0, 1.0)) ;\n    vec3 normal = getNormal(surf);    \n    \n    float cg = (camDir * t).x + (camDir * t).y + (camDir * t).z;\n    \n    vec3 col = hue(cg*.05 - iTime * .2 ).rgb * clamp(dot(light, normal), .25, 1.);\n        \n    // Border dark\n    col *= 0.2 + 0.8 * pow(32.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.3);   \n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 152, 152, 246], [248, 248, 268, 268, 316], [318, 318, 343, 343, 483], [485, 485, 540, 540, 2112]], "test": "untested"}
{"id": "wdGSzW", "name": "Cute MandelBulb", "author": "sp4ghet", "description": "Simple Mandelbulb", "tags": ["mandelbulb"], "likes": 4, "viewed": 101, "published": "Public", "date": "1573516113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat map(vec3 p){\n  vec3 w = p;\n  float m = dot(w,w);\n\n  vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.;\n    \n    \n\tfor( int i=0; i<4; i++ )\n  {\n    float power = 3. + 5. * abs(cos(iTime));\n    dz = power*pow(sqrt(m),power-1.)*dz + 1.0;\n\t\t// dz = 8.0*pow(m,3.5)*dz + 1.0;\n    \n    float r = length(w);\n    float b = power*acos( w.y/r) + iTime * 5.;\n    float a = power*atan( w.x, w.z ) + iTime * 2.;\n    w = p + pow(r,power) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n    trap = min( trap, vec4(abs(w),m) );\n\n    m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n  }\n\n  return 0.25*log(m)*sqrt(m)/dz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 c = vec4(uv, 0.75, 1.0);\n\n    vec3 ro = vec3(0. , 0., cos(0.)) * 2.;\n    vec3 rd = vec3(uv, (1.-dot(uv,uv)));\n    rd = rotate(rd, 3.14159265, vec3(1., 0., 0.));\n\n    // t is total distance\n    // d is step distance\n    float i = 0., t = 0., d = 0.;\n    vec3 p;\n    // raymarching loop\n    for(i = 0.; i < 100.; i++){\n      p = ro + rd * t;\n      d = map(p);\n      t += d*.75;\n      if(d < 0.001 || d > 100.){break;}\n    }\n\t\n    vec4 blue = vec4(0.5411, 0.90196, 0.8745, 1.);\n    vec4 pink = vec4(1.0, 0.72156, 0.7686, 1.0);\n    \n    c = (1. - vec4(i / 150.)) * blue * 1.2;\n    if(d > 100.) { c =  pink; }\n\n    fragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 474], [476, 476, 494, 494, 1081], [1083, 1083, 1137, 1137, 1874]], "test": "untested"}
{"id": "WdGXDm", "name": "don - Revolver SDF 2D", "author": "koktszfung", "description": "I tried to make an SDF for a revolver in 2D.\nThe code is very messy but the result is pretty cool XD.\nRay marching code written by hughsk (https://www.shadertoy.com/view/XsyGRW).", "tags": ["raymarching", "sdf"], "likes": 8, "viewed": 123, "published": "Public", "date": "1574226525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n*\tray marching tools adapted from hughsk's 2D SDF Toy https://www.shadertoy.com/view/XsyGRW\n*/\n\n#define TRACE_STEPS 20\n#define TRACE_RAY\n\n// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n// 3 = Distance Field Polarity\n#define DISPLAY 0\n\n// 0 = Angle controlled By iTime\n// 1 = Angle controlled By iMouse\n#define MOUSE 0\nconst float PI = 3.14159265359;\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n    vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n    position.x *= screenSize.x / screenSize.y;\n    return position;\n}\n\n// translational symmetry\nvec2 tsym(vec2 p, float m) {\n    return mod(p + m*.5, m) - m*.5;\n}\n\nfloat tsym(float p, float m) {\n    return mod(p + m*.5, m) - m*.5;\n}\n\n// rotational symmetry\nvec2 rsym(vec2 p, float n){\n\tfloat pr = length(p);\n    float pa = atan(p.y, p.x);\n    pa = tsym(pa, 2.*PI/n);\n    p = vec2(pr*cos(pa), pr*sin(pa));\n    return p;\n}\n\nvec2 rotate(vec2 p, float a) {\n    return vec2(p.x*cos(a) - p.y*sin(a),\n                p.x*sin(a) + p.y*cos(a));   \n}\n\nfloat add(float a, float b) {\n    return min(a, b);\n}\n\nfloat sub(float a, float b) {\n\treturn max(a, -b);\n}\n\n\n\nfloat shape_circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat shape_rect(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) +  min(max(d.x, d.y), 0.0);  // out + in\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n    vec2 dir = b - a;\n    return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat shape_trapezoid(vec2 p, float r1, float r2, float he ) {\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2, k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\n\n\nfloat shape_revolver_base(vec2 p) {\n    return shape_trapezoid(p + vec2(0, .5), .15, .1, .8) - .05;\n}\n\nfloat shape_revolver_cylinder_fill(vec2 p) {\n    vec2 p1 = rotate(p, iTime);\n    return shape_circle(p1, .4);\n}\n\nfloat shape_revolver_cylinder_cut(vec2 p) {\n    float cbig = shape_circle(p, .4);\n    float cmid  = shape_circle(p, .03);\n    \n    vec2 p11 = abs(rsym(rotate(p, PI/6.), 6.)) - vec2(.25, 0);\n    float cin  = shape_circle(p11, .075);\n    \n    vec2 p12 = abs(rsym(p, 6.)) - vec2(.4, 0);\n    float cout = shape_circle(p12, .075);\n\t\n    return sub(add(add(cmid, cin), cout), -cbig-.03);\n}\n\nfloat shape_revolver_barrel(vec2 p) {\n    p.x = abs(p.x);\n    float rect1 = shape_rect(p - vec2(0, .45), vec2(.04, .06)) - .01;\n    float rect2 = shape_rect(p - vec2(.08, .42), vec2(.04, .04)) - .01;\n\tfloat circle = abs(shape_circle(p - vec2(0, 0.25), 0.15)) - .025;\n    return add(sub(add(rect1, rect2), circle), circle);\n}\n\nfloat shape_revolver_frame(vec2 p) {\n    float rect = shape_rect(p+vec2(0, .25), vec2(.06, .2));\n    float circle = shape_circle(p, .1);\n\treturn add(rect, circle) - .025;\n}\n\nfloat shape_revolver_trigger(vec2 p) {\n    float rect1 = shape_rect(p+vec2(0, .55), vec2(.06, .05));\n    float trap = shape_trapezoid(p+vec2(0, .7), .03, .06, .08);\n    return add(trap, rect1) - .025;\n}\n\nfloat SAMPLER(vec2 p) {\n    float scale = .8;\n    p.y -= .25;\n    \n    p /= scale;\n    \n    vec2 p1, p2;\n    float time = mod(iTime/PI, 2.);\n    if (time > 1.){\n        p1 = rotate(p + vec2(0, .4), abs(sin(iTime))*PI*.25) - vec2(0, .4);\n        p2 = rotate(p1, iTime);\n    }else{\n        if (time > .11 && time < .2 && length(p - vec2(0, .25)) < pow(time, 2.)*120.) return 0.;\n        p.y -= (time > .1)? exp(-time*5.)*.75 : 0.;\n        p1 = p;\n        p2 = p;\n    }\n    \n    float cylinder_back = shape_circle(p, .425);\n    float cylinder_cut = shape_revolver_cylinder_cut(p2);\n    float cylinder_fill = shape_revolver_cylinder_fill(p2);\n    float base = shape_revolver_base(p);\n    float s1 = sub(add(add(cylinder_fill, cylinder_back), base), cylinder_cut);\n    \n    float trigger = shape_revolver_trigger(p);\n    float s2 = add(sub(s1, trigger - .025), trigger);\n    \n    float frame_still = shape_revolver_frame(p);\n    float frame_move = shape_revolver_frame(p1/.9)*.9;\n    float s3 = add(sub(s2, frame_move - .025), frame_move);\n    float s4 = add(sub(s3, frame_still - .025), frame_still);\n\n    \n    float barrel = shape_revolver_barrel(p);\n    float s5 = add(sub(s4, barrel - .025), barrel);\n    \n\n    return s5*scale;\n}\n\n\nvec3 draw_line(float d, float thickness) {\n    const float aa = 3.0;\n    return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n    return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n    return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n    p += iTime * -0.1 * sign(d) * vec2(0, 1);\n    p = mod(p + 0.06125, 0.125) - 0.06125;\n    float s = sign(d) * 0.5 + 0.5;\n    float base = draw_solid(d);\n    float neg = shape_rect(p, vec2(0.045, 0.0085) * 0.5);\n    float pos = shape_rect(p, vec2(0.0085, 0.045) * 0.5);\n    pos = min(pos, neg);\n    float pol = mix(neg, pos, s);\n\n    float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n    return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n    float t = clamp(d * 0.85, 0.0, 1.0);\n    vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n    float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n    float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n    float d2 = abs(1.0 - draw_line(d).x);\n    vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n    grad -= rim;\n    grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n    return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {\n    vec3 col = vec3(0);\n    vec3 line = vec3(1, 1, 1);\n    vec2 _ro = ro;\n\n    for (int i = 0; i < TRACE_STEPS; i++) {\n        float t = SAMPLER(ro);\n        col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n        col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n        col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n        ro += rd * t;\n        if (t < 0.01) break;\n    }\n\n    #ifdef TRACE_RAY\n    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);\n    #endif\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime * 0.5;\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    float d;\n    vec3 col;\n    vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n    vec2 rd = normalize(-ro);\n\n    d = SAMPLER(uv);\n\n    #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n    #if MOUSE == 0\n    col -= (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    #endif\n    #endif\n    #if DISPLAY == 1\n    col = vec3(0) + 1.0 - vec3(draw_line(d));\n    #if MOUSE == 0\n    col += (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(1, 0.25, 0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    #endif\n    col = 1. - col;\n    #endif\n    #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n    #endif\n    #if DISPLAY == 3\n    col = vec3(draw_polarity(d, uv.xy));\n    #endif\n\n    fragColor.rgb = col;\n    fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 385, 424, 424, 527], [529, 529, 576, 576, 706], [708, 734, 762, 762, 800], [802, 802, 832, 832, 870], [872, 895, 922, 922, 1058], [1060, 1060, 1090, 1090, 1178], [1180, 1180, 1209, 1209, 1233], [1235, 1235, 1264, 1264, 1286], [1290, 1290, 1327, 1327, 1355], [1357, 1357, 1391, 1391, 1490], [1492, 1492, 1534, 1534, 1618], [1620, 1620, 1665, 1665, 1784], [1786, 1864, 1926, 1926, 2245], [2249, 2249, 2284, 2284, 2350], [2352, 2352, 2396, 2396, 2463], [2465, 2465, 2508, 2508, 2848], [2850, 2850, 2887, 2887, 3174], [3176, 3176, 3212, 3212, 3348], [3350, 3350, 3388, 3388, 3552], [3554, 3554, 3577, 3577, 4782], [4785, 4785, 4827, 4827, 4939], [4941, 4941, 4966, 4966, 5001], [5003, 5003, 5030, 5030, 5094], [5096, 5096, 5133, 5133, 5551], [5553, 5553, 5590, 5590, 6041], [6043, 6043, 6095, 6095, 6651], [6653, 6653, 6708, 6708, 7584]], "test": "untested"}
{"id": "wdGXDw", "name": "Desert Postcard", "author": "dr2", "description": "Wobbly blob in a (pseudo-)Nabatean treasury, with some dynamic trompe-l'oeil (mousing recommended)", "tags": ["illusion", "surface", "architecture", "sand"], "likes": 13, "viewed": 312, "published": "Public API", "date": "1574160705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Desert Postcard\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 bSize, sunDir, vnBlk;\nvec2 blbRad;\nfloat tCur, dstFar;\nint idObj;\nbool isSh;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  for (int k = 0; k < 5; k ++) {\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.8;\n  }\n  return p;\n}\n\nfloat BlobDf (vec3 p)\n{\n  vec3 q;\n  float d, t;\n  t = tCur + 1.31;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.2 * t);\n  d = SmoothMin (PrBoxDf (SMap (q - vec3 (0.7, -0.3, 0.), t + 2.), vec3 (blbRad.x)),\n     PrBoxDf (SMap (q - vec3 (-0.7, -0.3, 0.), 1.3 * t), vec3 (blbRad.y)), 0.2);\n  q = p;\n  q.y -= -2.6;\n  d = SmoothMin (d, PrCylDf (q.xzy, 2.7, 0.2), 0.5);\n  return d * (isSh ? 1. : 0.25);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cs, b, s;\n  float dMin, d, g, w;\n  dMin = dstFar;\n  cs = sin (pi / 8. + vec2 (0., 0.5 * pi));\n  w = 0.06;\n  q = p;\n  q.y -= 7.3;\n  g = dot (vec2 (abs (q.x), q.y), cs);\n  d = min (max (min (abs (g) - w, 0.), - q.y - 1.5),\n     max (min (abs (q.y + 1.525) - w, 0.), g - w));\n  q.y -= -0.25;\n  g = dot (vec2 (abs (q.x), q.y), cs);\n  d = min (d, min (max (min (abs (g) - w, 0.), - q.y - 1.),\n     max (min (abs (q.y + 1.025) - w, 0.), g - w)));\n  b = vec2 (4., 2.5);\n  q = p;\n  q.y -= 3.;\n  s = abs (q.xy) - b;\n  d = min (d, min (max  (min (s.y - w, 0.), min (abs (s.x) - w, 0.)),\n     max  (min (s.x - w, 0.), min (abs (s.y) - w, 0.))));\n  q = p;\n  q.yz -= vec2 (4., bSize.z);\n  d = max (PrBoxDf (q - vec3 (0., 0., -0.2), bSize), - d);\n  q.y -= -1.;\n  d = max (d, - PrBox2Df (q.xy, b - 3. * w));\n  q.y -= -2.3;\n  d = max (d, - PrCylDf (q.xzy, 2.7, 0.1));\n  DMIN (1);\n  q = p;\n  q.y -= 4.;\n  d = PrBoxDf (q, vec3 (bSize.xy - 0.05, 0.1));\n  q.y -= -1.;\n  d = max (d, - PrBox2Df (q.xy, b - 3. * w + 0.05));\n  DMIN (2);\n  q = p;\n  q.y -= 3.;\n  g = abs (q.x) - b.x;\n  q.xz = vec2 (mod (q.x + 0.75, 1.5) - 0.75, abs (q.z - bSize.z) - bSize.z + 0.3);\n  d = PrCylDf (q.xzy, 0.2, b.y - 4. * w);\n  q.y = abs (q.y) - b.y + 4. * w;\n  d = max (min (d, PrCylDf (q.xzy, 0.275, w)), g);\n  DMIN (3);  \n  q = p;\n  q.yz -= vec2 (3., bSize.z);\n  if (! isSh) d = PrBoxDf (q, vec3 (b - 3. * w, bSize.z)) + 0.1;\n  if (isSh || d < dMin) {\n    d = BlobDf (q);\n    DMIN (4);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  vec2 vf, s;\n  float dstObj, dstGrnd, db, sh, f;\n  bool isBg;\n  isBg = true;\n  sh = 1.;\n  roo = ro;\n  bSize = vec3 (7., 4., 3.75);\n  db = BlkHit (ro + vec3 (0., - bSize.y, 0.1), rd, vec3 (bSize.xy, 0.05));\n  if (db < dstFar) {\n    vf = vec2 (0.);\n    if (vnBlk.z < -0.99) {\n      blbRad = vec2 (1.1 + 0.31 * sin (tCur + 1.31), 1. + 0.41 * sin (1.7 * (tCur + 1.31)));\n      isSh = false;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        if (idObj == 1) {\n          if (vn.y > 0.99 && length (ro.xz- vec2 (0., bSize.z)) < 2.7) {\n            col4 = vec4 (0.6, 0.7, 0.1, 0.2);\n          } else {\n            col4 = vec4 (0.4, 0.25, 0.15, 0.);\n            if (vn.z < -0.99) vf = vec2 (8., 2.);\n            else vf = vec2 (16., 1.);\n          }\n        } else if (idObj == 2) {\n          col4 = vec4 (0.7, 0.5, 0.2, 0.3);\n        } else if (idObj == 3) {\n          col4 = vec4 (0.6, 0.4, 0.2, 0.3);\n          s = vec2 (mod (ro.x + 0.75, 1.5) - 0.75, abs (ro.z - bSize.z) - bSize.z + 0.3);\n          vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * (0.5 -\n             mod (16. * (atan (s.x, s.y) / (2. * pi) + 0.5), 1.))));\n        } else if (idObj == 4) {\n          col4 = vec4 (mix (vec3 (0.6, 0.7, 0.1), vec3 (0.9, 0.2, 0.1),\n             smoothstep (0.7, 4.5, ro.y)), 0.3);\n        }\n        if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n        isSh = true;\n        isBg = false;\n      } else if (rd.y < 0.) {\n        dstObj = - ro.y / rd.y;\n        if (dstObj < dstFar) {\n          ro += dstObj * rd;\n          isSh = true;\n        }\n      }\n      sh = (isSh) ? ObjSShadow (ro + 0.01 * sunDir, sunDir) : 1.;\n      if (! isBg) col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else {\n      ro += db * rd;\n      vn = vnBlk;\n      vn.z *= -1.;\n      if (vn.z > -0.99) {\n        col4 = vec4 (0.4, 0.25, 0.15, 0.);\n        vf = vec2 (32., 2.);\n      } else {\n        f = 0.;\n        if (abs (ro.y - bSize.y) < bSize.y - 0.5) f = abs (ro.x);\n        if (abs (ro.x + 0.5 * bSize.x) < 0.5 * bSize.x - 1.) \n           f = abs (abs (ro.y - 0.7 * bSize.y) - 0.5);\n        s = abs (ro.xy - bSize.xy * vec2 (-0.8, 1.6)) - 0.7;\n        if (max (s.x, s.y) < 0.02) f = min (abs (s.x), abs (s.y));\n        col4 = vec4 (0.7, 0.7, 0.65, 0.1);\n        if (f > 0.) col4 *= 0.5 + 0.5 * smoothstep (0.01, 0.02, f);\n        vf = vec2 (64., 0.5);\n      }\n      vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      isBg = false;\n    }\n  }\n  if (isBg) {\n    if (rd.y < 0.) {\n      ro = roo;\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      f = 1. - smoothstep (0.3, 0.5, dstGrnd / dstFar);\n      if (f > 0.) vn = VaryNf (4. * ro, RippleNorm (ro.xz, vn, 6. * f), f);\n      col = mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.2 +\n         0.6 * smoothstep (0.7, 1.1, 2. * Fbm2 (2. * ro.xz)));\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n      col *= 0.7 + 0.3 * smoothstep (length (vec2 (max (abs (ro.x) - bSize.x, 0.),\n         max (abs (ro.z + 0.1) - 0.05, 0.))), 0., 0.05);\n    } else col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.015 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  }\n  az += 0.7 * pi * (2. * mod (floor (0.06 * tCur), 2.) - 1.) *\n     SmoothBump (0.3, 0.7, 0.15, mod (0.06 * tCur, 1.));\n  el = clamp (el, -0.4 * pi, 0.02 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 3.5, -25.);\n  zmFac = 4.5;\n  dstFar = 100.;\n  sunDir = normalize (vec3 (0., 0., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.2 * pi * sin (0.05 * 2. * pi * tCur));\n  sunDir.yz = Rot2D (sunDir.yz, pi * (0.22 + 0.07 * sin (0.03 * 2. * pi * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGXDw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 724, 753, 753, 885], [887, 887, 910, 910, 1272], [1274, 1274, 1296, 1296, 2807], [2809, 2809, 2842, 2842, 3019], [3021, 3021, 3042, 3042, 3237], [3239, 3239, 3276, 3276, 3510], [3512, 3512, 3554, 3554, 3841], [3843, 3843, 3868, 3868, 4247], [4249, 4249, 4293, 4293, 4482], [4484, 4484, 4518, 4518, 5110], [5112, 5112, 5147, 5147, 8653], [8655, 8655, 8711, 8711, 10140], [10142, 10142, 10174, 10174, 10274], [10276, 10276, 10309, 10309, 10398], [10400, 10400, 10442, 10442, 10493], [10495, 10495, 10517, 10517, 10555], [10557, 10557, 10579, 10579, 10617], [10619, 10619, 10664, 10664, 10767], [10769, 10769, 10826, 10826, 10909], [10911, 10911, 10941, 10941, 11054], [11088, 11088, 11112, 11112, 11165], [11167, 11167, 11191, 11191, 11321], [11323, 11323, 11348, 11348, 11494], [11496, 11496, 11521, 11521, 11707], [11709, 11709, 11731, 11731, 11885], [11887, 11887, 11908, 11908, 12063], [12065, 12065, 12094, 12094, 12306], [12308, 12308, 12347, 12347, 12532]], "test": "untested"}
{"id": "WdGXRc", "name": "Jumper", "author": "giezu", "description": "Visualisation based on capsule - JUMPER music video.\n\nTwitter: @kmgiezu\n\ncapsule - JUMPER\nhttps://www.youtube.com/watch?v=_nUbhbEp65s", "tags": ["sdf", "edm", "cineshader"], "likes": 3, "viewed": 5191, "published": "Public API", "date": "1574545265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat dLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    float d = dLine(p, a, b);\n    float m = S(.03, .01, d);\n    return m;\n}\n\nfloat dCross(vec2 p, vec2 b)\n{\n    const vec2 r = vec2(1.0, 0.0);\n    const vec2 u = vec2(0.0, 1.0);\n    vec2 bu = b * u;\n    vec2 br = b * r;\n\n    float m = line(p, -br, br);\n    m += line(p, -bu, bu);\n    return m;\n}\n\nfloat dCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat dBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p * vec2(233.34, 851.734));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id) * iTime;\n    return sin(n)*.15;\n}\n\nfloat CrossLayer(vec2 uv)\n{\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    float m = 0.;\n\n    float t = iTime * 0.25;\n    vec2 crossSize = vec2(0.125);\n    crossSize *= sin(t) * 0.5 + 1.5;\n\n    m += dCross(gv+GetPos(id), crossSize);\n    m = min(m, -dBox(uv, vec2(6.0)));\n\n    m = S(0.002, 0.0, m);\n    m = 1.0 - m;\n\n    return m;\n}\n\nfloat CircleLayer(vec2 uv)\n{\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    float m = 0.;\n\n    float t = iTime * 0.25;\n    float r = 0.125;\n    r *= sin(t) * 0.5 + 1.5;\n\n    m += abs(dCircle(gv+GetPos(id), r)) - 0.025;\n    m = max(m, dBox(uv, vec2(24.0)));\n\n    m = S(0.002, 0.0, m);\n\n    return m;\n}\n\nfloat SquareLayer(vec2 uv)\n{\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    float m = 0.;\n\n    float t = iTime * 0.25;\n    float r = 0.125;\n    r *= sin(t) * 0.5 + 1.5;\n\n    m += abs(dBox(gv+GetPos(id), vec2(r))) - 0.025;\n    m = max(m, dBox(uv, vec2(24.0)));\n\n    m = S(0.002, 0.0, m);\n\n    return m;\n}\n\nvec3 Background(vec2 p)\n{\n    return vec3(0.5, 0.5, sin(iTime * 0.5) * 0.1 + 0.5) * (0.7 - p.y * p.x);\n}\n\nmat2 GetRot(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 bg = Background(uv);\n\n    float m = 0.0;\n    \n\tvec3 color1 = vec3(1., 1., 0.);\n\tvec3 color2 = vec3(1., 0., 1.);\n\tvec3 color3 = vec3(0., .6, 1.);\n\n\n    // Cross layers\n\n    const int numCross = 3;\n\n    float speeds[numCross];\n    speeds[0] = 0.2;\n    speeds[1] = 0.2;\n    speeds[2] = 0.2;\n\n    float scales[numCross];\n    scales[0] = 3.0;\n    scales[1] = 5.0;\n    scales[2] = 9.0;\n\n    vec3 colors[numCross];\n    colors[0] = color1;\n    colors[1] = color2;\n    colors[2] = color3;\n\n    vec2 positions[numCross];\n    positions[0] = vec2(0.0, 0.0);\n    positions[1] = vec2(0.25, 0.1);\n    positions[2] = vec2(-0.3, -0.2);\n\n    float t = 0.0;\n    int i = 0;\n    float z = 0.0;\n    float fade = 0.0;\n    for (i = 0; i < numCross; ++i)\n    {\n        t = iTime * speeds[i];\n\n        z = fract(float(i) * 0.1 + t);\n        fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n\n        uv *= GetRot(t);\n        uv += positions[i];\n        m += CrossLayer(uv * scales[i]) * fade;\n        if (fragColor.rgb == vec3(0.0))\n            fragColor.rgb += m * colors[i];\n    }\n\n    uv -= vec2(-0.05, -0.1);\n    t = iTime * 0.05;\n    z = fract(float(i) * 0.1 +t);\n    fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n    uv *= GetRot(t);\n    m += CircleLayer(uv * 20.0) * fade;\n    if (fragColor.rgb == vec3(0.0))\n        fragColor.rgb += m * vec3(1.0);\n\n    t = iTime * 0.2;\n    z = fract(float(i) * 0.1 +t);\n    fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n    t = iTime * 0.5;\n    uv *= GetRot(-t);\n    m += SquareLayer(uv * 16.0) * fade;\n    if (fragColor.rgb == vec3(0.0))\n        fragColor.rgb += m * vec3(1.0, 1.0, 1.0);\n\n    // BG\n    if (fragColor.rgb == vec3(0.0))\n        fragColor.rgb += bg;\n\n    fragColor.rgb = sqrt(fragColor.rgb);\n\n    //imageStore(imgOut, ivec2(gl_GlobalInvocationID.xy), col);\n}", "image_inputs": [{"id": "MtXGDl", "previewfilepath": "https://soundcloud.com/maslyastar/capsule-jumper", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/maslyastar/capsule-jumper", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 77, 77, 201], [203, 203, 239, 239, 315], [317, 317, 347, 347, 535], [537, 537, 569, 569, 597], [599, 599, 627, 627, 711], [713, 713, 732, 732, 833], [835, 835, 853, 853, 907], [909, 909, 931, 931, 986], [988, 988, 1015, 1015, 1329], [1331, 1331, 1359, 1359, 1641], [1643, 1643, 1671, 1671, 1956], [1958, 1958, 1983, 1983, 2062], [2064, 2064, 2086, 2086, 2162], [2164, 2164, 2221, 2221, 4064]], "test": "untested"}
{"id": "WdGXRW", "name": "Five Sides Should Be Enough", "author": "blackle", "description": "animated version of my freestyle graphics entry for demosplash. programmed in bonzomatic in 15 minutes while waiting for my flight from toronto. set ANIMATED to 0 to see the compo version.", "tags": ["hexagon", "demosplash"], "likes": 1, "viewed": 293, "published": "Public API", "date": "1573481696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define ANIMATED 1\n\n#if ANIMATED\n#define time (iTime/3.+12.6)\n#else\n#define time 16.\n#endif\n\nvec4 plas( vec2 v, float t )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( t + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(t)), c * 0.15, cos( c * 0.1 + t / .4 ) * .25, 1.0 );\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash (vec2 p) {\n  int x = FK(p.x);int y = FK(p.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat hash1(float k){\n  return hash(vec2(k,cos(k)+1.));\n}\n\nvec3 hash3(float k) {\n  float rnd = hash1(k);\n  return vec3(hash1(rnd*2.),hash1(rnd*3.),hash1(rnd*4.));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat comp (vec3 p , vec3 off, vec3 ro) {\n  float ph = acos(ro.x);\n  float th = ro.y*3.1415;\n  vec3 ax = vec3(cos(ph),sin(ph)*cos(th), sin(ph)*sin(th));\n  p+=off;\n  p = erot(p, ax, ro.z*3.1415);\n  p = fract(p)-0.5;\n  return length(p)-pow(1./(3.1415*2.),1./3.);\n}\n\nfloat scene(vec3 p) {\n  float dt = 0.;\n  float cc = 0.;\n  for (int i = 0; i < 5; i++ ) {\n    vec3 off = hash3(float(i));\n    vec3 ro = hash3(cos(float(i)));\n    dt += comp(p, off, ro);\n    cc+=1.;\n  }\n  return dt/sqrt(cc*2.);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat bpm = 22.*6.;\n\nfloat hockey(float y) {\n return 0.5*(y+sqrt(4.+y*y)); \n}\n\nfloat pentafriend(vec2 uv) {\n  float dt = 10000.;\n  for (int i = 0; i < 5; i++ ) {\n    float ag = 3.1415/5.*2.*float(i) + floor(time/60.*bpm)*3.1415/10.;\n    float off = 3.1415/5.*2.;\n    vec2 a = vec2(sin(ag),cos(ag));\n    vec2 b = vec2(sin(ag+off),cos(ag+off));\n    dt = min(dt, linedist(uv*3., a, b));\n  }\n  return smoothstep(0.08,0.09,dt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float dt = pentafriend(uv);\n\n  vec3 cam = normalize(vec3(0.4, uv));\n  float sift = time/4.;\n  float srt = 2.;\n  vec3 init = vec3(-4.+time,cos(sift)*srt,sin(sift)*srt);\n  vec3 p = init;\n  float k = 1.;\n  for (int i =0;i< 15; i++) {\n    float dist = scene(p);\n    if(i == 0) k = sign(dist);\n    dist*=k;\n    //dist = hockey(dist)*2;\n    //if (abs(dist)<0.001) break;\n    if (distance(p, init) > 100.) break;\n    p += cam*dist;\n  }\n  float c = length(sin(p)*0.5+0.5)/sqrt(3.);\n  float d = exp(-distance(p,init))/exp(0.);\n  vec3 c1 = vec3(0.3,0.1,0.9);\n  vec3 c2 = vec3(0.9,0.2,0.1);\n  fragColor.xyz = sqrt(c1*c1*c + c2*c2*d) + hash(uv*time)*0.05;\n  \n  fragColor = sqrt(mix(pow(1.-fragColor, vec4(2.)), pow(fragColor, vec4(2.)), dt));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGXRW.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 287, 317, 317, 473], [530, 530, 551, 551, 630], [632, 632, 653, 653, 689], [691, 691, 712, 712, 796], [798, 798, 836, 836, 898], [900, 900, 941, 941, 1162], [1164, 1164, 1185, 1185, 1391], [1393, 1393, 1433, 1433, 1521], [1544, 1544, 1567, 1567, 1600], [1602, 1602, 1630, 1630, 1947], [1949, 1949, 2006, 2006, 2881]], "test": "untested"}
{"id": "WdKSD1", "name": "Doodling with h0ffman", "author": "Flopine", "description": "H0ffman did an AWESOME youtube live dj set on Amiga here: https://youtu.be/zVF-GbGHxA8?t=3220\nSo inspiring I wrote a shader along it :) thank you <3 ", "tags": ["raymarching", "improvisation"], "likes": 7, "viewed": 290, "published": "Public", "date": "1573929193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// H0ffman did an AWESOME youtube live DJ set on Amiga here: \n// https://youtu.be/zVF-GbGHxA8?t=3220\n// So inspiring I wrote a shader along it :) thank you <3 \n\n#define PI 3.141592\n#define time iTime*5.\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(12.4,16.1)))*1245.1);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\nfloat sc(vec3 p, float s) \n{\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x, min(p.y, p.z)) - s;\n}\n\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat room (vec3 p)\n{\n    float b = -box(p,vec3(6.,3.,1e10));\n    float per = 3.;\n    p.x = abs(p.x)-5.;\n    p.z = mod(p.z,per)-per*0.5;\n    \n    return stmin(b, cyl(p.xzy, 0.6,15.),0.5,3.);\n}\n\nfloat prim1 (vec3 p)\n{\n    p.xy *= rot(tan(p.z+time)*0.05);\n    p.xz *= rot(sin(p.y+time));\n    moda(p.xz, 5.);\n    p.x -= 0.2;\n    return cyl(p.xzy,0.1,15.);\n}\n\nfloat prim2 (vec3 p)\n{\n    float size = 0.5;\n    return max(-sc(p,size), box(p,vec3(size+0.02)));\n}\n\nfloat g1 = 0.;\nfloat fractal(vec3 p)\n{\n    p.xy *= rot(tan(p.z+time)*0.2);\n    mo(p.xz, vec2(.2));\n    p.xz *= rot(time*0.5);\n    mo(p.xy, vec2(.5));\n    p.xy *= rot(sin(p.z*0.5));\n\n    p.x -=.5;\n    float d =  prim2(p);\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\nfloat wave (vec3 p)\n{\n    float per = 5.;\n    p.xy *= rot(p.z*0.2);\n    p.x = abs(p.x)-2.;\n\n    p.z = mod(p.z,per)-per*0.5;\n    return prim1(p);\n}\n\n\nfloat SDF (vec3 p)\n{\n    p.xy *= rot(p.z*0.1);\n    float d = stmin(wave(p),room(p),.5,5.);\n    d = min(d, fractal(p-vec3(0.,0.,time)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.001,0.001,-5.+time),\n        p = ro,\n        rd = normalize(vec3(uv,1)),\n        col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/100.;\n            break;\n        }\n        d *= 0.8 +dither*0.1;\n        p += d*rd;\n    }\n\n    float t = length(ro-p);\n    col = vec3(shad);\n\n    col += g1*vec3(0.5,length(uv),0.1)*0.8;\n\n    col = mix(col, vec3(0.2), 1.-exp(-0.002*t*t));\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 517, 539, 539, 589], [591, 591, 641, 641, 744], [746, 746, 766, 766, 809], [811, 811, 847, 847, 991], [993, 993, 1025, 1025, 1072], [1074, 1074, 1102, 1102, 1190], [1192, 1192, 1220, 1220, 1301], [1304, 1304, 1342, 1342, 1381], [1383, 1383, 1404, 1404, 1575], [1577, 1577, 1599, 1599, 1737], [1739, 1739, 1761, 1761, 1838], [1855, 1855, 1878, 1878, 2103], [2105, 2105, 2126, 2126, 2251], [2254, 2254, 2274, 2274, 2405], [2407, 2407, 2464, 2464, 3169]], "test": "untested"}
{"id": "wdKSDm", "name": "ZzArt demo (2)", "author": "jarble", "description": "This is another animation based on a ZzArt shader.", "tags": ["generative"], "likes": 1, "viewed": 220, "published": "Public API", "date": "1574215852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ZzArt - Generation: 23 (870289856)\n\nconst float PI=3.141592653589793;\nvec3 CosinePalette( float t, vec3 a, vec3 b, vec3 c, vec3 d ) { return a + b*cos( PI*2.*(c*t+d)); }\nvec4 lengthA(vec4 a)      { return vec4(length(a)); }\nvec4 asinA(vec4 a)        { return asin(clamp(a,-1.,1.)); }\nvec4 acosA(vec4 a)        { return acos(clamp(a,-1.,1.)); }\nvec4 logA(vec4 a)         { return log(abs(a)); }\nvec4 log2A(vec4 a)        { return log2(abs(a)); }\nvec4 sqrtA(vec4 a)        { return sqrt(abs(a)); }\nvec4 inversesqrtA(vec4 a) { return inversesqrt(abs(a)); }\nvec4 pow2(vec4 a)         { return a*a; }\nvec4 pow3(vec4 a)         { return a*a*a; }\n\nvoid mainImage(out vec4 a, in vec2 p)\n{\na=p.yxyx/iResolution.yxyx;\na.xy *= vec2(-3.645, -2.707);\na.xy += vec2(4.093, -5.479);\na.wz *= vec2(-3.645, -2.707);\na.wz += vec2(4.093, -5.479);\nvec4 b = a;\n\n// Generated Code - Line Count: 12\nfor (int i = 0; i < 2; ++i)\n{\nb.wzyx /= atan(vec4(-2.749, 4.616, -7.395, -0.165)).wzzy;\nb.xzwy -= (b).zyzw-sin(iTime);\nb.xzwy /= logA(vec4(0.069, -0.068, -3.404, 0.082)).ywyz-cos(iTime);;\na.yxzw += exp(vec4(0.298, 3.602, -0.079, -0.003)).xxzw;\nb.wyxz += sin(b).wzxw;\na.wzyx += (b).zwxz;\nb.yzxw += (vec4(-1.533, -2.509, -1.082, 7.806)).xzww;\na.ywzx = exp2(a).xwxx;\nb.wzyx *= (b).ywyz;\nb.wyzx = (b).xzxz;\na.wyzx *= exp2(b).xyxy;\na.wyxz -= (b).xwxz;\n}\n\n// Cosine palettes by iq\na.x = a.x * -0.092+0.891;\na.xyz = b.x * CosinePalette(a.x,\n vec3(0.465, 0.472, 0.162),\n vec3(0.757, 0.723, 0.165),\n vec3(0.101, 0.660, 0.966),\n vec3(0.683, 0.408, 0.702));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 136, 136, 172], [173, 173, 200, 200, 226], [227, 227, 254, 254, 286], [287, 287, 314, 314, 346], [347, 347, 374, 374, 396], [397, 397, 424, 424, 447], [448, 448, 475, 475, 498], [499, 499, 526, 526, 556], [557, 557, 584, 584, 598], [599, 599, 626, 626, 642], [644, 644, 683, 683, 1525]], "test": "untested"}
{"id": "WdKSDR", "name": " εξάγωνο", "author": "blauwmaan", "description": "hexagonal fun built up on art of code", "tags": ["hexagon"], "likes": 3, "viewed": 255, "published": "Public API", "date": "1573774394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat MaxDistance (vec2 p) {\n\tp = abs(p);\n    \n       \n    float c = dot(p, normalize(vec2(1, 1.73)));\n    c = max(c, p.x); \n    \n    return c;\n\n}\n\nvec4 hexaCoords (vec2 uv) {\n\n   vec2 r = vec2(1., 1.73);\n    vec2 h= r*.5;\n    vec2 a = mod(uv, r)-h;\n    \n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv;\n        \n    if(length(a)<length(b))\n    \tgv = a;\n    else \n    \tgv = b;\n    \n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-MaxDistance(gv);\n    \n    vec2 id = uv-gv;\n    return vec4(x, y, id.x, id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n \n    \n    vec3 col = vec3 (cos(t), sin(t)*1., 0);\n    \n \tuv *= 5.;\n    \n \n    \n   vec4 coords = hexaCoords(uv);\n   \n   float grid = smoothstep(.05, sin(t), coords.y*sin(coords.z*coords.w+t)); \n    col += grid; \n// col.rg = hexaCoords(uv*sin(t)).xy;\n \n//    float c = sin(MaxDistance(uv)*10.+t);\n   \n // col += sin(t)*smoothstep(c*sin(5.*t), .2, 0.1*tan(.5*t));\n      \n  \n       \n   \n    col += Circle(uv, coords.zw, sin(t)*0.1, 0.01);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 141], [143, 143, 171, 171, 289], [291, 291, 318, 318, 656], [658, 658, 715, 715, 1284]], "test": "untested"}
{"id": "WdKSRd", "name": "Sunrise fly", "author": "sigomatix", "description": "Just imagine flying in the sky during sunrise", "tags": ["sunrise"], "likes": 2, "viewed": 146, "published": "Public", "date": "1574760160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorA = vec3(1.0,94.0/255.0,69.0/255.0);\nvec3 colorB = vec3(221.0/255.0,178.0/255.0,133.0/255.0);\nvec3 colorC = vec3(192.0/255.0,193.0/255.0,197.0/255.0);\nvec3 colorD = vec3(55.0/255.0,125.0/255.0,193.0/255.0);\nvec3 colorE = vec3(33.0/255.0,68.0/255.0,98.0/255.0);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.xy;\n\n    float offset = sin(iTime/10.0+st.x)/4.0;\n\n    vec3 color1 = mix(colorA,colorB,smoothstep(0.0, 0.25+offset, st.y));\n    color1 = mix(color1,colorC,smoothstep(0.25+offset, 0.33+offset, st.y));\n    color1 = mix(color1,colorD,smoothstep(0.33+offset, 0.66+offset, st.y));\n    color1 = mix(color1,colorE,smoothstep(0.66+offset, 1.00, st.y));\n    \n\n    fragColor = vec4(color1,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 328, 328, 751]], "test": "untested"}
{"id": "wdKSWh", "name": "Raytracing some spheres 2", "author": "janiorca", "description": "Second iteration of the ray tracer. Playing with sky color with scattering and absorption. The effect is not quite what I was looking for but is an improvement over the previous one", "tags": ["raytracer", "sphere", "raytrace"], "likes": 4, "viewed": 354, "published": "Public API", "date": "1573937856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define absorption_coeff 0.0051\n#define scattering_coeff 0.0013\n\nconst int num_spheres = 30;\nconst float maximum_dist = 99999.0;\n\nfloat w_intersect_sphere( float max_t, vec3 ray_dir, vec3 origin, \n    vec3 sphere, float sphere_radius2, int idx_in, \n    out vec3 pos, out vec3 norm, out int idx ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n        return max_t;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return max_t;\n        } \n        else {\n            float thc = sqrt(sphere_radius2-distToMidpoint2);\n            float t0 = tCA - thc;           // entry \n            if( t0 < max_t ) {\n                pos = origin + t0*ray_dir;\n                norm = normalize( pos-sphere);\n                idx = idx_in;\n                return t0;\n            } else {\n                return max_t;\n            }\n        }\n    }\n}\n\n// For shadows we only care if there was intersection\nbool intersects_sphere( vec3 ray_dir, vec3 origin, vec3 sphere, float sphere_radius2 ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n            return false;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return false;\n        } \n        else {\n            return true;\n        }\n    }\n}\n\nfloat ground_plane_intersect( vec3 ray_dir, vec3 origin, float ground, out vec3 pos, out vec3 norm ) {\n    if( ray_dir.y >= 0.0 ) {\n        return maximum_dist;\n    }\n    float t = ( ground-origin.y ) /  ray_dir.y; \n    norm = vec3( 0.0, 1.0f, 0.0f );\n    pos = origin + ray_dir*t;\n    return t;\n}\n\nfloat fresnel( float n, vec3 normal, vec3 incident )\n{\n    // Schlick aproximation\n    float r0 = (1.0-n) / (1.0+n);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n    return ret;\n}\n\n// vec3 extinction( float dist ) {\n//     return  exp( -dist*( vec3( 0.0005, 0.0015, 0.0017 )*14.0 ) );\n// }\n\nfloat extinction( float dist ) {\n    return      exp( -dist*( absorption_coeff + scattering_coeff ) );\n}\n\nvec3 in_scatter( float dist, float cos_angle ) {\n    vec3 rayleigh_scatter =  vec3( 0.000005, 0.000015, 0.00027 )* 3.0 / 16.0*3.14159* ( 1.0 + cos_angle*cos_angle ); \n    float rayleigh_coeff = 20.0 / (  absorption_coeff + scattering_coeff ) * ( 1.0-exp( -dist*( scattering_coeff ) ) );\n\n    float mie_g = 0.76;\n    vec3 mie_scatter =  vec3( 0.0003, 0.0003, 0.0003 ) * ( 1.0 - mie_g )*( 1.0 - mie_g ) / ( 4.0 * 3.14159 * pow( ( 1.0 + mie_g*mie_g  - 2.0 * mie_g *cos_angle ), 1.5 ) ); \n    float mie_coeff = 20.0 / (  absorption_coeff + scattering_coeff ) * ( 1.0-exp( -dist*( scattering_coeff ) ) );\n\n    return rayleigh_scatter*rayleigh_coeff +mie_scatter*mie_coeff;\n }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 sun_dir = normalize( vec3( 1.0, 1.10+sin(sin(iTime/10.0)), 1.0 ));\n\n    vec2 center = vec2( 0.5, 0.25 );\n    vec3 spheres[num_spheres];\n    for( int idx=0; idx < num_spheres; idx++ ) \n    {\n        float fidx = float(idx);\n        float fidx2 = fidx*fidx;\n        vec3 spos = vec3( sin( fidx*0.12312 + iTime * 0.121312 + 0.423 + fidx2*0.324), \n            sin( fidx*0.13312 + iTime * .372 + 0.4223+ fidx2*1.54 ),\n            sin( fidx*0.2912 + iTime * .255552 + 1.423+ fidx2*1.1324 )\n        );\n        spos *= 15.0f;\n        spheres[ idx ] = spos;\n    }\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    vec2 screen_pos_2d = 2.0*(uv - center);\n    vec3 screen_pos_3d = vec3( screen_pos_2d, -39.0 );\n\n    float _angle = iTime/3.0;\n    mat3 rot_m = mat3( cos(_angle),0,  -sin( _angle ), \n                        0,          1,          0,\n                        sin(_angle), 0, cos(_angle) );\n\n    vec3 origin = rot_m*vec3( 0,0,-40.0) ;\n    vec3 ray_dir = normalize(rot_m*screen_pos_3d - origin);\n\n    float contribution = 1.0;\n    vec3 final_color = vec3( 0,0,0);\n    for( int bounce =2; bounce >0 ; bounce -- ) {\n        vec3 new_ray_dir;\n        vec3 norm;\n        vec3 pos;\n        vec3 diffuseCol;\n        float refractive_index;\n        float reflectance = 0.0;\n        int final_idx = -1;\n        float current_t = maximum_dist;\n\n        current_t = ground_plane_intersect( ray_dir, origin , -20.0, pos, norm );\n        if( current_t <= maximum_dist ) {\n            diffuseCol = vec3( 0.05, 0.55, 0.05 );\n            if( ( ( int( pos.x/5.0) +int(pos.z/5.0) ) & 1 )== 1){\n                diffuseCol = vec3( 0.59, 0.6, 0.5 );\n                final_idx = -1;\n            } \n        } else {\n            diffuseCol = vec3( 1.0, 1.0, 0.0);\n\n        }\n\n        for( int idx=1; idx < num_spheres; idx++ ) {\n            vec3 vv = vec3( 0.0, 0.0, 0.0 )*float(idx);\n           current_t  =  w_intersect_sphere( current_t, ray_dir, origin, spheres[idx], 4.2*4.2, idx, \n               pos, norm, final_idx);\n        }\n        // workout out material properties\n        if( final_idx > 0 ) {\n            if( final_idx % 3 == 0 ) {\n                diffuseCol = vec3( 0.02, 0.02, 0.12 );\n                refractive_index = 1.77;\n            } else if( final_idx % 3 == 1 ) {\n                diffuseCol = vec3( 0.5, 0.1, 0.1 );\n                refractive_index = 1.2;\n            } else {\n                diffuseCol = vec3( 0.2, 0.5, 0.1 );\n                refractive_index = 1.5;\n            }\n            reflectance = fresnel( refractive_index, norm, ray_dir);\n            new_ray_dir = reflect( ray_dir, norm );\n        }\n\n        vec3 point_color = vec3( 0, 0, 0 );\n\n        if( current_t >= maximum_dist ) {\n            point_color += in_scatter( current_t, dot( sun_dir,ray_dir) );\n            final_color += point_color * contribution;\n        }\n\n        // light the point\n        for( int lt=0; lt<1; lt++ ) \n        {\n            // Is the light shadowed\n            bool in_shade = false;\n            for( int idx=1; idx < num_spheres; idx++ ) \n            {\n                if( intersects_sphere( sun_dir, pos, spheres[idx], 4.2*4.2 ) ) \n                {\n                    in_shade = true;\n                    break;\n                }\n            }\n            if( !in_shade)\n            {\n                vec3 reflectedLight = reflect( -sun_dir, norm );\n                vec3 toCamera = -ray_dir;\n                float diffuse = dot( sun_dir, norm );\n\n                vec3 halfway = normalize( toCamera + sun_dir );\n                float specular = pow( dot( norm, halfway ), 121.0 );\n            \n                specular = clamp( specular, 0.0, 1.0 );\n\n                vec3 fragDiffuse = diffuseCol * diffuse;\n                point_color += vec3(specular,specular,specular) + fragDiffuse;\n            } else {\n                point_color += diffuseCol* 0.02;\n            }\n        }\n        // attenuate\n        point_color *= extinction( current_t );\n        point_color += in_scatter( current_t, dot( sun_dir,ray_dir) );\n\n        final_color += point_color * contribution * ( 1.0 - reflectance );\n        contribution = contribution * reflectance;\n        ray_dir = new_ray_dir;\n        origin = pos;\n\n        if( final_idx == -1 ){\n            break;\n        }\n    }\n    vec3 fragFinal = pow( final_color, vec3(1.0 / 2.2) );\n    fragColor = vec4(fragFinal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 297, 326, 1101], [1103, 1157, 1245, 1274, 1719], [1721, 1721, 1823, 1823, 2018], [2020, 2020, 2074, 2102, 2272], [2274, 2384, 2416, 2416, 2488], [2490, 2490, 2538, 2538, 3160], [3163, 3163, 3220, 3220, 7646]], "test": "untested"}
{"id": "wdKSWw", "name": "ZzArt 4 - Generative Abstract", "author": "KilledByAPixel", "description": "Evolved using zzart.3d2k.com", "tags": ["zzart"], "likes": 10, "viewed": 429, "published": "Public API", "date": "1574192634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ZzArt - Generation: 11 (133004417)\n\nconst float PI=3.141592653589793;\nvec3 CosinePalette( float t, vec3 a, vec3 b, vec3 c, vec3 d ) { return a + b*cos( PI*2.*(c*t+d)); }\nvec4 lengthA(vec4 a)      { return vec4(length(a)); }\nvec4 asinA(vec4 a)        { return asin(clamp(a,-1.,1.)); }\nvec4 acosA(vec4 a)        { return acos(clamp(a,-1.,1.)); }\nvec4 logA(vec4 a)         { return log(abs(a)); }\nvec4 log2A(vec4 a)        { return log2(abs(a)); }\nvec4 sqrtA(vec4 a)        { return sqrt(abs(a)); }\nvec4 inversesqrtA(vec4 a) { return inversesqrt(abs(a)); }\nvec4 pow2(vec4 a)         { return a*a; }\nvec4 pow3(vec4 a)         { return a*a*a; }\n\nvoid mainImage(out vec4 a, in vec2 p)\n{\na=p.yxyx/iResolution.yxyx;\na+=vec2(0,-.1).yxyx;\n\na.xy *= vec2(-6.961, 2.807);\na.xy += vec2(-9.299, 2.808);\na.wz *= vec2(-6.961, 2.807);\na.wz += vec2(-9.299, 2.808);\nvec4 b = a;\n    \n// Generated Code - Line Count: 11\nfor (int i = 0; i < 2; ++i)\n{\nb.xwyz = (vec4(9.128, -0.496, -0.044, 9.615)).yzwz;\na.xywz -= cos(a+iTime).xzzw;\na.zwxy *= (a).zxyx;\nb.yzwx += (vec4(-1.740, -3.156, 4.371, 2.672)).zxzy;\nb.yxwz = abs(b).wzxz;\na.zwxy /= (b).yzwy;\na.ywxz -= (b).wxzw;\na.yxzw -= log2A(a).zzxw;\n}\n\n// Cosine palettes by iq\na.x = a.x * -0.018+0.063;\na.xyz = b.x * CosinePalette(a.x,\n vec3(0.410, 0.045, 0.042),\n vec3(0.960, 0.279, 0.187),\n vec3(0.742, 0.722, 0.604),\n vec3(0.949, 0.047, 0.964));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 136, 136, 172], [173, 173, 200, 200, 226], [227, 227, 254, 254, 286], [287, 287, 314, 314, 346], [347, 347, 374, 374, 396], [397, 397, 424, 424, 447], [448, 448, 475, 475, 498], [499, 499, 526, 526, 556], [557, 557, 584, 584, 598], [599, 599, 626, 626, 642], [644, 644, 683, 683, 1373]], "test": "untested"}
{"id": "wdKXDy", "name": "Sequence (scene control)", "author": "gaz", "description": "sample https://qiita.com/gaziya5/private/0dacfdcbc8029b21ff1e\nI use a translation app for comments. There may be funny phrases.", "tags": ["sequence"], "likes": 4, "viewed": 120, "published": "Public", "date": "1574930370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// sample https://qiita.com/gaziya5/private/0dacfdcbc8029b21ff1e\n// ++++++++++++++++++++++++++++\n// シーケンス関係のマクロ\n// Sequence-related macros\n\n// world timeはmod()でループさせて、制御範囲を決める。\n// The world time is looped with mod () to determine the control range.\n#define worldTime mod(iTime,30.0)\n\nfloat TIME=0.0,SAM=0.0;\nint ID=-1;\n\n#define S(a)\\\n    TIME=max(TIME,(1.0-step(SAM+a,worldTime))*(worldTime-SAM));\\\n    ID+=int(step(SAM,worldTime));\\\n    SAM+=a;\n\n// シーンの順番\n// Scene order\n#define SceneID int[](3,0,1,2,1,3,2,0)[ID]\n\n// +++++++++++++++++++++++++++++\n// 良く使いまわすマクロ\n// Frequently used macros\n#define PI acos(-1.0)\n#define TAU PI*2.0\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n// https://twitter.com/phi16_/status/1143451702219042816\n#define hue(t) (cos((vec3(0,2,-2)/3.0+t)*TAU)*0.5+0.5)\n// https://twitter.com/phi16_/status/1151731126580338688\n#define hsv(h,s,v) mix(vec3(1),hue(h),s)*v\n// https://qiita.com/7CIT/items/4126d23ffb1b28b80f27\n#define lpNorm(p,n) pow(dot(pow(abs(p),vec2(n)),vec2(1)),1.0/n)\n// 超テキトーな乱数取得関数。\n// Cheap random number acquisition function.\n#define hash(n) fract(sin(n)*5555.0)\n// https://twitter.com/iquilezles/status/1177461747625553921\n#define opRepLim(p,s,lim) p-s*clamp(round(p/s),0.0,lim)\n\n// +++++++++++++++++++++++++++++\n// scene 0 で、使ってる関数\n// Function used in scene 0\n//\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// pmod()のスムース版\n// https://www.shadertoy.com/view/WlBSRR\nvec2 polarSmoothFold(vec2 p,float n)\n{\n    float h=floor(log2(n));\n    float a =TAU*exp2(h)/n;\n    for(int i=0; i<int(h)+2; i++)\n    {\n        vec2 v = vec2(-cos(a),sin(a));  \n \t\tp-=2.0*smin(0.0,dot(p,v),0.05)*v;\n        a*=0.5;\n    }\n    return p;\n}\n\n// +++++++++++++++++++++++++++++\n// scene 1 で、使ってる関数\n// Function used in scene 1\n//\nfloat normalizeTime(float time, float startTime, float useTime)\n{\n    return clamp((time-startTime)/useTime, 0.0, 1.0);\n}\n\n\n// +++++++++++++++++++++++++++++\n// scene 2 で、使ってる関数\n// Function used in scene 2\n//\n// https://neort.io/art/bj2225k3p9f9psc9ovf0\n// イージング関数を一部抜粋。\nfloat ease_in_quad(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn c*(t/=d)*t + b;\n}\n\nfloat ease_in_sine(float x) {\n\tfloat t=x; float b=0.; float c=1.; float d=1.;\n\treturn -c * cos(t/d * (3.14159265359/2.)) + c + b;\n}\n\n// +++++++++++++++++++++++++++++\n// scene 3 で、使ってる関数\n// Function used in scene 3\n// https://qiita.com/gaziya5/items/e58f8c1fce3f3f227ca7\n// リズムシーケンスを少し改造\n// Slightly modified rhythm sequence\n//\n\n#define Rhythm2Int(v,a)v=0;for(int i=0;i<16;i++)v+=a[i]<<i;\n\nfloat rhythmSequence(int s,float time, float a)\n{\n  float n =mod(time,a);\n  for(int i=0;i<16;i++){\n    if((s>>(int(time/a)-i)%16&1)==1)break;\n    n+=a;\n  }\n  return n;\n}\n\n// +++++++++++++++++++++++++++++\n// int A[26]は、アルファベットのデータだが、わかりずらいので、マクロを使用。\n// int A [26] is alphabetic data, but it is difficult to understand, so use macros.\n// int N[10]は、数字のデータ。インデックスが、そのまま数字なので、マクロを省略。\n// int N [10] is numeric data. Since the index is a number as it is, the macro is omitted.\n#define _A 0\n#define _B 1\n#define _C 2\n#define _D 3\n#define _E 4\n#define _F 5\n#define _G 6\n#define _H 7\n#define _I 8\n#define _J 9\n#define _K 10\n#define _L 11\n#define _M 12\n#define _N 13\n#define _O 14\n#define _P 15\n#define _Q 16\n#define _R 17\n#define _S 18\n#define _T 19\n#define _U 20\n#define _V 21\n#define _W 22\n#define _X 23\n#define _Y 24\n#define _Z 25\n\nint A[26]=int[](7325,53709,35217,53705,36241,3217,39317,7196,49601,39176,11282,35088,6202,14392,39321,3229,47513,11421,37285,16577,39192,2578,14872,8738,16418,33667);\nint N[10]=int[](39835,4106,36237,38285,5148,38293,40341,643,40349,38301);\n\n// 16セグメントの距離関数。\n// 16 segment distance function.\n// intをデータとして使用。bit演算でデータを取り出す。\n// Use int as data. Extract data by bit operation.\nfloat de16Seg(vec2 p,int n)\n{\n\tfloat e=2.;\n\tmat2 m=mat2(0,-1,1,0);\n    for(int i=0;i<16;i++){\n\t\tint j=i&3;\n\t\tif(j==0)m*=mat2(0,1,-1,0);\n\t\tif((n>>i&1)==1){\n\t\t\tvec2 a=m*vec2(26>>j&1,19>>j&1)*vec2(0.6,1);\n\t\t\tvec2 b=m*vec2(13>>j&1,9>>j&1)*vec2(0.6,1);\n            a.x+=0.2*a.y;\n            b.x+=0.2*b.y;\n            vec2 c=p-a,d=b-a;\n\t\t\te=min(e,length(c-d* clamp(dot(c,d)/dot(d,d), 0.0, 1.0)));\n\t\t}\n\t}\n\treturn e;\n}\n\n// debug用マクロのフラグ。 -1で通常。0~3でシーンを指定。\n// Flag for macro for debug. Usually at -1. Specify the scene with 0 ~ 3.\n#define TEST_ID -1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.15);\n\n    // これでシーンの切り替え時間を設定する。\n    // This sets the scene switching time.\n    S(3.0)S(5.0)S(3.0)S(4.0)S(4.0)S(5.0)S(3.0)S(3.0)\n        \n    // switchのcaseの後にブロックは、無くても良いにですが、変数名の衝突が、面倒なのでブロックを使ってます。\n    // There is no need to have a block after the switch case, but the variable name conflict is cumbersome, so the block is used.\n#if TEST_ID < 0\n    switch(SceneID)\n#else\n    switch(TEST_ID)\n#endif\n    {\n        case 0:\n        {\n            // シーケンスを使ってない奴。\n            // A guy who doesn't use sequences.\n            p*=8.0;\n            for(int i=0; i<3; i++)\n            {\n                p=polarSmoothFold(p,8.0);\n                p-=0.7+sin(TIME)*0.1;\n                p*=rot(hash(2.3+float(i)+floor(TIME*1.5)));\n                p=polarSmoothFold(p,5.0);\n                p.x-=0.3+sin(TIME)*0.1;\n                p*=0.6;  \n            }\n            float de=abs(lpNorm(p,5.0)-0.3);\n            de = min(de,abs(dot(p,rot(sin(TIME)*0.5+1.7)*vec2(0,1))));\n            col=mix(vec3(0),col,smoothstep(0.03,0.031,de));\n            col=mix(hsv(atan(p.x,p.y)*0.5+TIME,0.7,0.8),col,smoothstep(0.02,0.021,de));\n            break;\n        }\n        case 1:\n        {\n            // 個別のシーケンス\n            // Individual sequence\n            float de;\n            vec3 q;\n            \n            float itr=35.0;\n            float num=15.0;\n            \n            for(float i=0.0;i<num;i+=num/itr)\n            {\n                vec2 coord=vec2(hash(i+133.125),hash(i+320.123))*2.0-1.0;\n                coord.x*=iResolution.x/iResolution.y;\n                float t=normalizeTime(TIME, hash(i+456.123)*5.0, hash(i+789.123));\n                t=smoothstep(0.0,1.0,smoothstep(0.0, 1.0, t)); // easing\n                float r=mix(0.05,0.5,t);\n                de=abs(lpNorm(p-coord*0.7,8.0)-r);\n            \tcol=mix(vec3(0),col,smoothstep(0.02,0.021,de));\\\n            \tcol=mix(hsv(hash(i+74221.123),0.7,0.8),col,smoothstep(0.01,0.011,de));\n            }\n            break;\n        }\n        case 2:\n        {\n            // 累積時間をつかったシーケンス\n            // Sequence using accumulated time\n            // ここで使うならworld timeは、TIMEになる。注意。\n            // Caution. If used here, the world time will be TIME. \n            float T=0.0,SAM1=0.0;\n\t\t\t#define Q(a) T=clamp((TIME-SAM1)/a, 0.0, 1.0);SAM1+=a;\n            #define DSP2(c)\\\n            \tcol=mix(vec3(0),col,smoothstep(0.03,0.031,de));\\\n            \tcol=mix(c,col,smoothstep(0.02,0.021,de));\n\t\t\tfloat de,r;\n            vec2 coord;\n            \n            // shape 1\n            SAM1=0.0; // init\n            coord=vec2(0);\n            r=0.0;\n            Q(0.5)\n            \tT=ease_in_quad(T); // easing\n                r+=0.5*T;\n            Q(0.5)\n            Q(0.5)\n            Q(0.5)\n            \tT=ease_in_sine(T); // easing\n            \tr-=0.3*T;\n            de=abs(length(p-coord)-r);\n            DSP2(hsv(0.0,0.8,0.7))\n                \n            // shape 2\n            SAM1=0.0; // init\n            coord=vec2(0);\n            r=0.0;\n            Q(0.5)\n            Q(0.5)\n                T=ease_in_quad(T); // easing\n            \tr+=0.15*T; \n                coord+=vec2(0.7,0)*T;\n            Q(0.5)\n            \tT=ease_in_sine(T); // easing\n            \tcoord *=rot(T*TAU);\n            de=abs(length(p-coord)-r);\n            DSP2(hsv(0.5,0.8,0.7))\n            de=abs(length(p+coord)-r);\n            DSP2(hsv(0.5,0.8,0.7))          \n            break;\n        }\n        case 3:\n        {\n            // music shader シーケンスからの応用\n            // Application from music shader sequence\n\t\t\tfloat bpm=120.0;\n\t\t\tfloat beat=15.0/bpm;\n            int rhytm;\n    \t\tRhythm2Int(rhytm, int[]( 1,0,0,0, 0,0,0,1, 1,0,1,0, 0,0,0,0 ))\n            float localTime=rhythmSequence(rhytm,worldTime,beat);\n\t\t\tfloat value=exp(-localTime*3.0); //envelope\n            \n            #define DSP3(c)\\\n            \tcol=mix(vec3(0),col,smoothstep(0.03,0.031,de));\\\n            \tcol=mix(c,col,smoothstep(0.02,0.021,de));\n        \t\n            float de;\n            vec2 q=vec2(atan(p.x,p.y), length(p)-0.3);\n            q.y=opRepLim(q.y,0.2,floor(5.0*value));\n            float s=TAU/4.0;\n            q.x=mod(q.x,s)-0.5*s;\n            q.x-=clamp(q.x,-0.2,0.2);\n            de=length(q);\n            DSP3(mix(vec3(1),vec3(1,0,0),0.8))\n            float h=length(p)*0.5;\n            for(float i=0.0;i<3.0;i++) p=abs(p)-0.2/exp2(i);\n            if(p.x<p.y) p=p.yx;\n\t\t\tp.x-=clamp(p.x,0.0,value);\n\t\t\tde=length(p);\n            DSP3(hsv(h,0.7,0.8))\n            break;\n        }\n    }\n    \n    // デバック用の文字列\n    // String for debugging\n    // わざわざブロックを作ってる理由は、ブロック内だと変数名が重複しても、\n    // エラーが出ず、ブロック内の変数名が優先されるからです。\n    // The reason for making a block purposely is that if a variable name is duplicated within a block, \n    // an error will not occur and the variable name within the block will be given priority.\n    // デバック用なので、気楽に書きたいからですね。\n    // Because it is for debugging, I want to write it easily.\n\t{\n        vec2 p=fragCoord/iResolution.y;\n    \tp*=50.0;\n\n    \t#define ALF(a) idx=A[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n    \t#define NUM(a) idx=N[a];de=min(de,de16Seg(p,idx));p.x-=2.0;\n        #define DSP(c)\\\n        \tcol=mix(vec3(0),col,smoothstep(0.4,0.41,de));\\\n    \t\tcol=mix(c,col,smoothstep(0.15,0.16,de));\n        \n    \tint idx;\n   \t\tfloat de=2.0;\n    \tp-=vec2(35,10);\n    \tALF(_S)ALF(_C)ALF(_E)ALF(_N)ALF(_E)\n    \tDSP(vec3(1))\n        p.x-=1.0;\n        de=2.0;\n    \tNUM(SceneID)\n    \tDSP(vec3(1,0,0))\n    \tp-=vec2(-13,-4);\n        de=2.0;\n    \tALF(_L)ALF(_O)ALF(_C)ALF(_A)ALF(_L)\n        p.x-=1.0;\n    \tALF(_T)ALF(_I)ALF(_M)ALF(_E)\n        DSP(vec3(1))\n        p.x-=1.0;\n        de=2.0;\n    \tNUM(int(TIME)/10)\n        NUM(int(TIME)%10)\n    \tDSP(vec3(1,0,0))\n        de=2.0;\n        ALF(_S)\n    \tDSP(vec3(1))\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1345, 1445, 1486, 1486, 1593], [1595, 1664, 1702, 1702, 1914], [1916, 2016, 2081, 2081, 2137], [2140, 2328, 2357, 2357, 2431], [2433, 2433, 2462, 2462, 2564], [2566, 2864, 2913, 2913, 3033], [4064, 4263, 4292, 4292, 4673]], "test": "untested"}
{"id": "wdKXRV", "name": "GPU Stove", "author": "okou", "description": "_            _\n  \\_(ツ)_/", "tags": ["stove"], "likes": 1, "viewed": 50, "published": "Public", "date": "1574504229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // GPU usage in GTX1070: 5=20% 20=35% 40=65% 50=100%\n    const int HOTPOWER = 2;\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tmp;\n    float arr[HOTPOWER];\n    float size = float(HOTPOWER);\n    \n    for(int i=0; i<HOTPOWER; i++){\n        vec2 seed = vec2(uv.x*float(i)*iTime, uv.y*float(i));\n        arr[i] = rand(seed);\n    }\n    \n    for (int i=0; i<HOTPOWER; ++i) {\n\t\tfor (int j=i+1; j<HOTPOWER; ++j) {\n        \tif (arr[i] > arr[j]) {\n            \ttmp =  arr[i];\n            \tarr[i] = arr[j];\n            \tarr[j] = tmp;\n          \t}\n        }\n    }\n    \n\tint idxr = int(mod(floor(uv.x*size*10.+iTime), float(size)));\n    int idxg = int(mod(floor(uv.y*size*10.+iTime), float(size)));\n    vec3 col = vec3(arr[idxr],arr[idxg],arr[HOTPOWER-1]);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 208, 977]], "test": "untested"}
{"id": "wdKXW1", "name": "noise based brick", "author": "neither", "description": "Generate brick textures using simplex noises.", "tags": ["noise", "brick", "tile"], "likes": 2, "viewed": 82, "published": "Public", "date": "1573970041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nfloat pi = 3.14159;\nfloat omega = .5f;\nvec4 pt4( float x, float y, float dx, float dy, float xyOffset ) {\n    float s = x;\n    float t = y;\n\n    float nx = xyOffset + cos(s * omega * pi) * dx / (omega * pi);\n    float ny = -xyOffset + cos(t * omega * pi) * dy / (omega * pi);\n    float nz = xyOffset + sin(s * omega * pi) * dx / (omega * pi);\n    float nw = -xyOffset + sin(t * omega * pi) * dy / (omega * pi);\n\n    return vec4(nx, ny, nz, nw);\n}\n\nfloat noise(vec2 p) {\n    return   0.5333333*(abs(snoise(p)))\n\t\t\t+0.2666667*(abs(snoise(2.*p)))\n\t\t\t+0.1333333*(abs(snoise(4.*p)))\n\t\t\t+0.0666667*(abs(snoise(8.*p)));\n}\n\nfloat fbm(vec2 p, float sx, float sy) {\n    return   sin(sx * p.x + sy * p.y + 0.5333333*abs(snoise(p))\n\t\t\t+0.2666667*abs(snoise(2.*p))\n\t\t\t+0.1333333*abs(snoise(4.*p))\n\t\t\t+0.0666667*abs(snoise(8.*p)));\n}\n\nfloat fbm2(vec2 p, float sx, float sy, float offset) {\n    return   sin(sx * p.x + floor((p.y * sy / 2. / pi - offset)) * pi + 0.5333333*abs(snoise(p))\n\t\t\t+0.2666667*abs(snoise(2.*p))\n\t\t\t+0.1333333*abs(snoise(4.*p))\n\t\t\t+0.0666667*abs(snoise(8.*p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sx = 1.;\n    float sy = 2.;\n    float offset = 0.2;\n    vec3 brick_color_base = vec3(147, 66, 34) / 256.;\n    vec3 brick_shadow_1 = vec3(129, 60, 15) / 256.;\n    vec3 brick_shadow_2 = vec3(107, 61, 20) / 256.;\n    vec3 shadow_color = vec3(38, 6, 6) / 256.;\n    \n    vec2 p = fragCoord.xy/iResolution.y; \n    \n    p.x += iTime * .2;\n    \n    float intensity1 = pow(clamp(fbm(p*20., 0., sy), 0., 1.) + .03, 40.);\n    \n    float intensity2 = pow(clamp(fbm2(p*20., sx, sy, offset), 0., 1.) + .03, 40.);\n   \n    float intensity = clamp(intensity1 + intensity2, 0., 1.);\n    \n    float c = pow(1.1 - noise(p * vec2(5., 20.) + 707.), 10.);\n    float c2 = pow(1.1 - noise(p * vec2(5., 20.) + 34.), 10.);\n    \n    vec3 brick = mix(brick_color_base, brick_shadow_1, c);\n    \n    brick = mix(brick, brick_shadow_2, c2);\n    \n    brick = mix(brick, shadow_color, intensity);\n    \n    fragColor.xyz = brick;\n    //fragColor.xyz = brick_color_1;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKXW1.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 450, 471, 471, 520], [522, 522, 545, 545, 594], [596, 596, 618, 618, 658], [660, 660, 684, 684, 724], [726, 726, 754, 754, 806], [808, 808, 838, 838, 890], [892, 892, 924, 924, 1187], [1195, 1269, 1293, 1293, 3771], [3772, 3772, 3793, 3793, 3842], [3844, 3844, 3865, 3865, 3914], [3916, 3916, 3938, 3938, 3975], [3976, 3976, 4000, 4000, 5506], [5546, 5546, 5612, 5612, 5953], [5955, 5955, 5976, 5976, 6121], [6123, 6123, 6162, 6162, 6326], [6328, 6328, 6382, 6382, 6579], [6581, 6581, 6638, 6638, 7582]], "test": "untested"}
{"id": "wdKXWG", "name": "Shifting Perforations", "author": "ShnitzelKiller", "description": "Testing automatically orienting carved regions on a curved surface", "tags": ["raytracing", "sphere"], "likes": 4, "viewed": 341, "published": "Public API", "date": "1574933666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.5\n\n//size of the windows\n#define STRIDE 0.25\n\n//radius of the sphere\n#define RADIUS 1.\n\n//depth of the holes\n#define DEPTH 0.125\n\n//offset of the holes\n//#define OFFSET -0.125\n\n\n// Raytrace sphere\nfloat sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return -1.;\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return tin;\n}\n\n\n// Raytrace box, returns (t_in, t_out)\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    vec3 pin =  - k - n;\n    float tout = min(pout.x, min(pout.y, pout.z));\n    float tin = max(pin.x, max(pin.y, pin.z));\n    if (tin > tout) {\n        return vec2(-1.);\n    }\n    no = -sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tfloat ang = iTime * 0.5;\n    vec3 eye = 1.5*vec3(cos(ang), sin(ang), 1.);\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + FDIST * w);\n    \n    vec3 n;\n    float t = sphere(eye, rd, RADIUS, n);\n    vec3 col;\n    \n    if (t > 0.) {\n        \n        //get offsets and cell IDs and their centroids/normals\n        vec3 ro = eye + t * rd;\n        vec3 offset = vec3(iMouse.x/iResolution.x, iTime*0.3, iMouse.y/iResolution.y);\n        ro += offset;\n        vec3 mask = 1.-step(0.9,abs(fract(ro/STRIDE)-0.5)*2.);\n        vec3 modro = fract(ro/STRIDE);\n        vec3 id = floor(ro/STRIDE);\n        ro -= offset;\n        vec3 cc = (id+0.5)*STRIDE - offset;\n        float OFFSET = length(cc) - RADIUS;\n        vec3 nn = normalize(cc);\n        vec3 sundir = normalize(vec3(1., 1., 1));\n        \n        // transform to tangent space for raytracing cavities\n        vec3 uu = normalize(cross(vec3(0., 0., 1.), nn));\n        vec3 vv = cross(nn, uu);\n        mat3 rot = mat3(uu, vv, nn);\n        mat3 rott = transpose(rot);\n        vec3 rd_inner = rott * rd;\n        vec3 ro_inner = rott * (ro-cc) + vec3(0., 0., OFFSET);\n        vec3 n_inner;\n        vec3 dims = vec3(vec2(0.3*STRIDE), DEPTH);\n        vec2 t_inner = box(ro_inner, rd_inner, dims, n_inner);\n        float fac = 1.;\n        if (t_inner.y > 0. && t_inner.x < 0. && mask.x*mask.y*mask.z > 0.5) {\n            // determine shadows\n            vec3 sundir_inner = rott * sundir;\n            vec3 n_shadow;\n            vec3 ro_shadow = ro_inner + t_inner.y * rd_inner;\n\t\t\tvec2 t_shadow = box(ro_shadow, sundir_inner, dims, n_shadow);\n            // where the shadow ray hits the cavity in world space; if it's outside the hull, no shadow\n            vec3 ro_light = cc + rot * (ro_shadow - vec3(0., 0., OFFSET) + t_shadow.y * sundir_inner);\n            fac = step(RADIUS, length(ro_light));\n            n = rot * n_inner;\n        }\n        // shade\n        fac *= max(0., dot(n, sundir));\n        float fac2= max(0., dot(n, -sundir));\n        col = fac * vec3(1., 1., 0.95) + fac2 * vec3(0.1, 0.1, 0.2);\n    } else {\n        col = vec3(0.);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 213, 276, 276, 493], [496, 535, 593, 593, 973], [975, 975, 1032, 1032, 3320]], "test": "untested"}
{"id": "WdKXWz", "name": "Stranger Crystal", "author": "ShnitzelKiller", "description": "A crystal with bizarre properties", "tags": ["raytracing", "reflection", "refraction", "crystal"], "likes": 5, "viewed": 243, "published": "Public API", "date": "1573802844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FDIST 0.7\n#define PI 3.1415926\n\n\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.05\n#define BOXDIMS vec3(0.6, 0.6, 1.)\n\n#define ABSORPTION_RATE vec3(0.7, 0.5, 0.4)\n#define IOR 1.33\n#define SCATTER_FACTOR 0.02\n#define SAMPLES 10\n#define REFLECTIONS 4\n\n\nvec2 rand2d(in vec2 uv) {\n    return fract(mat2(-199.258, 457.1819, -1111.1895, 2244.185)*sin(mat2(111.415, -184, -2051, 505)*uv));\n}\n\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 ni, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pin = - k - n;\n    vec3 pout =  k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout) return vec2(-1.);\n    ni = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    no = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    return vec2(tin, tout);\n}\n\nvec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {\n\tfloat pd = dot(ro, rd);\n    float disc = pd*pd + r*r - dot(ro, ro);\n    if (disc < 0.) return vec2(-1.);\n    float tdiff = sqrt(disc);\n    float tin = -pd - tdiff;\n    float tout = -pd + tdiff;\n    ni = normalize(ro + tin * rd);\n    \n    return vec2(tin, tout);\n}\n\nvec3 bgcol(in vec3 rd) {\n    return mix(vec3(0., 0., 1.), vec3(0.6, 0.8, 1.), 1.-pow(abs(rd.z), 2.));\n}\n\n//raytrace the exterior surroundings\nvec4 background(in vec3 ro, in vec3 rd) {\n    float t = (-1. - ro.z)/rd.z;\n    vec3 col1;\n    if (t < 0.) {\n        t = 1000.;\n        col1 = bgcol(rd);\n    } else {\n        vec2 uv = ro.xy+t*rd.xy;\n        if (max(abs(uv.x), abs(uv.y)) > 8.) col1 = bgcol(rd);\n        else {\n            vec2 checkers = smoothstep(vec2(GROUNDGRID*0.75), vec2(GROUNDGRID), abs(mod(uv, vec2(GROUNDSPACING))*2.-GROUNDSPACING));\n            float aofac = smoothstep(-0.7, .4, length(abs(uv)-min(abs(uv), vec2(0.75))));\n            col1 = mix(vec3(0.2), vec3(0.8), min(checkers.x,checkers.y)) * aofac;\n        }\n    }\n    \n    vec3 ni;\n    vec2 t2 = sphere(ro - vec3(BOXDIMS.x + 0.6, 0., -0.4), rd, 0.6, ni);\n    float tea = mix(t, t2.x, step(0., t2.x));\n    return vec4(mix(col1, mix(vec3(1.), vec3(1., 1., 0.), (t2.x * rd + ro).z+0.5), step(0., t2.x)), tea);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    float mouseY = iMouse.y < 1. ? 0.5 : (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec3 eye = 4.*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n    \n    vec3 ni, no;\n    vec2 t = box(eye, rd, BOXDIMS, ni, no);\n    vec3 ro = eye + t.x * rd;\n    vec2 coords = ro.xy * ni.z + ro.yz * ni.x + ro.zx * ni.y;\n    \n    vec4 bgg = background(eye, rd);\n    \n    if (t.x > 0. && t.x < bgg.w) {\n        vec3 col = vec3(0.);\n        float R0 = (IOR-1.)/(IOR+1.);\n        R0*=R0;\n        for (int i=0; i<SAMPLES; i++) {\n            \n            vec2 theta = rand2d(coords + float(i) * vec2(1., 0.) * vec2(104., -30.6));\n            theta *= vec2(2.*PI, SCATTER_FACTOR*PI);\n            vec3 n = vec3(cos(theta.x)*sin(theta.y), sin(theta.x)*sin(theta.y), cos(theta.y));\n            // reflection\n            vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n            vec3 rdr = reflect(rd, nr);\n            vec3 reflcol = background(ro, rdr).xyz;\n            \n            // refraction, absorption and internal reflection\n            vec3 rd_refr = refract(rd, nr, 1./IOR);\n            \n            vec3 insidecol = vec3(0.);\n            float accum = 1.;\n            vec3 transmission = vec3(1.);\n            \n            for (int j=0; j<REFLECTIONS; j++) {\n                \n                vec3 ni2, no2;\n                vec2 tout = box(ro, rd_refr, BOXDIMS, ni2, no2);\n                ro = ro + tout.y * rd_refr;\n                vec3 rd_refr_out = refract(rd_refr, -no2, IOR);\n\n                float fresnel2 = R0 + (1.-R0) * pow(1.-dot(rd_refr_out, no2), 5.);\n                vec3 reps = ro;\n                reps.z = max(reps.z, -0.999);            \n            \trd_refr = reflect(rd_refr, -no2);\n                transmission *= pow(ABSORPTION_RATE, vec3(tout.y));\n            \tinsidecol += accum * (1.-fresnel2) * background(reps, rd_refr_out).xyz * transmission;\n                accum *= fresnel2;\n            }    \n            \n            float fresnel = R0 + (1.-R0) * pow(1.-dot(-rd, nr), 5.);\n            col += mix(insidecol, reflcol, fresnel);\n        }\n        col /= float(SAMPLES);\n\n        fragColor = vec4(col, 1.);\n    } else {\n\t\tfragColor = vec4(bgg.xyz, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 284, 284, 392], [394, 394, 465, 465, 897], [899, 899, 961, 961, 1226], [1228, 1228, 1252, 1252, 1331], [1333, 1370, 1411, 1411, 2211], [2213, 2213, 2270, 2270, 4819]], "test": "untested"}
{"id": "wdKXzd", "name": "Perlin noise vs interpolation", "author": "FabriceNeyret2", "description": "If no scrambling matrix is used between scales (i.e. original Perlin noise), the noise is exactly 0 on grid vertex (green isocurve).\nThis can be used to stochastically interpolate a mesh or polyline, still passing through control points.\n", "tags": ["procedural", "2d", "noise", "perlin", "gradient", "flownoise"], "likes": 18, "viewed": 666, "published": "Public API", "date": "1574793987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see also the curve cases: https://www.shadertoy.com/view/WdGXWG\n//                           https://www.shadertoy.com/view/WsGXDy\n\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 x ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(x.x+x.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(x.x)+floor(x.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n    s *= iTime;                        // same rotation speed at all scales\n // s *= iTime/ _z;                    // rotation speed increase with small scale    \n    const vec2 k = vec2( .3183099, .3678794 );\n    x = x*k + k.yx + 5.;\n    return ( -1. + 2.*fract( 16. * k*fract( x.x*x.y*(x.x+x.y)) ) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 p )  //fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 4; i++, s /= 2. ) { _z = s; // for flownoise\n        v += s*noise( p ); p *= m;\n    }\n    return v;\n}\n\n// -----------------------------------------------\n\n#define S(v) smoothstep( pix, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u -.5*R ) / R.y * 8., U0=U;\n    O -= O;\n    float pix = 12./R.y;\n    \n    O -= S(abs(U.x));\n    \n\tif( U.x < 0. )          // left: noise\t\n\t\tO += noise( U ) * 1.5;\n    else\t                // right: fractal noise\n\t\tO += perlin(U);\n\n    O.r += S(fract(U0.x));  // grid\n    O.r += S(fract(U0.y));\n    O.g += S( abs(O.x) );   // isoline 0\n\n\tO = .5 + .5*O;\n    O = mix(O, vec4(0,.5,0,1), S (length(fract(U0-.5)-.5)-.05) ); // grid vertices\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKXzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 220, 242, 306, 973], [975, 975, 998, 998, 1227], [1229, 1229, 1270, 1270, 1478], [1480, 1571, 1609, 1609, 2095]], "test": "untested"}
{"id": "WdKXzh", "name": "shaded circle", "author": "bantic", "description": "trying to make a color wheel", "tags": ["circle", "colorwheel"], "likes": 1, "viewed": 72, "published": "Public", "date": "1573421798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.1415926;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    vec2 toCenter = vec2(0.5)-st;\n    float radius = length(toCenter)*2.0;\n    float angle = iTime*2.0 + atan(toCenter.y,toCenter.x) + 2.0*(sin(iTime+radius));\n    vec3 c = vec3((angle/(2.0*PI)),radius+0.5,1.0);\n    color = hsb2rgb(c);\n    \n    float circleRadius = 0.5 *min(iResolution.x,iResolution.y);\n    float dist2Center = length(fragCoord.xy - 0.5 * iResolution.xy);\n    if (dist2Center < circleRadius) {\n      fragColor = vec4(color, 1.0);              \n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 100, 100, 333], [335, 335, 392, 392, 1008]], "test": "untested"}
{"id": "wdtSD2", "name": "Interferrence", "author": "Hendiadyoin", "description": "A simple Simulation of Interferrence of Waves", "tags": ["physics"], "likes": 2, "viewed": 73, "published": "Public", "date": "1572946926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.2831853f\n\nstruct source{\n\tvec2 pos;\n    float l;\n    float amp;\n};\n// you can change evrything below\nconst bool decay = true;\nconst float scale = 200.f;\nconst float v = 10.f;\nconst source [2] sc=source[](\n\tsource(\n        vec2(-30,0),\n          5.f,\n          500.f), //high values due to quadratic decay\n    source(\n    \tvec2(30,0),\n        5.f,\n        500.f)\n        );\n// no Changes past here\n\n//calculate the overall amplitude of the wave at the position\nfloat amp(vec2 pos,float t){\n    float a = 0.f;\n    for(int i = 0;i<sc.length();i++){\n        source s = sc[i];\n        float d = length(pos*scale-s.pos);\n        float l = d/s.l;\n        float f = v/s.l;\n    \tfloat ta = sin((l-f*t)*TWO_PI);\n        if (decay){\n            ta*= s.amp/d/d;\n        }\n        a+=ta;\n    }\n    return clamp(a,0.,1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y;\n    O = vec4( amp( U, iTime/2.f ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 477, 505, 505, 826], [828, 828, 869, 922, 1023]], "test": "untested"}
{"id": "wdtSDs", "name": "[TWITCH] Boss Key", "author": "Flopine", "description": "The is a shader I made during a live session on Twitch. I wanted to do something NPR and also experiment with procedural texturing and interactivity :) \nYou can watch the stream here: https://www.twitch.tv/flopine", "tags": ["raymarching", "mouse", "interactive", "zelda", "npr"], "likes": 10, "viewed": 303, "published": "Public", "date": "1573169607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define time iTime \n#define PI 3.141592\n\n#define circle(uv,r) smoothstep(0.13,0.1, length(uv)-r)\n#define anim (2.*(iMouse.xy/iResolution.xy)-1.)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat key (vec3 p)\n{\n    vec3 pp = p;\n\n    float c1 = cyl(p.xzy, 0.2-p.y*0.08, 1.);\n    float c2 = cyl(p.xzy-vec3(0.,0.,0.7), 0.2,0.1);\n    float c3 = cyl(p.xzy-vec3(0.,0.,0.96), 0.2,0.1);\n\n    p.y -= 0.45;\n    moda(p.xz, 4.);\n    p.x -= 0.25;\n    float c4 = cyl(p.yzx, 0.02-p.x*0.4, 0.2);\n\n    p = pp;\n    p.y += 0.45;\n    p.y -= pow(max(0.,p.x),5.)*0.3;\n    p.x -= 0.5;\n    float c5 = cyl(p.yzx, 0.05-p.x*0.2, 0.55);\n    p.y += 0.35;\n    p.x -= 0.1;\n    c5 = min(c5, cyl(p.yzx, 0.05-p.x*0.2, 0.55));\n\n\n    p = pp;\n    p.y -= 1.88;\n    float c6 = max(abs(cyl(p, 0.7,1.))-0.1,abs(p.z)-0.21);\n\n    p = pp;\n    float cut_c = cyl(p-vec3(0.,1.7,0.), 0.77,2.);\n    p.x = abs(p.x);\n    p.y -= 1.8;\n    p.x -= .8;\n\n    p.xy *= rot(PI/8.);\n    p.y -= pow(abs(p.x+0.2), 2.)*0.5;\n\n    float c7 = max(-cut_c,cyl(p.yzx, 0.2-p.x*0.2, 1.));\n\n    return min(c7,min(min(c5,c6),min(min(c3,c2),min(c1,c4))));\n}\n\nfloat center_key (vec3 p)\n{\n    p.y -= 1.8;\n    return cyl(p, .65, 0.1);\n}\n\nint mat_id;\nvec3 final_p;\nfloat SDF (vec3 p)\n{\n    p.xz *= rot(time);\n    p.xy *= rot(PI/4.);\n    p.y += 0.8;\n    final_p = p;\n    float k = key(p);\n    float ck = center_key(p);\n    float d = min(k,ck);\n\n    if(d == k) mat_id = 1;\n    if(d == ck) mat_id = 2;\n\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps= vec2(0.01,0.);\n    return normalize(SDF(p) - vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)) );\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec4 eye (vec2 uv)\n{\n    float spec_stain = circle(uv-vec2(.1),0.01);\n    float pupil = clamp(circle(uv,0.05)-spec_stain,0.,1.);\n    float iris = clamp(circle(uv, 0.2) - (spec_stain + pupil),0.,1.);\n    float outer_ring = clamp(circle(uv, 0.3)-(iris+pupil + spec_stain),0.,1.);\n\n    return vec4(spec_stain,pupil,iris,outer_ring);\n}\n\nvec3 eye_color (vec2 uv)\n{\n    vec4 e = eye(uv);\n    return vec3(1.)*e.x +\n        vec3 (0.)*e.y + \n        vec3(0.9,0.,0.)*e.z +\n        vec3 (0.9,0.8,0.)*e.w+\n        vec3 (0.5,0.2,0.7) * (1.-clamp(e.x+e.y+e.z+e.w,0.,1.));\n}\n\n// courtesy of Alkama\nfloat pales (vec2 uv, float speed, float number)\n{\n    uv *= rot(-time*speed);\n    return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*number)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.,0.,-6.),\n        p = ro, \n        rd = normalize(vec3(uv,1.)),\n        col = mix(vec3(0.1,0.5,0.1),vec3(0.7,0.8,0.5),pales(uv, 0.2, 5.))+pales(uv, -0.5, 10.)*0.3;\n\n\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n\n        p += d*rd*0.5;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p),\n            l = normalize(vec3(5., 2., -4.)),\n            h = normalize(l-rd);\n        float spec = pow(abs(dot(n,h)), 25.);\n\n        if (mat_id == 1) \n        {\n            vec3 diffuse = mix(vec3(0.3,0.2,0.0), vec3(0.7,0.7,0.2),smoothstep(0.5,0.65,lighting(n,l)));\n\n            float fre = pow(clamp(1.-abs(dot(-rd,n)),0.,1.), 2.);\n\n            col = diffuse + vec3(1.,0.7,0.7)*spec + fre * vec3(0.8,0.7, 0.3);\n        }\n        \n        if (mat_id == 2)\n        {\n            vec2 p_eye = (final_p.xy-clamp(anim,-0.3,.3))-vec2(0.,1.88); \n            vec3 diffuse = eye_color(p_eye);\n\n            col = diffuse * lighting(n,l) + spec*(eye(p_eye).w);\n        }\n    }\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 476, 496, 496, 539], [541, 541, 577, 577, 722], [724, 724, 762, 762, 802], [804, 804, 824, 824, 1696], [1698, 1698, 1725, 1725, 1772], [1800, 1800, 1820, 1820, 2050], [2052, 2052, 2075, 2075, 2190], [2192, 2192, 2225, 2225, 2262], [2264, 2264, 2284, 2284, 2595], [2597, 2597, 2623, 2623, 2823], [2825, 2847, 2897, 2897, 2996], [2998, 2998, 3053, 3053, 4383]], "test": "untested"}
{"id": "WdtSW2", "name": "fractal fbm tiles", "author": "ArthurSango", "description": "fractal fbm tiles", "tags": ["fractal", "fbm", "tiles"], "likes": 1, "viewed": 211, "published": "Public API", "date": "1572910684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r( vec2 uv) {\n  return fract( sin( dot( uv, vec2( 123.3, 34.222) ) ));\n}\n\nfloat noise( vec2 st ) {\n\n    vec2 uv = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(5.-2.0*f);\n    \n    vec2 a = uv;\n    vec2 b = uv + vec2(1.,0.);\n    vec2 c = uv + vec2(1.,1.);\n    vec2 d = uv + vec2(0.,1.);\n\n    float ra = r(a);\n    float rb = r(b);\n    float rc = r(c);\n    float rd = r(d);\n    \n    return mix( mix( ra, rb, u.x) , mix(rc,rd,u.y) , abs( sin( ra+rb+rc+rd ) ) );\n    \n\n}\n\n// borrowed frrom https://www.iquilezles.org/www/articles/fbm/fbm.htm\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = abs ( uv * 2. - 1. );\n    \n    float a = iTime;\n    \n    vec3 col = vec3(1.);\n    \n    uv *= mat2( sin(a/10.), 0., 0., sin( a/10.) );\n    \n       \n    if ( (uv.x < 0.25 && uv.y > 0.75) || (uv.y < 0.25 && uv.x > 0.25 ) ) {\n      uv *= mat2 ( cos(a), sin(a), -sin(a), cos(a) );\n    } else  if ( (uv .x < 0.25 && uv .y < 0.25) || (uv .y > 0.75 && uv .x > 0.25 ) ) {\n      uv  *= mat2 ( cos(-a), sin(-a), -sin(-a), cos(a) );\n    }   else  {\n      uv  *= mat2 ( -cos(-a), -sin(-a), -sin(-a), -cos(a) );\n    }\n \n  //  uv *= step(  distance( uv, vec2(0.) ), 0.5 * r(uv) );\n    uv *= step(  distance( uv, vec2(0.) ), 0.5 * abs(sin(a/10.)) );\n  \n    \n \n\tcol.x = fbm( uv, 0.6) - 0.1 ;\n    col.z = fbm( uv, 0.1) - 0.1 ;\n    col.y = fbm( uv, 0.9 ) - distance( uv, vec2( 0.5) );\n    \n    vec3 c = cross( col, vec3( sin(a), cos(a), -sin(1.-a) ) );\n    col *= c;\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 78], [80, 80, 104, 104, 478], [480, 550, 586, 586, 789], [792, 792, 849, 899, 1833]], "test": "untested"}
{"id": "wdtSWf", "name": "Pixel Machine mouse simulation", "author": "erich666", "description": "Recreating the AT&T Pixel Machine mouse demo from 1987, with a Whitted feel. The ground plane back then was a Mandrill, and I believe the size was 64x64 pixels. But, it was interactive! This one should run on a cheap phone.", "tags": ["raytracing", "mouse", "sphere"], "likes": 13, "viewed": 596, "published": "Public API", "date": "1573077555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simulate the AT&T Pixel Machine demo in which a mouse moved the reflective sphere.\n// by Eric Haines\n// Derived from https://www.shadertoy.com/view/4dsGRn by Matthijs De Smedt, @anji_nl\n\nconst float ZMAX = 99999.0;\nconst float EPSILON = 0.001;\n\n// model location (sphere)\nvec3 lm = vec3(0.0,0.0,0.0);\n\nvec3 backgroundColor = vec3(0.34, 0.55, 0.85);\n\nstruct Intersection\n{\n\tvec3 p;\n\tfloat dist;\n\t\n\tvec3 n;\n\tvec3 diffuse;\n\tvec3 specular;\n};\n\t\nstruct Ray\n{\n\tvec3 o;\n\tvec3 dir;\n};\n\t\nstruct Light\n{\n\tvec3 p;\n\tvec3 color;\n};\n\t\nstruct Plane\n{\n\tvec3 n;\n\tfloat d;\n};\n\t\nstruct Sphere\n{\n\tvec3 c;\n\tfloat r;\n};\n\t\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nIntersection RaySphere(Ray ray, Sphere sphere)\n{\n\tIntersection i;\n\ti.dist = ZMAX;\n\tvec3 c = sphere.c;\n\tfloat r = sphere.r;\n\tvec3 e = c-ray.o;\n\tfloat a = dot(e, ray.dir);\n\tfloat b = r*r - dot(e,e) + a*a;\n\tif( b>0.0 )\n\t{\n\t\tfloat f = sqrt(b);\n\t\tfloat t = a - f;\n\t\tif(t > EPSILON)\n\t\t{\n\t\t\ti.p = ray.o + ray.dir*t;\n\t\t\ti.n = normalize(i.p-c);\n\t\t\ti.dist = t;\n\t\t}\n\t}\n\treturn i;\n}\n\nIntersection RayPlane(Ray ray, Plane p)\n{\n\tIntersection i;\n\tfloat num = p.d-dot(p.n, ray.o);\n\tfloat denom = dot(p.n, ray.dir);\n\tfloat t = num/denom;\n\tif(t > EPSILON)\n\t{\n\t\ti.p = ray.o + ray.dir * t;\n\t\t// hit rectangle?\n\t\tif ( i.p.x < -8.0 || i.p.x > 8.0 || i.p.z < 4.0 || i.p.z > 24.0 ) {\n\t\t\t// missed\n\t\t\ti.dist = ZMAX;\n\t\t} else {\n\t\t\ti.n = p.n;\n\t\t\ti.dist = t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// did not hit plane\n\t\ti.dist = ZMAX;\n\t}\n\treturn i;\n}\n\nIntersection MinIntersection(Intersection a, Intersection b)\n{\n\tif(a.dist < b.dist)\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\n\nvec3 PlaneMaterial(Intersection i)\n{\n\tfloat d = 0.0;\n\t// checkerboard function that returns 0 or 1\n\td = mod(floor(i.p.x)+floor(i.p.z),2.0);\n\t// vary between red (0) and yellow (1)\n\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n}\n\nIntersection SceneIntersection(Ray r)\n{\n\tIntersection iOut;\n\t\n\tPlane plane;\n\tplane.n = normalize(vec3(0,1,0));\n\tplane.d = -2.0;\n\tIntersection iPlane = RayPlane(r, plane);\n\tiPlane.diffuse = PlaneMaterial(iPlane);\n\tiPlane.specular = vec3(0.0);\n\tiOut = iPlane;\n\t\n    vec3 pos = lm;\n    Sphere sphere;\n    sphere.c = pos;\n    sphere.r = 2.0;\n    Intersection iSphere = RaySphere(r, sphere);\n    iSphere.diffuse = vec3(0.2);\n    iSphere.specular = vec3(0.7);\n    iOut = MinIntersection(iOut, iSphere);\n\n\treturn iOut;\n}\n\nvec3 CalcLighting(Light light, Intersection i, vec3 origin)\n{\n\tif ( i.dist >= ZMAX ) {\n\t\treturn backgroundColor;\n\t}\n\tvec3 n = i.n;\n\tvec3 p = i.p;\n\tvec3 l = light.p;\n\tvec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*i.diffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * i.specular;\n\tvec3 color;\n\tcolor = (diffuse+spec) * light.color;\n\n\tRay shadowRay;\n\tshadowRay.o = i.p;\n\tfloat lightDist = 100.0;\n\tshadowRay.dir = light.p;\n\tIntersection shadowI = SceneIntersection(shadowRay);\n\tif(shadowI.dist < lightDist)\n\t{\n\t\tcolor *= 0.4;\n\t}\n\t\n\treturn color;\n}\n\nvec3 GetLighting(Intersection i, vec3 origin)\n{\n\tvec3 color = vec3(0);\n\tLight light;\n\t\n    // or just set X to -2.0 to stop animation\n\tlight.p = normalize(vec3(2.0*sin(iTime*0.5),2.0,-2.0));\n\tlight.color = vec3(2.5);\n\tcolor += CalcLighting(light, i, origin);\n\n\treturn color;\n}\n\nvec3 GetColor(Ray ray, vec2 fragCoord)\n{\n\t// Branch version\n\tIntersection i = SceneIntersection(ray);\n\tvec3 color = GetLighting(i, ray.o);\n\tif(i.dist < ZMAX-EPSILON && i.specular.x > 0.0)\n\t{\n\t\tvec3 specular = i.specular;\n\t\tvec3 incident = normalize(i.p-ray.o);\n\t\tray.dir = reflect(incident,i.n);\n\t\tray.o = i.p+ray.dir*EPSILON;\n\t\t// First bounce\n\t\ti = SceneIntersection(ray);\n\t\tcolor += GetLighting(i, ray.o) * specular;\n        /* no second bounce needed, since there's just the shiny sphere.\n\t\tif(i.dist < ZMAX-EPSILON && i.specular.x > 0.0)\n\t\t{\n\t\t\tspecular *= i.specular;\n\t\t\tincident = normalize(i.p-ray.o);\n\t\t\tray.dir = reflect(incident,i.n);\n\t\t\tray.o = i.p+ray.dir*EPSILON;\n\t\t\t// Second bounce\n\t\t\ti = SceneIntersection(ray);\n\t\t\tif(i.dist < ZMAX-EPSILON && specular.x > 0.0)\n\t\t\t{\n\t\t\t\tcolor += GetLighting(i, ray.o) * specular;\n\t\t\t}\n\t\t}\n\t\t*/\n    }\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.0-vec2(1.0))*vec2(iResolution.x/iResolution.y,1.0)*2.0;\n    lm = vec3(1.5*mouse.x,0.0,3.0*mouse.y+14.0);\n\n\tvec2 pos = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n\tvec2 posAR;\n\tposAR.x = pos.x * (iResolution.x/iResolution.y);\n\tposAR.y = pos.y;\n    // fov knob\n    posAR *= 0.3;\n\tvec3 rayDir = normalize(vec3(posAR.x, posAR.y - 0.30, 1.0));\n\tRay ray;\n\tray.o = vec3(0,2.2,0);\n\tray.dir = rayDir;\n\t\n\tvec3 color = GetColor(ray, fragCoord);\n\tfragColor = vec4(color.x, color.y, color.z, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 603, 628, 628, 656], [658, 658, 706, 706, 1028], [1030, 1030, 1071, 1071, 1460], [1462, 1462, 1524, 1524, 1589], [1591, 1591, 1627, 1627, 1831], [1833, 1833, 1872, 1872, 2346], [2348, 2348, 2409, 2409, 2988], [2990, 2990, 3037, 3037, 3266], [3268, 3268, 3308, 3327, 4134], [4136, 4136, 4193, 4193, 4731]], "test": "untested"}
{"id": "wdtSWl", "name": "Torsion_pendulum_clock_simpler", "author": "Caramoule", "description": "A torsion pendulum clock made only of primitives and displayed with ray tracing.\n\nUncomment the line 513 and comment the line 514 to call a more detailed version of the object. Or check my other Shadertoy clock.", "tags": ["raytracing", "clock", "implicit", "surface"], "likes": 2, "viewed": 97, "published": "Public", "date": "1573157317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blobs - Base code by Eric Galin\n// Etienne LUQUIN\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.0;\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R)\n{\n  float u = clamp(x/R,0.0,1.0);\n  float v = (1.0-u*u);\n  return v*v*v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Segment Skeleton\n// p : point origine\n// a : point a\n// b : point b\n// e : energy associated to skeleton\n// R : radius thickness\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 u = normalize(b - a);\n    float distFinal = 0.0;\n    \n    if (dot(u, (p - a)) < 0.0)\n    {\n        distFinal = distance(p, a);\n    }\n    else if (dot(u, (p - b)) > 0.0)\n    {\n        distFinal = distance(p, b); \n    }\n    else\n    {\n        float distPA = distance(p, a);\n        float L = dot((p - a), u);\n        distFinal = sqrt( (distPA * distPA) - (L * L) );\n    }\n    return e * falloff(distFinal, R);\n}\n\n// Disk Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat disk(vec3 p, vec3 c, vec3 dir, float ray, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n                  \n    if(L < ray)\n    {\n      distFinal = abs(HP);   \n    }\n    else\n    {\n      distFinal = sqrt( ((L - ray) * (L - ray)) + (HP * HP) );\n    }\n    \n    return e * falloff(distFinal, R);\n}\n\n// Tore Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat tore(vec3 p, vec3 c, vec3 dir, float ray, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n                  \n    distFinal = sqrt( ((L - ray) * (L - ray)) + (HP * HP) ); \n    \n    return e * falloff(distFinal, R);\n}\n\n// Cylinder Skeleton\n// p : point origine\n// c : point center of skeleton\n// dir : orientation of the skeleton\n// ray : radius of skeleton\n// h : float height of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat cylinder(vec3 p, vec3 c, vec3 dir, float ray, float h, float e, float R)\n{\n    vec3 u = normalize(dir);\n    float distFinal = 0.0;\n    \n    float HP = dot(u, (p - c));\n    float distCP = distance(p, c);\n    float L = sqrt( (distCP * distCP) - (HP * HP) );\n    float hMax = max(0.0, abs(HP) - h);           \n    \n    if(L < ray)\n    {\n      distFinal = hMax;\n    }\n    else\n    {\n      distFinal = sqrt( (L - ray) * (L - ray) + hMax * hMax );\n    }\n     return e * falloff(distFinal, R);\n}\n\n// Sphere Skeleton\n// p : point origine\n// c : point center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat sphere(vec3 p, vec3 c, float ray, float e, float R)\n{\n  return e * falloff(max(0.0, distance(p, c) - ray), R);\n}\n\n// Bubble Skeleton\n// p : point origine\n// c : point center of skeleton\n// e : energy associated to skeleton\n// R : radius thickness\nfloat bubble(vec3 p, vec3 c, float ray, float e, float R)\n{\n  float distFinal = 0.0;\n  float distCP = distance(p, c);\n    \n  if(distCP < ray)\n  {\n  \tdistFinal = ray;  \n  }\n  else\n  {\n    distFinal = distCP - ray;\n  }\n  return e * falloff(distFinal, R);\n}\n\n// Box Skeleton\n// p : point origine\n// a : point corner of skeleton\n// dir : orientation of the skeleton not implemented yet\n// h : float height\n// w : float width\n// d : float depth\n// e : energy associated to skeleton\n// R : radius thickness\nfloat box(vec3 p, vec3 a, vec3 dir, float w, float h, float d, float e, float R)\n{\n  // ne prend pas enore en compte l'orientation et les valeurs negatives\n  vec3 u = normalize(dir);\n  float distFinal = 0.0;\n\n  float maxAx = a.x + w;\n  float maxAy = a.y + h;\n  float maxAz = a.z + d;    \n    \n  if(p.x < a.x)\n    distFinal += (a.x - p.x) * (a.x - p.x);\n  else if(p.x > maxAx)\n    distFinal += (maxAx - p.x) * (maxAx - p.x);\n      \n  if(p.y < a.y)\n    distFinal += (a.y - p.y) * (a.y - p.y);\n  else if(p.y > maxAy)\n    distFinal += (maxAy - p.y) * (maxAy - p.y);\n      \n  if(p.z < a.z)\n    distFinal += (a.z - p.z) * (a.z - p.z);\n  else if(p.z > maxAz)\n    distFinal += (maxAz - p.z) * (maxAz - p.z);\n    \n  return e * falloff(distFinal, R);\n}\n\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Difference\n// a,b : field function of the sub-trees\nfloat Diff(float a,float b)\n{\n    return min(a, 2.0 * T - b);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n   return min(a,b);\n}\n\n\n// Complex objects creation\n\n// Modelisation de la base horloge\nfloat Base(vec3 p, bool simplified)\n{\n  float baseCy1 = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 12.0, 0.5, 1.0, 2.0);\n  float baseDi1 = disk(p, vec3(0.0, 1.5, 0.0), vec3(0.0, 1.0, 0.0), 11.0, 1.0, 1.5);\n  float base = Blend(baseCy1, baseDi1);\n      \n  float baseDi2 = disk(p, vec3(0.0, 2.5, 0.0), vec3(0.0, 1.0, 0.0), 10.0, 1.0, 1.5);\n  base = Blend(base, baseDi2);\n    \n  float basePillar3 = cylinder(p, vec3(-3.0, 5.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 2.5, 1.0, 1.0); \n  base = Blend(base, basePillar3);\n   \n  if(!simplified)\n  {\n \t  float basePillar1 = disk(p, vec3(3.0, 3.1, 5.5), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 0.3);\n \t  base = Blend(base, basePillar1);\n      \n      float basePillar2 = disk(p, vec3(3.0, 3.1, -5.5), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 0.3);\n      base = Blend(base, basePillar2);\n\n      float holeTo1 = tore(p, vec3(0.0, 3.0, 0.0), vec3(0.0, 1.0, 0.0), 9.0, 1.0, 0.5);\n      base = Diff(base, holeTo1);\n\n      float holeCy1 = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 10.0, 1.0, 1.0, 1.0);\n      base = Diff(base, holeCy1);\n  }\n  \n  return base;\n}\n\n// Modelisation du mechanisme derriere le cadran\nfloat Battery(vec3 p, bool simplified)\n{\n  float pillarCy1 = cylinder(p, vec3(3.0, 8.0, 5.5), vec3(0.0, 1.0, 0.0), 0.3, 6.0, 1.0, 1.0);\n  float pillarCy2 = cylinder(p, vec3(3.0, 8.0, -5.5), vec3(0.0, 1.0, 0.0), 0.3, 6.0, 1.0, 1.0);\n  float battery = Union(pillarCy1, pillarCy2);  \n        \n  float batteryBox1 = box(p, vec3(-3.0, 14.0, -6.2), vec3(0.0, 1.0, 0.0), 7.0, 0.5, 12.4, 1.0, 0.2);\n  battery = Union(battery, batteryBox1);\n    \n  float batteryBox2 = box(p, vec3(-3.0, 14.5, -3.5), vec3(0.0, 1.0, 0.0), 5.2, 7.0, 7.0, 1.0, 0.2);\n  battery = Blend(battery, batteryBox2);\n    \n  float pillarCy3 = cylinder(p, vec3(-3.0, 17.0, 0.0), vec3(0.0, 1.0, 0.0), 0.6, 5.0, 1.0, 1.0); \n  battery = Blend(battery, pillarCy3);\n    \n  if(!simplified)\n  {\n      float holeBox3 = box(rotateY(p, 10.0), vec3(-5.0, 13.0, -8.2), vec3(0.0, 1.0, 0.0), 6.0, 2.0, 3.0, 1.0, 0.1);\n  \t  battery = Diff(battery, holeBox3);\n      \n      float holeBox4 = box(rotateY(p, -10.0), vec3(-5.0, 13.0, 5.2), vec3(0.0, 1.0, 0.0), 6.0, 2.0, 3.0, 1.0, 0.1);\n  \t  battery = Diff(battery, holeBox4);\n  }\n    \n  float holeBox1 = box(p, vec3(3.0, 13.0, -4.0), vec3(0.0, 1.0, 0.0), 8.0, 2.0, 8.0, 1.0, 0.2);\n  battery = Diff(battery, holeBox1);\n    \n  return battery;\n}\n\n// Modelisation du cadran \t\nfloat Dial(vec3 p, bool simplified)\n{\t\n  float dial = disk(p, vec3(3.0, 18.0, 0.0), vec3(1.0, 0.0, 0.0), 5.0, 1.0, 1.5);\n  float holeCy1 = cylinder(p, vec3(4.7, 18.0, 0.0), vec3(1.0, 0.0, 0.0), 4.3, 1.0, 1.0, 1.0);\n  dial = Diff(dial, holeCy1);\n  \n  float midSeg1 = segment(p, vec3(3.0, 18.0, 0.0), vec3(3.7, 18.0, 0.0), 1.0, 0.5);\n  dial = Union(dial, midSeg1);\n    \n  if(!simplified)\n  {\n      float twelve = segment(p, vec3(3.2, 21.5, 0.6), vec3(3.2, 22.0, 0.6), 1.0, 0.3);\n      twelve = Union(twelve, segment(p, vec3(3.2, 21.5, 0.2), vec3(3.2, 22.0, 0.2), 1.0, 0.3));\n      twelve = Union(twelve, segment(p, vec3(3.2, 21.5, -0.3), vec3(3.2, 22.0, -0.7), 1.0, 0.3));\n      twelve = Union(twelve, segment(p, vec3(3.2, 22.0, -0.3), vec3(3.2, 21.5, -0.7), 1.0, 0.3));\n      dial = Union(dial, twelve);\n\n      float three = segment(p, vec3(3.2, 17.75, 3.5), vec3(3.2, 18.25, 3.5), 1.0, 0.3);\n      three = Union(three, segment(p, vec3(3.2, 17.75, 3.9), vec3(3.2, 18.25, 3.9), 1.0, 0.3));\n      three = Union(three, segment(p, vec3(3.2, 17.75, 4.3), vec3(3.2, 18.25, 4.3), 1.0, 0.3));\n      dial = Union(dial, three);\n\n      float six = segment(p, vec3(3.2, 14.5, -0.7), vec3(3.2, 14.0, -0.4), 1.0, 0.3);\n      six = Union(six, segment(p, vec3(3.2, 14.0, -0.4), vec3(3.2, 14.5, -0.1), 1.0, 0.3));\n      six = Union(six, segment(p, vec3(3.2, 14.5, 0.3), vec3(3.2, 14.0, 0.3), 1.0, 0.3));\n      dial = Union(dial, six);\n\n      float nine = segment(p, vec3(3.2, 17.75, -3.9), vec3(3.2, 18.25, -3.5), 1.0, 0.3);\n      nine = Union(nine, segment(p, vec3(3.2, 17.75, -3.5), vec3(3.2, 18.25, -3.9), 1.0, 0.3));\n      nine = Union(nine, segment(p, vec3(3.2, 17.75, -4.3), vec3(3.2, 18.25, -4.3), 1.0, 0.3));\n      dial = Union(dial, nine);\n  }   \n    \n  return dial;\n}\n\n// Modelisation de l'engrenage qui tourne\nfloat Clockwork(vec3 p, float t, bool simplified)\n{\n  float clockwork = cylinder(p, vec3(-3.0, 10.0, 0.0), vec3(0.0, 1.0, 0.0), 0.2, 3.0, 1.0, 1.0); \n  \n  if(!simplified)\n  {\n      float t1 = t + M_PI/2.0;\n      float t2 = t + M_PI;\n      float t3 = t + (3.0 * M_PI)/2.0;\n\n      float holeSeg1 = segment(p, vec3(cos(t) - 3.0, 12.0, -sin(t)), \n                                    vec3(cos(t1) - 3.0, 8.0, -sin(t1)), 1.0, 1.4); \n      clockwork = Diff(clockwork, holeSeg1);\n\n      float holeSeg2 = segment(p, vec3(cos(t2) - 3.0, 12.0, -sin(t2)), \n                                    vec3(cos(t3) - 3.0, 8.0, -sin(t3)), 1.0, 1.4); \n      clockwork = Diff(clockwork, holeSeg2);\n  }\n    \n  return clockwork;\n}\n\n// Modelisation des aiguilles qui tournent\nfloat HandMoving(vec3 p, float t)\n{\n  float t1 = t / 12.0;\n  \n  float hands = segment(p, vec3(3.4, 18.0, 0.0), \n                        vec3(3.4, cos(t) * 3.0 + 18.0,  sin(t) * 3.0),\n                        1.0, 0.2);\n  hands = Union(hands, segment(p, vec3(3.7, 18.0, 0.0), \n                        vec3(3.8, cos(t1) * 2.0 + 18.0,  sin(t1) * 2.0),\n                        1.0, 0.2));\n  return hands;\n}\n\n// Modelisation des pendules qui tournent\nfloat PendulumMoving(vec3 p, float t)\n{\n  float t1 = t + M_PI/2.0;\n  float t2 = t + M_PI;\n  float t3 = t + (3.0 * M_PI)/2.0;\n    \n  float ball1 = sphere(p, vec3(cos(t) * 3.0 - 3.0, 6.0, sin(t) * 3.0), 1.2, 1.0, 1.0);\n  float ball2 = sphere(p, vec3(cos(t1) * 3.0 - 3.0, 6.0, sin(t1) * 3.0), 1.2, 1.0, 1.0);\n  float pendulums = Union(ball1, ball2);\n    \n  float ball3 = sphere(p, vec3(cos(t2) * 3.0 - 3.0, 6.0, sin(t2) * 3.0), 1.2, 1.0, 1.0);\n  pendulums = Union(pendulums, ball3);\n    \n  float ball4 = sphere(p, vec3(cos(t3) * 3.0 - 3.0, 6.0, sin(t3) * 3.0), 1.2, 1.0, 1.0);\n  pendulums = Union(pendulums, ball4);\n    \n  float attachSeg1 = segment(p, vec3(cos(t) * 3.0 - 3.0, 6.0, sin(t) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg1);\n    \n  float attachSeg2 = segment(p, vec3(cos(t1) * 3.0 - 3.0, 6.0, sin(t1) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg2);\n    \n  float attachSeg3 = segment(p, vec3(cos(t2) * 3.0 - 3.0, 6.0, sin(t2) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3); \n  pendulums = Blend(pendulums, attachSeg3);\n    \n  float attachSeg4 = segment(p, vec3(cos(t3) * 3.0 - 3.0, 6.0, sin(t3) * 3.0), \n                             vec3(-3.0, 6.0, 0.0), 1.0, 0.3);  \n  pendulums = Blend(pendulums, attachSeg4);\n    \n  return pendulums;\n}\n \nfloat Object_complex(vec3 p)\n{\n  float t = iTime;\n    \n  // base horloge\n  float base = Base(p, false);\n    \n  // arriere du cadran\n  float battery = Battery(p, false);\n  float finalObj = Union(base, battery);\n\n  // cadran\n  float dial = Dial(p, false);\n  finalObj = Union(finalObj, dial);\n \n  // engrenage\n  float clockwork = Clockwork(p, t, false);\n  finalObj = Union(finalObj, clockwork);\n    \n  // aiguilles\n  float hands = HandMoving(p, t);\n  finalObj = Union(finalObj, hands);\n   \n  // pendules\n  float pendulums = PendulumMoving(p, t);\n  finalObj = Blend(finalObj, pendulums);\n    \n  return finalObj;  \n}\n\nfloat Object_simplified(vec3 p)\n{\n  float t = iTime;  \n  \n  // base horloge\n  float base = Base(p, true);\n    \n  // arriere du cadran\n  float battery = Battery(p, true);\n  float finalObj = Union(base, battery);\n\n  // cadran\n  float dial = Dial(p, true);\n  finalObj = Union(finalObj, dial);\n \n  // mecanisme\n  float clockwork = Clockwork(p, t, true);\n  finalObj = Union(finalObj, clockwork);\n    \n  // aiguilles\n  float hands = HandMoving(p, t);\n  finalObj = Union(finalObj, hands);\n   \n  // pendules\n  float pendulums = PendulumMoving(p, t);\n  finalObj = Blend(finalObj, pendulums);\n    \n  return finalObj;\n}\n    \n// Potential field of the object\n// p : point\nfloat Object(vec3 p)\n{\n  p.z=-p.z;\n    \n  // utilisation de mes fonctions\n  //float v = segment(p, vec3(0.0, 0.0, 0.0), vec3(3.0, 0.0, 3.0), 1.0, 4.0);\n  //float v = disk(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 1.0, 1.0);\n  //float v = tore(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 1.0, 1.0);\n  //float v = sphere(p, vec3(0.0, 0.0, 0.0), 3.0, 1.0, 1.0);\n  //float v = bubble(p, vec3(0.0, 0.0, 0.0), 3.0, 1.0, 1.0);\n  //float v = cylinder(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 5.0, 1.0, 1.0);\n  //float v = box(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), 3.0, 5.0, 4.0, 1.0, 1.0);\n    \n  //float finalObj = Object_complex(p);\n  float finalObj = Object_simplified(p);\n\n  return finalObj - T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = Object(p);\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(0.4, 0.3, 0.75), vec3(0.75, 0.85, 1.0), d.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*Background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  //vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n  vec3 ro = vec3(0.0, 10.0, 30);\n  \n  // position camera base\n  ro = rotateY(ro, 90.0);\n  rd = rotateY(rd, 90.0);\n  ro = rotateZ(ro, -0.2);\n  rd = rotateZ(rd, -0.2);\n  \n  vec2 mouse = iMouse.xy / iResolution.xy;\n  ro = rotateY(ro, -mouse.x * 5.0);\n  rd = rotateY(rd, -mouse.x * 5.0);\n  ro = rotateZ(ro, -mouse.y * 5.0);\n  rd = rotateZ(rd, -mouse.y * 5.0);\n   \n    \n  //float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n    \n    \n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = Background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 369, 400, 400, 498], [500, 500, 531, 531, 630], [632, 632, 663, 663, 762], [765, 828, 861, 861, 934], [951, 1069, 1116, 1116, 1153], [1155, 1287, 1344, 1344, 1763], [1765, 1961, 2028, 2028, 2415], [2417, 2613, 2680, 2680, 2987], [2989, 3221, 3301, 3301, 3715], [3717, 3850, 3909, 3909, 3968], [3970, 4103, 4162, 4162, 4357], [4359, 4604, 4686, 4759, 5346], [5363, 5416, 5446, 5446, 5464], [5466, 5521, 5550, 5550, 5584], [5586, 5674, 5704, 5704, 5727], [5729, 5824, 5861, 5861, 5883], [5915, 5950, 5987, 5987, 7040], [7042, 7091, 7131, 7131, 8323], [8325, 8353, 8390, 8390, 10112], [10114, 10156, 10207, 10207, 10860], [10862, 10905, 10940, 10940, 11306], [11308, 11350, 11389, 11389, 12756], [12759, 12759, 12789, 12789, 13370], [13372, 13372, 13405, 13405, 13980], [13986, 14032, 14054, 14054, 14755], [14757, 14797, 14828, 14828, 15049], [15051, 15156, 15207, 15207, 15638], [15640, 15745, 15802, 15802, 16253], [16256, 16297, 16322, 16322, 16396], [16398, 16459, 16487, 16504, 16821], [16823, 16855, 16879, 16879, 16960], [16963, 16963, 17020, 17020, 18177]], "test": "untested"}
{"id": "wdtXDl", "name": "Codevember #7 - Mandelmonster", "author": "desertsky", "description": "Codevember 2019", "tags": ["raymarching", "sdf", "codevember"], "likes": 1, "viewed": 257, "published": "Public API", "date": "1573161709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// Formula for original MandelBulb from http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// also see https://www.shadertoy.com/view/4tGXWd\nfloat MandelBulb(vec3 pos, const int limitIterations)\n{\n    const int Iterations = 12;\n    const float Bailout = 8.0;\n    float Power = 5.0 + cos(iTime*0.325);\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < Iterations; i++)\n    {\n        r = length(z);\n        if (r > Bailout || i == limitIterations) break;   // TODO: test if better to continue loop and if() rather than break?\n\n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr = pow(r, Power-1.0)*Power*dr + iTime/10000.;\n\n        // scale and rotate the point\n        float zr = pow(r,Power);\n        theta = theta*Power;\n        phi = phi*Power;\n\n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\nfloat map(vec3 p) \n{\n    \n    float planeDist = p.y;\npR(p.xy, -90.);  \n    pR(p.yz,iTime/7.4);\n    float mm= MandelBulb(p-vec3(-2.,-.5,-.3),13);\n\n    return (mm);\n}\n\n\nfloat RM(vec3 ro, vec3 rd) \n{\n    float t = 0.;\n\n    for (int i = 0; i < 100; i++) \n    {\n    \tvec3 pos = ro + rd * t;\n    \tfloat h = map(pos);\n        \n        if(h<.001) break;\n        \n        t+=h;\n        \n        if(t>40.0) {\n            t=-1.0;\n            break;\n        }\n  \n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p) \n{\n\tvec2 e = vec2(.01,0);\n    float d = map(p);\n    \n    vec3 pointNormal = d- vec3(\n    \tmap(p-vec3(e.xyy)),\n        map(p-vec3(e.yxy)),\n        map(p-vec3(e.yyx))  \n    );\n    \n    return normalize(pointNormal);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.,0.2*uv.y,0.2*uv.y+.3);\n\n    vec3 ro = vec3(1.3,1.7,-2.);\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    float t = RM(ro,rd);\n    \n    if(t>0.0) \n    {\n\tcol = vec3(.2*sin(iTime*3.),.3*cos(iTime*4.)+uv.x,sin(iTime*3.));\n\n    vec3 pos = ro + t * rd;\n\tvec3 nor = GetNormal(pos);\n    vec3 sun_dir = normalize(vec3(2.5,2.,-1.5));\n    float sun_sha = step(RM(pos+nor*.001,sun_dir),0.);\n    float sun_dif = (clamp(dot(nor,sun_dir),.0,1.));\n    \n        \n    //shadows\n        \n    col+=vec3(.9)*sun_dif;\n    //col = mix(col,col*0.2,shadow);\n    }\n\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 74], [77, 290, 345, 345, 1176], [1178, 1178, 1198, 1198, 1342], [1345, 1345, 1374, 1374, 1655], [1657, 1657, 1682, 1682, 1896], [1900, 1900, 1957, 1957, 2618]], "test": "untested"}
{"id": "WdVSzw", "name": "MengerSponge x 4", "author": "jorge2017a1", "description": "MengerSponge x 4", "tags": ["mengerspongex4"], "likes": 2, "viewed": 63, "published": "Public", "date": "1573657906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n\n///-----------------------------------------\n\n// Distance Functions\n//float sdBox( vec3 p, vec3 b ) {\n//    vec3 d = abs(p) - b;\n//    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n//}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat dSphereCenter(vec3 p) {\n    return dSphere(p - vec3(0.0, 1.0, -0.5), 1.0);\n}\n\nfloat dSphereLeft(vec3 p) {\n    return dSphere(p - vec3(2.5, 1.0, 0.0), 1.0);\n}\n\nfloat dBar(vec2 p, float width) {\n    vec2 d = abs(p) - width;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n    float bar_x = dBar(p.yz, x);\n    float bar_y = dBar(p.zx, x);\n    float bar_z = dBar(p.xy, x);\n    return min(bar_z, min(bar_x, bar_y));\n}\n\nfloat dMengerSponge(vec3 p) \n{\n    float d = sdBox(p, vec3(1.0));\n    //float d = sdSphere (p-vec3(0.0), 3.0);\n    \n    float one_third = 1.0 / 3.0;\n    for (float i = 0.0; i < 3.0; i++) {\n        float k = pow(one_third, i);\n        float kh = k * 0.5;\n        d = max(d, -dCrossBar(mod(p + kh, k * 2.0) - kh, k * one_third));\n    }\n    return d;\n}\n\nfloat dMengerSpongeRight(vec3 p) {\n    //return dMengerSponge(p - vec3(-2.5, 1.0, 0.0));\n    return dMengerSponge(p - vec3(-1.0, 1.0, 0.0));\n}\n\n\n///--------------------------------------------\n\n//Coordinate positioning of each shape\nfloat GetDist(vec3 p) {\t\n\n \t\n    float planeDist = p.y;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    d=1000.0;\n    d=min(d,planeDist);\n    //d = min(d, sp ); \n    \n    \n    \n    dm1=dMengerSponge(p-vec3(0.,2.0,-1.0));\n    dm2=dMengerSponge(p-vec3(0.,2.0,3.0));\n    dm3=dMengerSponge(p-vec3(0.,2.0,6.0));\n    dm4=dMengerSponge(p-vec3(0.,2.0,15.0));\n    \n    d=min(d, dm1);\n    d=min(d, dm2);\n    d=min(d, dm3);\n    d=min(d, dm4);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n    \n    vec3 lightPos1 = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    vec3 lightPos2 =lpos;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(0.0, cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n    //vec3 ro = vec3(0, 2, 0);\n    \n    vec3 ro = vec3(0, 2, 5.1+10.0*sin(iTime*0.5));\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = (ro + rd * d )+texture(iChannel0, uv).x;\n    \n    \n    float dif = GetLightPos(p, ro);\n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVSzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[348, 365, 398, 398, 463], [468, 486, 522, 522, 591], [592, 607, 638, 638, 788], [789, 809, 845, 845, 932], [933, 949, 981, 1009, 1070], [1120, 1274, 1306, 1306, 1334], [1336, 1336, 1365, 1365, 1418], [1420, 1420, 1447, 1447, 1499], [1501, 1501, 1534, 1534, 1638], [1640, 1640, 1674, 1674, 1817], [1819, 1819, 1849, 1849, 2168], [2170, 2170, 2204, 2258, 2312], [2364, 2403, 2426, 2426, 2857], [2859, 2859, 2893, 2893, 3127], [3129, 3129, 3153, 3153, 3385], [3387, 3387, 3411, 3411, 3795], [3801, 3801, 3839, 3839, 4622], [4624, 4624, 4681, 4681, 5166]], "test": "untested"}
{"id": "wdVSzy", "name": "Ashoka Chakra", "author": "piyushslayer", "description": "Ashoka chakra is found at the center of the Indian flag today, which replaced (in 1947) the [i]charkha[/i] (spinning wheel) found in the pre-independence version of the flag. Looks better in full screen mode.", "tags": ["2d", "flag", "symbol", "buddhism"], "likes": 5, "viewed": 1813, "published": "Public API", "date": "1574382330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\nAshoka chakra is one of the most common depictions of the dharma chakra,\nwhich in turn is one of the oldest known symbols in Buddhism and Hinduism.\nAshoka Chakra was adopted by India in 1947 and is present at the center of the\nIndian Flag today.\n\nBest viewed in fullscreen mode.\n*/\n\n\n#define PI 3.1415926535\n\n#define ROT(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\n#define RADIUS .7\n#define HALF_RADIUS RADIUS * .5\n#define NAVY_BLUE vec3(0., 0., .534)\n\n// iq's 2d sdf for iscosceles triangles (https://www.shadertoy.com/view/MldcD7)\nfloat isoscelesTriangle(in vec2 q, in vec2 p)\n{\n    p.y -= .5;\n    p.x = abs(p.x);\n    \n\tvec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0., 1.);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0., 1.), 1.);\n    \n    float s = -sign(q.y);\n\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                  vec2(dot(b, b), s * (p.y - q.y)));\n\n\treturn -sqrt(d.x) * sign(d.y);\n}\n\nfloat getChakra(vec2 uv)\n{\n\tfloat outerCircle = smoothstep(.005, -.005, abs(length(uv) - RADIUS - .22) - .06);\n    float innerCircle = smoothstep(.22, .21, length(uv));\n    float spokes = 0., spokeThickness = .03, notches = 0., theta = 2. * PI / 24.;\n    for (int i = 0; i < 24; ++i)\n    {\n        vec2 suv = ROT(float(i) * theta) * uv;\n        // shorter inward pointing triangle\n        suv.y += HALF_RADIUS;\n        spokes += smoothstep(.005, .0,\n\t\t\t\t\tisoscelesTriangle(vec2(spokeThickness, RADIUS * .334), suv));\n        // longer outward pointing triangle\n        suv.y -= RADIUS + .005;\n        spokes += smoothstep(.005, .0,\n\t\t\t\t\tisoscelesTriangle(vec2(spokeThickness, -RADIUS * .666), suv));\n        \n        // boundary notches\n\t\tvec2 nuv = ROT(float(i) * theta + theta * .5) * uv;\n        nuv.y -= RADIUS + .16;\n        notches += smoothstep(.04, .039, length(nuv));\n    }\n    \n    float chakra = notches + innerCircle + outerCircle + spokes;\n    return max(0., 1. - chakra);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // oscillate the chakra's rotation\n    uv = ROT(sin(iTime * .2)* PI) * uv;\n\n    vec3 col = vec3(0.);\n    col += getChakra(uv) + NAVY_BLUE;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[455, 535, 582, 582, 918], [920, 920, 946, 946, 1907], [1909, 1909, 1966, 1966, 2233]], "test": "untested"}
{"id": "WdVXDW", "name": "Highway To The Sun", "author": "Soleam", "description": "Rotation achieved", "tags": ["colors", "rotation"], "likes": 5, "viewed": 112, "published": "Public", "date": "1574084851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define c0 vec3(1.,.81,.41)\n#define c1 vec3(1.,.64,.45)\n#define c2 vec3(.92,.4,.39)\n#define c3 vec3(.7,.16,.4)\n#define c4 vec3(.38,.06,.37)\n#define PI 3.1415926535897932384626433832795\n\nfloat getAngle(vec2 uv)\n{\n    float a = atan(uv.y,uv.x);\n    if(a<0.)\n    {\n        a = 2.*PI+a;\n    }\n    return a;\n}\nfloat clipAngle(float a)\n{\n    return mod(a,2.*PI);\n}\nfloat bar(vec2 uv, float a, float L, float R, float h)\n{\n    float angle = getAngle(uv);\n    float r = length(uv);\n    float radiusValue = (h-abs(R-r))/h;\n    float midAngle = 0.;\n    float angleValue = abs(a-angle);\n    if(angleValue>PI)\n    {\n        angleValue=2.*PI-angleValue;\n    }\n    \n    angleValue = smoothstep(0.,fwidth(angleValue),L-angleValue); \n    radiusValue = smoothstep(0.,fwidth(radiusValue),radiusValue); \n\t\n    return angleValue*radiusValue;\n    //return smoothstep(0.,.1,radiusValue);\n}\nfloat rond(vec2 uv, float R)\n{\n    float r = length(uv);\n    return smoothstep(0.,.05,(R-r)/R);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n   \n    \n    //first bar\n    float a1 = -iTime*6.;\n    float l1 = 2.;\n    float R1 = .25;\n    float h1 = .07;\n    \n   \tfloat alpha1 = bar(uv,clipAngle(a1),clipAngle(l1),R1,h1);\n    \n    //second bar\n    float a2 = iTime*4.;\n    float l2 = 1.5;\n    float R2 = .5;\n    float h2 = .14;\n    \n    float alpha2 = bar(uv,clipAngle(a2),clipAngle(l2),R2,h2);\n    \n    //third bar\n    float a3 = -iTime*2.;\n    float l3 = 1.;\n    float R3 = 1.;\n    float h3 = .32;\n    \n    float alpha3 = bar(uv,clipAngle(a3),clipAngle(l3),R3,h3);\n    \n    //center circle\n    float alpha4 = rond(uv,0.14);\n    \n    vec3 col = c1*alpha1+c2*alpha2+c3*alpha3+c0*alpha4;\n    \n    col+= (1.-alpha1 - alpha2 - alpha3 - alpha4)*c4;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 211, 211, 304], [305, 305, 331, 331, 358], [359, 359, 415, 415, 867], [868, 868, 898, 898, 965], [967, 967, 1024, 1074, 1901]], "test": "untested"}
{"id": "WdVXRm", "name": "Ghostly Cavern", "author": "blackle", "description": "interesting raymarched noise function with transparency effects", "tags": ["noise"], "likes": 4, "viewed": 326, "published": "Public API", "date": "1573670785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash1(float k) {\n    int x = FK(k);int y = FK(cos(k));\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float k) {\n    float r1 = hash1(k);\n    float r2 = hash1(r1);\n    float r3 = hash1(r2);\n    return vec3(r1, r2, r3);\n}\n\n//rotate P around axis AX by angle RO\nvec3 rotate(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 sphericalCoordinates(vec2 p) {\n    float phi = acos(p.x);\n    float theta = p.y*3.1415;\n    return vec3(cos(phi), sin(phi)*sin(theta), sin(phi)*cos(theta));\n}\n\nvec3 domainRepetition(vec3 p, vec3 scale) {\n    return (fract(p/scale)-0.5)*scale;\n}\n\nvec4 component(vec3 p, vec3 offset, vec3 rotation) {\n    vec3 axis = sphericalCoordinates(rotation.xy);\n    float angle = rotation.z * 3.1415;\n    p = rotate(p, axis, angle);\n    p = domainRepetition(p + offset, vec3(1));\n\n    vec3 normal = rotate(normalize(p), axis, -angle);\n    return vec4(length(p)-0.48, normal);\n}\n\nvec4 scene(vec3 p) {\n    vec4 accum = vec4(0.);\n    float iters = 5.;\n    for (float i = 0.; i < iters; i++) {\n    \tvec3 off = hash3(i);\n    \tvec3 rot = hash3(hash1(i));\n    \taccum += component(p, off, rot);\n    }\n    return accum/sqrt(iters*1.5)-0.1;\n}\n\nfloat phong(vec3 norm, vec3 light) {\n    return abs(dot(norm, light));\n}\n\nvec3 shade(vec3 p, vec3 norm, vec3 cam) {\n    float d1 = length(sin(p)*0.5+0.5)/sqrt(3.);\n    float d2 = length(sin(norm)*0.5+0.5)/sqrt(3.);\n    return sqrt(phong(norm, cam)*( d1*vec3(0.8,0.2,0.1) + (1.-d2)*vec3(0.3,0.6,0.9)  ));\n}\n\nvoid castRay(vec3 cam, inout vec3 p, inout vec4 dist) {\n    float sgn = 1.;\n    for (int i = 0; i < 100; i++) {\n        dist = scene(p);\n        if (i == 0) sgn = sign(dist.x);\n        if (abs(dist.x) < 0.001) return;\n        p += cam*dist.x*sgn;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    fragColor = vec4(0.0);\n    \n    vec3 cam = normalize(vec3(0.5, uv));\n    vec3 init = vec3(iTime,0.,0.);\n    vec3 p = init;\n    vec4 dist; vec3 norm;\n    castRay(cam, p, dist);\n    norm = normalize(dist.yzw);\n    vec3 col1 = shade(p, norm, cam);\n    \n    float pdist = distance(p, init);\n    float transparency = pow(1./(pdist+1.),8.);\n    float fog1 = pow(exp(-pdist*0.5)/exp(0.),0.5);\n    \n    vec3 col2 = col1;\n    if (transparency > 0.02) {\n    \tp+=cam*0.1;\n        init = p;\n    \tcastRay(cam, p, dist);\n    \tnorm = normalize(dist.yzw);\n    \tcol2 = shade(p, norm, cam);\n    }\n\n    float pdist2 = distance(p, init);\n    float fog2 = pow(exp(-pdist2*0.5)/exp(0.),0.5);\n    \n    fragColor.xyz = mix(col1*fog1, col2*fog2, transparency);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVXRm.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 249, 271, 271, 355], [357, 357, 378, 378, 486], [488, 526, 566, 566, 632], [634, 634, 669, 669, 797], [799, 799, 842, 842, 883], [885, 885, 937, 937, 1204], [1206, 1206, 1226, 1226, 1459], [1461, 1461, 1497, 1497, 1533], [1535, 1535, 1576, 1576, 1766], [1768, 1768, 1823, 1823, 2022], [2024, 2024, 2081, 2131, 2934]], "test": "untested"}
{"id": "wdVXz1", "name": "CDA_qAZ_Live04_SkyPath.glsl", "author": "Cephalopodium", "description": "From Antoine Zanuttini  Live Session 04 Tutorial, SkyPath like a misty Chinese bridge journey.\n", "tags": ["test", "tutorial", "fromyt", "azlive04"], "likes": 9, "viewed": 167, "published": "Public", "date": "1574495122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Name: CDA_AZ_Live04_SkyPath.glsl\n// Tags: Test, AZ_Live04, Tutorial, from YT\n// Desc: From Antoine Zanuttini  Live Session 04 Tutorial, \n// SkyPath like a misty Chinese bridge journey.\n// Last update 19/11/19 09:10\n// Tut time 01:20:00 of 01:22:05\n// #version 410 core (Shadertoy Throws err.. must occur 1st, except comments!  \n\n/* \nfloat rnd(vec2 uv) {\n   return fract(sin(dot(uv,vec2(127.478,36.874))) * 77894.6214 + 0.395);}\nfloat rnd(vec3 uvw) {\n   return fract(sin(dot(uvw,vec3(127.478,36.874,423.879)))*77894.6214+0.395);}\nvec2 rnd2(vec2 uv) {\n   vec2 tmp = vec2(dot(uv,vec2(127.478,36.874)),\n                   dot(uv,vec2(745.195,9413.6845)));\n   return fract(sin(tmp) *vec2(77894.6214,96843.1243)+vec2(0.395,0.745));}\nvec3 cdaCol(int a) {\n     vec3 tmp = vec3(0);\n     tmp = vec3(\n        abs(sin(cos(iTime+3.)*2.*1.+iTime)),\n        abs(cos(sin(iTime+2.)*3.*1.+iTime)),\n        abs(cos(sin(iTime+5.)*7.*1.+iTime))); // 0.5);\n     if (a==0) {\n        return tmp;\n     } else {\n        return vec3(1.-tmp.x,1.-tmp.y,1.-tmp.z);\n     }}\nfloat sph(vec3 p, float r) {\n    return length(p)-r;}\nfloat plane(vec3 p,vec3 n, float d) {\n    return dot(p,n)-d;}\nfloat vmax(vec3 p) {\n    return max(max(p.x,p.y),p.z);}\nvec3 rep(vec3 p,vec3 s) {\n    return (fract((p)/s)-0.5)*s;}\nvec3 clamp3(vec3 v,vec3 m1, vec3 m2) {\n    return vec3(clamp(v.x,m1.x,m2.x), \n                clamp(v.y,m1.y,m2.y),\n                clamp(v.z,m1.z,m2.z));}\nfloat smin(float a,float b,float c) {\n    float h = clamp(0.5+0.5*(b-a)/c,0.,1.);\n    return mix(b,a,h) - h*c*(1.-h);}\nfloat sdf(vec3 p) {\n    float s1a = sph(p + vec3(0,-1,0),2.0);\n    float s1b = sph(p + vec3(0,-2.8,2),2.4);\n    float s1c = sph(p + vec3(0,-0.1,0.6),1.8);\n    float s1 = max(-s1c,max(s1a,-s1b));\n\n    float p1 = plane(p,vec3(0,1,0),-1.0);\n    float b1 = box(p+vec3(0,.3,0),vec3(2.5,1.0,2.5)); // was ..vec3(1,0,0)...\n    vec3 mm = clamp3(p,vec3(-8,-1,-8),vec3(8,1,8));\n    float dec = 1.5;\n    float ss = 0.9;\n    float s2=sph(rep(mm-vec3(0.0,0.8,0.0),vec3(3)),ss);\n    float s3=sph(rep(mm-vec3(dec,0.8,0.0),vec3(3)),ss);\n    float s4=sph(rep(mm-vec3(0.0,0.8,dec),vec3(3)),ss);\n    float s5=sph(rep(mm-vec3(dec,0.8,dec),vec3(3)),ss);\n    float md = 0.5;    // sharpness of ground spheres, try .01\n    float smallSpheres = smin(smin(s2,s3,md),smin(s4,s5,md),md);\n\n    float m1 = smin(s1,p1,0.4);\n    float m2 = smin(m1,b1,0.4);\n    float m3 = smin(m2,smallSpheres,0.2);\n    return m3;}  */\n\nint lvl=1;\nfloat PI = acos(-1.);\n\nfloat sph(vec3 p, float r) {\n    return length(p)-r;}\n\nfloat box(vec3 p, vec3 s) {\n    vec3 ap=abs(p)-s;\n    return length(max(vec3(0.),ap))+min(0.,max(ap.x,max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n    float ca=cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n    vec3 off=vec3(0);\n    off.x += sin(p.z*.6)*.7;  // horizontal wiggle\n    off.x += sin(p.z*.017)*1.5;\n    off.y += cos(p.z*.27)*.5;  // vertical wiggle\n    off.y += cos(p.z*.34)*.25;\n   return off;\n}\n\nfloat stair(vec3 p,float s1,float s2) {\n    p.z = (fract(p.z/s1-0.5)-0.5)*s1; // creates infinite line of boxes\n    p.yz *= rot(PI*0.25);  // box turned on its side \n    float b = box(p,vec3(s2,s1,s1)); // was (s1) makes stair x-axis wider\n    return b;\n}\n\nfloat map(vec3 p) {\n    float rep = 10.;                    // stair-bridge repeat val\n    p.y -= max(0.,abs(p.x)-10.)*0.3;    // height of stair bridges \n    p.x = (fract(p.x/rep-0.5)-0.5)*rep; // duplicate stair bridges \n    p += tunnel(p);       // Adds horiz. & vertical wiggle to stairs \n    vec3 rp = p;\n    float tar= 0.0;\n    float at = 0.0;         // chase this light ?\n    float boxrep = 10.0;                             // stilt repeat rate \n    rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;\n    vec3 rp2 = p;\n    float boxrep2 = 1.0;                             // HR stake repeat rate  \n    rp2.x = abs(rp2.x)-0.4;                          // doubles handrail fence\n    rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;\n/*\n    vec3 rp3 = p;\n    float boxrep3 = 2.0;                             // HR stake hole repeat rate \n    rp3.x = abs(rp3.x)-0.4;                          // @doubles stake hole\n    rp3.z = ((fract(rp3.z/boxrep3-0.5)-0.5)*boxrep3);    // -1. offsets stake holes to avoid stilts\n*/\n    float b = box(rp+vec3(0.,-9.,0.),vec3(.6,10.5,.6)); // box like stilt, boxsize\n    vec3 rp3=rp+vec3(0.,1.5,0.);          // define stilt roof\n    rp3.xy*=rot(PI*.3); // *iTime);  // turn it round z axis\n    rp3.yz*=rot(PI*.3); // *iTime);  // turn it round x axis \n//    rp3.xz*=rot(PI*.3); // *iTime);  // CDA turn it round y axis \n    float b2 = box(rp3,vec3(0.7));    // .7 roof size\n    b2 = max(b2,p.y+1.5);             // 1.5 cutoff for bottom of roof\n    b  = min(b,b2);                   // add it to stilt\n\n    float st = stair(p,0.1,0.4);                     // was box(p,vec3(0.5))\n    float st2 = stair(p + vec3(0.,.7,0.),0.6,0.4);   // stilt hole, ceil & floor\n    b = max(b, -st2);      // removes hole from stilt\n\n    float c=box(rp2+vec3(-.05,.3,0),vec3(.05,.3,.2)); // HR stake,path pos., boxsize \n          // CDA fix - prevents showing HRs in \"caves\" path x-offset=-.05\n    rp2.y = abs(rp2.y+0.43)-0.1;       // doubles HR, rail height & separation\n    rp2.x = abs(rp2.x-0.05);           // CDA fix offset into HR \"stake\"\n\n    c = min(c,box(rp2,vec3(.01,.01,1.))); // HR height,HR dim.Was +v3(0,.5,0),was .03\n/* \n    float e = sph(rp3+vec3(-.05,.3,0.),.2);  // define stake holes \n //   rp3.x = abs(rp3.x-0.)+.0;                 // CDA fix offset into HR \"stake\"\n    e = max(st2,sph(rp3+vec3(-.05,.3,0.),.13));       // removes hole from stake\n    c = min(c, e)*1.01; //                            // combines hole with handrails\n*/\n//    return(max(c,e)); // min(st,min(c,b)));  \n    return min(c,min(b,st));      // Combines handrails, with stilt with stair \n    // length(p)-0.5;  // AZ debug\n}\n\nvec3 norm(vec3 p) {\n   vec2 off = vec2(0.01,0.0);\n   return normalize(map(p)-vec3(map(p-off.xyy), \n                    map(p-off.yxy),\n                    map(p-off.yyx)));\n}\n \nfloat rnd(vec2 uv) {\n   return fract(sin(dot(uv,vec2(127.478,36.874))) * 77894.6214 + 0.395);\n}\n\nfloat rnd(float t) {\n   return fract(sin(t*435.232)*7412.223);\n}\n\nfloat curve(float t,float d) {\n   float g=t/d;\n   return mix(rnd(floor(g)),rnd(floor(g)+1.),pow(smoothstep(0.,1.,fract(g)),10.));\n}\n\nfloat curve2(float t,float d) {\n   float g=t/d;\n   float ig= floor(g);\n   float fg= fract(g);\n   fg = pow(fg,rnd(ig)*2.+.5);\n   fg = smoothstep(0.,1.,fg);\n   return (ig+fg)*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = vec2(fragCoord.x/ iResolution.x, \n                   fragCoord.y/ iResolution.y);     // AZ\n    uv -= 0.5;                                      // AZ\n    uv /= vec2(iResolution.y / iResolution.x,1);    // AZ \n    float rand=rnd(uv);\n    float dither = 0.8+0.1*rand;\n\n    vec3 s = vec3(0.,-1,0); // was vec3(0.,-1.+sin(iTime)-1.,-3.); \n                            // Skews stair angle,was (0,0,-3)\n                                // +sin(iTime) rotates stairs around y axis \n    vec3 t = vec3(0,-0.3,3);    // was vec3(0), -.3 lowers horizon\n    vec3 tar = vec3(0,-0.7,3);    // was vec3(0), -.7 raises Follow Light\n// @\n    int cda = 0;                 // var to control CDA mode when >0\n    float ttt = iTime;\n\n    bool done=false;\n    float tSplit = 30.0;        // number of seconds to split\n    // display split 50/50 by time\n    if (ttt/tSplit-float(int(ttt/tSplit))>.5) {\n //   if (int(ttt/tSplit*2.0)%2==0) {\n        if (!done) {\n      //    cda=int(rnd(ttt)*6.);\n       //   cda++;\n          cda=(cda%6)+1;\n        }    \n        done=true;   \n    } \n    // @\n    float motion = 0.0;\n    if (cda!=0) {\n       ttt*=0.42;      // CDA slow it down\n//       motion=ttt;     // CDA disable seasickness from adding curve above  \n    }\n    motion=curve2(ttt*1.5,0.8)*3.0; // slides viewpoint back & forth on path\n    \n    s.z += motion;            // moves camera\n    t.z += motion;\n    float offset= 15.0;\n    tar.z += (curve2(ttt*1.5-offset, 1.1)+offset)*3.0+pow(curve(ttt,.9),3.)*5.;\n  //  tar.z += ttt *1.5*3.0; // +pow(curve(ttt,.7),2.)*5.;\n  //  tar.z += ttt + pow(curve(ttt,.7),2.)*5.; // slides FL back and forth on path\n\n    s-=tunnel(s);             // camera follows along stair path \n    vec3 offt=tunnel(t);      // \n    t-=offt;\n    tar-=tunnel(tar); \n    if (cda!=0) {\n       if (cda>=4) {  \n          s.yz *= rot(ttt*0.25);     // s.yz=dolphin t*=.2\n       } else {\n         if (cda>=3) {       \n            s.xy *= rot(ttt*0.0125); // s.xy=petFly  t*=.0125\n         } else {\n           if (cda>=2) { \n              s.xz *= rot(ttt*0.5);  // Spins on y axis, s.xz=Copter t*=.5\n           }\n         }\n       }  \n    }\n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz,vec3(0,1,0)-offt*0.2));\n    vec3 cy=normalize(cross(cz,cx));\n    vec3 r=normalize(cx*uv.x+cy*uv.y + cz*(.7+sin(ttt*2.)*.4));  \n    // normalize(-uv,.8); .8=zoom  , cz(sin()) gives FOV Distortions\n    vec3 col = vec3(0);\n    vec3 back = vec3(0);\n    vec3 back2 = vec3(0);\n\n    vec3 ln = normalize(vec3(-.7,-1.,-0.5)); //s y-spin only sways, was v3(-1)\n    if (cda==0) {   \n       back = mix(vec3(.1,.3,1.)*.1,vec3(1.,.3,.5)*.5, \n                    pow(r.y*.5+.5,2.)); // Controls Blue to Maroon \n    } else {\n//     back2 = mix(vec3(.1,.3,1.)*.1,vec3(1.,.3,.5)*.5, \n//                     1.-pow(r.y*.5+.5,2.)); // for at2 but unused \n//     back = mix(vec3(.5,.5,.5)*.1,vec3(1.,.5,.4)*.5, \n//                      pow(r.y*.5+.5,1.9)); // CDA Controls Grey to Orange \n       back = mix(vec3(1.-cos(ttt/3.),.65,.5)*.1,vec3(0.4,.5,sin(ttt/5.))*.5, \n                      pow(r.y*.5+.5,2.)); // CDA Time varying colour controls\n    }\n    vec3 p=s;\n    float dd = 0.;\n    int i=0;\n    float at = 0.0;         // chase this light ?\n    float at2 =0.0; \n\n    for (i=0;i<100;++i) {\n        float d = map(p)*0.9; // .9 const controls details\n        if (d<0.001) {\n           vec3 n = norm(p);\n   //        dd = length(p-s);\n           float fog = clamp(10.-dd*.018,0.,1.);  // .018 is fog strength\n           float bot = pow(clamp(-(p.y-10.)*.1,0.,1.),2.)*fog;\n//           fog *= clamp(-p.y+10.,0.,1.);\n           float aodist=.3;                   // ambient occlusion distance\n           float ao=clamp(map(p+n*aodist)/aodist,0.,1.); // ambient occlusion value\n           ao=mix(ao,1.0,0.3);\n           float f = pow(1.-dot(n,-r),2.);\n           col += vec3(.3,.4,.7)*max(0.,dot(n,ln))*bot*ao; // abs(n)*.5; AZ debug RGB\n           col += 4.*f*back*2.*(-n.y*.5+.5)*bot*ao; // blue Light, back was v3(.5,.6,1.)\n//           col += mix(col,vec3(.1,.3,1.),bot); // *0.05*exp(dd*0.04);\n           dd = mix(100.,d,bot);\n           break;\n        }\n        if (dd>100.) { \n           dd= 100.;\n           break;\n        }\n        p  += d*r;\n        dd += d;\n        if (cda==0) {\n            at+=exp(-length(tar-p)*7.);  // 7. Follow Light brightness, higher is dimmer\n            at2+=exp(-d*.1)*.05;         // \n        } else {\n            at+=exp(-length(tar-p)*6.);  // 7. Follow Light brightness, higher is dimmer\n            at2+=exp(-d*.05)*.075;          // brighter\n        }\n    }\n    if (i>99) dd=100.;\n    if (cda==0) {\n      col += vec3(1.,.3,.5) * at * 3.3;     // Follow Light colour fringe, 3.3 is  size\n      col += vec3(1.,.3,.5) * at2 * 0.2;\n      col += back*0.05*exp(dd*0.05); // ++blue thru fog, exp(dd*light[0..1]) , \n                                         // back was vec3(.1,.3,1.)\n    } else {\n      col += vec3(1.,.93,.5) * at * 3.3;     // Follow Light colour fringe, 3.3 is  size\n      col += vec3(1.,.3,.5) * at2 * 0.2;\n      col += back*0.025*exp(dd*0.04635); // ++blue thru fog, exp(dd*light[0..1]) , \n                                         // back was vec3(.1,.3,1.)\n    }\n    /*\n    if (int(ttt)>10) { \n       if (lvl%5==0) {\n           lvl=0;           \n       } else {\n           lvl++;\n       } \n       cda+=1; // lvl%5;\n//       col=vec3(float(lvl)/5.); // vec3(lvl,cda,int(iTime)%15);\n    } */\n    // Output to screen\n\n    fragColor = vec4(col,1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 2476, 2504, 2504, 2529], [2531, 2531, 2558, 2558, 2652], [2654, 2654, 2673, 2673, 2748], [2750, 2750, 2771, 2771, 2974], [2976, 2976, 3015, 3015, 3231], [3233, 3233, 3252, 3252, 5867], [5869, 5869, 5888, 5888, 6043], [6046, 6046, 6066, 6066, 6141], [6143, 6143, 6163, 6163, 6207], [6209, 6209, 6239, 6239, 6340], [6342, 6342, 6373, 6373, 6519], [6521, 6521, 6578, 6578, 12072]], "test": "untested"}
{"id": "wdVXzh", "name": "Bitwise Beauty", "author": "drewlark", "description": "Source code is fairly self explanatory. Click screen and move mouse to \"zoom\" in and out", "tags": ["xor", "bitwise", "and", "or", "bitwiseoperations"], "likes": 4, "viewed": 70, "published": "Public", "date": "1573460883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float SPEED = pow(iTime/20.0,2.0);\n    \n    ivec2 iCoord = ivec2(fragCoord);\n    \n    \n    \n   \tint red = iCoord.x ^ iCoord.y;\n    int green = iCoord.x & iCoord.y;\n    int blue = iCoord.x &~ iCoord.y;\n    \n    \n    vec3 col = vec3(red,green,blue);\n\n    // Output to screen\n    fragColor = vec4(col, 1) * SPEED;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 374]], "test": "untested"}
{"id": "WdVXzR", "name": "Knob Industrial", "author": "andremichelle", "description": "Let's build more knobs...", "tags": ["knob"], "likes": 4, "viewed": 197, "published": "Public API", "date": "1573253067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define N 12.\n\n// https://vogerdesign.com/collections/latest-ui-kits/products/vintage-dials-dark-set-vol-2\n\nvec4 check(vec2 uv) {\n    return vec4(vec3(0.02*mod(floor(5.0*uv.x)+floor(5.0*uv.y),2.0)), 1.);\n}\n\nfloat Hash(in vec2 p, in float scale) {\n\treturn fract(sin(dot(mod(p, scale), vec2(27.16898, 38.90563))) * 5151.5473453);\n}\n\nfloat Noise(in vec2 p, in float scale ) {\n\tvec2 f;\n\tp *= scale;\n\tf = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(Hash(p, scale),\n\t\t\tHash(p + vec2(1.0, 0.0), scale), f.x),\n\t\t\tmix(Hash(p + vec2(0.0, 1.0), scale),\n\t\t\tHash(p + vec2(1.0, 1.0), scale), f.x), f.y);\n}\n\nfloat fBm(in vec2 p) {\n\tfloat f = 0.0;\n\tfloat scale = 10.;\n    p = mod(p, scale);\n\tfloat amp   = .6;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += Noise(p, scale) * amp;\n\t\tamp *= .5;\n\t\tscale *= 2.;\n\t}\n\treturn min(f, 1.0);\n}\n\nvec4 over( in vec4 a, in vec4 b ) {\n    return mix(a, b, 1.-a.w);\n}\n\nfloat nCap(vec2 uv, float angle) {\n    const float r1 = 0.44;\n    float a = atan(uv.y, uv.x)+angle;\n    float b = a/PI*N/2.-.25;\n    float f = fract(b);\n    float l = length(uv);\n    float d = step(f, r1);\n    return (1.-d*0.1)*.5-l;\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/-iResolution.y*2.0;\n    vec2 st = uv+vec2(.0,-.16); // shadow offset\n    float av = sin(iTime*.5)*PI*.8; // angle value\n    mat2 mat = mat2(cos(av), -sin(av), sin(av), cos(av));\n    \n    float a = atan(uv.y, uv.x);\n    float l = length(uv);\n\tfloat sCap = nCap(uv, av); // n-gon shape\n\tfloat dCap = nCap(st, av); // shadow\n\n    float noise = fBm(uv*mat*1.2);\n    vec3 col0 = vec3(.08,.20, .28);\n    vec3 col1 = vec3(.18,.39, .28);\n    vec3 col2 = vec3(.10,.28, .39);\n\n    vec3 colN = vec3(pow(noise, 2.0)+.04);\n    mat2 m = mat2(cos(av), sin(av), -sin(av), cos(av));\n    \n    float lineS = line(uv, vec2(.0, -.14)*m, vec2(.0, -.5)*m)-.05;\n    float capShape = max(-lineS*.75, l-0.386);\n    \n    vec4 col;\n    \n    float g = -1. + smoothstep(.75, -.75, uv.y) * 1.5;\n\tcol = vec4(g*.02+.16);\n    col = over(vec4(vec3(.0), max(smoothstep(0.01, 0.1, dCap+.08), smoothstep(0.02, 0.01, length(st)-0.5))*.8), col); // shadow\n    col = over(vec4(vec3(g*.06+.04), smoothstep(0.02, 0.01, l-0.5)), col); // bottom edge\n    col = over(vec4(vec3(colN*.02), smoothstep(0.02, 0.01, l-0.48)), col); // bottom fill\n    col = over(vec4(vec3(colN*.1+g*.04+col1*.1), smoothstep(0.001, 0.02, sCap)), col); // shape\n    col = over(vec4(vec3(1.)*(.95+g*.05), smoothstep(0.0, 0.12, .02-abs(sCap-.01))), col); // shape edge\n    col = over(vec4(vec3((col0-smoothstep(0.2, 1., noise)*.03+smoothstep(0.5, 0.3, noise)*.05))+g*.03, smoothstep(0.02, 0.01, capShape)), col); // cap fill\n    col = over(vec4(vec3(0.), smoothstep(0.008, 0.0, abs(capShape-.01))), col); // cap edge dark\n    col = over(vec4(vec3(g*.16+.20), smoothstep(0.01, 0.0, abs(capShape))), col); // cap edge tint\n\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 127, 148, 148, 224], [226, 226, 265, 265, 348], [350, 350, 391, 391, 638], [640, 640, 662, 662, 856], [858, 858, 893, 893, 925], [927, 927, 961, 961, 1162], [1164, 1164, 1211, 1211, 1330], [1332, 1332, 1389, 1389, 3104]], "test": "untested"}
{"id": "wdVXzV", "name": "Sphere to octahedron", "author": "tomoe", "description": "deformation", "tags": ["raymarching"], "likes": 4, "viewed": 238, "published": "Public API", "date": "1574517574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define INFTY 1e6\nfloat wireBox(vec3 p) {\n    vec3 q = abs(p) - 0.5;\n    vec3 r = -1.0 * min(q, 0.0);\n    float minVal = min(r.x, min(r.y, r.z));\n    float maxVal = max(r.x, max(r.y, r.z));\n    float midVal = min(max(r.x, r.y), min(max(r.y, r.z), max(r.z, r.x)));\n    return sqrt(pow(length(max(q, 0.0)), 2.0) + pow(minVal, 2.0) + pow(midVal, 2.0));\n}\nfloat box(vec3 p) {\n    vec3 q = abs(p) - 0.5;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\nfloat oct(vec3 p) {\n    return abs(p.x) + abs(p.y) + abs(p.z) - 1.0;\n}\nfloat sphere(vec3 p) {\n    return length(p) - 0.5;\n}\nfloat sphereCloud(vec3 p) {\n    p = abs(p);\n    return length(mod(3.0 * p, 1.0) - 0.5) - 0.4 * (1.0 - max(max(p.x, p.y), p.z));\n}\nfloat surfaceSDF(vec3 p) {\n    float t = abs(mod(iTime * 0.3, 6.0) - 3.0);\n    float val;\n    if (t < 1.0)val = mix(sphereCloud(p), box(p), clamp(t, 0.0, 1.0));\n    else if (t < 2.0)val = mix(box(p), wireBox(p), clamp(t - 1.0, 0.0, 1.0));\n    else val = mix(wireBox(p), oct(p), clamp(t - 2.0, 0.0, 1.0));\n    return val;\n}\n\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nvec3 getNormal(vec3 p) {\n    float d = EPSILON;\n    return normalize(vec3(\n            surfaceSDF(p + vec3(d, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec3(0.0, d, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec3(0.0, 0.0, d)) - surfaceSDF(p)\n    ));\n}\n    \nmat3 rotX(float t) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(t), cos(t),\n        0.0, - cos(t), sin(t)\n    );\n}\nmat3 rotY(float t) {\n    return mat3(\n        sin(t), 0.0, cos(t),\n        0.0, 1.0, 0.0,\n        - cos(t), 0.0, sin(t)\n    );\n}\nmat3 scalar(float t) {\n    return mat3(\n        t, 0.0, 0.0,\n        0.0, t, 0.0,\n        0.0, 0.0, t\n    );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 lightDir = vec3(0.0, 2.0, 2.0);\n    \n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 2.0);\n    vec3 cDir = vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    float t = iTime * 0.3;\n    mat3 g = rotX(t) * rotY(t);\n    cPos = g * cPos;\n    cDir = g * cDir;\n    cUp = g * cUp;\n    vec3 cSide = cross(cDir, cUp);\n    \n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    float ang = getAngle(ray, - normalize(cPos));\n    vec3 rPos = cPos + (1.0 / cos(ang)) * ray;\n    \n    // marching loop\n    for(int i = 0; i < 120; i ++ ) {\n        rPos += 0.015 * ray;\n        if (surfaceSDF(rPos) < 0.01) {\n            break;\n        }\n    }\n    vec3 normal = getNormal(rPos);\n    float diff = clamp(dot(normalize(lightDir - rPos), normal), 0.01, 1.0);\n    \n    // hit check\n    if (surfaceSDF(rPos) < 0.01) {\n        fragColor = vec4(diff * vec3(rPos.x, 1.0, rPos.p), 1.0);\n    } else {\n        fragColor = vec4(vec3(1.0, 1.0, 1.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 87, 87, 397], [398, 398, 417, 417, 514], [515, 515, 534, 534, 585], [586, 586, 608, 608, 638], [639, 639, 666, 666, 768], [769, 769, 795, 795, 1091], [1093, 1093, 1125, 1125, 1177], [1178, 1178, 1202, 1202, 1450], [1456, 1456, 1476, 1476, 1584], [1585, 1585, 1605, 1605, 1713], [1714, 1714, 1736, 1736, 1824], [1825, 1825, 1880, 1880, 3013]], "test": "untested"}
{"id": "wdySDV", "name": "CircleShadowCast2D", "author": "yp3y5akh0v", "description": "Casting shadows with circles", "tags": ["glsl"], "likes": 3, "viewed": 161, "published": "Public", "date": "1574999846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_TRACE_STEPS 20\n#define EPS 0.0001\n#define N 5\n\nstruct Circle {\n    vec2 pos;\n    float r;\n    vec3 color;\n};\n\nCircle obstacles[N];\nCircle light;\n    \nfloat CircleSDF(vec2 pos, Circle c) {\n    return length(pos - c.pos) - c.r;\n}\n\nfloat SceneSDF(vec2 pos) {\n    float result = CircleSDF(pos, obstacles[0]);\n    for (int i = 1; i < N; i++) {\n        result = min(result, CircleSDF(pos, obstacles[i]));\n    }\n    return result;\n}\n\nfloat ShadowCasting(vec2 pos) {\n    vec2 resultPos = pos;\n    float resultDist = 0.;\n    vec2 dir = normalize(light.pos - pos);\n    for (int i = 0; i < MAX_RAY_TRACE_STEPS; i++) {\n        float d = SceneSDF(resultPos);\n        if (abs(d) < EPS) {\n            break;\n        }\n        resultPos += d * dir;\n        resultDist += abs(d);\n    }\n    return resultDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec3 c = vec3(0.);\n\n    light = Circle(vec2(0.5), 0.05, vec3(1.));\n    light.pos.x += cos(iTime) / 2.5;\n\n    vec2 lightToUV = uv - light.pos;\n    c += light.r / pow(length(lightToUV), 0.8);\n\n    obstacles[0] = Circle(iMouse.xy / iResolution.y, 0.03, vec3(1., 0, 0));\n    obstacles[1] = Circle(vec2(0.3, 0.3), 0.04, vec3(0.4, 0.3, 0.7));\n    obstacles[2] = Circle(vec2(0.7, 0.2), 0.1, vec3(1., 0.7, 0));\n    obstacles[3] = Circle(vec2(0.6, 0.7), 0.02, vec3(1., 0, 1));\n    obstacles[4] = Circle(vec2(0.2, 0.7), 0.06, vec3(0., 0.5, 1.));\n    \n    for (int i = 0; i < N; i++) {\n        c += length(uv - obstacles[i].pos) < obstacles[i].r ? \n            obstacles[i].color :\n            vec3(0);\n    }\n\n    float surfDist = ShadowCasting(uv);\n    if (surfDist < length(lightToUV) - EPS) {\n        c *= 0.5;\n    }\n\n    fragColor = vec4(c, 1.);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdySDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 203, 203, 243], [245, 245, 271, 271, 441], [443, 443, 474, 474, 809], [811, 811, 868, 868, 1761]], "test": "untested"}
{"id": "WdySDW", "name": "filtering, mitchell, separable", "author": "hornet", "description": "comparing radial and separable evaluations of the mitchell-netravali filter, see http://mentallandscape.com/Papers_siggraph88.pdf\nsee also https://www.shadertoy.com/view/4sGcRW\nnote that a gaussian-filter is \"actually\" separable, producing the same result", "tags": ["filtering"], "likes": 0, "viewed": 40, "published": "Public", "date": "1574713751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//note: range [-2;2]\n//note: not normalized\nfloat Mitchell1D(float x)\n{\n    //const float B = 0.0; //Catmull-Rom?\n\tconst float B = 1.0/3.0; //Mitchell\n\tconst float C = 0.5 * (1.0-B);\n\tx = abs( 2.0 * x );\n    if ( x > 2.0 )\n        return 0.0;\n\tif (x > 1.0)\n\t\treturn ((-B - 6.0*C) * x*x*x + (6.0*B + 30.0*C) * x*x + (-12.0*B - 48.0*C) * x + (8.0*B + 24.0*C)) * (1.0/6.0);\n\telse\n\t\treturn ((12.0 - 9.0*B - 6.0*C) * x*x*x + (-18.0 + 12.0*B + 6.0*C) * x*x + (6.0 - 2.0*B)) * (1.0/6.0);\n}\nfloat FilterMitchell_sep(vec2 p, vec2 r)\n{\n    p /= r;\n    return Mitchell1D(p.x) * Mitchell1D(p.y);\n}\nfloat FilterMitchell_rad(vec2 p, vec2 r)\n{\n    p /= r;\n    return Mitchell1D( length(p) ); //note: radius version...\n}\n\n// =======================\n\nfloat Gaussian( float x )\n{\n\tconst float alpha = 4.0;\n\tconst float expv = exp(-alpha); //note: radius = 1.0\n    return max(0.0, (exp(-alpha * x * x) - expv));\n    //return max(0.0, (exp(-alpha * x * x) - expv) / (1.0-expv)); //note: normalisation-factor to always get f(0)=1\n}\nfloat FilterGaussian_sep(vec2 p, vec2 radius )\n{\n    p /= radius;\n\treturn Gaussian(p.x) * Gaussian(p.y);\n}\nfloat FilterGaussian_rad(vec2 p, vec2 radius )\n{\n    p /= radius;\n    \n    return Gaussian( length(p) );\n}\n\nfloat filter_sep( vec2 p, vec2 r )\n{\n    return FilterMitchell_sep( p, r );\n    //return FilterGaussian_sep( p, r );\n}\nfloat filter_rad( vec2 p, vec2 r )\n{\n    return FilterMitchell_rad( p, r );\n    //return FilterGaussian_rad( p, r );\n}\n\n// =======================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord/iResolution.xy;\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xx;\n    if ( uv.y > 1.0 )\n    {\n        float aspect = iResolution.x / iResolution.y;\n        float y = 0.5 * aspect;\n        float h = 1.0 - y;\n        \n        vec2 luv = vec2( fract(uv.x), (ssuv.y-y)/h);\n        luv.y = luv.y/0.7-0.2;\n        \n        float x = -1.0+2.0*luv.x;\n        float f;\n        if ( ssuv.x < 0.5 )\n            f = filter_sep( vec2(x,0.0), vec2(1.0,1.0) );\n        else\n            f = filter_rad( vec2(x,0.0), vec2(1.0,1.0) );\n\n        float z = step( abs(luv.y-0.0), 0.5*dFdy(luv.y) );\n        fragColor = vec4( mix( vec3(0.85), vec3(0.5), z ), 1.0 );\n\n        float v = step( abs(luv.y-f), 0.5*dFdy(luv.y) );\n        fragColor = vec4( mix( fragColor.rgb, vec3(0.0), v ), 1.0 );\n        \n        return;\n    }\n    uv = fract(uv);\n    //fragColor = vec4( uv, 0, 1 ); return;\n\n    const vec2 r = vec2(0.5);\n    const vec2 ctr = vec2(0.5, 0.5 );\n    vec2 p = uv - ctr;\n    float v;\n    if ( ssuv.x < 0.5 )\n    {\n        v = filter_sep( p, r );\n    }\n    else\n\t{\n        v = filter_rad( p, r );\n    }\n\n    fragColor = 0.5 + vec4(vec3(10.0 * abs(v) ), 1.0 );\n    fragColor.rgb *= (v<0.0) ? vec3(1.0, 0.0, 0.25 ) : vec3(0, 0.5, 1.0 );\n    \n    float t = abs(fract( 10.0*v + iTime )-0.5);\n    t = min( 1.0, max( 0.0, t/0.3+0.7) );\n    \n    fragColor = clamp( fragColor, 0.0, 1.0 );\n    fragColor.rgb = mix( fragColor.rgb, vec3(0.0), 1.0-t );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdySDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 71, 113, 482], [483, 483, 525, 525, 585], [586, 586, 628, 628, 704], [706, 734, 761, 761, 1010], [1011, 1011, 1059, 1059, 1117], [1118, 1118, 1166, 1166, 1224], [1226, 1226, 1262, 1262, 1344], [1345, 1345, 1381, 1381, 1463], [1465, 1494, 1551, 1551, 3003]], "test": "untested"}
{"id": "wdySRc", "name": "mandelbrot renderer", "author": "sklappal", "description": "mandelbrot ", "tags": ["mandelbrot"], "likes": 0, "viewed": 89, "published": "Public", "date": "1574625041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI   3.14159265358979323846264338327950288\n\nfloat ComplexNorm2(vec2 c) {\n  return c.x*c.x + c.y*c.y;\n}\nvec2 ComplexSum(vec2 c1, vec2 c2) {\n  return vec2(c1.x + c2.x, c1.y + c2.y);\n}\nvec2 ComplexSquare(vec2 c) {\n  return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\nfloat DivergenceSpeed(vec2 pos) {\n  vec2 zn = vec2(0.0, 0.0);\n  \n  for(int i = 0; i < 1000; i++)\n  {\n    float cn = ComplexNorm2(zn);\n    \n    if (cn > 4.0) {\n      return (float(i) + 1.0 - (log(log(sqrt(cn))) / log(2.0))) / (1000.0 + 1.0);\n    }\n    zn = ComplexSum(ComplexSquare(zn), pos);\n  }\n  return 0.0;\n}\n\nvec4 grayScale(float ds) {\n return vec4(ds, ds, ds, 1.0);   \n    \n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec4 rainbow(float ds) {\n  \treturn vec4(hsl2rgb(vec3(ds, 1.0, 0.5)), 1.0);\n}\n\nvec4 calcColor(float ds, float zoom) {\n    return mix(grayScale(ds), rainbow(ds), zoom*2.0 - 1.0);\n    \n}\n\n\nfloat myRound (float f) {\n \treturn floor(f + 0.5);   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = 2.0*fragCoord/iResolution.y - vec2(aspect*1.0, 1.0);\n\n\n    float zoomSpeed = 0.01;\n    float zoomRound = zoomSpeed * iTime;\n    float nearestWhole = myRound(zoomRound);\n    float zoomStep = sin(distance(zoomRound, nearestWhole)*M_PI);\n    float zoom = mix(1.5, 50000.0, pow(zoomStep, 10.0));\n    \n    vec2 cameras[5];\n    cameras[0] = vec2(-0.77682, -0.13576); // good\n    cameras[1] = vec2(0.2599, 0.002); // good\n    cameras[2] = vec2(-0.761560,-0.0847570); // good\n    cameras[3] = vec2(-1.6301, 0.001); // good\n    cameras[4] = vec2(-0.81152, -0.18453); // good\n    \n    \n \t\n    int cameraIndex = int(nearestWhole);\n    vec2 prevCamera = cameras[((cameraIndex-1) % cameras.length())];\n    vec2 curCamera = cameras[((cameraIndex) % cameras.length())];\n\n    \n    float t = 0.0;\n    \n    if (distance(nearestWhole, zoomRound) < 0.1)\n    {\n     \tt = (zoomRound - nearestWhole + 0.1) / 0.2;\n    }\n    \n    if (zoomRound - nearestWhole > 0.1)\n    {\n     \tt = 1.0;   \n    }\n    \n    vec2 camera = mix(prevCamera, curCamera, t);\n\n    vec2 jitter = vec2(cos(40.0*iTime*zoomSpeed), sin(20.0*iTime* zoomSpeed));\n    //vec2 jitter = vec2(0.0);\n\n    vec2 mappedPos = (camera + (1.0/zoom)*(uv + jitter));\n\n    fragColor = calcColor(sqrt(DivergenceSpeed(mappedPos)), zoomStep);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdySRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 82, 82, 112], [113, 113, 148, 148, 191], [192, 192, 220, 220, 277], [278, 278, 311, 311, 589], [591, 591, 617, 617, 658], [660, 660, 687, 687, 830], [833, 833, 857, 857, 909], [911, 911, 949, 949, 1016], [1019, 1019, 1044, 1044, 1074], [1076, 1076, 1132, 1132, 2463]], "test": "untested"}
{"id": "WdySRw", "name": "Right_Hemisphere", "author": "nolibab", "description": "Port intro 'Right Hemisphere' release for CAFe party 2019 coded by jetlag & SandS.", "tags": ["voronoi", "sdf", "pseudo3d", "hemisphere"], "likes": 4, "viewed": 154, "published": "Public", "date": "1573573562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float y,v,D,i,k,z,x,m,f,r,c,a,n;\nfloat l;\nvec3 b[16];\nfloat s;\n\nvec3 p(vec3 l,vec3 i)\n{vec3 v=sin(i),m=cos(i);\nreturn l*mat3(m.y,v.z*v.y, -v.y*m.z,\n             -v.x*v.y, m.x*m.z+v.x*v.z*m.y, v.z*m.x-v.x*m.z*m.y,\n              m.x*v.y, v.x*m.z-m.x*v.z*m.y, v.z*v.x+m.x*m.z*m.y);\n}\n\nfloat e(vec3 D,vec3 v)\n{vec3 b,m,y=vec3(.5,.5,.001);\nm=v;\nv.z=(v.z+s)*4.;\nb=D-v;\nb=p(b,(l+x)/29.*m);\nm=max(b-y,-b-y);\nreturn max(max(m.x,m.y),m.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nl = iTime;\n{\nfloat g=l,o=0.,\nt[10]=float[](0.,3.9666667,0.0333333,0.4666667,0.5333333,3.,127.7,17.2666667,318.0333333,9.),\nT[10]=float[](0.,0.3,0.3118975,-0.1418975,0.0561538,0.4738462,0.,-1.,1.,-1.);\nfor(int u=0;u<10;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\ny=o;\n}\n\n{float g=l,o=0.,\nt[8]=float[](0.,3.,9.,0.0033333,11.9966667,0.0033333,5.9966667,90.),\nT[8]=float[](300.,0.,-71.1,34.1,-20.,-109.,-47.2307692,78.4615385);\nfor(int u=0;u<8;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nv=o;\n}\n\n{float g=l,o=0.,\nt[27]=float[](0.,8.,0.0033333,1.9966667,19.,0.0333333,2.1,0.0333333,36.8333333,0.0333333,0.5,0.0333333,27.4333333,0.0033333,0.9966667,15.,0.3,0.2,0.1666667,0.2,0.1333333,7.,5.,0.0333333,0.5333333,0.3333333,1.1),\nT[27]=float[](2.8,0.,-0.1,0.1,0.,-0.2,-0.09998,0.29998,0.,0.2,0.,-0.2,0.,4.498,-0.0515385,-4.2464615,2.7905856,-0.2453174,0.1246057,-0.0996845,0.0249211,-1.5951104,0.,-0.4,0.35,-0.05,0.1);\nfor(int u=0;u<27;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nD=o;\n}\n\n{float g=l,o=0.,\nt[17]=float[](0.,16.,0.0033333,3.9966667,0.0033333,47.9966667,0.0033333,0.53,0.0033333,2.83,0.0033333,0.6633333,0.0033333,23.9633333,0.0033333,23.9966667,0.0033333),\nT[17]=float[](3.,0.,1.,0.,-1.,0.,-1.,0.,1.,0.,-1.,0.,1.,0.,-2.,0.,1.);\nfor(int u=0;u<17;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\ni=o;\n}\n\n{float g=l,o=0.,\nt[14]=float[](0.,96.,0.0033333,12.9966667,2.9666667,0.0666667,5.9666667,2.,0.0333333,4.9666667,0.0033333,17.2966667,6.6,4.0666667),\nT[14]=float[](0.,0.,1.,0.,-0.1,0.1,0.,-0.14,-0.36,-0.2,-0.3,0.,0.433125,0.266875);\nfor(int u=0;u<14;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nk=o;\n}\n\n{float g=l,o=0.,\nt[10]=float[](0.,104.,0.0333333,0.7,3.2666667,4.,0.2333333,0.1,3.3666667,4.3),\nT[10]=float[](0.,0.,0.8501577,-0.4195584,-0.2018927,-0.0189274,0.1987382,0.5914826,0.,-0.5);\nfor(int u=0;u<10;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nz=o;\n}\n\n{float g=l,o=0.,\nt[15]=float[](0.,12.,0.0033333,3.9966667,0.0033333,3.9966667,0.0033333,3.9966667,1.,55.0333333,0.0033333,7.9633333,0.0033333,7.9966667,0.0033333),\nT[15]=float[](86.,0.,78.,0.,-375.,-10.,385.,0.,-158.,0.,150.,-6.,-28.,-4.,-112.);\nfor(int u=0;u<15;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nx=o;\n}\n\n{float g=l,o=0.,\nt[16]=float[](0.,8.,0.0033333,3.9966667,0.0033333,3.9633333,0.0033333,0.0633333,3.9666667,0.0033333,60.03,0.0033333,7.9633333,0.0033333,7.9966667,0.0033333),\nT[16]=float[](-0.5,0.,0.438,0.,-0.308,0.,0.,-0.61,0.,0.48,0.,0.7,-0.2,-0.45,0.,-0.05);\nfor(int u=0;u<16;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nm=o;\n}\n\n{float g=l,o=0.,\nt[13]=float[](0.,8.,0.0033333,3.9966667,0.0033333,3.9966667,0.0033333,3.9966667,0.0033333,60.03,0.0033333,7.9633333,0.0033333),\nT[13]=float[](-0.5,0.,-0.3,0.,0.3,0.,0.78,0.,-0.78,0.,0.1,0.,-0.1);\nfor(int u=0;u<13;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nf=o;\n}\n\n{float g=l,o=0.,\nt[24]=float[](0.,8.,0.0033333,3.9966667,0.0033333,0.9966667,3.,0.0033333,3.9966667,0.0033333,3.9966667,0.0033333,6.9966667,3.,46.0333333,0.0033333,7.9633333,0.0033333,7.9966667,0.0033333,23.9966667,0.0033333,24.9966667,7.9666667),\nT[24]=float[](1.4,0.,-0.36,0.,0.16,0.,-0.0818182,-0.6381818,0.02,0.36,-0.01,0.35,0.,0.,1.18,-1.68,0.,0.6,-0.15,0.25,0.,0.25,0.55,-0.26);\nfor(int u=0;u<24;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nr=o;\n}\n\n{float g=l,o=0.,\nt[24]=float[](0.,29.,2.1333333,0.0333333,2.8666667,0.0333333,0.1,0.1333333,0.7,3.,30.,0.0333333,0.5333333,0.0333333,0.9,10.5333333,0.0333333,9.9333333,0.0333333,0.2333333,1.7333333,33.,0.0333333,1.9666667),\nT[24]=float[](0.,0.,1.,-1.,0.,0.4,0.,-0.2,-0.2,0.,0.714,-0.454,0.34,-0.26,0.41,0.25,-1.,0.,0.25,-0.02,-0.23,0.,0.6184615,-0.6184615);\nfor(int u=0;u<24;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nc=o;\n}\n\n{float g=l,o=0.,\nt[10]=float[](0.,28.,0.0333333,0.4666667,0.0333333,0.5,0.0333333,42.3333333,0.6,0.0333333),\nT[10]=float[](15.,0.,-3.4,-2.6,-5.,-4.,15.,0.,-15.,15.);\nfor(int u=0;u<10;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\na=o;\n}\n\n{float g=l,o=0.,\nt[20]=float[](0.,52.,0.0333333,0.4,0.0333333,0.5,0.4,14.6333333,0.0333333,0.5333333,0.0333333,1.2,1.2,0.0333333,0.3333333,0.0333333,0.6,0.0333333,0.0666667,0.4333333),\nT[20]=float[](0.,0.,0.35,-0.25,0.1,-0.15,-0.05,0.,0.25,-0.15,0.1,-0.2,0.,0.3,-0.2,0.2,0.7,-0.0910528,-0.7089472,-0.2);\nfor(int u=0;u<20;++u)\n{if(g<t[u])\n{o+=T[u]*g/t[u];\nbreak;\n}\no+=T[u];\ng-=t[u];\n}\nn=o;\n}\n\ns=D+smoothstep(120.,180.,l+x)*.6-smoothstep(240.,300.,l+x);\nb[0]=vec3(-1.82129,1.71411,-.649904);\nb[1]=vec3(.080076,-1.89453,-.054688);\nb[2]=vec3(-1.8955,1.93799,-.651004);\nb[3]=vec3(.541992,-.31836,-.33008);\nb[4]=vec3(.233396,1.71875,1.39844);\nb[5]=vec3(1.3623,.159668,-.252444);\nb[6]=vec3(.193114,-1.80225,.1499);\nb[7]=vec3(-.240724,1.62451,1.41504);\nb[8]=vec3(-.833008,1.0166,-.081056);\nb[9]=vec3(.291012,1.09619,-.390628);\nb[10]=vec3(.262204,.458496,.170408);\nb[11]=vec3(-.883792,-.952884,-.9418);\nb[12]=vec3(.48828,-1.417,.151236);\nb[13]=vec3(1.3872,1.2832,-.411624);\nb[14]=vec3(1.62012,-.122316,-.397952);\nb[11]-=v/vec3(70.,110.,-180.);\nfloat g,u,o,t=.0001,T,V=.00015;\nvec3 h,d=vec3(0.),F,C,Z,Y,X,W=vec3(.5,.5,.001),U=vec3(0.,0.,0.),S=vec3(t,0.,0.),R=vec3(0.,t,0.),Q=vec3(0.,0.,t);\n\nfor(int P=0;P<3;P++)\n{T=.00015;\nfor(int O=0;O<3;O++)\n{vec2 N=(fragCoord.xy/iResolution.xy+vec2(T,V)+vec2(m,f))/vec2(1.,16./9.)*r;\ng=1.;\nh=normalize(vec3(N,1.));\nfor(int M=0;M<5;M++)\n{if(M>=int(i))break;\nu=26.;\nfor(int L=0;L<15;L++)if(L!=int(a))F=b[L],F.z=(F.z+s)*4.,u=min(u,length(h*g-F)-.71);\nif(u<t)break;\ng+=u;\nif(g>26.)break;\n}\nif(g<26.)\n{if(mod(N.y,.08)<.04)g-=n;\nh*=g;\nu=26.;\nfor(int L=0;L<15;L++)\n{F=b[L];\nY=F;\nZ=F;\nF.z=(F.z+s)*4.;\nC=h-F;\nC=p(C,(l+x)/29.*Z);\nZ=max(C-W,-C-W);\no=max(max(Z.x,Z.y),Z.z);\nif(o<u)u=o,X=Y;\n}\nU=normalize(vec3(e(h+S,X)-e(h-S,X),e(h+R,X)-e(h-R,X),e(h+Q,X)-e(h-Q,X)));\n}\nF=vec3(U.xy,vec3(1.-g/20.));\nF.z+=F.y/2.;\nF.y=F.y+F.x;\nd+=clamp(F,0.,1.);\nT+=.0003;\n}\nV+=.0003;\n}\n\nd/=9.;\nd=(1.-k)*d+vec3(d.x+d.z*z)*k;\nd.xz+=c*vec2(abs(U.y),d.z/3.);\nfragColor=vec4(d*y,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdySRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 87, 87, 280], [282, 282, 306, 306, 431], [434, 434, 491, 491, 6600]], "test": "untested"}
{"id": "WdySRy", "name": "Berries !", "author": "ReavenTehDerg", "description": "Berries for my cutie berry :3", "tags": ["heart", "berry"], "likes": 2, "viewed": 82, "published": "Public", "date": "1574247715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p)\n{\n    p = fract(p * vec2(367.68, 654.55));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\nvec2 N22(vec2 p)\n{\n    float x = N21(p);\n    float y = N21(p + x);\n    return vec2(x, y);\n}\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id);\n    return sin(n) * 0.5;\n}\nvec2 rotate2(vec2 vec, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, s, -s, c);\n    return vec * rot;\n}\nfloat circleMask(vec2 uv, float radius)\n{\n    float vL = length(uv);\n    float circle = smoothstep(radius, radius - 12./iResolution.y, vL);\n    return circle;\n}\nfloat berrybaseMask(vec2 uv)\n{\n    uv.y -= abs(uv.x) * 0.5;\n    \n    return circleMask(uv, 0.2);\n}\nfloat berryleafMask(vec2 uv)\n{    \n    uv.x += 0.09;\n    uv.y -= 0.19;\n    vec2 saveUv = uv;\n    \n    uv.x -= 0.02;\n    uv = rotate2(uv, 0.4);\n    uv.x *= 0.6;    \n    float mask = circleMask(uv, 0.05);\n    \n    uv = saveUv;\n    uv.x -= 0.07;\n    uv.y += 0.02;\n    uv.y *= 0.7;\n    mask += circleMask(uv, 0.05);\n    \n    uv = saveUv;\n    uv.x -= 0.10;\n    uv.y -= 0.013;\n    uv.x *= 0.5;\n    \n    mask += circleMask(uv, 0.05);\n    \n    return clamp(mask, 0.0, 1.0);\n}\n\nfloat berryDots(vec2 uv)\n{\n    uv *= 7.7;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 pos = GetPos(id);\n    float distance = length(gv - pos);\n\n    float _dot = smoothstep(0.06, 0.059, distance);\n    return _dot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv -= iTime * 0.1;\n    uv *= 3.0;\n    \n    vec2 gv = fract(uv) - 0.5;\n    \n    float leafMask = berryleafMask(gv);\n    float berryBMask = berrybaseMask(gv);\n    float berryDot = berryDots(uv);    \n    \n    vec3 berryCol = berrybaseMask(gv) * vec3(1.0, 0.0, 0.2);    \n    berryCol = mix(berryCol, vec3(1.0), berryDot * berryBMask);    \n\n    vec3 leafCol = leafMask * vec3(0.0, 1.0, 0.0);    \n    vec3 res = mix(berryCol, leafCol, leafMask);\n    \n    vec3 mateColor = vec3(1.0, 0.4, 0.2);\n    \n    res = mix(mateColor, res, leafMask + berryBMask);\n    \n    fragColor = vec4(res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdySRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 119], [120, 120, 138, 138, 211], [212, 212, 234, 234, 283], [284, 284, 321, 321, 431], [432, 432, 473, 473, 592], [593, 593, 623, 623, 691], [692, 692, 722, 722, 1159], [1161, 1161, 1187, 1187, 1396], [1398, 1398, 1455, 1455, 2119]], "test": "untested"}
{"id": "wdySWG", "name": "Wang Tile Border Animation", "author": "Shane", "description": "Using ideas set out in MathMasterZach's \"Self-Avoiding Random Road\" example to create a Wang tile border animation.", "tags": ["tile", "wang", "tracks"], "likes": 26, "viewed": 718, "published": "Public API", "date": "1574949678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\n\tWang Tile Border Animation\n\t--------------------------\n\n\tShadertoy user MathMasterZach put together a very nice, cleverly made maze\n    recently, complete with a surrounding conveyor belt system, then Fabrice put\n\tin some really clever suggestions. I effectively brought nothing to the table,\n\tbut I was part of the cheer squad, so I felt like I was contributing. :D \n\n\tAnyway, I'm aware of the concept of an animated border -- I applied it in my\n    \"Hexagonal Maze Flow\" example. I've also been vaguely aware that an animated \n    border can be applied to all kinds of patterns, but figured it would be too \n    much of a book-keeping mission to produce one around anything but the simplest\n\tof grid arrangements.\n\t\n    However, after perusing the code for a while, I realized that either Zach or \n    Fabrice had employed a neat trick that involved producing a pattern on a\n    standard grid, then subdividing each grid cell into four squares, which in turn\n\twould provide the scaffolding upon which to mold a path around the original \n\tstructure in a simplistic and manageable fashion. It's quite clever, and the \n    kind of thing that would have taken me forever to realize.\n\n\tIn this particular example, I'm applying a very similar principle to a Wang \n    tile pattern. As usual, I got a bit excited with the prettying up portion,\n    which has a tendency to drown out the relevant logic. However, the imagery \n    itself is kind of self explanatory and should give people enough to go on.\n\tHere's a brief summary:\n\n    Straight horizontal segments on the bottom of each cell travel west, and the \n    top ones travel east. Straight vertical segments on the left side of the cell\n    move north, and those on the right travel south. Arcs with their centers at \n    the physical cell center turn clockwise, whereas those with their centers \n    fixed on the cell edges move in the counter-clockwise direction.\n\n    I've also provided some options below and explained the notable segments.\n    Plus, you can always refer the original, which contains much more elegant and \n    succinct code. The link is below.\n\n\n\n\tBased on:\n\n\t// A really nice example on so many different levels. The maze code itself is\n\t// also pretty interesting and clever. The path itself visits every node exactly\n\t// once without crossing its own path, and is useful for all kinds of \n\t// things -- See the link below this one. I'm going to produce a couple of \n    // examples along these lines too.\n\tSelf-Avoiding Random Road - mathmasterzach\n\thttps://www.shadertoy.com/view/wdySWm\n\n\n\tOther examples:\n\n    // This example is really pleasing to watch.\n    Indexed Space Fill Random Path - mathmasterzach\n\thttps://www.shadertoy.com/view/wdySRy\n\n    // A similar animated flow line example, but this was easier to construct.    \n    Hexagonal Maze Flow - Shane\n    https://www.shadertoy.com/view/llSyDh\n\n\t// Dr2 has already put together an extruded 3D example.\n\tLong Loop - Dr2\n\thttps://www.shadertoy.com/view/wdKSDy\n\n\n*/\n\n// Display the inner Wang tile structure that the border flows around. Essentially, \n// you could apply the same concept to heaps of things. Aesthetically, I prefer \n// turning this option off, but it helps visualize the concept more.\n#define SHOW_INNER_STRUCTURE\n\n// Show the straight rails, instead of the beaded structure.\n//#define SHOW_RAILS\n\n// A visual aid to display the original grid boundaries. Although, things get\n// a bit cluttered at this point, so it's probably better with the SHOW_RAILS\n// option turned on.\n//#define SHOW_ORIGINAL_GRID\n\n// A plainer palette to declutter things a bit. The colors vary ever so slightly,\n// so technically, it's not monochrome, but that doesn't write well as a define. :)\n//#define MONOCHROME\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Dave Hoskins's vec2 to float hash.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y)*p3.z);\n    \n    // IQ's version. It's my preferred version, but unfortunately,\n    // not always accurate enough for some systems.\n    //return fract(sin(dot(p, vec2(137.609, 157.583)))*43758.5453);\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// This renders a horizontal or vertical box-line from point \"a\" to point \"b,\" with a line \n// width of \"w.\" It's different to the the usual line formula because it doesn't render the \n// rounded caps on the end -- Sometimes, you don't want those. It utilizes IQ's box formula \n// and was put together in a hurry, so I'd imagine there are more efficient ways to do the \n// same, but it gets the job done. I put together a more generalized angular line formula as \n// well.\nfloat lBoxHV(vec2 p, vec2 a, vec2 b, float w){\n    \n   vec2 l = abs(b - a); // Box-line length.\n   p -= vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)); // Positioning the box center.\n   \n   // Applying the above to IQ's box distance formula.\n   vec2 d = abs(p) - (l + w)/2.; \n   return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\n\n// Distance formula.\nfloat dist(vec2 p, vec2 b){\n    \n    //return length(p) - b.x;\n    return sBoxS(p, b, .2);\n    \n}\n\n// Use the unique edge point IDs to produce a Wang tile ID for the tile.\nfloat edges(vec2 ip, vec2[4] ep, float rnd){\n    \n    // Initial ID: Trivial, and converts to a binary string of \"0000,\" which indicates\n    // the cell has no edge points, or an empty tile.\n    float id = 0.;\n    \n    // Note: exp2(i) = pow(2., i).\n    for(int i = 0; i<4; i++) id += hash21(ip + ep[i])>rnd? exp2(float(i)) : 0.;\n    \n    return id; // Range [0-15] inclusive.\n    \n}\n\n// Hacky global. Just a regional ID for coloring purposes.\nvec2 regID;\n\nvec4 distField(vec2 p){\n    \n    // Tile ID and local coordinate.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    \n    // Set the region ID to the main tile ID.\n    regID = ip;\n    \n    // Distance field holders.\n    float d = 1e5, d2 = d, d3 = d;\n    \n    // Wang tile constrction. Pretty standard, and I've explained it in other\n    // examples, if you feel like looking them up.\n    //\n    const float thresh = .5; // Threshold.\n    vec2[4] eps = vec2[4](vec2(-.5, 0), vec2(0, .5), vec2(.5, 0), vec2(0, -.5));\n    vec2[4] cp = eps; \n    \n    // Edge ID for the \n    float id = edges(ip, eps, thresh);\n    // Decode each binary digit.\n    vec4 bit = mod(floor(id/vec4(1, 2, 4, 8)), 2.);\n\n    \n    int iNum = 0; // Edge point index.\n    \n    for(int i = 0; i<4; i++){\n        // Edge numbers.\n        if(bit[i]>.5) {\n            \n            d2 = min(d2, lBoxHV(p, vec2(0), eps[i], 0.));\n            cp[iNum++] = eps[i];\n        }\n        \n    } \n    \n    \n    \n    // Subdividing each cell into four squares, then using the existing\n    // structure to perform  bit checks.\n    \n    // Subdividing further into four squares.\n    vec2 q = mod(p, .5) - .25;\n    \n    \n    // Quadrant identification.\n    int quadID;\n    \n    if(p.x<0.){\n        if(p.y<0.) quadID = 0;\n        else quadID = 1;\n    }\n    else {\n        if(p.y<0.) quadID = 3;\n        else quadID = 2;\n    }\n    \n    \n     \n    // Object angle variable. Moving clockwise.\n    float ang = -iTime/2.;\n    // Quadrant sign variable. It was used to great effect in Zach's example.\n    vec2 s = sign(p);\n    \n    \n    \n    // This mess was written quickly off the top of my head. In concept, it's\n    // simple though. For each quadrant, construct an edge list by referencing\n    // the main Wang structure, then render the Wang structure for it using\n    // standard Wang tile methods.\n    \n    for(int j = 0; j<4; j++){\n        \n        // If the line from the main cell is blocking the \n        // direction, head in that direction also, since you want to\n        // avoid the line and not run into it. Otherwise, head\n        // toward the open space.\n        \n        // Border count.\n        int borders = 0;\n        \n        // Quad ID.\n        float qID = 0.;\n        \n        // Contrucing the edge IDs for this particular quadrant. \n        if(bit[j]>.5) { \n            qID += float(1<<(j)); // 1, 2, 4, 8.\n            borders++;\n        }\n        else qID += float(1<<((j + 1)&3)); // 2, 4, 8, 1.\n        \n        if(bit[(j + 3)&3]>.5) {\n            qID += float(1<<((j + 3)&3)); // 8, 1, 2, 4. \n            borders++;\n        }\n        else qID += float(1<<((j + 2)&3)); // 4, 8, 1, 2.\n        \n        \n        // Edge bit extraction.\n        vec4 qBit = mod(floor(qID/vec4(1, 2, 4, 8)), 2.);\n\n        // Fill in the point structure. Actually, this isn't\n        // technically needed, as you can constuct things with\n        // the quadrant sign variable \"s,\" but I'll need it later.\n        int cnt = 0;\n        vec2[4] qCp = eps; \n        for(int i = 0; i<4; i++){\n            if(qBit[i]>.5){\n                qCp[cnt++] = eps[i]/2.;\n            }\n        }\n        \n        \n        // Contruct the distance fields for this quadrant in any empty\n        // cells. By the way, you don't need to leave empty cells empty,\n        // but I prefer it that way.\n        if(quadID == j && iNum>0){\n            \n            // Refering to the imagery. If there's one border, render\n            // a straight line.\n            if(borders == 1){\n                \n                // Straight line.\n                d = min(d, lBoxHV(q,  qCp[0], qCp[1], 0.)); \n                //d = min(d, lBoxHV(q, vec2(0), qCp[0], 0.)); \n                //d = min(d, lBoxHV(q, vec2(0), qCp[1], 0.)); \n              \n                \n                // Vertical.\n                if(abs(qCp[0].x - qCp[1].x)<.001) {\n                    \n            \n                    // If you take a look at the imagery, you'll see that vertical\n                    // lines on the left need to travel in opposite directions, \n                    // depending which side of the \"p.x = 0\" line they're on. Hence\n                    // the \"s.x\" term. The same applies for the horizontal term\n                    // below.\n                    // \n                    // On a side note. If you choose the right number of repeat \n                    // segments, you can manipulate the angle (or spacing, in this\n                    // case) to make things look more consistant -- since the perimeter\n                    // of a square is larger than that of its circumscribed circle.\n                    //\n                    // For instance, with three segments in each quarter circle, you \n                    // could increase the three here to four by multiplying s.x by 4/3. \n                    // You'd want to do it for the horizontal case below as well.\n                    ang += -(q.y + .25)*s.x;\n                    \n                    // Region ID.\n                    regID = ip + .3;\n                    \n                }\n                else {\n                    \n                    // See the comments above.\n                    ang += (q.x + .25)*s.y;\n                    \n                    // Region ID.\n                    regID = ip + .1;\n                    \n                }\n               \n\n            }\n            else if(borders == 2){\n                \n                // Two borders mean a curved inner bend rendering.\n                \n                vec2 offs = qCp[0] +  qCp[1];\n                d = min(d, dist(q - offs, vec2(.25)));\n                \n                // Quarter circles, so four segments per complete\n                // revolution, which means... Carry the one... The\n                // figure Zach chose works perfectly, so that's good\n                // enough for me. :D\n                //\n                // Current angle. You could use the \"s\" variable too.\n                //ang += atan(q.y - s.y/4., q.x - s.x/4.)/6.283*4.;\n                ang += -atan(q.x - offs.x, q.y - offs.y)/3.14159;\n                \n               \n   \t\t\t\t// Region ID.\n                regID = ip + .2;\n                \n            }\n            else {\n                \n                 // No borders in a non-empty quadrand requre a curved \n                // outer bend rendering.\n                \n                 vec2 offs = qCp[0] +  qCp[1];\n                 d = min(d, dist(q - offs, vec2(.25)));\n                 \n                 // Current angle. You could use the \"s\" variable too.\n                 //ang += atan(q.y - s.y/4., q.x - s.x/4.)/6.283*4.;\n                 ang += atan(q.x - offs.x, q.y - offs.y)/3.14159;\n                \n\n                 // Region ID.\n                 regID = ip + .4;\n                 \n            }\n            \n        }\n            \n        \n    }\n    \n    \n    // Rendering lines around the original Wang tile borders, which is a\n    // bit wasteful, but this is a cheap 2D example.\n    d3 = min(d3, lBoxHV(p, vec2(-.5, -.5), vec2(-.5, .5), 0.));\n    d3 = min(d3, lBoxHV(p, vec2(.5, -.5), vec2(.5, .5), 0.));\n    d3 = min(d3, lBoxHV(p, vec2(-.5, .5), vec2(.5, .5), 0.));\n    d3 = min(d3, lBoxHV(p, vec2(-.5, -.5), vec2(.5, -.5), 0.));\n    \n    #ifdef SHOW_ORIGINAL_GRID\n    d3 -= .045;\n    #endif\n\n    //#ifndef SHOW_ORIGINAL_GRID\n    // Region border construction: Ugly coding at its finest. :)\n    //\n    // I wanted to render region borders, and needed a quick working\n    // method. It works, but I'm pretty sure there are way more \n    // streamlined ways to get the job done.\n    if(id==1. || id==4.){\n        d3 = min(d3, lBoxHV(p, eps[1], eps[3], 0.));\n    }\n    \n    if(id==2. || id==8.){\n        d3 = min(d3, lBoxHV(p, eps[0], eps[2], 0.));\n    }\n    \n    if(id==3. || id==6. ||id==9. ||id==12.){\n        d3 = min(d3, lBoxHV(p, eps[0], eps[2], 0.));\n        d3 = min(d3, lBoxHV(p, eps[1], eps[3], 0.));\n       \n    }\n    \n    if(id==7. || id==13.) d3 = min(d3, lBoxHV(p, eps[0], eps[2], 0.));\n    if(id==11. || id==14.) d3 = min(d3, lBoxHV(p, eps[1], eps[3], 0.));\n    //#endif\n\n    \n\n    \n    // Returning the border, main structure and current angle.\n    return vec4(d, d2, d3, ang);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Subtle barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .025*(r*r*.5 + r);\n    \n    // Scaling and translation.\n    float gSc = 6.;\n    //rot2(3.14159/4.)*\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-.5, 0)*iTime;\n    \n   \n    \n    // Keeping a copy.\n    vec2 oP = p;\n    \n    // Smoothing factor, based on scale and resolution.\n    float sf = gSc/iResolution.y;\n  \n    // The animated border distance field and the field for the shadow, \n    // which we're calling first, so as not to disturb some globals.\n    vec4 dSh = distField(p - vec2(-.08, -.12));\n    vec4 d = distField(p);\n    \n    // The straight rail, which we're not using at present.\n    float oD = d.x;\n    float oDSh = dSh.x;\n    \n    // Current angle. Used for animated object construction. \n    float ang = d.w;\n    float angSh = dSh.w;\n    \n    // // The straight rail, which we're not using at present.\n    d.x = abs(d.x) - .15;\n    // The inner Wang tile structure.\n    d.y -= .055;\n    \n    // The corresponding shadows.\n    dSh.x = abs(dSh.x) - .15;\n    dSh.y -= .055;\n       \n    \n    \n    // Use the region ID to generated a random palette color.\n    // Four color palette.\n    vec3[4] pal = vec3[4](vec3(1, .8, .2), vec3(1, .4, .2), vec3(.2, .8, 1), vec3(.2, .4, 1));\n    vec3 col = pal[int(floor(hash21(regID)*3.999))];\n    col = mix(col, col.yzx, uv.y*.75 + .5);\n    \n    #ifdef MONOCHROME\n    float cRnd = hash21(regID); // Random cell color.\n    col = vec3(1, .75 + cRnd*.1, .45 + cRnd*.2);\n    #endif\n    \n\n    // Rendering the region borders.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.z - .01)));\n\n    \n     \n    // If you increase the number of segments, you'll often have to\n    // change the repeat shape width. Otherwise, you'll end up with\n    // a continuous blob.\n    const float aNum = 2.;\n    // This is something I occasionally need to remind myself of: There are two\n    // ways to render repeat objects around a curved surface. One is to obtain the\n    // the angular position to the object's center on a curve, then render with \n    // aspect correct local coordinates -- That way, if you draw a square, it won't \n    // be mutated.\n    //\n    // However, there are times, like this, when you want the object to mold to the\n    // underlying distance field's shape. The difference, in this case, is that I'm \n    // allowing the angle to vary from one side of the shape to the other, instead \n    // of snapping it to a central position. Obviously, for repeat objects, you \n    // still need to do the repetition thing, which is the case below.\n    float a = (mod(ang*2., 1./aNum) - .5/aNum);\n    \n     // Distance field coordinates -- For a circle, you'd use something like \n    // vec2(angle, radiusDistance), but that's just a special case. In a more general\n    // sense, it's vec2(angleOnSurface, surfaceDistance).\n    vec2 distP = abs(vec2(a/2., oD));\n    float rObj = sBoxS(distP, vec2(.05, .05), .025);\n    rObj = rObj - .12;\n    \n    // The corresponding shadows.\n    float aSh = (mod(angSh*2., 1./aNum) - .5/aNum);\n    vec2 distPSh = abs(vec2(aSh/2., oDSh));\n    float rObjSh = sBoxS(distPSh, vec2(.05, .05), .025);\n    // Cutting a whole out of the shadow to give it a caustic effect.\n    // Completely fake, of course. The correct line is below it. \n    rObjSh = max(rObjSh - .12, -(rObjSh - .04));\n    //rObjSh = rObjSh - .12;\n    \n    \n    // It's possible to rotate object colors, but not many.\n    //float objID = mod(floor(ang*aNum*2.), aNum);\n    \n    // Object color.\n    vec3 oCol = vec3(1);\n    \n    \n    #ifdef SHOW_RAILS\n    // With the translucent rails option, decrease the size of the\n    // rounded square objects slightly.\n    rObj += .01;\n    rObjSh += .01;\n    #endif\n    \n\n    \n    #ifdef SHOW_INNER_STRUCTURE\n    // When dispaying the inner structure, merge its shadow with the \n    // outer framework.\n    #ifdef SHOW_RAILS\n    dSh.x = min(max(dSh.x, -rObjSh), dSh.y);\n    #else\n    rObjSh = min(rObjSh, dSh.y);\n    #endif    \n    #endif\n    \n    #ifdef SHOW_ORIGINAL_GRID\n    #ifdef SHOW_RAILS\n    dSh.x = min(dSh.x, dSh.z);\n    #else\n    rObjSh = min(rObjSh, dSh.z);\n    #endif\n    #endif\n    \n    // Lay down the shadows.\n    #ifdef SHOW_RAILS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., dSh.x))*.7);\n    #else\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., rObjSh))*.7); \n    #endif\n    \n    #ifdef SHOW_ORIGINAL_GRID\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, d.z + .02)));\n    #endif\n    \n    // Render the objects themselves, in a fake translucent manner.\n    vec3 svCol = col;\n    #ifdef SHOW_RAILS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x)));\n    col = mix(col, min(svCol*2., 1.), (1. - smoothstep(0., sf, d.x + .03)));\n    #else\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, rObj)));\n    col = mix(col, min(svCol*2., 1.), (1. - smoothstep(0., sf, rObj + .03)));\n    #endif\n    \n   \n    // Applying the middle section of the repeat animated pattern.\n    svCol = col;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, rObj + .06)));\n    col = mix(col, mix(svCol*2., oCol, .75), (1. - smoothstep(0., sf, rObj + .09)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., max(rObj + .09, rObjSh + .02)))*.15);\n     \n    \n    #ifdef SHOW_INNER_STRUCTURE\n    // Render the inner Wang tile structure.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.y)));\n    col = mix(col, mix(svCol*2., vec3(1, .85, .35), .75), (1. - smoothstep(0., sf, d.y + .03)));\n    #endif\n    \n    // Apply some subtle noise.\n    float ns = fbm(oP/gSc*96.*max(iRes/450., 1.));\n    vec3 tx = mix(vec3(1, .8, .7), vec3(.05, .1, .15), ns);\n    col *= tx*.5 + .7;\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    float vig = pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./6.);\n    col *= min(vig*1.25, 1.);\n    \n    \n    // Rough gamma correction, then output to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdySWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3753, 3786, 3808, 3808, 3866], [3869, 4021, 4042, 4070, 4375], [4378, 4602, 4621, 4621, 4826], [4828, 4906, 4924, 4924, 4997], [5001, 5001, 5048, 5048, 5145], [5147, 5620, 5666, 5666, 5948], [5952, 5973, 6000, 6035, 6070], [6072, 6145, 6189, 6335, 6528], [6530, 6602, 6625, 6667, 14815], [14819, 14819, 14873, 14916, 21081]], "test": "untested"}
{"id": "wdySWK", "name": "Hello world. ", "author": "laralex", "description": "My first shader ever. I've tried not to use any `if` statement", "tags": ["simple", "circle"], "likes": 1, "viewed": 124, "published": "Public", "date": "1574968667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Circle\n    vec2 center = uv / 2.0;\n    float radius = 0.3;\n    float sqrRadius = radius * radius;\n    \n   \n    vec2 diffCoord = uv - center;\n    vec2 sqrCoord = diffCoord * diffCoord;\n    float circleBlur = 0.003;\n    float isInCircle = 1.0 - smoothstep(sqrRadius-circleBlur, sqrRadius,sqrCoord.x + sqrCoord.y);\n   \n    // One line rotates faster than the other\n    mat2 rotationMatrix = mat2(\n        cos(iTime), -sin(iTime),\n        sin(iTime), cos(iTime)\n    );\n    mat2 rotationMatrixFast = mat2(\n        cos(3.0*iTime), -sin(3.0*iTime),\n        sin(3.0*iTime), cos(3.0*iTime)\n    );\n    // Check if coords are in a circle and in a segment between 2 lines\n    // To check that coords are \"on a particular side\" of a line, \n    // both lines are defined with a normal vector to it, not a tangent vector\n    // so to check that coords are on this side, just check that dot(normal, coord) > 0\n    float lineBlur = 0.0005;\n    float isInFrontOfLine = smoothstep(0.0, lineBlur, dot(vec2(0.0, 0.1) * rotationMatrix, diffCoord));\n    float isInFrontOfFastLine = smoothstep(0.0, lineBlur, dot(vec2(0.0, 0.1) * rotationMatrixFast, diffCoord));\n    vec3 dynamicColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = \n        isInCircle\n        * isInFrontOfLine\n        * isInFrontOfFastLine\n        * dynamicColor;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdySWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 93, 1548]], "test": "untested"}
{"id": "wdySWV", "name": "Twisty Swirly Thingy", "author": "undeadmockingbird", "description": "Twisty swirly thing.", "tags": ["twist"], "likes": 12, "viewed": 155, "published": "Public", "date": "1574985659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat t = iTime;\n\tvec2 r = iResolution.xy;\n\tvec2 uv = fragCoord.xy - r / 2.0;\n\tuv = vec2(length(uv) / r.y - 0.3, atan(uv.x, uv.y));    \n\tvec3 s = cos(5.0 * vec3(0, 1, 2) + t + uv.y + sin(uv.y) * cos(t)) / 10.0;\n\tvec3 e = s.zxy;\n \tvec3 f = max(uv.x - s, e - uv.x);\n \tfragColor.rgb = dot(clamp(f * r.y, 0., 1.), 50. * (s - e)) * (s - .1) + f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdySWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 399]], "test": "untested"}
{"id": "wdySzm", "name": "Best Oban", "author": "sametaylak", "description": "best oban", "tags": ["best", "oban"], "likes": 4, "viewed": 69, "published": "Public", "date": "1573642300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 ap = abs(p) - s;\n    return length(max(vec3(0.0), ap)) + min(0.0, max(ap.x, max(ap.y, ap.z)));\n}\n\nfloat roundBox(vec3 p, vec3 s, float r)\n{\n  vec3 rb = abs(p) - s;\n  return length(max(rb, 0.0)) + min(max(rb.x, max(rb.y, rb.z)), 0.0) - r;\n}\n\nfloat cylinder(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat ship(in vec3 p)\n{\n    float s = sphere(p, 0.4);\n    float b = max(cylinder(p.yz + vec2(0.1, 0.0), 0.2), abs(p.x) - 0.8);\n    float d = min(s, b);\n    \n    float s2 = sphere(p + vec3(1.0, 0.1, 0.0), 0.3);\n    float s3 = sphere(p + vec3(-1.0, 0.1, 0.0), 0.3);\n    \n    float sideSpheres = min(s2, s3);\n    d = min(d, sideSpheres);\n\n    float c1 = roundBox(p + vec3(1.0, 0.1, 0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c2 = roundBox(p + vec3(1.0, 0.3, 1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c1, c2, 0.01));\n    \n    float c3 = roundBox(p + vec3(-1.0, 0.1, 0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c4 = roundBox(p + vec3(-1.0, 0.3, 1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c3, c4, 0.01));\n    \n    return d;\n}\n\nmat2 rot(float a)\n{\n\tfloat ca = cos(a);\n    float sa = sin(a);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0.0);\n    off.x += sin(p.z * 0.3) + 0.5;\n    off.y += cos(p.z * 0.5) * 0.1;\n    return off;\n}\n\nfloat map(in vec3 p)\n{\n    p += tunnel(p);\n    \n    vec3 p1 = p;\n    \n    float m = iTime * 4.0;\n    p1.z += m;\n    \n    float t = clamp(sin(p.z * 0.3), -1.0, 1.0) * 0.35;\n   \tp1.yx *= mat2(1.0, t, -t, 1.0);\n    \n\tfloat d = ship(p1);\n    \n    vec3 bp = p;\n    bp.z = fract(bp.z / 2.0 - 0.5) - 0.5;\n    float bPlane = box(bp + vec3(0.0, 3.0, 0.0), vec3(5.0, 0.2, 1.0));\n    \n    d = min(d, bPlane);\n    \n    vec3 sp = p;\n    sp.xy *= rot(1.0);\n    sp.z = fract(sp.z / 2.0 - 0.5);\n    float rPlane = box(sp + vec3(-1.0, 4.0, 0.0), vec3(2.0, 0.2, 1.0));\n    \n    d = min(d, rPlane);\n    \n    vec3 sp2 = p;\n    sp2.yx *= rot(1.0);\n\tsp2.z = fract(sp2.z / 2.0 - 0.5);\n    float lPlane = box(sp2 + vec3(1.0, 4.0, 0.0), vec3(2.0, 0.2, 1.0));\n    \n    d = min(d, lPlane);\n    \n    return d;\n}\n\nvec3 norm(in vec3 p)\n{\n    vec2 o = vec2(0.0001, 0.0);\n\treturn normalize(\n    \tvec3(\n        \tmap(p+o.xyy) - map(p-o.xyy),\n        \tmap(p+o.yxy) - map(p-o.yxy),\n        \tmap(p+o.yyx) - map(p-o.yyx)\n        )\n    );\t\n}\n\nfloat rayTrace(in vec3 ro, in vec3 rd)\n{\n\tfloat t = 0.0;\n    for(int i = 0; i < 100; i++) {\n    \tvec3 p = ro + t * rd;\n        \n        float h = map(p);\n        if(h < 0.001) {\n        \tbreak;\n        }\n        \n        t += h;\n        if(t > 20.0) {\n            break;\n\t\t}\n    }\n    \n    if(t > 20.0) {\n    \tt = -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 1.0, 2.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    float m = iTime * 4.0;\n    ro.z -= m;\n    ta.z -= m;\n    \n    ro -= tunnel(ro);\n    vec3 offT = tunnel(ta);\n    ta -= offT;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0) + offT * 0.3));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = vec3(\n    \tnormalize(\n        \tuv.x * uu + uv.y * vv + ww\n        )\n    );\n\n\tvec3 color = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n    float t = rayTrace(ro, rd);\n    \n    if(t > 0.0) {\n        vec3 p = ro + t * rd;\n        vec3 n = norm(p);\n        \n        vec3 sunDir = normalize(vec3(0.8, 0.8, 0.8));\n        float sunSha = step(rayTrace(p + n * 0.001, sunDir), 0.0);\n        float sunDif = clamp(dot(n, sunDir), 0.0, 1.0);\n        \n        vec3 skyDir = vec3(0.0, 0.75, -1.0);\n        float skyDif = clamp(0.5 + 0.5 * dot(n, skyDir), 0.0, 1.0);\n        \n    \tcolor = vec3(1.0, 0.7, 0.5) * sunDif * sunSha;\n        color += vec3(0.0, 0.1, 0.3) * skyDif;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdySzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 56], [58, 58, 85, 85, 188], [190, 190, 231, 231, 331], [333, 333, 366, 366, 391], [393, 393, 434, 434, 528], [530, 530, 553, 553, 1279], [1281, 1281, 1300, 1300, 1376], [1378, 1378, 1399, 1399, 1510], [1512, 1512, 1534, 1534, 2295], [2297, 2297, 2319, 2319, 2514], [2516, 2516, 2556, 2556, 2862], [2864, 2864, 2919, 2919, 4065]], "test": "untested"}
{"id": "WdyXDm", "name": "Hyperspace Streaks", "author": "blue_max", "description": "Based on Louis Sugy's shader. I've only tweaked and simplified a few bits of the effect to make it look closer to the effect we see in Solo. I'll add it to the old X-Wing Alliance videogame soon.", "tags": ["hyperspace", "starwars"], "likes": 12, "viewed": 352, "published": "Public", "date": "1574578225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n * Based on https://www.shadertoy.com/view/Wl2GRz\n * Created by Louis Sugy, 2019\n * You can use it under the terms of the MIT license\n * (free to use even in commercial projects, attribution required)\n */\n\n#define PI 3.14159265\n#define ATAN5 1.37340076695\n\nvec3 blue_col = vec3(0.5,0.7,1);\n\nconst float t2 = 2.0;\n\nvec2 cart2polar(vec2 cart) {\n    return vec2(atan(cart.y, cart.x), length(cart));\n}\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat jumpstep(float low, float high, float val)\n{\n    /*\n     This curve is plotted here:\n\n     https://www.iquilezles.org/apps/graphtoy/?f1(x)=atan(10%20*%20x%20-%205.0)%20/%20(2%20*%20atan(5.0))%20+%200.5&f2(x)=clamp(f1(x),%200,%201)&f3(x)=(10%20*%20x%20-%205.0)%20/%20(2%20*%20atan(5.0))%20+%200.5\n    */\n    // This part of the curve looks like a smoothstep going from 0\n    // to halfway up the curve\n    float f1 =  clamp(\n       atan(8.0 * (val-low) / (high-low) - 5.0) / (2.0 * ATAN5) + 0.5, \n       0.0, 1.0\n    );\n    // This is a linear curve\n    float f2 = (8.0 * (val-low) / (high-low) - 5.0) / (2.0 * ATAN5) + 0.5;\n    return max(f1, f2);\n}\n\nvec3 pixelVal(vec2 coord)\n{    \n    // Pixel to point (the center of the screen is (0,0)\n    //float t1 = 2.8, t2 = 4.5;\n    vec3 resolution = iResolution * 4.0;\n    vec2 uv = (2.0 * coord - resolution.xy) / resolution.x;\n    vec2 ad = cart2polar(uv);\n    // ad: polar coords\n    // ad.x = angle\n    // ad.y = radius\n    \n    // Loop forever\n    float time = mod(iTime, t2);\n    \n    // Uncomment this line to revert the effect\n    //time = t2 - time;\n    \n    //time = 0.5 * t2; // DEBUG\n    float t = time / t2; // normalized [0..1] time\n    \n    vec3 bg = vec3(0.0);\n    vec3 fg = 0.75 * vec3(0.082, 0.443, 0.7);\n    vec3 col = mix(bg, fg, t);\n    // whiteout:\n    col = mix(col, vec3(1.0), smoothstep(0.5, 0.9, t));\n \n    //time = 1.25; // DEBUG\n    float intensity = 1.0;\n    // Smaller r's produce longer streaks\n    float r = ad.y;\n    r = r * 40.0 / (5.0 + 60.0 * jumpstep(0.0, t2, 0.5*pow(time, 3.5)));\n\n    // Lower values in the multiplier for ad.x yield thicker streaks\n    float noiseVal = simplexNoise(vec3(60.0 * ad.x, r, 0.0));\n    float noiseGain = 1.0 + 2.0 * smoothstep(0.5, 0.9, t);\n    noiseVal *= noiseGain;\n    \n    // Let's remove a few streaks:\n    float lo_t = clamp(mix(0.25, 0.0, t), 0.0, 1.0);\n    noiseVal = smoothstep(lo_t, 1.0, noiseVal);\n    \n    // Overall intensity of the streaks\n    intensity = mix(0.0, 10.0, t * 1.5);\n    // Multiplying by ad.y darkens the center streaks a little bit\n    noiseVal *= ad.y * intensity * noiseVal;\n    float white_level = smoothstep(0.0, 1.0, noiseVal);\n    white_level *= white_level;\n\n    col += intensity * blue_col * vec3(noiseVal) + vec3(white_level);\n    \n    ///////////////////////////////////////\n    // Add the white disk in the center\n    ///////////////////////////////////////\n    float disk_size = 0.025, falloff, disk_col;\n    float disk_intensity;\n    disk_intensity = smoothstep(0.25, 0.65, t);\n    //disk_size = jumpstep(0.0, t2 - 0.3, 0.5*pow(time, 3.5));\n        \n    falloff = 3.0; // 100 = short fallof, 3.0 = bigger, nicer falloff\n    // Negative fallofs will make a black disk surrounded by a halo\n    disk_col = exp(-(ad.y - disk_size) * falloff);\n    col += disk_intensity * disk_col * vec3(0.913, 0.964, 0.980);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 avgcol = vec3(0.0);\n    \n    for(int i = -1; i <= 1; i++)\n        for(int j = -1; j <= 1; j++)\n            avgcol += pixelVal(4.0 * fragCoord + vec2(i, j));\n    avgcol /= 9.0;\n\n    // Output to screen\n    fragColor = vec4(avgcol, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyXDm.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 318, 346, 346, 401], [403, 533, 555, 555, 707], [709, 709, 737, 737, 1397], [1399, 1399, 1449, 1805, 2054], [2056, 2056, 2083, 2176, 4288], [4290, 4290, 4347, 4347, 4594]], "test": "untested"}
{"id": "WdyXDw", "name": "Kaleidozoom VR", "author": "shadeThrower", "description": "3D VR version of my kaleidozoom shader", "tags": ["psychedelic", "kaleidoscope", "trippy", "trig", "geometric"], "likes": 5, "viewed": 333, "published": "Public API", "date": "1574137587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float tme = iTime*.2;\n    float scale = 0.125;\n   \n    float posMod;\n    float posModGradA;\n    float posModGradB;\n    posMod = (cos(tme/2.+3.1416)*.95 + .05)/2.+.5;\n    posModGradA = (cos(tme*1.1)*.9 + .1)/2.+.5;\n    posModGradB = (cos(tme*.9)*.9 + .1)/2.+.5;\n    \n    vec2 adjVec = vec2((sin(tme)*.5), (cos(tme)*.5));\n    \n    vec2 uv = fragCoord/iResolution.xy* vec2(2.,2.);\n    if(fragCoord.x/iResolution.x > 0.5){\n        uv.x -= 1.;\n    }\n    else{\n        uv.x = 1. - uv.x;\n    }\n    uv.x = pow(uv.x*1., 1.+uv.x*posModGradB*.7)*(1.+pow(abs(1.-uv.y)*posModGradA*.7, 2.));\n  \tuv.y -= .5;\n    \n    //Diagonal Moving\n    //uv.x = sin((fract(tme)+uv.x)*3.14)/2.+.5;\n    //uv.y = cos((fract(tme)+uv.y)*3.14)/2.+.5;\n    \n    //Mouse Movement Multiple\n    /*if(fragCoord.x/iResolution.x > 0.5){\n    \tuv.x = sin((1.-iMouse.x/iResolution.y*10.+uv.x)*3.14)/2.+.5;\n    } else {\n        uv.x = sin((1.+iMouse.x/iResolution.y*10.+uv.x)*3.14)/2.+.5;\n    }\n    uv.y = cos((1.-iMouse.y/iResolution.x*16.+uv.y)*3.14)/2.+.5;*/\n\n    //Auto Move Circular\n    //uv.x = sin((1.-(sin(tme/2.)/2.+1.)*5.+uv.x)*3.14)/2.+.5;\n    //uv.y = cos((1.-(cos(tme/2.)/2.+1.)*8.+uv.y)*3.14)/2.+.5;\n    \n    // Move and Zoom\n\t//uv.x = sin((1.-.5*5.+uv.x)*6.28*(sin(tme)+2.))/2.+.5;\n    //uv.y = sin((1.-.5*8.+uv.y)*6.28*(sin(tme)+2.))/2.+.5;\n    \n    \n    //Rotation (in progress)\n    /*vec2 uvTmp = uv;\n    uvTmp.x += sin(length(uv-vec2(.5,.5)))*(sin(tme)/2.+.5);\n    uvTmp.y += cos(length(uv-vec2(.5,.5)))*(sin(tme)/2.+.5);\n    uv = uvTmp;*/\n    \n    vec2 uvM;\n    //uv = vec2(pow((uv.x-.5)*length(normalize(uv-0.5))*5., -.05)*posMod, pow((uv.y-.5)*length(normalize(uv-0.5))*5., -.05)*posMod);\n    //uv = vec2(pow((uv.x-.5)*length(uv-0.5)*5., -.07)*posMod*2., pow((uv.y-.5)*length(uv-0.5)*5., -.07)*posMod*2.);\n    \n    \n    //Autozoom\n    /*uv = vec2(pow(abs(uv.x-.5)+length(uv-.5), -.07)*posMod*3., pow(abs(uv.y-.5)+length(uv-.5), -.07)*posMod*3.);\n    uvM = mod(uv, scale);*/\n    \n    \n    //Forward Travel\n    //INTERACTIVE: Mouse X controls flight speed, Mouse Y controls depth\n    float normX;\n    float normY;\n    if(iMouse.y>0. || iMouse.x>0.){\n    \tnormX = ((iMouse.x)-1.)/iResolution.x;\n    \tnormY = ((iMouse.y)-1.)/iResolution.y;\n    }\n    else{\n        normX = 0.3;\n        normY = 0.3;\n    }\n    normX = .4;\n    normY = .6;\n    float zoomMult = pow(max(normY,0.001)*5., .5);\n    uv = vec2(pow(abs(uv.x-.5)+length(uv-.5), -.07)*zoomMult*2., pow(abs(uv.y-.5)+length(uv-.5), -.07)*zoomMult*2.);\n    uvM = mod(uv+fract((tme)*normX)*5.*(normY*.75+.25), scale);\n\t//End interactive\n    \n    \n    uv = normalize(uvM-vec2(scale/2.))*(adjVec+vec2(.5));\n\n    if(mod(floor((uv.x)/scale),2.) == 0.)\n            uvM.x = scale - uvM.x;\n    if(mod(floor((uv.y)/scale),2.) == 0.)\n            uvM.y = scale - uvM.y;\n\n    uvM += adjVec*length(uvM + adjVec - vec2(0.5));\n\n    // With uvM and uv gradients\n    vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(((cos(length(uv*posModGradA*100.))*.4+.6)+(cos(length(uvM*posModGradB*100.))*.4+.6))/2.),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(((cos(length(uv*posModGradA*100.))*.4+.6)+(cos(length(uvM*posModGradB*100.))*.4+.6))/2.),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*(((cos(length(uv*posModGradA*100.))*.4+.6)+(cos(length(uvM*posModGradB*100.))*.4+.6))/2.);\n    \n    // With uv gradients\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(uv*posModGrad*100.))*.4+.6),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(uv*posModGrad*100.))*.4+.6),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*(cos(length(uv*posModGrad*100.))*.4+.6);*/\n    \n    // True to fragCoord (in progress)\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(((fragCoord/iResolution.xy-.5)*posMod))*100.)/2.+.5),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(((fragCoord/iResolution.xy-.5)*posMod))*100.)/2.+.5),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*(cos(length(((fragCoord/iResolution.xy-.5)*posMod))*100.)/2.+.5);*/\n    \n    // Without gradients\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))));*/\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 4839]], "test": "untested"}
{"id": "wdyXR1", "name": "Night Sky s", "author": "icaroleles1", "description": "A simple Night Sky", "tags": ["sky"], "likes": 1, "viewed": 126, "published": "Public", "date": "1573407282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat N21(vec2 uv){\n\treturn fract(sin(uv.x*32342. + uv.y*4899999.)*11456.);    \n}\n\nfloat perlinNoise(vec2 uv){\n    \n\tvec2 gv = fract(uv);\t\n\tvec2 id = floor(uv);\n\t\n    \n    gv = gv*gv*gv*(3.-2.*gv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl,br,gv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl,tr,gv.x);\n    \n    float c = mix(b,t,gv.y);\n     \n    \n    return c;\n}\n\n\n#define OCTAVES 3\nfloat fbm(vec2 gv,float frequency,float amplitude){\n\tfloat c=0.;\n\tfloat n=0.;\n\tfor(int i=0;i<OCTAVES;i++){\n\t\tc+=perlinNoise(gv*frequency*1.)*amplitude;\n\t\tfrequency*=2.14325434;\n\t\tamplitude*=.18124;\n\t\tn+=amplitude;\n\t}\n\tc/=n;\n\treturn c;\n\t\n}\nvec2 N22(vec2 p){\n    \n \tvec2 c = fract(p*vec2(84337.834,12.5465));\n    c+= (dot(p.y*12.3,p.x*7656756.4343));\n                   \n    return c;\n   \n}\n\n\nfloat star(vec2 gv,vec2 pos){\n    \n return smoothstep(.1,.06,distance(gv,pos));\n   \n    \n}\n\nvec2 getStarPos(vec2 id,vec2 offset){\n    vec2 starPos = N22(id+offset) ;\n\n    return  sin(starPos)*1.4;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv*=.47;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 iv = 5.*uv;\n    \n    uv.x += iTime*0.025;\n\tuv.y += (iTime*0.7)*0.1;\n    vec2 gv = fract(iv)-.5;\n    vec2 id = floor(iv);\n    \n    \n    \n    \n    vec2 starPos = getStarPos(id,vec2(0,1.));\n    \n  \n    \n    \n    float starPoint = star(gv,starPos);\n    vec4 outPut;\n    \n    if(true){\n    col =vec3(fbm(uv,5.,1.));\n\toutPut = vec4(col*.5*vec3(.4,.4,2.1),1.);\n    }\n    \n    \n               \n        \n      vec2 points[9];\n      int i=0;\n  \t  for(int y=-1;y<=1;y++){\n        \n        for(int x=-1;x<=1;x++){\n\t\t\tpoints[i++] = getStarPos(id,vec2(x,y));    \n\t\t\n        }\n        \n    }\n     for(int c=0;c<3;c++){\n            vec2 j = points[c] - gv;\n            j*=20.;\n            col+=1./length(9.*dot(j,j)) * vec3(1.3,.9,.3);\n            \n        }\n        \n        \n     outPut += vec4(col,1.);\n\n    fragColor = outPut*.165;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 82], [84, 84, 111, 111, 457], [478, 478, 529, 529, 716], [717, 717, 734, 734, 866], [869, 869, 898, 898, 959], [961, 961, 998, 998, 1072], [1074, 1074, 1131, 1131, 2150]], "test": "untested"}
{"id": "WdyXRD", "name": "Penumbra Shadows", "author": "iq", "description": "Improved nurof3n's idea to capture internal penumbra with traditional fake sdf shadows. This method doesn't break the external penumbra, and matches better physically correct shadows. It works for different light sizes.", "tags": ["3d", "raymarching", "sdf", "shadows"], "likes": 36, "viewed": 2099, "published": "Public API", "date": "1573504932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader is what I believe the most accurate fake soft shadow implementation\n// to date, in that it reproduces correct inner and outer penumbra sizes casting\n// a single ray. It matches the ground truth pretty well for different light\n// source sizes.\n// \n// Code is in line 119\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    vec2 q = vec2( length(p.xz)-r, abs(p.y-h*0.5)-h*0.5 );\n    return min( max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nbool shadowBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return false;\n\treturn tN>0.0 && tN<tmax;\n}\n\nbool shadowSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float tmax )\n{\n\tvec3 oc = ro - cen;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return false;\n\tfloat t = -b - sqrt( h );\n    return t>0.0 && t<tmax;\n}\n\nbool shadowCylinder( in vec3 ro, in vec3 rd, in float he, float ra, in float tmax )\n{\n    float he2 = he*he;\n    \n    float k2 = 1.0        - rd.y*rd.y;\n    float k1 = dot(ro,rd) - ro.y*rd.y;\n    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return false;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = ro.y + t*rd.y;\n    if( y>0.0 && y<he )\n    {\n        return t>0.0 && t<tmax;\n    }\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : he) - ro.y)/rd.y;\n    if( abs(k1+k2*t)<h )\n    {\n        return t>0.0 && t<tmax;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec3 p2 = vec3( mod(pos.x+1.0,3.0)-1.0, pos.yz );\n    vec3 p3 = vec3( mod(pos.x+2.0,3.0)-1.0, pos.yz );\n    vec3 p4 = vec3( mod(pos.x+3.0,3.0)-1.0, pos.yz );\n\n    float d1 = sdPlane(    pos-vec3(0.0,0.00,0.0) );\n    float d2 = sdSphere(   p2-vec3(0.0,0.30,0.0), 0.4 );\n    float d3 = sdBox(      p3-vec3(0.0,0.25,0.0), vec3(0.2,0.5,0.2) );\n    float d4 = sdCylinder( p4-vec3(0.0,0.0,0.0), 0.8,0.3 );\n      \n    return min(min(d1,d2),min(d3,d4));\n}\n\n//------------------------------------------------------------------\n//\n// Approximated soft shadows, based on\n//\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n//\n// and\n//\n// https://www.shadertoy.com/view/tscSRS\n//\n// and further fixed and improved\n//\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n \tfloat t = mint;\n    float res = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n     \tfloat h = map(ro + t*rd);\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n\n// montecarlo based shadow, for ground truth comparison\nfloat seed; float rand(void) { return fract(sin(seed++)*768.475278); }\n\nfloat realSoftShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, float w )\n{\n    vec3 uu = normalize(cross(rd,vec3(0,1,0)));\n    vec3 vv = normalize(cross(rd,uu));\n    \n    float tot = 0.0;\n    const int num = 32; // cast 32 rays\n\tfor( int j=0; j<num; j++ )\n    {\n        // uniform distribution on an disk\n        float ra = sqrt(rand());\n        float an = 6.283185*rand();\n        vec3 jrd = rd + w*ra*(uu*cos(an)+vv*sin(an));\n        \n        // raycast\n        float res = 1.0;\n        \n        for( int i=0; i<7; i++ ) // 7 objects\n        {\n            int k = i % 3;\n            bool sha = false;\n                 if(k==0) sha = shadowBox( ro, jrd, vec3(-4.0 + float(i),0.25,0.0), vec3(0.2,0.5,0.2), tmax);\n            else if(k==1) sha = shadowSphere(ro, jrd, vec3(-4.0 + float(i),0.3,0.0), 0.4, tmax);\n            else          sha = shadowCylinder( ro - vec3(-4.0 + float(i),0.0,0.0), jrd, 0.8, 0.3, tmax);\n            \n            if( sha ) { res=0.0; break; }\n        }\n        \n        \n        tot += res;\n    }\n    return tot/float(num);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    for( int i=0; i<128; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in int technique, in float lightSize)\n{ \n    vec3  col = vec3(0.0);\n    float t = castRay(ro,rd);\n\n    if( t>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tvec3 mate = vec3(0.3);\n\n        // key light\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\n        vec3  hal = normalize( lig-rd );\n        \n        float sha = (technique==0) ? realSoftShadow(pos, lig, 0.01, 3.0, lightSize ) \n                                   : apprSoftShadow(pos, lig, 0.01, 3.0, lightSize );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n        \n\t\tfloat spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*\n                    dif *\n                    (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\n        col +=       9.0*spe*vec3(0.90,0.80,1.0);\n        \n        // ambient light\n        float occ = (pos.y>0.01) ? 1.0 : calcAO( pos, nor );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n        col += mate*amb*occ*vec3(0.05,0.1,0.15);\n        \n        // fog\n        col *= exp( -0.0008*t*t*t );\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    float an = 12.0 - sin(0.1*iTime);\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    seed = sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)*sin(iTime);\n    \n    // animation\n    int technique = (fract(iTime/3.0)>0.5) ? 1 : 0;\n    float lightSize = 0.05 + 0.04*sin(0.7*iTime);\n\n    // render\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, technique, lightSize);\n\n        // gain\n        col = 1.8*col/(1.0+dot(col,vec3(0.333)));\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyXRD.jpg", "access": "shaders20k", "license": "mit", "functions": [[1365, 1435, 1460, 1460, 1475], [1477, 1477, 1508, 1508, 1599], [1601, 1601, 1636, 1636, 1664], [1666, 1666, 1710, 1710, 1827], [1829, 1829, 1913, 1913, 2185], [2187, 2187, 2274, 2274, 2461], [2463, 2463, 2548, 2548, 3070], [3072, 3142, 3168, 3168, 3620], [3622, 3892, 3965, 3965, 4295], [4298, 4366, 4384, 4384, 4424], [4426, 4426, 4513, 4513, 5492], [5494, 5494, 5526, 5526, 5726], [5728, 5728, 5769, 5769, 6339], [6341, 6341, 6383, 6383, 6644], [6646, 6646, 6722, 6722, 7809], [7811, 7811, 7863, 7863, 8040], [8143, 8143, 8200, 8215, 9381]], "test": "untested"}
{"id": "WdyXRm", "name": "scraggly circle back n forth", "author": "thisisthais", "description": "why is noise so hard", "tags": ["noise", "tbos"], "likes": 2, "viewed": 47, "published": "Public", "date": "1573680530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 random2D(vec2 st){\n  st=vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)));\n  return-1.+2.*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st){\n  vec2 i=floor(st);\n  vec2 f=fract(st);\n  // mixing function\n  vec2 u=f*f*(3.-2.*f);\n  \n  return mix(mix(dot(random2D(i+vec2(0.,0.)),f-vec2(0.,0.)),\n  dot(random2D(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n  mix(dot(random2D(i+vec2(0.,1.)),f-vec2(0.,1.)),\n  dot(random2D(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n}\n\nfloat circle(in vec2 _st,in float _radius){\n  vec2 l=_st-vec2(.5);\n  return 1.-smoothstep(_radius-(_radius*.01),\n  _radius+(_radius*.01),\n  dot(l,l)*4.);\n}\n\nfloat shape(vec2 st,float radius){\n  st=st-vec2(.5);\n  float r=length(st)*2.;\n  float a=atan(st.y,st.x);\n  float m=abs(mod(2.*iTime,2.*PI)-PI)/a*2.2;\n  float f=radius;\n  \n  // stripeys, where they coming from, idk\n  m+=noise(st+iTime*.1)*10.;\n  st-=.9;\n  m+=noise(st+iTime*.1)*5.;\n  st.y+=.4;\n  m+=noise(st+iTime*.1)*7.;\n  st=1.-st;\n  m+=noise(st+iTime*.1)*5.;\n  st+=.9;\n  m+=noise(st+iTime*.1)*10.;\n  \n  f+=sin(a*100.)*noise(st+iTime*.2)*.1;\n  f+=(sin(a*100.)*.1*pow(m,2.));\n  return smoothstep(f,f+.007,r);\n}\n\nfloat shapeBorder(vec2 st,float radius,float width){\n  return shape(st,radius)-shape(st,radius+width);\n}\n\nvec2 rotate2D(vec2 _st,float _angle){\n  _st-=.5;\n  _st=mat2(cos(_angle),-sin(_angle),\n  sin(_angle),cos(_angle))*_st;\n  _st+=.5;\n  return _st;\n}\n\nfloat squigglyCircle(vec2 st,float radius){\n  st=vec2(.5)-st;\n  float r=length(st)*2.;\n  float a=atan(st.y,st.x);\n  float m=abs(mod(iTime*2.,PI*2.)-PI)/3.6;\n  float f=radius;\n  m+=noise(st+iTime*.1)*.5;\n  \n  f+=sin(a*50.)*noise(st+iTime*.2)*.1;\n  f+=(sin(a*20.)*.1*pow(m,2.));\n  return 1.-smoothstep(f,f+.007,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st=fragCoord.xy/iResolution.yy;\n  st.x-=0.4;\n  vec3 color=vec3(0.);\n  st=rotate2D(st,PI*iTime/3.);\n  color=vec3(shapeBorder(st,1.5,30.));\n  color*=squigglyCircle(st,.5*(sin(iTime)+2.1));\n  \n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 58, 58, 169], [171, 256, 277, 277, 585], [587, 587, 630, 630, 742], [744, 744, 778, 778, 1254], [1256, 1256, 1308, 1308, 1360], [1362, 1362, 1399, 1399, 1506], [1508, 1508, 1551, 1551, 1822], [1824, 1824, 1880, 1880, 2107]], "test": "untested"}
{"id": "WdyXzm", "name": "Quadratic Bezier - over/under", "author": "vegardno", "description": "Find distance to (infinitely extended) quadratic bezier while also calculating whether the point is \"over or under\" the curve (AKA \"inside or outside\")\n\nHacky; NOT optimized.", "tags": ["2d", "bezier", "quadratic"], "likes": 1, "viewed": 95, "published": "Public", "date": "1573601195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// based on https://www.shadertoy.com/view/MlKcDD\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C, out vec3 col)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    vec2 e = 2. * (C - B);\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    col = 1. - vec3(0.1,0.4,0.7);\n    \n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n      \t//t = clamp( t, 0.0, 1.0 );\n\n        vec2 tangent = (1. - t) * c + t * e;\n        \n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n\n        // inside if true\n        if (tangent.x * qos.y < tangent.y * qos.x)\n            col = 1. - col;\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        //t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos1 = d + (c + b*t.x)*t.x;\n        vec2 tangent1 = (1. - t.x) * c + t.x * e;\n        float dis1 = dot(qos1,qos1);\n\n        vec2 qos2 = d + (c + b*t.y)*t.y;\n\t\tvec2 tangent2 = (1. - t.y) * c + t.y * e;\n        float dis2 = dot(qos2,qos2);\n\n        vec2 qos3 = d + (c + b*t.z)*t.z;\n\t\tvec2 tangent3 = (1. - t.z) * c + t.z * e;\n        float dis3 = dot(qos3,qos3);\n\n        vec2 qos;\n        vec2 tangent;\n        if (dis1 < dis2) {\n            if (dis1 < dis3) {\n                qos = qos1;\n                tangent = tangent1;\n            } else {\n                qos = qos3;\n                tangent = tangent3;\n            }\n        } else {\n            if (dis2 < dis3) {\n                qos = qos2;\n                tangent = tangent2;\n            } else {\n                qos = qos3;\n                tangent = tangent3;\n            }\n        }\n        \n        res = length( qos );\n\n\t\tif (tangent.x * qos.y < tangent.y * qos.x)\n            col = 1. - col;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n\tvec2 v0 = vec2(-.5 + .1 * cos(1. * iTime), .1 * sin(1. * iTime));\n    vec2 v1 = vec2( .0 + .3 * cos(2. * iTime), .0);\n    vec2 v2 = vec2( .5 + .1 * cos(3. * iTime), .1 * sin(3. * iTime));\n\n    vec3 col;\n    float d = sdBezier( p, v0,v1,v2, col );\n\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyXzm.jpg", "access": "shaders20k", "license": "mit", "functions": [[1131, 1172, 1236, 1236, 3412], [3415, 3415, 3472, 3472, 3946]], "test": "untested"}
{"id": "WdyXzW", "name": "Old school TV", "author": "GrooveDZX", "description": "Geometric Modeling practical work", "tags": ["spheremarchingcsg"], "likes": 2, "viewed": 51, "published": "Public", "date": "1573497316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ID3D - TP : Blobs\n// Teacher : Eric Galin\n// Student : Zahidi Ali\n#define PI 3.14\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T = 0.5;\n\nconst float rA = 10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB = 40.0;\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R)\n{\n  float u = clamp(x / R, 0.0, 1.0);\n  float v = (1.0 - u * u);\n  return v * v * v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e * falloff(length(p - c), R);\n}\n\n// Segment skeleton\n// p : point\n// a : First extremity of the skeleton\n// b : Second extremity of the skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n  float len;\n  vec3 u = normalize(b - a);\n  vec3 ap = p - a;\n  vec3 bp = p - b;\n  if (dot(ap, u) < 0.) // We are on the left of the segment\n    len = length(p - a);\n  else if (dot(bp, u) > 0.) //We are on the right of the segment\n    len = length(b - p);\n  else\n    len = sqrt((length(ap) * length(ap)) - (dot(ap, u) * dot(ap, u))); // On calcule la distance au segment\n  return e * falloff(len, R);\n}\n\n// Disk skeleton\n// p : point\n// c : center of skeleton\n// n : normal of the skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat disk(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.0;\n  // First get the distance to c on the disk plane\n  vec3 pc = p - c;\n  float pcDn = abs(dot(pc, n));\n  float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n  if (projected2C <= R)\n    len = pcDn;\n  else\n  {\n    len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n  }\n  return e * falloff(len, R);\n}\n\n// Circle skeleton\n// p : point\n// c : center of skeleton\n// n : normal of the skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat circle(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.0;\n  // First get the distance to c on the disk plane\n  vec3 pc = p - c;\n  float pcDn = abs(dot(pc, n));\n  float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n  if (projected2C <= R / 2.)\n  {\n    len = R - projected2C;\n  }\n  else\n  {\n    len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n  }\n  return e * falloff(len, R);\n}\n\n// Cylinder skeleton\n// p : point\n// c : center of skeleton\n// n : orientation of the skeleton\n// e : energy associated to skeleton\n// H : height of the skeleton\n// R : radius\nfloat cylinder(vec3 p, vec3 c, vec3 n, float e, float H, float R)\n{\n  float len = 0.;\n    \n  vec3 pc = p - c;\n  float vDist = abs(dot(pc, n));\n  float hDist = sqrt(pow(length(pc), 2.0) - pow(vDist, 2.0));\n\n  // \tOrientate the normal to where p is from c\n  //If we are on the extremities\n  if (vDist > H)\n  {\n    if (dot(pc, n) < 0.0)\n      n = -n;\n    //Compute center of the concerned disk\n    vec3 cc = c + (n * H);\n\n    vec3 pcc = p - cc;\n    float pccDn = abs(dot(pcc, n));\n    float projected2CC = sqrt(pow(length(pcc), 2.0) - pow(pccDn, 2.0));\n    if (projected2CC <= R)\n      len = pccDn;\n    else\n    {\n      len = sqrt(pow(pccDn, 2.0) + pow(projected2CC - R, 2.0));\n    }\n  }\n  else\n  {\n    //\tget the coplanar disk center to the point\n    vec3 cc = c + n * dot(p - c, n);\n    len = length(p - cc) - R;\n  }\n  return e * falloff(len, R);\n}\n\n// Sphere skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat sphere(vec3 p, vec3 c, float e, float R)\n{\n  float len = length(p - c) - R;\n  return e * falloff(len, R);\n}\n\n// Hemisphere skeleton\n// p : point\n// c : center of skeleton\n// n : normal\n// e : energy associated to skeleton\n// R : radius\nfloat hemisphere(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.;\n  if (dot(p - c, n) > 0.) // On top\n  {\n    len = length(p - c) - R;\n  }\n  else\n  {\n    vec3 pc = p - c;\n    float pcDn = abs(dot(pc, n));\n    float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n    if (projected2C <= R)\n      len = pcDn;\n    else\n    {\n      len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n    }\n  }\n  return e * falloff(len, R);\n}\n\n// Bubble skeleton\n// p : point\n// c : center of skeleton\n// n : Elongation axis\n// e : energy associated to skeleton\n// R : radius\nfloat bubble(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.0;\n  len = length(p - c) - R + min(R, pow(dot(p - c, n), 2.));\n  return e * falloff(len, R);\n}\n\n// Cone skeleton\n// p : point\n// c : center of skeleton\n// n : normal of the skeleton\n// e : energy associated to skeleton\n// H : Height\n// R : radius\nfloat cone(vec3 p, vec3 c, vec3 n, float e, float H, float R)\n{\n  float len = 10.;\n  vec3 pc = p - c;\n  //\tGet the tip\n  vec3 tip = c - n * H;\n  //\tGet the bottom extremity\n  //\tGet the projected Vector on the plane\n  vec3 planeProj = normalize(pc - n * dot(pc, n));\n  //\tCompute the extremity\n  vec3 extremity = c + planeProj * R;\n  //Get the vector going along the edge of the cone\n  vec3 edge = normalize(extremity - tip);\n  //Get the closest point on the cone\n  vec3 q = tip + (edge * dot(p - tip, edge));\n  if (dot(q - extremity, -n) < 0.)\n  {\n    float pcDn = abs(dot(pc, n));\n    float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n    if (projected2C <= R)\n      len = pcDn;\n    else\n    {\n      len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n    }\n  }\n  else if (dot(q - extremity, -n) < H) // If q is in the middle of the cone\n  {\n    //Get the vector going along the edge of the cone and forming a right angle\n    //triangle with p\n    vec3 edge90 = tip + (edge * dot(p - tip, edge)) - tip;\n    len = sqrt(pow(length(p - tip), 2.) - pow(length(edge90), 2.));\n  }\n  else // We are on the top of the cone\n  {\n    len = length(p - tip);\n  }\n\n  return e * falloff(len, R);\n}\n\n// Box skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// W : width of the skeleton\n// H : height of the skeleton\n// D : depth of the skeleton\nfloat box(vec3 p, vec3 c, float e, float R, float W, float H, float D)\n{\n  float len = 0.;\n  vec3 lenVec = vec3(0.0, 0.0, 0.0);\n  \n  //Component wise length computation\n  lenVec.x = max(abs(c.x - p.x) - W / 2.0,0.);\n  lenVec.y = max(abs(c.y - p.y) - H / 2.0,0.);\n  lenVec.z = max(abs(c.z - p.z) - D / 2.0,0.);\n    \n  len =  length(lenVec);\n    \n  return e * falloff(len, R);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a, float b)\n{\n  return a + b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a, float b)\n{\n  return max(a, b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a, float b)\n{\n  return min(a, b);\n}\n\n// Substraction\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Minus(float a, float b, float T)\n{\n  return min(a, 2. * T - b);\n}\n\n// Animation interpolation\nfloat interpolation(float duration, float transitionDuration, float transition1, float transition2)\n{\n  float t = mod(iTime, duration);\n  if (t < transition1 || t > transition2 + transitionDuration)\n    return 1.;\n  else if (t > transition1 + transitionDuration && t < transition2)\n    return 0.;\n  else if (t < transition2)\n    return cos((t - transition1) / transitionDuration * (PI / 2.));\n  else\n    return sin((t - transition2) / transitionDuration * (PI / 2.));\n}\n\n// Potential field of the object\n// p : point\nvec2 Object(vec3 p)\n{\n  p.z = -p.z;\n  float v;\n  /* \n  // PRIMITIVES\n  float seg = segment(p, vec3(0.0, 0.0, 0.0), vec3(5.0, 0.0, 0.0), 1.0, 1.0);\n  float dis = disk(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 2.0);\n  float cir = circle(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 5.0);\n  float cyl = cylinder(p, vec3(0.0, 0.0, 0.0), rotateZ(vec3(0.0, 0.0, 1.0), 10. * cos(iTime)), 1., 5.0, 1.0);\n  float sph = sphere(p, vec3(1., 1., 1.), 1.0, 1.0);\n  float bub = bubble(p, vec3(0., 0., 0.), vec3(1.0, 0., 0.), 1.0, 1.0);\n  float con = cone(p, vec3(0., 0., 0.), vec3(-1.0, 0., 0.), 5.0, 3.0, 1.0);\n  float bx = box(p, vec3(0.0, 0.0, 0.0), 1., 1., 1., 3., 2.);\n  */\n  float t = 1. - interpolation(30., 5., 5., 20.); // Animation factor\n  vec3 tvPos = vec3(0.0, 0.0, 0.0);\n  vec3 tvNormal = vec3(0.0, 0.0, -1.0); // Points to the front of the tv\n  vec3 tvUp = vec3(0.0, 1.0, .0);\n  vec3 hOffset = t * 4. * tvNormal;\n  vec3 vOffset = t * 2. * tvUp;\n  vec3 headPos = tvPos + tvUp * 2.5;\n  vec3 screenPos = (tvPos + tvNormal * 0.75) + hOffset;\n    \n  float tvWidth = 7.;\n  float tvHeight = 5.;\n  float tvDepth = 2.;\n  float antennaWidth = .75;\n  float tvBody = box(p, tvPos, 1., 1., tvWidth, tvHeight, tvDepth);\n  float tvHead = hemisphere(p, headPos, tvUp, 1., antennaWidth);\n  float screen = box(p, screenPos, 1., 1., tvWidth - 2., tvHeight - 2., tvDepth - 1.);\n  float buttonLeft = cylinder(p, tvPos - vec3(tvWidth / 2. - 0.5, tvHeight / 2. - .25, tvDepth / 2.) + hOffset,\n                              tvNormal, 1.0, 0.5, .25);\n  float buttonRight = cylinder(p, tvPos - vec3(-tvWidth / 2. + 0.5, tvHeight / 2. - .25, tvDepth / 2.) + hOffset,\n                               tvNormal, 1.0, 0.5, .25);\n  float tvBack = cone(p, tvPos - tvDepth / 2. * tvNormal - hOffset, tvNormal, 1., 3., 1.5);\n\n  //DETAILS\n\n  tvHead = Union(tvHead, segment(p, headPos + t * 2. * (tvNormal * 1.5 + tvUp * 3. - 2. * cross(tvNormal, tvUp)),\n                                 headPos + tvNormal * 1.5 + tvUp * 3. - 2. * cross(tvNormal, tvUp) +\n                                     t * 2. * (tvNormal * 1.5 + tvUp * 3. - 2. * cross(tvNormal, tvUp)),\n                                 1.0,\n                                 .25));\n  tvHead = Union(tvHead, segment(p, headPos + t * 2. * (tvNormal * 1.5 + tvUp * 3. + 2. * cross(tvNormal, tvUp)),\n                                 headPos + tvNormal * 1.5 + tvUp * 3. + 2. * cross(tvNormal, tvUp) +\n                                     +t * 2. * (tvNormal * 1.5 + tvUp * 3. + 2. * cross(tvNormal, tvUp)),\n                                 1.0,\n                                 .25));\n  tvBody = Minus(tvBody,\n                 box(p, tvPos + tvNormal, 1., 1., tvWidth - 2., tvHeight - 2., tvDepth - 1.), T);\n\n  tvBody = Minus(tvBody,\n                 cylinder(p, tvPos - vec3(tvWidth / 2. - 0.5, tvHeight / 2. - .25, tvDepth / 2.),\n                          tvNormal, 1.0, 0.5, .25),\n                 T);\n  tvBody = Minus(tvBody,\n                 cylinder(p, tvPos - vec3(-tvWidth / 2. + 0.5, tvHeight / 2. - .25, tvDepth / 2.),\n                          tvNormal, 1.0, 0.5, .25),\n                 T);\n\n  tvBody = Minus(tvBody,\n                 segment(p, tvPos - vec3(tvWidth / 2. - 2., tvHeight / 2. - .25, tvDepth / 2. + .5),\n                         tvPos - vec3(-tvWidth / 2. + 2., tvHeight / 2. - .25, tvDepth / 2. + .5),\n                         1., .5),\n                 T);\n\n  tvBody = Minus(tvBody,\n                 cone(p, tvPos - tvDepth / 2. * tvNormal, tvNormal, 1., 3., 1.5),\n                 T);\n\n  v = Union(tvBody, tvHead);\n  v = Union(v, screen);\n  v = Union(v, buttonLeft);\n  v = Union(v, buttonRight);\n  v = Union(v, tvBack);\n  if (screen > 0.5)\n    return vec2(v - T, dot(p - tvPos, cross(tvNormal, tvUp)) / 4.);\n  else\n    return vec2(v - T, -999.);\n}\n\n// Calculate object normal\n// p : point\nvec4 ObjectNormal(in vec3 p)\n{\n  float eps = 0.0001;\n  vec3 n;\n  vec2 v = Object(p);\n  n.x = Object(vec3(p.x + eps, p.y, p.z)).x - v.x;\n  n.y = Object(vec3(p.x, p.y + eps, p.z)).x - v.x;\n  n.z = Object(vec3(p.x, p.y, p.z + eps)).x - v.x;\n  return vec4(normalize(n), v.y);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h, out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;\n    vec3 p = o + t * u;\n    float v = Object(p).x;\n    // Hit object\n    if (v > 0.0)\n    {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += Epsilon;\n    // Escape marched far away\n    if (t > rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h, out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;\n    vec3 p = o + t * u;\n    float v = Object(p).x;\n    // Hit object\n    if (v > 0.0)\n    {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, abs(v) / 4.0);\n    // Escape marched far away\n    if (t > rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(0.4, 0.3, 0.75), vec3(0.75, 0.85, 1.0), d.y * 0.5 + 0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25 * Background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5 * (1.0 + dot(n, l));\n\n  c += diff * lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t = float(n) / (float(Steps - 1));\n  return vec3(t, 0.25 + 0.75 * t, 0.5 - 0.5 * t);\n}\n\nvec3 screenColor(float x, float t)\n{\n  // t at 1 means\n  float freq = 10.;\n  float speed = 3.;\n  vec3 col = t * vec3(cos(x * freq + iTime * speed),\n                      cos(x * freq + freq / 2. + iTime * speed),\n                      cos(x * freq + freq + iTime * speed)) +\n             (1. - t) * vec3(0.);\n  // Output to screen\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp * pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  vec2 mouse = iMouse.xy / iResolution.xy;\n\n  /*ro = rotateY(ro, -mouse.x * 5.0);\n  rd = rotateY(rd, -mouse.x * 5.0);\n  ro = rotateZ(ro, -mouse.y * 5.0);\n  rd = rotateZ(rd, -mouse.y * 5.0);*/\n\n  float a = iTime * 0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit, s);\n  vec3 pos = ro + t * rd;\n  // Shade background\n  vec3 rgb = Background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec4 nScreen = ObjectNormal(pos);\n    vec3 n = nScreen.xyz;\n    float t = interpolation(30., .25, 5., 24.75);\n    if (nScreen.w == -999.)\n      // Shade object with light\n      rgb = Shade(pos, n);\n    else\n      rgb = screenColor(nScreen.w, t);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 315, 346, 346, 452], [454, 454, 485, 485, 592], [594, 594, 625, 625, 732], [734, 797, 830, 830, 915], [932, 1040, 1087, 1087, 1129], [1131, 1294, 1351, 1351, 1753], [1755, 1892, 1946, 1946, 2281], [2283, 2422, 2478, 2478, 2837], [2839, 3015, 3082, 3082, 3862], [3864, 3973, 4021, 4021, 4086], [4088, 4215, 4275, 4275, 4664], [4666, 4798, 4854, 4854, 4965], [4967, 5118, 5181, 5181, 6321], [6323, 6503, 6575, 6575, 6879], [6895, 6948, 6979, 6979, 6997], [6999, 7087, 7118, 7118, 7140], [7142, 7237, 7275, 7275, 7297], [7299, 7394, 7434, 7434, 7465], [7467, 7494, 7595, 7595, 7963], [7965, 8011, 8032, 8032, 11813], [11815, 11855, 11885, 11885, 12128], [12130, 12235, 12287, 12287, 12703], [12705, 12810, 12868, 12868, 13303], [13305, 13346, 13371, 13371, 13449], [13451, 13512, 13540, 13557, 13882], [13884, 13916, 13940, 13940, 14035], [14037, 14037, 14073, 14091, 14383], [14385, 14385, 14440, 14440, 15566]], "test": "untested"}
{"id": "wdyXzz", "name": "Parallax Window Box Test", "author": "Delvar", "description": "just a test of parallax windows for another shader i'm tinkering with, thought id share it separately.\nUsed here https://www.shadertoy.com/view/WdyXzz", "tags": ["test", "parallax", "window"], "likes": 18, "viewed": 306, "published": "Public", "date": "1574261870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// =================================================================\n//  'Parallax Window Box Test'\n//  https://www.shadertoy.com/view/wdyXzz\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//  Used in this shader https://www.shadertoy.com/view/WdyXzz\n//\n//\tCredits: \n//\tWindows inspired by but no longer bassed off otaviogood : 'Skyline' : https://www.shadertoy.com/view/XtsSWs\n//\tStarted from scratch with a parallax affect, lots of info taken from differnt palces but mainly this implementation, https://andrewgotow.com/2018/09/09/interior-mapping-part-1/\n//\tSome very good points here, like making the effect in texture space, and the optimisation of only needing to check 3 faces, which seems obvius once I read it.\n//\tObviusly my implementation doesn't use a cube texture for the interior, instead generates some pastal shaded walls.\n//\tI have added a fade to solid colour at distance too, no point doing the extra work for a window thats only a few pixles wide.\n//\n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 10.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.0001\n\n#define RAY_MAX_STEPS_SHADOW 30\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.01\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET 0.041\n\n#define RAY_MAX_STEPS_REFLECTION 30\n#define RAY_MAX_DISTANCE_REFLECTION 10.0\n#define OBJECT_MIN_SURFACE_DISTANCE_REFLECTION 0.01\n#define OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET 0.041\n\n#define PI 3.1415926535897932384626433832795\n#define PARALLAX_INTERROOM_WALL_THICKNESS 0.47\n#define PARALLAX_INTERROOM_WALL_COLOUR vec3(0.01)\n#define PARALLAX_WINDOW_SURROUND_THICKNESS 0.1\n#define PARALLAX_WINDOW_SURROUND_COLOUR vec3(0.05)\n\n//Just for fun i added a cube map for the interior mapping ... \n//#define PARALLAX_CUBE_MAP iChannel0\n\n#define DEBUG_RAY_DITHER\n//#define DEBUG_CAMERA_FLY\n#define DEBUG_CAMERA_TABLE\n#define DEBUG_DISTANCE_FOG\n#define DEBUG_LIGHTING\n#define DEBUG_AMBIENT\n//#define DEBUG_AMBIENT_OCCLUSION\n#define DEBUG_OCCLUSION   // used instead of DEBUG_AMBIENT_OCCLUSION when you want the efect but without adding DEBUG_AMBIENT or DEBUG_LIGHTING\n#define DEBUG_REFLECTION\n#define DEBUG_REFLECTION_FRESNEL\n\n//change the filtering method, Linier, Smoothstep or Quintic, little visual change when noise is stacked but can impact performance.\n//#define VALUE_NOISE_FILTER_SMOOTH\n#define VALUE_NOISE_FILTER_QUINTIC\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_WINDOW\t1\n#define MAT_WALL\t2\n#define MAT_SOLID\t3\n\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\n// ========== ==========\n\n// ========== Constants ==========\n\nconst float gridSize = 5.0;\nconst float gridSizeH = gridSize*0.5;\nconst float gridSizeQ = gridSize*0.25;\n\nconst float roadLength = gridSize*5.0;\nconst float roadLengthH = roadLength*0.5;\nconst float roadLengthQ = roadLength*0.25;\n\nconst float roadWidth = gridSize;\nconst float roadWidthH = roadWidth*0.5;\nconst float roadWidthQ = roadWidth*0.25;\n\nconst float blockSize = roadLength + gridSize;\nconst float blockSizeH = blockSize*0.5;\nconst float blockSizeQ = blockSize*0.25;\n\nconst vec3 roadLightColour = vec3(0.9,0.6,0.1);\nconst float roadLightBrightness = 5.0;\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\nray getRefRay(vec3 origin, vec3 normal, vec3 originalDirection) {\n    ray ray;\n    ray.direction = normalize(reflect(originalDirection, normal));\n    ray.origin = origin + ray.direction*OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET;\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HH,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HH))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin((st+vec3(HD,HH,HE))*vec3(HH,HE,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nvec3 valueNoiseFilter(vec3 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat valueNoiseFilter(float x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat lengthSquare(vec2 a) {\n    return dot(a,a);\n}\n\nfloat lengthSquare(vec3 a) {\n    return dot(a,a);\n}\n\n//get the maximum of the 3 componants\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 3d, Unsigned\nfloat valueNoise3du(vec3 samplePoint) {\n    vec3 pointI = floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    vec3 u = valueNoiseFilter(pointF);\n\n    //Slight Optimisation\n    vec4 m = mix(\n        vec4(\n            hash31(pointI ),//bbl,\n            hash31(pointI + vec3(0.0,1.0,0.0) ),//btl,\n            hash31(pointI + vec3(0.0,0.0,1.0) ),//fbl,\n            hash31(pointI + vec3(0.0,1.0,1.0) )//ftl\n        ),vec4(\n            hash31(pointI + vec3(1.0,0.0,0.0) ),//bbr,\n            hash31(pointI + vec3(1.0,1.0,0.0) ),//btr,\n            hash31(pointI + vec3(1.0,0.0,1.0) ),//fbr,\n            hash31(pointI + vec3(1.0,1.0,1.0) )//ftr\n        ),u.x);\n\n    vec2 n = mix(m.xz, m.yw, u.y);\n    return mix(n.x,n.y,u.z);\n}\n\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(pointI),hash11(pointI + 1.0 ),valueNoiseFilter(fract(samplePoint)));\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(mod(pointI, wrap)),hash11(mod(pointI + 1.0 ,wrap)),valueNoiseFilter(fract(samplePoint)));\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n// All primitives are centered at the origin.\n\n// == 2D ==\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// == ==\n\n// == 3D ==\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdXAlignedCapsule( vec3 p, float l, float r )\n{\n    p.z -= clamp( p.z, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdYAlignedCapsule( vec3 p, float l, float r )\n{\n    p.y -= clamp( p.y, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdZAlignedCapsule( vec3 p, float l, float r )\n{\n    p.x -= clamp( p.x, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdXAlignedCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdYAlignedCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// == ==\n\n// ========== ==========\n\nfloat getFog(vec3 direction, float time) {\n    time=time*0.1;\n    float fog = 0.0;\n    vec2 t = vec2(time,-time);\n\n    fog+= valueNoise3du(direction + vec3(t.x));\n    fog+= valueNoise3du((direction + vec3(t.xyx)) * 2.0) * 0.5;\n    fog+= valueNoise3du((direction + vec3(t.xxy)) * 4.0) * 0.25;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 8.0) * 0.125;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 16.0)* 0.0625;\n    \n    //return fog/1.9375;\n    return fog;//*0.516129032258;\n}\n\n// --quick hack to strobe the road lights so they always strobe away from the camera\n\nfloat getRoadLightStrobe(float distanceFromCamera, float time) {\n    return smoothstep(0.0,1.0,clamp(sin(time*5.0 - (distanceFromCamera/RAY_MAX_DISTANCE)*PI*5.0)*0.5,0.0,1.0));\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    time *= 0.05;\n\n    float b = blockSize;\n\n    vec3 path[16];\n    int i=0;\n\n    path[i++] = vec3( 0.0*b,\t0.0,\t 0.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b - gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b + gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b - 1.0,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t-2.0*b+1.0);\n    path[i++] = vec3( 4.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t 0.0*b);\n\n    time = mod(time,float(path.length()));\n\n    float cornerRadius = 0.1;\n    float inverseCornerRadius = 1.0 - cornerRadius;\n\n    int timeI = int(floor(time));\n    float timeF = fract(time)*inverseCornerRadius+cornerRadius;\n\n    vec3 p0 = path[timeI];\n    vec3 r;\n    timeI += 1;\n    if (timeI>=path.length()) {\n        timeI = 0;\n    }\n    vec3 p1 = path[timeI];\n    if (timeF >= inverseCornerRadius) {\n        timeI += 1;\n        if (timeI>=path.length()) {\n            timeI = 0;\n        }\n        vec3 p2 = path[timeI];\n        vec3 p01 = p0 + ((p1-p0) * (inverseCornerRadius));\n        vec3 p12 = p2 + ((p1-p2) * (inverseCornerRadius));\n        float t = map(timeF,inverseCornerRadius,1.0,0.0,1.0);\n        vec3 a = mix(p01,p1,t);\n        vec3 b = mix(p1,p12,t);\n        r= mix(a,b,t);\n    } else {\n        r=mix( p0, p1, timeF);\n    }\n\n\n    vec3 rd;\n    rd.y = (sin(time*5.0) + sin(time*9.0)) * 0.8;\n    rd.x = sin(time*6.0) + sin(time*8.0);\n    rd.z = sin(time*7.0) + sin(time*7.0);\n\n    rd *= sin(fract(time)*PI);\n    rd *= clamp(length(r)/gridSize-gridSize,0.0,1.0);\n    r+=rd*0.5;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 lookAt, float distance, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    \n\tmat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw );\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.origin = lookAt + camera.forward*-distance;\n    \n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n        vec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n\n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0);\n        roll = clamp(roll,-0.5,0.5);//clamp(-0.1,0.1,1.0-pow(1.0-roll,5.0));\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #elif defined(DEBUG_CAMERA_TABLE)\n    return getCamera(vec3(0.0)+vec3(0.5), 2.5, 0.0, -mouse.y*PI, -mouse.x*2.0*PI,  0.5);\n    #else\n    return getCamera(vec3(0.0,0.0,-5.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    #endif\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float time) {\n    rayMarchHit hit;\n    #if defined(DEBUG_USE_SQUARE_DISTANCE)\n    hit.distance = RAY_MAX_DISTANCE*RAY_MAX_DISTANCE;\n    #else\n    hit.distance = RAY_MAX_DISTANCE;\n    #endif\n\n    float newDistance = hit.distance;\n\n    newDistance = min(newDistance, sdBox( position-vec3(0.5), vec3(0.48) )-0.02);\n    newDistance = min(newDistance, sdBox( position-vec3(0.5) - vec3(1.0,0.0,sin(time*0.5)), vec3(0.48))-0.02);\n    newDistance = min(newDistance, sdBox( position-vec3(0.5) - vec3(-1.0,sin(time*0.5),0.0), vec3(0.48))-0.02);\n    newDistance = min(newDistance, sdBox( position-vec3(0.5) - vec3(sin(time*0.5),1.0,0.0), vec3(0.48))-0.02);\n   \n    newDistance = min(newDistance, sdYAlignedCappedCylinder( position-vec3(0.5,-0.5,0.0), 0.98, 0.48 )-0.02);\n    newDistance = min(newDistance, sdXAlignedCappedCylinder( position-vec3(1.25,-0.5,0.0), 1.48, 0.23 )-0.02);\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WALL;\n    }\n    \n    /*if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WINDOW;\n    }*/\n    \n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    float accumilatedDistance = 0.0;\n    float modulatedMinSurfaceDistance = minSurfaceDistance;\n    int i;\n    for(i=0; i<maxSteps; i++) {\n        float distanceRatio = clamp((accumilatedDistance/maxDistance),0.0,1.0);\n\n        //the more itterations the less precise we are, improve perfomance a bit with only mild artifacts\n        modulatedMinSurfaceDistance=mix(minSurfaceDistance,minSurfaceDistance*20.0,distanceRatio);\n\n        vec3 currentPoint = ray.origin + ray.direction * accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, time);\n\n        #if defined (DEBUG_RAY_DITHER)\n        if(hit.distance > modulatedMinSurfaceDistance*2.0) {\n            //we take smaller steps closer to the camera, gives a better Neon result.           \n            hit.distance *= 0.5+mix(distanceRatio,1.0, hash31(fract(currentPoint+time)))*0.5;\n        }\n        #endif\n\n        accumilatedDistance += hit.distance;\n\n        if(accumilatedDistance >= maxDistance) {\n            accumilatedDistance = maxDistance;\n            hit.surfaceNormal = -ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //forget bouncing back, if we end up inside just terminate\n        else if(hit.distance < modulatedMinSurfaceDistance) {\n            break;\n        }\n\n    }\n    hit.iteration = i;\n    hit.distance = max(0.0,accumilatedDistance);\n    return hit;\n}\n// ========== ==========\n\n// ========== Texturing ==========\n\n\nfloat getConcreteErosion(vec3 position, bool showLine) {\n    float concrete=0.0;\n    concrete+= valueNoise3du(position * 4.0) * 0.25;\n    concrete+= valueNoise3du(position * 8.0) * 0.125;\n    concrete+= valueNoise3du(position * 16.0) * 0.0625;\n    concrete+= valueNoise3du(position * 32.0) * 0.03125;\n    concrete/=0.25+0.125+0.0625+0.03125;\n    concrete = (abs(concrete*2.0-1.0)+0.3);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        line = 1.0-clamp(line*25.0,0.0,1.0);\n        line*=line*line*4.0;\n        line = clamp(1.0-line,-10.0,1.0);\n        concrete = min(line,concrete*line);\n    }\n\n    return concrete;\n}\n\nfloat sampleConcrete(vec3 position, bool showLine) {\n    float concrete = valueNoise3du(position * 4.0);\n    concrete += valueNoise3du(position * 8.0) * 0.5;\n    concrete += valueNoise3du(position * 16.0) * 0.25;\n    concrete += valueNoise3du(position * 32.0) * 0.125;\n    concrete /= 1.0+0.5+0.25+0.125;\n    concrete = (abs(concrete*2.0-1.0)+0.8);\n    concrete = clamp(concrete,0.0,1.0);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        line = 1.0-clamp(line*25.0,0.0,1.0);\n        line*=line*line;\n        line = 1.0-clamp(line-0.2,0.0,1.0);\n        concrete *= line;\n    }\n\n    return concrete;\n}\n\nfloat getConcrete(vec3 position, inout vec3 normal, bool showLine) {\n    float center=getConcreteErosion(position, showLine);\n\n    vec3 rightDir;\n\tvec3 upDir;\n\n    if(abs(normal.y)<0.999) {\n    \trightDir = normalize(cross(vec3(0.0, 1.0, 0.0), normal));\n\t\tupDir = normalize(cross(normal, rightDir));\n    } else {\n        rightDir = normalize(cross(vec3(1.0, 0.0, 0.0), normal));\n\t\tupDir = normalize(cross(normal, rightDir));\n    }\n    float right = getConcreteErosion(position+rightDir*0.01, showLine);\n    float up = getConcreteErosion(position+upDir*0.01, showLine);\n    //FIXME: apply correct normal calculations, this is NOT how you do it!\n    vec3 pNormal;\n    pNormal=(vec3(\n        right - center,\n        up - center,\n        right - center\n    ));\n\n    pNormal*=-1.3;\n    normal = normalize(normal + pNormal);    \n\t   \n    //float concrete=clamp(getConcreteErosion(position, showLine)+0.5,0.0,1.0);\n    float concrete=sampleConcrete(position, showLine);\n    return concrete;\n}\n\nvoid textureSolid(in vec3 block, inout ray ray, inout rayMarchHit hit, inout vec3 colour, in float time) {\n    float concrete = getConcrete(hit.origin, hit.surfaceNormal, true);\n    colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n    colour = clamp(colour,vec3(0.0),vec3(1.0));\n    colour *= concrete;\n}\n\n    \n    //Features to implement?\n    //curtains_left\n    //curtains_right\n    //curtains_both\n\t//blinds\n    //circle lights\n    //light spacing\n    //door\n    //door colour\n    \n\t//brightness\n    //light colour\n    //strip lights x, z\n    //ceiling colour\n    //wall colour\n    //floor colour\n    \n    \nvoid textureParallaxWindow(in vec3 block, inout ray ray, inout rayMarchHit hit, in vec2 uv, in vec3 cell, in vec3 lightColour, in float brightness, inout vec3 colour, in float time) {\n    \n    if(abs(uv.x)>PARALLAX_INTERROOM_WALL_THICKNESS||abs(uv.y)>PARALLAX_INTERROOM_WALL_THICKNESS) {\n        colour=PARALLAX_INTERROOM_WALL_COLOUR;\n        return;\n    }\n    \n    vec3 absNormal = abs(hit.surfaceNormal);\n    vec3 flatNormal;\n\n    //flaten the normal so we still project axis aligned with no distortion of y axis curve.\n    if(absNormal.y > absNormal.x && absNormal.y > absNormal.z) {\n        flatNormal = vec3(0.0,1.0,0.0);\n    } else {\n        flatNormal = normalize(vec3(hit.surfaceNormal.x,0.0,hit.surfaceNormal.z));\n    }    \n    \n    vec3 roomSize = vec3(1.0) ;\n    roomSize.z += hash31(cell*16.8736)*2.0;\n        \n    vec3 tangent = normalize(cross(vec3(0.0,1.0,0.0),flatNormal));\n    vec3 bitangent = normalize(cross(flatNormal,tangent));\n    mat3 tMatrix = mat3(tangent,bitangent,flatNormal);\n    \n    vec3 rayDir = normalize(ray.direction*tMatrix)/roomSize;\n    vec3 hitPos = vec3(uv.x,uv.y,0.0)/roomSize;\n\t\n    //Room cube, We assume the room is 1 unit cube from -0.5 to +0.5\n    vec3 roomMin = vec3(-PARALLAX_INTERROOM_WALL_THICKNESS,-PARALLAX_INTERROOM_WALL_THICKNESS,-1.0);\n    vec3 roomMax = vec3(PARALLAX_INTERROOM_WALL_THICKNESS,PARALLAX_INTERROOM_WALL_THICKNESS,0.0);\n    vec3 roomMid = vec3(0.0);\n    \n    //we only need to interesct 3 planes per ray, looking at the direction of the ray find which 3 its heading towards.\n    vec3 planes = mix(roomMin, roomMax, step(0.0, rayDir));\n    //now do the parallax calcualtion to find the project position 'into' the window\n    vec3 planeIntersect = ((planes-hitPos)/rayDir);\n    float distance;\n    \n\t#if defined(PARALLAX_CUBE_MAP)\n    \tdistance = min(planeIntersect.x,min(planeIntersect.y,planeIntersect.z));\n    \tvec3 intersectionPos = ((hitPos + rayDir * distance) );\n    \tvec3 samplePoint = intersectionPos * rotateY(hash31(cell)*PI);\n    \tcolour = texture( PARALLAX_CUBE_MAP, samplePoint ).xyz;\n    \tintersectionPos-=roomMin;\n    #else\n        if(planeIntersect.x < planeIntersect.y && planeIntersect.x < planeIntersect.z) {\n            //Left/Right wall\n            colour=clamp(hash33(cell*48.2270)+0.7,0.0,1.0);\n            distance = planeIntersect.x;\n        } else if (planeIntersect.y < planeIntersect.x && planeIntersect.y < planeIntersect.z) {\n            if(rayDir.y<0.0) {\n                //Floor\n                colour = clamp(hash33(cell*81.7619)+0.3,0.0,1.0);\n            } else {\n                //Ceiling\n                colour =mix(clamp(hash33(cell*20.9912)+0.3,0.0,1.0),\n                            lightColour*6.0,\n                        abs(sin((planeIntersect.y*PI*3.0))));\n            }\n            distance = planeIntersect.y;\n        } else if (planeIntersect.z < planeIntersect.x && planeIntersect.z < planeIntersect.y) {\n            //Back wall\n            colour=clamp(hash33(cell*54.8454)+0.7,0.0,1.0);\n            distance = planeIntersect.z;\n            //colour=vec3(planeIntersect.z);\n        } else {\n            //error!\n            colour=PARALLAX_INTERROOM_WALL_COLOUR;\n            distance = 0.0;   \n        }\n        vec3 intersectionPos = ((hitPos + rayDir * distance) - roomMin);\n    #endif\n        //add some distance and height shadow    \n        colour*=clamp(intersectionPos.z*(1.0-intersectionPos.y)+0.2,0.0,1.0)*brightness*lightColour;\n    \n}\n\nvoid textureWall(in vec3 block, inout ray ray, inout rayMarchHit hit, inout vec3 colour, in float time) {\n    vec2 uv;\n    vec3 absNormal = abs(hit.surfaceNormal);\n    float scale = 2.0;\n\n    if(absNormal.y > absNormal.x && absNormal.y > absNormal.z) {\n        uv.xy=fract(hit.origin.xz*scale)-0.5;\n    } else {\n        if(absNormal.x > absNormal.z) {\n            if(hit.surfaceNormal.x>0.0) {\n                uv.x=1.0-fract((hit.origin.z)*scale);\n            } else {\n                uv.x=fract((hit.origin.z)*scale);\n            }\n        } else {\n            if(hit.surfaceNormal.z>0.0) {\n                uv.x=fract((hit.origin.x)*scale);\n            } else {\n                uv.x=1.0-fract((hit.origin.x)*scale);\n            }\n        }\n        uv.y=fract(hit.origin.y*scale);\n\t\tuv-=0.5;\n        //vec2 windowSize=vec2(1.0);\n        vec2 windowSize=vec2(hash21(block.xy*39.195),hash21(block.xy*26.389))*0.7+0.2;\n\n        if (windowSize.x > 0.8){\n            windowSize.x=1.0;\n        }\n\n        if (windowSize.y > 0.8){\n            windowSize.y=1.0;\n        }\n\n        float round=0.0;\n\n        if (windowSize.x < 1.0 && windowSize.y < 1.0) {\n            round = min(windowSize.x,windowSize.y) * hash21(block.xy*87.981);\n        }\n\n        if ( abs(uv.x*2.0) < windowSize.x+PARALLAX_WINDOW_SURROUND_THICKNESS && abs(uv.y*2.0) < windowSize.y+PARALLAX_WINDOW_SURROUND_THICKNESS) {\n            float distance = sdBox(uv*2.0,windowSize-round)-round;\n            if(distance < 0.0) {\n                vec3 cell = floor(hit.origin*scale) + block*blockSize;\n                bool on = (hash31(cell) + sin(time*0.5)*0.05) > 0.5;\n                hit.materialId = MAT_WINDOW;\n                if(on) {\n                    float brightness = clamp(hash31(cell),0.1,1.0);\n                    vec3 lightColour = clamp(hash33(cell)+0.7,0.0,1.0);\n                    float distanceRatio=hit.distance/RAY_MAX_DISTANCE;\n                    if(distanceRatio<0.3) {\n                        textureParallaxWindow(block, ray, hit, uv, cell, lightColour, brightness, colour, time);\n                        colour*=3.0;\n                        if(distanceRatio>0.2) {\n                            colour=mix(colour,lightColour*3.0*brightness,(distanceRatio-0.2)*10.0);\n                        }\n                        //shade the edge of the glass a bit.\n                        colour = mix(PARALLAX_WINDOW_SURROUND_COLOUR,colour,clamp(abs(distance*20.0),0.0,1.0));\n                    } else {\n                        colour=lightColour*3.0*brightness;\n                    }\n                } else {\n                    colour=vec3(0.0);\n                }\n            } else if(distance < PARALLAX_WINDOW_SURROUND_THICKNESS) {\n                hit.materialId = MAT_WINDOW;\n                colour=PARALLAX_WINDOW_SURROUND_COLOUR;\n            } \n        }\n    }\n    \n    if (hit.materialId != MAT_WINDOW){\n        float concrete = getConcrete(hit.origin, hit.surfaceNormal, true);\n        colour = hash33(block.xyx) * vec3(0.25,0.1,0.2)+0.5;\n        colour = clamp(colour,vec3(0.0),vec3(1.0));\n        colour *= concrete;\n    }\n}\n\n// ========== ==========\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 2.0;\n    rayMarchHit hit;\n\n    for( float i=0.0; i<3.0; i++ )\n    {\n        float distance = 0.1*i;\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nvoid getOffsetLight(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance = length(lightOffset);\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    //dotProd *= diffuseBrightness;\n    dotProd *= fallOff;\n    specularBrightness = dotProd;\n}\n\nvoid getLight(vec3 position, vec3 normal, vec3 rayDirection, float shininess, vec3 cameraOrigin, out vec3 diffuseLight, out vec3 specularLight, float time) {\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    // -- Camera Light\n    vec3 lightOrigin = cameraOrigin;\n\n    float diffuseBrightness;// = 0.0;\n    float specularBrightness;// = 0.0;\n\n    getOffsetLight(position, normal, rayDirection,lightOrigin-position, 5.0, shininess, diffuseBrightness, specularBrightness);\n    diffuseLight = vec3(0.5 * diffuseBrightness);\n    specularLight = vec3(0.5 * specularBrightness);\n}\n\n// ========== ==========\n\n// ========== Calculate Normal ==========\n\nfloat map(in vec3 pos, float time ){\n    return GetRayMarchHit(pos, time).distance;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n\n    #if 0\n    vec2 e = vec2(1.0,-1.0)*0.005773;\n    return normalize( e.xyy*map( pos + e.xyy, time ) + \n                     e.yyx*map( pos + e.yyx, time ) + \n                     e.yxy*map( pos + e.yxy, time ) + \n                     e.xxx*map( pos + e.xxx, time ) );\n    #else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time);\n    }\n    return normalize(n);\n    #endif    \n}\n\n// ==========  ==========\n\n// ========== Get colour for a ray hit ==========\n\nvoid renderRay(inout ray ray, inout rayMarchHit hit, inout vec3 colour, bool isReflection, float time) {\n    vec3 skybox = mix(vec3(0.03,0.1,0.25),vec3(0.5,0.4,0.3),(ray.direction.y*0.5+0.5)+0.2);\n\tvec3 block = vec3(floor((hit.origin.xz+vec2(time*blockSize*0.5,0.0))/blockSize), floor(hit.origin.y));\n    \n    #if defined(DEBUG_OCCLUSION)\n        float occlusion =getOcclusion(hit.origin, hit.surfaceNormal, time);\n    #endif\n    \n    if(hit.materialId == MAT_SKY) {\n        colour = skybox;\n    } else if (hit.materialId == MAT_WALL) {\n        textureWall(block, ray, hit, colour, time);\n    } else if (hit.materialId == MAT_SOLID) {\n        textureSolid(block, ray, hit, colour, time);\n    }\n    #if defined(DEBUG_LIGHTING)\n        vec3 diffuseLight;\n        vec3 specularLight;\n        float shininess = 1.0;\n        float specularIntensity = 0.1;\n\n        if (hit.materialId == MAT_SOLID || hit.materialId == MAT_WALL) {\n            shininess = 5.0;\n            specularIntensity = 2.1;\n        } else if (hit.materialId == MAT_WINDOW) {\n            shininess = 50.0;\n            specularIntensity = 2.0;\n        } \n\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, shininess, ray.origin, diffuseLight, specularLight, time);\n\n        #if defined(DEBUG_AMBIENT)\n            vec3 ambient = skybox;\n            #if defined(DEBUG_AMBIENT_OCCLUSION) && !defined(DEBUG_OCCLUSION)\n                if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n                    ambient *=(getOcclusion(hit.origin, hit.surfaceNormal, time));\n                }\n            #endif\n            diffuseLight += ambient;\n        #endif\n\n        if (hit.materialId != MAT_WINDOW) {\n            colour*=diffuseLight;\n        }\n        colour+=(specularLight*specularIntensity);\n    #endif\n    \n\t#if defined(DEBUG_OCCLUSION)\n\t\tcolour *=occlusion;\n\t#endif\n    \n    #if defined(DEBUG_DISTANCE_FOG)\n    float distanceFog = hit.distance/RAY_MAX_DISTANCE;\n    colour = mix(colour, skybox, distanceFog);\n    #endif\n}\n\n// ==========  ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray mainRay = getRay(uv, camera);\n    \n    rayMarchHit hit = RayMarch(mainRay, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n    hit.surfaceNormal = calcNormal( hit.origin, time );\n\t\n    // ---- Render\n    vec3 colour;\n    renderRay(mainRay, hit, colour, false, time);\n\n    #if defined(DEBUG_REFLECTION)\n    //if (hit.materialId == MAT_WINDOW) {\n        float distanceRatio = hit.distance/RAY_MAX_DISTANCE;\n        vec3 refColour;    \n        if(distanceRatio<1.0) {\n            float reflection;\n            if (hit.materialId == MAT_SOLID || hit.materialId == MAT_WALL) {\n                reflection = 0.1;\n            } else if (hit.materialId == MAT_WINDOW) {\n                reflection = 0.5;\n            } \n            \n            #if defined(DEBUG_REFLECTION_FRESNEL)\n            \tfloat fresnel = 1.0-max(0.0,-dot(hit.surfaceNormal,mainRay.direction));\n            \treflection=(reflection*fresnel);\n            #endif\n            \n            ray refRay = getRefRay(hit.origin, hit.surfaceNormal, mainRay.direction);\n            rayMarchHit refHit = RayMarch(refRay, RAY_MAX_DISTANCE_REFLECTION, OBJECT_MIN_SURFACE_DISTANCE_REFLECTION, RAY_MAX_STEPS_REFLECTION, time);\n            refHit.surfaceNormal = calcNormal( refHit.origin, time );\n            renderRay(refRay, refHit, refColour, true, time);\n            if(distanceRatio>0.25) {\n                reflection*=1.0-((distanceRatio-0.25)*4.0);\n            } \n            colour = mix(colour,refColour,reflection);\n        } \n   // }\n    #endif\n\t\n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n    colour = clamp(colour,0.0,1.0); \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n    fragColour = vec4(colour,1.0);\n}", "image_inputs": [{"id": "XdX3zn", "previewfilepath": "/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyXzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[4235, 4270, 4296, 4296, 4458], [4460, 4460, 4484, 4484, 4630], [4632, 4632, 4657, 4657, 4811], [4813, 4813, 4868, 4928, 4989], [4991, 5059, 5085, 5085, 5141], [5169, 5211, 5247, 5247, 5511], [5513, 5513, 5578, 5578, 5766], [5794, 5957, 5981, 5981, 6257], [6259, 6259, 6282, 6282, 6566], [6568, 6568, 6591, 6591, 6888], [6891, 6937, 6960, 6960, 7007], [7009, 7009, 7031, 7031, 7082], [7084, 7084, 7106, 7106, 7170], [7241, 7301, 7373, 7373, 7441], [7443, 7443, 7474, 7474, 7671], [7673, 7673, 7704, 7704, 7901], [7903, 7903, 7936, 7936, 8133], [8135, 8135, 8163, 8163, 8186], [8188, 8188, 8216, 8216, 8239], [8241, 8279, 8300, 8300, 8338], [8407, 8438, 8477, 8477, 9166], [9169, 9200, 9239, 9239, 9639], [9641, 9672, 9712, 9712, 9844], [9846, 9885, 9938, 9938, 10091], [10207, 10219, 10254, 10254, 10282], [10284, 10284, 10321, 10321, 10405], [10417, 10430, 10455, 10455, 10473], [10475, 10475, 10510, 10510, 10536], [10538, 10538, 10569, 10569, 10660], [10662, 10662, 10714, 10714, 10837], [10839, 10839, 10892, 10892, 10953], [10955, 10955, 11008, 11008, 11069], [11071, 11071, 11124, 11124, 11185], [11187, 11187, 11247, 11247, 11354], [11356, 11356, 11416, 11416, 11523], [11536, 11562, 11604, 11604, 12052], [12054, 12140, 12204, 12204, 12318], [12346, 12386, 12418, 12418, 14333], [14335, 14335, 14414, 14414, 14851], [14853, 14853, 14948, 14948, 15420], [15422, 15422, 15491, 15491, 15625], [15627, 15627, 15669, 15669, 16771], [16799, 16837, 16892, 16892, 18076], [18078, 18078, 18180, 18180, 19584], [19611, 19648, 19704, 19704, 20292], [20294, 20294, 20346, 20346, 20921], [20923, 20923, 20991, 20991, 21907], [21909, 21909, 22015, 22015, 22219], [22401, 22525, 22708, 22708, 25985], [25987, 25987, 26092, 26092, 29093], [29095, 29121, 29186, 29186, 29570], [29572, 29572, 29753, 29753, 30610], [30612, 30612, 30769, 30769, 31202], [31230, 31273, 31309, 31309, 31358], [31360, 31424, 31468, 31468, 32064], [32093, 32144, 32248, 32248, 34160], [34189, 34227, 34285, 34285, 36557]], "test": "untested"}
{"id": "ws3SD2", "name": "Lens - distance", "author": "shanecelis", "description": "This is a derivative of Inigo Quilez's SDF vesica function. It offers a \"lens\" that is a reparameterization of a vesica that you specify by it's half-height and width.", "tags": ["2d", "distancefield", "sdf", "lens", "distance", "vesica"], "likes": 4, "viewed": 112, "published": "Public", "date": "1572892572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an vesica (intersection of two disks). Can be seen as a\n// special case of abje's crescent shape (https://www.shadertoy.com/view/XlVfz1)\n\n\n// List of some other 2D distances:\n//\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n// Pie:                  https://www.shadertoy.com/view/3l23RK\n// Arc:                  https://www.shadertoy.com/view/wl23RK\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))\n                               : length(p-vec2(-d,0.0))-r;\n}\n\n/** This is a different way of specifying the vesica. We specify the half-height h\n    and its width w. This allows us to maintain the same height of the vesica, which is\n    good if you're trying to simulate eyelids and things. -Shane Celis */\n\nfloat sdLens(vec2 p, float h, float w)\n{\n \tfloat d = h / w - w / 4.0;\n    float r = w / 2.0 + d;\n    return sdVesica(p, r, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float d = sdLens( p, 0.8, 0.8 + 0.2*sin(iTime) );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3SD2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1232, 2699, 2741, 2741, 2955], [2957, 3203, 3243, 3243, 3331], [3333, 3333, 3390, 3390, 3787]], "test": "untested"}
{"id": "ws3SDl", "name": "Turn of the Screw", "author": "dr2", "description": "Screw", "tags": ["raymarch", "kinematics", "screw"], "likes": 13, "viewed": 240, "published": "Public API", "date": "1573120022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Turn of the Screw\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, tPhs;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, len, r, a;\n  dMin = dstFar;\n  len = 3.;\n  q = p;\n  q.xy = Rot2D (q.xy, -4. * len * pi * tPhs);\n  q.z -= len * (1. - 2. * tPhs);\n  a = (length (q.xy) > 0.) ? atan (q.y, - q.x) / (2. * pi) : 0.;\n  r = 0.3 + 0.2 * q.z / len - 0.2 * abs (sin (2. * pi * (q.z - a)));\n  r = max (0.07, r);\n  d = 0.7 * PrCylDf (q, r, len);\n  DMINQ (1);\n  q.z -= len - 0.2;\n  d = max (PrSphDf (q, 0.9), - q.z + 0.2);\n  q.z -= 0.9;\n  d = max (d, - min (PrBox2Df (q.xz, vec2 (0.1, 0.4)), PrBox2Df (q.yz, vec2 (0.1, 0.4))));\n  DMINQ (2);\n  q = p;\n  q.z -= -0.5;\n  d = PrBoxDf (q, vec3 (2.5, 2.5, 0.5));\n  DMINQ (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 60; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (h, 0.05, 0.4);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat BgPat (vec3 rd)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = max (max (tm.x, tm.y), tm.z) * rd;\n  q = mod (8. * vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.));\n  return min (SmoothBump (0.16, 0.84, 0.06, q.x), SmoothBump (0.16, 0.84, 0.06, q.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL, sh, t;\n  bool refBg;\n  t = mod (0.03 * tCur, 1.);\n  tPhs = SmoothBump (0.25, 0.75, 0.23, t);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    refBg = (idObj == 1 || idObj == 2 && length (qHit + vec3 (0., 0., 0.9)) > 0.899 &&\n       qHit.z > -0.69);\n    if (idObj == 1 || idObj == 2) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.2) * (1. -\n         0.07 * cos (8. * atan (qHit.y, - qHit.x)));\n    } else if (idObj == 3) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.05);\n      if (abs (vn.z) > 0.99) col4.rgb *= 1. - 0.3 * Fbm2 (qHit.xy * vec2 (4., 1.));\n      else col4.rgb *= 0.95 + 0.05 * cos (16. * pi * qHit.z);\n      if (vn.z < -0.99) col4.rgb *= mix (0.5 + 0.5 * smoothstep (0.05, 0.2, length (qHit.xy)),\n         1., smoothstep (0.2, 0.24, abs (t - 0.75)));\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 1 || idObj == 2) {\n      nDotL *= nDotL;\n      nDotL *= nDotL;\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, - ltDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 16.);\n    if (refBg) col = mix (col, vec3 (1.) * (0.9 + 0.1 * BgPat (reflect (rd, vn))), 0.2);\n  } else {\n    col = mix (vec3 (0.07, 0.1, 0.07), vec3 (1.) * (0.9 + 0.1 * BgPat (rd)), 0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.7 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 2. * pi * mPtr.y;\n  } else {\n    az += 0.01 * pi * tCur;\n    el -= 0.2 * pi * sin (0.05 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 5.;\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3SDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 527, 549, 549, 1181], [1183, 1183, 1216, 1216, 1393], [1395, 1395, 1416, 1416, 1613], [1615, 1615, 1652, 1652, 1893], [1895, 1895, 1918, 1918, 2242], [2244, 2244, 2279, 2279, 3686], [3730, 3730, 3786, 3786, 4996], [4998, 4998, 5030, 5030, 5130], [5132, 5132, 5165, 5165, 5254], [5256, 5256, 5289, 5289, 5316], [5318, 5318, 5360, 5360, 5411], [5413, 5413, 5470, 5470, 5553], [5555, 5555, 5585, 5585, 5698], [5732, 5732, 5756, 5756, 5886], [5888, 5888, 5913, 5913, 6099], [6101, 6101, 6122, 6122, 6277]], "test": "untested"}
{"id": "ws3XDj", "name": "Colorful Lantern", "author": "santiagoap", "description": "Another test of my capability with sin and absolute functions.", "tags": ["sin"], "likes": 4, "viewed": 58, "published": "Public", "date": "1572885243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void CreateCrossFX(vec2 uv, vec2 pos, inout vec3 result)\n{\n    uv += pos;\n    vec3 preResult = vec3(0.);\n    preResult += vec3(abs(-((sin(iTime) + 1. / 2.)) * 20. + length(uv + 50.)));\n    preResult *= vec3(abs(uv.x -0.3));\n    preResult *= vec3(abs(uv.x -0.6) * 2.);\n    preResult *= (vec3(1.) - vec3(abs(uv.x -sin(iTime))));\n    preResult *= (vec3(1.) - vec3(abs(uv.x -sin(iTime))));\n    preResult *= vec3(abs(uv.x + 0.3));\n    preResult *=( vec3(sin(iTime) * .1 + 0.3) - vec3(abs(uv.y)));\n    preResult *= sin(iTime) + 1. /2. + 1.8;\n    result += preResult / 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv -= .5;\n    \n    vec3 result = vec3(.0);\n\tCreateCrossFX(uv, vec2(0.,0.), result);\n    result *= mix(min(vec3(0.2,0.9,0.1),vec3(.2)), \n                  vec3(0.5,0.1,0.2), uv.x);\n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3XDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 568], [570, 570, 627, 627, 928]], "test": "untested"}
{"id": "ws3XDl", "name": "Implicit function", "author": "Kanata", "description": "Graph of a third-degree polynomial implicit function.\nTweak the coefficients a~j and enjoy how it changes.", "tags": ["math", "mathematics"], "likes": 4, "viewed": 295, "published": "Public API", "date": "1573121757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          uv = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime,\n          x = uv.x,\n          y = uv.y,\n\n          a = 1.,\n          b = 1.,\n          c = 1.,\n          d = 1.,\n          e = sin(.5* t),\n          f = sin(.6* t),\n          g = sin(.7* t),\n          h = sin(.8* t),\n          i = sin(.9* t),\n          j = sin(1.* t),\n\n          p = a* x* x* x + b* x* x* y + c* x* y* y + d* y* y* y+\n                   e* x* x + f* x* y + g* y* y + h* x + i* y + j;\n\n    O = vec4( .05 / abs(p) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3XDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 576]], "test": "untested"}
{"id": "ws3XRj", "name": "Neon Jungle v0.2", "author": "Delvar", "description": "Flying around a smog filled Mega City, Mouse to free look.\nA new version here:  'Neon Jungle v0.5'  https://www.shadertoy.com/view/WdyXzz", "tags": ["fog", "windows", "neon", "concrete", "megacity", "fly", "smog"], "likes": 11, "viewed": 189, "published": "Public", "date": "1572959327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// =================================================================\n//  'Neon Jungle v0.2'\n//  https://www.shadertoy.com/view/ws3XRj\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  A new version here:  'Neon Jungle v0.5'  https://www.shadertoy.com/view/WdyXzz\n//\n//\tThe 'Face Fog' hides a multitude of sins :)\n//\n//\tCredits: \n//\tIdea sparked from the 2d shader,  mhnewman : 'Descent ' : https://www.shadertoy.com/view/XtSGWD\n//\n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tWindows bassed off (but rewitten so I understand it!) otaviogood : 'Skyline' : https://www.shadertoy.com/view/XtsSWs\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 35.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.005\n\n#define RAY_MAX_STEPS_SHADOW 30\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.01\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET 0.041\n\n#define PI 3.1415926535897932384626433832795\n\n#define DEBUG_RAY_DITHER\n#define DEBUG_CAMERA_FLY\n#define DEBUG_WHITE_NEON\n#define DEBUG_DISTANCE_FOG\n#define DEBUG_FACE_FOG\n#define DEBUG_LIGHTING\n#define DEBUG_AMBIENT\n#define DEBUG_AMBIENT_OCCLUSION\n#define DEBUG_RENDER_RAILS\n#define DEBUG_VIGNETTE\n\n//#define DEBUG_OCCLUSION   // used instead of DEBUG_AMBIENT_OCCLUSION when you want the efect but without adding DEBUG_AMBIENT or DEBUG_LIGHTING\n\n//change the filtering method, Linier, Smoothstep or Quintic, little visual change when noise is stacked but can impact performance.\n//#define VALUE_NOISE_FILTER_SMOOTH\n//#define VALUE_NOISE_FILTER_QUINTIC\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_WINDOW\t1\n#define MAT_WALL\t2\n#define MAT_SOLID\t3\n#define MAT_RAIL\t4\n#define MAT_NEON\t5\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\n// ========== ==========\n\n// ========== Constants ==========\n\nconst float gridSize = 5.0;\nconst float gridSizeH = gridSize*0.5;\nconst float gridSizeQ = gridSize*0.25;\n\nconst float roadLength = gridSize*5.0;\nconst float roadLengthH = roadLength*0.5;\nconst float roadLengthQ = roadLength*0.25;\n\nconst float roadWidth = gridSize;\nconst float roadWidthH = roadWidth*0.5;\nconst float roadWidthQ = roadWidth*0.25;\n\nconst float blockSize = roadLength + gridSize;\nconst float blockSizeH = blockSize*0.5;\nconst float blockSizeQ = blockSize*0.25;\n\nconst vec3 roadLightColour = vec3(0.9,0.6,0.1);\nconst float roadLightBrightness = 5.0;\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n//#define HE 702.566665305\n//#define HF 149.311292882\n//#define HG 446.230257362\n//#define HH 833.597411735\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HG))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nvec3 valueNoiseFilter(vec3 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat valueNoiseFilter(float x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat lengthSquare(vec2 a) {\n    return dot(a,a);\n}\n\nfloat lengthSquare(vec3 a) {\n    return dot(a,a);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 3d, Unsigned\nfloat valueNoise3du(vec3 samplePoint) {\n    vec3 pointI = floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    vec3 u = valueNoiseFilter(pointF);\n\n    //Slight Optimisation\n    vec4 m = mix(\n        vec4(\n            hash31(pointI ),//bbl,\n            hash31(pointI + vec3(0.0,1.0,0.0) ),//btl,\n            hash31(pointI + vec3(0.0,0.0,1.0) ),//fbl,\n            hash31(pointI + vec3(0.0,1.0,1.0) )//ftl\n        ),vec4(\n            hash31(pointI + vec3(1.0,0.0,0.0) ),//bbr,\n            hash31(pointI + vec3(1.0,1.0,0.0) ),//btr,\n            hash31(pointI + vec3(1.0,0.0,1.0) ),//fbr,\n            hash31(pointI + vec3(1.0,1.0,1.0) )//ftr\n        ),u.x);\n\n    vec2 n = mix(m.xz, m.yw, u.y);\n    return mix(n.x,n.y,u.z);\n\n    /*\n//The original function, just for referance.\nfloat bbl = hash31(pointI + vec3(0.0,0.0,0.0) );\nfloat bbr = hash31(pointI + vec3(1.0,0.0,0.0) );\nfloat btl = hash31(pointI + vec3(0.0,1.0,0.0) );\nfloat btr = hash31(pointI + vec3(1.0,1.0,0.0) );\n\nfloat fbl = hash31(pointI + vec3(0.0,0.0,1.0) );\nfloat fbr = hash31(pointI + vec3(1.0,0.0,1.0) );\nfloat ftl = hash31(pointI + vec3(0.0,1.0,1.0) );\nfloat ftr = hash31(pointI + vec3(1.0,1.0,1.0) );\n\nfloat bb = mix(bbl,bbr,u.x);\nfloat bt = mix(btl,btr,u.x);\n\nfloat b = mix(bb,bt,u.y);\n\nfloat fb = mix(fbl,fbr,u.x);\nfloat ft = mix(ftl,ftr,u.x);\n\nfloat f = mix(fb,ft,u.y);\n\nreturn mix(b,f,u.z);\n*/\n}\n\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n\n    /*\n//The original function, just for referance.\nfloat bl = hash21(pointI + vec2(0.0,0.0) );\nfloat br = hash21(pointI + vec2(1.0,0.0) );\nfloat fl = hash21(pointI + vec2(0.0,1.0) );\nfloat fr = hash21(pointI + vec2(1.0,1.0) );\nvec2 u = valueNoiseFilter(pointF);\nfloat b = mix(bl,br,u.x);\nfloat f = mix(fl,fr,u.x);\n\nreturn mix(b,f,u.y);\n*/\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(pointI),hash11(pointI + 1.0 ),valueNoiseFilter(fract(samplePoint)));\n    /*\n//The original function, just for referance.\nfloat pointI = floor(samplePoint);\nfloat pointF = fract(samplePoint);\nfloat b = hash11(pointI);\nfloat f = hash11(pointI + 1.0 );\nfloat u = valueNoiseFilter(pointF);\nreturn mix(b,f,u);\n*/\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(mod(pointI, wrap)),hash11(mod(pointI + 1.0 ,wrap)),valueNoiseFilter(fract(samplePoint)));\n    /*\n//The original function, just for referance.\nfloat pointI = floor(samplePoint);\nfloat pointF = fract(samplePoint);\n\nfloat a = hash11(mod(pointI, wrap));\nfloat b = hash11(mod(pointI + 1.0 ,wrap));\nfloat u = valueNoiseFilter(pointF);\nreturn mix(a,b,u);\n*/\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n// All primitives are centered at the origin.\n\n// == 2D ==\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// == ==\n\n// == 3D ==\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdXAlignedCylinder( vec3 p, float l, float r )\n{\n    p.z -= clamp( p.z, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdZAlignedCylinder( vec3 p, float l, float r )\n{\n    p.x -= clamp( p.x, 0.0, l );\n    return length(p) - r;\n}\n\n// == ==\n\n// ========== ==========\n\nfloat getFog(vec3 direction, float time) {\n    time=time*0.1;\n    float fog = 0.0;\n    vec2 t = vec2(time,-time);\n\n    fog+= valueNoise3du(direction + vec3(t.x));\n    fog+= valueNoise3du((direction + vec3(t.xyx)) * 2.0) * 0.5;\n    fog+= valueNoise3du((direction + vec3(t.xxy)) * 4.0) * 0.25;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 8.0) * 0.125;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 16.0)* 0.0625;\n    \n    //return fog/1.9375;\n    return fog;//*0.516129032258;\n}\n\n// --quick hack to strobe the road lights so they always strobe away from the camera\n\nfloat getRoadLightStrobe(float distanceFromCamera, float time) {\n    return smoothstep(0.0,1.0,clamp(sin(time*5.0 - (distanceFromCamera/RAY_MAX_DISTANCE)*PI*5.0)*0.5,0.0,1.0));\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    time *= 0.05;\n\n    float b = blockSize;\n\n    vec3 path[16];\n    int i=0;\n\n    path[i++] = vec3( 0.0*b,\t0.0,\t 0.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b - gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b + gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b - 1.0,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t-2.0*b+1.0);\n    path[i++] = vec3( 4.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t 0.0*b);\n\n    time = mod(time,float(path.length()));\n\n    float cornerRadius = 0.1;\n    float inverseCornerRadius = 1.0 - cornerRadius;\n\n    int timeI = int(floor(time));\n    float timeF = fract(time)*inverseCornerRadius+cornerRadius;\n\n    vec3 p0 = path[timeI];\n    vec3 r;\n    timeI += 1;\n    if (timeI>=path.length()) {\n        timeI = 0;\n    }\n    vec3 p1 = path[timeI];\n    if (timeF >= inverseCornerRadius) {\n        timeI += 1;\n        if (timeI>=path.length()) {\n            timeI = 0;\n        }\n        vec3 p2 = path[timeI];\n        vec3 p01 = p0 + ((p1-p0) * (inverseCornerRadius));\n        vec3 p12 = p2 + ((p1-p2) * (inverseCornerRadius));\n        float t = map(timeF,inverseCornerRadius,1.0,0.0,1.0);\n        vec3 a = mix(p01,p1,t);\n        vec3 b = mix(p1,p12,t);\n        r= mix(a,b,t);\n    } else {\n        r=mix( p0, p1, timeF);\n    }\n\n\n    vec3 rd;\n    rd.y = (sin(time*5.0) + sin(time*9.0)) * 0.8;\n    rd.x = sin(time*6.0) + sin(time*8.0);\n    rd.z = sin(time*7.0) + sin(time*7.0);\n\n    rd *= sin(fract(time)*PI);\n    rd *= clamp(length(r)/gridSize-gridSize,0.0,1.0);\n    r+=rd*0.5;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n        vec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n\n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0);\n        roll = clamp(roll,-0.5,0.5);//clamp(-0.1,0.1,1.0-pow(1.0-roll,5.0));\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(0.0,0.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float time) {\n    rayMarchHit hit;\n    #if defined(DEBUG_USE_SQUARE_DISTANCE)\n    hit.distance = RAY_MAX_DISTANCE*RAY_MAX_DISTANCE;\n    #else\n    hit.distance = RAY_MAX_DISTANCE;\n    #endif\n\n    float newDistance = hit.distance;\n\n    vec3 pBlockCenter = position + (0.5*blockSize);\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    vec3 pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n    //wold position of the center of the grid, positionGI*blockSize\n    vec3 pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    vec3 pBlockWF = pBlockF*blockSize; \n\n    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;\n\n    //on north/south - -2.5 < mod(x,blockSize) < 2.5\n    bool onNorthSouth = (pBlockWF.x >= -gridSizeH && pBlockWF.x <= gridSizeH && (pBlockWF.z < -gridSizeH || pBlockWF.z > gridSizeH) );\n    bool onEastWest = (pBlockWF.z >= -gridSizeH && pBlockWF.z <= gridSizeH && (pBlockWF.x < -gridSizeH || pBlockWF.x > gridSizeH) );\n\n    #if defined(DEBUG_RENDER_RAILS)\n    //Road Main Beams\n    //FIXME: the length of beams *0.8?!?!\n    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));\n    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF.zyx)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));\n\n    //Intersection Main Beams\n    newDistance = min(newDistance,sdCircle( abs(pBlockWF.xz) - vec2(2.0,2.2), 0.05 ));\n    newDistance = min(newDistance,sdCircle( abs(pBlockWF.zx) - vec2(2.0,2.2), 0.05 ));\n\n    //dont crossbrase the road\n    if (pBlockWF.y < -gridSizeH || pBlockWF.y > gridSizeH) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));\n    }\n\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));\n\n    if (onNorthSouth) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));\n    }\n\n    if (onEastWest) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_RAIL;\n        hit.neon = vec3(0.0);\n    }\n    #endif\n\n\n    // Lights\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.2,1.25,2.0), vec3(2.0,1.25,2.2), 0.1));\n\n    if (onNorthSouth) {\n        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));\n    }\n\n    if (onEastWest) {\n        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_NEON;\n        hit.neon = roadLightColour*4.0;\n    }\n\n    //Buildings.\n    //rework the grids so 0,0,0 is the center of the buildings\n    pBlockCenter = position;\n\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n\n    //wold position of the center of the grid, positionGI*blockSize\n    pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    pBlockWF = pBlockF*blockSize; \n\n    float floorCount=2.0;\n    float buildingFloor = floor(pBlockWF.y);\n    float blockHash = hash21(pBlockI.xz);\n    float round = clamp(blockHash-0.5,0.0,0.5);\n    for(float i=-floorCount;i<=floorCount;i++) {\n        float width=valueNoise1du(buildingFloor + i + blockHash)*0.1+0.8;\n        float buildingfloorSize = floor(width * roadLength)*0.5+0.25;\n        buildingfloorSize-=round;\n        newDistance = min(newDistance, sdBox(vec3(pBlockWF.x,fract(pBlockWF.y)-i,pBlockWF.z), vec3(buildingfloorSize,0.5-round,buildingfloorSize))-round);\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WALL;\n        hit.neon = vec3(0.0);\n    }\n\n    //Corners\n    newDistance = min(newDistance, sdBox( abs(pBlockWF.xz)-(roadLength*0.5)+(gridSize*0.4), vec2(0.5) ) - 0.5 );\n\n    //Mid Beams\n    if (abs(pBlockWF.z) < (roadLength*0.5)) {\n        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.x)-(roadLength*0.5)+(gridSize*0.2),pCellWF.z), vec2(0.375) ) - 0.125);\n    }\n    if (abs(pBlockWF.x) < (roadLength*0.5)) {\n        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.z)-(roadLength*0.5)+(gridSize*0.2),pCellWF.x), vec2(0.375) ) - 0.125);\n    }\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_SOLID;\n        hit.neon = vec3(0.0);\n    }\n\n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    //float lastDistance = 1.0;\n    float accumilatedDistance = 0.0;\n    vec3 accumilatedNeon = vec3(0.0);\n    float modulatedMinSurfaceDistance = minSurfaceDistance;\n    int i;\n    for(i=0; i<maxSteps; i++) {\n        float distanceRatio = clamp((accumilatedDistance/maxDistance),0.0,1.0);\n\n        //the more itterations the less precise we are, improve perfomance a bit with only mild artifacts\n        modulatedMinSurfaceDistance=mix(minSurfaceDistance,minSurfaceDistance*20.0,distanceRatio);\n\n        vec3 currentPoint = ray.origin + ray.direction * accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, time);\n\n        if (hit.materialId==MAT_NEON) {\n            vec3 neon;\n            if (hit.distance > minSurfaceDistance) {\n                neon = (hit.neon) * max(1.0-hit.distance/2.0,0.0) * 0.05;\n            }\n            neon *= 1.0-distanceRatio;\n\n            float lightStrobe = getRoadLightStrobe(accumilatedDistance, time);\n\n            accumilatedNeon += neon*lightStrobe;\n        }\n        #if defined (DEBUG_RAY_DITHER)\n        if(hit.distance > 0.0) {\n            //we take smaller steps closer to the camera, gives a better Neon result.           \n            hit.distance *= 0.5+mix(distanceRatio,1.0, hash31(fract(currentPoint+time)))*0.5;\n        }\n        #endif\n\n        accumilatedDistance += hit.distance;\n\n        if(accumilatedDistance >= maxDistance) {\n            accumilatedDistance = maxDistance;\n            hit.surfaceNormal = -ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //terminate if we are very close or bounce back out if we end up within an object. \n        //else if(hit.distance > -minSurfaceDistance && hit.distance < minSurfaceDistance) {\n\n        //forget bouncing back, if we end up inside just terminate\n        else if(hit.distance < modulatedMinSurfaceDistance) {\n            break;\n        }\n\n    }\n    hit.iteration = i;\n    hit.distance = accumilatedDistance;\n    hit.neon = accumilatedNeon;\n    return hit;\n}\n// ========== ==========\n\n// ========== Texturing ==========\n\n\nfloat getConcreteErosion(vec3 position, bool showLine) {\n    float concrete=0.0;\n    concrete+= valueNoise3du(position * 4.0) * 0.25;\n    concrete+= valueNoise3du(position * 8.0) * 0.125;\n    concrete+= valueNoise3du(position * 16.0) * 0.0625;\n    concrete+= valueNoise3du(position * 32.0) * 0.03125;\n    concrete/=0.25+0.125+0.0625+0.03125;\n    concrete = (abs(concrete*2.0-1.0)+0.3);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        if(line < 0.05) {\n            line = smoothstep(-0.5,1.0,clamp(line*15.0,0.0,1.0));\n            line = 1.0-line;\n            line*=4.0;\n            line=1.0-line;\n            line = clamp(line,-10.0,1.0);\n            concrete = min(line,concrete*line);\n        }\n    }\n\n    return concrete;\n}\n\nfloat sampleConcrete(vec3 position, bool showLine) {\n    float concrete;\n\n    concrete= valueNoise3du(position);\n    concrete+= valueNoise3du(position * 2.0) * 0.5;\n    concrete+= valueNoise3du(position * 4.0) * 0.25;\n    concrete+= valueNoise3du(position * 8.0) * 0.125;\n    concrete+= valueNoise3du(position * 16.0) * 0.0625;\n    concrete/=1.0+0.5+0.25+0.125+0.0625;\n    concrete = (abs(concrete*2.0-1.0)+0.9);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        if(line < 0.05) {\n            line = smoothstep(0.0,1.0,clamp(line*10.0,0.0,1.0))*3.0;\n            line = clamp(line+0.5,0.0,1.0);\n            concrete *= line;\n        }\n    }\n\n    return concrete;\n}\n\nfloat getConcrete(vec3 position, inout vec3 normal, bool showLine) {\n    vec3 rightDir = normalize(cross(vec3(0.0,1.0,0.0), normal))*0.00001;\n    vec3 upDir =  normalize(cross(normal, rightDir))*0.00001;\n\n    float center = getConcreteErosion(position, showLine);\n    float right = getConcreteErosion(position+rightDir, showLine);\n    float up = getConcreteErosion(position+upDir, showLine);\n    \n    //FIXME: apply correct normal calculations, this is NOT how you do it!\n    //vec3 worldNormal = tangent * texNormal.x + binormal * texNormal.y + normal * texNormal.z;\n    vec3 pNormal;\n    pNormal=(vec3(\n        right - center,\n        up - center,\n        right - center\n    ));\n\n    pNormal*=-3000.0;\n    normal = normalize(normal + pNormal);\n    float concrete=sampleConcrete(position, showLine);//*0.5+0.5;\n    return concrete;\n}\n\nvoid textureSolid(vec2 block, vec3 position, inout vec3 colour, inout vec3 normal) {\n    float concrete = getConcrete(position, normal, true);\n    colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n    colour = clamp(colour,vec3(0.0),vec3(1.0));\n    colour *= concrete;\n}\n\nvoid textureWall(vec2 block, vec3 position, inout vec3 colour, inout vec3 normal, inout int material) {\n    float scale = 2.0;\n\n    float windowHeight =\thash21(block*39.195)*0.4+0.4;\n    float windowWidth =\t\thash21(block*26.389)*0.7+0.2;\n\n    if (windowWidth > 0.8){\n        windowWidth=1.0;\n    }\n\n    vec3 ramp = fract(position*scale)*2.0-1.0;\n\n    vec2 uv;\n    if (windowWidth==1.0) {\n        uv.x=0.0; \n    } else if (abs(ramp.x) > abs(ramp.z)) {\n        uv.x = ramp.x;\n    } else {\n        uv.x = ramp.z;\n    }\n    uv.y = ramp.y;\n\n    if ( (abs(uv.x) < windowWidth) && abs(uv.y) < windowHeight) {\n        colour=vec3(0.0);\n        material = MAT_WINDOW;\n    } else {\n        //uv.x=clamp(abs(uv.x)-windowWidth,0.0,1.0)/(1.0-windowWidth);\n        //uv.y=clamp(abs(uv.y)-windowHeight,0.0,1.0)/(1.0-windowHeight);\n\n        //Remove vertical lines when windows are close togther\n        if (windowWidth>=0.7) {\n            uv.x=0.0; \n        }\n\n        //FIXME: apply correct normal calculations, this is NOT how you do it!\n        vec3 pNormal;\n        uv*=uv*uv*0.5;\n        pNormal = vec3(uv.x,uv.y,uv.x);\n        normal = normalize(normal-pNormal);\n\n        float concrete = getConcrete(position, normal, false);\n        colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n        colour = clamp(colour,vec3(0.0),vec3(1.0));\n        colour *= concrete;\n    }\n}\n\n// ========== ==========\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 2.0;\n    rayMarchHit hit;\n\n    for( float i=0.0; i<3.0; i++ )\n    {\n        float distance = 0.1*i;\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nfloat getShadow(vec3 origin, vec3 destination, float soft, float time) {\n    float currentDistance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW;\n    float maxDistance = distance(destination, origin);\n    vec3 direction = normalize(destination-origin);\n    rayMarchHit rayMarchHit;\n    float light = 1.0;\n\n    for(int i=0; i<RAY_MAX_STEPS_SHADOW; i++) {\n        vec3 currentPoint = origin + direction*currentDistance;\n        rayMarchHit = GetRayMarchHit(currentPoint, time);\n        //Soft Shadows!\n        light = min(light,soft * rayMarchHit.distance/currentDistance);\n        currentDistance += rayMarchHit.distance;\n        if(currentDistance > maxDistance) {\n            break;\n        } else if(rayMarchHit.distance < OBJECT_MIN_SURFACE_DISTANCE_SHADOW) {\n            light = 0.0;\n            break;\n        }\n    }\n\n    return light;\n}\n\nvoid getOffsetLight(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance = length(lightOffset);\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    dotProd *= diffuseBrightness;\n    specularBrightness = dotProd;\n}\n\nvoid getOffsetLight2(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, bool xAligned, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance;\n\n    if(xAligned) {\n        distance = sdXAlignedCylinder(lightOffset, 0.4, 0.1 );\n    } else {\n        distance = sdZAlignedCylinder(lightOffset, 0.4, 0.1 );\n    }\n\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    dotProd *= diffuseBrightness;\n    specularBrightness = dotProd;\n}\n\nvoid getLight(vec3 position, vec3 normal, vec3 rayDirection, float shininess, vec3 cameraOrigin, out vec3 diffuseLight, out vec3 specularLight, float time) {\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    // -- Camera Light\n    vec3 lightOrigin = cameraOrigin;\n\n    float diffuseBrightness;// = 0.0;\n    float specularBrightness;// = 0.0;\n\n    getOffsetLight(position, normal, rayDirection,lightOrigin-position, 9.0, shininess, diffuseBrightness, specularBrightness);\n    diffuseLight = vec3(0.5 * diffuseBrightness);\n    specularLight = vec3(0.5 * specularBrightness);\n    // -- Road Lights\n\n    //get the closest road light\n    vec3 pBlockCenter = position+(0.5*blockSize);\n\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    vec3 pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n    //wold position of the center of the grid, positionGI*blockSize\n    //vec3 pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    vec3 pBlockWF = pBlockF*blockSize;\n    // Cell\n    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;\n\n    //sample just past the cross over point, has some artifacts but enlarges the light area.\n    float maxDistance = gridSize*0.75;\n\n    float lightStrobe;\n    vec3 lightPositionOffset;\n\n    if(abs(pBlockWF.y) -1.0 < gridSize) {\n\n        if(pBlockWF.y>0.0) {\n            lightPositionOffset.y = 1.0-pBlockWF.y;\n        } else {\n            lightPositionOffset.y = -1.0-pBlockWF.y;\n        }\n\n        // North/South\n        if(abs(pBlockWF.x) < gridSize) {\n            if(pBlockWF.z > gridSize*-0.5 && pBlockWF.z < 0.0) {\n                lightPositionOffset.z = -pCellWF.z - gridSize;\n            } else if(pBlockWF.z < gridSize*0.5 && pBlockWF.z > 0.0) {\n                lightPositionOffset.z = -pCellWF.z + gridSize;\n            } else {\n                lightPositionOffset.z = -pCellWF.z;\n            }\n            if(pBlockWF.x>0.0) {\n                lightPositionOffset.x = 2.0-pBlockWF.x;\n            } else {\n                lightPositionOffset.x = -2.0-pBlockWF.x;\n            }\n\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            if(lightStrobe>0.0) {\n                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, true, maxDistance, shininess, diffuseBrightness, specularBrightness);\n                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n                specularLight += roadLightColour * (specularBrightness*lightStrobe);\n            }\n        }\n\n        // East/West\n        if(abs(pBlockWF.z) < gridSize) {\n\n            if(pBlockWF.x > gridSize*-0.5 && pBlockWF.x < 0.0) {\n                lightPositionOffset.x = -pCellWF.x - gridSize;\n            } else if(pBlockWF.x < gridSize*0.5 && pBlockWF.x > 0.0) {\n                lightPositionOffset.x = -pCellWF.x + gridSize;\n            } else {\n                lightPositionOffset.x = -pCellWF.x;\n            }\n            if(pBlockWF.z>0.0) {\n                lightPositionOffset.z = 2.0-pBlockWF.z;\n            } else {\n                lightPositionOffset.z = -2.0-pBlockWF.z;\n            }\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            if(lightStrobe>0.0) {\n                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, false, maxDistance, shininess, diffuseBrightness, specularBrightness);\n                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n                specularLight += roadLightColour * (specularBrightness*lightStrobe);\n            }\n        }\n    } \n\n    // Up/Down\n    maxDistance = gridSize*1.4;\n    if (abs(pBlockWF.x)-2.0 < maxDistance && abs(pBlockWF.z)-2.0 < maxDistance) {\n        if(pBlockWF.x>0.0) {\n            lightPositionOffset.x = 2.0-pBlockWF.x;\n        } else {\n            lightPositionOffset.x = -2.0-pBlockWF.x;\n        }\n\n        if(pBlockWF.z>0.0) {\n            lightPositionOffset.z = 2.0-pBlockWF.z;\n        } else {\n            lightPositionOffset.z = -2.0-pBlockWF.z;\n        }\n\n        lightPositionOffset.y = 0.0-pCellWF.y;\n\n        lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n        getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n        diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n        specularLight += roadLightColour * (specularBrightness*lightStrobe);\n\n        //apply lights from above and below to get smooth transitions\n        if (pCellWF.y>0.0) {\n            lightPositionOffset.y = gridSize-pCellWF.y;\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n            specularLight += roadLightColour * (specularBrightness*lightStrobe);\n        } else {\n            lightPositionOffset.y = -gridSize-pCellWF.y;\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n            specularLight += roadLightColour * (specularBrightness*lightStrobe);\n        }\n    }\n}\n\n// ========== ==========\n\n// ========== Calculate Normal ==========\n\nfloat map(in vec3 pos, float time ){\n    return GetRayMarchHit(pos, time).distance;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n\n    #if 0\n    vec2 e = vec2(1.0,-1.0)*0.005773;\n    return normalize( e.xyy*map( pos + e.xyy, time ) + \n                     e.yyx*map( pos + e.yyx, time ) + \n                     e.yxy*map( pos + e.yxy, time ) + \n                     e.xxx*map( pos + e.xxx, time ) );\n    #else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time);\n    }\n    return normalize(n);\n    #endif    \n}\n// ==========  ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n    //vec3 debugOverlay = vec3(0.0);\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray ray = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(ray, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n    hit.surfaceNormal = calcNormal( hit.origin, time );\n\n    // ---- Render\n    vec3 colour;\n    vec3 skybox = mix(vec3(0.03,0.1,0.25),vec3(0.5,0.4,0.3),(ray.direction.y*0.5+0.5)+0.2);\n\n    if (hit.materialId == MAT_WALL) {\n        vec2 block= floor(hit.origin.xz/blockSize);\n        textureWall(block, hit.origin, colour, hit.surfaceNormal, hit.materialId);        \n    }else if (hit.materialId == MAT_SOLID) {\n        vec2 block= floor(hit.origin.xz/blockSize);\n        textureSolid(block, hit.origin, colour, hit.surfaceNormal);        \n    }else if (hit.materialId == MAT_NEON) {\n        #if defined(DEBUG_WHITE_NEON)\n        float lightStrobe = getRoadLightStrobe(hit.distance, time);\n        colour = mix(roadLightColour*0.1,vec3(4.0),lightStrobe);\n        #else \n        colour = vec3(0.0);\n        #endif\n    } else {\n        colour = vec3(0.5,0.4,0.3);\n    }\n\n    if(hit.materialId == MAT_WINDOW) {\n        vec3 hash = hash33(floor(hit.origin*2.0));\n        float on = (hash.x+hash.y+hash.z)+sin(time*0.4+hash.y)*0.05;\n        if(on >1.5) {\n            vec3 wColour = normalize(hash+vec3(0.99));\n            colour=wColour * 5.0;\n        } else {\n            colour=vec3(0.0);\n        }\n    }\n\n    #if defined(DEBUG_LIGHTING)\n    if (hit.materialId != MAT_NEON && hit.materialId != MAT_SKY) {\n        vec3 diffuseLight;\n        vec3 specularLight;\n        float shininess = 10.0;\n        float specularIntensity = 0.1;\n\n        if (hit.materialId == MAT_SOLID) {\n            shininess = 2.0;\n            specularIntensity = 0.1;\n        } else if (hit.materialId == MAT_WALL) {\n            shininess = 20.0;\n            specularIntensity = 0.5;\n        } else if (hit.materialId == MAT_WINDOW) {\n            shininess = 100.0;\n            specularIntensity = 2.0;\n        } \n\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, shininess, camera.origin, diffuseLight, specularLight, time);\n\n        #if defined(DEBUG_AMBIENT)\n        vec3 ambient = skybox*0.5;\n        #if defined(DEBUG_AMBIENT_OCCLUSION)\n        if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n            ambient *=(getOcclusion(hit.origin, hit.surfaceNormal, time));\n        }\n        #endif\n        diffuseLight += ambient;\n        #endif\n\n        if (hit.materialId != MAT_WINDOW) {\n            colour*=diffuseLight;\n        }\n        colour+=(specularLight*specularIntensity);\n\n    }\n    #endif\n\n    #if defined(DEBUG_OCCLUSION)\n    if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n        colour *=(getOcclusion(hit.origin, hit.surfaceNormal, time));\n    }\n    #endif\n\n    #if defined(DEBUG_DISTANCE_FOG)\n    float distanceFog = hit.distance/RAY_MAX_DISTANCE;\n    colour = mix(colour, skybox, distanceFog);\n    #endif\n\n    #if defined (DEBUG_FACE_FOG)\n    float faceFog = getFog(ray.direction+ray.origin,time) * (0.4+0.1*sin(time*0.1));\n    colour += hit.neon * (0.5+faceFog*2.0);\n    colour = mix(colour, vec3(2.0), faceFog);\n    //colour=vec3(faceFog);\n    #else\n    colour += hit.neon;\n    #endif\n\n    // Exposure and Gamma \n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    // colour grading\n    //colour = colour*vec3(1.0,0.8,0.9);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    #if defined(DEBUG_VIGNETTE) \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.5)+0.4,0.0,1.0);\n    //Burn it in\n    colour=vec3(1.0)-((vec3(1.0)-colour)/vignette);\n    #endif\n\n    fragColour = vec4(colour,1.0);\n}", "image_inputs": [{"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3XRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[3384, 3419, 3445, 3445, 3607], [3609, 3609, 3633, 3633, 3779], [3781, 3781, 3806, 3806, 3960], [3962, 3962, 4017, 4077, 4138], [4140, 4208, 4234, 4234, 4290], [4318, 4360, 4396, 4396, 4660], [4729, 4960, 4984, 4984, 5260], [5262, 5262, 5285, 5285, 5569], [5571, 5571, 5594, 5594, 5891], [5894, 5940, 5963, 5963, 6010], [6012, 6012, 6034, 6034, 6085], [6087, 6087, 6109, 6109, 6156], [6227, 6287, 6359, 6359, 6427], [6429, 6429, 6460, 6460, 6657], [6659, 6659, 6690, 6690, 6887], [6889, 6889, 6922, 6922, 7119], [7121, 7121, 7149, 7149, 7172], [7174, 7174, 7202, 7202, 7225], [7294, 7325, 7364, 7364, 8696], [8699, 8730, 8769, 8769, 9510], [9512, 9543, 9583, 9583, 9954], [9956, 9995, 10048, 10048, 10462], [10578, 10590, 10625, 10625, 10653], [10655, 10655, 10692, 10692, 10776], [10788, 10801, 10826, 10826, 10844], [10846, 10846, 10881, 10881, 10907], [10909, 10909, 10940, 10940, 11031], [11033, 11033, 11085, 11085, 11208], [11210, 11210, 11264, 11264, 11325], [11327, 11327, 11381, 11381, 11442], [11454, 11480, 11522, 11522, 11970], [11972, 12058, 12122, 12122, 12236], [12264, 12304, 12336, 12336, 14251], [14253, 14253, 14332, 14332, 14769], [14771, 14771, 14840, 14840, 14974], [14976, 14976, 15018, 15018, 15996], [16024, 16062, 16117, 16117, 21879], [21881, 21881, 21983, 21983, 24021], [24048, 24085, 24141, 24141, 24840], [24842, 24842, 24894, 24894, 25532], [25534, 25534, 25602, 25602, 26368], [26370, 26370, 26454, 26454, 26645], [26647, 26647, 26750, 26750, 28015], [28017, 28043, 28108, 28108, 28492], [28494, 28494, 28566, 28566, 29328], [29330, 29330, 29511, 29511, 30342], [30344, 30344, 30541, 30541, 31516], [31518, 31518, 31675, 31675, 37264], [37292, 37335, 37371, 37371, 37420], [37422, 37486, 37530, 37530, 38126], [38154, 38192, 38250, 38250, 42578]], "test": "untested"}
{"id": "Ws3XRs", "name": "Basic Procedural Noise Terrain", "author": "avcourt", "description": "A very simple terrain generator.\n\nsee github.com/avcourt/terrain for a detailed description.", "tags": ["procedural", "terrain"], "likes": 6, "viewed": 573, "published": "Public", "date": "1572566182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* Author: Andrew Vaillancourt\n* GitHub, Twitter: @avcourt\n*\n* For a detailed README see github.com/avcourt/terrain\n*\n*/\n\n// CONSTANTS, try playing around with some values\n\n// colors\nconst vec3 SKY_COL = vec3(0.76,0.94, 1.0);\nconst vec3 MTN_COL = vec3(0.4, 0.2, 0.0);\nconst vec3 ICE_COL = vec3(0.9, 0.9, 1.0);\nconst vec3 LIGHT_COL = vec3(0.95, 1.0, 0.89); // white, slightly yellow light\n\nconst float FOG_DENSITY = -0.04;\nconst float SKY = -1.0;                 // materialID for sky\nconst vec3 EPS = vec3(0.001, 0.0, 0.0); // smaller values = more detail when normalizing\nconst float MAX_DIST = 60.0;            // used when ray casting to limit ray length\nconst int RAYS = 30;                    // number of rays cast, set lower if framerate slows\nconst int FREQUENCY = 10;               // try lower values if framerate issues encountered\n\n// the following are used in terrain function\nconst float START_HEIGHT = 0.4;\nconst float WEIGHT = 0.6;\nconst float MULT = 0.35;\n\n\n\n// Simple 2d noise algorithm from http://shadertoy.wikia.com/wiki/Noise\n// I tweaked a few values\nfloat noise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\n//generate terrain using above noise algorithm\nfloat terrain( vec2 p, int freq ) {\t\n\tfloat h = START_HEIGHT; // height, start at higher than zero so there's not too much snow/ice\n\tfloat w = WEIGHT; \t// weight\n\tfloat m = MULT; \t// multiplier\n\tfor (int i = 0; i < freq; i++) {\n\t\th += w * noise((p * m)); // adjust height based on noise algorithm\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\n// this function determines how to colour, based on y.pos \n// out of the 3 basics SKY, MTN, ICE, assigns -1.0, 0.0 or 1.0\nvec2 map( vec3 pos, int octaves ) {\n\t\n\tfloat dMin = MAX_DIST;\t// nearest intersection\n\tfloat d; \t\t// depth\n\tfloat materialID = SKY; // set default material id to sky\n\t\n\t// rocky terrain - MTN\n\tfloat h = terrain(pos.xz, octaves);\n\td = pos.y - h;\n\tif (d < dMin) { \n\t\tdMin = d;\n\t\tmaterialID = 0.0;\n\t}\n\t// ice -set IF-statement to false to remove ice\n\tif (true) {\n        float s = 0.05;\n\t\td = pos.y - s;\t\n\t\tif (d<dMin) { \n\t\t\tdMin = d;\n\t\t\tmaterialID = 1.0;\n\t\t}\n\t}\n\treturn vec2(dMin, materialID);\n}\n\n// ray casting funciton. ro = ray origin, rd = ray direction\n// returns materialID\nvec2 castRay( vec3 ro, vec3 rd, int freq) {\n\tfloat dist = 0.0;   // distance\n\tfloat delta = 0.2;  // step\n\tfloat material = -1.0;\n\tfor (int i = 0; i < RAYS; i++) {\n\t\tif (dist < MAX_DIST ) {\t// ignore if 'sky'\n\t\t\tdist += delta; \t\t// next step\n\t\t\tvec2 result = map(ro + rd*dist, freq); // get intersection\n\t\t\tdelta = result.x; \n\t\t\tmaterial = result.y; // set material id based on y pos\n\t\t} \n\t\telse break; //ignore 'sky'\n\t}\n\tif (dist > MAX_DIST) material = SKY; // if nothing intersects set as sky\n\treturn vec2(dist, material);\n}\n\n// calculates normal, try changing epsilon constant\nvec3 calcNormal( vec3 p, int freq) {\n\treturn normalize( vec3(map(p + EPS.xyy, freq).x - map(p-EPS.xyy, freq).x,\n\t\t\t       map(p+EPS.yxy, freq).x - map(p-EPS.yxy, freq).x,\n\t\t\t       map(p+EPS.yyx, freq).x - map(p-EPS.yyx, freq).x) );\n}\n\n\n\nvec3 render( vec3 ro, vec3 rd ) {\n\tconst int freq = FREQUENCY;\n\t\n\tvec3 color = SKY_COL; // base color is sky color\n\tvec2 res = castRay(ro, rd, freq);\n\t\n\tvec3 lightPos = normalize( vec3(1.0, 0.9, 0.0) ); // light position\n\t\n\tvec3 pos = ro + rd*res.x; // world position\n\t\n\t// material  = sky\n\tif (res.y < -0.5) {\n\t\tcolor = SKY_COL;\n\t\treturn color;\n\t}\n\t// now we can calculate normals for moutnains and ice\n    vec3 normal = calcNormal(pos, 10); \n\n\t// material = MTN \n\tif (res.y > -0.5 && res.y < 0.5 ) {\t\n        color = MTN_COL;\t\n\t\t// add light\n\t\tfloat ambient = clamp( 0.5 + 0.5 * normal.y, 0.0, 1.0); // ambient\n\t\tfloat diffuse = clamp( dot( normal, lightPos ), 0.0, 5.0); // diffuse\t\t\n\t\tcolor += (0.4 * ambient) * LIGHT_COL;\n\t\tcolor *= (1.9 * diffuse) * LIGHT_COL;\t\n\t}\n\t// material = ICE\n\tif (res.y > 0.5) {\n        color = ICE_COL;\n\t\t\t\n\t\t// add light\n\t\tfloat ambient = clamp( 0.5 + 0.5 * normal.y, 0.0, 1.0);     // ambient\n\t\tfloat diffuse = clamp( dot( normal, lightPos ), 0.0, 2.0);  // diffuse\n\t\n\t\tcolor += (0.3 * ambient) * LIGHT_COL;\n\t\tcolor *= (2.1 * diffuse) * LIGHT_COL;\n\t}\n\t\n\t// fog from http://in2gpu.com/2014/07/22/create-fog-shader/\n\tfloat fog = exp(FOG_DENSITY * res.x); \n\tcolor = mix(vec3(0.3,0.3,0.35), color, fog); \n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0; // bound screen coords to [0, 1]\n\tpos.x *= iResolution.x / iResolution.y; // set aspect ratio\n\n\t// camera\n\tfloat x = 0.0 + (2.5*iTime);\n\tfloat y = 3.0;\n    float z = 1.0;\n\tvec3 camPos = vec3(x, y, z); // set camera position\n\t\n\tconst vec3 up = vec3(0.0, 1.0, 0.0); // up vector\n\tvec3 camLook = vec3(camPos.x + 1.0, y*0.8, 0.0); // lookAt vector\n\t\n\t\n\tvec3 w = normalize( camLook - camPos );\n\tvec3 u = normalize( cross(w, up) );\n\tvec3 v = normalize( cross(u, w) );\n\t\n\tvec3 rd = normalize( pos.x*u + pos.y*v + 2.0*w );\n\t\n\t// render\n\tvec3 color = render(camPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3XRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[978, 1076, 1099, 1099, 1332], [1335, 1382, 1417, 1417, 1718], [1720, 1842, 1877, 1877, 2335], [2337, 2420, 2463, 2463, 2946], [2948, 3000, 3036, 3036, 3234], [3238, 3238, 3271, 3271, 4492], [4494, 4494, 4551, 4551, 5210]], "test": "untested"}
{"id": "Ws3XWl", "name": "Sphere FBM", "author": "iq", "description": "Carving a series of sphere fields of higher frequencies and smaller sizes. Unlike simply doing an FBM displacement on a solid, this yields a distance field (bound).", "tags": ["3d", "raymarching", "fractal", "distancefield", "sdf", "fbm"], "likes": 130, "viewed": 7475, "published": "Public API", "date": "1573688713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This shader uses a a grid of spheres to carve out fractal detail from\n// a solid block. Unlike naive SDF disaplcemente by a traditional fBM,\n// this shader produces a field that is a valid SDF, so there's no need\n// to reduce the raymarcher's step size to get artifact free visuals.\n//\n// The article that explains this technique can be found here:\n//\n//     https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n//\n// A additive synthesis example of this technique, here: \n//\n//     https://www.shadertoy.com/view/3dGSWR\n\n\n\n// 0 = lattice\n// 1 = simplex\n#define NOISE 0\n\n\n// please, do not use in real projects - replace this by something better\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n//---------------------------------------------------------------\n// A random SDF - it places spheres of random sizes in a grid\n//---------------------------------------------------------------\n\nfloat sdBase( in vec3 p )\n{\n#if NOISE==0\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\t#define RAD(r) ((r)*(r)*0.7)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return min(min(min(SPH(i,f,vec3(0,0,0)),\n                       SPH(i,f,vec3(0,0,1))),\n                   min(SPH(i,f,vec3(0,1,0)),\n                       SPH(i,f,vec3(0,1,1)))),\n               min(min(SPH(i,f,vec3(1,0,0)),\n                       SPH(i,f,vec3(1,0,1))),\n                   min(SPH(i,f,vec3(1,1,0)),\n                       SPH(i,f,vec3(1,1,1)))));\n#else\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(d0.yzx, d0);\n\tvec3 i1 = e*(1.0-e.zxy);\n\tvec3 i2 = 1.0-e.zxy*(1.0-e);\n    \n    vec3 d1 = d0 - (i1  - 1.0*K2);\n    vec3 d2 = d0 - (i2  - 2.0*K2);\n    vec3 d3 = d0 - (1.0 - 3.0*K2);\n    \n    float r0 = hash( i+0.0 );\n    float r1 = hash( i+i1 );\n    float r2 = hash( i+i2 );\n    float r3 = hash( i+1.0 );\n\n    #define SPH(d,r) length(d)-r*r*0.55\n\n    return min( min(SPH(d0,r0),\n                    SPH(d1,r1)),\n                min(SPH(d2,r2),\n                    SPH(d3,r3)));\n#endif\n}\n\n//---------------------------------------------------------------\n// subtractive fbm\n//---------------------------------------------------------------\nvec2 sdFbm( in vec3 p, float d )\n{\n    const mat3 m = mat3( 0.00,  0.80,  0.60, \n                        -0.80,  0.36, -0.48,\n                        -0.60, -0.48,  0.64 );\n    float t = 0.0;\n\tfloat s = 1.0;\n    for( int i=0; i<7; i++ )\n    {\n        float n = s*sdBase(p);\n    \td = smax( d, -n, 0.2*s );\n        t += d;\n        p = 2.0*m*p;\n        s = 0.5*s;\n    }\n    \n    return vec2(d,t);\n}\n\nvec2 map( in vec3 p )\n{\n    // box\n    float d = sdBox( p, vec3(1.0) );\n\n    // fbm\n    vec2 dt = sdFbm( p+0.5, d );\n\n    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;\n    \n    return dt;\n}\n\nconst float precis = 0.0005;\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 res = vec2(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float t = dis.x;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec2 h = map( pos );\n        res.x = t;\n        res.y = h.y;\n        \n\t\tif( h.x<precis || t>dis.y ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>dis.y ) res = vec2(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)\n{\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;\n    if( dis.y<0.0 ) return 1.0;\n    \n    tmin = max(tmin,dis.x);\n\ttmax = min(tmax,dis.y);\n    \n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n     \tfloat h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO min(iFrame,0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n   \n        // camera anim\n        float an = -0.1*iTime;\n        vec3 ro = 4.0*vec3( cos(an), 0.4, sin(an) );\n        vec3 ta = vec3( 0.0, -0.35, 0.0 );\n\n        // camera matrix\t\n        vec3  cw = normalize( ta-ro );\n        vec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n        vec3  cv = normalize( cross(cu,cw) );\n        vec3  rd = normalize( p.x*cu + p.y*cv + 2.7*cw );\n\n        // render\n        vec3 col = vec3(0.01);\n        vec2 tm = raycast( ro, rd );\n        float t = tm.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float occ = tm.y*tm.y;\n\n            // material\n            vec3 mate = mix( vec3(0.6,0.3,0.1), vec3(1), tm.y )*0.7;\n\n            // key light\n            {\n            const vec3 lig = normalize(vec3(1.0,0.5,0.6));\n            float dif = dot(lig,nor);\n            if( dif>0.0 ) dif *= calcSoftShadow(pos+nor*0.001,lig,0.001,10.0,0.003);\n            dif = clamp(dif,0.0,1.0);\n            vec3 hal = normalize(lig-rd);\n            float spe = clamp(dot(hal,nor),0.0,1.0);\n            spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n            col = vec3(0.0);\n            col += mate*1.5*vec3(1.30,0.85,0.75)*dif;\n            col +=      9.0*spe;\n            }\n            // ambient light\n            {\n            col += mate*0.2*vec3(0.40,0.45,0.60)*occ*(0.6+0.4*nor.y);\n            }\n        }\n\n        // tonemap\n        col = col*1.7/(1.0+col);\n        \n        // gamma\n        col = pow(col,vec3(0.4545));\n        \n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.7 + 0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor=vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3XWl.jpg", "access": "shaders20k", "license": "mit", "functions": [[1655, 1729, 1751, 1751, 1854], [1856, 1926, 1957, 1957, 2048], [2050, 2102, 2143, 2143, 2215], [2217, 2285, 2336, 2336, 2604], [2606, 2801, 2828, 2828, 4022], [4024, 4175, 4209, 4209, 4570], [4572, 4572, 4595, 4606, 4754], [4786, 4786, 4826, 4826, 5225], [5227, 5291, 5323, 5323, 5531], [5533, 5595, 5668, 5695, 6167], [6298, 6298, 6355, 6355, 8674]], "test": "untested"}
{"id": "Ws3XWs", "name": "Menger Sponge (3 iterations)", "author": "JentGent", "description": "The Menger Sponge. The fractal that doesn't look like the original Menger Sponge is an alternate made by changing the offset of the subtraction cubes.", "tags": ["3d", "raymarching", "fractal"], "likes": 3, "viewed": 85, "published": "Public", "date": "1573095515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Come check me out on Khan Academy!\n// https://www.khanacademy.org/profile/JentacularGent/projects\n\n// Menger Sponge.\n\n// Set float precision\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Output color\nvec3 c = vec3(1.0, 1.0, 1.0);\n\n// Distance estimators\nfloat deSphere(vec3 from, vec3 center, float radius) {\n\treturn length(center - from) - radius;\n} // Sphere\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n} // Torus\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n    vec3 section = abs(center - from) - dimensions;\n    return length(max(section, 0.0)) + min(max(section.x, max(section.y, section.z)),0.0);\n} // Cuboid\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n} // Uncapped cylinder\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capped cylinder\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2.0, center.x + capAt / 2.0), from.yz)) - radius;\n} // Capsule\n\n// Find normal of a sphere\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\n// Rounded objects (WARNING: also increases object size!)\nfloat deRound(float pd, float radius) {\n\tfloat de = pd;\n\treturn de - radius;\n}\n\n// Booleans (union, subtraction, intersection)\nfloat boolUnion(float pd, float pd2) {\n\treturn min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n\treturn max(pd, -pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n\treturn max(pd, pd2);\n}\n\nfloat deAxis(vec3 from, vec3 center, float size) {\n    float inf = 100000.0;\n    float de = deCuboid(from, center, vec3(inf, size, size));\n    de = boolUnion(de, deCuboid(from, center, vec3(size, inf, size)));\n    de = boolUnion(de, deCuboid(from, center, vec3(size, size, inf)));\n    return de;\n}\n\n// Smooth Booleans\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n\tfloat level = clamp(0.5 + (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n\treturn mix(pd, pd2, level) - smoothness * level * (1.0 - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2.0, 0.0, 1.0 );\n    return mix(pd2, -pd, level) + smoothness * level * (1.0 - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2.0, 0.0, 1.0);\n    return mix(pd, pd2, level) + smoothness * level * (1.0 - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rotate(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot; // X rotation\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot; // Y rotation\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot; // Z rotation\n    inp += anchor;\n    return inp;\n}\n// Lights\nvec3 sun = normalize(vec3(3.0, -3.0, 2.0));\nvec3 point = vec3(0.0, 0.0, 0.0);\n\n// Camera\nvec3 cam = vec3(0.0, 0.0, -5.0);\nfloat FOV = 0.5;\n\n// Glow settings\nvec3 glow_color = vec3(1.0, 1.0, 1.0);\nfloat glow_strength = 0.0;\n\nuniform vec2 cursor;\n\nfloat PI = 3.14159265358979323;\n\n// Scene (creating the scene)\nfloat scene(vec3 from) {\n    \n    float size = 1.0;\n    float de = deCuboid(from, vec3(0.0), vec3(size));\n    float concentration = 3.0 - ceil(cos(iTime * 0.5));\n    for(int iteration = 0; iteration < 3; iteration ++) {\n        vec3 scaledFrom = abs(concentration - concentration * abs(mod(from * size, 2.0) - 1.0));\n        size *= concentration;\n        de = boolSubtraction(de, deAxis(scaledFrom, vec3(0.0), 1.0) / size);\n    }\n    \n    float other = deCuboid(from, vec3(cos(iTime) * 2.0, 0.0, 0.5), vec3(0.5));\n    // de = smoothBoolUnion(de, deSphere(from, vec3(cos(iTime) * 2.0, 0.0, 0.0), 0.5), 0.5);\n    // de = smoothBoolUnion(de, other, 0.5);\n    \n    return de;\n    \n}\n\n// Get the normal of a point on the surface of an object\nvec3 getNormal(vec3 from) {\n    vec2 slopeOther = vec2(0.0001, -0.0001); \n    return normalize(\n        slopeOther.xxx * scene(from + slopeOther.xxx) +\n        slopeOther.xyy * scene(from + slopeOther.xyy) +\n        slopeOther.yyx * scene(from + slopeOther.yyx) + \n        slopeOther.yxy * scene(from + slopeOther.yxy)\n    );\n}\n// March the rays!\nvec3 render(vec3 from, vec3 dir) {\n\tvec3 at = from;\n\tfloat closest = 10000.0;\n\tfor(float totalDE = 0.0; totalDE < 100.0; totalDE += 1.0) {\n\t\tfloat de = scene(at);\n\t\tat += dir * de;\n\t\tif(de < closest) {\n\t\t\tclosest = de;\n\t\t}\n\t\tif(de < 0.01) {\n\t\t    vec3 normal = getNormal(at);\n\t\t    \n\t\t    float shade = dot(normal, -sun);\n\t\t    float bias = 1.0;\n\t\t    vec3 atShadow = at + normal * bias;\n\t\t    float closestShadow = 10000.0;\n\t\t    for(float shadowDE = 0.0; shadowDE < 100.0; shadowDE += 1.0) {\n\t\t        float deShadow = scene(atShadow);\n\t\t        atShadow += -sun * deShadow;\n\t\t        if(deShadow < closestShadow) {\n\t\t            closestShadow = de;\n\t\t        }\n\t\t        if(deShadow < 0.01) {\n\t\t            shade = 0.0;\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    return clamp(vec3(0.0, 1.0, 1.0) * clamp(shade, 0.25, 1.0) - totalDE / 100.0, 0.0, 1.0);\n\t\t}\n\t}\n    return glow_color * glow_strength - closest / 10.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    cam.x = cos(mod(iTime / 2.0, PI * 2.0)) * 3.0;\n    cam.y = 2.0;\n    cam.z = sin(mod(iTime / 2.0, PI * 2.0)) * 3.0;\n     \n    float yaw = mod(iTime / 2.0, PI * 2.0) + PI / 2.0;\n    float pitch = PI / 2.0 + 0.4;\n    // float yaw = 0.0;\n    // float pitch = PI / 2.0;\n    \n    float xMap = fragCoord.x / iResolution.x - 0.5;\n    float yMap = fragCoord.y / iResolution.x - 0.5;\n    vec3 dir = normalize(vec3(xMap, yMap * cos(pitch - PI / 2.0) + cos(pitch), yMap * sin(pitch - PI / 2.0) + sin(pitch)));\n    vec3 rotated = rotate(dir, 0.0, yaw, 0.0, vec3(0.0));\n    dir.x = rotated.x;\n    dir.z = rotated.z;\n    \n    c = render(cam, dir);\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3XWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 260, 314, 314, 356], [357, 367, 437, 437, 533], [534, 543, 600, 600, 745], [746, 756, 820, 820, 871], [872, 893, 968, 968, 1102], [1103, 1122, 1190, 1190, 1324], [1337, 1364, 1404, 1404, 1440], [1442, 1500, 1539, 1539, 1578], [1580, 1627, 1665, 1665, 1689], [1690, 1690, 1734, 1734, 1759], [1760, 1760, 1805, 1805, 1829], [1831, 1831, 1881, 1881, 2128], [2130, 2149, 2211, 2211, 2348], [2349, 2349, 2417, 2417, 2562], [2563, 2563, 2632, 2632, 2775], [2777, 2777, 2852, 2852, 2983], [2985, 2985, 3057, 3057, 3466], [3756, 3786, 3810, 3810, 4465], [4467, 4524, 4551, 4551, 4851], [4852, 4871, 4905, 4905, 5780], [5782, 5782, 5837, 5837, 6511]], "test": "untested"}
{"id": "WscGW4", "name": "01 - ripples", "author": "sgfx", "description": "ripples", "tags": ["test"], "likes": 4, "viewed": 69, "published": "Public", "date": "1572617301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float d = 1.0 - (dot(uv, uv));\n    d += iTime / 3.;\n    d *= 3.;\n    \n    float id = floor(d);\n    id = fract(id * 38.97);\n    \n    vec3 colors = id * vec3(46.35, 17.376, 49.84);\n    colors = fract(colors);\n    \n    float m = fract(d);\n    m = 2.0 * (m - 0.5);\n    m = 1.0 - abs(m);\n    m = smoothstep(0.0, 1.0, m);\n    \n    col += (colors * m);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 540]], "test": "untested"}
{"id": "WscSD2", "name": "Julia Set by jorgemoag", "author": "jorgemoag", "description": "test", "tags": ["fractal"], "likes": 0, "viewed": 82, "published": "Public", "date": "1573048294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int max_iter = 60;\n    float scale = 4.0;\n    \n    vec2 uv = scale * fragCoord/iResolution.xy - vec2(0.5 * scale);\n    uv.y *= iResolution.y / iResolution.x;\n    \n    // c = 0.7885 * e ^ (i * alpha)\n    float alpha = mix(0.0, 2.0 * 3.14159, fract(0.1 * iTime + 0.5));\n    vec2 c = vec2(0.7885 * cos(alpha), 0.7885 * sin(alpha));\n    \n    \n    // otros valores interesantes para c:\n    // c = 0.285 + 0.01i\n    // c = −0.70176 − 0.3842i\n    // c = −0.8 + 0.156i\n    // c = −0.7269 + 0.1889i\n    \n    vec2 Z = uv;\n    \n    int iter;\n    for (iter = 0; iter < max_iter; ++iter)\n    {\n        vec2 Zn = Z;\n        Zn.x = Z.x * Z.x - Z.y * Z.y;\n        Zn.y = 2.0 * Z.x * Z.y;\n        \n        Z = Zn + c;\n        \n        if (dot(Z,Z) > 4.0)\n        {\n            break;\n        }\n    }\n    \n    float s = float(iter) / float(max_iter);    \n    vec3 col = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0), 1.5 * s);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1045]], "test": "untested"}
{"id": "wscSDB", "name": "Emil Rottmayer - Reset/Momentum", "author": "z0rg", "description": "The album cover from Emil Rottmayer's last album \"Reset/Momentum\"\nYep I did not clean the code yet :p", "tags": ["2d", "abstract", "synthwave"], "likes": 2, "viewed": 189, "published": "Public API", "date": "1573026356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nvec3 blue = vec3(19.,33.,149.)/255.;\n\nmat2 r2d(float a) { float sa = sin(a);float ca = cos(a); return mat2(ca, sa, -sa, ca); }\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nfloat _union(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat sdf_cir(vec2 uv, float r)\n{\n  return length(uv)-r;\n}\n\nfloat sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nfloat rdrCir(vec2 uv, float r, float th)\n{\n  float col= sat(1.-_sub(sdf_cir(uv, r),sdf_cir(uv,r-th))/0.005);\n col += abs(uv.y)-(sin(25.*uv.x+iTime)*0.2+0.2)*0.1;\nreturn col;\n}\n\nvec3 rdrChroma(vec2 uv)\n{\n  float r = length(uv)*0.15;\n//  uv = uv+vec2(sin(iTime),cos(iTime))*0.2;\n  vec3 col;\n\n  col.r = rdrCir(uv+uv*r,0.1,0.01);\n  col.g = rdrCir(uv,0.1,0.01);\n  col.b = rdrCir(uv-uv*r,0.1,0.01);\n  return col;\n}\n\nbool inTriangle(vec2 A, vec2 B, vec2 C, vec2 P, float thick)\n{\n  vec2 v0 = C - A ;\n  vec2 v1 = B - A ;\n  vec2 v2 = P - A; // Compute dot products\n  float dot00 = dot(v0, v0) ;\n  float dot01 = dot(v0, v1) ;\n  float  dot02 = dot(v0, v2) ;\n  float dot11 = dot(v1, v1) ;\n  float dot12 = dot(v1, v2) ;\n  // Compute barycentric coordinates\n  float invDenom = 1. / (dot00 * dot11 - dot01 * dot01) ;\n  float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n   float v = (dot00 * dot12 - dot01 * dot02) * invDenom ;\n   // Check if point is in triangle return\n   ;\n   return (u >= 0.) && (v >= 0.) && (u + v < 1.) &&\n   (u<thick||v<thick||(u+v)>1.-thick);\n}\n\nfloat curve(float a)\n{\n  return max(mod(iTime,10.)/10.,0.5)*(sin(iTime+a*102.4)*0.5+0.5)*((sin(a*5.-iTime*15.)*0.3+0.3)+(sin((iTime+a)*13.5)*0.5+0.5));\n}\n\nvec3 mix3(vec3 a, vec3 b, vec3 c, float f)\n{\n\n  vec3 gradA = mix(a, b, sat(f*2.));\n  vec3 gradB = mix(gradA, c, sat(f-0.5)*2.);\n  return gradB;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n\ncol = mix(blue,vec3(0.),abs(uv.y)*0.5);\n  if (uv.y <0.)\n  col = mix(vec3(0.),blue,pow(-uv.y,.5)*.5);\n\n  vec2 posT= vec2(0.,-0.6);\n  float rT = 1.2;//1.7+float(mod(iTime,0.25*sin(iTime)));\n  float aT = (PI*2.)/3.;\n  float offA = 0.;//iTime;\n\n  vec2 A = vec2(rT*sin(aT*1.+offA),rT *cos(aT*1.+offA))-posT;//+vec2(0.,0.1*sin(iTime));\nvec2 B = vec2(rT*sin(aT*2.+offA),rT *cos(aT*2.+offA))-posT;\nvec2 C = vec2(rT*sin(aT*3.+offA),rT *cos(aT*3.+offA))-posT;\n\nvec2 posT2= vec2(0.,0.6);\nfloat angleB = 3.14159265;\nvec2 A2 = vec2(rT*sin(aT*1.+angleB),rT *cos(aT*1.+angleB))-posT2;//+vec2(0.,0.1*sin(iTime));\nvec2 B2 = vec2(rT*sin(aT*2.+angleB),rT *cos(aT*2.+angleB))-posT2;\nvec2 C2 = vec2(rT*sin(aT*3.+angleB),rT *cos(aT*3.+angleB))-posT2;\n\n    float cirSpeed = .2;\n    vec2 cirPos = vec2(1.,2.5)+vec2(sin(iTime*cirSpeed), cos(iTime*cirSpeed))*0.5;\n        vec2 ciruv = uv - cirPos;\n      float inCir = sat(1.-sat(sdf_cir(ciruv, .5))*10000.);\n    \n    vec3 cirBaseCol = blue*0.3;\n    vec3 cirHaloCol = (vec3(136.,234.,255.)/210.)*pow(length(ciruv-vec2(1.5,2.)*0.15),1.2)*pow(length(ciruv-vec2(-.5,2.5)*0.15),1.2)*(length(ciruv)+0.6)+0.15*sat(dot(ciruv,-cirPos));\n    col = mix(col, cirBaseCol+cirHaloCol, inCir);\n    \n    uv.y *= 1.2;\nif(inTriangle(A,B,C,uv,1.))\n  col = mix3(vec3(0.),blue,vec3(136.,234.,255.)/210.,abs(uv.y*0.7));\nif(inTriangle(A2,B2,C2,uv,1.))\n  col += mix3(vec3(0.),blue,vec3(204.,247.,255.)/210.,abs(uv.y))*float(mod(abs(uv.y+iTime*0.05),0.07)<0.01);\n    \n\n  return col;\n}\n\n\t\t\t\t//normpdf function gives us a Guassian distribution for each blur iteration; \n//this is equivalent of multiplying by hard #s 0.16,0.15,0.12,0.09, etc. in code above\n\t\t\t\tfloat normpdf(float x, float sigma)\n\t\t\t\t{\n\t\t\t\t\treturn 0.39894*exp(-0.5*x*x / (sigma*sigma)) / sigma;\n\t\t\t\t}\n\t\t\t\tvec3 blur(vec2 uv, float blurAmount) {\n\t\t\t\t\t//get our base color...\n\t\t\t\t\tvec3 col = rdr(uv);\n\t\t\t\t\t//total width/height of our blur \"grid\":\n\t\t\t\t\tconst int mSize = 11;\n\t\t\t\t\t//this gives the number of times we'll iterate our blur on each side \n\t\t\t\t\t//(up,down,left,right) of our uv coordinate;\n\t\t\t\t\t//NOTE that this needs to be a const or you'll get errors about unrolling for loops\n\t\t\t\t\tconst int iter = (mSize - 1) / 2;\n\t\t\t\t\t//run loops to do the equivalent of what's written out line by line above\n\t\t\t\t\t//(number of blur iterations can be easily sized up and down this way)\n\t\t\t\t\tfor (int i = -iter; i <= iter; ++i) {\n\t\t\t\t\t\tfor (int j = -iter; j <= iter; ++j) {\n\t\t\t\t\t\t\tcol += rdr(vec2(uv.x + float(i) * blurAmount, uv.y + float(j) * blurAmount)) * normpdf(float(i), 7.);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//return blurred color\n\t\t\t\t\treturn col / float(mSize-2);\n\t\t\t\t}\n\nvec3 rdrClean(vec2 uv)\n{\n    return blur(uv, .0008);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv = uv-(iResolution.xy/iResolution.xx)*0.5;\n    uv -= vec2(-0.1,-0.05);\nuv*=8.;\n    uv *= r2d(-0.4);\n vec3 col;// = vec3(length(uv));\n    \n    \n col += rdrClean(uv);\ncol = pow(col, vec3(1./1.5));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 86, 86, 155], [157, 157, 178, 178, 208], [209, 209, 229, 229, 256], [258, 258, 288, 288, 310], [312, 312, 344, 344, 365], [367, 367, 400, 400, 425], [427, 427, 461, 461, 509], [511, 511, 553, 553, 686], [688, 688, 713, 713, 919], [921, 921, 983, 983, 1567], [1569, 1569, 1591, 1591, 1722], [1724, 1724, 1768, 1768, 1869], [1871, 1871, 1890, 1890, 3386], [3392, 3561, 3602, 3602, 3667], [3672, 3672, 3710, 3739, 4524], [4526, 4526, 4550, 4550, 4580], [4582, 4582, 4639, 4639, 4913]], "test": "untested"}
{"id": "WscSDl", "name": "TIPE", "author": "MaximeG", "description": "tipe", "tags": ["tag"], "likes": 1, "viewed": 106, "published": "Public API", "date": "1573086535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dSegment( in vec2 p, vec2 a, vec2 b ) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y * (60. + 40. * sin(iTime * 0.25));\n    \n    vec2 nextDirection = vec2(1., 0.);\n    float nextDirectionDot = 0.5 + 0.4 * dot(normalize(-uv), nextDirection);\n    \n    float distanceToNextPoint = length(uv);\n\n    float targetSpeedMultiplier = (1. - (1. - max(min(distanceToNextPoint / 60., 1.), 0.)) * (1. - nextDirectionDot * nextDirectionDot));\n\tfloat result = 0.5 + 0.5*targetSpeedMultiplier;\n    result = pow(result, 4.);\n    vec3 col = vec3(result);\n    \n    if (dSegment(uv, vec2(0.), vec2(4., 0.)) < .25)\n    \tcol = vec3(1., 0., 0.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 163], [165, 165, 222, 222, 853]], "test": "untested"}
{"id": "wscSWl", "name": "Codevember03 - Deep", "author": "z0rg", "description": "My participation at codevember 2019 3rd day, the subject is deep.", "tags": ["2d", "octopus", "deep", "codevember"], "likes": 6, "viewed": 172, "published": "Public API", "date": "1573113245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nmat2 r2d(float a){float sa = sin(a);float ca = cos(a);return mat2(ca,sa,-sa,ca);}\nfloat lenny(vec2 uv)\n{\n  return abs(uv.x)+abs(uv.y);\n}\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat sdf_cir(vec2 uv,float r)\n{\n  return length(uv)-r;\n}\n\nfloat sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n\n  return max(r.x,r.y)+0.005*cos(iTime+10.*atan(uv.y,uv.x)/(3.1415));\n}\n\nfloat _union(float a, float b)\n{\n  return min(a, b);\n}\n\nfloat _sub(float a, float b)\n{\n  return max(-a,b);\n}\nfloat _inter(float a, float b)\n{\n  return max(a,b);\n}\n\nfloat sdf_tentacle(vec2 uv, float thick, float amp,float freq, float off)\n{\n  uv.x += thick+amp;\n  return (uv.x+thick*0.5)-thick-(sin(off+freq*uv.y)*amp+amp);\n}\n\nfloat sdf_tentacle2(vec2 uv, float thick, float len, float freq, float amp, float off)\n{\n  return _inter(_sub(sdf_tentacle(uv, thick,amp,freq,off),sdf_tentacle(uv-vec2(thick,0.),thick,amp,freq,off)),\n    sdf_rect(uv, vec2(2.,len)));\n}\n\n\nfloat sdf_medusa(vec2 uv)\n{\n  float ret =  mix(sdf_rect(uv, vec2(.07)),length(uv)-0.15,0.5);\n//  ret = _union(sdf_rect(uv, vec2(.1)),tent);\n   ret = _union(sdf_tentacle2(uv-vec2(0.,-.2), 0.001,0.3,30.,0.05*uv.y,iTime),ret);\n   ret = _union(sdf_tentacle2(r2d(sin(0.5*iTime+uv.y*2.)*.5)*uv-vec2(0.,-.2), 0.001,0.3,30.,0.05*uv.y,iTime),ret);\n   ret = _union(sdf_tentacle2(r2d(sin(1.+0.3*iTime+uv.y*2.)*.5)*uv-vec2(0.,-.2), 0.001,0.1,25.,0.05*uv.y,iTime+0.3),ret);\n   ret = _union(sdf_tentacle2(r2d(sin(0.7+0.5*iTime+uv.y*2.)*.5)*uv-vec2(0.,-.2), 0.02,0.2,15.,0.1*uv.y,iTime+1.),ret);\n\n\n   return ret;\n  return sdf_rect(uv+vec2(0.1,0.),vec2(0.15));\n}\n\nint mat = -1;\n\n\nfloat map(vec2 uv)\n{\n  uv += vec2(sin(uv.x+uv.y+iTime)*0.03);\n  return sdf_medusa(uv*r2d(-0.2+sin(iTime*0.5)*0.2));\n}\n\n// This one must change, it does not work as intended and does not contribute a lot to the final image)\nvec3 rdrBack(vec2 uv)\n{\n  const int lines = 8;\n  vec3 acc= vec3(1.);\n\n  for (int i = 0; i< lines;++i)\n  {\n    float fi = float(i);\n    vec2 pos= 1.*vec2(rand(vec2(fi*12., 8.-fi)), rand(vec2(mod(fi,0.5),fi)));\n    pos-= vec2(0.2);\n    pos-=pos;\n    float speed = 0.5;\n    pos -= max((fi/8.),0.1)*vec2(sin(speed*(iTime+fi)),cos(speed*(fi+iTime*(mod(fi,2.)<0.1?1.:-1.))));\n    acc -= 3.*pow(length(uv-pos)*0.005*fi,1.);\n  }\n  return acc;\n}\n\n\nvec3 rdr(vec2 uv)\n{\n  vec3 overlay;\n  vec3 col;\n  vec3 back;\n  back = pow(length(uv),4.)+vec3(.5)*rand(uv);\n  back *= rdrBack(uv);\n  float obj = map(uv);\n  float obs = float(0.05*sin(uv.x*5.+iTime)<uv.y+0.1*sin(iTime*0.1));\nvec3 light = obs*2.*vec3(0.15,0.21,0.24)*sat(1.-lenny(uv*vec2(0.5,3.)));\n\n  col = mix(vec3(.0),back+light,clamp(obj*50.,.0,1.))*3.;\nfloat freq = 200.;\nback*= vec3(0.5)*((sin(uv.x*freq)*0.5+0.5)+\n  (sin(uv.y*freq+iTime)*0.5+0.5))\n  +sin((sin(uv.x*20.-iTime*0.5)*uv.y*1.2+iTime*0.1)*20.5);\n  overlay = back;\n  float a = atan(uv.y,uv.x);\n  return clamp(1.-length(uv*1.3),0.,1.  )*(col+overlay)*(1.-(sin(a*30.))*(length(uv)*(sin(a*20.+iTime))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv-= vec2(.5)*(iResolution.xy/iResolution.xx);\n  uv *= 2.;\n  vec3 col;\n\n\n  col = rdr(uv);\n  col*= mix(vec3(0.23,0.12,clamp(-uv.y,0.,1.)*0.5).zyx*5.,col,0.8);\n  col += 1.5*vec3(0.15,0.31,0.24)*(1.-lenny(uv*vec2(1.,1.)));\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscSWl.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 397, 417, 417, 485], [486, 486, 504, 504, 567], [568, 568, 590, 590, 622], [624, 624, 644, 644, 671], [673, 673, 705, 705, 730], [732, 732, 766, 766, 861], [863, 863, 895, 895, 917], [919, 919, 949, 949, 971], [972, 972, 1004, 1004, 1025], [1027, 1027, 1102, 1102, 1187], [1189, 1189, 1277, 1277, 1423], [1426, 1426, 1453, 1453, 2072], [2090, 2090, 2110, 2110, 2207], [2209, 2313, 2336, 2336, 2749], [2752, 2752, 2771, 2771, 3419], [3421, 3421, 3478, 3478, 3775]], "test": "untested"}
{"id": "WscSzf", "name": "American pyramid", "author": "plosique", "description": "Calculates the intersection of planes using their respective SDF's ", "tags": ["raymarching", "geometry"], "likes": 0, "viewed": 52, "published": "Public", "date": "1572912971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS=255; \nconst float MAX_DIST=100.0; \nconst float MIN_DIST=0.0; \nconst float EPS=0.001; \nconst float a=0.2; \nconst vec3 ls=vec3(3.0,3.0,-1.0); \n//const vec3 ia=vec3(.85,.64,.32);\n//const vec3 id=vec3(.82,.70,.55); \n//const vec3 is=vec3(.82,.71,0.55); \nconst vec3 Red=vec3(1.,0.,0.); \nconst vec3 Blue=vec3(0.,0.,1.); \nconst vec3 Egypt=vec3(.82,.55,.71);\nconst float kd=0.1; \nconst float ks=0.; \nconst float ka=0.9; \nconst float pi=acos(-1.); \nvec3 n[6]; \nvec3 plpt[6];\n\nfloat rand(vec2 uv){\n    uv=fract(uv*vec2(233.34,851.73));\n    uv+=dot(uv,uv+23.45);\n    return fract(uv.x*uv.y);\n}\nfloat value(vec2 uv){\n    uv*=4.;\n    vec2 uvf=fract(uv);\n    uvf=uvf*uvf*(3.-2.*uvf);\n    vec2 bl=floor(uv);\n    float vbl=rand(bl);\n    float vbr=rand(bl+vec2(1.,0.));\n    float vtl=rand(bl+vec2(0.,1.));\n    float vtr=rand(bl+vec2(1.,1.));\n    float x0=mix(vbl,vbr,uvf.x);\n    float x1=mix(vtl,vtr,uvf.x);\n  return mix(x0,x1,uvf.y);\n} \n\n  \n    \n    \nfloat fractal(vec2 uv){\n    float sum=0.;\n    for(float i=0.;i<4.;++i){\n        sum+=value(uv*pow(2.,i))/pow(2.,i);\n    }\n    return fract(sum/2.);\n}\n\n\nvec2 rotate2D(vec2 plane,float theta){\n    return vec2(plane.x*cos(theta)-plane.y*sin(theta),plane.x*sin(theta)+plane.y*cos(theta)); \n}\n    \n\nfloat planeSDF(vec3 n,vec3 plpt,vec3 pt){ \n    pt.x-=plpt.x;\n    pt.y-=plpt.y;\n    pt.z-=plpt.z;\n\n    return dot(n,pt); \n} \n\n\nfloat sceneSDF(in vec3 pt,out int id){   \n    float ma=planeSDF(n[0],plpt[0],pt);\n    id=0;\n    float val;\n    for(int i=1;i<6;i++){\n        val=planeSDF(n[i],plpt[i],pt);\n        if(ma<val){ \n            id=i;\n            ma=val;\n        } \n    } \n    return ma; \n}\n\nvec2 iter(vec2 uv){ \n    float dx=uv.x/uv.y;\n    float dy=uv.y/uv.x;\n    for(int i=0;i<30;i++){ \n        uv.x*=dx;\n        uv.y*=dy;\n    } \n    return uv;\n}\n\n\n\nvec4 ray_march(in vec3 eye, in vec3 dir){\n    vec4 bkg=vec4(0.0,0.0,0.0,1.0); \n    vec3 pt; \n\tpt=eye;\n    float step_size=0.0;\n    int j; \n    for(int i=0;i<MAX_STEPS;i++){\n        step_size=sceneSDF(pt,j); \n        \n        pt=pt+step_size*dir;\n        \n        if (step_size>MAX_DIST){  \n            return bkg ;\n        } \n        if (step_size<EPS){\n            vec3 N=n[j]; \n            vec3 L=(ls-pt); \n            vec3 V=(eye-pt); \n            vec3 R=reflect(-L,N);\n            vec2 uv; \n            if(j==0 || j==3){ \n              uv=vec2(pt.y,pt.z);\n            }else{\n               uv=vec2(pt.y,pt.x); \n            }\n                \n                \n            \n            //float mul=value(vec2(sin(iTime),cos(iTime)));\n            //uv*=mul;\n            uv=uv+fractal(uv+fractal(uv+fractal(uv+fractal(uv)))); \n            \n            //vec2 uv2=uv+10.;\n            //uv2=uv+fractal(uv2+fractal(uv2+fractal(uv2)));\n            //vec2 uv3=uv+50.;\n            //uv3=uv3+fractal(uv3+fractal(uv3+fractal(uv3)));\n            \n            //uv=mix(uv,uvn,.5+.5*sin(iTime*.5)); \n            //uv1=iter(uv1);\n            //uv2=iter(uv2);\n            //uv3=iter(uv3); \n            //vec3 ia=uv1.x*Red+uv1.y*Blue;\n            //vec3 id=Red*uv2.x+Blue*uv2.y;\n            //vec3 is=Red*uv3.x+Blue*uv3.y; \n            //vec3 ia=Red*fractal(vec2(uv+1000.))+Blue*fractal(vec2(uv+2000.));\n            //vec3 id=Red*fractal(vec2(uv+1500.))+Blue*fractal(vec2(uv+3000.));\n            //vec3 is=Red*fractal(vec2(uv+1200.))+Blue*fractal(vec2(uv+3200.));\n            //vec3 ret=ka*ia+kd*(dot(L,N))*id+ks*pow(dot(R,V),a)*is;\n            //vec3 ret=vec3(0.82,0.71,0.55);  \n            float diff=.1;\n            vec3 ret=vec3(0.82+diff*fractal(uv),.71+diff*fractal(uv+1000.),.55+diff*fractal(uv+2000.)); \n            vec4 ret2=vec4(ret,1.0);\n            return ret2;\n                \n            \n        } \n       \n    }return bkg ;\n}\n\nvec3 ray_dir(vec3 eye,vec3 pix_loc){ \n    return normalize(pix_loc-eye); \n}\n\n\n    \n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv=fragCoord-0.5*iResolution.xy; \n    uv=uv.xy/(0.5*iResolution.y);\n    float diff=iResolution.x/iResolution.y;\n    vec2 posx=rotate2D(vec2(1.,0.),pi/6.); \n    vec2 negx=rotate2D(vec2(-1.,0.),-pi/6.);\n    vec2 posz=rotate2D(vec2(0.,1.),-pi/6.);   \n    vec2 negz=rotate2D(vec2(0,-1.),pi/6.); \n    n[0]=vec3(posx,0.);\n    //n[0]=vec3(1.,0.,0.);\n    n[1]=vec3(0.,1.,0.); \n    //n[2]=vec3(0.,posz.x,posz.y*2.*diff);\n    //n[2]=normalize(n[2]);\n    n[2]=vec3(0.,posz); \n    n[3]=vec3(negx,0.);\n    //n[3]=vec3(-1.,0.,0.); \n    n[4]=vec3(0.,-1.,0.);\n    n[5]=vec3(0.,negz);\n    //n[5]=normalize(n[5]); \n    //n[5]=vec3(0.,0.,-1.);\n    plpt[0]=vec3(1.0,-1.0,0.);\n    plpt[1]=vec3(0.,mod(iTime,20.)/20.,0.);\n    plpt[2]=vec3(0.,1.0,1.0);\n    plpt[3]=vec3(-1.,1.0,0.);\n    plpt[4]=vec3(0.,-1.,0.);\n    plpt[5]=vec3(0.,-1.0,-1.);\n    \n    float theta=iTime;\n    //for(int i=0;i<6;i++){ \n      //  vec2 rotn=rotate2D(vec2(n[i].x,n[i].z),theta);\n        //vec2 rotp=rotate2D(vec2(plpt[i].x,plpt[i].z),theta); \n         //n[i].x=rotn.x;\n         //n[i].z=rotn.y; \n         //plpt[i].x=rotp.x;\n         //plpt[i].z=rotp.y;\n    //} \n    vec2 init=vec2(0.,-10.);\n    vec2 act_eye=rotate2D(init,theta);\n    vec2 loc=rotate2D(vec2(uv.x,-5.),theta); \n    vec3 eye=vec3(act_eye.x,-.5,act_eye.y); \n    vec3 pix_loc=vec3(loc.x,uv.y,loc.y); \n    vec3 dir=ray_dir(eye,pix_loc);  \n    vec4 pix_val=ray_march(eye,dir);\n        \n\n    // Output to screen\n    fragColor = pix_val;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 486, 506, 506, 601], [602, 602, 623, 623, 938], [954, 954, 977, 977, 1103], [1106, 1106, 1144, 1144, 1241], [1248, 1248, 1289, 1289, 1370], [1374, 1374, 1412, 1412, 1640], [1642, 1642, 1661, 1661, 1798], [1802, 1802, 1843, 1843, 3730], [3732, 3732, 3768, 3768, 3807], [3825, 3825, 3882, 3933, 5396]], "test": "untested"}
{"id": "WscXD2", "name": "[inercia2019] raka", "author": "Alien01", "description": "My first entry. 2nd place at inercia2019 one scene compo.", "tags": ["inercia2019"], "likes": 4, "viewed": 104, "published": "Public", "date": "1572872933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Raka\n// by @Alien01_\n// My first entry. 2nd place at inercia2019 one scene compo.\n\n#define PI 3.141592\n\n\n// From IQ's website\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// Also IQ's\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n\nfloat square(vec2 uv, float r){\n  float a = step(uv.x, r/2.) - step(uv.x, -r/2.);\n  float b = step(uv.y, r/2.) - step(uv.y, -r/2.);\n  float c = a*b;\n  return c;\n}\n\nfloat gridShape(vec2 uv, float r){\n  return square(uv, r * 2.0);\n}\n\nfloat map(vec3 p, float iTime){\n  vec3 pt = p;\n  pt.yz *= rot((iTime * 0.5));\n  pt.xy *= rot(cos(iTime * 0.5 * PI));\n  pt.xy *= rot(0.5);\n  pt.yz *= rot(1.0);\n  pt.yz *= rot(PI/2.0);\n  float t = torus(pt, vec2(2.0, 0.5 * cos(iTime)));\n  vec3 ps1 = pt;\n  ps1.xz *= rot( iTime);\n  ps1.y -= 1.5 * cos(iTime * 2.0);\n  ps1.x -= 0.5;\n  float s1 = sphere(ps1, 0.5);\n  vec3 ps2 = pt;\n  ps2.xz *= rot( iTime);\n  ps2.y -= 1.5 * sin(iTime * 2.0);\n  ps2.x += 0.5;\n  float s2 = sphere(ps2, 0.5);\n  float s = smin(s2, s1, 2.0);\n  return smin(t,s, 0.3);\n}\n\nvec3 trace(vec2 uv, float iTime){\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  vec3 p = ro+rd;\n  float t = 0.;\n  int i = 0;\n  int iter = 64;\n  float d = 0.0;\n  for(i=0; i<iter; i++){\n      d = map(p, iTime);\n\t  t += d;\n\t  p += rd*d;\n\t  if(t > 100. ){\n        return vec3(0);\n      }\n      else if( d < 0.1){\n      return vec3(1.0-p.z);\n    }\n  }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  float gTime = iTime;\n  gTime *= 0.4;\n  \n  vec2 uv = fragCoord/iResolution.xy;\n  \n  uv.x -= 0.4;\n  uv.y -= 0.4;\n  uv *= 1.2;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec2 uv1 = uv;\n\n  float d = trace(uv, iTime).x;\n  d = smoothstep(d, 0.0, abs(cos(iTime)));\n \n  uv.yx *= rot(0.2 * gTime);\n  vec3 color = vec3(0.0);\n  \n  vec2 st = fract(uv * 15.) - 0.5;\n  vec2 stid = floor(uv) + 0.5;  \n  \n  \n  st *= rot(d);\n  color += 0.9*gridShape(st, d*0.16);\n  color += 0.5*gridShape(st, 0.4);\n  \n  \n  color *= mix(square(uv, 0.9), 0.8, d);  \n  uv /= 2.0;\n  \n  vec2 id = ceil(uv) - 0.5;\n  id *= rot( 0.5 * gTime * PI);\n  color += 0.5*gridShape(id, 0.4 );\n  \n  if ( id.y + id.x - 0.3  <  uv.y ){  \n    color = 1.0-color.zxy;\n  }\n\n  color.r *= 2.0;\n  color += vec3(0.2, 0.0, 0.4);\n  color *= 1.-dot(uv1,uv1) ;\n  fragColor = vec4(color,1.0);\n  \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 204, 235, 235, 300], [301, 314, 357, 357, 456], [458, 458, 476, 476, 526], [528, 528, 558, 558, 584], [586, 586, 617, 617, 748], [750, 750, 784, 784, 816], [818, 818, 849, 849, 1358], [1360, 1360, 1393, 1393, 1736], [1739, 1739, 1796, 1796, 2642]], "test": "untested"}
{"id": "WscXDl", "name": "symbiote", "author": "mahalis", "description": "a project for Nodevember day 7, “Moss”. it’s simpler than I’d like—I was experimenting with some more interesting lighting effects, but the sphere displacement messes up the distance metric enough that most of them straight-up didn’t work.", "tags": ["raymarch", "moss", "nodevember"], "likes": 2, "viewed": 311, "published": "Public API", "date": "1573144352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// except where otherwise noted, this code is CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\n// -----------------\n\n// 3d noise by iq, from https://www.shadertoy.com/view/Xsl3Dl\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n// -----------------\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// x: distance, y: index of closest material\n\nvec2 d(vec3 position) {\n    float mossDist = sdSphere(position, 0.48) - pow(max(0.0, noise(position * 4.0 + vec3(0.05,0.1,0.02) * iTime)), 0.7) * 0.08;\n    \n    float sphereDist = sdSphere(position, 0.48);\n    if (mossDist < sphereDist) {\n        return vec2(mossDist, 1.0);\n    }\n    \n    return vec2(sphereDist, 0.0);\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy).x, d(p + eps.yxy).x, d(p + eps.yyx).x) - v) / eps.x;\n}\n\n// x: distance traveled, y: distance to surface at the intersection point, z: material index\nvec3 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    float rayLength = 0.0;\n    for(int i = 0; i < 90; i++) {\n        float stepLength = max(lastDistance * 0.8, prec);\n        vec3 samplePosition = lastSamplePosition + stepLength * towards;\n        rayLength += stepLength;\n        \n        vec2 distanceAndMaterial = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = distanceAndMaterial.x;\n        \n        if (lastDistance < 0.0) {\n            return vec3(rayLength, lastDistance, distanceAndMaterial.y);\n        }\n    }\n    return vec3(0.0,1.0,0.0);\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye, float materialIndex) {\n    vec3 toLight = normalize(vec3(-0.3, 0.9, 0.5)  - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    \n    float localNoiseValue = noise(position * 160.);\n    \n    vec3 albedo = mix(vec3(0.7 + 0.1 * localNoiseValue), mix(vec3(0.3,0.6,0.1), vec3(0.1,0.3,0.), pow(1.-abs(localNoiseValue),2.0)), materialIndex);\n    \n    float ambience = mix(0.2,0.5,clamp(dot(normal, vec3(0.0,-1.0,0.0)), 0.0, 1.0));\n    const float specular = 0.4;\n    float specularPower = mix(8.,2.,materialIndex); // moss is rougher\n    float shadow = smoothstep(0.0, 0.1, march(position + normal * 0.05, toLight, 0.002).y);\n    float lighting = (ndotL + pow(ndotH, specularPower) * specular) * shadow + ambience;\n    float fres = pow(clamp(1.0 - ndotV, 0.0, 1.0), 3.0) * materialIndex * 0.4;\n    \n    return lighting * albedo + fres;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = vec3(0.0, 0.4, 2.0);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    vec3 marchResult = march(cameraPosition, rayDirection, 0.001);\n    if (marchResult.y > 0.0) {\n        fragColor = vec4(0.0); // “sky” color\n    } else {\n        vec3 position = cameraPosition + rayDirection * marchResult.x;\n        fragColor = vec4(lightSurface(position, gradient(position, marchResult.y), -rayDirection, marchResult.z), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscXDl.jpg", "access": "shaders20k", "license": "cc-by-2.5", "functions": [[189, 1268, 1289, 1289, 1458], [1460, 1460, 1486, 1486, 2311], [2314, 2336, 2369, 2369, 2397], [2399, 2445, 2468, 2468, 2766], [2768, 2768, 2800, 2800, 2932], [2934, 3027, 3076, 3076, 3694], [3696, 3696, 3776, 3776, 4714], [4716, 4716, 4773, 4773, 5615]], "test": "untested"}
{"id": "wscXDX", "name": "Least square approximation", "author": "ircss", "description": "least square approximation .", "tags": ["projection", "leastsquare"], "likes": 7, "viewed": 329, "published": "Public API", "date": "1572993020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void DrawPoint(vec2 pos, vec2 uv,float size, vec3 dotColor, inout vec3 sceneColor){\n    \n    float d    = distance(uv, pos);\n    sceneColor = mix(dotColor, sceneColor, smoothstep(size, size + 0.01, d));\n    \n}\n\nvoid DrawLine(float m, float c, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n\n    vec2  xy   = vec2(uv.x, uv.x * m + c); \n    float d    = distance(xy, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + 0.01, d));\n    \n}\n\nvoid DrawVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + 0.01, d));\n    \n}\n\nvoid DrawHalfVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.01, d)+ m, 0. ,1.)); \n}\n\nvoid DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    float m    = 1. - step(0.,vUv/v2);\n          m   += step(len, vUv/v2);\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.01, d)+ m, 0. ,1.)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---------------------------------------------------------\n    // ---COORDINATE SETUP\n    \n    vec2  uvCoordinate    =  fragCoord/iResolution.xy;\n    float aCorreection    =  iResolution.x/iResolution.y;\n    \n          uvCoordinate.x *=  aCorreection;\n          uvCoordinate   -=  vec2(aCorreection/2., 0.5);\n    \n    // ---------------------------------------------------------\n\n    vec3  col             = vec3(0.6,0.6,0.6);\n    vec3  mainLinesColor  = vec3(0.8,0.2,0.1);\n    vec3  eLinesColor     = vec3(0.6,0.8,0.1);\n    vec3  dotColors       = vec3(0.1,0.3,0.);\n    \n    vec2  graphOrigin     = vec2(0., 0.);\n    float sideLengths     = 0.5;\n    vec2  side1           = vec2(cos(iTime*0.4), sin(iTime*0.4));\n    vec2  side2           = vec2(2.,0.);\n    float side2Sqr        = dot(side2, side2);\n    \n    float lineWidth       = 0.0003;\n    \n    float numberOfPoints  = 5.;\n   \n    DrawHalfVectorWithLength( graphOrigin, normalize( side1), sideLengths,uvCoordinate, lineWidth, mainLinesColor, col);\n    DrawHalfVectorWithLength( graphOrigin - vec2(sideLengths, 0.), side2, sideLengths,uvCoordinate, lineWidth, mainLinesColor, col);\n    \n    \n\n    for(float i = 1. ; i <= numberOfPoints; i ++){\n        \n        float f    = (i / numberOfPoints);\n        \n        vec2 point = graphOrigin + normalize(side1) * f*sideLengths;\n        \n        DrawPoint(point, uvCoordinate, 0.01,dotColors, col); \n        \n        // projection on the other line\n        \n        \n\n        float sP  = dot(side2, point - graphOrigin);\n        vec2  p   = side2 * sP/side2Sqr;\n              p  += graphOrigin;\n        DrawPoint(p , uvCoordinate,  0.01,dotColors, col); \n        \n        vec2 e    = point - p; \n        \n        DrawHalfVectorWithLength(p, normalize(e), length(e), uvCoordinate,lineWidth*0.1, eLinesColor, col);\n    }\n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 209], [211, 211, 303, 303, 469], [471, 471, 573, 573, 829], [831, 831, 937, 937, 1246], [1248, 1248, 1375, 1375, 1720], [1722, 1722, 1779, 1871, 3681]], "test": "untested"}
{"id": "WscXRs", "name": "[TWITCH] ShaderTober - Coat", "author": "Flopine", "description": "A small doodle with inktober's theme \"Coat\".\nI've made it on a Twitch live session that you can watch here > https://www.twitch.tv/flopine", "tags": ["raymarching", "scales", "twitch", "inktober"], "likes": 10, "viewed": 175, "published": "Public", "date": "1572568817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define wr vec2(1.,0.8)\n#define time iTime\n#define PI 3.141592\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat wool (vec2 uv)\n{\n    uv.x = abs(uv.x);\n    float c = 0.5-abs(uv.x-uv.y);\n    return c;\n}\n\nvec4 wool_grid (vec2 uv)\n{\n    uv *= 10.;\n    vec2 ga = mod(uv,wr)-wr*0.5;\n    vec2 gb = mod(uv-wr*0.5,wr)-wr*0.5;\n\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n    guv.y = wool(guv);\n    vec2 id = uv-guv;\n    return vec4(guv,id);\n}\n\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat SDF (vec3 p)\n{ \n    p.z += wool_grid(p.xy*0.8).y*0.1;\n\n    p.xz *= rot(p.y*0.5);\n    moda(p.xz, 7.);\n    p.x -= .8 + sin(p.y*2.+time)*0.5;\n\n    p.xz *= rot(p.y+time);\n    moda(p.xz, 5.);\n    p.x -= 0.12+cos(p.y*5.-time)*0.15;\n    \n    return cyl(p.xzy, 0.1,5.);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                         SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                         SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nfloat fre (vec3 n, vec3 rd)\n{return pow(clamp(1.-dot(n, -rd),0.,1.),1.5);}\n\nfloat spe (vec3 l, vec3 n, vec3 rd)\n{\n    vec3 h = normalize(-rd);\n    return pow(max(dot(n,h),0.),10.);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tuv *= 0.5;\n    \n    vec3 ro = vec3(0.001,0.001,-3.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n\n    bool hit = false;\n\tfloat dmax = 10.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = palette (fre(n,rd),\n                       vec3(0.5),\n                       vec3(0.5),\n                       vec3(.5),\n                       vec3(0.1,0.37,0.43));      \n        col += spe(ro,n,rd) * vec3(0.,0.5,0.);\n    }\n\t\n    col *= smoothstep(0.1,0.4,wool_grid(uv).y)*1.-(abs(sin(length(uv*wool_grid(uv).zw)-time))-0.1);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 376, 395, 395, 438], [440, 440, 477, 477, 621], [623, 623, 645, 645, 717], [719, 719, 745, 745, 958], [961, 961, 999, 999, 1038], [1040, 1040, 1060, 1060, 1309], [1311, 1311, 1334, 1334, 1585], [1587, 1587, 1616, 1616, 1661], [1663, 1663, 1700, 1700, 1769], [1771, 1771, 1827, 1827, 1858], [1860, 1860, 1915, 1915, 2759]], "test": "untested"}
{"id": "WsdSzM", "name": "shadetober #20 (tread)", "author": "percentcer", "description": "Inktober, but with shaders", "tags": ["inktober", "shadertober", "shadetober", "inktober2019"], "likes": 3, "viewed": 250, "published": "Public API", "date": "1572597306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*dot(q,b)+dot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat expImpulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat map (in vec2 p) {\n    float dist = 10.;\n    \n    const float spacer = .01;\n    const vec2 rhwid = vec2(.1,.2);\n    \n    const vec2 xoffs = vec2(rhwid.x + spacer, 0.);\n    for (int i = 0; i < 20; i++) {\n    vec2 yoffs = vec2(0., (rhwid.y + spacer) * float(i));\n        if (i % 2 == 0) {\n        \tdist = min(dist, sdRhombus(p + yoffs + xoffs, rhwid));\n\t\t\tdist = min(dist, sdRhombus(p + yoffs - xoffs, rhwid));\n        } else {\n        \tdist = min(dist, sdRhombus(p + yoffs, rhwid));\n        \tdist = min(dist, sdRhombus(p + yoffs + xoffs * 2., rhwid));\n\t\t\tdist = min(dist, sdRhombus(p + yoffs - xoffs * 2., rhwid));\n        }\n    }\n    \n    return dist;\n}\n\nmat2 rot(float a) {\n    return mat2(\n        cos(a), sin(a),\n        -sin(a), cos(a)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (\n        fragCoord * 2.)/iResolution.y;\n    uv.y -= 2.;\n    uv.x += .5;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.,.8,0.);\n    const vec3 GRAY = vec3(.1);\n    \n    for (int i = 0; i < 7; i++) {\n        uv.x -= .6;\n        \n        vec2 uv_r = rot(.1) * uv;\n        if (map(uv_r) < .0 && abs(uv_r.x) < .25) {\n            float pulse = expImpulse(1., fract(iTime - .1 * float(i) + uv_r.y * .1));\n            col = mix(col, GRAY, 1.-pulse);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 235], [237, 237, 275, 275, 321], [323, 323, 346, 346, 981], [983, 983, 1002, 1002, 1080], [1082, 1082, 1139, 1189, 1729]], "test": "untested"}
{"id": "wsdXWf", "name": "Flower Kaleidoscope", "author": "gbunny", "description": "Floral experiment.\nMouse around for extra kaleidoscope-y interaction", "tags": ["flower", "kaleidoscope"], "likes": 2, "viewed": 86, "published": "Public", "date": "1573072848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.14159265359\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvec3 Flower(vec2 st, vec3 color, float petalsCount){\n    float pct = 0.0;\n    st-= .5; //centering\n    float radius = length(st) * 3.5;\n    float a = atan(st.y,st.x);\n    float f= abs(cos(a*.5*petalsCount))+.4;\n    vec3 temp = vec3(1. - smoothstep(f,radius, .9));\n    temp += color;\n    return temp;\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    return _st;\n}\n\nfloat proceduralSplatter(vec2 st, float radius, float numCircles){\n    float pct = 0.;\n    st.x -= .5;\n    for (float i = 1.; i < numCircles; i++){\n        st.y -=(.3/ (i+1.));\n        pct +=smoothstep(radius * 1./i, radius * 1./i - .1, length(st));\n    }\n    return pct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    st.x *= aspect;\n    vec3 color = Flower(st, vec3(0.58,0.42,1.00), 5.);\n    color = mix(color, Flower(rotate2D(st, PI * -.1), vec3(1.00,0.53,0.39), 7.), cos(time / 2.));\n    st += rotate2D(st,iMouse.y /100.);\n    color = mix(color, Flower(rotate2D(st, PI * .1), vec3(0.70,1.00,0.73), 8.), sin(time));\n    st += rotate2D(st, iMouse.x /50.);\n    color = mix(color, Flower(rotate2D(st, PI * -.1), vec3(0.61,0.05,0.05), 6.), cos(time / 4.));\n    color = mix(color, Flower(rotate2D(st, PI * .5), vec3(0.00,0.85,0.85), 5.), sin(time / 4.));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 173, 173, 422], [424, 424, 462, 462, 570], [572, 572, 638, 638, 845], [847, 847, 903, 903, 1592]], "test": "untested"}
{"id": "WsG3z1", "name": "Cellular Motion", "author": "sgfx", "description": "Living cells", "tags": ["voronoi", "cells"], "likes": 12, "viewed": 251, "published": "Public", "date": "1572617293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\nuniform float fft;\nuniform float fftLowerFrc;\nuniform float fftUpperFrc;\n\n// Return a pseudo-random 0-1 vec2 for each floored value of the input\nvec2 rand2(vec2 p) {\n\t// Turn the vector into a integer id\n    p = floor(p);\n    \n    // Pseudo-randomness...\n    // from https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.01031, .01010, .00973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Triple-frequency sine wave, for variation on a vec2\nvec2 sin3(vec2 j, vec3 freq) {\n    j.x = sin(freq.x * j.x) + sin(freq.y * j.x) + sin(freq.z * j.x);\n    j.y = sin(freq.x * j.y) + sin(freq.y * j.y) + sin(freq.z * j.y);\n    j /= 3.0;\n    return j;\n}\n\nfloat smoothmin(float a, float b, float s) {\n    float j = clamp((b - a) / s + 0.5, 0.0, 1.0);\n    float k = j * (1. - j);\n    return a * j + (1. - j) * b - k * s * 0.5;\n}\n\nfloat smootthreshold(float a, float x, float s) {\n    return mix(a, 1.0, smoothstep(x - s, x + s, a));\n}\n\n// Cellular motion, it's a voronoi with some fancy motion\n// Voronoi is pretty much a random collection of points that\n// shows the distance from each point to the next-closest point\nfloat vor_cells(vec2 uv, float tile, float speed, float s, float threshold,\n                float edge_smooth, float seed) {\n    // Time offset, so the motion doesn't start from a grid layout\n    float t_offset = 9999.0;\n\n    // Coordinates for a 'grid' of cells\n    uv *= tile;\n\n    // -0.5 to 0.5 uv coordinate per grid cell\n    vec2 cell_uv = fract(uv) - 0.5;\n\n\t// Find the distance from the current cells's random\n    // position to the next closest\n    float min_dist = 100.0;\n    // Loop through the surrounding grid cells, normally you'd just go\n    // one grid cell in each direction, but because the motion is larger\n    // than just the current grid cell, we go two grid cells in each direction\n    for(float x = -2.0; x <= 2.0; x++) {\n        for(float y = -2.0; y <= 2.0; y++){\n            // Offset from the current grid cell\n            vec2 offset = vec2(x, y);\n            // Get a noise value for random cell motion\n            vec2 noise = rand2(uv + offset);\n            // Motion frequency for our triple-sine\n            vec3 freq = vec3(1.0, 2.67, 3.3676);\n            // Animate the cell position\n            vec2 pos = offset + sin3((noise * (iTime * speed + t_offset)), freq);\n\n            // Find distance to the offset cell\n            float size = sin((noise.x * noise.y * 398.67) + (iTime * speed) + t_offset) * .45 - smoothstep(0.2,1.,fftLowerFrc) * 0.5;\n            float dist = distance(cell_uv, pos) - size;\n            //min_dist = clamp(min(dist, min_dist), 0.0, 1.0);\n            min_dist = clamp(smoothmin(dist, min_dist, s), 0.0, 1.0);\n        }\n    }\n\t// Keep the distance of the closest cell\n    float cells = min_dist / 1.2;\n\n    cells = smootthreshold(cells, threshold, edge_smooth);\n    cells = pow(cells, 7.0);\n    cells = 1.0 - pow(1.0 - cells, 24.0);\n\n    return cells;\n}\n\n// Circular gradient to look like a lens vignette\nfloat vignette(vec2 uv, vec2 pos, float radius, float falloff) {\n    float v = dot(uv - pos, uv - pos);\n    v /= radius;\n    v = pow(v, falloff);\n    return 1.0 - v / radius;\n}\n\n// Turn a grayscale input into a 3 color gradient\nvec3 mix3(vec3 a, vec3 b, vec3 c, float x) {\n    vec3 m = mix(a, b, clamp(x * 2.0, 0.0, 1.0));\n    m = mix(m, c, clamp(((x - 0.5) * 2.0), 0.0, 1.0));\n    return m;\n}\n\nfloat quantize(float i, float steps) {\n    return floor(i * steps) / steps;\n}\n\n// Film grain, basically a simplified version of cells, with random negative\n// cell values, time is quantized to film framerate\nfloat filmgrain(vec2 uv, float scale, float var, float strength) {\n    uv *= scale;\n    vec2 cell_uv = fract(uv) - 0.5;\n    float qtime = quantize(iTime, 24.);\n\n    float grain = 1.0;\n    for(float x = -1.; x <= 1.; x++) {\n        for(float y = -1.; y <= 1.; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 noise = rand2(uv + offset);\n            vec2 pos = offset + sin(noise * qtime) * 0.5;\n            float size = sin((noise.x * noise.y * 654.387) + qtime) * var;\n            float d = 1.0 - clamp(distance(cell_uv, pos), 0.0, 1.0);\n            // randomize greyscale value\n            grain -= d * sin((noise.x * noise.y * 159.876) * qtime) * strength;\n        }\n    }\n    return grain;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    // Offset canvas UV by mouse position\n    vec2 mouse_uv = uv - iMouse.xy/iResolution.xy;\n\n    float fade = 0.0;\n    float tile = 4.5;\n    float speed = 0.1;\n\n    // Black canvas to start\n    vec3 color = vec3(0.0);\n\n    // Main cells\n    float cells = vor_cells(mouse_uv, tile, speed + smoothstep(0.,0.4,fftLowerFrc) * 0.0005, 0.2, 0.65, 0.02, 0.0);\n    // Second layer of cells for secondary motion and variation\n    float cells2 = vor_cells(mouse_uv * 0.666, tile, speed*1.5 + smoothstep(0.,0.5,fft) * 0.002, 0.75, 1.0, 0.5, 50.0);\n\t// Blend the cell layers together\n    //cells = mix(cells, cells2, 0.1);\n    cells += cells2 * 0.1 + smoothstep(0.1,0.5,fft)*0.075;\n    cells *= 1.0 - pow(uv.y,2.);\n\n    // Cell colorization\n    vec3 a = vec3(0.9, 0.8, 0.5);\n    vec3 b = vec3(0.7, 0.125, 0.13);\n    vec3 c = vec3(0.2, 0.1, 0.06);\n    color += mix3(a, b, c, 1.0 - cells);\n\n    // Apply vignette\n    float vig = vignette(uv, vec2(0.0), 2.25 - smoothstep(0.,1.,clamp(fftLowerFrc-.1,0.,1.)) * 0.1, 1.0);\n    color *= vig;\n\n    // Apply film grain\n    float grain = filmgrain(uv, 192., 24., 0.06 + fftUpperFrc*.1);\n    // Mask grain mostly to darker areas\n    grain = clamp((grain + cells * 0.75), 0.0, 1.0);\n    color *= grain;\n\n    // Flicker\n    float flicker = sin(iTime * 48.0);\n    flicker = 1.0 - (0.5 * flicker + 1.0) * 0.01;\n    color *= flicker;\n\n    // Output\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsG3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 168, 188, 226, 466], [468, 523, 553, 553, 721], [723, 723, 767, 767, 894], [896, 896, 945, 945, 1000], [1002, 1185, 1309, 1376, 3002], [3004, 3054, 3118, 3118, 3230], [3232, 3282, 3326, 3326, 3447], [3449, 3449, 3487, 3487, 3526], [3528, 3657, 3723, 3723, 4364], [4366, 4366, 4421, 4421, 5896]], "test": "untested"}
{"id": "WsGSRV", "name": "primera cruz00", "author": "jorge2017a1", "description": "primera cruz00", "tags": ["primeracruz00"], "likes": 1, "viewed": 28, "published": "Public", "date": "1574370934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n\n// For unions \n/*float unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}*/\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n\n\n//Coordinate positioning of each shape\nfloat GetDist(vec3 p) {\t\n\n \t\n    float planeDist = p.y;\n\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,0.0,5.0),vec3(1.0,7.00,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,5.0,5.0),vec3(3.3,0.5,1.0));  //horizontal\n    float bx2a = sdBox (p-vec3(0.,5.0,5.5),vec3(3.0,0.4,1.8));  //horizontal\n    \n    float bx3 = sdBox (p-vec3(0.,0.5,5.0),vec3(3.0,0.5,2.0));  //escalon2\n    float bx4 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.0,0.5,3.0)); //escalon1\n    \n    float bx5 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.5,0.25,4.0)); //escalon3 \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n  \n    float dif1, dif2, dif3;\n    \n    \n    d=1000.0;\n    d=min(d,planeDist);\n  \n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    \n    //intersectSDF\n    //unionSDF\n    //differenceSDF\n    \n   \n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos1 = vec3(1, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(0, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\n\nfloat GetLightv3(vec3 p) {\n    vec3 lightPos1 = vec3(-1, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(2, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    \n    vec3 lightPos3 = vec3(-2.5, 5.5, 0.5);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos3.xy += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l3 = normalize(lightPos3-p);\n    vec3 n3 = GetNormal(p);\n    \n    float dif3 = clamp(dot(n3, l3), 0., 1.);\n    float d3 = RayMarch(p+n3*SURF_DIST*2., l3);\n    if(d3<length(lightPos3-p)) dif3 *= .1;\n    \n    \n    return (dif1+dif2+dif3)/3.0;\n}\n\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n    \n    vec3 lightPos1 = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    vec3 lightPos2 =lpos;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(0.0, cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n    //vec3 ro = vec3(0, 1.0, 0);\n\n    vec3 ro = vec3(2.0+2.0*cos(iTime), 4.5, -4.0+4.0*cos(iTime));\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n    \n\n    float d = RayMarch(ro, rd);\n\n    vec3 p = (ro + rd * d );  //+texture(iChannel0, uv).x;\n\n    \n    float dif = GetLight(p);\n   \n    float dif3= GetLightv3(p);\n    \n \n    dif=dif3+dif;\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 86, 119, 119, 184], [187, 205, 241, 241, 310], [311, 326, 357, 357, 507], [508, 528, 564, 564, 651], [652, 668, 700, 728, 789], [793, 989, 1035, 1035, 1067], [1069, 1069, 1111, 1111, 1143], [1145, 1145, 1192, 1192, 1225], [1230, 1269, 1292, 1292, 2342], [2344, 2344, 2378, 2378, 2612], [2614, 2614, 2638, 2638, 2870], [2872, 2872, 2896, 2896, 3280], [3285, 3285, 3311, 3311, 4112], [4115, 4115, 4141, 4141, 5346], [5350, 5350, 5388, 5388, 6171], [6173, 6173, 6230, 6230, 6778]], "test": "untested"}
{"id": "wsGSRW", "name": "psychedelicfire", "author": "xdegtyarev", "description": "psychedelic", "tags": ["psychedelic"], "likes": 6, "viewed": 132, "published": "Public", "date": "1573512759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 uv = U / iResolution.xy * vec2(4,2) + vec2(-2,1);\n    float pi = 3.1415,\n        time = iTime * .1,\n           t = time*pi,\n           d = length(uv)-.3;\n\n    uv *= mat2( cos(t), -sin(t)*d*.5, sin(t), cos(t));\n\n    float  a = atan(uv.y, uv.x),\n          tt = fract(iTime) *.5 -.5,\n  timeWobble = cos(t+d) *.01*d;\n    float v = 0.;\n \n    for(float j = 0.; j<10.; j+=.5){\n        float q = j==0. ? tt+.5 : 1.;\n        for(float i = 0.; i<6.28; i += pi/8. ){\n            vec2 u = uv + vec2(sin(i),cos(i)) * (j-timeWobble+tt-.25) *q;\n            v += smoothstep( .0, .05* sin(time)*(1.-d)*time, \n                             length(u)- (smoothstep(0., 3.,j+tt)+timeWobble*3.) * q );\n        } \n    }\n    O = .5+ .5* sin(  pi/2.* ( mod(v+iMouse, 4.) + sin(vec4(10,5,-10,0)*time) )\n                     -(d*3.-a*3.) + t );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGSRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 866]], "test": "untested"}
{"id": "wsGSW3", "name": "Madeon Logo ", "author": "ReavenTehDerg", "description": "I love Madeon's music :D", "tags": ["texture", "animated", "squares"], "likes": 3, "viewed": 92, "published": "Public", "date": "1575129572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//aaStep by liqwidice\nfloat aaStep(float edge, float gradient)\n{\n    float halfPix = fwidth(gradient) / 2.0;\n    float low = edge - halfPix;\n    float hi  = edge + halfPix;\n    return clamp((gradient - low) / (hi - low), 0.0, 1.0);\n}\n\nmat2 rotMat(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    mat2 rotmat = mat2(c, -s, s, c);\n    \n    return rotmat;\n}\nfloat middleSquare(vec2 uv)\n{\n    return aaStep(dot(abs(uv), vec2(1, 1)), 0.27);\n}\n\nfloat sideThingy(vec2 uv, bool mirrored)\n{\n    if(mirrored)\n        uv *= -1.0;\n    \n    uv *= 1.2;\n    uv.x += abs(sin(iTime * 0.4) * 0.2) + 0.3;\n    float piece = middleSquare(uv);\n    \n    uv.x -= 0.20;\n    piece -= middleSquare(uv);\n\n    return clamp(piece, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 tex = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    float ms = middleSquare(vec2(uv));       \n    float sides = sideThingy(uv, false);\n    sides += sideThingy(vec2(uv.x, uv.y), true);\n    \n    ms += sides;\n    \n    vec3 result = mix(vec3(ms), tex, ms);\n    result = mix(result, vec3(1), 1.0 - ms);\n                \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 64, 64, 233], [235, 235, 261, 261, 381], [382, 382, 411, 411, 464], [466, 466, 508, 508, 740], [742, 742, 799, 799, 1242]], "test": "untested"}
{"id": "WsGSzD", "name": "Basic : Truchet", "author": "Gijs", "description": "Most basic truchet", "tags": ["2d", "tructet"], "likes": 3, "viewed": 104, "published": "Public", "date": "1574193708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash1( int n ) {\n    // integer hash copied from Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x7fffffff))/float(0x7fffffff);\n}\n\n//cross\nfloat tile1(vec2 uv){\n    float d = min(abs(uv.x),abs(uv.y));\n    return d;\n}\n\n//two circles\nfloat tile2(vec2 uv){\n    if(uv.y<-uv.x) uv.xy = -uv.xy;\n\tfloat d = abs(distance(uv,vec2(1,1))-1.);  \n    return d;\n}\n\n//rotation of tile2\nfloat tile3(vec2 uv){\n    return tile2(vec2(-uv.x,uv.y));\n}\n\nfloat truchet(vec2 p){\n    vec2  tile = floor(p);\n    float id   = tile.x*10000.+tile.y;\n\t      p   = (fract(p)-.5)*2.;\n   \n    float t = hash1(int(id));\n    float d = 1e20;\n    if(t<0.33){\n        d = tile1(p);\n    }else if(t<0.67){\n        d = tile2(p);\n    }else{\n        d = tile3(p);\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = cos(iTime*.5)*2.+3.;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y*zoom;\n    \n    float e = zoom*2./min(iResolution.x,iResolution.y);\n   \tvec3 col = vec3(0);\n    \n  \tfloat d = truchet(uv);\n    \n    col = vec3(smoothstep(e*5.,e,d));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 65, 198], [200, 208, 229, 229, 285], [287, 301, 322, 322, 418], [420, 440, 461, 461, 499], [501, 501, 523, 523, 816], [818, 818, 875, 875, 1170]], "test": "untested"}
{"id": "WsGSzt", "name": "Dynamic Space Rocks", "author": "dr2", "description": "Asteroid flythrough.\nUse the mouse; switch forward/backward views when mouse in small frame.", "tags": ["voronoi", "flight", "asteroid"], "likes": 18, "viewed": 417, "published": "Public API", "date": "1574682770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Dynamic Space Rocks\" by dr2 - 2019 \n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Asteroid flythrough\n// Use the mouse; switch forward/backward views when mouse in small frame.\n// Based on \"Asteroid Field\" with Voronoi displacements from \"Rainbow Cavern\".\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat, flyerMat;\nvec4 astV, astCs;\nvec3 bGrid, trkAx, trkAy, trkFx, trkFy, flPos, flyerPos, qHit, ltDir, cId, cHash;\nfloat tCur, dstFar, spd, szFacFl, astOcc;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a, g, w;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        g = vec3 (gx, gy, gz);\n        w = g + 0.7 * Hashv3v3 (ip + g) - fp;\n        a.z = dot (w, w);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nvoid AstState ()\n{\n  float s, r;\n  cHash = Hashv3v3 (cId);\n  if (cHash.x > astOcc) {\n    s = fract (64. * length (cHash));\n    s *= s;\n    r = 0.5 * bGrid.x * min (0.8 + 0.3 * cHash.x * (1. - s) * abs (sin (3. * pi * cHash.y * (1. - s))), 1.);\n    astV = vec4 ((r - 1.1 * (0.15 - 0.07 * s)) * vec3 (sin ((cHash.z * tCur + cHash.x) +\n       vec2 (0.5 * pi, 0.)), 0.), 0.15 - 0.07 * s);\n    astCs = vec4 (sin (2. * pi * (cHash.x + 0.09 * cHash.z * tCur) + vec2 (0.5 * pi, 0.)),\n       sin (2. * pi * (cHash.y + 0.11 * cHash.z * tCur) + vec2 (0.5 * pi, 0.)));\n  }\n}\n\nvec3 AstRot (vec3 p)\n{\n  p.xy = Rot2Cs (p.xy, astCs.xy);\n  p.zy = Rot2Cs (p.zy, astCs.zw);\n  return p;\n}\n\nvec3 AstRotT (vec3 p)\n{\n  p.zy = Rot2Cs (p.zy, vec2 (astCs.z, - astCs.w));\n  p.xy = Rot2Cs (p.xy, vec2 (astCs.x, - astCs.y));\n  return p;\n}\n\nvec3 AstCell (vec3 p)\n{\n  cId.xy = floor (p.xy / bGrid.xy);\n  p.z += 0.2 * spd * tCur * Hashfv2 (cId.xy) * smoothstep (6., 10., length (cId.xy));\n  cId.z = floor (p.z / bGrid.z);\n  return p;\n}\n\nfloat AstDf (vec3 p)\n{\n  float d;\n  d = PrRoundBoxDf (p, 0.6 * astV.w * (1. - 0.5 * cHash), 0.4 * astV.w);\n  if (d < 0.07) d -= 0.04 * VPoly ((8. + 2. * cHash.y) * p);\n  return 0.7 *  d;\n}\n\nfloat AstRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s, rdi;\n  float dHit, d, da, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 80; j ++) {\n    p = ro + dHit * rd;\n    p = AstCell (p);\n    if (cId != cIdP) {\n      AstState ();\n      cIdP = cId;\n    }\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = abs (Minv3 (s)) + eps;\n    if (cHash.x > astOcc && length (cId.xy - floor (TrackPath (bGrid.z * cId.z).xy / bGrid.xy)) >= 1.)\n       d = min (d, AstDf (AstRot (p - (bGrid * (cId + 0.5) + astV.xyz))));\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 AstNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.005, -0.005);\n  v = vec4 (- AstDf (p + e.xxx), AstDf (p + e.xyy), AstDf (p + e.yxy), AstDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 AstCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, p, col;\n  p = AstCell (ro);\n  AstState ();\n  p = AstRot (p - (bGrid * (cId + 0.5) + astV.xyz));\n  vn = AstNf (p);\n  vn = VaryNf (32. * (0.5 + 0.5 * cHash.x) * p, vn, 16. * (0.5 + 0.5 * cHash.y));\n  vn = AstRotT (vn);\n  col = HsvToRgb (vec3 (0.02 + 0.12 * cHash.x, 0.1 + 0.3 * cHash.y,\n     min (0.6 + 0.3 * cHash.z + 0.5 * Fbm3 (4. * p), 1.)));\n  col = col * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n     0.2 * vec3 (1.) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  return col;\n}\n\nfloat FlyerEngDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p = flyerMat * (p - flyerPos) / szFacFl;\n  q = p - vec3 (0., 0.3, -0.6);\n  q.xz = abs (q.xz) - vec2 (1.6, 1.3);\n  q.xy = Rot2D (q.xy, -32. * tCur);\n  d = max (PrCylDf (q, 0.4, 0.4), 0.05 - min (abs (q.x), abs (q.y)));\n  return szFacFl * d;\n}\n\nfloat FlyerEngRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = FlyerEngDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, h;\n  dMin = dstFar / szFacFl;\n  p = flyerMat * (p - flyerPos) / szFacFl;\n  q = p;\n  h = 0.5 - 0.05 * (q.z + 0.3) * (q.z + 0.3);\n  q.y -= h;\n  d = PrRoundBoxDf (q, vec3 (0.9 - 0.06 * (q.z + 0.5) * (q.z + 0.5), h, 2.7), 0.15);\n  q = p + vec3 (0., -0.3, 0.6);\n  qq = q;\n  qq.xz = abs (qq.xz) - vec2 (1.6, 1.3);\n  d = min (min (min (d, PrCylAnDf (qq, 0.44, 0.04 - 0.03 * (qq.z / 0.48) * (qq.z / 0.48), 0.48)),\n     PrCylDf (qq, 0.15 - 0.12 * (qq.z / 0.45) * (qq.z / 0.45), 0.45)),\n     PrRoundBoxDf (qq, vec3 (0.4, 0.01, 0.1), 0.01));\n  q = p;\n  q.y -= 0.3;\n  qq = q;\n  qq.z = abs (qq.z + 0.6) - 1.3;\n  d = SmoothMin (d, PrRoundBoxDf (qq, vec3 (1.15, 0.03 - 0.05 * abs (qq.z), 0.3), 0.01), 0.05);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (0.52, 0.5);\n  d = PrCapsDf (q, 0.6, 1.);\n  DMINQ (2);\n  return 0.7 * szFacFl * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- FlyerDf (p + e.xxx), FlyerDf (p + e.xyy), FlyerDf (p + e.yxy), FlyerDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4;\n  float ax;\n  col4 = vec4 (0.9, 1., 0.9, 0.3);\n  ax = abs (qHit.x);\n  if (idObj == 1) {\n    if (qHit.z > 2. && length (vec2 (ax - 0.2, qHit.y + 0.3)) < 0.12) {\n      if (length (vec2 (ax - 0.2, qHit.y + 0.3)) < 0.1) col4 = vec4 (1.1, 1.1, 0.8, -2.);\n      else col4 = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (qHit.z < -2. && length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.1) {\n      if (length (vec2 (abs (ax - 0.3) - 0.15, qHit.y + 0.1)) < 0.08)\n         col4 = vec4 (0.8 + 0.2 * sin (2. * pi * tCur), 0., 0., -2.);\n      else col4 = vec4 (0.5, 0.5, 0.7, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && length (vec2 (ax - 1.6, qHit.y)) < 0.2) {\n      col4 = vec4 (1., 0., 0., 0.3);\n    } else if (ax < 0.02 || qHit.z < -2.8 && mod (8. * qHit.x + 0.1, 1.) < 0.2 ||\n       qHit.z > 2.8 && mod (12. * qHit.y + 0.1, 1.) < 0.2 ||\n       abs (qHit.z + 1.3) < 0.9 && ax < 0.8 && mod (6. * qHit.x + 0.1, 1.) < 0.15 ||\n       abs (qHit.z + 0.7) < 0.5 && abs (qHit.y - 0.2) < 0.3 && mod (12. * qHit.y + 0.1, 1.) < 0.15) {\n      col4 = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (abs (abs (qHit.z + 0.15) - 1.3) < 0.1 && ax > 1.12) {\n      col4 = vec4 (0.6, 0.6, 0.6, 0.3);\n    } else if (length (vec2 (abs (qHit.z + 0.6) - 1.3, ax - 1.6)) < 0.1 && abs (qHit.y) > 0.44) {\n       col4 = mix (0.8 * col4, vec4 (0., 1., 0., -2.), step (0.5, mod (0.5 * tCur, 1.)));\n    }\n  } else if (idObj == 2) {\n    if (min (ax, abs (qHit.z - 1.)) > 0.03) col4 = vec4 (0.1, 0.1, 0.2, -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstAst, dstFlyer, dstEng, refFac;\n  dstEng = FlyerEngRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (dstFlyer < dstEng) dstEng = dstFar;\n  dstAst = AstRay (ro, rd);\n  col = vec3 (0.1, 0.07, 0.03);\n  if (min (dstFlyer, dstAst) < dstFar) {\n    if (dstFlyer < dstAst) {\n      ro += dstFlyer * rd;\n      vn = FlyerNf (ro);\n      col4 = FlyerCol ();\n      col = col4.rgb;\n      refFac = 0.;\n      if (col4.a >= 0.) {\n        col = col * (0.2 + 0.1 * max (dot (vn, - ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.)) +\n           col4.a *  pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n        refFac = 0.3;\n      } else if (col4.a == -1.) refFac = 0.7;\n      if (refFac > 0.) {\n        rd = reflect (rd, vn);\n        ro += 0.01 * rd;\n        dstAst = AstRay (ro, rd);\n        ro += dstAst * rd;\n        col = mix (col, AstCol (ro, rd), refFac);\n      }\n    } else if (dstAst < dstFar) {\n      ro += dstAst * rd;\n      col = AstCol (ro, rd);\n    }\n  }\n  col = mix (vec3 (0.1, 0.07, 0.03), col, \n     exp2 (- 10. * max (min (min (dstFlyer, dstAst), dstFar) / dstFar - 0.7, 0.)));\n  if (dstEng < min (dstAst, dstFar)) col = mix (col, vec3 (0.4, 0.6, 1.) *\n     (0.8 + 0.4 * Fbm1 (32. * tCur)), 0.7);\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = - asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl = clamp (rl - 3. * TrackAcc (s).x, -0.4 * pi, 0.4 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, ori, ca, sa;\n  vec2 canvas, uv, mMid, ut, mSize;\n  float el, az, rl, zmFac, asp, vuDir;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (1. / mSize.y, 1. / mSize.y - 1.) * mSize * vec2 (-1. + 1./6., 1.);\n  ut = abs (uv - mMid) - mSize;\n  vuDir = 1.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuDir = -1.;\n  }\n  szFacFl = 0.005;\n  spd = 1.;\n  astOcc = 0.5;\n  tCur = mod (tCur, 10800.) + 10.;\n  az = 0.;\n  el = 0.;\n  rl = 0.;\n  if (mPtr.z > 0.) {\n    if (mPtr.x > -0.5 + 1./6. || mPtr.y < 0.5 - 1./6.) {\n      az = 2. * pi * mPtr.x;\n      el = 0.6 * pi * mPtr.y;\n    } else vuDir *= -1.;\n  }\n  el += 0.005 * pi * (Fbm1 (0.1 * tCur) - 0.5);\n  az += 0.005 * pi * (Fbm1 (0.1 * tCur + 1.) - 0.5);\n  rl += 0.02 * pi * (Fbm1 (0.3 * tCur + 2.) - 0.5);\n  ori = vec3 (el, az, rl);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  bGrid = vec3 (1.);\n  trkAx = vec3 (0.7, 0.8, 1.2);\n  trkAy = vec3 (1., 1.1, 0.9);\n  trkFx = vec3 (0.43, 0.33, 0.23);\n  trkFy = vec3 (0.41, 0.31, 0.12);\n  FlyerPM (spd * tCur + ((vuDir > 0.) ? 0.5 + 0.45 * sin (0.2 * tCur) :\n     - (0.25 + 0.2 * sin (0.2 * tCur))), 0.03 * pi * (Fbm1 (1.3 * tCur) - 0.5), 0.);\n  flyerPos = flPos;\n  flyerMat = flMat;\n  FlyerPM (spd * tCur, 0., vuDir);\n  ro = flPos;\n  zmFac = 3.;\n  rd = normalize (vec3 (uv, zmFac));\n  rd = rd * flMat;\n  rd = vuMat * rd;\n  ltDir = normalize (vec3 (0., 1., -1.));\n  ltDir.xz = Rot2D (ltDir.xz, 0.2 * pi * sin (0.1 * pi * tCur));\n  ltDir.yz = Rot2D (ltDir.yz, 0.1 * pi * sin (0.06 * pi * tCur));\n  if (vuDir < 0.) ltDir *= -1.;\n  dstFar = 25.;\n  col = ShowScene (ro, rd);\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n     col = vec3 (0.1, 0.5, 0.1);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec3 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGSzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[128, 1046, 1072, 1072, 1153], [1155, 1155, 1180, 1180, 1287], [1289, 1289, 1314, 1314, 1437], [1439, 1439, 1461, 1461, 1891], [1893, 1893, 1911, 1911, 2455], [2457, 2457, 2479, 2479, 2561], [2563, 2563, 2586, 2586, 2702], [2704, 2704, 2727, 2727, 2896], [2898, 2898, 2920, 2920, 3086], [3088, 3088, 3121, 3121, 3850], [3852, 3852, 3873, 3873, 4063], [4065, 4065, 4097, 4097, 4636], [4638, 4638, 4665, 4665, 4930], [4932, 4932, 4970, 4970, 5151], [5153, 5153, 5177, 5177, 6026], [6028, 6028, 6063, 6063, 6242], [6244, 6244, 6267, 6267, 6467], [6469, 6469, 6487, 6487, 8006], [8008, 8008, 8043, 8043, 9311], [9313, 9313, 9357, 9357, 9879], [9881, 9881, 9934, 9934, 12099], [12101, 12101, 12147, 12147, 12194], [12196, 12196, 12238, 12238, 12289], [12291, 12291, 12344, 12344, 12405], [12407, 12407, 12450, 12450, 12523], [12525, 12525, 12570, 12570, 12673], [12675, 12675, 12732, 12732, 12815], [12817, 12817, 12839, 12839, 12877], [12879, 12879, 12909, 12909, 13022], [13024, 13024, 13055, 13055, 13119], [13121, 13121, 13145, 13145, 13281], [13315, 13315, 13339, 13339, 13399], [13401, 13401, 13425, 13425, 13478], [13480, 13480, 13504, 13504, 13634], [13636, 13636, 13660, 13660, 13853], [13855, 13855, 13879, 13879, 14099], [14101, 14101, 14126, 14126, 14272], [14274, 14274, 14299, 14299, 14485], [14487, 14487, 14512, 14512, 14737], [14739, 14739, 14761, 14761, 14915], [14917, 14917, 14938, 14938, 15093], [15095, 15095, 15124, 15124, 15336], [15338, 15338, 15377, 15377, 15557]], "test": "untested"}
{"id": "WsGSzw", "name": "Oban Racers", "author": "sametaylak", "description": "Oban Racers", "tags": ["oban", "racers"], "likes": 1, "viewed": 83, "published": "Public", "date": "1573582487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat cylinder(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 ap = abs(p) - s;\n    return length(max(vec3(0.0), ap)) + min(0.0, max(ap.x, max(ap.y, ap.z)));\n}\n\nfloat roundBox(vec3 p, vec3 s, float r)\n{\n  vec3 rb = abs(p) - s;\n  return length(max(rb, 0.0)) + min(max(rb.x, max(rb.y, rb.z)), 0.0) - r;\n}\n\nmat2 rot(float a)\n{\n\tfloat ca = cos(a);\n    float sa = sin(a);\n\treturn mat2(ca, sa, -sa, ca);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat ship(vec3 p) {\n    float s = sphere(p, 0.4);\n    float b = max(cylinder(p.yz + vec2(0.1, 0.0), 0.2), abs(p.x) - 0.8);\n    float d = min(s, b);\n    \n    float s2 = sphere(p + vec3(1.0, 0.1, 0.0), 0.3);\n    float s3 = sphere(p + vec3(-1.0, 0.1, 0.0), 0.3);\n    \n    float sideSpheres = min(s2, s3);\n    d = min(d, sideSpheres);\n\n    float c1 = roundBox(p + vec3(1.0, 0.1, -0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c2 = roundBox(p + vec3(1.0, -0.10, -1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c1, c2, 0.01));\n    \n    float c3 = roundBox(p + vec3(-1.0, 0.1, -0.8), vec3(0.11, 0.1, 0.8), 0.075);\n    float c4 = roundBox(p + vec3(-1.0, -0.10, -1.2), vec3(0.1, 0.3, 0.4), 0.075);\n    d = min(d, smin(c3, c4, 0.01));\n    \n    return d;\n}\n\nvec3 tunnel(vec3 p) {\n\tvec3 off = vec3(0.0);\n    off.x += sin(p.z * 0.3);\n    off.y += cos(p.z * 0.5) * 0.1;\n    return off;\n}\n\nfloat map(in vec3 p)\n{\n    p += tunnel(p);\n\n    vec3 p1 = p;\n    float m = iTime * 4.0;\n    p1.z -= m;\n    \n    p1.zy *= rot(0.1);\n    float t = clamp(sin(-p.z * 0.3), -1.0, 1.0) * 0.35;\n   \tp1.yx *= mat2(1.0, t, -t, 1.0);\n    float s = ship(p1);\n\n    \n    vec3 bp = p;\n    bp.z = fract(bp.z / 2.0 - 0.5) - 0.5;\n    float bPlane = box(bp + vec3(0.0, -0.75, 0.0), vec3(2.0, 0.2, 1.0));\n    \n    vec3 sp = p;\n    sp.xy *= rot(1.0);\n    sp.z = fract(sp.z / 0.0 - 0.5);\n    float rPlane = box(sp + vec3(1.4, -2.0, 1.0), vec3(1.0, 0.2, 1.0));\n    \n    vec3 sp2 = p;\n    sp2.yx *= rot(1.0);\n    sp2.z = fract(sp2.z / 0.0 - 0.5);\n    float lPlane = box(sp2 + vec3(-1.4, -2.0, 1.0), vec3(1.0, 0.2, 1.0));\n    \n    return min(s, min(bPlane, min(rPlane, lPlane)));\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 off = vec2(0.01, 0.0);\n    return normalize(map(p) - vec3(map(p - off.xyy), map(p - off.yxy), map(p - off.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 s = vec3(0.0, -2.0, -4.0);\n    vec3 t = vec3(0.0, 0.0, 3.0);\n    \n    float m = iTime * 4.0;\n    s.z += m;\n    t.z += m;\n    \n    s -= tunnel(s);\n    vec3 offT = tunnel(t);\n    t -= offT;\n    \n    vec3 cz = normalize(t - s);\n    vec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0) - offT * 0.2));\n    vec3 cy = normalize(cross(cz, cx));\n    \n    vec3 r = normalize(cx * uv.x + cy * uv.y + cz);\n    \n    vec3 col = vec3(0.0);\n    vec3 l = normalize(vec3(0.0, -1.0, 0.0));\n    \n    vec3 p = s;\n    for(int i = 0; i < 100; ++i)\n    {\n    \tfloat d = map(p);\n        if(d < 0.001) {\n            vec3 n = norm(p);\n            float f = pow(1.0 - dot(n, -r), 1.0);\n            col += max(0.0, dot(n, l));\n        \n            break;\n        }\n        if(d > 100.0) break;\n        p += d * r;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 56], [58, 58, 91, 91, 116], [118, 118, 145, 145, 248], [250, 250, 291, 291, 391], [393, 393, 412, 412, 488], [490, 490, 531, 531, 625], [627, 627, 647, 647, 1381], [1383, 1383, 1404, 1404, 1509], [1511, 1511, 1533, 1533, 2267], [2269, 2269, 2288, 2288, 2410], [2412, 2412, 2469, 2469, 3456]], "test": "untested"}
{"id": "wsGXDh", "name": "Twitch: Two Spheres and a Torus", "author": "blackle", "description": "fiddling with primitives and fake global illumination/AO. the title is a topology joke :3\n\ntwitch recording: https://www.twitch.tv/videos/508931099", "tags": ["liveshader"], "likes": 13, "viewed": 545, "published": "Public API", "date": "1573871696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p , vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x);int y = FK(p.y);\n  return float((x*x+y)*(y*y-x)-x)/2.147e9;\n}\n\nvec2 linedist(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  float s = sign(dot(vec2(-pa.y,pa.x),b-a));\n  float d = distance(p, mix(a,b,clamp(k,0.,1.)));\n  return vec2(d,s);\n}\n\nfloat triangle(vec2 p, vec2 dim) {\n  vec2 a = vec2(0,dim.y);\n  vec2 b = vec2(dim.x,-dim.y);\n  vec2 ldx = min(linedist(p, a, b), linedist(p, b, vec2(-b.x,b.y)));\n  return -ldx.x*ldx.y;\n}\n\nfloat torus(vec3 p, vec2 di) {\n  vec2 crd = vec2(length(p.xy), p.z);\n  return length(crd-vec2(di.x,0)) - di.y;\n}\n\nfloat cylinder(vec3 p, vec2 di) {\n  vec2 crd = vec2(length(p.xy), p.z);\n  crd.y = abs(crd.y)-di.y;\n  crd.x -= di.x;\n  \n  float sg = sign(crd.x)+sign(crd.y);\n  return sg == 2. ? length(crd) : max(crd.x,crd.y);\n}\n\nfloat cone(vec3 p, vec2 di) {\n  vec2 crd = vec2(length(p.xy), p.z);\n  return triangle(crd, di);\n}\n\nfloat scene(vec3 p) {\n  vec3 tor = p;\n  tor = erot(tor, vec3(0,0,1), iTime);\n  tor = erot(tor, vec3(0,1,0), 0.6);\n  \n  vec3 cyl = p - vec3(0,-1,0);\n  cyl = erot(cyl, vec3(0,1,0), iTime);\n  \n  vec3 con = p - vec3(0,1,0);\n  con = erot(con, vec3(0,1,0), -iTime);\n  \n  float best = cylinder(cyl, vec2(0.3, 0.8))-0.01;\n  best = min(best, torus(tor, vec2(0.8,0.2)));\n  best = min(best, cone(con, vec2(0.5,0.7)))-0.01;\n  return min(best, p.z+0.9);\n}\n\nbool flor(vec3 cam, vec3 init, inout vec3 inter) {\n  vec3 flooror = vec3(0,0,-0.9);\n  vec3 floornor = vec3(0,0,1);\n  float d = dot(cam, vec3(0,0,1));\n  if (d > 0.) return false;\n  \n  float t = dot(flooror-init, floornor)/d;\n  inter = t*cam+init;\n  return true;\n}\n\nmat3 eps = mat3(0.001);\n#define AP(f,k) vec3(f(k[0]),f(k[1]),f(k[2]))\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-eps;\n  return normalize(scene(p) - AP(scene, k));\n}\n\nvec3 shade(float d) {\n  float str = cos(d*200.+3.1415)*0.2+0.8 * pow((exp(0.)-exp(-abs(d))), 0.3);\n  return d > 0. ? vec3(1,0.5,0)*str : vec3(0,0.5,1)*str;\n}\n\nfloat skycol(vec3 angl) {\n  return sqrt(max(angl.z,0.))*0.5+0.5;\n}\n\nfloat skyshade(vec3 norm) {\n  float d = pow(norm.z+0.3,2.)*pow(norm.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n  return sqrt(sqrt(d))*0.8+0.2;\n}\n\nfloat ao(vec3 p, vec3 n, float sc) {\n  float d1 = 0.001;\n  float d2 = scene(p+n*sc);\n  return sqrt(((d2-d1)/sc)*0.5+0.5);\n}\n\nfloat comp(float p) {\n  //return p;\n  return pow(abs(p),5.)*sign(p);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(1.4, uv));\n  vec3 init = vec3(-4.,0.,0.);\n  bool hit = false;\n  vec3 p = init;\n  for (int i = 0; i < 150; i++) {\n    float dist = scene(p);\n    if ( abs(dist) < 0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) break;\n    p+=cam*dist;\n  }\n  vec3 inter;\n  if (flor(cam, init, inter)) {\n    if (distance(inter, init) < distance(init, p) || !hit) {hit=true; p = inter;}\n  }\n  float noise = comp(hash(uv*iTime));\n  if (!hit) {\n    fragColor.xyz = vec3(skycol(cam)) + noise*0.05;\n    return;\n  }\n  vec3 n = norm(p);\n  float fog = exp(-distance(init,p)*0.03)/exp(0.)*0.4+0.6;\n  float aoo = pow(ao(p, n, 0.1)*ao(p, n, 0.2)*ao(p, n, 0.33)*ao(p, n, 0.66)*ao(p, n, 1.),1./5.);\n  fragColor.xyz = vec3(skyshade(n)*0.8*aoo)*fog;\n  fragColor.xyz += noise*0.05;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXDh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 194, 233, 233, 297], [354, 354, 374, 374, 454], [456, 456, 495, 495, 668], [670, 670, 704, 704, 855], [857, 857, 887, 887, 969], [971, 971, 1004, 1004, 1181], [1183, 1183, 1212, 1212, 1280], [1282, 1282, 1303, 1303, 1724], [1726, 1726, 1776, 1776, 1988], [2060, 2060, 2079, 2079, 2154], [2156, 2156, 2177, 2177, 2313], [2315, 2315, 2340, 2340, 2381], [2383, 2383, 2410, 2410, 2519], [2521, 2521, 2557, 2557, 2644], [2646, 2646, 2667, 2681, 2719], [2721, 2721, 2778, 2778, 3707]], "test": "untested"}
{"id": "WsGXDy", "name": "Perlin noise vs interpolation 3", "author": "FabriceNeyret2", "description": "flownoise variant.\n\nIf no scrambling matrix is used between scales (i.e. original Perlin noise), the noise is exactly 0 on grid vertex.\nThis can be used to stochastically interpolate a mesh or polyline, still passing through control points (mouseY).", "tags": ["procedural", "2d", "noise", "perlin", "gradient", "lightning", "flownoise"], "likes": 3, "viewed": 428, "published": "Public API", "date": "1574842388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// flownoise variant of https://shadertoy.com/view/WdGXWG\n// curve variant of 2D https://shadertoy.com/view/wdKXzd\n\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z;\nvec2 hash( vec2 x ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(x.x+x.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = 5.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale\n    const vec2 k = vec2( .3183099, .3678794 );\n    x = x*k + k.yx;\n    return ( -1. + 2.*fract( 16. * k*fract( x.x*x.y*(x.x+x.y)) ) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 p )  //fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 7; i++, s /= 2. ) { _z = s; // for flownoise\n        v += s*noise( p ); p *= m;\n    }\n    return v;\n}\n\n// -----------------------------------------------\n\n#define S(v) smoothstep( pix, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u -.5*R ) / R.y * 2.,\n         M = iMouse.xy; if (M!=vec2(0)) M = ( M -.5*R ) / R.y * 2.;\n    O -= O;\n    float pix = 3./R.y,\n          y = perlin(vec2(U.x,0)) + U.x*M.y;\n    \n    O += S(abs(y - U.y));\n\n    O.g += S(length(U)-.03);\n    O.r += S(length(U-vec2(1,M.y))-.03);\n    O.b += S(length(U+vec2(1,M.y))-.03);\n  //O.b += S(abs(U.y - U.x*M.y));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 196, 218, 282, 852], [854, 854, 877, 877, 1106], [1108, 1108, 1149, 1149, 1357], [1359, 1450, 1488, 1488, 1883]], "test": "untested"}
{"id": "WsGXRm", "name": "stripe snake tunnel", "author": "thisisthais", "description": "idek", "tags": ["noise", "tbos"], "likes": 2, "viewed": 35, "published": "Public", "date": "1573680525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nvec2 random2D(vec2 st){\n  st=vec2(dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)));\n  return-1.+2.*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st){\n  vec2 i=floor(st);\n  vec2 f=fract(st);\n  // mixing function\n  vec2 u=f*f*(3.-2.*f);\n  \n  return mix(mix(dot(random2D(i+vec2(0.,0.)),f-vec2(0.,0.)),\n  dot(random2D(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n  mix(dot(random2D(i+vec2(0.,1.)),f-vec2(0.,1.)),\n  dot(random2D(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n}\n\nfloat circle(in vec2 _st,in float _radius){\n  vec2 l=_st-vec2(.5);\n  return 1.-smoothstep(_radius-(_radius*.01),\n  _radius+(_radius*.01),\n  dot(l,l)*4.);\n}\n\nfloat shape(vec2 st,float radius){\n  st=st-vec2(.5);\n  float r=length(st)*2.;\n  float a=atan(st.y,st.x);\n  float m=abs(mod(2.*iTime,2.*PI)-PI)/a*2.2;\n  float f=radius;\n  \n  // stripeys, where they coming from, idk\n  m+=noise(st+iTime*.3)*50.;\n  st-=.9;\n  m+=noise(st+iTime*.3)*50.;\n  st.y+=.4;\n  m+=noise(st+iTime*.3)*50.;\n  \n  f+=sin(a*100.)*noise(st+iTime*.2)*.1;\n  f+=(sin(a*100.)*.1*pow(m,2.));\n  return smoothstep(f,f+.007,r);\n}\n\nfloat shapeBorder(vec2 st,float radius,float width){\n  return shape(st,radius)-shape(st,radius-width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st=fragCoord.xy/iResolution.xy;\n  st.y*=0.5;\n  vec3 color=vec3(0.);\n  color=vec3(shape(st,.5));\n  color+=circle(st,.005*(sin(iTime)+1.1));\n  \n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 58, 58, 169], [171, 256, 277, 277, 585], [587, 587, 630, 630, 742], [744, 744, 778, 778, 1177], [1179, 1179, 1231, 1231, 1283], [1285, 1285, 1341, 1341, 1520]], "test": "untested"}
{"id": "wsGXRR", "name": "Compulsive Eye", "author": "andremichelle", "description": "The obligatory eyeball shader.", "tags": ["eye", "eyeball"], "likes": 15, "viewed": 459, "published": "Public API", "date": "1573217233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n// Tileable Noise > https://www.shadertoy.com/view/4dlGW2\n\nfloat Hash(in vec2 p, in float scale) {\n\treturn fract(sin(dot(mod(p, scale), vec2(27.16898, 38.90563))) * 5151.5473453);\n}\n\nfloat Noise(in vec2 p, in float scale ) {\n\tvec2 f;\n\tp *= scale;\n\tf = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(Hash(p, scale),\n\t\t\tHash(p + vec2(1.0, 0.0), scale), f.x),\n\t\t\tmix(Hash(p + vec2(0.0, 1.0), scale),\n\t\t\tHash(p + vec2(1.0, 1.0), scale), f.x), f.y);\n}\n\nfloat fBm(in vec2 p) {\n\tfloat f = 0.0;\n\tfloat scale = 10.;\n    p = mod(p, scale);\n\tfloat amp   = .6;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += Noise(p, scale) * amp;\n\t\tamp *= .5;\n\t\tscale *= 2.;\n\t}\n\treturn min(f, 1.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdPie( in vec2 p, in vec2 c, in float r ) {\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r));\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb ) {\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec4 over( in vec4 a, in vec4 b ) {\n    return mix(a, b, 1.-a.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*2.;\n    float l = length(uv);\n    vec4 col = vec4(.04,.22, .34, 1.);\n    if( l < .86) {\n        vec3 main = vec3(0);\n        float a = atan(uv.y, uv.x);\n        float anim = sin(iTime*PI*.3)*.04;\n        main += vec3(.1, .7, 1.) * smoothstep(.0, .99, fBm(vec2(a/PI*09.+sin(l*29.+a*11.)*.06, l*(2.00+anim*2.))))*.9;\n        main += vec3(.0, 1., .6) * smoothstep(.5, .70, fBm(vec2(a/PI*13.+sin(l*29.+a*11.)*.10, l*(1.50+anim))))*.3;\n        main += vec3(.4, .9, .9) * smoothstep(.2, .96, fBm(vec2(a/PI*11.+sin(l*11.+a*17.)*.11, l*(1.50+anim))))*.3;\n        float ta = PI*.3;\n        float tb = PI-2.5;\n        float bulge = smoothstep(.3, .0, abs(l-.5));\n        float reflection = smoothstep(.07, .0, sdArc(uv,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), .52, .01));\n        col = over(vec4(main*.8 + bulge*.2 + reflection*.2, smoothstep(.14, 0.001, l-.69)), col); // iris\n        col = over(vec4(vec3(.8,.5,.14), smoothstep(.0, .97, fBm(vec2(a/PI*2., l+anim))*(sin(PI+min(l,PI*.25)*PI*4.)))*.7), col); // iris brown blotch\n        col = over(vec4(vec3(.0), smoothstep(.16, .02-anim, l-.21)), col); // pupil black\n        col = over(vec4(vec3(.96, .97, .99), smoothstep(.024, .0, length(uv-vec2(-.06,.13))-.04-anim*.02)*.9), col); // pupil reflection\n    \tcol = over(vec4(vec3(.96, .97, .99)*.2, smoothstep(.01, .0, length(uv-vec2(.07,-.14))-.01)), col); // pupil reflection tiny\n    }\n    col = over(vec4(vec3(.95,.9, .88), smoothstep(-.04, .01, l-.83)), col); // eye skin\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 79, 118, 118, 201], [203, 203, 244, 244, 491], [493, 493, 515, 515, 709], [711, 791, 840, 840, 983], [985, 985, 1060, 1060, 1244], [1246, 1246, 1281, 1281, 1313], [1315, 1315, 1372, 1372, 2927]], "test": "untested"}
{"id": "wsGXWK", "name": "大龙猫 - XWing Missile HUD", "author": "totetmatt", "description": "Use the force Luke.", "tags": ["starwars"], "likes": 6, "viewed": 353, "published": "Public API", "date": "1575126965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n\nmat2 r(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 N(float angle) {return vec2(sin(angle),cos(angle));}\n#define tempo iTime/2.\n\nfloat line(vec2 uv,float offset) {\n     \n    float p  = abs(uv.y)*2.;\n\n    return smoothstep(.003,.001,length( (uv+vec2(0.,fract(offset+ 2.*iTime*.25)*.5)) - vec2(clamp(uv.x,-0.5*p,0.5*p),0.)));\n}\n\nfloat frame(vec2 uv) {\n    vec2 uuv = uv ;\n    uuv.y = -uuv.y;\n   return \n   max(\n        max(\n            max(\n                smoothstep(.003,.001,length( (uv  - clamp(uv.x,-0.5,0.5)))),\n                smoothstep(.003,.001,length( (uuv - clamp(uv.x,-0.5,0.5))))\n            ),\n            max(\n                smoothstep(.003,.001,length( (uv - vec2(clamp(uv.x,-0.5,0.5),uv.x*.5)))),\n                smoothstep(.003,.001,length( (uuv - vec2(clamp(uv.x,-0.5,0.5),uv.x*.5))))\n            )),\n         max(\n            smoothstep(.003,.001,length( (uv - vec2(clamp(uv.x,-0.5,0.5),uv.x*.2)))),\n            smoothstep(.003,.001,length( (uuv - vec2(clamp(uv.x,-0.5,0.5),uv.x*.2))))\n        )\n);\n   \n}\nfloat redline(vec2 uv) {\n    uv.y*=mod(iTime,10.),\n    uv= abs(uv);\n    return smoothstep(.02,.010,length( (uv  - vec2(clamp(uv.x,-1.5,1.5),.0+.1))));\n\n}\nfloat unit(vec2 uv,float offset) {\n\n   return max(line(-uv.yx,offset),max(line(uv.yx,offset),line(uv,offset)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n   vec3 col =  vec3(0);\n   float d = max(unit(uv,0.75),max(unit(uv,0.25),max(unit(uv,0.),unit(uv,0.5))));\n   d += frame(uv);\ncol.r = redline(uv.yx);\n   col.rg += d;\n  \n\n    fragColor = vec4( \n        col,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 98, 98, 142], [144, 144, 165, 165, 201], [226, 226, 260, 260, 422], [424, 424, 446, 446, 1121], [1122, 1122, 1146, 1146, 1275], [1276, 1276, 1310, 1310, 1389], [1390, 1390, 1445, 1445, 1728]], "test": "untested"}
{"id": "wsGXWm", "name": "Stereographic projection", "author": "tomoe", "description": "The sphere without the top point is projected onto the complex plane. The deformation is given by moebius transformation.", "tags": ["raymarching", "moebiustransformation", "complexfunction"], "likes": 8, "viewed": 393, "published": "Public API", "date": "1574165972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-2\n#define INFTY 1e6\n\n// complex numbers\nconst vec2 c1 = vec2(1.0, 0.0); //1\nconst vec2 c0 = vec2(0.0); //0\n\nconst float sphereSize = 1.0;\n\n// coordinate change \nvec2 xy2pol(vec2 z) {   //(Re(z),Im(z))->(arg,rad)\n    return vec2(atan(z.x, z.y), length(z));\n}\nvec2 pol2xy(vec2 z) {   //(arg,rad)->(Re(z),Im(z))\n    return vec2(z.y * cos(z.x), z.y * sin(z.x));\n}\n\n// operations of complex numbers\nvec2 cMult(vec2 z, vec2 w) {    //z*w\n    return vec2(z.x * w.x - z.y * w.y, z.y * w.x + z.x * w.y);\n}\nvec2 cPow(vec2 z, float n) {    //z^n\n    z = xy2pol(z);\n    z = vec2(n * z.x, pow(z.y, n));\n    return pol2xy(z);\n}\nvec2 cConj(vec2 z) {    //bar{z}\n    return vec2(z.x, - z.y);\n}\nvec2 cInv(vec2 z) { //z^{-1}\n    return (1.0 / pow(length(z), 2.0)) * cConj(z);\n}\n\n// geometry\nfloat sphereSDF(vec3 p) {\n    return length(p) - sphereSize ;\n}\nfloat planeSDF(vec3 p) {\n    return abs(p.y);\n}\nfloat sceneSDF(vec3 p) {\n    return min(planeSDF(p), sphereSDF(p));\n}\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nfloat hitSphere(vec3 camPos, vec3 ray) {\n    return length(camPos) * sin(getAngle( - camPos, ray)) - sphereSize;\n}\nfloat hitPlane(vec3 camPos, vec3 ray) {\n    return dot(vec3(0.0, 1.0, 0.0), ray);\n}\nfloat hitScene(vec3 camPos, vec3 ray) {\n    return min(hitPlane(camPos, ray), hitSphere(camPos, ray));\n}\nfloat getDist2Plane(vec3 camPos, vec3 ray) {\n    float ang = getAngle(vec3(0.0, - 1.0, 0.0), ray);\n    float dist = abs(camPos.y);\n    if (hitPlane(camPos, ray) < 0.0) {\n        return dist / cos(ang);\n    } else {\n        return INFTY;\n    }\n}\nfloat getDist2Sphere(vec3 camPos, vec3 ray) {\n    float ang = getAngle( - camPos, ray);\n    float dist = length( - camPos);\n    if (hitSphere(camPos, ray) < 0.0) {\n        return dist * cos(ang) - sqrt(pow(dist * cos(ang), 2.0) - pow(dist, 2.0) + pow(sphereSize, 2.0));\n    } else {\n        return INFTY;\n    }\n}\nfloat getDist2Scene(vec3 camPos, vec3 ray) {\n    return min(getDist2Plane(camPos, ray), getDist2Sphere(camPos, ray));\n}\nvec3 getNormal(vec3 p) {\n    float d = EPSILON;\n    return normalize(vec3(\n        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p),\n        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p),\n        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p)\n    ));\n}\nmat3 rotX(float theta) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(theta), cos(theta),\n        0.0, - cos(theta), sin(theta)\n    );\n}\nmat3 rotY(float theta) {\n    return mat3(\n        sin(theta), 0.0, cos(theta),\n        0.0, 1.0, 0.0,\n        - cos(theta), 0.0, sin(theta)\n    );\n}\nfloat fct(vec2 z) {    \n    return pow(cos(z.x * PI), 2.0) + pow(sin(z.y * PI), 2.0);\n}\n// fct(x+iy)=cos^2(x*PI)+sin^2(y*PI)\n// cases where 1<value<2\n// 0<x<0.5: x<y<1-x or 1+x<y<2-x \n// 0.5<x<1: 1-x<y<x or 2-x<y<1+x\n// 1<x<1.5: x<y<3-x or x-1<y<2-x\n// 1.5<x<2: x-1<y<x or 2-x<y<x-1\n\nvec2 moebius(vec2 a, vec2 b, vec2 c, vec2 d, vec2 z) {\n    return cMult((cMult(a, z) + b), (cMult(c, z) + d));\n}\n// moebius(a,b,c,d,z)=(az+b)/(cz+d)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // fragment position\n    vec2 pixPos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 camPos = vec3(0.0, 0.0, 1.9);\n    vec3 camDir = vec3(0.0, - 0.0, - 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camSide = cross(camDir, camUp);\n    float targetDepth = 1.0;\n    float theta = 3.2 * PI / 4.0;\n    camPos = rotX(theta) * camPos;\n    camDir = rotX(theta) * camDir;\n    camUp = rotX(theta) * camUp;\n    \n    // ray\n    vec3 ray = normalize(camSide * pixPos.x + camUp * pixPos.y + camDir * targetDepth);\n\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);;\n    if (hitScene(camPos, ray) < 0.0) {\n        vec3 rayPos = camPos + getDist2Scene(camPos, ray) * ray;\n        vec3 top = vec3(0.0, sphereSize, 0.0);\n        vec3 top2Sph = rayPos- top ;\n        float ang = getAngle( - top, top2Sph);\n        vec3 planePos = sphereSize / (length(top2Sph) * cos(ang)) * top2Sph;\n        float t = 0.5 * iTime;\n        vec2 a = pol2xy(vec2(0.5 * t, 0.5 + 0.47 * sin(t)));\n        vec2 b = c1 * cos(t);\n        vec2 c = c0;\n        vec2 d = c1;\n        \n        fragColor = mix(\n            vec4(vec3(0.0), 1.0),\n            vec4(1.0), \n            step(1.0, fct(moebius(a, b, c, d, planePos.xz))));\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 205, 226, 255, 301], [302, 302, 323, 352, 403], [405, 438, 466, 475, 540], [541, 541, 569, 578, 657], [658, 658, 678, 690, 721], [722, 722, 741, 750, 803], [805, 817, 842, 842, 880], [881, 881, 905, 905, 928], [929, 929, 953, 953, 998], [999, 999, 1031, 1031, 1083], [1084, 1084, 1124, 1124, 1198], [1199, 1199, 1238, 1238, 1282], [1283, 1283, 1322, 1322, 1387], [1388, 1388, 1432, 1432, 1632], [1633, 1633, 1678, 1678, 1945], [1946, 1946, 1990, 1990, 2065], [2066, 2066, 2090, 2090, 2314], [2315, 2315, 2339, 2339, 2463], [2464, 2464, 2488, 2488, 2612], [2613, 2613, 2632, 2632, 2700], [2701, 2897, 2951, 2951, 3009], [3010, 3047, 3102, 3128, 4409]], "test": "untested"}
{"id": "wsGXWz", "name": "Simple Little Radar", "author": "EdLynch", "description": "A simple circle based radar", "tags": ["radar", "learning"], "likes": 2, "viewed": 217, "published": "Public API", "date": "1573763792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nmat2 rotate2d(float _angle, float speed){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat crossN(in vec2 _st, float _size){\n    return  box(_st, vec2(_size,_size/4.)) +\n            box(_st, vec2(_size/4.,_size));\n}\n\n\nvec3 radar(vec2 st, float radius, vec3 radarColor, float speed){\n    st -= vec2(0.5);\n    float num = fract(iTime*speed) *2.*PI;\n    st *= rotate2d(num,speed);\n    st += vec2(0.5);\n    float intensity = smoothstep(0.16, 0.3, distance(st, vec2(0.5)))\n        *smoothstep(distance(vec2(0.5),st), distance(vec2(0.5),st)+.005, radius+.01);\n    intensity +=  ((smoothstep(0.4,0.5,st.x) - smoothstep(0.5,0.53,st.x))*\n        smoothstep(distance(st, vec2(0.5)), distance(st, vec2(0.5))+.05, radius+.02))\n        *smoothstep(0.45, 0.51, st.y);\n    return vec3(intensity*radarColor);\n}\n\nvec3 graientRing(vec2 st, float radius, vec3 radarColor){\n    float intensity = smoothstep(0.1, 0.3, distance(st, vec2(0.5)))\n        *smoothstep(distance(vec2(0.5),st), distance(vec2(0.5),st)+.005, radius+.01);\n    return vec3(intensity*radarColor);\n}\n\nvec3 ring(vec2 st, float radius, float thickness, vec3 ringColor){\n    float intensity = smoothstep(radius*.93-thickness, radius+0.01-thickness, distance(st, vec2(0.5)))\n         - smoothstep(radius, radius+0.01, distance(st, vec2(0.5)));\n    \n    return vec3(intensity*ringColor);\n}\n\nvec3 ringWithGaps(vec2 st, float radius, float thickness, vec3 ringColor){\n    vec3 ring = ring(st, radius, thickness, ringColor);\n    float gap = crossN(st, radius*3.) * (step(distance(st, vec2(0.5)), radius+.01)\n          -step(distance(vec2(0.5),st), radius-.01));\n    ring = ring - gap;\n    if(ring.x < .000001){\n        ring = vec3(0.);\n    }\n    return ring;\n}\n\nvec3 spinningRing(vec2 st, float radius, float thickness, vec3 ringColor, float time, float speed, bool clockwise){\n    vec3 color = ringWithGaps(st, radius, thickness, ringColor);\n    //return color;\n    st -= vec2(0.5);\n    float modifier = 1.;\n    if(!clockwise){modifier=-1.;}\n    // rotate the space\n    float num = fract(u_time*speed) *2.*PI * modifier;\n    st *= rotate2d(num,speed);\n    st += vec2(0.5);\n    color = ringWithGaps(st, radius, thickness, ringColor);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.y;\n    st.x -= .45;\n    vec3 color = vec3(0.362,0.172,0.960)*st.y*abs(sin(iTime));\n    \n    color += spinningRing(st, 0.4, 0.01, vec3(0.995,0.502,0.149), iTime, .1, false);\n    color += spinningRing(st, 0.3, 0.01, vec3(0.387,0.552,0.970), iTime, .3, true);\n    color += graientRing(st, 0.15*abs(sin(iTime)), vec3(0.995,0.100,0.462));\n    color += radar(st, .2, vec3(0.312,0.995,0.503), .6);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 177, 177, 263], [265, 265, 303, 303, 570], [572, 572, 611, 611, 702], [705, 705, 769, 769, 1281], [1283, 1283, 1340, 1340, 1535], [1537, 1537, 1603, 1603, 1820], [1822, 1822, 1896, 1896, 2188], [2190, 2190, 2305, 2305, 2686], [2688, 2688, 2745, 2745, 3215]], "test": "untested"}
{"id": "wsGXzw", "name": "Melted Ball", "author": "Easy", "description": "melted likes some water balls", "tags": ["tutorial"], "likes": 1, "viewed": 321, "published": "Public API", "date": "1573628278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p)\n{\n\tvec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n    float t = iTime*1.0+10.0;\n    \n    vec2 p1 = vec2(0.55,0.0);\n    vec2 p2 = vec2(-0.55,0.0);\n    \n    float radius = 0.15;\n    float expend = 0.1;\n    float threshold = 0.8;\n    float d = 0.0;\n    \n    for (float i = 1.0; i <= 60.0; i++)\n    {\n        vec2 n = N22(vec2(i+1.0,i));\n        vec2 p = vec2(1.0*sin(n.x*t/ratio)*ratio, 1.0*sin(n.y*t));\n        d += smoothstep(radius+expend, radius, length(uv - p));\n    }\n    d = smoothstep(threshold, 1.0, d);\n    \n    // Output to screen\n    fragColor = vec4(0.4,0.6,1.0,1.0)*d;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 140], [142, 142, 199, 249, 893]], "test": "untested"}
{"id": "WsKSDK", "name": "FastSleep", "author": "fancyblock", "description": "help me fast to sleep", "tags": ["2d"], "likes": 2, "viewed": 82, "published": "Public", "date": "1575020502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float pct = 0.0;\n    \n    vec2 center = vec2(cos(iTime) * 2.0 + 0.5, sin(iTime) * 2.0 + 0.5);\n    \n    pct = distance(uv, center);\n    \n    vec3 color = vec3(sin(pct * 160.0 - iTime * 50.0), cos(0.5 + iTime), sin(0.2 + iTime * 3.5));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 446]], "test": "untested"}
{"id": "WsKSDm", "name": "simple ray intersection 2", "author": "neur0sys", "description": "learning ray intersection stuff", "tags": ["lineplaneintersection"], "likes": 3, "viewed": 128, "published": "Public", "date": "1574242845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://en.wikipedia.org/wiki/Specular_reflection#Law_of_reflection\n// https://en.wikipedia.org/wiki/Lambertian_reflectance\n\n#define M_PI 3.14159265358979\n\n\nstruct Hit {\n\tvec3 c;\n    vec3 p;\n    bool h;\n};\n\nvec3 traceAmbient()\n{\n    // ambient\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * vec3(1.0);\n    return ambient;\n}\n\nvec3 traceDiffuse(vec3 lightDir, vec3 n)\n{\n    // diffuse\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0);\n    \n    vec3 c = vec3(1.0);\n    \n    return diffuse * c;\n}\n\nvec3 traceSpecular(vec3 lightDir, vec3 hit, vec3 l0, vec3 n)\n{\n    // specular\n    vec3 viewDir = normalize(hit - l0);\n    vec3 reflectDir = reflect(lightDir, n); \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);\n    return vec3(spec);\n}\n\nvec3 getLightPos()\n{\n    float t0 = iTime;\n    vec3 lightPos = vec3(0.0, 6.0, -10.0);\n    lightPos.z += cos(t0) * 8.0;\n    lightPos.x += sin(t0) * 8.0;\n    return lightPos;\n}\n\n\nvec3 traceLight(vec3 n, vec3 hit, vec3 l0)\n{\n    vec3 lightDir = normalize(getLightPos() - hit);\n    \n    vec3 ambient = traceAmbient();\n\n    vec3 diffuse = traceDiffuse(lightDir, n);\n\n    vec3 spec = traceSpecular(lightDir, hit, l0, n);\n   \n    return ambient + diffuse + spec;\n}\n\n// https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\nHit tracePlane(vec3 l0, vec3 l)\n{\n \t// plane equation\n    // (p - p0) . n = 0\n    \n    // t = ((p0 - l0) . n) / (l . n)\n \n    vec3 n = vec3(0.0, 1.0, 0.0);\n    vec3 p0 = vec3(-1.0, -1.0, -1.0);\n    \n    float denom = dot(n, l);\n    if (denom < 1e-6) {\n    \tfloat t = dot((p0 - l0), n) / denom;\n        vec3 hit = l0 + l * t;\n        \n        vec3 light = traceLight(n, hit, l0);\n        \n        vec3 c = vec3(1.0);\n        c += -1.0 * texture(iChannel0, hit.xz / 7.0).xyz * vec3(0.4, 0.9, 0.9);\n        \n        // checker board\n        float u = mod(hit.x, 2.0);\n        float v = mod(hit.z, 2.0);\n        \n        if ((u > 1.0 && v > 1.0) || (u < 1.0 && v < 1.0)) {\n            c -= 0.5;\n        }\n\n        return Hit(c * light, hit, true);\n    } else {\n    \treturn Hit(vec3(0.0), vec3(0.0), false);\n    }\n}\n\n\n// https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\nHit traceSphere(vec3 l0, vec3 l, vec3 o, float r, bool isFlat)\n{\n    // sphere: dot((p - c), (p - c)) = r * r\n    // line = a + t * b\n    \n    // t = (-b -+ sqrt(b*b - 4*a*c)) / 2*a\n    \n    // a = dot (b, b)\n    // b = 2 * dot (b, a-c)\n    // c = dot (a - c, a - c) - r * r\n   \n    float yOffset = cos(iTime / 3.0) * 2.0;\n    float zOffset = sin(iTime / 3.0) * 2.0;\n    float xOffset = sin(iTime / 3.0) * 2.0;\n    \n    //o.y += yOffset;\n    //o.z += zOffset;\n    //o.x += xOffset;\n    \n    float a = dot(l, l);\n    float b = 2.0 * dot(l, l0 - o);\n    float c = dot(l0 - o, l0 - o) - r * r;\n    float dis = b * b - 4.0 * a * c;\n    \n    if (dis < 0.) {\n        return Hit(vec3(0.0), vec3(0.0), false);\n    }\n    \n    float t = (-b - sqrt(dis)) / (2.0*a);\n    \n    vec3 hit = l0 + l * t;\n    vec3 n = normalize(hit - o);\n    vec3 light = traceLight(n, hit, l0);\n    \n    if (isFlat) {\n    \treturn Hit(vec3(1.0), hit, true);\n    }\n    \n    vec3 c0 = vec3(1.0);\n    \n    // https://en.wikipedia.org/wiki/UV_mapping#Finding_UV_on_a_sphere\n    // u = 0.5 + (arctan2(dz, dx)) / 2 * pi\n    // v = 0.5 - arcsin(dy) / pi\n    vec3 d = normalize(hit - o);\n    float u = mod(atan(d.z, d.x) / (2.0 * M_PI), 1.0);\n    float v = mod(asin(d.y) / M_PI, 1.0);\n    c0 = texture(iChannel1, vec2(u + iTime / 8.0, v)).xyz * 1.5;\n  \n    c0 = c0 * light;\n    \n    return Hit(c0, hit, true);\n}\n\nvec3 render(vec2 uv)\n{\n    // ray equation\n    // p = l0 + l * t\n    \n\tvec3 l0 = vec3(0.0, 0.0, 1.0);\n    vec3 l = normalize(vec3(uv, -1.0));\n \n    float yOffset = sin(iTime / 2.0) * 2.0 + 2.0;\n    float zOffset = cos(iTime / 2.0) * 3.0 + 3.0;\n    float xOffset = cos(iTime / 2.0) * 4.0 + 4.0;\n    \n    l0.y += yOffset;\n    l0.z += zOffset;\n    l0.x += xOffset;\n    \n    vec3 c = vec3(0.0);\n    \n    Hit hits[3];\n    \n    hits[0] = tracePlane(l0, l);\n    \n    hits[1] = traceSphere(l0, l, vec3(3.0, 0.0, -4.0), 1.0, false);\n    \n    hits[2] = traceSphere(l0, l, getLightPos(), 0.3, true);\n\n    Hit closest = Hit(vec3(0.0), vec3(0.0), false);\n    \n    for (int i = 0; i < 3; i++) {\n        if (hits[i].h && distance(hits[i].p, closest.p) > 0.0) {\n        \tclosest = hits[i];\n        }\n    }\n    \n    // Very naive and dumb way to calculate dynamic shadows I pulled out of the hat.\n    // Cast from hit point to light source, if intersects with any object it's in dark\n    if (closest.h) {\n    \tvec3 hit = closest.p;\n        vec3 light = getLightPos();\n        \n        // Add 1e-3 to the sphere radius size to get rid of an artifact (not sure).\n        Hit occluded = traceSphere(hit, light, vec3(3.0, 0.0, -4.0), 1.0 + 1e-3, false);\n        \n        if (occluded.h) {\n            closest.c *= 0.5;\n        }\n        \n    }\n    \n    return closest.c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //uv.y = 1.0 - uv.y;\n    uv = uv * 2.0 - 1.0;\n \tuv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = render(uv);\n\n    // c += render(uv + vec2(-0.001, 0.001));\n    // c += render(uv + vec2( 0.000, 0.001));\n    // c += render(uv + vec2( 0.001, 0.001));\n    // c += render(uv + vec2(-0.001, 0.000));\n    // c += render(uv + vec2( 0.000, 0.000));\n    // c += render(uv + vec2( 0.001, 0.000));\n    // c += render(uv + vec2(-0.001,-0.001));\n    // c += render(uv + vec2( 0.000, 0.001));\n    // c += render(uv + vec2( 0.001,-0.001));\n    \n    // c /= 9.0;\n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKSDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 210, 231, 246, 349], [351, 351, 393, 408, 550], [552, 552, 614, 630, 804], [806, 806, 826, 826, 980], [983, 983, 1027, 1027, 1263], [1265, 1330, 1363, 1449, 2140], [2143, 2209, 2273, 2483, 3577], [3579, 3579, 3601, 3643, 4930], [4932, 4932, 4989, 4989, 5620]], "test": "untested"}
{"id": "WsKSDR", "name": "PacMan", "author": "Sorangon", "description": "Here is an animated pacman shader, the first time I create a shader with shadertoy (I mainly use CG in Unity) !", "tags": ["videogame"], "likes": 2, "viewed": 66, "published": "Public", "date": "1573856884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\n\n//Screen space UV\nvec2 SSUV(vec2 uv){\n    return vec2(uv.x/ iResolution.x, uv.y/ iResolution.y);\n}\n\nfloat Circle(float radius, vec2 center, vec2 uv){\n    vec2 centeredUV = uv - center;\n    centeredUV.x *= iResolution.x/iResolution.y;\n    float circle = floor((1.0 - length(centeredUV)) + radius);\n    \n    return saturate(circle);\n}\n\n\nfloat Mouth(vec2 uv, vec2 center){\n    vec2 coordinate = uv - center;\n    float mouth = atan(coordinate.y, coordinate.x) / PI;\n    mouth = 1.0 - abs(mouth);\n    \n    float t = iTime * 30.0;\n    \n    float mouthPercentage = 0.38;\n    mouth = floor(mouth + (sin(t) + 1.0) / 2.0 * mouthPercentage);\n    \n    return mouth;\n}\n    \n\nfloat Balls(vec2 fragCoord, float scrolling, float spacing, float scale){\n    vec2 scrollinUV = vec2(fragCoord.x + scrolling, fragCoord.y);\n    \n    float heightMiddle = (iResolution.y/2.0) - scale/2.0;\n    \n    float circleSize = scale;\n    vec2 circleGrid = vec2(fract(scrollinUV.x / circleSize) - 0.5, fract((scrollinUV.y - heightMiddle)/ circleSize) - 0.5);\n    float c = 1.0 - length(circleGrid) * 2.0;\n    \n    float halfHeight = (fragCoord.y / iResolution.y) / 2.0;\n    float halfMask = (fragCoord.y - heightMiddle) / circleSize;\n    float ballsMask = -2.0 * (halfMask * halfMask) + 2.0 * halfMask;\n    ballsMask = ceil(saturate(ballsMask) * 2.0);\n    c = ceil(saturate(ballsMask * c));\n    \n    \n    \n    float verticalGrid = 1.0 - scrollinUV.x / circleSize;\n    verticalGrid /= spacing;\n    \n    verticalGrid = fract(verticalGrid);\n    verticalGrid = ceil(saturate(1.0 - (verticalGrid * spacing)));\n    c *= verticalGrid;\n    \n    float halfWidthMask = ceil((fragCoord.x / iResolution.x) - 0.25);\n    \n    return halfWidthMask * c;\n} \n\n\nvec4 Background(vec2 fragCoord){\n    float horizontalSineVal = SSUV(fragCoord).y * PI;\n    float background = sin(horizontalSineVal * 30.0) + 1.0 - sin(horizontalSineVal);\n    background = max(background, 0.0);\n              \n    float verticalSineVal = SSUV(fragCoord).x * 50.0 + iTime * 18.0;\n    float parralax = (1.0 - sin(verticalSineVal * PI) * 1.0);\n    parralax *= ceil(1.0 - fract((verticalSineVal - 1.0)/ 14.0)* 14.0);\n    parralax -= sin(horizontalSineVal);\n    parralax = saturate(parralax);\n    \n    return vec4(0.0, 0.0, 0.15, 1.0) * (max(background, parralax));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime * 6.0;\n    vec2 imageUV = fragCoord - vec2(sin(t) * 15.0, cos(t * 0.5) * 5.0) - vec2(-190,0.0);\n    vec2 screenSpaceUV = SSUV(imageUV);\n    vec4 color = vec4(1.0, 0.95, 0.0, 0.0);\n    \n    vec4 circle1  = vec4(vec3(Circle(0.3, vec2(0.5, 0.5), screenSpaceUV)), 1.0) * color;\n    \n    float eye = Circle(0.05, vec2(0.44, 0.6), screenSpaceUV);\n    float innerEye = Circle(0.04, vec2(0.44, 0.6), screenSpaceUV);\n    \n    \n    float mouth = Mouth(screenSpaceUV, vec2(0.5, 0.5));\n    \n    vec4 pacMan = circle1 - eye * 0.7 - innerEye * 0.15 - mouth;\n    pacMan = clamp(pacMan,0.0,1.0);\n    \n    float pacManMask = ceil(length(pacMan));\n    \n    vec4 balls = vec4(vec3(Balls(fragCoord, iTime * 1200.0,4.0, 70.0)), 0.0);\n    balls *= color;\n    balls *= saturate(1.0 - pacManMask);\n    \n    vec4 result = pacMan + balls;\n    \n    //Calculate background\n    if(length(result) <= 0.0){\n        result = Background(fragCoord);\n    }\n    \n    fragColor = result;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 81], [83, 101, 120, 120, 181], [183, 183, 232, 232, 415], [418, 418, 452, 452, 738], [745, 745, 818, 818, 1787], [1791, 1791, 1823, 1823, 2369], [2372, 2372, 2428, 2428, 3406]], "test": "untested"}
{"id": "wsKSRG", "name": "Raster/copper bars", "author": "antireality", "description": "It's 2019. What better way to use insane amounts of GPU power than to recreate some good old Amiga/C64 Raster colour bars?", "tags": ["oldschool", "amiga", "c64"], "likes": 3, "viewed": 388, "published": "Public API", "date": "1574329064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define barCount 15\n#define borderSize 0.1\n#define speed 1.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float r,g,b;\n    float delay = 0.125;\n    float barWidth = 20.0;\n    \n    float offset = 0.0;\n    float brightness = 0.0;\n    \n    if((uv.y > borderSize) && (uv.y < 1.0 - borderSize))\n    {\n        for(int i=0; i< barCount; i++)\n        {        \n             float yBarPos = (sin((iTime*speed)+offset)*.35)+0.5;\n            offset += delay;\n\n            if(brightness < 0.001)\n                brightness = clamp(1.0-(abs(yBarPos-uv.y)*barWidth),0.0,1.0);\n\n           r = brightness*abs(sin(offset+iTime));\n           g = brightness*abs(cos(offset+iTime));\n           b = brightness*0.25;           \n        }\n    }\n    else\n    {\n        r = g = 0.0;\n        b = 0.25;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 119, 169, 963]], "test": "untested"}
{"id": "WsKSRK", "name": "ShareX", "author": "fre3k", "description": "Shamelessly stolen from there: http://glslsandbox.com/e#58887.0", "tags": ["procedural"], "likes": 19, "viewed": 343, "published": "Public API", "date": "1574434439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t;\n\tt = iTime * 0.91;\n    vec2 r = iResolution.xy,\n    o = gl_FragCoord.xy - r/2.0;\n    o = vec2(length(o) / r.y - .3, atan(o.y,o.x));    \n    vec4 s = 0.08*cos(1.5*vec4(0,1,2,3) + t + o.y + sin(o.y) * cos(t)),\n    e = s.yzwx, \n    f = max(o.x-s,e-o.x);\n    fragColor = dot(clamp(f*r.y,0.,1.), 72.*(s-e)) * (s-.1) + f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKSRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 388]], "test": "untested"}
{"id": "wsKSWK", "name": "wave greek frieze 5  (237 chars)", "author": "FabriceNeyret2", "description": "Dare fullscreen ! :-p\ngolfing of my [url]https://shadertoy.com/view/XtSBDK[/url]\nother greek friezes here: [url]https://www.shadertoy.com/results?query=frieze[/url]", "tags": ["waves", "patterns", "2tweets", "short", "greek", "golf", "frieze"], "likes": 29, "viewed": 492, "published": "Public API", "date": "1575038143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfing of https://shadertoy.com/view/XtSBDK ( 343 chars )\n// NB: -15 chars without animation  -43 without big spiral antialiasing (at least for the 266 chars version )\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,  U = u+u - R;\n    float a = atan(U.y,U.x)/6.283 ;\n    a += ceil( U = 5.*length(U)/R - a ).y;\n    U.x= 2.6*a*a - iTime;\n    a  = dot( U = 2.* fract( U ) - 1. ,\n              cos( .4*a*a * max(0.,1.-length(U) ) - vec2(33,0) ));\n    O += min(1., a/fwidth(a) +.5) - pow( U.y*U.y, 5.);\n}/*\n\n\n\n\n\n\n// --- 244 chars\n\n#define mainImage(O,u)                                            \\\n    vec2  R = iResolution.xy,           U = u+u - R;              \\\n    float a = atan(U.y,U.x)/6.283 +.5,  l = length(U)*5./R.y - a; \\\n    a += ceil(l);                                                 \\\n    a = dot( U = 2.* fract( vec2( 2.6*a*a - iTime, l ) ) - 1. ,   \\\n             cos( .4*a*a * max(0.,1.-length(U) ) - vec2(33,0) )); \\\n    O += min(1., a/fwidth(a) +.5) - pow( U.y*U.y, 5.)            /*\n        \n\n        \n\n\n        \n// --- 266 chars\n        \n#define mainImage(O,u)                                       \\\n    vec2 R = iResolution.xy, U = 5.* ( u+u - R ) / R.y;      \\\n    float a = atan(U.y,U.x)/6.283 +.5, l = length(U)-a;      \\\n    a += ceil(l); a = 2.6*a*a - iTime;                       \\\n    a = dot( U = fract(vec2(a,l)) - .5  ,                    \\\n             cos( .3*(iTime+a) * max(0.,.5-length(U)) - vec2(33,0) ));  \\\n    O  += min(1., a/fwidth(a) +.5) - pow( abs( 2.*fract(l) -1. ), 10.) /*\n        \n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 173, 209, 209, 522]], "test": "untested"}
{"id": "WsKSWm", "name": "top crop and Random", "author": "AnnaGevorgyan99", "description": "top crop using random", "tags": ["random"], "likes": 1, "viewed": 58, "published": "Public", "date": "1574178267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 xy) {\n    return fract(sin(dot(xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nvec4 topCrop(vec4 texColor,vec2 xy,float size)\n{\n    float l=step(size,1.-xy.y);\n    texColor=l*texColor+(1.-l)*vec4(vec3(random(xy)),1.);\n    return texColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 xy = fragCoord/iResolution.xy;\n\n    vec4 texColor=texture(iChannel0,xy);\n    texColor=topCrop(texColor,xy,sin(iTime/3.));\n       \n        \n    fragColor=texColor;\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 128], [131, 131, 179, 179, 292], [294, 294, 350, 350, 529]], "test": "untested"}
{"id": "wsKSWy", "name": "RayMarching for RoundedCylinder", "author": "gonnavis", "description": "RayMarching for RoundedCylinder", "tags": ["raymarching"], "likes": 2, "viewed": 48, "published": "Public", "date": "1574914849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat GetDist(vec3 p) {\n\tvec3 s = vec3(0,.8, 6);\n    float sphereDist =  sdRoundedCylinder(p-s, .3, .2, .6);\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKSWy.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 348, 412, 412, 529], [530, 530, 553, 553, 728], [730, 730, 764, 764, 970], [972, 972, 996, 996, 1185], [1187, 1187, 1211, 1211, 1516], [1518, 1518, 1575, 1575, 1901]], "test": "untested"}
{"id": "wsKSzt", "name": "camino de abismo", "author": "jorge2017a1", "description": "camino de abismo", "tags": ["caminodeabismo"], "likes": 0, "viewed": 51, "published": "Public", "date": "1574780771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n\n\n\n///--------------------------------------------\n\n// For unions \n/*float unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}*/\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n\nmat2 Rot2(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n    \n}    \n\n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}    \n\n\n//Coordinate positioning of each shape\nfloat GetDist(vec3 p) {\t\n\n \t\n    float planeDist = p.y;\n  \t\n    float d;\n    \n   \n    float bx1 = sdBox (p-vec3(-4.,0.5,0.),vec3(10.0,1.5,10.0));\n   \n    //float d1 = p.y-pathterrain(p.x,p.z);\n    //float d1 =-pathterrain(p.x,p.z);  //bien\n    \n   \n    vec2 v1= Rot2(60.0)*vec2(p.x, p.z);\n   \n    float d1 =pathterrain(v1.x,v1.y);\n    \n    \n     d=planeDist;  \n    \n    float dif1;\n    dif1=d1;\n    \n    d=max(d,dif1);  \n   \n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.2;\n    //Determines size of shadow\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos1 = vec3(1, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(0, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\n\nfloat GetLightv3(vec3 p) {\n    vec3 lightPos1 = vec3(-1, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    \n    vec3 lightPos2 = vec3(2, 5, -6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    \n    vec3 lightPos3 = vec3(-2.5, 5.5, 0.5);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos3.xy += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l3 = normalize(lightPos3-p);\n    vec3 n3 = GetNormal(p);\n    \n    float dif3 = clamp(dot(n3, l3), 0., 1.);\n    float d3 = RayMarch(p+n3*SURF_DIST*2., l3);\n    if(d3<length(lightPos3-p)) dif3 *= .1;\n    \n    \n    return (dif1+dif2+dif3)/3.0;\n}\n\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n    \n    vec3 lightPos1 = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos1.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 n1 = GetNormal(p);\n    \n    float dif1 = clamp(dot(n1, l1), 0., 1.);\n    float d1 = RayMarch(p+n1*SURF_DIST*2., l1);\n    if(d1<length(lightPos1-p)) dif1 *= .1;\n    \n    \n    vec3 lightPos2 =lpos;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos2.xz += vec2(0.0, cos(iTime)*2.);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n2 = GetNormal(p);\n    \n    float dif2 = clamp(dot(n2, l2), 0., 1.);\n    float d2 = RayMarch(p+n2*SURF_DIST*2., l2);\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    \n    return (dif1+dif2)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    //Color of each object\n    //vec3 ro = vec3(0, 1.0, 0);\n    \n    vec3 ro = vec3(10.0+10.0*cos(iTime), 4.0+2.*sin(iTime),iTime*0.01);\n    \n    vec3 rd = normalize(vec3(uv.x-1.0, uv.y,1.0));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = (ro + rd * d );  //+texture(iChannel0, uv).x;\n    \n    float dif = GetLight(p);\n    float dif3= GetLightv3(p);\n    \n    dif=dif+ GetLightPos(p,ro);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n    //Background color is white\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKSzt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[348, 365, 398, 398, 463], [468, 486, 522, 522, 591], [592, 607, 638, 638, 788], [789, 809, 845, 845, 932], [933, 949, 981, 1009, 1070], [1125, 1321, 1367, 1367, 1399], [1401, 1401, 1443, 1443, 1475], [1477, 1477, 1524, 1524, 1557], [1561, 1561, 1582, 1582, 1669], [1676, 1676, 1711, 1762, 1857], [1864, 1903, 1926, 1926, 2344], [2346, 2346, 2380, 2380, 2614], [2616, 2616, 2640, 2640, 2872], [2874, 2874, 2898, 2898, 3282], [3287, 3287, 3313, 3313, 4114], [4117, 4117, 4143, 4143, 5348], [5352, 5352, 5390, 5390, 6173], [6175, 6175, 6232, 6232, 6798]], "test": "untested"}
{"id": "wsKXDV", "name": "Heaven and Hell", "author": "adurdin", "description": "Thanks to iq for his “Happy Jumping” tutorial video! I followed along, and changed things up to make this, and then norgg collaborated with me on the alternate version.", "tags": ["sdf"], "likes": 22, "viewed": 330, "published": "Public", "date": "1575056769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by andy durdin and norgg (@adurdin, @norgg)\n// This work is licensed under a Creative Commons\n// Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Based on “Happy Jumping” by Inigo Quilez\n\n#define TERRAIN_DETAIL 1\n#define SKY_DETAIL 1\n#define COLOR_GRADING 1\n\n// input: h in [0,360] and s,v in [0,1] - output: r,g,b in [0,1]\nvec3 hsl2rgb(vec3 c){return mix(c.bbb,mix(clamp(vec3(-1,2,2)-abs(c.r-vec3(3,2,4))*vec3(-1,1,1),0.,1.),vec3(c.b>.5),abs(.5-c.b)*2.),c.g);}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r;\n//         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdSphere( in vec3 pos, float rad )\n{\n    return length(pos) - rad;\n}\n\nfloat sdStick( in vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0,1.0 );\n    float r = mix( ra, rb, h );\n    return length(pa - h*ba) - r;\n}\n\nfloat sdEllipsoid( in vec3 pos, vec3 rad )\n{\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat smin( in float a, in float b, float k )\n{\n    float h = max( k - abs(a-b), 0.0 );\n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat smax( in float a, in float b, float k )\n{\n    float h = max( k - abs(a-b), 0.0 );\n    return max(a,b) + h*h/(k*4.0);\n}\n\nvec4 char_evil( in vec3 q, float atime, float sy, float sz, float cc, float ss, float y, float y2, float y3 )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // Body coordinate ref\n    vec3 b = q;\n    vec3 sb = vec3( abs(b.x), b.yz );\n\n    // body\n    {\n    vec3 rad = vec3(0.25,0.25*sy,0.25*sz);\n    float d = sdEllipsoid(q, rad);\n    if( d<res.x ) res = vec4(d,18.0,1.0,0.0);\n    }\n\n    // legs\n    {\n    vec3 legBase = vec3(0.15,-0.25,0.0);\n    legBase.y += 0.1/sy;\n    float la = -sign(b.x)*cos(3.1416*atime);\n    float ccc = cos(la);\n    float sss = sin(la);\n    vec3 legEnd = legBase + 0.2*vec3(0.2, -ccc, sss);\n    float d2 = sdStick( sb,\n                  legBase,\n                  legEnd,\n                  0.03,\n                  0.06 );\n    d = smin(res.x,d2,0.02);\n    if( d<res.x ) res = vec4(d, 16.0,1.0,0.0);\n    }\n\n    // Head coordinate ref\n    vec3 neck = vec3(0.0,0.0,0.12);\n    vec3 h = q - neck;\n\n    // Head rotation\n    float hr = -1.0+2.0*smoothstep( -0.2,0.2, -0.4*sin(atime * 1.7) );\n    float hp = -1.0+2.0*smoothstep( -0.4,0.4, 0.1+0.15*cos(atime * 3.3) );\n    //hr = -5.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n    //hp = -2.0*(iMouse.y/iResolution.y - 0.5); // mouse control\n    cc = cos(hr);\n    ss = sin(hr);\n    h.xz = mat2(cc,-ss,ss,cc)*h.xz;\n    cc = cos(hp);\n    ss = sin(hp);\n    h.yz = mat2(cc,-ss,ss,cc)*h.yz;\n\n    vec3 sh = vec3( abs(h.x), h.yz );\n\n    // pants (using head coordinates so they angle when the head does)\n    if (h.y < 0.0) { res.y = 6.0; }\n\n    // head\n    {\n\n    float d2 = sdEllipsoid(h - vec3(0.0,0.28,0.0), vec3(0.15,0.2,0.23));\n    float d3 = sdEllipsoid(h - vec3(0.0,0.28,-0.05), vec3(0.23,0.2,0.2));\n\n    d2 = smin(d2,d3, 0.05);\n    d = smin(res.x,d2, 0.15);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // eyebrows\n    {\n    vec3 eb = sh - vec3(0.04,0.33,0.16);\n    float er = -0.8;\n    cc = cos(er);\n    ss = sin(er);\n    eb.xy = (mat2(cc,ss,-ss,cc))*eb.xy;\n    float d2 = sdEllipsoid(eb, vec3(0.06,0.03,0.07));\n    d = smin(d,d2, 0.02);\n    //d = min(d,d2);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // wrinkles\n    {\n    float ry = (h.y-0.03) - 1.3*h.x*h.x;\n    d += 0.001*sin(ry*160.0) * (1.0 - smoothstep(0.0,0.05,abs(ry)));\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // arms\n    {\n    float d2 = sdStick( sh + neck,\n                  vec3(0.20,0.25,0.1+-0.05),\n                  vec3(0.3+0.1*y3,-0.1+0.4*y3,0.1+0.05),\n                  0.03,\n                  0.06 );\n    d = smin(d,d2,0.02);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // ears\n    {\n    float d2 = sdStick( sh,\n                  vec3(0.1,0.4,-0.01),\n                  vec3(0.2,0.4+0.15*y2,0.02-0.1*y2),\n                  0.01,\n                  0.03 );\n    d = smin(d,d2,0.04);\n    if( d<res.x ) res = vec4(d, 12.0,1.0,0.0);\n    }\n\n    // unicorn horn\n    {\n    float ro = -0.6;\n    float cc = cos(ro);\n    float ss = sin(ro);\n    vec3 hh = (sh - vec3(0.1, 0.4, 0.1));\n    hh.xy = mat2(cc,-ss,ss,cc)*hh.xy;\n    float d = sdStick(hh,\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.2, 0.0),\n        0.03,\n        0.01);\n    if( d<res.x ) res = vec4(d, 17.0,1.0,0.0);\n    }\n\n    // mouth\n    {\n    float d = sdEllipsoid(h - vec3(0.0,0.15 - 2.0*h.x*h.x*h.x,0.15), vec3(0.2,0.04 + 0.02 * sin(atime * 1.3),0.2));\n    float occ = 1.0-smoothstep( -0.01,0.001, -d );\n    d = smax(res.x,-d,0.01);\n    if( d>res.x ) res = vec4(d, 12.0,occ,0.0);\n    }\n\n    // tooth\n    {\n    //float d = sdRoundBox( h - vec3(0.0,0.19 + 0.005 * sin(atime * 1.3),0.16), vec3(0.02,0.011,0.01), 0.005 );\n    float y = 0.005 * sin(atime * 1.3);\n    float d = sdRoundBox( sh - vec3(0.018,0.19 + y,0.16), vec3(0.01,0.011,0.01), 0.005 );\n//  d = min(d, sdRoundBox( sh - vec3(0.058,0.185 + y,0.15), vec3(0.01,0.011,0.01), 0.005 ));\n    d = min(d, sdStick( sh, vec3(0.058,0.19 + y,0.15), vec3(0.058,0.16 + y,0.15), \n                       0.01, 0.001 ));\n    if( d<res.x ) res = vec4(d,20.0,1.0,0.0);\n    }\n\n    // eye\n    {\n    // Eye rotation\n    vec3 e = h - vec3(0.08,0.28,0.16);\n\n    // Maybe there's a way to get the eyes to repeat without\n    // symmetry, but if so I don't know what it would be.\n    // The \"limited repetition\" example's opRepLim works,\n    // but I don't know how to do get two eyes with it instead\n    // of three:\n    //\n    //    float rep_s = 0.16;\n    //    vec3 rep_lim = vec3(1.0, 0.0, 0.0);\n    //    vec3 e_rep = e - rep_s*clamp( round(e/rep_s), -rep_lim,rep_lim );\n    //    e = e_rep;\n    //\n    // So I'm just going to do each eye separately with its own coordinate\n    // basis instead*:\n    //\n    // (*also lets me rotate the eyes differently, which is better anyway!)\n\n    vec3 e0 = e;\n    vec3 e1 = e - vec3(-0.16, 0.0, 0.0);\n\n    // Horizontal eye movement beyond -0.7..0.7 looks weird. \n    // Vertical eye movement beyond -0.5..0.8 looks weird.\n    // But we don't use the full range here, because we're also\n    // tilting the head.\n    const float es = 0.05; // eye smoothing\n    float etime = atime + 0.1; // eyes lead the head movement by a moment.\n    float er = -0.5*(-1.0 + 2.0*smoothstep( -es, es, sin(etime * 1.7) ));\n    float ep = 0.1 + 0.45*(-1.0 + 2.0*smoothstep( -es, es, cos(etime * 3.3) ));\n    //er = clamp( -5.0*(iMouse.x/iResolution.x - 0.5), -0.7,0.7 ); // mouse control\n    //ep = clamp( -2.0*(iMouse.y/iResolution.y - 0.5), -0.5,0.8 ); // mouse control\n\n    // BUG: eyes ought to look at something in world coordinates,\n    // and remain stable even when the head and body move. But\n    // that's hard... I'm not set up to do the inverse transforms :(\n    \n    // The eyes rotate less when moving towards the nose.\n    float er0 = (er < 0.0 ? er : 0.4 * er);\n    float cc0 = cos(er0);\n    float ss0 = sin(er0);\n    e0.xz = mat2(cc0,-ss0,ss0,cc0)*e0.xz;\n    float er1 = (er > 0.0 ? er : 0.4 * er);\n    float cc1 = cos(er1);\n    float ss1 = sin(er1);\n    e1.xz = mat2(cc1,-ss1,ss1,cc1)*e1.xz;\n    // But both eyes pitch identically.\n    cc = cos(ep);\n    ss = sin(ep);\n    e0.yz = mat2(cc,-ss,ss,cc)*e0.yz;\n    e1.yz = mat2(cc,-ss,ss,cc)*e1.yz;\n    \n    // Eye occlusion\n    float eo = 1.0-5.0*smoothstep( 0.06,0.4, sh.x );\n\n    // Left eye (e0)\n    d = sdSphere( e0, 0.05 );\n    if( d<res.x ) res = vec4(d,13.0,eo,0.0);\n    // pupil\n    d = sdSphere( e0 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,14.0,1.0,0.0);\n\n    // Right eye (e1)\n    d = sdSphere( e1, 0.05 );\n    if( d<res.x ) res = vec4(d,13.0,eo,0.0);\n    // pupil\n    d = sdSphere( e1 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,14.0,1.0,0.0);\n    }\n\n    // --- wings ---\n    \n    {\n    float ws = 2.3;\n    vec3 wo = mix(sb, sh, 0.8) - vec3(0.0,0.1,-0.16);\n\n    //float wf = 0.5 + 0.6 * sin(ws * atime);\n    //float cc = cos(wf);\n    //float ss = sin(wf);\n    //wo.yz = mat2(cc,ss,-ss,cc) * wo.yz;\n    \n    float wr = -0.1 - 0.8 * pow(abs(sin(ws * atime)), 0.5);\n    cc = cos(wr);\n    ss = sin(wr);\n    wo.xy = mat2(cc,ss,-ss,cc) * wo.xy;\n    \n    float d = sdEllipsoid( wo - vec3(0.5,0.0 -1.6*pow(wo.x-0.3,2.0),0.0), vec3(0.3,0.15,0.01) );\n    \n    if( d<res.x ) res = vec4(d,19.0,0.0,0.0);\n    }\n\n    return res;\n}\n\nvec4 char_happy( in vec3 q, float atime, float sy, float sz, float cc, float ss, float y, float y2, float y3 )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // Body coordinate ref\n    vec3 b = q;\n    vec3 sb = vec3( abs(b.x), b.yz );\n\n    // body\n    {\n    vec3 rad = vec3(0.25,0.25*sy,0.25*sz);\n    float d = sdEllipsoid(q, rad);\n    if( d<res.x ) res = vec4(d,8.0,1.0,0.0);\n    }\n\n    // legs\n    {\n    vec3 legBase = vec3(0.15,-0.25,0.0);\n    legBase.y += 0.1/sy;\n    float la = -sign(b.x)*cos(3.1416*atime);\n    float ccc = cos(la);\n    float sss = sin(la);\n    vec3 legEnd = legBase + 0.2*vec3(0.2, -ccc, sss);\n    float d2 = sdStick( sb,\n                  legBase,\n                  legEnd,\n                  0.03,\n                  0.06 );\n    d = smin(res.x,d2,0.02);\n    if( d<res.x ) res = vec4(d, 6.0,1.0,0.0);\n    }\n\n    // Head coordinate ref\n    vec3 neck = vec3(0.0,0.0,0.12);\n    vec3 h = q - neck;\n\n    // Head rotation\n    float hr = -1.0+2.0*smoothstep( -0.2,0.2, -0.4*sin(atime * 1.7) );\n    float hp = -1.0+2.0*smoothstep( -0.4,0.4, 0.1+0.15*cos(atime * 3.3) );\n//    hr = -5.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n//    hp = 2.0*(iMouse.y/iResolution.y - 0.5); // mouse control\n    cc = cos(hr);\n    ss = sin(hr);\n    h.xz = mat2(cc,-ss,ss,cc)*h.xz;\n    cc = cos(hp);\n    ss = sin(hp);\n    h.yz = mat2(cc,-ss,ss,cc)*h.yz;\n\n    vec3 sh = vec3( abs(h.x), h.yz );\n\n    // pants (using head coordinates so they angle when the head does)\n    if (h.y < 0.0) { res.y = 6.0; }\n\n    // head\n    {\n\n    float d2 = sdEllipsoid(h - vec3(0.0,0.28,0.0), vec3(0.15,0.2,0.23));\n    float d3 = sdEllipsoid(h - vec3(0.0,0.28,-0.05), vec3(0.23,0.2,0.2));\n\n    d2 = smin(d2,d3, 0.05);\n    d = smin(res.x,d2, 0.15);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // eyebrows\n    {\n    vec3 eb = sh - vec3(0.12,0.36-0.03*y,0.13);\n    float er = 0.5;\n    cc = cos(er);\n    ss = sin(er);\n    eb.xy = (mat2(cc,ss,-ss,cc))*eb.xy;\n    float d2 = sdEllipsoid(eb, vec3(0.06,0.035,0.05));\n    d = smin(d,d2, 0.04);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // wrinkles\n    {\n    float ry = (h.y-0.03) - 1.3*h.x*h.x;\n    d += 0.001*sin(ry*160.0) * (1.0 - smoothstep(0.0,0.05,abs(ry)));\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // arms\n    {\n    float d2 = sdStick( sh + neck,\n                  vec3(0.20,0.25,0.1+-0.05),\n                  vec3(0.3+0.1*y3,-0.1+0.4*y3,0.1+0.05),\n                  0.03,\n                  0.06 );\n    d = smin(d,d2,0.02);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // ears\n    {\n    float d2 = sdStick( sh,\n                  vec3(0.1,0.4,-0.01),\n                  vec3(0.2,0.4+0.15*y2,0.02-0.1*y2),\n                  0.01,\n                  0.03 );\n    d = smin(d,d2,0.04);\n    if( d<res.x ) res = vec4(d, 2.0,1.0,0.0);\n    }\n\n    // unicorn horn\n    {\n    float ro = 0.7;\n    float cc = cos(ro);\n    float ss = sin(ro);\n    vec3 hh = (h - vec3(0.0, 0.4, 0.1));\n    hh.yz = mat2(cc,-ss,ss,cc)*hh.yz;\n    float d = sdStick(hh,\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.3, 0.0),\n        0.05,\n        0.01);\n    if( d<res.x ) res = vec4(d, 7.0,1.0,0.0);\n    }\n\n    // mouth\n    {\n    float d = sdEllipsoid(h - vec3(0.0,0.15 + 5.0*h.x*h.x,0.15), vec3(0.1,0.04,0.2));\n    float occ = 1.0-smoothstep( -0.01,0.001, -d );\n    d = smax(res.x,-d,0.04);\n    if( d>res.x ) res = vec4(d, 2.0,occ,0.0);\n    }\n\n    // tooth\n    {\n    float d = sdRoundBox( h - vec3(0.0,0.19,0.16), vec3(0.02,0.011,0.01), 0.005 );\n//    float d = sdRoundBox( sh - vec3(0.018,0.19,0.16), vec3(0.01,0.011,0.01), 0.005 );\n    if( d<res.x ) res = vec4(d,3.0,1.0,0.0);\n    }\n\n    // eye\n    {\n    // Eye rotation\n    vec3 e = h - vec3(0.08,0.28,0.16);\n\n    // Maybe there's a way to get the eyes to repeat without\n    // symmetry, but if so I don't know what it would be.\n    // The \"limited repetition\" example's opRepLim works,\n    // but I don't know how to do get two eyes with it instead\n    // of three:\n    //\n    //    float rep_s = 0.16;\n    //    vec3 rep_lim = vec3(1.0, 0.0, 0.0);\n    //    vec3 e_rep = e - rep_s*clamp( round(e/rep_s), -rep_lim,rep_lim );\n    //    e = e_rep;\n    //\n    // So I'm just going to do each eye separately with its own coordinate\n    // basis instead*:\n    //\n    // (*also lets me rotate the eyes differently, which is better anyway!)\n\n    vec3 e0 = e;\n    vec3 e1 = e - vec3(-0.16, 0.0, 0.0);\n\n    // Horizontal eye movement beyond -0.7..0.7 looks weird. \n    // Vertical eye movement beyond -0.5..0.8 looks weird.\n    // But we don't use the full range here, because we're also\n    // tilting the head.\n    const float es = 0.05; // eye smoothing\n    float etime = atime + 0.1; // eyes lead the head movement by a moment.\n    float er = -0.5*(-1.0 + 2.0*smoothstep( -es, es, sin(etime * 1.7) ));\n    float ep = 0.1 + 0.45*(-1.0 + 2.0*smoothstep( -es, es, cos(etime * 3.3) ));\n//    er = clamp( -5.0*(iMouse.x/iResolution.x - 0.5), -0.7,0.7 ); // mouse control\n//    ep = clamp(  2.0*(iMouse.y/iResolution.y - 0.5), -0.5,0.8 ); // mouse control\n\n    // BUG: eyes ought to look at something in world coordinates,\n    // and remain stable even when the head and body move. But\n    // that's hard... I'm not set up to do the inverse transforms :(\n    \n    // The eyes rotate less when moving towards the nose.\n    float er0 = (er < 0.0 ? er : 0.4 * er);\n    float cc0 = cos(er0);\n    float ss0 = sin(er0);\n    e0.xz = mat2(cc0,-ss0,ss0,cc0)*e0.xz;\n    float er1 = (er > 0.0 ? er : 0.4 * er);\n    float cc1 = cos(er1);\n    float ss1 = sin(er1);\n    e1.xz = mat2(cc1,-ss1,ss1,cc1)*e1.xz;\n    // But both eyes pitch identically.\n    cc = cos(ep);\n    ss = sin(ep);\n    e0.yz = mat2(cc,-ss,ss,cc)*e0.yz;\n    e1.yz = mat2(cc,-ss,ss,cc)*e1.yz;\n    \n    // Eye occlusion\n    float eo = 1.0-5.0*smoothstep( 0.06,0.4, sh.x );\n\n    // Left eye (e0)\n    d = sdSphere( e0, 0.05 );\n    if( d<res.x ) res = vec4(d,3.0,eo,0.0);\n    // pupil\n    d = sdSphere( e0 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,4.0,1.0,0.0);\n\n    // Right eye (e1)\n    d = sdSphere( e1, 0.05 );\n    if( d<res.x ) res = vec4(d,3.0,eo,0.0);\n    // pupil\n    d = sdSphere( e1 - vec3(0.00,0.00,0.04), 0.02 );\n    if( d<res.x ) res = vec4(d,4.0,1.0,0.0);\n    }\n\n    // --- wings ---\n    \n    {\n    float ws = 24.0;\n    vec3 wo = mix(sb, sh, 0.8) - vec3(0.0,0.1,-0.16);\n\n    float wf = 0.5 + 0.6 * sin(ws * atime);\n    float cc = cos(wf);\n    float ss = sin(wf);\n    wo.yz = mat2(cc,ss,-ss,cc) * wo.yz;\n    \n    float wr = -0.8 + 0.1 * sin(ws * atime);\n    cc = cos(wr);\n    ss = sin(wr);\n    wo.xy = mat2(cc,ss,-ss,cc) * wo.xy;\n    \n    float d = sdEllipsoid( wo - vec3(0.5,0.0,0.0), vec3(0.5,0.15,0.05) );\n    \n    if( d<res.x ) res = vec4(d,9.0,9.0,0.0);\n    }\n\n    return res;\n}\n\nvec4 terrain_evil( in vec3 pos, float atime, vec3 cen )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // terrain\n    float fh = -0.1 + 0.09*(sin(atime+2.0*pos.x)+ 0.8 * sin(atime*1.7+1.3*pos.z));\n    float l = length((pos - cen).xz);\n\n#if TERRAIN_DETAIL && 0\n    float gt = fract(atime);\n    fh -= 0.1\n        *sin(gt*8.0+l*2.0)\n        *exp( -1.0*l*l )\n        *exp( -1.0*gt )\n        *smoothstep(0.0,0.1,gt);\n#endif\n\n    d = pos.y - fh;\n    res = (d<res.x) ? vec4(d,11.0,1.0,0.0) : res;\n\n#if TERRAIN_DETAIL\n    // lava trees\n    {\n    vec3 q = vec3( mod(abs(pos.x), 3.0)-1.5,\n                   pos.y,\n                   mod(pos.z+1.5, 3.0)-1.5 );\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*31.1 + id.y*31.7;\n    float fy = fract(id.x*1.72+atime*1.225);\n    float y = 0.9*pow(fy, 0.5);\n    vec3 rad = vec3(0.7,1.0+0.5*sin(fid*431.19),0.8);\n    // rad -= 0.05*(sin(pos.x*3.0)+sin(pos.y*6.0)+sin(pos.z*5.0));\n    rad *= clamp(2.0*fy*(1.0-fy), 0.001, 1.0);\n    float d2 = sdEllipsoid( q-vec3(0.5,y,0.0), rad );\n    float f = smoothstep( -0.2,0.2,\n        sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n    d2 -= 0.007*f; // non-euclidean distortion of surface.\n    d = smin(d, d2, 0.7);\n\n    // Reduce step size for terrain to increase accuracy\n    // (preventing artifacts when the raymarcher goes inside\n    // the terrain because of the noneuclidean distortions).\n    // (this is a hacky solution)\n//    d *= 0.9;\n\n    res = (d<res.x) ? vec4(d,11.0,1.0,0.0) : res;\n    }\n\n    // candy\n    {\n    vec3 q = vec3( mod(pos.x+0.25, 0.5)-0.25,\n                   pos.y - fh,\n                   mod(pos.z+0.25, 0.5)-0.25);\n\n    vec2 id = floor((pos.xz+0.25)/0.5);\n    vec2 fid = vec2( id.x*21.1 + id.y*11.7,\n                      id.x*13.1 + id.y*51.7 );\n    vec2 dis = cos(fid);\n    vec3 ofs = vec3( dis.x*0.1,\n                     -0.25+0.2*fract(fid.x)+0.1*sin(atime*1.2+fid.x),\n                     dis.y*0.1);\n    vec3 group = vec3( 0.0,\n                       -0.05*(1.0 - cos(pos.x)*cos(pos.x)),\n                       0.0 );\n    vec3 so = q - ofs - group;\n    \n    float angle = 0.0 + sin(fid.x);\n    float cc = cos(angle);\n    float ss = sin(angle);\n    so.xz = mat2(cc, ss, -ss, cc) * so.xz;\n \n        \n    vec3 sso = vec3(abs(so.x), so.yz);\n    float d = sdSphere( so, 0.1 );\n    \n    float co = 0.5+0.5*clamp( (pos.y-fh)/0.03, 0.0,1.0 );\n\n    res = (d<res.x) ? vec4(d,15.0,co,0.0) : res;\n        \n    d = sdSphere( sso - vec3(0.034, 0.02, 0.09), 0.025);\n    d = max(res.x,-d);\n    res = (d>res.x) ? vec4(d,19.0,0.01,0.0) : res;\n    }\n#endif\n\n    return res;\n}\n\nvec4 terrain_happy( in vec3 pos, float atime, vec3 cen )\n{\n    float d = 999.0;\n    vec4 res = vec4(d,-1.0,0.0,0.0);\n\n    // terrain\n    float fh = -0.1 + 0.05*(sin(2.0*pos.x)+sin(2.0*pos.z));\n    float l = length((pos - cen).xz);\n\n#if TERRAIN_DETAIL && 0\n    float gt = fract(atime);\n    fh -= 0.1\n        *sin(gt*8.0+l*2.0)\n        *exp( -1.0*l*l )\n        *exp( -1.0*gt )\n        *smoothstep(0.0,0.1,gt);\n#endif\n\n    d = pos.y - fh;\n    res = (d<res.x) ? vec4(d,1.0,1.0,0.0) : res;\n\n#if TERRAIN_DETAIL\n    // trees\n    {\n    vec3 q = vec3( mod(abs(pos.x), 3.0)-1.5,\n                   pos.y,\n                   mod(pos.z+1.5, 3.0)-1.5 );\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*31.1 + id.y*31.7;\n    float fy = fract(id.x*1.72+atime*0.125);\n    float y = 2.0*fy;\n    vec3 rad = vec3(0.7,1.0+0.5*sin(fid*431.19),0.8);\n    rad -= 0.05*(sin(pos.x*3.0)+sin(pos.y*6.0)+sin(pos.z*5.0));\n    rad *= clamp(4.0*fy*(1.0-fy), 0.001, 1.0);\n    float d2 = sdEllipsoid( q-vec3(0.5,y,0.0), rad );\n    float f = smoothstep( -0.2,0.2,\n        sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n    d2 -= 0.007*f; // non-euclidean distortion of surface.\n    d = smin(d, d2, 0.3);\n\n    // Reduce step size for terrain to increase accuracy\n    // (preventing artifacts when the raymarcher goes inside\n    // the terrain because of the noneuclidean distortions).\n    // (this is a hacky solution)\n//    d *= 0.9;\n\n    res = (d<res.x) ? vec4(d,1.0,1.0,0.0) : res;\n    }\n\n    // candy\n    {\n    vec3 q = vec3( mod(pos.x+0.25, 0.5)-0.25,\n                   pos.y - fh,\n                   mod(pos.z+0.25, 0.5)-0.25 );\n    vec2 id = floor((pos.xz+0.25)/0.5);\n    vec2 fid = vec2( id.x*21.1 + id.y*11.7,\n                      id.x*13.1 + id.y*51.7 );\n    vec2 dis = cos(fid);\n    vec3 ofs = vec3( dis.x*0.1,\n                     -0.25+0.3*fract(fid.x),\n                     dis.y*0.1);\n    vec3 group = vec3( 0.0,\n                       -0.05*(1.0 - cos(pos.x)*cos(pos.x)),\n                       0.0 );\n    float d = sdSphere( q - ofs - group, 0.1 );\n    float co = 0.5+0.5*clamp( (pos.y-fh)/0.03, 0.0,1.0 );\n\n    res = (d<res.x) ? vec4(d,5.0,co,0.0) : res;\n    }\n#endif\n\n    return res;\n}\n\nvec4 map( in vec3 pos, float atime )\n{\n    float t = fract(atime);\n    float y = 4.0*t*(1.0 - t);\n    float dy = 4.0*(1.0 - 2.0*t);\n    // delayed parabolas\n    float t2 = fract(atime - 0.2);\n    float y2 = 4.0*t2*(1.0 - t2);\n    float t3 = fract(atime + 0.15);\n    float y3 = 4.0*t3*(1.0 - t3);\n\n    vec2 uu = normalize(vec2(1.0,-dy));\n    vec2 vv = vec2(-uu.y, uu.x);\n\n    float itime = floor(atime);\n    float ftime = fract(atime);\n\n    // position\n    float x = -1.0+2.0*abs(fract(0.5*atime) - 0.5)/0.5;\n    vec3 cen = vec3( 0.6 * sin(atime),\n                     //0.8*pow(pow(y,2.0-y), 0.4)+0.15, // temp\n                     0.7 + 0.3 * sin(atime),\n                     itime+pow(ftime,0.7) );\n    float sy = 0.7 + 0.3*y;\n    float sz = 1.0/sy;\n\n    // ref coords\n    vec3 q = pos - cen;\n\n    float ro = 0.3*x;\n    float cc = cos(ro);\n    float ss = sin(ro);\n    q.xy = mat2(cc,-ss,ss,cc)*q.xy;\n\n\n    // Swap the character and the terrain\n    float ttime = mod(atime+2.0, 10.0);\n    float ctime = mod(atime+1.0, 10.0);\n    float tx = 0.0;\n    const float ts = 20.0;\n    if( ttime < 2.0 ) tx = ts*(ttime - 1.0);\n    else if( ttime < 5.0 ) tx = ts;\n    else if( ttime < 7.0 ) tx = -ts*((ttime - 5.0) - 1.0);\n    else tx = -ts;\n    \n\n    vec4 res, res2;\n\n    if( ctime<5.0 ) {\n        res = char_happy( q, atime, sy, sz, cc, ss, y, y2, y3 );\n    } else {\n        res = char_evil( q, atime, sy, sz, cc, ss, y, y2, y3 );\n    }\n    if( pos.x < tx) {\n        res2 = terrain_happy( pos, atime, cen );\n    } else {\n        res2 = terrain_evil( pos, atime, cen );\n    }\n    res = (res2.x < res.x) ? res2 : res;\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, float atime )\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize( vec3( map(pos+e.xyy,atime).x-map(pos-e.xyy,atime).x,\n                            map(pos+e.yxy,atime).x-map(pos-e.yxy,atime).x,\n                            map(pos+e.yyx,atime).x-map(pos-e.yyx,atime).x ) );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float atime )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; ++i )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, atime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( (1.0 - 2.0*occ), 0.0,1.0 );\n}\n\nfloat castShadow( in vec3 ro, in vec3 rd, float atime )\n{\n    float res = 1.0;\n    // Start a bit out to prevent self-shadowing \"onion rings\" due\n    // to noneuclidean distances (this is a hacky solution, and it\n    // will prevent any real small self-shadowing that we want, that\n    // we were getting at t=0.01)\n    float t = 0.05;\n    for( int i=0; i<100; ++i )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos,atime ).x;\n        // Divide by t to get cone tracing.\n        // A smaller constant factor gives softer shadows.\n        res = min( res, 16.0*h/t );\n        if( h<0.0001 ) break;\n        t += h * 0.5; // Step shadows slower to reduce banding.\n        if( t>20.0 ) break;\n    }\n\n    return clamp( res, 0.0,1.0 );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float atime )\n{\n    vec3 m = vec3(-1.0,1.0,0.0);\n    float t = 0.01;\n    for( int i=0; i<512; ++i )\n    {\n        vec3 pos = ro + t*rd;\n        vec4 h = map( pos,atime );\n        m = h.yzw;\n        if( abs(h.x)<(0.001*t) ) break;\n        t += h.x;\n        if( t>20.0 ) break;\n    }\n    if( t>20.0 ) m = vec3(-1.0,1.0,0.0);\n    return vec4(t,m);\n}\n\nvec3 sky_evil(vec3 rd, float atime)\n{\n    // sky (the default colour)\n    vec3 col = vec3(0.35,0.2,0.1) - 0.7*rd.y; // sky base\n    col = clamp( col, 0.0,1.0 );\n\n#if SKY_DETAIL\n    // clouds\n    vec2 uv = rd.xz/rd.y; // How is this derived??\n    vec2 uv0 = uv + atime*vec2(0.1, -0.08);\n    vec2 uv1 = uv + atime*vec2(0.2, -0.10);\n    float cl = 0.6*( sin(1.0*uv0.x) + sin(1.0*uv0.y) )\n             + 0.3*( sin(2.0*uv1.x) + sin(2.0*uv1.y) );\n    col = mix( col, vec3(1.0,0.5,0.5) * 0.0002,\n               smoothstep( -0.4,0.4, -0.5+cl ) );\n\n    // horizon glow/fog\n    col = mix( col, vec3(0.95,0.7,0.5), exp(-10.0*rd.y) );\n#endif\n    return col;\n}\n\nvec3 sky_happy(vec3 rd, float atime)\n{\n    // sky (the default colour)\n    vec3 col = vec3(0.4,0.75,1.0) - 0.7*rd.y; // sky base\n    col = clamp( col, 0.0,1.0 );\n\n#if SKY_DETAIL\n    // clouds\n    vec2 uv = rd.xz/rd.y; // How is this derived??\n    vec2 uv0 = uv + atime*vec2(0.1, -0.08);\n    vec2 uv1 = uv + atime*vec2(0.2, -0.10);\n    float cl = 0.6*( sin(1.0*uv0.x) + sin(1.0*uv0.y) )\n             + 0.3*( sin(2.0*uv1.x) + sin(2.0*uv1.y) );\n    col = mix( col, vec3(0.3,0.7,0.95),\n               smoothstep( -0.15,0.15, -0.5+cl ) );\n\n    // horizon glow/fog\n    col = mix( col, vec3(0.5,0.7,0.9), exp(-10.0*rd.y) );\n#endif\n    return col;\n}\n\nvec3 sky(vec3 rd, float atime)\n{\n    // Swap the character and the terrain\n    float ttime = mod(atime+1.5, 10.0);\n    float tx = 0.0;\n    if( ttime < 1.0 ) tx = 1.0-ttime;\n    else if( ttime < 5.0 ) tx = 0.0;\n    else if( ttime < 6.0 ) tx = (ttime - 5.0);\n    else tx = 1.0;\n\n    vec3 sky1 = sky_happy(rd, atime);\n    vec3 sky2 = sky_evil(rd, atime);\n    return mix(sky1, sky2, tx);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n\n    // time\n    float atime = mod(iTime, 60.0);\n//    atime = 134.7; // paused in sunlight\n//    atime = 4.0; // paused in shadow\n//    atime = 40.8; // paused 3/4 view\n//    atime = 110.25; // paused looking almost at camera\n//    atime = 20.13; // paused half in shadow\n\n    // character pos\n    float t = fract(atime-0.1);\n    float y = 4.0*t*(1.0 - t); // from character y, slightly advanced\n\n    // camera angle\n    float an = -0.2+0.4*sin(0.15*atime);\n//    an = 10.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n\n    // camera distance\n    float cd = 2.5-0.9*sin(0.1*atime)*sin(0.1*atime);\n    // camera offset\n    vec3 co = vec3(cd*sin(an),1.0,cd*cos(an)); // temp\n    // target\n    vec3 ta = vec3(0.0,0.7+0.0*0.2*y,atime); // temp\n\n    // float above floor\n    vec3 ro = ta + co;\n    float fh = -0.1 + 0.05*(sin(2.0*ro.x)+sin(2.0*ro.z)); // from terrain\n    ro.y = fh + 0.22 + 0.5*sin(0.2*atime)*sin(0.2*atime);\n\n    // camera shake when bouncing\n    // temp\n//    float bt = -1.0+2.0*abs(fract(atime-0.1) - 0.5)/0.5;\n//    float bou = 0.8*smoothstep(0.2,1.0,bt);\n//    ro += bou*vec3(0.05,-0.12,0.05)*sin(atime*12.0 + vec3(2.0,2.0,4.0));\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n    vec3 col = sky(rd, atime);\n\n    vec4 tm = castRay( ro, rd, atime );\n    if( tm.y>0.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, atime );\n\n        // albedo\n        vec3 al = vec3(0.18);\n        // specular\n        float ks = 1.0;\n\n        // happy materials\n        if( tm.y<1.5 )\n        {\n            // terrain\n            al = vec3(0.05,0.1,0.02);\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n            // get darker and redder as it grows higher\n            al = mix( al, vec3(0.005, 0.0005, 0.0), 0.3*pos.y );\n            // specular is only high near ground level\n            ks = clamp( 2.0 - 1.5*pos.y, 0.0,3.0 );\n        }\n        else if( tm.y<2.5 || (tm.y >= 7.5 && tm.y < 8.5) )\n        {\n            // body\n            al = vec3(0.02,0.1,0.3);\n            ks = 0.5;\n\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -2.0,2.0,\n                sin(30.0*pos.x*0.1)+sin(30.0*pos.y*0.1)+sin(30.0*pos.z*0.5) );\n            al = mix(al, vec3(0.4, 0.1, 0.2), 1.0 - f);\n        }\n        else if( tm.y<3.5 )\n        {\n            // eyes\n            al = vec3(0.4,0.4,0.4);\n            ks = 2.0;\n        }\n        else if( tm.y<4.5 )\n        {\n            // pupils\n            al = vec3(0.02);\n            ks = 10.0;\n        }\n        else if( tm.y<5.5 )\n        {\n            // candy\n            al = vec3(0.1, 0.02, 0.01);\n            vec2 id = floor((pos.xz+0.25)/0.5);\n            float fid = id.x*11.1 + id.y*31.7;\n            al += vec3(0.01,0.06,0.02)*cos( fid*10.0 + vec3(0.0, 0.2, 0.4) );\n            ks = 1.0;\n        }\n        else if( tm.y<6.5 )\n        {\n            // pants\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 3.0;\n        }\n        else if( tm.y<7.5 )\n        {\n            // horn\n            float hue = fract(atime * 3.0) * 6.28;\n            al = hsl2rgb(vec3(hue, 0.9, 0.4));\n            ks = 10.0;\n        }\n        else if( tm.y<9.5 )\n        {\n            // wings\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 5.0;\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(80.0*pos.x)+sin(80.0*pos.y)+sin(2.0) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n        }\n        else if( tm.y<10.5 )\n        {\n            // everything else\n            al = vec3(0.0,0.0,0.0);\n            ks = 0.0;\n        }\n        // evil materials\n        else if( tm.y<11.5 )\n        {\n            // terrain\n            al = vec3(0.4,0.03,0.01);\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n            // get darker and redder as it grows higher\n            al = mix( al, vec3(0.007, 0.0003, 0.0), 0.15*(pos.y + 6.0) );\n            // specular is only high near ground level\n            ks = clamp( 2.0 - 1.5*pos.y, 0.0,3.0 );\n        }\n        else if( tm.y<12.5 || (tm.y >= 17.5 && tm.y < 18.5) )\n        {\n            // body\n            al = vec3(0.02,0.1,0.3);\n            ks = 0.5;\n\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -2.0,2.0,\n                sin(30.0*pos.x*0.1)+sin(30.0*pos.y*0.1)+sin(30.0*pos.z*0.5) );\n            al = mix(al, vec3(0.4, 0.1, 0.2), 1.0 - f);\n        }\n        else if( tm.y<13.5 )\n        {\n            // eyes\n            al = vec3(0.6,0.0,0.0);\n            ks = 2.0;\n        }\n        else if( tm.y<14.5 )\n        {\n            // pupils\n            al = vec3(0.02);\n            ks = 10.0;\n        }\n        else if( tm.y<15.5 )\n        {\n            // candy\n            al = vec3(0.1, 0.1, 0.1);\n            vec2 id = floor((pos.xz+0.25)/0.5);\n            float fid = id.x*11.1 + id.y*31.7;\n            al += vec3(0.01,0.06,0.02)*cos( fid*10.0 + vec3(0.0, 0.2, 0.4) );\n            ks = 1.0;\n        }\n        else if( tm.y<16.5 )\n        {\n            // pants\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 3.0;\n        }\n        else if( tm.y<17.5 )\n        {\n            // horn\n            float hue = fract(atime * 0.1) * 6.28;\n            al = hsl2rgb(vec3(hue, 0.9, 0.4));\n            ks = 10.0;\n        }\n        else if( tm.y<19.5 )\n        {\n            // wings\n            al = vec3(0.0, 0.0, 0.0);\n            ks = 0.3;\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(80.0*pos.x)+sin(80.0*pos.y)+sin(2.0) );\n            //al += 0.2*f*vec3(0.06,0.06,0.02);\n        }\n        else if( tm.y<20.5 )\n        {\n            // eyes\n            al = vec3(0.5,0.5,0.1);\n            ks = 3.0;\n        }\n        else\n        {\n            // everything else\n            al = vec3(0.0,0.0,0.0);\n            ks = 0.0;\n        }\n        al = clamp( al, vec3(0.0), vec3(1.0) );\n\n        float occ = calcOcclusion( pos, nor, atime )*tm.z;\n        vec3 sun_dir = normalize( vec3(0.8,0.4,0.7) );\n        float sun_dif = clamp( dot(nor,sun_dir), 0.0,1.0 );\n        // push specular out of place a little\n        vec3 sun_hal = normalize(sun_dir - rd + vec3(0.0, 0.25, -0.5));\n        float sun_sha = castShadow( pos + nor*0.001, sun_dir, atime );\n        vec3 sun_sha_pen = vec3(sun_sha,\n                                mix( sun_sha, sun_sha*sun_sha, 0.5 ),\n                                sun_sha*sun_sha); // for orangey penumbras.\n        float sun_spe = ks*pow( clamp(dot(nor,sun_hal),0.0,1.0), 8.0 )*sun_dif\n                          *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0,1.0 );\n        float sky_ref = smoothstep( 0.0,1.5/ks, reflect(rd,nor).y );\n        float bou_dif = clamp( 0.01 + 0.99*dot(nor,vec3(0.0,-1.0,0.0)), 0.0,1.0 );\n        float fre = clamp( 1.0 + dot(rd,nor), 0.0,1.0 );\n\n        // Check if the guy is generally in shadow (so we can reduce\n        // sss when he is. And only apply this to the guy's body, not\n        // the whole scene!\n        // (Previously it was being applied when he looked down :D\n        // and it made the whole terrain flicker when applied D: )\n        float guy_sha = 1.0;\n        if (tm.y > 1.5 && tm.y <= 2.5) {\n        float itime = floor(atime);\n        float ftime = fract(atime);\n        float y = 4.0*ftime*(1.0 - ftime);\n        float x = -1.0+2.0*abs(fract(0.5*atime) - 0.5)/0.5;\n        vec3 cen = vec3( x*0.4,\n                         pow(y,2.0-y)+0.15,\n                         itime+pow(ftime,0.7) );\n        // offset the body raycast by a bunch to prevent it intersecting\n        // the body/head. We only want to consider environment shadows!\n        guy_sha = castShadow( cen+0.8*sun_dir, sun_dir, atime );\n        }\n\n        // diffuse (sun, sky, bounce)\n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(9.1,6.0,2.2)*sun_sha_pen;\n        lin += 1.5*sky_dif*vec3(0.5,0.8,3.9)*occ;\n        lin += 0.75*bou_dif*vec3(0.3,1.08,0.2)*occ;\n        // fake sss\n        lin += 2.0*fre*vec3(1.5,0.5,0.4)\n                  *(0.5+0.5*sun_dif) // reduce a little in unlit areas.\n                  *(0.15+0.85*guy_sha) // reduce a lot when guy in shadow.\n                  *(0.5+0.5*tm.z); // reduce a ton when in forced-occlusion places.\n        col = al*lin;\n\n        // specular\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        col += sky_ref*0.1*vec3(0.6,0.9,2.0)*sky_dif*occ;\n\n        // haze\n        col = mix( col, vec3(0.95,0.7,0.5), 1.0-exp(-0.00005*t*t*t) );\n\n#if COLOR_GRADING\n        // Inigo hack: boost reds in the lighting colours.\n        // Like a curves adjustment. Artistic more than realistic.\n        col = pow( col, vec3(0.8,0.9,1.0) );\n#endif\n\n//        col = vec3(tm.z*tm.z);\n//        col = vec3(occ*occ);\n//        col = vec3( guy_sha );\n        }\n\n    // Convert to gamma space.\n    col = pow( col, vec3(0.4545) );\n\n#if COLOR_GRADING\n    // Exposure and contrast adjustment:\n    // (Normally would do this in linear space, but this s-curve is only\n    // good between 0 and 1.)\n    col = clamp( 1.05*col, 0.0,1.0 ); // 5% exposure gain & clamp to prevent burn.\n    vec3 contrasty = col*col*(3.0 - 2.0*col); // shallow s-curve.\n    col = mix( col, contrasty, 0.25 ); // Just use a bit of the contrasty colours.\n#endif\n\n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n\n    // time\n    float atime = mod(iTime, 60.0);\n//    atime = 134.7; // paused in sunlight\n//    atime = 4.0; // paused in shadow\n//    atime = 40.8; // paused 3/4 view\n//    atime = 110.25; // paused looking almost at camera\n//    atime = 20.13; // paused half in shadow\n\n    // character pos\n    float t = fract(atime-0.1);\n    float y = 4.0*t*(1.0 - t); // from character y, slightly advanced\n\n    // camera angle\n    float an = -0.2+0.4*sin(0.15*atime);\n//    an = 10.0*(iMouse.x/iResolution.x - 0.5); // mouse control\n\n    // camera distance\n    float cd = 2.5-0.9*sin(0.1*atime)*sin(0.1*atime);\n    // camera offset\n    vec3 co = vec3(0.0,0.0,cd);//vec3(cd*sin(an),1.0,cd*cos(an)); // temp\n    // target\n    vec3 ta = vec3(0.0,0.7+0.0*0.2*y,atime); // temp\n\n    // float above floor\n    vec3 ro = ta + co;\n    float fh = -0.1 + 0.05*(sin(2.0*ro.x)+sin(2.0*ro.z)); // from terrain\n    ro.y = fh + 0.22 + 0.5*sin(0.2*atime)*sin(0.2*atime);\n\n    // camera shake when bouncing\n    // temp\n//    float bt = -1.0+2.0*abs(fract(atime-0.1) - 0.5)/0.5;\n//    float bou = 0.8*smoothstep(0.2,1.0,bt);\n//    ro += bou*vec3(0.05,-0.12,0.05)*sin(atime*12.0 + vec3(2.0,2.0,4.0));\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n    // sky (the default colour)\n    vec3 col = vec3(0.4,0.75,1.0) - 0.7*rd.y; // sky base\n    col = clamp( col, 0.0,1.0 );\n\n#if SKY_DETAIL\n    // clouds\n    vec2 uv = rd.xz/rd.y; // How is this derived??\n    vec2 uv0 = uv + atime*vec2(0.1, -0.08);\n    vec2 uv1 = uv + atime*vec2(0.2, -0.10);\n    float cl = 0.6*( sin(1.0*uv0.x) + sin(1.0*uv0.y) )\n             + 0.3*( sin(2.0*uv1.x) + sin(2.0*uv1.y) );\n    col = mix( col, vec3(0.3,0.7,0.95),\n               smoothstep( -0.15,0.15, -0.5+cl ) );\n\n    // horizon glow/fog\n    col = mix( col, vec3(0.5,0.7,0.9), exp(-10.0*rd.y) );\n#endif\n\n    vec4 tm = castRay( ro, rd, atime );\n    if( tm.y>0.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, atime );\n\n        // albedo\n        vec3 al = vec3(0.18);\n        // specular\n        float ks = 1.0;\n\n        if( tm.y<1.5 )\n        {\n            // terrain\n            al = vec3(0.05,0.1,0.02);\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n            // get darker and redder as it grows higher\n            al = mix( al, vec3(0.005, 0.0005, 0.0), 0.3*pos.y );\n            // specular is only high near ground level\n            ks = clamp( 2.0 - 1.5*pos.y, 0.0,3.0 );\n        }\n        else if( tm.y<2.5 || (tm.y >= 7.5 && tm.y < 8.5) )\n        {\n            // body\n            al = vec3(0.02,0.1,0.3);\n            ks = 0.5;\n\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -2.0,2.0,\n                sin(30.0*pos.x*0.1)+sin(30.0*pos.y*0.1)+sin(30.0*pos.z*0.5) );\n            al = mix(al, vec3(0.4, 0.1, 0.2), 1.0 - f);\n        }\n        else if( tm.y<3.5 )\n        {\n            // eyes\n            al = vec3(0.4,0.4,0.4);\n            ks = 2.0;\n        }\n        else if( tm.y<4.5 )\n        {\n            // pupils\n            al = vec3(0.02);\n            ks = 10.0;\n        }\n        else if( tm.y<5.5 )\n        {\n            // candy\n            al = vec3(0.1, 0.02, 0.01);\n            vec2 id = floor((pos.xz+0.25)/0.5);\n            float fid = id.x*11.1 + id.y*31.7;\n            al += vec3(0.01,0.06,0.02)*cos( fid*10.0 + vec3(0.0, 0.2, 0.4) );\n            ks = 1.0;\n        }\n        else if( tm.y<6.5 )\n        {\n            // pants\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 3.0;\n        }\n        else if( tm.y<7.5 )\n        {\n            // horn\n            float hue = fract(atime * 3.0) * 6.28;\n            al = hsl2rgb(vec3(hue, 0.9, 0.4));\n            ks = 10.0;\n        }\n        else if( tm.y<9.5 )\n        {\n            // wings\n            al = vec3(0.4, 0.1, 0.2);\n            ks = 5.0;\n            // polka dot pattern\n            float f = -1.0+2.0*smoothstep( -0.2,0.2,\n                sin(80.0*pos.x)+sin(80.0*pos.y)+sin(2.0) );\n            al += 0.2*f*vec3(0.06,0.06,0.02);\n        }\n        else\n        {\n            // everything else\n            al = vec3(0.0,0.0,0.0);\n            ks = 0.0;\n        }\n        al = clamp( al, vec3(0.0), vec3(1.0) );\n\n        float occ = calcOcclusion( pos, nor, atime )*tm.z;\n        vec3 sun_dir = normalize( vec3(0.8,0.4,0.7) );\n        float sun_dif = clamp( dot(nor,sun_dir), 0.0,1.0 );\n        // push specular out of place a little\n        vec3 sun_hal = normalize(sun_dir - rd + vec3(0.0, 0.25, -0.5));\n        float sun_sha = castShadow( pos + nor*0.001, sun_dir, atime );\n        vec3 sun_sha_pen = vec3(sun_sha,\n                                mix( sun_sha, sun_sha*sun_sha, 0.5 ),\n                                sun_sha*sun_sha); // for orangey penumbras.\n        float sun_spe = ks*pow( clamp(dot(nor,sun_hal),0.0,1.0), 8.0 )*sun_dif\n                          *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0,1.0 );\n        float sky_ref = smoothstep( 0.0,1.5/ks, reflect(rd,nor).y );\n        float bou_dif = clamp( 0.01 + 0.99*dot(nor,vec3(0.0,-1.0,0.0)), 0.0,1.0 );\n        float fre = clamp( 1.0 + dot(rd,nor), 0.0,1.0 );\n\n        // Check if the guy is generally in shadow (so we can reduce\n        // sss when he is. And only apply this to the guy's body, not\n        // the whole scene!\n        // (Previously it was being applied when he looked down :D\n        // and it made the whole terrain flicker when applied D: )\n        float guy_sha = 1.0;\n        if (tm.y > 1.5 && tm.y <= 2.5) {\n        float itime = floor(atime);\n        float ftime = fract(atime);\n        float y = 4.0*ftime*(1.0 - ftime);\n        float x = -1.0+2.0*abs(fract(0.5*atime) - 0.5)/0.5;\n        vec3 cen = vec3( x*0.4,\n                         pow(y,2.0-y)+0.15,\n                         itime+pow(ftime,0.7) );\n        // offset the body raycast by a bunch to prevent it intersecting\n        // the body/head. We only want to consider environment shadows!\n        guy_sha = castShadow( cen+0.8*sun_dir, sun_dir, atime );\n        }\n\n        // diffuse (sun, sky, bounce)\n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(9.1,6.0,2.2)*sun_sha_pen;\n        lin += 1.5*sky_dif*vec3(0.5,0.8,3.9)*occ;\n        lin += 0.75*bou_dif*vec3(0.3,1.08,0.2)*occ;\n        // fake sss\n        lin += 2.0*fre*vec3(1.5,0.5,0.4)\n                  *(0.5+0.5*sun_dif) // reduce a little in unlit areas.\n                  *(0.15+0.85*guy_sha) // reduce a lot when guy in shadow.\n                  *(0.5+0.5*tm.z); // reduce a ton when in forced-occlusion places.\n        col = al*lin;\n\n        // specular\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        col += sky_ref*0.1*vec3(0.6,0.9,2.0)*sky_dif*occ;\n\n        // haze\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp(-0.00005*t*t*t) );\n\n#if COLOR_GRADING\n        // Inigo hack: boost reds in the lighting colours.\n        // Like a curves adjustment. Artistic more than realistic.\n        col = pow( col, vec3(0.8,0.9,1.0) );\n#endif\n\n//        col = vec3(tm.z*tm.z);\n//        col = vec3(occ*occ);\n//        col = vec3( guy_sha );\n        }\n\n    // Convert to gamma space.\n    col = pow( col, vec3(0.4545) );\n\n#if COLOR_GRADING\n    // Exposure and contrast adjustment:\n    // (Normally would do this in linear space, but this s-curve is only\n    // good between 0 and 1.)\n    col = clamp( 1.05*col, 0.0,1.0 ); // 5% exposure gain & clamp to prevent burn.\n    vec3 contrasty = col*col*(3.0 - 2.0*col); // shallow s-curve.\n    col = mix( col, contrasty, 0.25 ); // Just use a bit of the contrasty colours.\n#endif\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKXDV.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[280, 345, 366, 366, 482], [484, 484, 529, 529, 685], [687, 687, 729, 729, 761], [763, 763, 827, 827, 989], [991, 991, 1035, 1035, 1132], [1134, 1134, 1181, 1181, 1258], [1260, 1260, 1307, 1307, 1384], [1386, 1386, 1497, 1497, 8555], [8557, 8557, 8669, 8669, 15334], [15336, 15336, 15393, 15393, 17966], [17968, 17968, 18026, 18026, 20179], [20181, 20181, 20219, 20219, 21807], [21809, 21809, 21854, 21854, 22116], [22118, 22118, 22180, 22180, 22475], [22477, 22477, 22534, 22534, 23221], [23223, 23223, 23276, 23276, 23607], [23609, 23609, 23646, 23678, 24256], [24258, 24258, 24296, 24328, 24899], [24901, 24901, 24933, 24975, 25286], [25288, 25288, 25343, 25343, 35146], [35149, 35149, 35205, 35205, 43169]], "test": "untested"}
{"id": "wsKXRK", "name": "VDropTunnel", "author": "Del", "description": "VDrop2 -> Tunnel remix - left mouse = warp speed", "tags": ["2d", "tunnel", "starfield", "drops"], "likes": 26, "viewed": 948, "published": "Public API", "date": "1574466595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// V-Drop - Del 19/11/2019 - (Tunnel mix - Enjoy)\n// vertical version: https://www.shadertoy.com/view/tdGXWm\n#define PI 3.14159\n\nfloat vDrop(vec2 uv,float t)\n{\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p)+0.1;\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    if (iMouse.z>0.5)\n    \tp.y *= 0.5;\n    float t =  iTime*0.4;\n    vec3 col = vec3(1.55,0.65,.225) * vDrop(p,t);\t// red\n    col += vec3(0.55,0.75,1.225) * vDrop(p,t+0.33);\t// blue\n    col += vec3(0.45,1.15,0.425) * vDrop(p,t+0.66);\t// green\n\tfragColor = vec4(col*(d*d), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 129, 159, 159, 607], [609, 609, 666, 666, 1084]], "test": "untested"}
{"id": "WsKXRz", "name": "Random shader name ", "author": "Virg", "description": "asd", "tags": ["asd"], "likes": 0, "viewed": 70, "published": "Public", "date": "1573482318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cm = distance(iMouse.xy,fragCoord.xy)/iResolution.x;\n \tvec2 center = iResolution.xy/2.;\n    float dist = distance(center,fragCoord);\n    float cl;\n    float cr;\n    float R = iResolution.x/2.*((sin(iTime/3.)+2.)/2.)+iResolution.x/10.;\n    vec3 col=vec3((dist>R && dist<R+1.)?1.:0.);\n    cl = sqrt((R*R)-pow(fragCoord.y-center.y,2.));\n    cr = center.x+cl;\n    cl = center.x-cl;\n    cl = abs(fragCoord.x+cl)/iResolution.x;\n    cr = abs(fragCoord.x+cr)/iResolution.x;\n    fragColor = vec4(cm,cl,cr,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 571]], "test": "untested"}
{"id": "wsKXWy", "name": "AntiBall", "author": "SugarRushLux", "description": "Black and white ocean scene", "tags": ["procedural"], "likes": 3, "viewed": 146, "published": "Public", "date": "1574927548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p)\n{\n\tp = fract(p*vec2(234.34, 1311.12));\n    p += dot(p, p+211.42);  \n    return fract(p.x*p.y);\n}\n\n\nvec3 bubbles(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    uv *= 100.0;\n\n    vec2 gv = fract(uv);  \n    vec2 id = floor(uv);\n\n    uv += iTime;\n\n    float n = Hash21(id);\n\n    if(n < 0.01)\n    {\n    \treturn col = vec3(smoothstep(0.6, 0.60000001, length(gv - 0.5) * -1.0 + 1.0));\n\n    }\n\n}\n\n\nfloat circle(vec2 uv, float r)\n{\n\treturn smoothstep(r, r-0.00001, length(uv));\n}\n\n\n#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV and ST Coords\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 st = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    \n    \n    //Warping ST Coords\n    st *= -2.0;\n    st.x += iTime*0.2;\n    float bounce = iTime*0.2;\n    \n    float cd;\n    float freq = 2.0;\n    float wind;\n    \n    st.y *= 10.0;\n    st.y += cos(st.x * (PI * freq))*-1.0;\n    \n    //Creating Ocean\n    if(st.y < 0.0) cd = 1.0;\n    //Creating Wind\n    st.y += 3.0;\n    if(st.y > 1.0 && st.y < 1.11) wind = 1.0;\n    wind *= cos(uv.x * 3.2 + 0.1 + iTime);\n    st.y += 2.0;\n    uv.x += 2.0;\n    if(st.y > 1.0 && st.y < 1.1) wind += 1.0;\n    wind *= cos(uv.x * 4.3 + 0.1 + iTime)*2.0;\n    st.y += 2.0;\n    uv.x += 3.0;\n    if(st.y > 1.0 && st.y < 1.09) wind += 1.0;\n    wind *= cos(uv.x * 5.1 + 0.1 + iTime)*4.0;\n    st.y += 2.0;\n    uv.x += 4.0;\n    if(st.y > 1.0 && st.y < 1.08) wind += 1.0;\n    wind *= cos(uv.x * 2.6 + 0.1 + iTime)*6.0;\n    \n   \n    uv.x -= 9.0;\n    \n    \n    //Creating Bubbles\n    vec3 bubble = \n    \t bubbles(vec2(uv.y + (cos(bounce * freq * PI) * 0.02 + 0.6), uv.x));\n    \n    //FloatingBall\n \tuv *= 22.0;\n    uv.y += cos(bounce * freq * PI);\n    float c = circle(uv, 1.0);\n    \n    //Masking\n    vec3 wave = vec3(cd);\n    vec3 ballT = clamp(vec3((wave * -1.0 + 1.0 / c)*-1.0 + 1.0), 0., 1.);\n    vec3 ballB = clamp(vec3(c - cd), 0., 1.);\n    bubble = vec3(clamp(bubble.x + wave.x, 0.0, 1.0));\n    \n    vec3 col = vec3(bubble - ballT + ballB - vec3(wind));\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 117], [120, 120, 143, 143, 402], [405, 405, 437, 437, 485], [511, 511, 568, 591, 2112]], "test": "untested"}
{"id": "wstSDj", "name": "snowflake", "author": "mahalis", "description": "another Nodevember project, for the theme “snow”. original plan was something elaborately procedural, placing cutouts along branches etc., and then some bad SDF math in the first part I put together ended up making cool patterns all on its own. go figure.", "tags": ["ice", "snowflake", "nodevember"], "likes": 4, "viewed": 593, "published": "Public API", "date": "1572925885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// license: CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\nvec2 r(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nvec2 opReflect(vec2 v, vec2 normal) {\n\tv -= 2. * min(0., dot(v, normal)) * normal;\n\treturn v;\n}\n\nconst vec2 axisH = vec2(0,1);\nconst vec2 axisV = normalize(vec2(-sqrt(3.), 1));\nconst vec2 axisH2 = vec2(-axisV.x, axisV.y);\n\n// this does not work as intended, but the result looks interesting enough and I don’t have time to debug it\nfloat sdHexBox(vec2 position, vec2 halfSize) {\n\tvec2 absPosition = abs(position);\nreturn max(dot(absPosition, axisH) - halfSize.y, dot(absPosition, axisV) - halfSize.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat t = iTime * 2.;\n\n\tvec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n\tuv = r(uv, t * 0.05);\n\tconst int segmentCount = 12;\n\tfor (int i = 0; i < segmentCount; i++) {\n\t\tfloat angle = 6.2832 * float(i) / float(segmentCount);\n\t\tuv = opReflect(uv, -vec2(cos(angle), sin(angle)));\n\t}\n    \n\tfloat dist = dot(uv, axisH) - 0.08; // core\n\t\n\tfloat hexRadius1 = cos(t * 0.13) * 0.06 + 0.25;\n\tfloat hexDistance1 = sdHexBox(uv - vec2(sin(t * 0.43) * 0.05 + 0.05,hexRadius1), vec2(0.002,0.03 + cos(t * 0.31) * 0.005));\n\n\tfloat hexRadius2 = cos(t * 0.18 + 0.1) * 0.1 + 0.15;\n\tfloat hexDistance2 = sdHexBox(uv - vec2(sin(t * 0.51 + 0.2) * 0.04 + 0.04, hexRadius2), vec2(0.002,0.03 + cos(t * 0.35 + 1.) * 0.01));\n\n\tfloat hexRadius3 = cos(t * 0.21 + 0.2) * 0.05 + 0.2;\n\tfloat hexDistance3 = sdHexBox(uv - vec2(sin(t * 0.61 + 0.4) * 0.04 + 0.06, hexRadius3), vec2(0.002,0.03));\n\n\tdist = min(dist, min(hexDistance1, min(hexDistance2, hexDistance3)));\n\n\tdist = min(dist, max(dot(uv, axisV) - 0.02, dot(uv, axisH) - max(hexRadius1,max(hexRadius2, hexRadius3)))); // arms\n\n\tfloat mask = smoothstep(fwidth(dist), 0., dist);\n\tfloat value = mask * pow(min(1.0,abs(dist + 0.2) * 5.), 60.);\n\n\tvec3 background = mix(vec3(0.1,0.6,0.7), vec3(0.1,0.2,0.5), length(uv) * 2.);\n\n\tvec3 refractedBackground = mix(vec3(0.,0.6,0.7), vec3(0.,0.2,0.5), min(1., length(uv) * 3.));\n\n\tfragColor = vec4(mix(background, value + refractedBackground, mask),1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstSDj.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 70, 95, 95, 196], [198, 198, 235, 235, 293], [421, 532, 578, 578, 703], [706, 706, 763, 763, 2195]], "test": "untested"}
{"id": "wstXDS", "name": "energized tentacles", "author": "julianlumia", "description": "not the most efficient code but still a cool doodle, OG bassed of https://www.shadertoy.com/view/XsByWd", "tags": ["twisty"], "likes": 3, "viewed": 142, "published": "Public", "date": "1572815744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\n\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\n\nvec2 path(float z){\n    float x = sin(z) - 1.0 * cos(z * 1.) - 4. * sin(z * 0.12345);\n    float y = cos(z) - 1. * sin(z * 1.) - 1. * cos(z * 2.12345);\n    return vec2(x,y);\n}\n\nvec2 path2(float z){\n    float x = sin(z) + 1.0 * cos(z * 1.) + .2 * sin(z * 0.12345);\n    float y = cos(z) + 1. * sin(z * 1.) + .5 * cos(z * 2.12345);\n    return vec2(x,y);\n}\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat GetDist (vec3 p)\n{\n\n    vec3 q =p;    \n    vec2 o = path(p.z) /5.0;\n    p = vec3(p.x,p.y,p.z)-vec3(o.x,o.y,0.);\n    vec2   o2 = path2(p.z) / 5.0;\n    q = vec3(q.x,q.y,q.z)-vec3(o2.x,o2.y,0.);\n    p.xy *= rz2(p.z*0.3)*0.7;\n    q.xy *= rz2(q.z*0.1)*.5;\n    p.zy = mod(p.zy ,5.) - 2.5;\n    q.zy = mod(q.zy ,5.) - 2.5;\n    q.zx = mod(q.zx ,5.) - 2.5;   \n    p.xy *= rz2(p.z*sin(t*.3+250.)*2.); \n    q.xy *= rz2(q.z*sin(-t*0.02+250.));\n    float cyl2wave = .3+1.5*(sin(p.z+t*0.5)*.1);\n    float cylfade = 2.-smoothstep(.0,8.,abs(p.z));\n    float cyl2r = 0.02*cyl2wave*cylfade;\n    float cylT = 1.;\n    float cylC = 1.;\n    vec2 cyl2p = modA(p.xy, 8.)-vec2(cyl2wave, 0)*cylfade;\n    float cyl2 = cyl(cyl2p, cyl2r);\n    cyl2p = modA(p.xy*rz2(-p.z*cylT), cylC)-vec2(cyl2wave, 0)*cylfade;\n    vec3 cubP = p;\n    float cubC = 0.1;\n    cubP.z = mod(cubP.z, cubC)-cubC*1.;\n    cubP.xy *= rz2(t*3.);\n    float cyl2a = smin(cyl2, cube(cubP,vec3(.1*cyl2wave*cylfade)),.5);\n    cyl2wave = .3+1.5*(sin(q.z+t*0.5)*.2);\n    cylfade = 2.-smoothstep(.0,8.,abs(q.z));\n    cyl2r = 0.06*cyl2wave*cylfade;\n    cylT = 1.;\n    cylC = 1.;\n    cyl2p = modA(q.xy, (abs(sin(t*0.1)+3.)))-vec2(cyl2wave, 0)*cylfade;\n    cyl2 = cyl(cyl2p, cyl2r);\n    cyl2p = modA(q.xy*rz2(-q.z*cylT), cylC)-vec2(cyl2wave, 0)*cylfade;\n    cubP = q;\n    cubC = 0.1;\n    cubP.z = mod(cubP.z, cubC)-cubC*1.;\n    cubP.xy *= rz2(t*3.);  \n    float cyl22 = smin(cyl2, cube(cubP,vec3(.1*cyl2wave*cylfade)),.5);\n\treturn smin(cyl2a,cyl22,0.1)*.6;\n}\n\nfloat marchCount;\n\nfloat RayMarch (vec3 ro, vec3 rd) \n{\n float dO = 0.;        \n marchCount = 0.0;\n for (int i=0; i<68; i++) \n  {\n   vec3 p = ro + dO * rd;\n   float dS = GetDist (p);\n   dO += dS;\n   if (dS<0.001 || abs(dO)>100.) break;\n   marchCount+= 2./dS*.0009;\n  }\n return dO;\n}\n \nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.1,0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n    \tGetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);    \n    vec3 ro = vec3(0.,0.,-t*2.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,.8));\n    float the = iTime *0.1;\n    rd.yx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    float d = RayMarch (ro,rd);\n    vec3 p = ro + rd *d;\n\tfloat fog = 1. / (2. + d * d *.1);\n    vec3 fc = vec3(fog);\n   fc *= marchCount * vec3(1., (sin(t +-p.z)*.5),(tan(t +-p.z)*.5));\n    fc *= vec3(fog);\n    vec3 sky = vec3(0., .1, 0.1);\n    fc = mix(sky, fc, 1.5/(d*d/1./1.*.01));\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 74, 74, 125], [126, 126, 155, 155, 177], [178, 178, 207, 207, 242], [244, 244, 263, 263, 418], [420, 420, 440, 440, 595], [597, 597, 630, 630, 761], [762, 762, 802, 802, 884], [886, 886, 910, 910, 2380], [2401, 2401, 2437, 2437, 2664], [2667, 2667, 2690, 2690, 2873], [2875, 2875, 2932, 2932, 3530]], "test": "untested"}
{"id": "WstXWS", "name": "Codevember01 - Contrast", "author": "z0rg", "description": "Contrast shader for codevember01", "tags": ["2d", "contrast", "codevember"], "likes": 5, "viewed": 133, "published": "Public API", "date": "1572782600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat sat(float a)\n{\n  return clamp(a,0.0,1.0);\n}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nvec3 negate(vec3 col, bool yes)\n{\n  if (yes)\n     return vec3(1.)-col;\n  return col;\n}\n\nbool range(float a, float mi, float ma)\n{\n  return a > mi && a <ma;\n}\n\nvec3 drawCircle(vec2 uv, vec2 pos, float rad)\n{\n  vec3 col;\n  col += vec3(0.5,0.,0.34);\n  if (rad<0.)\n    col = vec3(1.)-col;\n    rad = abs(rad);\n  float thick = 0.01;\n  return col*float(range(length(uv-pos), rad-thick, rad));\n}\n\nvec3 drawCir(vec2 uv, vec2 pos, float rad, float diag)\n{\n  uv = uv-pos;\n\n  float luv = mix(length(uv),lenny(uv),(0.5+0.5*sin(iTime))*diag);\n  float grad = (abs(luv - rad)/0.15);\n  vec3 col = vec3(pow(sat(1.-grad),5.))*vec3(1.);\n  float a = atan(uv.y,uv.x)/PI;\n  col += (luv/rad)*1000.*pow(abs(mod((0.3*iTime*PI+(luv*2.*PI)+a+sin(75.*pow(luv,4.2)+15.*iTime+a)*0.05),0.1)-0.05),2.5)*float(luv <rad);\n  return col;\n}\n\nvec3 rdrMain(vec2 uv)\n{\n  vec3 colGrad = vec3(0.45,0.34,0.78).yzz;\n  vec3 acc;\n\n  acc = mix(colGrad, vec3(0.3), 1.-length(uv));\n  acc *=min(pow(max(length(uv),0.1),3.5),1.);\n  acc += drawCir(uv, vec2(sin(iTime)*0.2,0.15*cos(iTime*0.4)),(0.4*sin(iTime)+0.6),1.);\n  return acc;\n}\n\nvec3 rdrLines(vec2 uv)\n{\n  const int lines = 16;\n  vec3 acc;\n\n  for (int i = 0; i< lines;++i)\n  {\n    float fi = float(i);\n    vec2 pos= vec2(rand(vec2(fi, 8.-fi)), rand(vec2(8.-fi,fi)));\n    pos-= vec2(0.5);\n    pos += (fi/8.)*vec2(sin(iTime*fi/8.),cos(iTime));\n    acc += drawCir(uv, pos,0.05*max(1.-pos.x,0.2),0.)*vec3(fi/12.,pos.y,fi/7.);\n  }\n  return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n  uv *= 2.5;\n\n\n  vec3 col = rdrMain(uv);\n  float inMask = float(uv.y< (sin(uv.x*10.+iTime*3.)*0.05+0.3*sin(iTime+uv.x)));\n  col = negate(col,bool(inMask));\n  col *= 1.-pow(length(uv),2.5);\n  col += rdrLines(uv);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstXWS.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 427, 447, 447, 515], [517, 517, 537, 537, 566], [568, 568, 589, 589, 619], [621, 621, 654, 654, 707], [709, 709, 750, 750, 778], [780, 780, 827, 827, 1008], [1010, 1010, 1066, 1066, 1423], [1425, 1425, 1448, 1448, 1702], [1704, 1704, 1728, 1728, 2066], [2068, 2068, 2125, 2125, 2490]], "test": "untested"}
{"id": "wstXzs", "name": "ShaderTober - Injured", "author": "Flopine", "description": "A small doodle with inktober's theme \"Injured\"", "tags": ["raymarching", "red", "inktober"], "likes": 10, "viewed": 118, "published": "Public", "date": "1572707957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define ITER 100.\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(14.4,16.5)))*1245.4);}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id)>= rep*.5) id = abs(id);\n    return id;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat stem_id;\nfloat stem (vec3 p)\n{\n    p.xz *= rot(p.y-iTime);\n    stem_id = moda(p.xz, 5.);\n    p.x -= (p.y >= 0.) ? 0.15+p.y*0.2 : 0.15;\n    return cyl(p.xzy, 0.1-p.y*0.02, 4.);\n}\n\nfloat spi (vec3 p)\n{\n    p.y -= p.x*p.x*0.2;\n    p.x -= 1.;\n    return cyl(p.yzx, 0.05-p.x*0.1, 1.);\n}\n\nfloat spikes (vec3 p)\n{\n    float d = 1e10;\n    for (int i=0; i<6;i++)\n    {\n        float ratio = float(i)/4.;\n        p.y += .6;\n        p.xz *= rot(PI/3.);\n        d = min(d, spi(p));\n    }\n    return d;\n}\n\nfloat g1 = 0.;\nfloat flower(vec3 p)\n{\n    p *= 1.5;\n    p.y -= 6.;\n    mo(p.xy, vec2(0.5));\n    mo(p.xz, vec2(.5));\n    p.yz *= rot(iTime);\n    p.x -= .8;\n    float d = box(p, vec3(.05-sin(p.y-.5),1.,0.05));\n    g1 += 0.1/(0.1+d*d);\n    return d/1.5;\n}\n\nint mat_id;\nfloat SDF(vec3 p)\n{\n    float g = abs(p.y+4.5+sin(length(p.xz)-iTime)*0.1)-0.1;\n    float sp = spikes(p);\n    float f = flower(p);\n    float st = stem(p);\n\n    float d = min(min(sp,f),min(st,g));\n\n    if (d == g) mat_id = 1;\n    if (d == sp) mat_id = 2;\n    if (d == f) mat_id = 3;\n    if (d == st) mat_id = 4;\n\n    return d;\n}\n\nvec3 getcam (vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 f = normalize(ta-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l)); \n    return normalize(f*0.8 + l*uv.x + u*uv.y);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy), SDF(p-eps.yxy), SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(2.,5.,-3.2),\n        p = ro,\n        ta = vec3(-1.8,2.,0.),\n        rd = getcam(ro,ta,uv),\n        col = vec3(0.);\n\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.4 + dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n\n        if (mat_id == 1)\n        {    \n            vec3 l_blood = vec3(-2.,5.,-3.);\n            vec3 h = normalize(l_blood-rd);\n            vec3 albedo = vec3(0.3,0.,0.);        \n            vec3 fre = pow(clamp(1.-dot(n,-rd),0.,1.), 4.) * vec3(0.8,0.5,0.7);       \n            float spe = pow(max(0.,dot(h,n)),22.);\n\n            col = albedo+fre+spe*3.;\n        }\n\n        if (mat_id == 2)\n        {\n            col = vec3(abs(p.x*2.),0.1,0.0);\n        }\n\n        if (mat_id == 3)\n        {\n            vec3 albedo = vec3(length(p)*0.15,0.1,0.0);\n\n            vec3 l_flower = vec3(0.,2.,-2.);\n            vec3 h = normalize(l_flower-rd);\n            float spe = pow(max(0.,dot(h,n)),5.);\n\n            col = albedo+spe;\n        }\n\n        if (mat_id == 4)\n        {\n            col = vec3(.8,abs(stem_id)*0.2,abs(stem_id)*0.1);\n        } \n        col *= 1.-shad;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 351, 374, 374, 424], [426, 426, 445, 445, 488], [490, 490, 528, 528, 757], [759, 759, 791, 791, 838], [840, 840, 877, 877, 916], [918, 918, 946, 946, 979], [996, 996, 1017, 1017, 1164], [1166, 1166, 1186, 1186, 1268], [1270, 1270, 1293, 1293, 1478], [1495, 1495, 1517, 1517, 1732], [1746, 1746, 1765, 1765, 2073], [2075, 2075, 2116, 2116, 2282], [2284, 2284, 2307, 2307, 2422], [2424, 2424, 2481, 2481, 3962]], "test": "untested"}
{"id": "wsVSzc", "name": "Hypercube with 4D rotation", "author": "tomoe", "description": "4D raymarching", "tags": ["raymarching", "4d", "hypercube"], "likes": 5, "viewed": 294, "published": "Public API", "date": "1574674598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define INFTY 1e6\nfloat wireHypCube(vec4 p) {\n    vec4 q = abs(p) - 0.5;\n    vec4 r = -1.0 * min(q, 0.0);\n    // minVal < midVal < maxVal among {x,y,z}\n    float minVal = min(r.x, min(r.y, r.z));\n    float maxVal = max(r.x, max(r.y, r.z));\n    float midVal = min(max(r.x, r.y), min(max(r.y, r.z), max(r.z, r.x)));\n    // val4 < val3 < val2 < val1 among {x,y,z,w}\n    float val4 = min(minVal, r.w);\n    float val1 = max(maxVal, r.w);\n    float val2 = max(midVal, min(maxVal, r.w));\n    float val3 = min(midVal, max(minVal, r.w));\n    // distance to the closest boundary component\n    return sqrt(pow(length(max(q, 0.0)), 2.0) + pow(val4, 2.0) + pow(val3, 2.0));\n}\nfloat surfaceSDF(vec4 p)\n{\n    float edge = 0.01;\t// thickness of edge\n    return wireHypCube(p) - edge;\t// suggested by iapafoto\n}\nfloat getAngle(vec4 p, vec4 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nvec4 getNormal(vec4 p) {\n    float d = EPSILON;\n    return normalize(vec4(\n            surfaceSDF(p + vec4(d, 0.0, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec4(0.0, d, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec4(0.0, 0.0, d, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec4(0.0, 0.0, 0.0, d)) - surfaceSDF(p)\n        ));\n    }\n    mat4 rotXW(float t) {\n        return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, cos(t), sin(t), 0.0,\n            0.0, - sin(t), cos(t), 0.0,\n            0.0, 0.0, 0.0, 1.0\n        );\n    }\n    mat4 rotXY(float t) {\n        return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, cos(t), sin(t),\n            0.0, 0.0, - sin(t), cos(t)\n        );\n    }\n    mat4 rotXZ(float t) {\n        return mat4(\n            1.0, 0.0, 0.0, 0.0,\n            0.0, cos(t), 0.0, sin(t),\n            0.0, 0.0, 1.0, 0.0,\n            0.0, - sin(t), 0.0, cos(t)\n        );\n    }\n    mat4 rotYZ(float t) {\n        return mat4(\n            cos(t), 0.0, 0.0, sin(t),\n            0.0, 1.0, 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            - sin(t), 0.0, 0.0, cos(t)\n        );\n    }\n    mat4 rotYW(float t) {\n        return mat4(\n            cos(t), 0.0, sin(t), 0.0,\n            0.0, 1.0, 0.0, 0.0,\n            - sin(t), 0.0, cos(t), 0.0,\n            0.0, 0.0, 0.0, 1.0\n        );\n    }\n    mat4 rotZW(float t) {\n        return mat4(\n            cos(t), sin(t), 0.0, 0.0,\n            - sin(t), cos(t), 0.0, 0.0,\n            0.0, 0.0, 1.0, 0.0,\n            0.0, 0.0, 0.0, 1.0\n        );\n    }\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec4 lightDir = vec4(0.0, 4.0, 1.0, 0.0);\n        \n        // fragment position\n        vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n        // camera\n        vec4 cPos = vec4(0.0, 0.0, 2.0, 0.0);\n        vec4 cDir = vec4(0.0, - 0.0, - 1.0, 0.0);\n        vec4 cUp = vec4(0.0, 1.0, 0.0, 0.0);\n        vec4 cSide = vec4(1.0, 0.0, 0.0, 0.0);\n        float targetDepth = 1.0;\n        float t = iTime * 0.3;\n        mat4 g = rotXZ(t) * rotZW(t) * rotXY(t) * rotYZ(t);\n        cPos = g * cPos;\n        cDir = g * cDir;\n        cUp = g * cUp;\n        cSide = g * cSide;\n        lightDir = g * lightDir;\n        \n        // ray\n        vec4 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n        float ang = getAngle(ray, - normalize(cPos));\n        vec4 rPos = cPos + ray;\n        \n        // marching loop\n        for(int i = 0; i < 20; i ++ ) {\n            rPos += surfaceSDF(rPos) * ray;\n            if (surfaceSDF(rPos) < 0.01) {\n                break;\n            }\n        }\n        vec4 normal = getNormal(rPos);\n        float diff = clamp(dot(normalize(lightDir - rPos), normal), 0.01, 1.0);\n        \n        // hit check\n        if (surfaceSDF(rPos) < 0.01) {\n            fragColor = vec4(diff * vec3(rPos.x, 1.0, rPos.p), 1.0);\n        } else {\n            fragColor = vec4(vec3(1.0, 1.0, 1.0), 1.0);\n        }\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 91, 91, 708], [709, 709, 735, 735, 840], [841, 841, 873, 873, 925], [926, 926, 950, 950, 1289], [1294, 1294, 1315, 1315, 1494], [1499, 1499, 1520, 1520, 1699], [1704, 1704, 1725, 1725, 1904], [1909, 1909, 1930, 1930, 2109], [2114, 2114, 2135, 2135, 2314], [2319, 2319, 2340, 2340, 2519], [2524, 2524, 2579, 2579, 3971]], "test": "untested"}
{"id": "wsVSzh", "name": "Lennard-Jones black holes", "author": "Roninkoi", "description": "Just playing around with the Lennard-Jones potential. Kind of reminds me of black holes!", "tags": ["blackhole", "lennardjones"], "likes": 3, "viewed": 104, "published": "Public", "date": "1573457957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2. * uv - 1.;\n    uv.y *= iResolution.y/iResolution.x; // [-1, 1] -> circ\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float a = iTime;\n    \n    x = cos(a) * uv.x - sin(a) * uv.y; // rotation\n    y = sin(a) * uv.x + cos(a) * uv.y;\n    \n    x -= 0.4 + sin(a) * 0.1;\n    float r1 = sqrt(x*x + y*y);\n    r1 += sin(3. * atan(x, y) + a * 5.) * 0.00651 * \n        sin(a * 8.) * \n        sin(a * 7. + 0.74);\n    r1 *= 2.7;\n    \n    x += 0.8 + sin(a) * 0.1;\n    \n    float r2 = sqrt(x*x + y*y);\n    r2 += sin(3. * atan(x, y) + a * 5.) * 0.00651 * \n        sin(a * 8.) * \n        sin(a * 7. + 0.74);\n    r2 *= 2.6;\n    \n    float r = r1 * r2;\n    \n    float epsilon = 1.;\n    float m = 1.;\n    float z = epsilon*(pow(m/r, 12.) - 2. * pow(m/r, 6.) + 1.); // Lennard-Jones potential\n    \n    vec3 col = vec3(1.);\n    \n    float q = z * 2. + 0.8;\n    vec3 cm = vec3(\n        sin(q), sin(q + PI / 3.0), sin(q + 2. * (PI / 3.0)) // colors\n    );\n    cm = normalize(cm);\n    cm = cm * 0.5 + vec3(0.5);\n    col *= cm;\n    \n    col /= exp(z*r);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 79, 79, 1200]], "test": "untested"}
{"id": "wsVSzm", "name": "Tengwar Annatar", "author": "vegardno", "description": "Fast font compilation -- as opposed to most vector fonts done with GLSL, this compiles really fast (<.1 sec on my Intel onboard graphics) by using arrays instead of straight code.\n\nOriginal font: https://www.dafont.com/tengwar-annatar.font", "tags": ["font", "elven", "elvish"], "likes": 11, "viewed": 181, "published": "Public", "date": "1573713050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 points[1395] = vec2[](\n    vec2(-968., 1573.),\n    vec2(-933., 1636.),\n    vec2(-907., 1640.),\n    vec2(-805., 1490.),\n    vec2(-795., 1390.),\n    vec2(-844., 1190.),\n    vec2(-876., 1228.),\n    vec2(-899., 1363.),\n    vec2(-952., 1519.),\n    vec2(-968., 1573.),\n    vec2(-968., 1573.),\n    vec2(-764., 1337.),\n    vec2(-741., 1545.),\n    vec2(-637., 1773.),\n    vec2(-625., 1774.),\n    vec2(-575., 1749.),\n    vec2(-558., 1693.),\n    vec2(-667., 1400.),\n    vec2(-702., 1328.),\n    vec2(-735., 1303.),\n    vec2(-762., 1322.),\n    vec2(-764., 1337.),\n    vec2(-764., 1337.),\n    vec2(-718., 1211.),\n    vec2(-606., 1409.),\n    vec2(-576., 1448.),\n    vec2(-459., 1547.),\n    vec2(-444., 1548.),\n    vec2(-391., 1509.),\n    vec2(-387., 1488.),\n    vec2(-461., 1383.),\n    vec2(-584., 1276.),\n    vec2(-640., 1219.),\n    vec2(-691., 1183.),\n    vec2(-717., 1205.),\n    vec2(-718., 1211.),\n    vec2(-718., 1211.),\n    vec2(-757., 1301.),\n    vec2(-694., 1468.),\n    vec2(-611., 1633.),\n    vec2(-572., 1649.),\n    vec2(-529., 1618.),\n    vec2(-527., 1601.),\n    vec2(-608., 1442.),\n    vec2(-696., 1312.),\n    vec2(-727., 1278.),\n    vec2(-736., 1276.),\n    vec2(-757., 1301.),\n    vec2(-757., 1301.),\n    vec2(-940., -1703.),\n    vec2(-879., -1617.),\n    vec2(-813., -1567.),\n    vec2(66., -830.),\n    vec2(343., -342.),\n    vec2(352., -264.),\n    vec2(274., -67.),\n    vec2(127., -7.),\n    vec2(26., -38.),\n    vec2(-37., -75.),\n    vec2(-51., -79.),\n    vec2(-69., -64.),\n    vec2(-18., 15.),\n    vec2(194., 143.),\n    vec2(470., 280.),\n    vec2(525., 328.),\n    vec2(575., 460.),\n    vec2(491., 670.),\n    vec2(259., 763.),\n    vec2(109., 755.),\n    vec2(-118., 640.),\n    vec2(-227., 575.),\n    vec2(-243., 588.),\n    vec2(-136., 719.),\n    vec2(63., 855.),\n    vec2(321., 921.),\n    vec2(352., 923.),\n    vec2(413., 923.),\n    vec2(493., 916.),\n    vec2(690., 782.),\n    vec2(749., 593.),\n    vec2(608., 309.),\n    vec2(381., 129.),\n    vec2(526., -117.),\n    vec2(527., -131.),\n    vec2(382., -533.),\n    vec2(135., -863.),\n    vec2(-597., -1512.),\n    vec2(-884., -1704.),\n    vec2(-925., -1718.),\n    vec2(-940., -1703.),\n    vec2(-940., -1703.),\n    vec2(-1657., -2241.),\n    vec2(-1595., -2152.),\n    vec2(-1409., -1974.),\n    vec2(-1385., -1951.),\n    vec2(-60., -103.),\n    vec2(195., 478.),\n    vec2(216., 595.),\n    vec2(175., 713.),\n    vec2(93., 746.),\n    vec2(-91., 695.),\n    vec2(-142., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-120., 759.),\n    vec2(126., 894.),\n    vec2(212., 906.),\n    vec2(231., 907.),\n    vec2(323., 883.),\n    vec2(367., 828.),\n    vec2(390., 726.),\n    vec2(367., 599.),\n    vec2(399., 628.),\n    vec2(548., 751.),\n    vec2(875., 889.),\n    vec2(1086., 799.),\n    vec2(1179., 552.),\n    vec2(1074., 262.),\n    vec2(821., 35.),\n    vec2(623., -16.),\n    vec2(471., 77.),\n    vec2(470., 89.),\n    vec2(502., 173.),\n    vec2(605., 221.),\n    vec2(608., 221.),\n    vec2(685., 189.),\n    vec2(724., 154.),\n    vec2(770., 144.),\n    vec2(977., 283.),\n    vec2(1005., 421.),\n    vec2(913., 653.),\n    vec2(733., 728.),\n    vec2(434., 563.),\n    vec2(242., 266.),\n    vec2(-211., -565.),\n    vec2(-1111., -1768.),\n    vec2(-1205., -1869.),\n    vec2(-1462., -2122.),\n    vec2(-1564., -2215.),\n    vec2(-1642., -2255.),\n    vec2(-1657., -2241.),\n    vec2(-1657., -2241.),\n    vec2(-1657., -2241.),\n    vec2(-1595., -2152.),\n    vec2(-1409., -1974.),\n    vec2(-1385., -1951.),\n    vec2(-60., -103.),\n    vec2(195., 478.),\n    vec2(216., 595.),\n    vec2(175., 713.),\n    vec2(93., 746.),\n    vec2(-91., 695.),\n    vec2(-142., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-121., 758.),\n    vec2(122., 894.),\n    vec2(212., 906.),\n    vec2(224., 906.),\n    vec2(385., 780.),\n    vec2(390., 726.),\n    vec2(378., 636.),\n    vec2(375., 628.),\n    vec2(375., 627.),\n    vec2(431., 678.),\n    vec2(817., 888.),\n    vec2(1030., 767.),\n    vec2(1089., 600.),\n    vec2(1554., 888.),\n    vec2(1723., 815.),\n    vec2(1815., 640.),\n    vec2(1823., 558.),\n    vec2(1691., 220.),\n    vec2(1445., 20.),\n    vec2(1300., -17.),\n    vec2(1155., 44.),\n    vec2(1144., 90.),\n    vec2(1205., 197.),\n    vec2(1278., 221.),\n    vec2(1359., 187.),\n    vec2(1402., 152.),\n    vec2(1444., 143.),\n    vec2(1575., 202.),\n    vec2(1648., 435.),\n    vec2(1588., 624.),\n    vec2(1405., 729.),\n    vec2(1183., 594.),\n    vec2(1154., 554.),\n    vec2(1051., 370.),\n    vec2(933., 190.),\n    vec2(910., 165.),\n    vec2(569., -16.),\n    vec2(411., 89.),\n    vec2(439., 164.),\n    vec2(544., 221.),\n    vec2(547., 221.),\n    vec2(626., 188.),\n    vec2(668., 152.),\n    vec2(709., 143.),\n    vec2(814., 171.),\n    vec2(880., 269.),\n    vec2(916., 432.),\n    vec2(787., 690.),\n    vec2(671., 729.),\n    vec2(371., 500.),\n    vec2(244., 270.),\n    vec2(-213., -568.),\n    vec2(-1111., -1768.),\n    vec2(-1205., -1869.),\n    vec2(-1462., -2122.),\n    vec2(-1564., -2215.),\n    vec2(-1642., -2255.),\n    vec2(-1657., -2241.),\n    vec2(-1657., -2241.),\n    vec2(-35., -3.),\n    vec2(-16., 36.),\n    vec2(93., 217.),\n    vec2(173., 436.),\n    vec2(451., 1290.),\n    vec2(533., 1490.),\n    vec2(1025., 2272.),\n    vec2(1276., 2478.),\n    vec2(1290., 2465.),\n    vec2(1222., 2368.),\n    vec2(1116., 2263.),\n    vec2(1094., 2238.),\n    vec2(803., 1806.),\n    vec2(401., 730.),\n    vec2(361., 607.),\n    vec2(360., 597.),\n    vec2(421., 651.),\n    vec2(868., 888.),\n    vec2(1089., 791.),\n    vec2(1173., 557.),\n    vec2(1044., 227.),\n    vec2(783., 22.),\n    vec2(617., -16.),\n    vec2(467., 67.),\n    vec2(464., 89.),\n    vec2(508., 183.),\n    vec2(597., 221.),\n    vec2(677., 188.),\n    vec2(718., 154.),\n    vec2(766., 144.),\n    vec2(953., 248.),\n    vec2(973., 292.),\n    vec2(999., 426.),\n    vec2(895., 662.),\n    vec2(757., 727.),\n    vec2(726., 728.),\n    vec2(401., 527.),\n    vec2(236., 267.),\n    vec2(49., 14.),\n    vec2(-19., -16.),\n    vec2(-35., -3.),\n    vec2(-35., -3.),\n    vec2(-174., 675.),\n    vec2(-119., 761.),\n    vec2(135., 895.),\n    vec2(214., 906.),\n    vec2(243., 906.),\n    vec2(368., 825.),\n    vec2(389., 723.),\n    vec2(378., 634.),\n    vec2(376., 628.),\n    vec2(430., 678.),\n    vec2(776., 886.),\n    vec2(815., 888.),\n    vec2(1025., 771.),\n    vec2(1087., 599.),\n    vec2(1342., 820.),\n    vec2(1549., 889.),\n    vec2(1732., 804.),\n    vec2(1815., 637.),\n    vec2(1822., 564.),\n    vec2(1690., 220.),\n    vec2(1441., 19.),\n    vec2(1295., -16.),\n    vec2(1147., 62.),\n    vec2(1143., 90.),\n    vec2(1186., 183.),\n    vec2(1279., 221.),\n    vec2(1359., 187.),\n    vec2(1399., 152.),\n    vec2(1441., 143.),\n    vec2(1552., 178.),\n    vec2(1576., 204.),\n    vec2(1647., 430.),\n    vec2(1545., 670.),\n    vec2(1491., 708.),\n    vec2(1404., 729.),\n    vec2(1107., 481.),\n    vec2(1035., 343.),\n    vec2(980., 252.),\n    vec2(785., 61.),\n    vec2(605., -14.),\n    vec2(564., -16.),\n    vec2(412., 71.),\n    vec2(410., 90.),\n    vec2(454., 184.),\n    vec2(543., 221.),\n    vec2(627., 185.),\n    vec2(673., 149.),\n    vec2(701., 144.),\n    vec2(710., 144.),\n    vec2(843., 205.),\n    vec2(871., 251.),\n    vec2(914., 430.),\n    vec2(843., 640.),\n    vec2(776., 698.),\n    vec2(669., 729.),\n    vec2(367., 486.),\n    vec2(225., 241.),\n    vec2(157., 129.),\n    vec2(-3., -14.),\n    vec2(-20., -16.),\n    vec2(-36., -3.),\n    vec2(15., 78.),\n    vec2(37., 106.),\n    vec2(183., 435.),\n    vec2(215., 590.),\n    vec2(154., 729.),\n    vec2(94., 747.),\n    vec2(-90., 695.),\n    vec2(-143., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-174., 675.),\n    vec2(-174., 675.),\n    vec2(-119., 761.),\n    vec2(135., 895.),\n    vec2(214., 906.),\n    vec2(243., 906.),\n    vec2(368., 825.),\n    vec2(389., 723.),\n    vec2(369., 598.),\n    vec2(393., 621.),\n    vec2(634., 808.),\n    vec2(872., 889.),\n    vec2(1110., 768.),\n    vec2(1139., 722.),\n    vec2(1178., 567.),\n    vec2(1032., 207.),\n    vec2(870., 66.),\n    vec2(622., -16.),\n    vec2(473., 62.),\n    vec2(470., 89.),\n    vec2(515., 186.),\n    vec2(605., 221.),\n    vec2(685., 187.),\n    vec2(727., 151.),\n    vec2(765., 144.),\n    vec2(980., 290.),\n    vec2(1004., 426.),\n    vec2(893., 667.),\n    vec2(841., 702.),\n    vec2(729., 729.),\n    vec2(534., 653.),\n    vec2(492., 619.),\n    vec2(290., 358.),\n    vec2(194., 186.),\n    vec2(157., 129.),\n    vec2(-3., -14.),\n    vec2(-20., -16.),\n    vec2(-36., -3.),\n    vec2(15., 78.),\n    vec2(37., 106.),\n    vec2(183., 435.),\n    vec2(215., 590.),\n    vec2(154., 729.),\n    vec2(94., 747.),\n    vec2(-90., 695.),\n    vec2(-143., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-174., 675.),\n    vec2(-991., -1806.),\n    vec2(-900., -1690.),\n    vec2(448., -91.),\n    vec2(463., -66.),\n    vec2(288., 257.),\n    vec2(218., 530.),\n    vec2(109., 712.),\n    vec2(89., 722.),\n    vec2(55., 728.),\n    vec2(46., 728.),\n    vec2(-89., 679.),\n    vec2(-151., 645.),\n    vec2(-158., 644.),\n    vec2(-174., 657.),\n    vec2(-94., 766.),\n    vec2(122., 879.),\n    vec2(190., 888.),\n    vec2(349., 781.),\n    vec2(369., 740.),\n    vec2(522., 845.),\n    vec2(733., 906.),\n    vec2(912., 807.),\n    vec2(921., 734.),\n    vec2(609., -6.),\n    vec2(-702., -1602.),\n    vec2(-841., -1733.),\n    vec2(-978., -1819.),\n    vec2(-991., -1806.),\n    vec2(-991., -1806.),\n    vec2(394., 669.),\n    vec2(516., 244.),\n    vec2(579., 141.),\n    vec2(691., 383.),\n    vec2(747., 604.),\n    vec2(632., 743.),\n    vec2(579., 746.),\n    vec2(577., 746.),\n    vec2(394., 669.),\n    vec2(394., 669.),\n    vec2(-2068., -381.),\n    vec2(-2006., -297.),\n    vec2(-1724., -155.),\n    vec2(-1555., -134.),\n    vec2(-1206., -176.),\n    vec2(-897., -225.),\n    vec2(-800., -228.),\n    vec2(-503., -149.),\n    vec2(-449., -105.),\n    vec2(-414., -94.),\n    vec2(-402., -101.),\n    vec2(-483., -201.),\n    vec2(-838., -348.),\n    vec2(-914., -352.),\n    vec2(-1272., -308.),\n    vec2(-1612., -258.),\n    vec2(-1670., -257.),\n    vec2(-1967., -336.),\n    vec2(-2021., -380.),\n    vec2(-2057., -391.),\n    vec2(-2068., -381.),\n    vec2(-2068., -381.),\n    vec2(160., 436.),\n    vec2(184., 500.),\n    vec2(260., 537.),\n    vec2(351., 485.),\n    vec2(362., 436.),\n    vec2(313., 348.),\n    vec2(261., 336.),\n    vec2(172., 387.),\n    vec2(160., 436.),\n    vec2(160., 436.),\n    vec2(-893., -2089.),\n    vec2(-835., -2003.),\n    vec2(-553., -1742.),\n    vec2(-490., -1682.),\n    vec2(-255., -1447.),\n    vec2(48., -1112.),\n    vec2(231., -886.),\n    vec2(815., 123.),\n    vec2(854., 226.),\n    vec2(752., 141.),\n    vec2(423., -15.),\n    vec2(398., -16.),\n    vec2(177., 82.),\n    vec2(93., 312.),\n    vec2(233., 659.),\n    vec2(492., 855.),\n    vec2(640., 888.),\n    vec2(655., 888.),\n    vec2(800., 809.),\n    vec2(804., 776.),\n    vec2(743., 666.),\n    vec2(669., 642.),\n    vec2(587., 682.),\n    vec2(541., 722.),\n    vec2(514., 728.),\n    vec2(501., 728.),\n    vec2(290., 581.),\n    vec2(267., 446.),\n    vec2(353., 225.),\n    vec2(548., 144.),\n    vec2(802., 274.),\n    vec2(850., 325.),\n    vec2(933., 455.),\n    vec2(1084., 869.),\n    vec2(1213., 1245.),\n    vec2(1707., 2218.),\n    vec2(1888., 2433.),\n    vec2(2104., 2605.),\n    vec2(2120., 2591.),\n    vec2(2048., 2490.),\n    vec2(1960., 2404.),\n    vec2(1390., 1370.),\n    vec2(1265., 1009.),\n    vec2(1118., 587.),\n    vec2(904., 40.),\n    vec2(736., -285.),\n    vec2(-106., -1394.),\n    vec2(-157., -1448.),\n    vec2(-399., -1689.),\n    vec2(-747., -2016.),\n    vec2(-853., -2097.),\n    vec2(-879., -2102.),\n    vec2(-884., -2102.),\n    vec2(-893., -2089.),\n    vec2(-893., -2089.),\n    vec2(-481., 1576.),\n    vec2(-452., 1633.),\n    vec2(-424., 1640.),\n    vec2(-420., 1640.),\n    vec2(-317., 1483.),\n    vec2(-308., 1391.),\n    vec2(-357., 1190.),\n    vec2(-389., 1224.),\n    vec2(-410., 1358.),\n    vec2(-465., 1519.),\n    vec2(-481., 1576.),\n    vec2(-481., 1576.),\n    vec2(-276., 1338.),\n    vec2(-254., 1541.),\n    vec2(-145., 1773.),\n    vec2(-138., 1774.),\n    vec2(-79., 1734.),\n    vec2(-71., 1693.),\n    vec2(-170., 1425.),\n    vec2(-200., 1360.),\n    vec2(-248., 1303.),\n    vec2(-275., 1324.),\n    vec2(-276., 1338.),\n    vec2(-276., 1338.),\n    vec2(-230., 1214.),\n    vec2(-145., 1373.),\n    vec2(4., 1537.),\n    vec2(26., 1547.),\n    vec2(44., 1548.),\n    vec2(96., 1510.),\n    vec2(100., 1488.),\n    vec2(70., 1427.),\n    vec2(-25., 1338.),\n    vec2(-153., 1215.),\n    vec2(-203., 1183.),\n    vec2(-229., 1205.),\n    vec2(-230., 1214.),\n    vec2(-230., 1214.),\n    vec2(-620., 1576.),\n    vec2(-589., 1634.),\n    vec2(-559., 1640.),\n    vec2(-456., 1484.),\n    vec2(-447., 1390.),\n    vec2(-496., 1190.),\n    vec2(-529., 1229.),\n    vec2(-552., 1366.),\n    vec2(-604., 1519.),\n    vec2(-620., 1576.),\n    vec2(-620., 1576.),\n    vec2(-416., 1336.),\n    vec2(-394., 1539.),\n    vec2(-284., 1773.),\n    vec2(-277., 1774.),\n    vec2(-217., 1732.),\n    vec2(-210., 1693.),\n    vec2(-315., 1411.),\n    vec2(-353., 1328.),\n    vec2(-387., 1303.),\n    vec2(-414., 1323.),\n    vec2(-416., 1336.),\n    vec2(-416., 1336.),\n    vec2(-369., 1214.),\n    vec2(-307., 1339.),\n    vec2(-138., 1535.),\n    vec2(-96., 1548.),\n    vec2(-43., 1511.),\n    vec2(-39., 1488.),\n    vec2(-115., 1381.),\n    vec2(-242., 1269.),\n    vec2(-292., 1219.),\n    vec2(-342., 1183.),\n    vec2(-369., 1214.),\n    vec2(-369., 1214.),\n    vec2(-339., 1301.),\n    vec2(-339., 1304.),\n    vec2(-187., 1629.),\n    vec2(-148., 1647.),\n    vec2(-105., 1614.),\n    vec2(-103., 1598.),\n    vec2(-191., 1434.),\n    vec2(-281., 1308.),\n    vec2(-318., 1276.),\n    vec2(-339., 1301.),\n    vec2(-339., 1301.),\n    vec2(-589., 750.),\n    vec2(-408., 1117.),\n    vec2(-380., 1169.),\n    vec2(7., 1652.),\n    vec2(230., 1743.),\n    vec2(384., 1675.),\n    vec2(437., 1528.),\n    vec2(333., 1296.),\n    vec2(152., 1182.),\n    vec2(106., 1176.),\n    vec2(-14., 1232.),\n    vec2(-36., 1301.),\n    vec2(43., 1437.),\n    vec2(114., 1477.),\n    vec2(125., 1467.),\n    vec2(108., 1432.),\n    vec2(98., 1407.),\n    vec2(172., 1307.),\n    vec2(214., 1299.),\n    vec2(296., 1361.),\n    vec2(302., 1424.),\n    vec2(225., 1586.),\n    vec2(120., 1620.),\n    vec2(-223., 1297.),\n    vec2(-395., 963.),\n    vec2(-463., 832.),\n    vec2(-544., 754.),\n    vec2(-578., 741.),\n    vec2(-589., 750.),\n    vec2(-589., 750.),\n    vec2(-1580., 977.),\n    vec2(-1518., 1061.),\n    vec2(-1238., 1204.),\n    vec2(-1070., 1224.),\n    vec2(-713., 1181.),\n    vec2(-374., 1132.),\n    vec2(-311., 1130.),\n    vec2(-16., 1209.),\n    vec2(38., 1252.),\n    vec2(73., 1264.),\n    vec2(86., 1254.),\n    vec2(37., 1185.),\n    vec2(-334., 1012.),\n    vec2(-426., 1007.),\n    vec2(-791., 1051.),\n    vec2(-1118., 1099.),\n    vec2(-1182., 1101.),\n    vec2(-1478., 1023.),\n    vec2(-1533., 979.),\n    vec2(-1569., 967.),\n    vec2(-1580., 977.),\n    vec2(-1580., 977.),\n    vec2(-409., 1303.),\n    vec2(-329., 1518.),\n    vec2(-264., 1639.),\n    vec2(-230., 1653.),\n    vec2(-187., 1621.),\n    vec2(-184., 1602.),\n    vec2(-231., 1496.),\n    vec2(-251., 1462.),\n    vec2(-320., 1356.),\n    vec2(-358., 1296.),\n    vec2(-388., 1276.),\n    vec2(-409., 1303.),\n    vec2(-409., 1303.),\n    vec2(-293., -2089.),\n    vec2(-233., -1999.),\n    vec2(-116., -1894.),\n    vec2(47., -1742.),\n    vec2(110., -1682.),\n    vec2(345., -1447.),\n    vec2(648., -1112.),\n    vec2(831., -886.),\n    vec2(1373., 24.),\n    vec2(1432., 168.),\n    vec2(1443., 196.),\n    vec2(1390., 151.),\n    vec2(1051., -16.),\n    vec2(815., 140.),\n    vec2(786., 224.),\n    vec2(770., 208.),\n    vec2(499., 20.),\n    vec2(344., -16.),\n    vec2(150., 70.),\n    vec2(76., 277.),\n    vec2(196., 583.),\n    vec2(364., 757.),\n    vec2(375., 766.),\n    vec2(348., 766.),\n    vec2(-136., 626.),\n    vec2(-218., 583.),\n    vec2(-234., 598.),\n    vec2(-167., 691.),\n    vec2(171., 865.),\n    vec2(508., 909.),\n    vec2(888., 884.),\n    vec2(1329., 861.),\n    vec2(1639., 874.),\n    vec2(1676., 876.),\n    vec2(1686., 877.),\n    vec2(1703., 924.),\n    vec2(1890., 1445.),\n    vec2(2621., 2561.),\n    vec2(2704., 2605.),\n    vec2(2720., 2591.),\n    vec2(2648., 2490.),\n    vec2(2560., 2404.),\n    vec2(2064., 1559.),\n    vec2(1802., 830.),\n    vec2(1536., 112.),\n    vec2(522., -1364.),\n    vec2(443., -1448.),\n    vec2(201., -1689.),\n    vec2(-147., -2016.),\n    vec2(-253., -2097.),\n    vec2(-279., -2102.),\n    vec2(-284., -2102.),\n    vec2(-293., -2089.),\n    vec2(-293., -2089.),\n    vec2(250., 408.),\n    vec2(381., 174.),\n    vec2(489., 144.),\n    vec2(678., 220.),\n    vec2(713., 252.),\n    vec2(802., 402.),\n    vec2(867., 542.),\n    vec2(1023., 722.),\n    vec2(1014., 722.),\n    vec2(539., 760.),\n    vec2(406., 702.),\n    vec2(261., 492.),\n    vec2(250., 408.),\n    vec2(250., 408.),\n    vec2(956., 414.),\n    vec2(1087., 175.),\n    vec2(1195., 143.),\n    vec2(1427., 284.),\n    vec2(1561., 515.),\n    vec2(1629., 707.),\n    vec2(1640., 740.),\n    vec2(1640., 741.),\n    vec2(1466., 725.),\n    vec2(1294., 719.),\n    vec2(1148., 707.),\n    vec2(1011., 598.),\n    vec2(956., 414.),\n    vec2(956., 414.),\n    vec2(-1355., 751.),\n    vec2(-1333., 793.),\n    vec2(-932., 1245.),\n    vec2(-719., 1477.),\n    vec2(-257., 1806.),\n    vec2(-182., 1819.),\n    vec2(-160., 1820.),\n    vec2(7., 1738.),\n    vec2(46., 1611.),\n    vec2(-42., 1405.),\n    vec2(-232., 1266.),\n    vec2(-304., 1254.),\n    vec2(-427., 1313.),\n    vec2(-449., 1384.),\n    vec2(-381., 1521.),\n    vec2(-287., 1581.),\n    vec2(-276., 1571.),\n    vec2(-295., 1534.),\n    vec2(-314., 1487.),\n    vec2(-265., 1397.),\n    vec2(-194., 1377.),\n    vec2(-120., 1401.),\n    vec2(-88., 1511.),\n    vec2(-153., 1655.),\n    vec2(-273., 1697.),\n    vec2(-655., 1470.),\n    vec2(-707., 1414.),\n    vec2(-1050., 1029.),\n    vec2(-1266., 787.),\n    vec2(-1344., 741.),\n    vec2(-1355., 751.),\n    vec2(-1355., 751.),\n    vec2(-174., 657.),\n    vec2(-115., 743.),\n    vec2(141., 888.),\n    vec2(226., 904.),\n    vec2(317., 908.),\n    vec2(720., 859.),\n    vec2(1068., 803.),\n    vec2(1196., 797.),\n    vec2(1523., 881.),\n    vec2(1591., 936.),\n    vec2(1638., 951.),\n    vec2(1654., 937.),\n    vec2(1552., 814.),\n    vec2(1470., 754.),\n    vec2(1083., 637.),\n    vec2(1048., 637.),\n    vec2(808., 658.),\n    vec2(776., 662.),\n    vec2(357., 487.),\n    vec2(146., 80.),\n    vec2(292., -283.),\n    vec2(672., -468.),\n    vec2(788., -476.),\n    vec2(1187., -362.),\n    vec2(1293., -243.),\n    vec2(1333., -116.),\n    vec2(1300., -41.),\n    vec2(1261., 31.),\n    vec2(1260., 48.),\n    vec2(1318., 156.),\n    vec2(1394., 181.),\n    vec2(1479., 133.),\n    vec2(1508., 24.),\n    vec2(1327., -329.),\n    vec2(1261., -394.),\n    vec2(678., -635.),\n    vec2(647., -636.),\n    vec2(183., -489.),\n    vec2(-16., -175.),\n    vec2(-27., -68.),\n    vec2(46., 227.),\n    vec2(61., 255.),\n    vec2(431., 631.),\n    vec2(552., 701.),\n    vec2(330., 736.),\n    vec2(170., 748.),\n    vec2(-78., 687.),\n    vec2(-122., 654.),\n    vec2(-158., 644.),\n    vec2(-174., 657.),\n    vec2(-174., 657.),\n    vec2(-348., -529.),\n    vec2(-174., -184.),\n    vec2(131., 40.),\n    vec2(37., 249.),\n    vec2(36., 286.),\n    vec2(462., 1152.),\n    vec2(1317., 2128.),\n    vec2(1527., 2332.),\n    vec2(1680., 2472.),\n    vec2(1773., 2525.),\n    vec2(1788., 2511.),\n    vec2(1707., 2404.),\n    vec2(784., 1441.),\n    vec2(244., 591.),\n    vec2(209., 415.),\n    vec2(244., 267.),\n    vec2(422., 143.),\n    vec2(587., 197.),\n    vec2(645., 234.),\n    vec2(663., 238.),\n    vec2(679., 224.),\n    vec2(624., 141.),\n    vec2(381., -1.),\n    vec2(318., -14.),\n    vec2(67., -92.),\n    vec2(-89., -200.),\n    vec2(-174., -395.),\n    vec2(-71., -630.),\n    vec2(181., -727.),\n    vec2(389., -688.),\n    vec2(444., -650.),\n    vec2(470., -548.),\n    vec2(430., -442.),\n    vec2(391., -379.),\n    vec2(386., -347.),\n    vec2(469., -225.),\n    vec2(521., -213.),\n    vec2(623., -294.),\n    vec2(644., -409.),\n    vec2(537., -660.),\n    vec2(235., -856.),\n    vec2(38., -887.),\n    vec2(-244., -776.),\n    vec2(-348., -540.),\n    vec2(-348., -529.),\n    vec2(-348., -529.),\n    vec2(-902., 1012.),\n    vec2(-852., 1085.),\n    vec2(-624., 1195.),\n    vec2(-563., 1199.),\n    vec2(-336., 1170.),\n    vec2(-142., 1147.),\n    vec2(1., 1181.),\n    vec2(33., 1207.),\n    vec2(65., 1221.),\n    vec2(74., 1221.),\n    vec2(84., 1211.),\n    vec2(35., 1140.),\n    vec2(-193., 1029.),\n    vec2(-254., 1024.),\n    vec2(-478., 1052.),\n    vec2(-673., 1076.),\n    vec2(-837., 1030.),\n    vec2(-879., 1003.),\n    vec2(-891., 1002.),\n    vec2(-902., 1012.),\n    vec2(-902., 1012.),\n    vec2(-1657., -2241.),\n    vec2(-1595., -2152.),\n    vec2(-1409., -1974.),\n    vec2(-1385., -1951.),\n    vec2(-102., -182.),\n    vec2(11., 31.),\n    vec2(135., 312.),\n    vec2(216., 595.),\n    vec2(175., 713.),\n    vec2(93., 746.),\n    vec2(-91., 695.),\n    vec2(-142., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-120., 759.),\n    vec2(126., 894.),\n    vec2(212., 906.),\n    vec2(230., 906.),\n    vec2(344., 866.),\n    vec2(388., 763.),\n    vec2(390., 731.),\n    vec2(366., 593.),\n    vec2(554., 755.),\n    vec2(880., 889.),\n    vec2(1091., 803.),\n    vec2(1172., 601.),\n    vec2(1010., 254.),\n    vec2(913., 160.),\n    vec2(1010., 157.),\n    vec2(1340., 238.),\n    vec2(1402., 285.),\n    vec2(1444., 298.),\n    vec2(1448., 298.),\n    vec2(1461., 283.),\n    vec2(1400., 194.),\n    vec2(1104., 40.),\n    vec2(892., 14.),\n    vec2(634., 33.),\n    vec2(532., 42.),\n    vec2(397., 45.),\n    vec2(115., 10.),\n    vec2(102., -15.),\n    vec2(-625., -1176.),\n    vec2(-1161., -1822.),\n    vec2(-1205., -1869.),\n    vec2(-1462., -2122.),\n    vec2(-1564., -2215.),\n    vec2(-1642., -2255.),\n    vec2(-1657., -2241.),\n    vec2(-1657., -2241.),\n    vec2(185., 142.),\n    vec2(465., 187.),\n    vec2(527., 189.),\n    vec2(701., 185.),\n    vec2(906., 249.),\n    vec2(923., 267.),\n    vec2(998., 469.),\n    vec2(911., 664.),\n    vec2(727., 728.),\n    vec2(429., 553.),\n    vec2(336., 439.),\n    vec2(200., 174.),\n    vec2(185., 142.),\n    vec2(185., 142.),\n    vec2(-174., 675.),\n    vec2(-119., 761.),\n    vec2(135., 895.),\n    vec2(214., 906.),\n    vec2(243., 906.),\n    vec2(368., 825.),\n    vec2(389., 723.),\n    vec2(376., 627.),\n    vec2(402., 650.),\n    vec2(821., 889.),\n    vec2(1047., 751.),\n    vec2(1087., 621.),\n    vec2(1088., 615.),\n    vec2(1182., 701.),\n    vec2(1430., 869.),\n    vec2(1543., 888.),\n    vec2(1727., 808.),\n    vec2(1807., 598.),\n    vec2(1624., 215.),\n    vec2(1564., 155.),\n    vec2(1600., 156.),\n    vec2(1993., 246.),\n    vec2(2047., 287.),\n    vec2(2085., 298.),\n    vec2(2089., 298.),\n    vec2(2102., 281.),\n    vec2(2030., 183.),\n    vec2(1713., 36.),\n    vec2(1617., 21.),\n    vec2(1435., 13.),\n    vec2(1023., 33.),\n    vec2(675., 47.),\n    vec2(4., -13.),\n    vec2(-21., -16.),\n    vec2(-36., -3.),\n    vec2(5., 67.),\n    vec2(37., 105.),\n    vec2(182., 431.),\n    vec2(215., 590.),\n    vec2(154., 729.),\n    vec2(94., 747.),\n    vec2(-90., 695.),\n    vec2(-143., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-174., 675.),\n    vec2(164., 138.),\n    vec2(489., 175.),\n    vec2(812., 212.),\n    vec2(914., 462.),\n    vec2(880., 594.),\n    vec2(675., 729.),\n    vec2(369., 487.),\n    vec2(222., 236.),\n    vec2(164., 138.),\n    vec2(164., 138.),\n    vec2(890., 189.),\n    vec2(891., 189.),\n    vec2(1243., 169.),\n    vec2(1355., 163.),\n    vec2(1540., 231.),\n    vec2(1633., 444.),\n    vec2(1633., 466.),\n    vec2(1544., 670.),\n    vec2(1427., 727.),\n    vec2(1392., 728.),\n    vec2(1175., 596.),\n    vec2(1043., 399.),\n    vec2(902., 204.),\n    vec2(890., 189.),\n    vec2(890., 189.),\n    vec2(-1657., -2241.),\n    vec2(-1595., -2152.),\n    vec2(-1409., -1974.),\n    vec2(-1385., -1951.),\n    vec2(-102., -182.),\n    vec2(11., 31.),\n    vec2(135., 312.),\n    vec2(216., 595.),\n    vec2(175., 713.),\n    vec2(93., 746.),\n    vec2(-91., 695.),\n    vec2(-142., 664.),\n    vec2(-158., 662.),\n    vec2(-174., 675.),\n    vec2(-120., 759.),\n    vec2(126., 894.),\n    vec2(212., 906.),\n    vec2(231., 907.),\n    vec2(323., 883.),\n    vec2(367., 828.),\n    vec2(390., 727.),\n    vec2(374., 625.),\n    vec2(374., 624.),\n    vec2(429., 675.),\n    vec2(823., 888.),\n    vec2(1052., 744.),\n    vec2(1088., 626.),\n    vec2(1090., 615.),\n    vec2(1178., 700.),\n    vec2(1530., 888.),\n    vec2(1544., 888.),\n    vec2(1730., 806.),\n    vec2(1808., 592.),\n    vec2(1733., 359.),\n    vec2(1601., 191.),\n    vec2(1566., 156.),\n    vec2(1575., 156.),\n    vec2(1587., 156.),\n    vec2(2006., 250.),\n    vec2(2017., 259.),\n    vec2(2093., 298.),\n    vec2(2097., 298.),\n    vec2(2110., 284.),\n    vec2(2052., 196.),\n    vec2(1746., 41.),\n    vec2(1628., 21.),\n    vec2(1459., 13.),\n    vec2(1042., 33.),\n    vec2(715., 46.),\n    vec2(591., 46.),\n    vec2(146., 5.),\n    vec2(110., 0.),\n    vec2(99., -20.),\n    vec2(-673., -1239.),\n    vec2(-1111., -1768.),\n    vec2(-1205., -1869.),\n    vec2(-1462., -2122.),\n    vec2(-1564., -2215.),\n    vec2(-1642., -2255.),\n    vec2(-1657., -2241.),\n    vec2(-1657., -2241.),\n    vec2(182., 136.),\n    vec2(183., 136.),\n    vec2(274., 150.),\n    vec2(643., 186.),\n    vec2(812., 214.),\n    vec2(822., 222.),\n    vec2(915., 462.),\n    vec2(784., 698.),\n    vec2(677., 729.),\n    vec2(367., 494.),\n    vec2(238., 257.),\n    vec2(189., 151.),\n    vec2(182., 136.),\n    vec2(890., 190.),\n    vec2(919., 189.),\n    vec2(1256., 169.),\n    vec2(1358., 164.),\n    vec2(1541., 229.),\n    vec2(1604., 331.),\n    vec2(1634., 466.),\n    vec2(1562., 656.),\n    vec2(1393., 728.),\n    vec2(1120., 523.),\n    vec2(1027., 371.),\n    vec2(906., 208.),\n    vec2(890., 190.),\n    vec2(-285., -2089.),\n    vec2(-200., -1978.),\n    vec2(115., -1686.),\n    vec2(658., -1120.),\n    vec2(1399., 65.),\n    vec2(1450., 197.),\n    vec2(1395., 151.),\n    vec2(1058., -16.),\n    vec2(824., 137.),\n    vec2(793., 225.),\n    vec2(778., 211.),\n    vec2(545., 39.),\n    vec2(352., -16.),\n    vec2(160., 67.),\n    vec2(84., 277.),\n    vec2(233., 618.),\n    vec2(375., 760.),\n    vec2(388., 771.),\n    vec2(380., 772.),\n    vec2(-39., 689.),\n    vec2(-138., 624.),\n    vec2(-217., 583.),\n    vec2(-234., 598.),\n    vec2(-165., 694.),\n    vec2(169., 869.),\n    vec2(504., 915.),\n    vec2(916., 893.),\n    vec2(1675., 858.),\n    vec2(1777., 858.),\n    vec2(1969., 889.),\n    vec2(2007., 901.),\n    vec2(2024., 886.),\n    vec2(1976., 811.),\n    vec2(1775., 719.),\n    vec2(1741., 632.),\n    vec2(1668., 434.),\n    vec2(1512., 37.),\n    vec2(400., -1505.),\n    vec2(121., -1777.),\n    vec2(-189., -2061.),\n    vec2(-270., -2102.),\n    vec2(-285., -2089.),\n    vec2(-285., -2089.),\n    vec2(257., 406.),\n    vec2(366., 187.),\n    vec2(417., 158.),\n    vec2(495., 144.),\n    vec2(680., 217.),\n    vec2(758., 302.),\n    vec2(815., 423.),\n    vec2(960., 654.),\n    vec2(1030., 722.),\n    vec2(1038., 730.),\n    vec2(1037., 730.),\n    vec2(727., 756.),\n    vec2(552., 768.),\n    vec2(427., 713.),\n    vec2(376., 668.),\n    vec2(264., 467.),\n    vec2(257., 406.),\n    vec2(257., 406.),\n    vec2(964., 412.),\n    vec2(1044., 211.),\n    vec2(1077., 184.),\n    vec2(1202., 144.),\n    vec2(1460., 319.),\n    vec2(1575., 535.),\n    vec2(1628., 660.),\n    vec2(1660., 714.),\n    vec2(1572., 715.),\n    vec2(1236., 720.),\n    vec2(998., 561.),\n    vec2(964., 412.),\n    vec2(964., 412.),\n    vec2(-877., -2089.),\n    vec2(-792., -1978.),\n    vec2(-477., -1686.),\n    vec2(56., -1133.),\n    vec2(807., 65.),\n    vec2(870., 230.),\n    vec2(790., 162.),\n    vec2(649., 64.),\n    vec2(407., -17.),\n    vec2(194., 71.),\n    vec2(115., 273.),\n    vec2(204., 526.),\n    vec2(419., 749.),\n    vec2(435., 762.),\n    vec2(312., 768.),\n    vec2(-134., 628.),\n    vec2(-217., 582.),\n    vec2(-234., 598.),\n    vec2(-165., 694.),\n    vec2(150., 868.),\n    vec2(397., 911.),\n    vec2(449., 911.),\n    vec2(741., 886.),\n    vec2(1226., 858.),\n    vec2(1377., 889.),\n    vec2(1415., 901.),\n    vec2(1432., 885.),\n    vec2(1347., 782.),\n    vec2(1198., 722.),\n    vec2(1180., 711.),\n    vec2(1149., 632.),\n    vec2(1076., 434.),\n    vec2(920., 37.),\n    vec2(-192., -1505.),\n    vec2(-471., -1777.),\n    vec2(-781., -2061.),\n    vec2(-862., -2102.),\n    vec2(-877., -2089.),\n    vec2(-877., -2089.),\n    vec2(290., 403.),\n    vec2(376., 207.),\n    vec2(557., 144.),\n    vec2(747., 217.),\n    vec2(904., 380.),\n    vec2(997., 569.),\n    vec2(1068., 714.),\n    vec2(989., 716.),\n    vec2(647., 739.),\n    vec2(612., 741.),\n    vec2(431., 670.),\n    vec2(296., 463.),\n    vec2(290., 403.),\n    vec2(290., 403.),\n    vec2(-972., 750.),\n    vec2(-967., 768.),\n    vec2(-652., 1234.),\n    vec2(-135., 1811.),\n    vec2(-43., 1860.),\n    vec2(72., 1889.),\n    vec2(203., 1852.),\n    vec2(215., 1843.),\n    vec2(326., 1883.),\n    vec2(379., 1889.),\n    vec2(536., 1816.),\n    vec2(583., 1676.),\n    vec2(490., 1461.),\n    vec2(304., 1332.),\n    vec2(242., 1322.),\n    vec2(111., 1405.),\n    vec2(100., 1449.),\n    vec2(178., 1590.),\n    vec2(254., 1635.),\n    vec2(257., 1635.),\n    vec2(266., 1625.),\n    vec2(248., 1590.),\n    vec2(235., 1555.),\n    vec2(314., 1452.),\n    vec2(352., 1445.),\n    vec2(423., 1473.),\n    vec2(438., 1507.),\n    vec2(450., 1577.),\n    vec2(343., 1748.),\n    vec2(270., 1766.),\n    vec2(-130., 1445.),\n    vec2(-153., 1413.),\n    vec2(-461., 958.),\n    vec2(-562., 814.),\n    vec2(-646., 746.),\n    vec2(-665., 740.),\n    vec2(-676., 750.),\n    vec2(-671., 768.),\n    vec2(-356., 1234.),\n    vec2(-19., 1663.),\n    vec2(65., 1740.),\n    vec2(-25., 1766.),\n    vec2(-200., 1696.),\n    vec2(-618., 1169.),\n    vec2(-818., 869.),\n    vec2(-858., 814.),\n    vec2(-942., 746.),\n    vec2(-961., 740.),\n    vec2(-972., 750.),\n    vec2(-972., 750.),\n    vec2(22., 446.),\n    vec2(99., 544.),\n    vec2(288., 669.),\n    vec2(400., 695.),\n    vec2(780., 559.),\n    vec2(1003., 392.),\n    vec2(1275., 216.),\n    vec2(1448., 176.),\n    vec2(1504., 181.),\n    vec2(1501., 207.),\n    vec2(1551., 299.),\n    vec2(1602., 310.),\n    vec2(1692., 258.),\n    vec2(1702., 210.),\n    vec2(1650., 121.),\n    vec2(1601., 109.),\n    vec2(1547., 124.),\n    vec2(1387., 56.),\n    vec2(1336., 53.),\n    vec2(1111., 111.),\n    vec2(834., 267.),\n    vec2(614., 397.),\n    vec2(266., 502.),\n    vec2(84., 457.),\n    vec2(34., 435.),\n    vec2(22., 446.),\n    vec2(22., 446.),\n    vec2(75., 1420.),\n    vec2(154., 1522.),\n    vec2(395., 1675.),\n    vec2(503., 1697.),\n    vec2(865., 1486.),\n    vec2(1102., 1150.),\n    vec2(1313., 839.),\n    vec2(1605., 631.),\n    vec2(1634., 629.),\n    vec2(1678., 635.),\n    vec2(1675., 660.),\n    vec2(1725., 752.),\n    vec2(1776., 764.),\n    vec2(1866., 710.),\n    vec2(1876., 663.),\n    vec2(1825., 573.),\n    vec2(1776., 561.),\n    vec2(1721., 577.),\n    vec2(1554., 507.),\n    vec2(1520., 504.),\n    vec2(1206., 673.),\n    vec2(973., 958.),\n    vec2(758., 1228.),\n    vec2(396., 1479.),\n    vec2(326., 1486.),\n    vec2(146., 1436.),\n    vec2(87., 1410.),\n    vec2(75., 1420.),\n    vec2(75., 1420.),\n    vec2(72., 210.),\n    vec2(124., 300.),\n    vec2(173., 310.),\n    vec2(263., 258.),\n    vec2(274., 210.),\n    vec2(271., 181.),\n    vec2(271., 180.),\n    vec2(361., 170.),\n    vec2(768., 319.),\n    vec2(1025., 491.),\n    vec2(1170., 584.),\n    vec2(1556., 719.),\n    vec2(1950., 530.),\n    vec2(2013., 446.),\n    vec2(2002., 435.),\n    vec2(1948., 459.),\n    vec2(1730., 516.),\n    vec2(1715., 516.),\n    vec2(1165., 332.),\n    vec2(949., 211.),\n    vec2(499., 46.),\n    vec2(472., 45.),\n    vec2(248., 111.),\n    vec2(228., 124.),\n    vec2(173., 109.),\n    vec2(86., 156.),\n    vec2(72., 210.),\n    vec2(72., 210.),\n    vec2(212., 662.),\n    vec2(264., 753.),\n    vec2(312., 764.),\n    vec2(402., 711.),\n    vec2(413., 662.),\n    vec2(410., 635.),\n    vec2(455., 630.),\n    vec2(762., 821.),\n    vec2(982., 1139.),\n    vec2(1207., 1465.),\n    vec2(1538., 1678.),\n    vec2(1552., 1679.),\n    vec2(1839., 1568.),\n    vec2(1969., 1446.),\n    vec2(1978., 1420.),\n    vec2(1967., 1410.),\n    vec2(1911., 1435.),\n    vec2(1732., 1485.),\n    vec2(1378., 1301.),\n    vec2(1133., 1002.),\n    vec2(890., 696.),\n    vec2(799., 605.),\n    vec2(572., 505.),\n    vec2(375., 571.),\n    vec2(367., 577.),\n    vec2(311., 561.),\n    vec2(239., 590.),\n    vec2(212., 662.),\n    vec2(212., 662.)\n);\n\nconst int curves[51] = int[](\n    0,\n    11,\n    23,\n    37,\n    49,\n    91,\n    142,\n    214,\n    256,\n    328,\n    376,\n    405,\n    415,\n    437,\n    447,\n    502,\n    514,\n    526,\n    540,\n    551,\n    563,\n    575,\n    586,\n    616,\n    638,\n    651,\n    705,\n    719,\n    733,\n    765,\n    816,\n    862,\n    883,\n    933,\n    947,\n    993,\n    1003,\n    1018,\n    1079,\n    1092,\n    1105,\n    1148,\n    1166,\n    1179,\n    1218,\n    1232,\n    1282,\n    1309,\n    1338,\n    1366,\n    1395\n);\n\nconst int glyphs[32] = int[](\n    0,\n    0,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    12,\n    13,\n    14,\n    15,\n    18,\n    21,\n    22,\n    23,\n    24,\n    25,\n    28,\n    29,\n    30,\n    31,\n    32,\n    34,\n    37,\n    40,\n    43,\n    45,\n    46,\n    48\n);\n\nstruct letter {\n    vec4 box;\n    vec2 pos;\n    int glyph_index;\n};\n\nconst letter letters[73] = letter[](\n    letter(vec4(-31000., 53., -29146., 1697.), vec2(-31022., 0.), 30),\n    letter(vec4(-30001., -2102., -26988., 2605.), vec2(-29108., 0.), 12),\n    letter(vec4(-28492., 1183., -27911., 1774.), vec2(-27872., 0.), 14),\n    letter(vec4(-28046., -16., -26050., 906.), vec2(-27872., 0.), 7),\n    letter(vec4(-26902., -1718., -25213., 923.), vec2(-25962., 0.), 3),\n    letter(vec4(-25763., 1183., -25182., 1774.), vec2(-25143., 0.), 14),\n    letter(vec4(-25428., -2102., -23119., 915.), vec2(-25143., 0.), 27),\n    letter(vec4(-24955., -2255., -21475., 906.), vec2(-23298., 0.), 5),\n    letter(vec4(-21551., -16., -20199., 906.), vec2(-21377., 0.), 8),\n    letter(vec4(-20705., 741., -19679., 1743.), vec2(-20116., 0.), 16),\n    letter(vec4(-21773., -2255., -18006., 907.), vec2(-20116., 0.), 26),\n    letter(vec4(-19852., -2255., -17016., 907.), vec2(-18195., 0.), 4),\n    letter(vec4(-17405., 1183., -16824., 1774.), vec2(-16924., 0.), 13),\n    letter(vec4(-17098., -636., -15270., 951.), vec2(-16924., 0.), 21),\n    letter(vec4(-16539., 741., -15138., 1820.), vec2(-15184., 0.), 20),\n    letter(vec4(-16061., -2102., -13752., 911.), vec2(-15184., 0.), 28),\n    letter(vec4(-14903., 740., -13348., 1889.), vec2(-13931., 0.), 29),\n    letter(vec4(-13771., 336., -13569., 537.), vec2(-13931., 0.), 11),\n    letter(vec4(-13391., 0., -13391., 0.), vec2(-13391., 0.), 0),\n    letter(vec4(-13674., -2102., -10661., 2605.), vec2(-12781., 0.), 12),\n    letter(vec4(-12165., 1183., -11584., 1774.), vec2(-11545., 0.), 14),\n    letter(vec4(-11719., -16., -9723., 906.), vec2(-11545., 0.), 7),\n    letter(vec4(-10575., -1718., -8886., 923.), vec2(-9635., 0.), 3),\n    letter(vec4(-9436., 1183., -8855., 1774.), vec2(-8816., 0.), 14),\n    letter(vec4(-9101., -2102., -6792., 915.), vec2(-8816., 0.), 27),\n    letter(vec4(-9039., -391., -7373., -94.), vec2(-6971., 0.), 10),\n    letter(vec4(-8628., -2255., -4861., 907.), vec2(-6971., 0.), 26),\n    letter(vec4(-5807., 1276., -5577., 1649.), vec2(-5050., 0.), 2),\n    letter(vec4(-6630., 967., -4964., 1264.), vec2(-5050., 0.), 17),\n    letter(vec4(-6707., -2255., -3871., 907.), vec2(-5050., 0.), 4),\n    letter(vec4(-4260., 1183., -3679., 1774.), vec2(-3779., 0.), 13),\n    letter(vec4(-3953., -636., -2125., 951.), vec2(-3779., 0.), 21),\n    letter(vec4(-3394., 741., -1993., 1820.), vec2(-2039., 0.), 20),\n    letter(vec4(-1967., 45., -26., 1679.), vec2(-2039., 0.), 31),\n    letter(vec4(-125., 0., -125., 0.), vec2(-125., 0.), 0),\n    letter(vec4(-408., -2102., 2605., 2605.), vec2(485., 0.), 12),\n    letter(vec4(1101., 1183., 1682., 1774.), vec2(1721., 0.), 14),\n    letter(vec4(1547., -16., 3543., 906.), vec2(1721., 0.), 7),\n    letter(vec4(2691., -1718., 4380., 923.), vec2(3631., 0.), 3),\n    letter(vec4(3830., 1183., 4411., 1774.), vec2(4450., 0.), 14),\n    letter(vec4(4165., -2102., 6474., 915.), vec2(4450., 0.), 27),\n    letter(vec4(6260., -16., 7585., 2478.), vec2(6295., 0.), 6),\n    letter(vec4(6563., -1819., 8475., 906.), vec2(7554., 0.), 9),\n    letter(vec4(7705., -2102., 10014., 911.), vec2(8582., 0.), 28),\n    letter(vec4(9354., 1183., 9935., 1774.), vec2(9835., 0.), 13),\n    letter(vec4(8178., -2255., 11014., 907.), vec2(9835., 0.), 4),\n    letter(vec4(10625., 1183., 11206., 1774.), vec2(11106., 0.), 13),\n    letter(vec4(10932., -636., 12760., 951.), vec2(11106., 0.), 21),\n    letter(vec4(11491., 741., 12892., 1820.), vec2(12846., 0.), 20),\n    letter(vec4(11969., -2102., 14278., 911.), vec2(12846., 0.), 28),\n    letter(vec4(13127., 740., 14682., 1889.), vec2(14099., 0.), 29),\n    letter(vec4(14259., 336., 14461., 537.), vec2(14099., 0.), 11),\n    letter(vec4(14639., 0., 14639., 0.), vec2(14639., 0.), 0),\n    letter(vec4(14956., -2102., 17969., 2605.), vec2(15249., 0.), 19),\n    letter(vec4(16118., 1183., 16699., 1774.), vec2(17086., 0.), 1),\n    letter(vec4(15429., -2255., 19196., 907.), vec2(17086., 0.), 26),\n    letter(vec4(18833., -16., 20185., 906.), vec2(19007., 0.), 8),\n    letter(vec4(19679., 741., 20705., 1743.), vec2(20268., 0.), 16),\n    letter(vec4(19920., -887., 22056., 2525.), vec2(20268., 0.), 22),\n    letter(vec4(21138., -16., 23414., 906.), vec2(21312., 0.), 25),\n    letter(vec4(21867., 741., 23268., 1820.), vec2(23222., 0.), 20),\n    letter(vec4(22329., -2102., 25342., 2605.), vec2(23222., 0.), 12),\n    letter(vec4(24049., 1276., 24274., 1653.), vec2(24458., 0.), 18),\n    letter(vec4(23581., -2102., 25890., 911.), vec2(24458., 0.), 28),\n    letter(vec4(25372., 1276., 25608., 1647.), vec2(25711., 0.), 15),\n    letter(vec4(24720., -1819., 26632., 906.), vec2(25711., 0.), 9),\n    letter(vec4(25082., -2255., 28200., 906.), vec2(26739., 0.), 24),\n    letter(vec4(27671., 1276., 27907., 1647.), vec2(28010., 0.), 15),\n    letter(vec4(27108., 1002., 28094., 1221.), vec2(28010., 0.), 23),\n    letter(vec4(26353., -2255., 29189., 907.), vec2(28010., 0.), 4),\n    letter(vec4(28800., 1183., 29381., 1774.), vec2(29281., 0.), 13),\n    letter(vec4(29107., -636., 30935., 951.), vec2(29281., 0.), 21),\n    letter(vec4(29666., 741., 31067., 1820.), vec2(31021., 0.), 20)\n);\n\nfloat curve(in vec2 p, int start, int end)\n{\n        float ret = 0.;\n\n        for (int i = start; i < end; ++i) {\n            vec2 A = points[i];\n            vec2 B = points[i + 1];\n            \n            vec2 d = B - A;\n            float k = d.y / d.x;\n            float m = A.y - k * A.x;\n\n            ret += abs(step(B.x, p.x) - step(A.x, p.x)) * step(p.y, k * p.x + m);\n        }\n\n        return ret;\n}\n\nfloat glyph(in vec2 p, int start, int end)\n{\n    float d = 0.;\n\n    for (int i = start; i < end; ++i) {\n        d += curve(p, curves[i], curves[i + 1] - 1);\n    }\n\n    return mod(d, 2.);\n}\n\n// https://stackoverflow.com/a/26697650/1697183\nfloat insideBox( in vec2 p, in vec4 box )\n{\n    vec2 s = step(box.zw, p) - step(box.xy, p);\n    return s.x * s.y;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCurve(in vec2 p, int start, int end)\n{\n    float d = 1e16;\n\n    for (int i = start; i < end; ++i) {\n        vec2 A = points[i];\n        vec2 B = points[i + 1];\n        d = min(d, sdLine(p, A, B));\n    }\n\n    return d;\n}\n\nfloat sdGlyph(in vec2 p, int start, int end)\n{\n    float d = 1e16;\n\n    for (int i = start; i < end; ++i) {\n        d = min(d, sdCurve(p, curves[i], curves[i + 1] - 1));\n    }\n\n    return d;\n}\n\nuniform int zero;\n\nfloat text(vec2 p)\n{\n    float d = 1e16;\n\n    for (int i = zero; i < 73; ++i) {\n        if (insideBox(p, letters[i].box + 100.*vec4(-1, -1, 1, 1)) > 0.) {\n            int glyph_index = letters[i].glyph_index;\n            if (glyph(p - letters[i].pos, glyphs[glyph_index], glyphs[glyph_index + 1]) > 0.) {\n                // fill\n                d = 0.;\n            } else {\n                // outline\n            \td = min(d, sdGlyph(p - letters[i].pos, glyphs[glyph_index], glyphs[glyph_index + 1]));\n            }\n        }\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    uv *= 10000.;\n    uv.x -= 500. * 50.;\n    uv.x += 500.*mod(iTime, 120.);\n    float col = text(uv);\n    //fragColor = vec4(vec3(smoothstep(-1., 20., col)), 1.0);\n    fragColor = vec4( smoothstep(-0., 1.5e4/iResolution.y, col) );\n    fragColor.xyz = pow( fragColor.xyz, vec3(1. / 2.2) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37938, 37938, 37982, 37982, 38346], [38348, 38348, 38392, 38392, 38536], [38538, 38586, 38629, 38629, 38701], [38703, 38781, 38830, 38830, 38949], [38951, 38951, 38997, 38997, 39178], [39180, 39180, 39226, 39226, 39372], [39393, 39393, 39413, 39413, 39940], [39942, 39942, 39999, 39999, 40359]], "test": "untested"}
{"id": "wsVXDh", "name": "don - Perlin Noise 2D", "author": "koktszfung", "description": "Simple Perlin Noise", "tags": ["perlinnoise"], "likes": 0, "viewed": 60, "published": "Public", "date": "1573971234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n *\t2D Perlin Noise\n */\n\n// 0 = Controlled by iTime\n// 1 = Controlled by iMouse\n#define MOUSE 0\n\n/* board size for periodic boundary condition */\nconst int NUM_SAMPLE_X = 800;\nconst int NUM_SAMPLE_Y = 800;\n\n/* choices of gradient vector */\nconst float[8] GRAD_I = float[](-2.,-2., 2., 2.,-1., 1.,-1., 1.);\nconst float[8] GRAD_J = float[](-1., 1.,-1., 1.,-2.,-2., 2., 2.);\n\n\n\n/* smooth function */\nfloat fade(float x) {\n    return 6. * pow(x, 5.) - 15. * pow(x, 4.) + 10. * pow(x, 3.);\n}\n\n/* linear interpolation */\nfloat lerp(float x, float a, float b) {\n    return (1. - x) * a + x * b;\n}\n\n/* get random float [0, 1] from noise map (less artifacts) */\nfloat rand(int i, int j, int seed) {\n    // use channel0 for noise map\n\tint u = int(texelFetch(iChannel0, ivec2(i, j), 0).x * float(NUM_SAMPLE_Y));\n    int v = int(texelFetch(iChannel0, ivec2(j, i), 0).x * float(NUM_SAMPLE_X));\n    u = (u + seed) % int(iChannelResolution[0].y);\n    v = (v + seed) % int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(u, v), 0).x;\n}\n\n/* get random float [0, 1] from hash function by Xor https://www.shadertoy.com/view/4l2GzW (more artifact) */\n/*float rand(int i, int j, int seed) {\n    float n = float(i * int(iResolution.x) + j + seed);\n \treturn fract(cos(n*89.42)*343.42);\n}*/\n\n/* colormap by mattz https://www.shadertoy.com/view/WlfXRN*/\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\n\n/* calculate perlin noise at current position */\nfloat noise(int num_row, int num_col, int seed, vec2 fragCoord) {\n    /* indices for current cell */\n    int i = int(fragCoord.y) * num_row / NUM_SAMPLE_Y ;\n    int j = int(fragCoord.x) * num_col / NUM_SAMPLE_X ;\n    \n    /* adjacent indices with periodic boundary condition */\n    int[4] ADJ_I = int[](i % num_row, i % num_row, (i + 1) % num_row, (i + 1) % num_row);\n    int[4] ADJ_J = int[](j % num_col, (j + 1) % num_col, j % num_col, (j + 1) % num_col);\n    \n    /* random integers by scaling rand of [0, 1] to [0, number of gradient vectors - 1] */\n    int num_grad = GRAD_I.length();\n    int r0 = int(rand(ADJ_I[0], ADJ_J[0], seed) * float(num_grad));\n\tint r1 = int(rand(ADJ_I[1], ADJ_J[1], seed) * float(num_grad));\n\tint r2 = int(rand(ADJ_I[2], ADJ_J[2], seed) * float(num_grad));\n\tint r3 = int(rand(ADJ_I[3], ADJ_J[3], seed) * float(num_grad));\n    if (r0 == num_grad) r0--;\n\tif (r1 == num_grad) r1--;\n\tif (r2 == num_grad) r2--;\n\tif (r3 == num_grad) r3--;\n    \n    /* (u, v) = displacement from (-1, -1) corner of current cell = (y, x) - floor((y, x)) */\n    float u = fragCoord.y * float(num_row) / float(NUM_SAMPLE_Y) - float(i);\n    float v = fragCoord.x * float(num_col) / float(NUM_SAMPLE_X) - float(j);\n\t\n    /* ((u, v) - corner pos) dot (gradient at corner) */\n    float n0 = (u)*GRAD_I[r0] + (v)*GRAD_J[r0];\n    float n1 = (u)*GRAD_I[r1] + (v - 1.)*GRAD_J[r1];\n    float n2 = (u - 1.)*GRAD_I[r2] + (v)*GRAD_J[r2];\n    float n3 = (u - 1.)*GRAD_I[r3] + (v - 1.)*GRAD_J[r3];\n    \n    /* interpolation */\n    float n01 = lerp(fade(v), n0, n1);\n    float n23 = lerp(fade(v), n2, n3);\n\n    /* rescale noise to [0, 1] */\n    return (lerp(fade(u), n01, n23) + 1.) * .5;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    #if MOUSE == 0\n    \tfloat scrollSpeed = 100.;\n    \tfragCoord.x += iTime * scrollSpeed;\n    #endif\n    #if MOUSE == 1\n    \tfragCoord += iResolution.xy - iMouse.xy;\n    #endif\n    \n    int seed = 0;\n    \n    float[4] noises;\n    noises[0] = noise(10, 10, seed, fragCoord) * .5;\n    noises[1] = noise(20, 20, seed, fragCoord) * .25;\n    noises[2] = noise(40, 40, seed, fragCoord) * .125;\n    noises[3] = noise(80, 80, seed, fragCoord) * .0625;\n    \n    float sum = 0.;\n    for (int i = 0; i < noises.length(); i++) {\n        sum += noises[i];\n    }\n    fragColor.rgb = viridis(sum);\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 400, 421, 421, 489], [491, 518, 557, 557, 592], [594, 656, 692, 726, 1039], [1288, 1349, 1372, 1372, 2026], [2030, 2079, 2144, 2179, 3758], [3762, 3762, 3819, 3819, 4431]], "test": "untested"}
{"id": "wsVXDm", "name": "Colorful_circle", "author": "manmohan", "description": "Circle so far", "tags": ["circle"], "likes": 1, "viewed": 34, "published": "Public", "date": "1574227100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\tvec2 middle = vec2(0.0,0.0);\n    float radios = .3;\n\tif (sqrt(pow(uv.x-middle.x,2.0)+pow(uv.y-middle.y,2.0))<=radios)\n    {\n        col = 0.5 - 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 426]], "test": "untested"}
{"id": "wsVXDV", "name": "Shitty Raytracing", "author": "sebost1234", "description": "ok", "tags": ["shitty"], "likes": 2, "viewed": 103, "published": "Public", "date": "1575061912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int nrofspheres = 7;\nvec4 getSphere(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec4(1.0+sin(iTime)   ,0.9,0.4, 0.01);\n    case 1:\n        return vec4(1.0+sin(iTime+.1),0.7,0.4, 0.01);\n    case 2:\n        return vec4(1.0+sin(iTime+.2),0.5,0.4, 0.01);    \n    case 3:\n        return vec4(1.0+sin(iTime+.3),0.3,0.4, 0.01);   \n    case 4:\n        return vec4(1.0+sin(iTime+.4),0.1,0.4, 0.01);\n    case 5:\n        return vec4(1.0,0.1,5.0, 7.0);\n    case 6:\n        return vec4(1.0+sin(iTime*0.4)*4.,2.0,5.0+cos(iTime*0.4)*4., 1);\n    } \n}\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        return vec3(247./255., 168./255.,  184./255.);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        return vec3(85./255., 205./255., 252./255.);\n    case 5:\n        return vec3(0.5);\n    case 6:\n        return vec3(1.0, 0.5, 0.5);\n    } \n}\n\nfloat getSphereOpacity(int i)\n{\n    return 0.3;    \n}\n\n\nvec3 getLightDir()\n{\n    return vec3(-1.,-1.,0.2);\n}\n\nvec3 skyColor(vec3 ray)\n{\n    float diffuse = clamp(dot(ray,-getLightDir()), 0.0, 10.0);\n    float specular = pow(diffuse, 2.);\n    \n    float tmp1 = diffuse+specular+0.1f;\n    \n    vec3 light = (vec3(tmp1*1., tmp1*1., tmp1*1.)+vec3(0.0,0.0,0.1));\n\n    return light;\n\n    //return texture(iChannel0, ray).rgb;\n}\n\n\nstruct RayCastInfo\n{\n\tint sphereid;//-1 if not hit\n\tfloat t0;\n    float t1;\n};\n\nRayCastInfo calculateRay(vec3 pos, vec3 dir)\n{\n    int sphereid = -1;\n    float truet0=999999999999.;\n    float truet1=999999999999.;\n\n    for(int i = -1;i<nrofspheres;i++)\n    {\n        vec4 sphere = getSphere(i);\n\n        vec3 L = sphere.xyz - pos; \n        float tca = dot(L,dir); \n        if (tca >= 0.)\n        {\n            float d2 = dot(L,L) - tca * tca; \n            if (d2 <= sphere.w)\n            {\n                float thc = sqrt(sphere.w - d2); \n                float t0 = tca - thc; \n                float t1 = tca + thc;\n\n                if(t0<truet0)\n                {\n                    sphereid = i;\n                    truet0 = t0;\n                    truet1 = t1;\n                }\n\n            }\n        }\n    }\n\n    RayCastInfo tmp;\n    tmp.sphereid = sphereid;\n    tmp.t0 = truet0;\n    tmp.t1 = truet1;\n  \treturn tmp;\n}\n\n\nconst int nrofrays = 15;\n\nvec3 calculateMainRay(vec3 startpos, vec3 startdir)\n{\n    vec3 pos[nrofrays];\n    vec3 dir[nrofrays];\n    vec3 color[nrofrays];\n    float count[nrofrays];\n    bool finished[nrofrays];\n    int raycount = 1;\n    \n    pos[0] = startpos;\n    dir[0] = startdir;\n    color[0] = vec3(1.0);\n    finished[0] = false;\n    count[0] = 1.;\n    \n    \n    for(int i = 0;i<nrofrays-1;i++)\n    {\n        for(int o = 0;o<raycount;o++)\n        {\n            if(!finished[o])\n            {\n                RayCastInfo tmp = calculateRay(pos[o],dir[o]);\n\n                if(tmp.sphereid!=-1)\n                {\n                    vec4 sphere = getSphere(tmp.sphereid);\n                    vec3 spherecolor = getSphereColor(tmp.sphereid);\n\t\t\t\t\tfloat sphereopacity = getSphereOpacity(tmp.sphereid);\n                    \n                    pos[o] = pos[o] + dir[o]*tmp.t0;\n                    vec3 normal = normalize(pos[o] - sphere.xyz);\n                    \n\n                    //refraction\n                    if(raycount<nrofrays&&sphereopacity>0.001)\n                    {\n                        raycount++;\n                        \n                        float size = tmp.t1 - tmp.t0;\n                        \n                        vec3 shiftdir = cross(normal, dir[o]);\n                       \n                        pos[raycount-1] =  pos[o] + dir[o]*tmp.t1 + shiftdir*size;\n\n                        dir[raycount-1] = dir[o];\n                        color[raycount-1] = (spherecolor/(size+0.1))*color[o];\n                        color[raycount-1] *= sphereopacity;\n                        \n                        finished[raycount-1] = false;\n                        count[raycount-1] = count[o];\n                    }\n\n                    //reflection\n                    {\n                        dir[o] = reflect(dir[o], normal);\n                        \n                        color[o] *= spherecolor;\n                        \n                        count[o]++;\n                    }\n\n\n                }\n                else \n                {\n                    finished[o] = true;\n                    color[o] *= skyColor(dir[o]);\n                }\n            }\n        }\n    }\n    \n    //if(raycount==2) return vec3(0.0, 1.0, 0.0);\n    \n    \n    vec3 finalcolor = vec3(0.0);\n    for(int i = 0;i<raycount;i++)\n    {\n        finalcolor += color[i]/count[i];\n    }\n    \n    return finalcolor/float(raycount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(fragCoord/iResolution.y, 0); \n    \n    \n    vec2 center = vec2((iResolution.x*0.5)/iResolution.y, (iResolution.y*0.5)/iResolution.y);\n    \n    vec3 raydirection = normalize(pos - vec3(center, pos.z-0.6));\n\n\n    \n    fragColor = vec4(calculateMainRay(pos, raydirection), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 44, 44, 543], [545, 545, 573, 573, 998], [1000, 1000, 1031, 1031, 1053], [1056, 1056, 1076, 1076, 1108], [1110, 1110, 1135, 1135, 1421], [1504, 1504, 1550, 1550, 2348], [2377, 2377, 2430, 2430, 4787], [4789, 4789, 4846, 4846, 5144]], "test": "untested"}
{"id": "WsVXDy", "name": "Helix Particles", "author": "CoolerZ", "description": "Particle system. Trying to recreate this https://codepen.io/gskinner/pen/mmbpjv\nWIP !!!!!!!!!!!!!!!!!!!!!!!!!!!!", "tags": ["workinprogress"], "likes": 3, "viewed": 85, "published": "Public", "date": "1574887646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// trying to recreate this https://codepen.io/gskinner/pen/mmbpjv\n\nfloat circle_d(vec2 uv)\n{\n    return length(uv);\n}\n\nfloat circle_m(vec2 uv)\n{\n    return smoothstep(1., 0.95, circle_d(uv));\n}\n\nvec2 trans(vec2 uv, vec2 xy, float scale)\n{\n    uv -= xy;\n    uv /= scale;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5)/(iResolution.xy - 1.);\n    float asr = iResolution.x/iResolution.y; // aspect ratio\n    uv.x *= asr;\n    vec2 temp_uv = vec2(uv.x - iTime, uv.y);\n    vec2 id = floor(temp_uv * 8.);\n    vec2 old_uv = uv;\n    uv.x -= iTime;\n    //uv.y += id.x * 0.05;\n    uv.y += 2. * sin(id.x * 0.05);\n    uv = fract(uv * 8.);\n    vec3 col = vec3(uv, 0.);\n    //vec3 col = vec3(id * 0.1, 0.);\n\n    //vec3 col = vec3(0.);\n    vec2 circle_pos = vec2(.5, .5);\n    float circle_size = .1;\n\n    float mask = circle_m(trans(uv, circle_pos, circle_size));\n    col = mix(col, vec3(1.), mask);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 92, 92, 117], [119, 119, 144, 144, 193], [195, 195, 238, 238, 286], [288, 288, 345, 345, 1002]], "test": "untested"}
{"id": "wsVXRR", "name": "ZzArt 2 - Generative Abstract", "author": "KilledByAPixel", "description": "Evolved using zzart.3d2k.com", "tags": ["zzart"], "likes": 3, "viewed": 246, "published": "Public API", "date": "1573283387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 a, vec2 p) {\n    vec2 q=p/iResolution.xy;\\\n    a=vec4(2.28*q-4.3,3.53*q-7.67);\\\n    a=cos(a.yywx*a.yyxz+iTime*1.57);\\\n    a-=exp2(a.wyxy);\\\n    vec4 b=(a.wyzy+a.yyzw)*sign(a.y);\\\n    a/=vec2(.88,.42).yyxy;\\\n    a/=a.xzxx;\\\n    a+=b.zzww-normalize(b.yxyw)-log2(b.wwxx);\\\n    b=clamp(abs(mod(3.71-.9*a.x+vec4(0,4,2,1),6.)-3.)-1.,0.,1.);\\\n    a=a.z*mix(vec4(1),b*b*(3.-2.*b),a.y/8.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 405]], "test": "untested"}
{"id": "wsVXRV", "name": "Hot touch spheres", "author": "janiorca", "description": "I was playing with rayleigh scattering and accidentally used the wrong equation for calculating the coefficents whcih created the heat like effect. I ultimately distilled it into the add_burn function.  ", "tags": ["raytracing", "effect", "scattering", "heat"], "likes": 15, "viewed": 375, "published": "Public API", "date": "1574511609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int num_spheres = 30;\n\nconst vec3 sun_dir = normalize( vec3( 1.0, 1.10, 1.0 ));\nconst float maximum_dist = 99999.0;\n\nfloat w_intersect_sphere( float max_t, vec3 ray_dir, vec3 origin, \n    vec3 sphere, float sphere_radius2, int idx_in, \n    out vec3 pos, out vec3 norm, out int idx ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n        return max_t;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return max_t;\n        } \n        else {\n            float thc = sqrt(sphere_radius2-distToMidpoint2);\n            float t0 = tCA - thc;           // entry \n            if( t0 < max_t ) {\n                pos = origin + t0*ray_dir;\n                norm = normalize( pos-sphere);\n                idx = idx_in;\n                return t0;\n            } else {\n                return max_t;\n            }\n        }\n    }\n}\n\n// For shadows we only care if there was intersection\nbool intersects_sphere( vec3 ray_dir, vec3 origin, vec3 sphere, float sphere_radius2 ) {\n   // intersect with sphere \n    vec3 origToSphere = sphere - origin;\n    float tCA = dot( origToSphere, ray_dir);\n    if( tCA < 0.0 ) {\n        // ray center is towards back of ray. cant intsesect\n        return false;\n    } else \n    {\n        float dd = length(origToSphere);\n        float distToMidpoint2 = dd*dd-tCA*tCA;\n        if( distToMidpoint2 > sphere_radius2 ) {\n            return false;\n        } \n        else {\n            return true;\n        }\n    }\n}\n\nfloat ground_plane_intersect( vec3 ray_dir, vec3 origin, float ground, out vec3 pos, out vec3 norm ) {\n    if( ray_dir.y >= 0.0 ) {\n        return maximum_dist;\n    }\n    float t = ( ground-origin.y ) /  ray_dir.y; \n    norm = vec3( 0.0, 1.0f, 0.0f );\n    pos = origin + ray_dir*t;\n    return t;\n}\n\nfloat fresnel( float n, vec3 normal, vec3 incident )\n{\n    // Schlick aproximation\n    float r0 = (1.0-n) / (1.0+n);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n    return ret;\n}\n\nconst vec3 absorption_coeff  = vec3( 0.000005, 0.000015, 0.00027 )*15.0;\nconst vec3 scattering_coeff = vec3( 0.00015, 0.00015, 0.00027 )*15.0;\n\nvec3 extinction( float dist ) {\n    return      exp( -dist*( absorption_coeff + scattering_coeff ) );\n}\n\nvec3 add_burn( float dist ) {\n    vec3 burn = 4.0*vec3( 27.0, 4.0, 1.0 ) / pow( dist, 4.0 );\n    return burn;\n }\n\nvec3 in_scatter( float dist, float cos_angle ) {\n    float rayleigh_scatter = .0003 / 16.0*3.14159* ( 1.0 + cos_angle*cos_angle ); \n\n    vec3 rayleigh_coeff =         vec3( 1.0 / ( absorption_coeff.x + scattering_coeff.x ) * ( 1.0-exp( -dist*( scattering_coeff.x ) ) ),\n                                        1.0 / ( absorption_coeff.y + scattering_coeff.y ) * ( 1.0-exp( -dist*( scattering_coeff.y ) ) ),\n                                        1.0 / ( absorption_coeff.z + scattering_coeff.z ) * ( 1.0-exp( -dist*( scattering_coeff.z ) ) ) );\n\n    float mie_g = 0.476;\n    vec3 mie_scatter =  vec3( 0.0020, 0.0008, 0.0002 ) * ( 1.0 - mie_g )*( 1.0 - mie_g ) / ( 4.0 * 3.14159 * pow( ( 1.0 + mie_g*mie_g  - 2.0 * mie_g *cos_angle ), 1.5 ) ); \n    float mie_coeff = 20.0 / (  absorption_coeff.x + scattering_coeff.x ) \n                            * ( 1.0-exp( -dist*( scattering_coeff.x ) ) );\n    return rayleigh_scatter*rayleigh_coeff+mie_scatter*mie_coeff;\n }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2( 0.5, 0.35 );\n    vec3 spheres[num_spheres];\n\n    float t = iTime*2.0;\n    float adjustedTime = (30.0*t - 45.0*cos(t) + cos(3.0*t) - 9.0* sin(2.0*t))/96.0;\n    adjustedTime += iTime*0.1;\n\n    float e = adjustedTime*0.0452 + 0.448661519;\n    float f = adjustedTime*0.032 + 0.6722;\n    float g = adjustedTime*0.0452 + 0.25389;\n\tfor( int  idx=0; idx < num_spheres; idx++ ) \n    {\n       vec3 spos  = vec3(sin( adjustedTime*0.1823+float(idx)*e )*0.417,\n                            sin( adjustedTime*0.6725+float(idx)*f)*0.35,\n                        sin( adjustedTime*0.135125+float(idx)*g)*0.42 );\n//         float fidx = float(idx);\n//        float fidx2 = fidx*fidx;\n//        vec3 spos = vec3( sin( fidx*0.21312 + adjustedTime * 0.151312 + 0.423 + fidx2*0.324), \n //           sin( fidx*0.17312 + adjustedTime * .372 + 0.4223+ fidx2*1.24 ),\n //           sin( fidx*0.2312 + adjustedTime * .255552 + 1.423+ fidx2*1.1324 )\n//        );\n        spos *= 30.0;\n        spheres[ idx ] = spos;\n    }\n    vec2 uv = fragCoord/iResolution.x;\n    float camera_dist = -35.0 + cos( adjustedTime / 2.0 )*10.0;\n    vec2 screen_pos_2d = 2.0*(uv - center);\n    vec3 screen_pos_3d = vec3( screen_pos_2d, camera_dist+1.0 );\n\n    float _angle = adjustedTime/3.0 + iTime*0.2;\n    mat3 rot_m = mat3( cos(_angle),0,  -sin( _angle ), \n                        0,          1,          0,\n                        sin(_angle), 0, cos(_angle) );\n\n    vec3 origin = rot_m*vec3( 0,0,camera_dist) ;\n    vec3 ray_dir = normalize(rot_m*screen_pos_3d - origin);\n\n    float contribution = 1.0;\n    vec3 final_color = vec3( 0,0,0);\n\n    for( int bounce =2; bounce >0 ; bounce -- ) {\n        vec3 new_ray_dir;\n        vec3 norm;\n        vec3 pos;\n        vec3 diffuseCol;\n        float refractive_index;\n        float reflectance = 0.0;\n        int final_idx = -1;\n        float current_t = maximum_dist;\n        float burn_coeff = 0.0;\n\n        current_t = ground_plane_intersect( ray_dir, origin , -20.0, pos, norm );\n        if( current_t <= maximum_dist ) {\n            refractive_index = 1.77;\n            diffuseCol = vec3( 0.05, 0.05, 0.05 );\n            if( ( ( int( pos.x/5.0) +int(pos.z/5.0) ) & 1 )== 1){\n                float d = ( pos.x*pos.x + pos.z*pos.z );\n                diffuseCol = mix( diffuseCol, vec3( 0.59, 0.6, 0.5 ),\n                     smoothstep( 8000.0, 4000.0, d ) );\n            } \n        } else {\n            diffuseCol = vec3( 1.0, 1.0, 0.0);\n        }\n\n        for( int idx=1; idx < num_spheres; idx++ ) {\n            vec3 vv = vec3( 0.0, 0.0, 0.0 )*float(idx);\n           current_t  =  w_intersect_sphere( current_t, ray_dir, origin, spheres[idx], 4.2*4.2, idx, \n               pos, norm, final_idx);\n        }\n        // workout out material properties\n        if( final_idx > 0 ) {\n            diffuseCol = vec3( 0.02, .02, 0.02 );\n            refractive_index = 1.3171;\n            reflectance = fresnel( refractive_index, norm, ray_dir);\n            new_ray_dir = reflect( ray_dir, norm );\n        }\n\n        vec3 point_color = vec3( 0, 0, 0 );\n\n        if( current_t >= maximum_dist ) {\n            point_color += in_scatter( current_t, dot( sun_dir,ray_dir) );\n            final_color += point_color * contribution;\n            break;\n        }\n\n        // light the point\n        for( int lt=0; lt<1; lt++ ) \n        {\n            // Is the light shadowed\n            bool in_shade = false;\n            for( int idx=1; idx < num_spheres; idx++ ) \n            {\n                if( intersects_sphere( sun_dir, pos, spheres[idx], 4.2*4.2 ) ) \n                {\n                    in_shade = true;\n                    break;\n                }\n            }\n            if( !in_shade)\n            {\n                vec3 reflectedLight = reflect( -sun_dir, norm );\n                vec3 toCamera = -ray_dir;\n                float diffuse = dot( sun_dir, norm );\n\n                vec3 halfway = normalize( toCamera + sun_dir );\n                float specular = pow( dot( norm, halfway ), 121.0 );\n            \n                specular = clamp( specular, 0.0, 1.0 );\n\n                vec3 fragDiffuse = diffuseCol * diffuse;\n                point_color += vec3(specular,specular,specular) + fragDiffuse;\n            } else {\n                point_color += diffuseCol* 0.02;\n            }\n        }\n        // attenuate\n        point_color *= extinction( current_t );\n        if( final_idx !=0 ) {\n            point_color += add_burn( current_t);\n\n        }\n        point_color += in_scatter( current_t, dot( sun_dir,ray_dir) );\n\n        final_color += point_color * contribution * ( 1.0 - reflectance );\n        contribution = contribution * reflectance;\n        ray_dir = new_ray_dir;\n        origin = pos;\n\n        if( final_idx == -1 ){\n            break;\n        }\n    }\n    vec3 fragFinal = pow( final_color, vec3(1.0 / 2.2) );\n    fragColor = vec4(fragFinal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVXRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 290, 319, 1094], [1096, 1150, 1238, 1267, 1708], [1710, 1710, 1812, 1812, 2007], [2009, 2009, 2063, 2091, 2261], [2407, 2407, 2438, 2438, 2510], [2512, 2512, 2541, 2541, 2624], [2626, 2626, 2674, 2674, 3589], [3592, 3592, 3649, 3649, 8544]], "test": "untested"}
{"id": "wsVXRz", "name": "trippy shapes", "author": "ArthurSango", "description": "erre", "tags": ["derp"], "likes": 3, "viewed": 291, "published": "Public API", "date": "1573342530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot( float a, vec2 uv ) {\n    \n    if ( (uv.x < 0.5 && uv.y < 0.5) || (uv.x > 0.5 && uv.y > 0.5) ) {\n      a = -a;\n    }\n    \n    return mat2( cos(a),-sin(a),sin(a),cos(a));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= rot(iTime, uv);\n   uv += 0.5;\n    uv = abs( 2. * uv - 1.);\n   uv = fract( (4. * (mod(uv.x, 2.) +1.)* uv));\n    //uv = fract(2. * uv);\n    \n    uv *= rot( mod( uv.y, 2.), uv);\n    \n    \n\n    vec3 col = vec3(0.);\n    col.r += uv.y * step( 0.9, distance(uv,vec2(sin(iTime))));\n    \n    \n    vec2 a = vec2( uv.x );\n    vec2 b = vec2(uv.y);\n    vec2 c = uv.yx;\n    float mind = 10000. ;\n    mind = min( mind, distance(uv,a));\n     mind = min( mind, distance(uv,b));\n     mind = min( mind, distance(uv,c));\n    \n    col.b = mind;\n    \n     vec2 a2 = vec2( 0.2 );\n    vec2 b2 = vec2(0.5);\n    vec2 c2 = vec2(0.7);\n    float mind2 = 10000. ;\n    mind2 = min( mind2, distance(uv,a2));\n     mind2 = min( mind2, distance(uv,b2));\n     mind2 = min( mind2, distance(uv,c2));\n    \n    col.g = mind2;\n    \n    col *= 1.4 ;\n    \n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 181], [183, 183, 240, 290, 1210]], "test": "untested"}
{"id": "wsySDw", "name": "Another_circle", "author": "manmohan", "description": "tutorial from the art of code", "tags": ["artofcode"], "likes": 0, "viewed": 42, "published": "Public", "date": "1574228776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = ( fragCoord -.5* iResolution.xy ) /iResolution.y;\n    // Time varying pixel color\n\tfloat r = 0.3;\n    float d = length(uv);\n    float c = smoothstep(r,r-(3.0/iResolution.y),d);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,c,4));\n    //if (d<r) c=1.0; else c=0.0;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 442]], "test": "untested"}
{"id": "wsySRG", "name": "Crosshatch shadow", "author": "yasuo", "description": "3D meta ball with the Crosshatch shadow.", "tags": ["raymarching", "shadow"], "likes": 1, "viewed": 263, "published": "Public API", "date": "1574261802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 N33(vec3 p) {\n    vec3 a = fract(p*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec3(a.x*a.y,a.y*a.z,a.z*a.x));\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat metaball(vec3 p, float i, float t) {\n    vec3 n = N33(vec3(i));\n    vec3 p2 = sin(n*t)*1.0;\n    p2.y += 2.1;\n    vec3 spp = p-p2;\n    float sp = length(spp)-(0.5+(i*0.1));\n    return sp;\n}\n\nvec4 metaBalls(vec3 p) {\n    float res = 1.0;\n    float t = iTime*3.0;\n    vec4 mb = vec4(1.0);\n\n    float k = 0.9;\n    res = smin(res,metaball(p,1.0, t),k); \n    res = smin(res,metaball(p,2.0, t),k); \n    res = smin(res,metaball(p,3.0, t),k); \n    res = smin(res,metaball(p,4.0, t),k); \n    res = smin(res,metaball(p,5.0, t),k); \n    res = smin(res,metaball(p,6.0, t),k); \n    \n    mb = vec4(mix(vec3(p.x,0.0,p.z),vec3(1.0,1.0,1.0),0.5),res*2.0);\n    \n    return mb;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    float _floor = p.y;\n\n    vec4 mb = metaBalls(p);\n    vec4 f = vec4(vec3(0.5,0.8,0.5),_floor*0.6);\n    \n    vec4 model = combine(mb,f);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nfloat GetAmbientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - RayMarch(p + n*d,n).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n\n    float ao = GetAmbientOcclusion(p,n);\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif*ao),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.xz *= Rot(radians(iTime*20.0));\n    ro.yz *= Rot(radians(-20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        \n        // This only floor gets shadow effect.\n        if(p.y<0.005 && dif.y>=0.899 && dif.y<=0.9){\n            float hatch_y_offset = 12.0;\n            float lum_threshold_1 = 2.0;\n            float lum_threshold_2 = 1.7;\n            float lum_threshold_3 = 1.5;\n            float lum_threshold_4 = 1.3;\n            \n            float lum = length(col.rgb);\n            vec3 tc = vec3(1.0);\n            vec3 hatchColor  = vec3(0.0, 0.8, 1.0);\n            \n            if (lum < lum_threshold_1) \n            {\n              if (mod(fragCoord.x + fragCoord.y, hatch_y_offset) == 0.0) \n                tc = hatchColor;\n            }  \n\n            if (lum < lum_threshold_2) \n            {\n              if (mod(fragCoord.x - fragCoord.y, hatch_y_offset) == 0.0) \n                tc = hatchColor;\n            }  \n\n            if (lum < lum_threshold_3) \n            {\n              if (mod(fragCoord.x + fragCoord.y - hatch_y_offset, hatch_y_offset) == 0.0) \n                tc = hatchColor;\n            }  \n\n            if (lum < lum_threshold_4) \n            {\n              if (mod(fragCoord.x - fragCoord.y - hatch_y_offset, hatch_y_offset) == 0.0) \n                tc = hatchColor;\n            }\n            \n            col *= tc;\n        }\n        \n    } else {\n        // background\n        col = vec3(0.3,0.5,0.8);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 304, 322, 322, 446], [448, 448, 489, 489, 580], [582, 582, 618, 618, 660], [662, 662, 691, 691, 775], [777, 777, 819, 819, 971], [973, 973, 997, 997, 1442], [1444, 1444, 1466, 1466, 1630], [1632, 1632, 1665, 1665, 1918], [1920, 1920, 1944, 1944, 2145], [2147, 2147, 2181, 2181, 2495], [2497, 2497, 2540, 2540, 2843], [2845, 2845, 2868, 2868, 3269], [3271, 3271, 3313, 3313, 3508], [3510, 3510, 3567, 3567, 5494]], "test": "untested"}
{"id": "WsySRt", "name": "hex blob", "author": "Sintel", "description": "some hexagon test", "tags": ["hex"], "likes": 2, "viewed": 44, "published": "Public", "date": "1574678596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//adapted from:\n\n// \"ShaderToy Tutorial - Hexagonal Tiling\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/VmrIDyYiJBA\n\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nvec2 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    //float x = atan(gv.x, gv.y);\n    //float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec2(id.x,id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    uv *= 100.;\n    \n    vec2 hc = HexCoords(uv);\n    \n    //float c = smoothstep(41., 40., 5.*sin(hc.x*0.3) + 5.*sin(hc.y*0.3) + length(hc)+50.*sin(0.8*iTime));\n    \n    col.r = smoothstep(41., 40., 5.*sin(hc.x*0.3) + 5.*sin(hc.y*0.3) + length(hc)+50.*sin(0.8*iTime));\n    col.g = smoothstep(41., 30., 5.*sin(hc.x*0.3) + 5.*sin(hc.y*0.3) + length(hc)+50.*sin(0.8*iTime+0.1));\n    col.b = smoothstep(41., 40., 5.*sin(hc.x*0.3) + 5.*sin(hc.y*0.3) + length(hc)+50.*sin(0.8*iTime+0.2));\n    \n    col = floor(col*8.0)/8.0;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsySRt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[17, 290, 313, 313, 420], [422, 422, 447, 447, 723], [725, 725, 782, 782, 1424]], "test": "untested"}
{"id": "wsySRW", "name": "Twitch: Legend of the Angry Ball", "author": "blackle", "description": "made this during a twitch livestream: https://www.twitch.tv/videos/505355583", "tags": ["clouds", "twitch", "liveshader"], "likes": 7, "viewed": 307, "published": "Public API", "date": "1573514499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat edge(vec2 p, vec2 k) {\n  p.y = abs(p.y);\n  p -= k;\n  float sgn = sign(p.x)+sign(p.y);\n  return sgn == 2. ? length(p) : max(p.x,p.y);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k);\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat component(vec3 p, vec3 ro) {\n  float phi = acos(ro.x);\n  float theta = ro.y*3.1415;\n  vec3 ax = vec3(cos(phi), sin(phi)*cos(theta), sin(phi)*sin(theta));\n  p = erot(p, ax, ro.z*3.1415);\n  \n  \n  vec3 sgn = mod(floor(p),2.)*2.-1.;\n  p = (fract(p)-0.5);\n  p*=sgn;\n  return (p.x+p.y+p.z)/sqrt(3.);\n}\n\nfloat hash1(float rnd) {\n  return hash(vec2(rnd,rnd*rnd+1.));\n}\n\nvec3 hash3(float rnd) {\n  return vec3(hash1(rnd+1.), hash1(hash1(rnd+2.)), hash1(hash1(rnd*2.+2.)*3.));\n}\n\nfloat noise(vec3 p, int iters) {\n  float d = 0.;\n  float acc =1.;\n  for (int i = 0; i < iters; i++) {\n    acc+=1.;\n    d += component(p, hash3(float(i)));\n  }\n  \n  return d/sqrt(acc*1.5)-0.2;\n}\n\nvec2 levl(vec3 p, vec3 off, float s) {\n\n  vec3 cls = normalize(p) * s; \n  return vec2(length(noise(cls+off, 1)), distance(p, cls));\n}\n\nfloat bpm = 136.;\n\nvec2 mmin(vec2 a, vec2 b) {\n  if (a.x < b.x) return a;\n  return b;\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  return distance(p, mix(a,b,clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.)));\n}\n\nfloat bgcol = 0.;\n\nvec2 scene(vec3 p) {\n  vec2 dst = vec2(100000.,-1.);\n  \n  float bar = floor(iTime/60.*bpm);\n  float iter = mod(bar, 4.)+1.;\n  \n  if (iter == 4.) iter = 2.;\n  float k = 0.;\n  for (int i = 0; i < int(iter); i++) {\n    vec2 mp = levl(p, vec3(iTime/2.), 1.+(float(i)+1.)*0.2);\n    if (i==0) k = -mp.x + 0.35;\n    float lev = edge(mp, vec2(0.3 - float(i)*0.15, 0.05))-0.05;\n    vec2 col = vec2(lev, float(i)+1.);\n    dst = mmin(dst, col);\n    bgcol = float(i)+1.;\n  }\n  \n  vec3 nrz = normalize(p)*1.2;\n  float krt=0.1;\n  float dthrg = length((fract(nrz/krt + iTime/2.)-0.5)*krt);\n  vec2 rtir = vec2(dthrg, distance(p, nrz));\n  float rz = length(p)-1.2;\n  \n  float anger = pow(fract(iTime/60.*bpm),0.5) * (length(sin(nrz*8.+iTime))/sqrt(3.)*0.5+0.5);\n  if (mod(bar, 4.) != 3.) anger = 0.;\n  rz = linedist(rtir, vec2(0), vec2(0,anger))-0.02;\n  rz = -min(-rz,-k);\n  rz = min(rz, length(p)-1.2);\n  \n  return mmin(vec2(rz,0),dst);\n}\n\n#define AP(f,k) vec3(f(k[0]).x,f(k[1]).x,f(k[2]).x)\nmat3 ep = mat3(0.01);\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-ep;\n  return normalize(scene(p).x - AP(scene,k));\n}\n\n\n\nvec3 colr(float m) {\n  vec3 col = vec3(0);\n  if (m == 0.) col= vec3(153,70,70);\n  if (m == 1.) col=vec3(173, 173, 173);\n  if (m == 2.) col=vec3(100, 222, 207) ;\n  if (m == 3.) col=vec3(255, 255, 255);\n  return col / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  //uv*=4;\n  float pound = fract(iTime/60.*bpm);\n  vec3 cam = normalize(vec3(1.+pound*0.3,uv));\n  vec3 init = vec3(-5.,0.,0.);\n  \n  float ro = iTime/2.;\n  cam = erot(erot(cam,vec3(0.,1.,0.), ro/3.), vec3(0.,0.,1.), ro);\n  init = erot(erot(init,vec3(0.,1.,0.), ro/3.), vec3(0.,0.,1.), ro);\n  \n  vec3 p = init;\n  bool hit = false;\n  vec2 dist;\n  for(int i = 0; i < 60; i++) {\n    dist = scene(p);\n    if (abs(dist.x)<0.001) { hit = true; break; }\n    if (distance(p, init) > 100.) break;\n    p+=cam*dist.x;\n  }\n  \n  vec3 n = norm(p);\n  vec3 c = colr(hit ? dist.y : bgcol);\n  //float edg = noise(vec3(uv,iTime/10));\n  vec3 colc = sqrt(c*c*length(sin(n*2.)*0.5+0.5)/sqrt(3.));\n  fragColor.xyz = erot(colc*2.-1., normalize(vec3(1.,1,2)), iTime)*0.5+0.5;\n  \n  fragColor.xyz += vec3(hash(uv*(iTime+0.1))*0.05);\n  if(hit) return;\n  \n  \n  vec3 p2 = init;\n  float dist2;\n  float k =1.;\n  for(int i = 0; i < 20; i++) {\n    dist2 = noise(p2, 4)-0.2;\n    if(i==0)k=sign(dist2);\n    dist2*=k;\n    if (abs(dist2)<0.001) { break; }\n    if (distance(p2, init) > 100.) break;\n    p2+=cam*dist2;\n  }\n  float col = length(sin(p2)*0.5+0.5)/sqrt(3.);\n  fragColor.xyz*=mix(col, 1.,0.4);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 141], [199, 199, 219, 219, 299], [301, 301, 339, 339, 401], [403, 403, 437, 437, 704], [706, 706, 730, 730, 769], [771, 771, 794, 794, 876], [878, 878, 910, 910, 1071], [1073, 1073, 1111, 1111, 1206], [1227, 1227, 1254, 1254, 1295], [1297, 1297, 1337, 1337, 1410], [1431, 1431, 1451, 1451, 2353], [2429, 2429, 2448, 2448, 2523], [2527, 2527, 2547, 2547, 2750], [2752, 2752, 2809, 2809, 4113]], "test": "untested"}
{"id": "WsySW1", "name": "Codevember #15", "author": "desertsky", "description": "Colorsssss", "tags": ["sdf", "beginner", "newbie"], "likes": 2, "viewed": 234, "published": "Public API", "date": "1573871620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return float((p.x+p.y+p.z-s)*0.57735027);\n}\nvec2 sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),1.));\n}\n\nvec2 map(vec3 p)\n{\n    vec3 q = mod(p+0.5*2.,2.)-2.*.5;\n    vec2 pl = vec2(.7+p.y,0.);\n    \n    vec2 sphere = vec2(length(q) - .3,1.);\n    \n    vec2 box = vec2(sdOctahedron(q,.25),1.);\n    \n    vec2 morph = vec2(mix(sphere.x,box.x,sin(iTime)),1);\n\n//    sdf = min(sdf,sphere);\n\treturn (morph.x < pl.x) ? morph : pl;\n\n}\n\n\n//raymarching\nvec2 RM(vec3 ro, vec3 rd) \n{\n    float m = -1.;\n    float dO = 0.;\n    \n    for (int i = 0; i < 100; i++) {\n\n        vec2 p = map(ro + rd * dO);\n        m = p.y;\n        if (p.x <= .01) break;\n        dO+=p.x;\n        if (dO >= 20.) \n        {\n            dO = -1.;\n        \tbreak;\n        }        \n    }\n    return vec2(dO,m);\n}\n\n//normals\nvec3 n(vec3 p) \n{\n    float d = map(p).x;\n    vec2 e = vec2(.001,.0);\n    vec3 pn = d - vec3(\n        map(p-vec3(e.xyy)).x,\n        map(p-vec3(e.yxy)).x,\n        map(p-vec3(e.yyx)).x\n        );\n    return normalize(pn);\n}\n\n//lighting\nvec3 l(vec3 p)\n{\n    vec3 mat = vec3(1.,.75,.5);\n    vec3 nor = n(p);\n    vec3 sunDir = vec3(2,1.,-1);\n\n    vec3 sunDif = clamp(dot(nor,sunDir),0.,1.)*mat;\n\n    vec3 skyDif = clamp(dot(nor,vec3(0.,1.,0.)),0.,1.)*vec3(0.,2.,4.)*.02;\n\t\n    vec3 bounce = (clamp(dot(nor,sunDir*-1.),.0,1.))*vec3(1.)*.005;\n    \n//    float sunSha = step(RM(p+n(p)*.02,sunDir),0.);\n    \n    \n    return sunDif+skyDif+bounce;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1,.3,.5)*uv.y*2.;\n    \n\t\n    vec3 ro = vec3(sin(10.*iMouse.x/iResolution.x), sin(5.*iMouse.y/iResolution.y),cos(10.*iMouse.x/iResolution.x));\n    vec3 ta = vec3(0.);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(.0,1.,.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(uv.x*uu+uv.y*vv+1.5*ww);\n    \n    vec2 rm = RM(ro,rd);\n    \n    if(rm.x > -1.) \n    {\t\n\t\tvec3 p = ro + rd * rm.x;\n\t\tvec3 mate = vec3(0.);\n        if(rm.y == 0.) {         mate = vec3(.2,.2,0.1);}\n        else if(rm.y > 1.) {        mate = vec3(.0,1.,.0);}\n        else { mate = mix(vec3(.9,.8,9.),vec3(.3*p.x,.5*p.z/2.,.9-p.x),sin(iTime));}\n        \n    \tcol = vec3(l(p))*mate;\n    \t\n            // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*p*p ) );\n\n        \n//        col = vec3(rm.y);\n    }\n    \n    \n    //gamma\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsySW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 98], [99, 99, 129, 129, 221], [223, 223, 241, 241, 541], [544, 558, 586, 586, 888], [890, 900, 917, 917, 1121], [1123, 1134, 1150, 1150, 1538], [1540, 1540, 1597, 1597, 2593]], "test": "untested"}
{"id": "wsySWc", "name": "Ray Tracer Spheres Stolen", "author": "undeadmockingbird", "description": "stolen spheres: https://www.shadertoy.com/view/XllBRf", "tags": ["raymarching"], "likes": 3, "viewed": 109, "published": "Public", "date": "1575152771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int nSpheres = 5; \nconst float sphereRadius = 3.0 / log2(float(nSpheres));\nconst float tau = 6.28318;\nconst float inf = 999.0;\nstruct Hit { \n    float t; \n    vec3 p; \n    vec3 n;\n    int id;\n};\nHit noHit;\n\nHit sphereHit(\n    vec3 center, \n    float radius, \n    vec3 rayOrigin, \n    vec3 rayDirection, \n    int id) \n{\n    radius += sin(dot(rayOrigin,rayDirection) * 5.0) / 2.0;\n    float a = dot(rayDirection, rayDirection);\n    vec3 L = rayOrigin - center;\n    float b = 2.0 * dot(rayDirection, L);\n    float c = dot(L, L) - radius * radius;\n    float discrim = b * b - 4.0 * a * c;\n    if (discrim < 0.0) return noHit;\n    float t = (-b - sqrt(discrim)) / (2.0 * a);\n    if (t < 0.0) {\n        return noHit;\n    }\n    vec3 p = rayOrigin + t * rayDirection;\n    return Hit(t, p, normalize(p - center), id);\n}\n\nHit hitSomething(vec3 rayOrigin, vec3 rayDirection, float time) {\n    const float fns = float(nSpheres);\n    Hit minHit = noHit;\n    for (int i = 0; i < nSpheres; i++) {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = sin(time * fni + fi) + 2.5;\n        vec3 center = vec3(\n            d*cos(tau*fni+time*10.0*fni) + sin(time*10.0) + 1.0, \n            d*sin(tau*fni+time*10.0*fni) + 1.0,\n            d*sin(0.5*tau*fni+time*fni*1.4142) + cos(time*10.0) + 1.0);\n        Hit hit = sphereHit(\n            center, \n            sphereRadius + sphereRadius * 2.0 * pow(float(i%10)/10.0, 5.0), \n            rayOrigin, \n            rayDirection, \n            0);\n        if (hit.t <= 0.0 || hit.t > minHit.t) continue;\n        minHit = hit;\n    }\n    Hit hit = sphereHit(vec3(0.0, -41.5, 2.0), 40.0, rayOrigin, rayDirection, 1);\n    if (hit.t > 0.0 && hit.t < minHit.t) {\n        minHit = hit;\n    }\n    return minHit;\n}\n\nvec3 colorSomething(\n    Hit hit, \n    float time, \n    vec3 rayOrigin, \n    vec3 rayDirection, \n    mat3x3 cam) \n{\n    if (hit.t > inf - 0.5) {\n        return vec3(0.0, 0.75+0.25*sin(time), 1.0);\n    }\n    vec3 color;\n    // diffuse\n    if (hit.id == 0) {\n        float dup    = 1.0 * dot(hit.n, cam[1]) + 0.0;\n        float dright = 1.0 * dot(hit.n, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(hit.n, -cam[2] ) + 0.0;\n        color = vec3(dright, dup, dfwd);\n    } else if(hit.id == 1) {\n        color = vec3(sin((hit.p.x+iTime)*3.0), cos(hit.p.y*20.0),0.0);\n    }\n    // specular\n    vec3 refl = reflect(rayDirection, hit.n);\n    float spec = pow(dot(refl, cam[1]), 20.0);\n    if (spec > 0.0) {\n        color += vec3(spec, spec, spec);\n    }\n    return color;\n}\n\nconst int maxDepth = 4;\nvec3 trace( \n    mat3x3 cam, \n    vec3 rayOrigin, \n    vec3 rayDirection, \n    float time)\n{\n    vec3 color = vec3(0.2);\n    float ref = 1.0;\n    for (int i = 0; i < maxDepth; i++) {\n        Hit minHit = hitSomething(rayOrigin, rayDirection, time);\n        if (minHit == noHit) {\n            break;\n        }\n        color += ref * colorSomething(minHit, time, rayOrigin, rayDirection, cam);\n        ref *= 0.6;\n        rayOrigin = minHit.p;\n        rayDirection = reflect(rayDirection, minHit.n);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    const vec3 zero = vec3(0.0, 0.0, 0.0);\n    noHit = Hit(inf, zero, zero, -1);\n    \n    // make time optionally srubbable\n    float time = (iMouse.z > 0.0) ? iMouse.x / iResolution.x : iTime / 15.0;\n    float camDist = 8.0;\n    vec3 rayOrigin = vec3(\n        1.1 * camDist * sin(tau * time * 0.5), \n        0.0,\n        0.9 * camDist * cos(tau * time * 0.5));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, -1.0, 0.0);\n    vec3 fwd   = normalize(lookat - rayOrigin);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rayDirection = normalize(fwd + 0.5 * (uv.x*right + uv.y*up));\n    \n    fragColor = vec4(trace(\n        mat3x3(right, camup, fwd), rayOrigin, rayDirection, time), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 324, 324, 816], [818, 818, 883, 883, 1758], [1760, 1760, 1875, 1875, 2528], [2554, 2554, 2646, 2646, 3077], [3079, 3079, 3135, 3135, 4001]], "test": "untested"}
{"id": "wsySzK", "name": "Surface experiments: organism", "author": "tomoe", "description": "with tricky SDF", "tags": ["raymarching"], "likes": 1, "viewed": 197, "published": "Public API", "date": "1574410719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPSILON 1e-4\n#define INFTY 1e6\n\nfloat surfaceSDF(vec3 p) {\n    float t = iTime * 0.3;\n    return (0.2 - 0.2 * pow(sin(cos(t)), 2.0)) \n        * length(\n            sin(abs(sin(0.1 * t * PI) + 2.5) * PI * sin(0.2 * t) * p)\n            - vec3(0.0, 0.0, 0.5)\n        ) \n        - 0.1 * p.x * p.y * p.z \n        + 0.2 * p.z * p.z * p.z \n        - 0.2 * p.x * p.x;\n    }\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\nvec3 getNormal(vec3 p) {\n    float d = EPSILON;\n    return normalize(vec3(\n            surfaceSDF(p + vec3(d, 0.0, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec3(0.0, d, 0.0)) - surfaceSDF(p),\n            surfaceSDF(p + vec3(0.0, 0.0, d)) - surfaceSDF(p)\n        ));\n}\nfloat getDiff(vec3 p, vec3 dir) {\n    float d = EPSILON;\n    return (surfaceSDF(p + d*dir) - surfaceSDF(p)) / d;\n}\nmat3 rotX(float t) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(t), cos(t),\n        0.0, - cos(t), sin(t)\n    );\n}\nmat3 rotY(float t) {\n    return mat3(\n        sin(t), 0.0, cos(t),\n        0.0, 1.0, 0.0,\n        - cos(t), 0.0, sin(t)\n    );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 lightDir = vec3(0.0, 4.0, 1.0);\n    \n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0, 1.0);\n    vec3 cDir = vec3(0.0, - 0.0, - 1.0);\n    vec3 cUp = vec3(0.0, 1.0, 0.0);\n    float targetDepth = 1.0;\n    float t = iTime * 0.2;\n    cPos = rotX(t) * rotY(t) * cPos;\n    cDir = rotX(t) * rotY(t) * cDir;\n    cUp = rotX(t) * rotY(t) * cUp;\n    lightDir = rotX(t) * lightDir;\n    vec3 cSide = cross(cDir, cUp);\n    \n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    float ang = getAngle(ray, - normalize(cPos));\n    vec3 rPos = cPos + ray;\n    \n    // marching loop\n    for(int i = 0; i < 120; i ++ ) {\n        rPos += 0.015 * ray;\n        if (surfaceSDF(rPos) < 0.01) {\n            break;\n        }\n    }\n    vec3 normal = getNormal(rPos);\n    float diff = clamp(dot(normalize(lightDir - rPos), normal), 0.01, 1.0);\n\n    // hit check\n    if (surfaceSDF(rPos) < 0.01) {\n        fragColor = vec4(diff * vec3(rPos.x, 1.0, rPos.p), 1.0);\n    } else {\n        fragColor = vec4(vec3(1.0, 1.0, 1.0), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 91, 91, 398], [399, 399, 431, 431, 483], [484, 484, 508, 508, 760], [761, 761, 794, 794, 875], [876, 876, 896, 896, 1004], [1005, 1005, 1025, 1025, 1133], [1134, 1134, 1189, 1189, 2350]], "test": "untested"}
{"id": "wsySzw", "name": "blob spheres", "author": "dma", "description": "Two spheres with phong lighting and smooth unioned so they blob together.", "tags": ["phong", "raymarch", "smooth"], "likes": 3, "viewed": 78, "published": "Public", "date": "1573614273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 union_objs(in vec2 obj0, in vec2 obj1) {\n    if (obj0.x < obj1.x) return obj0;\n    return obj1;\n}\n\nvec2 smoothUnion(in vec2 obj0, in vec2 obj1, in float k) {\n    float h = clamp(0.5 + 0.5 * (obj1.x - obj0.x)/k, 0., 1.);\n    return vec2(\n        mix(obj1.x, obj0.x, h) - k * h * (1.0 - h),\n        obj0.y\n    );\n}\n\nvec2 plane(in vec3 p) {\n    return vec2(p.y + 4., 0);\n}\n\nvec2 sphere(in vec3 p, in float r) {\n    float d = length(p) - r;\n    return vec2(d, 1.);\n}\n\nvec2 scene(in vec3 p) {\n    return union_objs(\n        plane(p),\n        smoothUnion(\n\t        sphere(vec3(p.x, p.y+sin(2.*iTime)*1.5, p.z), 1.5),\n            sphere(vec3(p.x+sin(iTime)*3., p.y, p.z), 1.0),\n            0.3\n        )\n    );\n}\n\nvec3 floor_color(in vec3 p) {\n    if (fract(p.x * 0.2) > 0.2) {\n        if (fract(p.z * 0.2) > 0.2) return vec3(0., 1., 0.);\n        return vec3(0.5, 0.6, 0.);\n    }\n    return vec3(0.5, 0.6, 0.);\n}\n\nvec3 prim_color(in vec3 p) {\n    return vec3(0.6, 0.6, 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n\n    vec2 vPos = -1. + 2. * uv;\n    \n    // up vector\n    vec3 vuv = vec3(0,1,0);\n    \n    // lookat\n    vec3 vrp = vec3(0);\n    \n    // cam pos\n    vec3 prp = vec3(-3, 2, -6);\n    \n    // light pos\n    vec3 lrp = vec3(-1, 6.5, -8);\n    \n    \n    // set up cam\n    vec3 vpn = normalize(vrp - prp);\n    vec3 u = normalize(cross(vuv, vpn));\n    vec3 v = cross(vpn, u);\n    vec3 vcv = (prp + vpn);\n    \n    vec3 scrCoord = vcv + vPos.x * u * 1. + vPos.y * v * ar;\n    vec3 scp = normalize(scrCoord-prp);\n    \n    // raymarch!\n    const vec3 e = vec3(0.02, 0, 0);\n    const float maxd = 100.;\n    vec2 d = vec2(0.02, 0.);\n    vec3 p;\n    \n    float f = 1.;\n    for (int i = 0; i < 256; i++) {\n        if ((abs(d.x) < .001) || f > maxd) break;\n        f += d.x;\n        p = prp + scp*f;\n        d = scene(p);\n    }\n    \n    vec3 c;\n    if (f < maxd) {\n        if (d.y == 0.) {\n            c = floor_color(p);\n        } else {\n            c = prim_color(p);\n        }\n        \n        vec3 n = vec3(d.x - scene(p - e.xyy).x,\n                      d.x - scene(p - e.yxy).x,\n                      d.x - scene(p - e.yyx).x);\n        vec3 N = normalize(n);\n        float b = dot(N, normalize(lrp-p));\n        \n        // phong lighting\n        c = vec3((b*c + pow(b,64.))*(1. - f*.02));\n    } else {\n\t    c = vec3(.0, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 102], [104, 104, 162, 162, 317], [319, 319, 342, 342, 374], [376, 376, 412, 412, 467], [469, 469, 492, 492, 710], [712, 712, 741, 741, 910], [912, 912, 940, 940, 974], [976, 976, 1033, 1086, 2533]], "test": "untested"}
{"id": "wsyXDW", "name": "color combinations", "author": "sobriquet", "description": "a grid of color combinations, somewhat inspired by Vasarely", "tags": ["grid", "vasarely"], "likes": 3, "viewed": 117, "published": "Public", "date": "1574253272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Experimenting with a grid of color combinations. The sides of the grid\n// are assumed to be a power of 2.\n//\n// Similar to this GeoGebra demonstration:\n// https://www.geogebra.org/m/eu75wg5x\n\n\n#define r (sqrt(2.)/4.)\n//#define r sqrt(1./(2.*acos(-1.)))\n\nvec3 f2c(float f) // compute the RGB components of a hue value between 0 and 1 \n{\n    return vec3(smoothstep(1./3.,1./6.,f)+smoothstep(2./3.,5./6.,f),\n                smoothstep(0.,1./6.,f)-smoothstep(1./2.,2./3.,f),\n                smoothstep(1./3.,1./2.,f)-smoothstep(5./6.,1.,f));\n}\n\nfloat c2i(float c, float f1, float f2) // assign a unique number to every point in a square grid\n{\n    float s1=0.;\n    float s2=0.;\n\n    float p1 = 1.;\n    float p2 = 1.;\n    for(float i=0.;i<(log2(c));i++) {\n    \ts1 += p2*mod(floor(f1/p1),2.);\n        s2 += 2.*p2*mod(floor(f2/p1),2.);\n        p1 *= 2.;\n        p2 *= 4.;\n    }\n\treturn s1+s2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c1 = 8.;\n    vec2 R = iResolution.xy;\n    float s = (max(R.x,R.y)-min(R.x,R.y))/2.;\n    float AA = 0.01*(c1/8.)*(2000./max(R.x,R.y));\n    vec2 uv1 = (fragCoord -.5* R.xy)/R.y;\n    vec2 uv = fract(c1*uv1);\n    float f1 = floor(c1*(fragCoord.x-s)/R.y);\n    float f2 = floor(c1*fragCoord.y/R.y);\n    float f3 = c2i(c1,f1,f2);\n    \n    float uvl = length(uv-.5);\n    vec3 col = f2c(fract((iTime+5.)*.05+f3/(c1*c1)+(.25*(mod(f3,3.)+1.))+abs(floor(mod(f3,4.)/2.)-mod(f3,2.))/2.))*smoothstep(uvl,uvl+AA,r)+\n        \t   f2c(fract((iTime+5.)*.05+f3/(c1*c1)+abs(floor(mod(f3,4.)/2.)-mod(f3,2.))*(.25*(mod(f3,3.)+1.))))*smoothstep(uvl+AA,uvl,r);\n    col *= vec3(step(abs(uv1.x),.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 257, 338, 338, 542], [544, 544, 642, 642, 890], [892, 892, 949, 949, 1665]], "test": "untested"}
{"id": "wsyXDz", "name": "2dMountainscape", "author": "ircss", "description": "A mountain scape done with Triangular waves.", "tags": ["2d", "triangularwaves", "mountainscape"], "likes": 18, "viewed": 273, "published": "Public", "date": "1573910730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SkyColorTop         vec3(39,  98,  176) /255.\n#define SkyColorButtom      vec3(140, 185, 245) /255.\n#define MountainOneBCol     vec3(140, 95,  84 ) /255.\n#define MountainOneSCol     vec3(189, 178, 149) /255.\n#define MountainTwoBCol     vec3(150, 87,  60 ) /255.\n#define MountainTwoSCol     vec3(209, 166, 119) /255.\n#define MountainThreeBCol   vec3(158, 107, 55 ) /255.\n#define MountainThreeSCol   vec3(214, 127, 64 ) /255.\n#define MountainFourBCol    vec3(112, 37,  0  ) /255.\n#define MountainFourSCol    vec3(227, 77,  27 ) /255.\n#define PoltColorBase       vec3(112, 37,  0  ) /255.\n#define PoltColorSecond     vec3(227, 77,  27 ) /255.\n#define BushesBase          vec3(82,  56,  0  ) /255.\n#define BushesSecond        vec3(130, 85,   0 ) /255.\n\n\n#define std           uvCoordinate, col\n#define mountainOne   MountainOneBCol,   MountainOneSCol,   0.5, 0.4,  0.2,  0.0085, 1.\n#define mountainTwo   MountainTwoBCol,   MountainTwoSCol,   0.3, 0.3,  0.35, 0.02,   13.\n#define mountainThree MountainThreeBCol, MountainThreeSCol, 0.2, 0.09, 0.25, 0.1,    7.\n#define mountainFour  MountainFourBCol,  MountainFourSCol,  0.1, 0.1,  0.2,  0.3,    22.\n\n// HELPERS -----------------------------------------------\nfloat rand(float seed){\n    return fract(sin(seed *512.)*42.1);\n}\n\n\n// =======================================================\n// DRAWING -----------------------------------------------\n\nfloat tWave(float x, float amplitude, float frequency){\n      return abs((fract(x*frequency) *2.)-1.) * amplitude;   \n}\n\nvoid sky(in vec2 coord, inout vec3 color){\n    color = mix(SkyColorButtom, SkyColorTop, coord.y);\n}\n\n\n\nvoid mountain(in vec2 coord, inout vec3 color,\n              in vec3 col1, in vec3 col2, float beginingHeight, \n              float baseFrecuqncy, float baseAmplitude, float scrollSpeed, float seed ){\n    \n    \n    coord.x += iTime*scrollSpeed;\n    float f  = beginingHeight ;\n    float d  = 0.  ;\n    \n    for(float i = 1.; i<10.; i++){\n      \n        f +=  tWave( coord.x + rand(i+seed),baseAmplitude / pow(1.95,i) ,baseFrecuqncy * pow(1.95,i));\n        \n    }\n    \n        for(float i = 1.; i<4.; i++){\n      \tfloat t  = tWave( coord.x+ rand(i+seed),baseAmplitude / pow(1.95,i) ,baseFrecuqncy * pow(1.95,i));\n              d +=  tWave(coord.x+ rand(i+seed)- coord.y*(t-0.5)*(4.+rand(i+seed)),baseAmplitude / pow(1.95,i) ,baseFrecuqncy * pow(1.95,i));\n    }\n    \n          d    = smoothstep(-0.0015,0.0015, dFdx(d));\n       \n          f    = 1.-step(f , coord.y);\n    \n    vec3 cTemp = mix(col2,col1 , d);\n         color = mix(color, cTemp, f);\n}\n\nvoid Pols(in vec2 coord, inout vec3 color){\n    \n    coord.x += iTime *1.8;\n    float f  = smoothstep(0.015, 0.05, fract(coord.x*0.5));\n    vec3  c  = mix(PoltColorBase, PoltColorSecond, smoothstep(0.2, 0.4, f));\n       color = mix(c,  color, f);\n    \n}\n\nvoid Bushes(in vec2 coord, inout vec3 color){\n    \n    coord.x += iTime *3.8;\n    \n     \n    float baseAmplitude = 1.;\n    float baseFrecuqncy = .1;\n    \n    float t = 0.;\n    float stripes =0.;\n       for(float i = 1.; i<8.; i++){\n      \n        float yC = tWave( coord.y + rand(i),baseAmplitude / pow(1.95,i) ,baseFrecuqncy * pow(1.95,i));\n        t +=  tWave( coord.x +yC*10.+ rand(i),baseAmplitude / pow(1.95,i) ,baseFrecuqncy * pow(1.95,i));\n        stripes +=tWave( coord.x *yC*10.+ rand(i),baseAmplitude / pow(1.95,i) ,baseFrecuqncy * pow(1.95,i));\n    }\n    \n    float d = (fract(coord.x*1.)-0.5)/0.5;\n    float f  = 1. -smoothstep(t, t+ 0.05, abs(d));\n   \n    float f1 = 1. -smoothstep(stripes, stripes+ 0.05, abs((fract(coord.x*1.)-0.5)/0.5));\n    \n          f  *= 1.-step(t-0.5, coord.y);\n    vec3  c  = mix(BushesBase, BushesSecond, coord.y);\n       color = mix(color,  c, mix(f, f*f1, step(0.,d)));\n    \n}\n\n// =============================================================\n// MAIN --------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---------------------------------------------------------\n    // ---COORDINATE SETUP\n    \n    vec2  uvCoordinate    =  fragCoord/iResolution.xy;\n    float aCorreection    =  iResolution.x/iResolution.y;\n    \n          uvCoordinate.x *=  aCorreection;\n    \t \n    // ---------------------------------------------------------\n\n    vec3 col = vec3(0.,0.,0.);\n\n    \n    sky(std);\n    mountain(std, mountainOne  );\n    mountain(std, mountainTwo  );\n    mountain(std, mountainThree);\n    mountain(std, mountainFour );\n    \n    Pols(std);\n    Bushes(std);\n    \n    //day night stuff\n    //col = mix(PoltColorBase, col, vec3(sin(iTime*0.1),sin(iTime*0.1+0.12),sin(iTime*0.1+0.1)));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1153, 1212, 1235, 1235, 1277], [1280, 1399, 1454, 1454, 1518], [1520, 1520, 1562, 1562, 1619], [1623, 1623, 1823, 1823, 2571], [2573, 2573, 2616, 2616, 2826], [2828, 2828, 2873, 2873, 3746], [3748, 3880, 3937, 4029, 4674]], "test": "untested"}
{"id": "WsyXRd", "name": "2D Islands", "author": "jlagarespo", "description": "Some nice islands (just a test, kinda ugly but ok)", "tags": ["islands"], "likes": 2, "viewed": 69, "published": "Public", "date": "1574695485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n   \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat remap(float low1, float high1, float low2, float high2, float value) {\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = iMouse.xy / 50.0;\n    float z = 10.0 * texelFetch(iChannel0, ivec2(38, 2), 0).x + 5.0;\n    vec2 uv = fragCoord / iResolution.xy * z + pos;\n    vec4 grass = vec4(0.2, 0.8, 0.2, 1) * (-fbm(uv) + 1.0) + fbm(uv.yx + iTime / 3.0) / 5.0;\n    vec4 ocean = vec4(0, 0.3, 1.0, 1) * (-fbm(uv) + 1.75);\n    vec4 sand = vec4(0.929, 0.788, 0.68, 1);\n    vec4 stone = vec4(0.75, 0.75, 0.75, 1) * (-fbm(uv) + 1.25);\n    vec4 fire = vec4(1.0, 0.5, 0.0, 1);\n    float f = fbm(uv);\n   \n    if (f < 0.4) {\n        if (f > 0.37) {\n            fragColor = mix(sand, ocean, remap(0.38, 0.4, 0.0, 1.0, f));\n        } else {\n            float f2 = fbm(vec2(uv.yx + 1.0)) / 2.25;\n            fragColor = mix(grass, sand, remap(0.25, 0.38, 0.0, 1.0, f - 0.06));\n            \n            // Bad slope detector\n            if (f < f2) {\n            \tfragColor = stone;\n            } else {\n\t\t\t\t// Wildfires\n                /*\n                if (f2 > 0.5) {\n                    float fireAmount = 1.0 - f;\n    \t\t\t\tfireAmount = clamp((-fireAmount + 1.7) * 3.0 - 2.25, 0.0, 1.0);\n                \tfragColor = mix(fragColor, fire, fireAmount);\n\t\t\t\t}\n\t\t\t\t*/\n            }\n        }\n    } else {\n        fragColor = ocean;\n    }\n    \n    // Clouds\n    float clouds = sin(fbm(uv.yx + (iTime / 4.0) / 5.0 + 1000.0 + sin(fbm(uv * -iTime / 100.0))));\n    clouds = clamp((-clouds + 1.7) * 3.0 - 4.4, 0.0, 1.0);\n    fragColor = mix(fragColor, vec4(1.0, 1.0, 1.0, 1.0), clouds / 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 101], [103, 103, 129, 129, 476], [496, 496, 520, 520, 744], [746, 746, 822, 822, 889], [891, 891, 946, 946, 2407]], "test": "untested"}
{"id": "wsyXW3", "name": "BW lines sketch 2", "author": "rrrzzz", "description": "blank", "tags": ["simple", "trigonometriccurve"], "likes": 3, "viewed": 81, "published": "Public", "date": "1575138672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 6.28318530718\n\n//rotate, make lines of varied form, create a silhouette when there are lots of lines\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\t\n\tvec3 pixel = vec3(0.0);\n    \n//\tfloat y = cos(mod(10.*iTime, 100.)*TWOPI*p.y); \n    float value = p.y  + cos(TWOPI*p.y) * p.x;\n\tfloat y = cos(mod(iTime*100., 10000.)*TWOPI*value + iTime*20.); \n\t                            \n\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\t\n\tpixel = vec3(y); \n\tfragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 116, 173, 173, 614]], "test": "untested"}
{"id": "WsyXWW", "name": "Artificial Heart", "author": "anazli9", "description": "Experimenting with theBookOfShaders code.", "tags": ["glsl", "general"], "likes": 1, "viewed": 48, "published": "Public", "date": "1573995393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(0.5) - uv;\n    float r = length(uv) * 2.;\n    float theta = atan(uv.y, uv.x);\n    float t = iTime * iTime/2.;\n    float f = smoothstep(-0.5, 1., cos(theta*10.)) * abs(cos(t/150.)) + 0.5;\n    float rnd = rand(uv);\n    vec3 rc = rnd * vec3( abs( sin(t * rnd) ),\n                            abs( cos(t) ),\n                            abs( cos(t * rnd + PI/2.) ) );\n    \n    vec3 col = vec3(1. - smoothstep(f, f + abs(sin(t))*2./3., r)) * rc;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 41, 41, 113], [115, 115, 172, 222, 773]], "test": "untested"}
{"id": "wsyXWz", "name": "iHaveNoIdeaWhatIAmDoing", "author": "Venay", "description": "iHaveNoIdeaWhatIAmDoing", "tags": ["ihavenoideawhatiamdoing"], "likes": 3, "viewed": 196, "published": "Public API", "date": "1573765187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv.y += sin(uv.x*3.14*5.+iTime)*.1;\n    uv.x += sin(uv.y*3.14*5.+iTime)*.1;\n    \n    float t = sin(iTime)/2.+.5;\n    float d = length(uv)*13.;\n    d= fract( mod(d,uv.x*uv.y*iTime) );\n    d = step(t,d);\n\n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 355]], "test": "untested"}
{"id": "WsyXzm", "name": "bubbles-psychedelia", "author": "xdegtyarev", "description": "bubbles", "tags": ["psychedelia"], "likes": 2, "viewed": 102, "published": "Public", "date": "1573601676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy * vec2(4,2) + vec2(-2,1.1);\n    float pi = 3.1415,\n   \t\t  time = iTime * 0.1,\n          t = time*pi,\n    \t  d = length(uv)-.3;\n   \t\n    uv *= mat2( cos(t), -sin(t)*(d)*0.5, sin(t), cos(t));\n    \n    \n  \tfloat  timeWobble = cos(t+d)*.1*d,\n           tt = fract(sin(t))*0.01,\n           v = 0.;\n    \n    for(float j = 0.; j<24.; j+=.5){\n        float q = j==0.? tt+.25 : 1.;\n        for(float i = 0.; i<6.28; i+=pi/16.){\n            vec2 u = uv+vec2(sin(i), cos(i))*(j-timeWobble+tt-0.25)*q;\n            v += smoothstep(.00, .1*(sin(t)*(1.0-d)*time*0.1), \n                            length(u*2.0)-(smoothstep(0., 0.4,j+tt)+timeWobble*1.0)* q*2.);\n        }\n    }\n    O = 0.5 + 0.5* cos(  pi * .5 * ( mod(v, 5. ) + sin(vec4(10,5,-10,0)*t) )  );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 818]], "test": "untested"}
{"id": "wsyXzz", "name": "blue spheres and stuff", "author": "cmarangu", "description": "[url]https://www.youtube.com/watch?v=7pucdUfDhPc[/url]", "tags": ["wip"], "likes": 4, "viewed": 143, "published": "Public", "date": "1573531820", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// /*\n// Current code for: blue spheres and stuff\n// Tags: 3d\n// Created: 2019 11/13\n// moved over from: https://www.shadertoy.com/view/tsGXzw\n// Description: slight modifications of my \"recursive reflections!\" https://www.shadertoy.com/view/wsyXzz\n\n// i know more\nconst float PI = 3.141592653589793238;\n\nconst vec3 suncol = vec3(1., 1., 1.);\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat SDFplane (vec3 p) {\n\treturn p.y+2.+sin((p.x+p.z+iTime)*PI*2./4.)/4.;\n}\n\nfloat SDFsphere (vec3 p) {\n    float PH = 6.;\n    p = vec3(mod(p.x, 10.)-5., p.y+sin(floor(p.x/10.)*2.+iTime/4.*PI*2.), mod(p.z, PH*2.)-PH);\n    float SDFp = length(p)-2.;\n    return SDFp;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = 1e20;\n    SDFp = min(SDFp, SDFplane(p));\n    SDFp = min(SDFp, SDFsphere(p));\n    return SDFp;\n}\n\nvec3 dSDF (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nfloat idSDF (vec3 p) {\n    float SDFspherep = SDFsphere(p);\n    float SDFplanep = SDFplane(p);\n    if (SDFspherep < SDFplanep) {\n        return 1.;\n    }\n\treturn 0.;\n}\n\nfloat rxindex (vec3 p) {\n    float idSDFp = idSDF(p);\n    if (idSDFp == 0.) {\n        return (.5+.5*sin((p.x-p.z)*PI/6.))*1.+0.;\n    }\n    if (idSDFp == 1.) {\n        return .3;\n    }\n}\n\nvec3 sund () {\n    return normalize(vec3(cos(iTime*PI*2./4.), 1., sin(iTime*PI*2./4.) ));\n}\n\nvec3 TEX (vec3 p, vec3 d) {\n    vec3 col = vec3(1., 0., 0.);\n    vec3 dSDFp = dSDF(p);\n    float idSDFp = idSDF(p);\n    float czk = mod(floor(p.x)+floor(p.y)+floor(p.z), 2.);\n    if (idSDFp == 0.) {\n        czk = mod(floor(p.x)+floor(p.z), 2.);\n    \t// czk = .5+.3*czk;\n        col = vec3(0., .7, .7)*czk;\n    }\n    if (idSDFp == 1.) {\n        czk = 1.;\n        col = vec3(0., .7, .7)*czk;\n    }\n    vec3 lighting = vec3(1., 1., 1.);\n    // diffuse lighting\n    float ang = clamp(dot(sund(), dSDFp)/2.+1., 0., 1.);\n    ang = (dot(sund(), dSDFp)+1.)/2.;\n    // ang = clamp(dot(sund(), dSDFp), 0., 1.);\n   \tlighting = lighting*ang;\n    // ambient lighting\n    lighting = .3+lighting*.7;\n    // u cant have red light from a blue sun\n    col = hadamard(col, hadamard(lighting, suncol));\n    return col;\n}\n\nvec3 bg (vec3 d) {\n    vec3 col = vec3(0., 0., 100./255.);\n    col += suncol*pow( clamp(dot(sund(), d), 0., 1.),40. );\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float rxcount = 0.;\n    float shiny = 1.;\n    vec3 finalcol = vec3(0., 0., 0.);\n    float distfromcam = 0.;\n    for (int i=0; i<200; ++i) {\n        float SDFp = SDF(p);\n        if (SDFp < 1e-2) {\n            p = p+d*SDFp*.995;\n            vec3 TEXpd = TEX(p, d);\n            float rxindexp = rxindex(p);\n            if (rxindexp == 0. || rxcount > 4.) {\n                // hits solid object, final color determined\n                finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n                return finalcol;\n            }\n            if (rxcount > 3.) {\n                // waaaay to many reflections reflect background col\n                break;\n            }\n            finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n            shiny = shiny*rxindexp;\n            d = reflect(d, dSDF(p));\n            p = p+d*.02;\n            ++rxcount;\n        }\n        float DE = SDFp;\n        if (0. < DE && DE < 10.) {\n            DE *= .7;\n        }\n        p = p+d*DE;\n        distfromcam += DE;\n        if (distfromcam > 155.) {\n            break;\n        }\n    }\n    // diverges waaaay out into the sky. reflect sky color\n    if (rxcount > 0.) {\n        return finalcol+bg(d)*shiny;\n    }\n    return bg(d);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) { maus.x = iResolution.x/2.; }\n    if (maus.y == 0.) { maus.y = iResolution.y/2.; }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -PI/4., PI/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    float PI = PI;\n    vec3 retina = march(vec3(cos(iTime/4.*PI*2./2.)*3.-5., 0., -7.+mod(iTime, 4.)/4.*2.*6.), dir1);\n    fragColor = vec4(retina, 1.);\n}\n\n/*\n// Old code for: \"recursive reflections!\"\n// Tags: raymarching, recursive, reflections\n// Created: 2019 11/12\n// Description: Wow that looks awesome. I accomplished\n// what I was trying to do (recursive reflections where\n// you do cuurentColor*.7+reflectedStuff*.3 etc.) but as it\n// turns out, what I was trying to code wasn't the effect I\n// wanted to create; *tinted* reflectios like gold.\nconst vec3 suncol = vec3(1., 1., 1.);\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat SDFplane (vec3 p) {\n\treturn p.y+2.;\n}\n\nfloat SDFsphere (vec3 p) {\n    float PH = 6.;\n    p = vec3(mod(p.x, 10.)-5., p.y, mod(p.z, PH*2.)-PH);\n    float SDFp = length(p)-2.;\n    return SDFp;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = 1e20;\n    SDFp = min(SDFp, SDFplane(p));\n    SDFp = min(SDFp, SDFsphere(p));\n    return SDFp;\n}\n\nvec3 dSDF (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nfloat idSDF (vec3 p) {\n    float SDFspherep = SDFsphere(p);\n    float SDFplanep = SDFplane(p);\n    if (SDFspherep < SDFplanep) {\n        return 1.;\n    }\n\treturn 0.;\n}\n\nfloat rxindex (vec3 p) {\n    float idSDFp = idSDF(p);\n    if (idSDFp == 0.) {\n        return .5+.5*sin((p.x+p.z)*3.141592/6.);\n    }\n    if (idSDFp == 1.) {\n        return .3;\n    }\n}\n\nvec3 sund () {\n    return normalize(vec3(cos(iTime), 1., sin(iTime) ));\n}\n\nvec3 TEX (vec3 p, vec3 d) {\n    vec3 col = vec3(1., 0., 0.);\n    vec3 dSDFp = dSDF(p);\n    float idSDFp = idSDF(p);\n    float czk = mod(floor(p.x)+floor(p.y)+floor(p.z), 2.);\n    if (idSDFp == 0.) {\n        col = vec3(0., .7, .7)*czk;\n    }\n    if (idSDFp == 1.) {\n        col = vec3(0., .7, .7)*czk;\n    }\n    vec3 lighting = vec3(1., 1., 1.);\n    // diffuse lighting\n    float ang = clamp(dot(sund(), dSDFp)/2.+1., 0., 1.);\n    ang = (dot(sund(), dSDFp)+1.)/2.;\n    // ang = clamp(dot(sund(), dSDFp), 0., 1.);\n   \tlighting = lighting*ang;\n    // ambient lighting\n    lighting = .3+lighting*.7;\n    // u cant have red light from a blue sun\n    col = hadamard(col, hadamard(lighting, suncol));\n    return col;\n}\n\nvec3 bg (vec3 d) {\n    vec3 col = vec3(0., 0., 100./255.);\n    col += suncol*pow( clamp(dot(sund(), d), 0., 1.),40. );\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float rxcount = 0.;\n    float shiny = 1.;\n    vec3 finalcol = vec3(0., 0., 0.);\n    for (int i=0; i<100; ++i) {\n        float SDFp = SDF(p);\n        if (SDFp < 1e-3) {\n            p = p+d*SDFp*.995;\n            vec3 TEXpd = TEX(p, d);\n            float rxindexp = rxindex(p);\n            if (rxindexp == 0. || rxcount > 4.) {\n                // hits solid object, final color determined\n                finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n                return finalcol;\n            }\n            if (rxcount > 3.) {\n                // waaaay to many reflections reflect background col\n                break;\n            }\n            finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n            shiny = shiny*rxindexp;\n            d = reflect(d, dSDF(p));\n            p = p+d*.02;\n            ++rxcount;\n        }\n        float DE = SDFp;\n        if (0. < DE && DE < 50.) {\n            DE *= .7;\n        }\n        p = p+d*DE;\n    }\n    // diverges waaaay out into the sky. reflect sky color\n    if (rxcount > 0.) {\n        return finalcol+bg(d)*shiny;\n    }\n    return bg(d);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) { maus.x = iResolution.x/2.; }\n    if (maus.y == 0.) { maus.y = iResolution.y/2.; }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -3.14/4., 3.14/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    float PI = 3.141592;\n    vec3 retina = march(vec3(cos(iTime/4.*3.141592*2./2.)*3.-5., 0., -7.+mod(iTime, 4.)/4.*2.*6.), dir1);\n    fragColor = vec4(retina, 1.);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 344, 376, 376, 422], [424, 424, 449, 449, 500], [502, 502, 528, 528, 692], [694, 694, 714, 714, 827], [829, 829, 849, 849, 1072], [1074, 1074, 1096, 1096, 1241], [1243, 1243, 1267, 1267, 1428], [1430, 1430, 1444, 1444, 1521], [1523, 1523, 1550, 1550, 2323], [2325, 2325, 2343, 2343, 2491], [2493, 2493, 2522, 2522, 3733], [3735, 3735, 3791, 3791, 4749]], "test": "untested"}
